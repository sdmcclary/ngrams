{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.net.InetSocketAddress; import java.net.URL; import java.util.ArrayList; import java.util.List;  public final class AddrUtil { private AddrUtil() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.List;  public final class ArrayModNodeLocator implements NodeLocator { private final HashAlgorithm hashAlg; private MemcachedNode[] nodes;  public ArrayModNodeLocator(List<MemcachedNode> n, HashAlgorithm alg) { super(); nodes = n.toArray(new MemcachedNode[n.size()]); hashAlg = alg; } private ArrayModNodeLocator(MemcachedNode[] n, HashAlgorithm alg) { super(); nodes = n; hashAlg = alg; } public Collection<MemcachedNode> getAll() { return Arrays.asList(nodes); } public MemcachedNode getPrimary(String k) { return nodes[getServerForKey(k)]; } public Iterator<MemcachedNode> getSequence(String k) { return new NodeIterator(getServerForKey(k)); } public NodeLocator getReadonlyCopy() { MemcachedNode[] n = new MemcachedNode[nodes.length]; for (int i = 0; i < nodes.length; i++) { n[i] = new MemcachedNodeROImpl(nodes[i]); } return new ArrayModNodeLocator(n, hashAlg); } @Override public void updateLocator(List<MemcachedNode> newNodes) { this.nodes = newNodes.toArray(new MemcachedNode[newNodes.size()]); } private int getServerForKey(String key) { int rv = (int) (hashAlg.hash(key) % nodes.length); assert rv >= 0 : \"Returned negative key for key \" + key; assert rv < nodes.length : \"Invalid server number \" + rv + \" for key \" + key; return rv; } class NodeIterator implements Iterator<MemcachedNode> { private final int start; private int next = 0; public NodeIterator(int keyStart) { start = keyStart; next = start; computeNext(); assert next >= 0 || nodes.length == 1 : \"Starting sequence at \" + start + \" of \" + nodes.length + \" next is \" + next; } public boolean hasNext() { return next >= 0; } private void computeNext() { if (++next >= nodes.length) { next = 0; } if (next == start) { next = -1; } } public MemcachedNode next() { try { return nodes[next]; } finally { computeNext(); } } public void remove() { throw new UnsupportedOperationException(\"Can't remove a node\"); } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.Collection; import java.util.Collections; import java.util.Map; import java.util.Set; import net.spy.memcached.transcoders.Transcoder;  public class BaseCacheMap<V> implements Map<String, V> { private final String keyPrefix; private final Transcoder<V> transcoder; private final MemcachedClientIF client; private final int exp;  public BaseCacheMap(MemcachedClientIF c, int expiration, String prefix, Transcoder<V> t) { super(); keyPrefix = prefix; transcoder = t; client = c; exp = expiration; } public void clear() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.net.SocketAddress; import java.nio.channels.SocketChannel; import net.spy.memcached.protocol.binary.BinaryMemcachedNodeImpl; import net.spy.memcached.protocol.binary.BinaryOperationFactory;  public class BinaryConnectionFactory extends DefaultConnectionFactory {  public BinaryConnectionFactory() { super(); }  public BinaryConnectionFactory(int len, int bufSize) { super(len, bufSize); }  public BinaryConnectionFactory(int len, int bufSize, HashAlgorithm hash) { super(len, bufSize, hash); } @Override public MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c, int bufSize) { boolean doAuth = false; if (getAuthDescriptor() != null) { doAuth = true; } return new BinaryMemcachedNodeImpl(sa, c, bufSize, createReadOperationQueue(), createWriteOperationQueue(), createOperationQueue(), getOpQueueMaxBlockTime(), doAuth, getOperationTimeout(), getAuthWaitTime(), this); } @Override public OperationFactory getOperationFactory() { return new BinaryOperationFactory(); } @Override protected String getName() { return \"BinaryConnectionFactory\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.concurrent.CountDownLatch; import net.spy.memcached.ops.Operation;  public interface BroadcastOpFactory {  Operation newOp(MemcachedNode n, CountDownLatch latch); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public interface CASMutation<T> {  T getNewValue(T current); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.transcoders.Transcoder; /** * Object that provides mutation via CAS over a given memcache client. * * <p> * Example usage (reinventing incr): * </p> * * <pre> * "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public enum CASResponse {  OK,  NOT_FOUND,  EXISTS,  OBSERVE_ERROR_IN_ARGS,  OBSERVE_MODIFIED,  OBSERVE_TIMEOUT; }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public class CASValue<T> { private final long cas; private final T value;  public CASValue(long c, T v) { super(); cas = c; value = v; }  public long getCas() { return cas; }  public T getValue() { return value; } @Override public String toString() { return \"{CasValue \" + cas + \"/\" + value + \"}\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public class CacheMap extends BaseCacheMap<Object> {  public CacheMap(MemcachedClientIF c, int expiration, String prefix) { super(c, expiration, prefix, c.getTranscoder()); }  public CacheMap(MemcachedClientIF c, String prefix) { this(c, 0, prefix); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.Arrays;  public final class CachedData {   public static final int MAX_SIZE = 20 * 1024 * 1024; private final int flags; private final byte[] data;  public CachedData(int f, byte[] d, int maxSize) { super(); if (d.length > maxSize) { throw new IllegalArgumentException(\"Cannot cache data larger than \" + maxSize + \" bytes (you tried to cache a \" + d.length + \" byte object)\"); } flags = f; data = d; }  public byte[] getData() { return data; }  public int getFlags() { return flags; } @Override public String toString() { return \"{CachedData flags=\" + flags + \" data=\" + Arrays.toString(data) + \"}\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.io.IOException; import java.net.InetSocketAddress; import java.net.SocketAddress; import java.nio.channels.SocketChannel; import java.util.Collection; import java.util.List; import java.util.concurrent.BlockingQueue; import java.util.concurrent.ExecutorService; import net.spy.memcached.auth.AuthDescriptor; import net.spy.memcached.metrics.MetricCollector; import net.spy.memcached.metrics.MetricType; import net.spy.memcached.ops.Operation; import net.spy.memcached.transcoders.Transcoder;  public interface ConnectionFactory {  MemcachedConnection createConnection(List<InetSocketAddress> addrs) throws IOException;  MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c, int bufSize);  BlockingQueue<Operation> createOperationQueue();  BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  long getOpQueueMaxBlockTime();  ExecutorService getListenerExecutorService();  boolean isDefaultExecutorService();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  boolean getKeepAlive();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector();  long getAuthWaitTime(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.concurrent.BlockingQueue; import java.util.concurrent.ExecutorService; import net.spy.memcached.auth.AuthDescriptor; import net.spy.memcached.metrics.MetricCollector; import net.spy.memcached.metrics.MetricType; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationQueueFactory; import net.spy.memcached.protocol.ascii.AsciiOperationFactory; import net.spy.memcached.protocol.binary.BinaryOperationFactory; import net.spy.memcached.transcoders.Transcoder;  public class ConnectionFactoryBuilder { protected OperationQueueFactory opQueueFactory; protected OperationQueueFactory readQueueFactory; protected OperationQueueFactory writeQueueFactory; protected Transcoder<Object> transcoder; protected FailureMode failureMode; protected Collection<ConnectionObserver> initialObservers = Collections.emptyList(); protected OperationFactory opFact; protected Locator locator = Locator.ARRAY_MOD; protected long opTimeout = -1; protected boolean isDaemon = false; protected boolean shouldOptimize = false; protected boolean useNagle = false; protected boolean keepAlive = false; protected long maxReconnectDelay = DefaultConnectionFactory.DEFAULT_MAX_RECONNECT_DELAY; protected int readBufSize = -1; protected HashAlgorithm hashAlg; protected AuthDescriptor authDescriptor = null; protected long opQueueMaxBlockTime = -1; protected int timeoutExceptionThreshold = DefaultConnectionFactory.DEFAULT_MAX_TIMEOUTEXCEPTION_THRESHOLD; protected MetricType metricType = null; protected MetricCollector collector = null; protected ExecutorService executorService = null; protected long authWaitTime = DefaultConnectionFactory.DEFAULT_AUTH_WAIT_TIME;  public ConnectionFactoryBuilder() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.net.SocketAddress;  public interface ConnectionObserver {  void connectionEstablished(SocketAddress sa, int reconnectCount);  void connectionLost(SocketAddress sa); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.io.IOException; import java.net.InetSocketAddress; import java.net.SocketAddress; import java.nio.channels.SocketChannel; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.SynchronousQueue; import java.util.concurrent.ThreadFactory; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import net.spy.memcached.auth.AuthDescriptor; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.metrics.DefaultMetricCollector; import net.spy.memcached.metrics.MetricCollector; import net.spy.memcached.metrics.MetricType; import net.spy.memcached.metrics.NoopMetricCollector; import net.spy.memcached.ops.Operation; import net.spy.memcached.protocol.ascii.AsciiMemcachedNodeImpl; import net.spy.memcached.protocol.ascii.AsciiOperationFactory; import net.spy.memcached.protocol.binary.BinaryMemcachedNodeImpl; import net.spy.memcached.protocol.binary.BinaryOperationFactory; import net.spy.memcached.transcoders.SerializingTranscoder; import net.spy.memcached.transcoders.Transcoder;  public class DefaultConnectionFactory extends SpyObject implements ConnectionFactory {  public static final FailureMode DEFAULT_FAILURE_MODE = FailureMode.Redistribute;  public static final HashAlgorithm DEFAULT_HASH = DefaultHashAlgorithm.NATIVE_HASH;  public static final int DEFAULT_OP_QUEUE_LEN = 16384;  public static final long DEFAULT_OP_QUEUE_MAX_BLOCK_TIME = TimeUnit.SECONDS.toMillis(10);  public static final int DEFAULT_READ_BUFFER_SIZE = 16384;  public static final long DEFAULT_OPERATION_TIMEOUT = 2500;  public static final long DEFAULT_MAX_RECONNECT_DELAY = 30;  public static final int DEFAULT_MAX_TIMEOUTEXCEPTION_THRESHOLD = 998;  public static final MetricType DEFAULT_METRIC_TYPE = MetricType.OFF;  public static final long DEFAULT_AUTH_WAIT_TIME = 1000; protected final int opQueueLen; private final int readBufSize; private final HashAlgorithm hashAlg; private MetricCollector metrics;  private ExecutorService executorService;  public DefaultConnectionFactory(int qLen, int bufSize, HashAlgorithm hash) { super(); opQueueLen = qLen; readBufSize = bufSize; hashAlg = hash; metrics = null; }  public DefaultConnectionFactory(int qLen, int bufSize) { this(qLen, bufSize, DEFAULT_HASH); }  public DefaultConnectionFactory() { this(DEFAULT_OP_QUEUE_LEN, DEFAULT_READ_BUFFER_SIZE); } public MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c, int bufSize) { OperationFactory of = getOperationFactory(); if (of instanceof AsciiOperationFactory) { return new AsciiMemcachedNodeImpl(sa, c, bufSize, createReadOperationQueue(), createWriteOperationQueue(), createOperationQueue(), getOpQueueMaxBlockTime(), getOperationTimeout(), getAuthWaitTime(), this); } else if (of instanceof BinaryOperationFactory) { boolean doAuth = false; if (getAuthDescriptor() != null) { doAuth = true; } return new BinaryMemcachedNodeImpl(sa, c, bufSize, createReadOperationQueue(), createWriteOperationQueue(), createOperationQueue(), getOpQueueMaxBlockTime(), doAuth, getOperationTimeout(), getAuthWaitTime(), this); } else { throw new IllegalStateException(\"Unhandled operation factory type \" + of); } }  public MemcachedConnection createConnection(List<InetSocketAddress> addrs) throws IOException { return new MemcachedConnection(getReadBufSize(), this, addrs, getInitialObservers(), getFailureMode(), getOperationFactory()); }  public FailureMode getFailureMode() { return DEFAULT_FAILURE_MODE; }  public BlockingQueue<Operation> createOperationQueue() { return new ArrayBlockingQueue<Operation>(getOpQueueLen()); }  public BlockingQueue<Operation> createReadOperationQueue() { return new LinkedBlockingQueue<Operation>(); }  public BlockingQueue<Operation> createWriteOperationQueue() { return new LinkedBlockingQueue<Operation>(); }  public NodeLocator createLocator(List<MemcachedNode> nodes) { return new ArrayModNodeLocator(nodes, getHashAlg()); }  public int getOpQueueLen() { return opQueueLen; }  public long getOpQueueMaxBlockTime() { return DEFAULT_OP_QUEUE_MAX_BLOCK_TIME; }  @Override public long getAuthWaitTime() { return DEFAULT_AUTH_WAIT_TIME; }  @Override public ExecutorService getListenerExecutorService() { if (executorService == null) { ThreadFactory threadFactory = new ThreadFactory() { @Override public Thread newThread(Runnable r) { return new Thread(r, \"FutureNotifyListener\"); } }; executorService = new ThreadPoolExecutor( 0, Runtime.getRuntime().availableProcessors(), 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), threadFactory ); } return executorService; } @Override public boolean isDefaultExecutorService() { return true; }  public int getReadBufSize() { return readBufSize; }  public HashAlgorithm getHashAlg() { return hashAlg; }  public OperationFactory getOperationFactory() { return new AsciiOperationFactory(); }  public long getOperationTimeout() { return DEFAULT_OPERATION_TIMEOUT; }  public boolean isDaemon() { return false; }  public Collection<ConnectionObserver> getInitialObservers() { return Collections.emptyList(); }  public Transcoder<Object> getDefaultTranscoder() { return new SerializingTranscoder(); }  public boolean useNagleAlgorithm() { return false; }  public boolean getKeepAlive() { return false; }  public boolean shouldOptimize() { return false; }  public long getMaxReconnectDelay() { return DEFAULT_MAX_RECONNECT_DELAY; }  public AuthDescriptor getAuthDescriptor() { return null; }  public int getTimeoutExceptionThreshold() { return DEFAULT_MAX_TIMEOUTEXCEPTION_THRESHOLD; } @Override public MetricType enableMetrics() { String metricType = System.getProperty(\"net.spy.metrics.type\"); return metricType == null ? DEFAULT_METRIC_TYPE : MetricType.valueOf(metricType.toUpperCase()); } @Override public MetricCollector getMetricCollector() { if (metrics != null) { return metrics; } String enableMetrics = System.getProperty(\"net.spy.metrics.enable\"); if (enableMetrics().equals(MetricType.OFF) || enableMetrics == \"false\") { getLogger().debug(\"Metric collection disabled.\"); metrics = new NoopMetricCollector(); } else { getLogger().info(\"Metric collection enabled (Profile \" + enableMetrics() + \").\"); metrics = new DefaultMetricCollector(); } return metrics; } protected String getName() { return \"DefaultConnectionFactory\"; } @Override public String toString() { return \"Failure Mode: \" + getFailureMode().name() + \", Hash Algorithm: \" + ((DefaultHashAlgorithm)getHashAlg()).name() + \" Max Reconnect Delay: \" + getMaxReconnectDelay() + \", Max Op Timeout: \" + getOperationTimeout() + \", Op Queue Length: \" + getOpQueueLen() + \", Op Max Queue Block Time\" + getOpQueueMaxBlockTime() + \", Max Timeout Exception Threshold: \" + getTimeoutExceptionThreshold() + \", Read Buffer Size: \" + getReadBufSize() + \", Transcoder: \" + getDefaultTranscoder() + \", Operation Factory: \" + getOperationFactory() + \" isDaemon: \" + isDaemon() + \", Optimized: \" + shouldOptimize() + \", Using Nagle: \" + useNagleAlgorithm() + \", ConnectionFactory: \" + getName(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.zip.CRC32;  public enum DefaultHashAlgorithm implements HashAlgorithm {  NATIVE_HASH,  CRC_HASH, /** * FNV hashes are designed to be fast while maintaining a low collision rate. * The FNV speed allows one to quickly hash lots of data while maintaining a * reasonable collision rate. * * @see <a href=\"http:"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public enum FailureMode {  Redistribute,  Retry,  Cancel }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public interface HashAlgorithm {  long hash(final String k); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.HashMap; import java.util.Map;  public final class HashAlgorithmRegistry { private HashAlgorithmRegistry() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.net.InetSocketAddress; import java.util.HashMap; import java.util.List; import java.util.Map; /** * ConnectionFactory instance that sets up a ketama compatible connection. * * <p> * This implementation piggy-backs on the functionality of the * <code>DefaultConnectionFactory</code> in terms of connections and queue * handling. Where it differs is that it uses both the <code> * KetamaNodeLocator</code> and the <code>HashAlgorithm.KETAMA_HASH</code> to * provide consistent node hashing. * </p> * * @see <a href=\"http:"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.Iterator; import java.util.SortedMap; import java.util.TreeMap; import net.spy.memcached.compat.SpyObject;  class KetamaIterator extends SpyObject implements Iterator<MemcachedNode> { private final String key; private long hashVal; private int remainingTries; private int numTries = 0; private final HashAlgorithm hashAlg; private final TreeMap<Long, MemcachedNode> ketamaNodes;  protected KetamaIterator(final String k, final int t, TreeMap<Long, MemcachedNode> ketamaNodes, final HashAlgorithm hashAlg) { super(); this.ketamaNodes = ketamaNodes; this.hashAlg = hashAlg; hashVal = hashAlg.hash(k); remainingTries = t; key = k; } private void nextHash() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.net.InetSocketAddress; import java.util.HashMap; import java.util.Map;  public class KetamaNodeKeyFormatter { public enum Format {  SPYMEMCACHED,  LIBMEMCACHED } private final Format format; public Format getFormat() { return format; } "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.util.DefaultKetamaNodeLocatorConfiguration; import net.spy.memcached.util.KetamaNodeLocatorConfiguration; import java.net.InetSocketAddress; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.SortedMap; import java.util.TreeMap; /** * This is an implementation of the Ketama consistent hash strategy from * last.fm. This implementation may not be compatible with libketama as hashing * is considered separate from node location. * * Note that this implementation does not currently supported weighted nodes. * * @see <a href=\"http:"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.io.UnsupportedEncodingException; import java.util.ArrayList; import java.util.Collection;  public final class KeyUtil { private KeyUtil() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import net.spy.memcached.auth.AuthDescriptor; import net.spy.memcached.auth.AuthThreadMonitor; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.internal.BulkFuture; import net.spy.memcached.internal.BulkGetFuture; import net.spy.memcached.internal.GetFuture; import net.spy.memcached.internal.OperationFuture; import net.spy.memcached.internal.SingleElementInfiniteIterator; import net.spy.memcached.ops.CASOperationStatus; import net.spy.memcached.ops.CancelledOperationStatus; import net.spy.memcached.ops.ConcatenationType; import net.spy.memcached.ops.DeleteOperation; import net.spy.memcached.ops.GetAndTouchOperation; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.GetsOperation; import net.spy.memcached.ops.Mutator; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatsOperation; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.ops.StoreType; import net.spy.memcached.ops.TimedOutOperationStatus; import net.spy.memcached.protocol.binary.BinaryOperationFactory; import net.spy.memcached.transcoders.TranscodeService; import net.spy.memcached.transcoders.Transcoder; import net.spy.memcached.util.StringUtils; import java.io.IOException; import java.net.InetSocketAddress; import java.net.SocketAddress; import java.text.MessageFormat; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.CancellationException; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; import java.util.concurrent.atomic.AtomicReference; /** * Client to a memcached server. * * <h2>Basic usage</h2> * * <pre> * MemcachedClient c = new MemcachedClient( * new InetSocketAddress(&quot;hostname&quot;, portNum)); * * "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import net.spy.memcached.internal.BulkFuture; import net.spy.memcached.internal.OperationFuture; import net.spy.memcached.transcoders.Transcoder; import java.net.SocketAddress; import java.util.Collection; import java.util.Iterator; import java.util.Map; import java.util.Set; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit;  public interface MemcachedClientIF {  int MAX_KEY_LENGTH = 250; Collection<SocketAddress> getAvailableServers(); Collection<SocketAddress> getUnavailableServers(); Transcoder<Object> getTranscoder(); NodeLocator getNodeLocator(); Future<Boolean> append(long cas, String key, Object val); Future<Boolean> append(String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); <T> Future<Boolean> append(String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); Future<Boolean> prepend(String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<Boolean> prepend(String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); Future<CASResponse> asyncCAS(String key, long casId, int exp, Object value); <T> OperationFuture<CASResponse> asyncCAS(String key, long casId, int exp, T value, Transcoder<T> tc); <T> CASResponse cas(String key, long casId, int exp, T value, Transcoder<T> tc); CASResponse cas(String key, long casId, Object value); CASResponse cas(String key, long casId, int exp, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc); <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by, long def, int exp); Future<Long> asyncIncr(String key, int by, long def, int exp); Future<Long> asyncDecr(String key, long by, long def, int exp); Future<Long> asyncDecr(String key, int by, long def, int exp); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Long> asyncIncr(String key, long by, long def); Future<Long> asyncIncr(String key, int by, long def); Future<Long> asyncDecr(String key, long by, long def); Future<Long> asyncDecr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import net.spy.memcached.compat.SpyThread; import net.spy.memcached.compat.log.Logger; import net.spy.memcached.compat.log.LoggerFactory; import net.spy.memcached.internal.OperationFuture; import net.spy.memcached.metrics.MetricCollector; import net.spy.memcached.metrics.MetricType; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.KeyedOperation; import net.spy.memcached.ops.NoopOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationException; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.ops.VBucketAware; import net.spy.memcached.protocol.binary.BinaryOperationFactory; import net.spy.memcached.protocol.binary.MultiGetOperationImpl; import net.spy.memcached.protocol.binary.TapAckOperationImpl; import net.spy.memcached.util.StringUtils; import java.io.IOException; import java.net.ConnectException; import java.net.InetSocketAddress; import java.net.Socket; import java.net.SocketAddress; import java.net.SocketException; import java.nio.ByteBuffer; import java.nio.channels.CancelledKeyException; import java.nio.channels.ClosedChannelException; import java.nio.channels.ClosedSelectorException; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.SocketChannel; import java.text.MessageFormat; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.IdentityHashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.SortedMap; import java.util.TreeMap; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.TimeUnit;  public class MemcachedConnection extends SpyThread {  private static final int DOUBLE_CHECK_EMPTY = 256;  private static final int EXCESSIVE_EMPTY = 0x1000000;  private static final int DEFAULT_WAKEUP_DELAY = 1000;  private static final int DEFAULT_RETRY_QUEUE_SIZE = -1;  private static final int MAX_CLONE_COUNT = 100; private static final String RECON_QUEUE_METRIC = \"[MEM] Reconnecting Nodes (ReconnectQueue)\"; private static final String SHUTD_QUEUE_METRIC = \"[MEM] Shutting Down Nodes (NodesToShutdown)\"; private static final String OVERALL_REQUEST_METRIC = \"[MEM] Request Rate: All\"; private static final String OVERALL_AVG_BYTES_WRITE_METRIC = \"[MEM] Average Bytes written to OS per write\"; private static final String OVERALL_AVG_BYTES_READ_METRIC = \"[MEM] Average Bytes read from OS per read\"; private static final String OVERALL_AVG_TIME_ON_WIRE_METRIC = \"[MEM] Average Time on wire for operations (\u00b5s)\"; private static final String OVERALL_RESPONSE_METRIC = \"[MEM] Response Rate: All (Failure + Success + Retry)\"; private static final String OVERALL_RESPONSE_RETRY_METRIC = \"[MEM] Response Rate: Retry\"; private static final String OVERALL_RESPONSE_FAIL_METRIC = \"[MEM] Response Rate: Failure\"; private static final String OVERALL_RESPONSE_SUCC_METRIC = \"[MEM] Response Rate: Success\";  protected volatile boolean shutDown = false;  private final boolean shouldOptimize;  protected Selector selector = null;  protected final NodeLocator locator;  protected final FailureMode failureMode;  private final long maxDelay;  private int emptySelects = 0;  private final int bufSize;  private final ConnectionFactory connectionFactory;  protected final ConcurrentLinkedQueue<MemcachedNode> addedQueue;  private final SortedMap<Long, MemcachedNode> reconnectQueue;  protected volatile boolean running = true;  private final Collection<ConnectionObserver> connObservers = new ConcurrentLinkedQueue<ConnectionObserver>();  private final OperationFactory opFact;  private final int timeoutExceptionThreshold;  private final List<Operation> retryOps;  protected final ConcurrentLinkedQueue<MemcachedNode> nodesToShutdown;  private final boolean verifyAliveOnConnect;  private final ExecutorService listenerExecutorService;  protected final MetricCollector metrics;  protected final MetricType metricType;  private final int wakeupDelay;  private final int retryQueueSize;  public MemcachedConnection(final int bufSize, final ConnectionFactory f, final List<InetSocketAddress> a, final Collection<ConnectionObserver> obs, final FailureMode fm, final OperationFactory opfactory) throws IOException { connObservers.addAll(obs); reconnectQueue = new TreeMap<Long, MemcachedNode>(); addedQueue = new ConcurrentLinkedQueue<MemcachedNode>(); failureMode = fm; shouldOptimize = f.shouldOptimize(); maxDelay = TimeUnit.SECONDS.toMillis(f.getMaxReconnectDelay()); opFact = opfactory; timeoutExceptionThreshold = f.getTimeoutExceptionThreshold(); selector = Selector.open(); retryOps = Collections.synchronizedList(new ArrayList<Operation>()); nodesToShutdown = new ConcurrentLinkedQueue<MemcachedNode>(); listenerExecutorService = f.getListenerExecutorService(); this.bufSize = bufSize; this.connectionFactory = f; String verifyAlive = System.getProperty(\"net.spy.verifyAliveOnConnect\"); if(verifyAlive != null && verifyAlive.equals(\"true\")) { verifyAliveOnConnect = true; } else { verifyAliveOnConnect = false; } wakeupDelay = Integer.parseInt( System.getProperty(\"net.spy.wakeupDelay\", Integer.toString(DEFAULT_WAKEUP_DELAY))); retryQueueSize = Integer.parseInt(System.getProperty(\"net.spy.retryQueueSize\", Integer.toString(DEFAULT_RETRY_QUEUE_SIZE))); getLogger().info(\"Setting retryQueueSize to \" + retryQueueSize); List<MemcachedNode> connections = createConnections(a); locator = f.createLocator(connections); metrics = f.getMetricCollector(); metricType = f.enableMetrics(); registerMetrics(); setName(\"Memcached IO over \" + this); setDaemon(f.isDaemon()); start(); }  protected void registerMetrics() { if (metricType.equals(MetricType.DEBUG) || metricType.equals(MetricType.PERFORMANCE)) { metrics.addHistogram(OVERALL_AVG_BYTES_READ_METRIC); metrics.addHistogram(OVERALL_AVG_BYTES_WRITE_METRIC); metrics.addHistogram(OVERALL_AVG_TIME_ON_WIRE_METRIC); metrics.addMeter(OVERALL_RESPONSE_METRIC); metrics.addMeter(OVERALL_REQUEST_METRIC); if (metricType.equals(MetricType.DEBUG)) { metrics.addCounter(RECON_QUEUE_METRIC); metrics.addCounter(SHUTD_QUEUE_METRIC); metrics.addMeter(OVERALL_RESPONSE_RETRY_METRIC); metrics.addMeter(OVERALL_RESPONSE_SUCC_METRIC); metrics.addMeter(OVERALL_RESPONSE_FAIL_METRIC); } } }  protected List<MemcachedNode> createConnections( final Collection<InetSocketAddress> addrs) throws IOException { List<MemcachedNode> connections = new ArrayList<MemcachedNode>(addrs.size()); for (SocketAddress sa : addrs) { SocketChannel ch = SocketChannel.open(); ch.configureBlocking(false); MemcachedNode qa = connectionFactory.createMemcachedNode(sa, ch, bufSize); qa.setConnection(this); int ops = 0; Socket socket = ch.socket(); socket.setTcpNoDelay(!connectionFactory.useNagleAlgorithm()); socket.setKeepAlive(connectionFactory.getKeepAlive()); try { if (ch.connect(sa)) { getLogger().info(\"Connected to %s immediately\", qa); connected(qa); } else { getLogger().info(\"Added %s to connect queue\", qa); ops = SelectionKey.OP_CONNECT; } selector.wakeup(); qa.setSk(ch.register(selector, ops, qa)); assert ch.isConnected() || qa.getSk().interestOps() == SelectionKey.OP_CONNECT : \"Not connected, and not wanting to connect\"; } catch (SocketException e) { getLogger().warn(\"Socket error on initial connect\", e); queueReconnect(qa); } connections.add(qa); } return connections; }  private boolean selectorsMakeSense() { for (MemcachedNode qa : locator.getAll()) { if (qa.getSk() != null && qa.getSk().isValid()) { if (qa.getChannel().isConnected()) { int sops = qa.getSk().interestOps(); int expected = 0; if (qa.hasReadOp()) { expected |= SelectionKey.OP_READ; } if (qa.hasWriteOp()) { expected |= SelectionKey.OP_WRITE; } if (qa.getBytesRemainingToWrite() > 0) { expected |= SelectionKey.OP_WRITE; } assert sops == expected : \"Invalid ops: \" + qa + \", expected \" + expected + \", got \" + sops; } else { int sops = qa.getSk().interestOps(); assert sops == SelectionKey.OP_CONNECT : \"Not connected, and not watching for connect: \" + sops; } } } getLogger().debug(\"Checked the selectors.\"); return true; }  public void handleIO() throws IOException { if (shutDown) { getLogger().debug(\"No IO while shut down.\"); return; } handleInputQueue(); getLogger().debug(\"Done dealing with queue.\"); long delay = wakeupDelay; if (!reconnectQueue.isEmpty()) { long now = System.currentTimeMillis(); long then = reconnectQueue.firstKey(); delay = Math.max(then - now, 1); } getLogger().debug(\"Selecting with delay of %sms\", delay); assert selectorsMakeSense() : \"Selectors don't make sense.\"; int selected = selector.select(delay); if (shutDown) { return; } else if (selected == 0 && addedQueue.isEmpty()) { handleWokenUpSelector(); } else if (selector.selectedKeys().isEmpty()) { handleEmptySelects(); } else { getLogger().debug(\"Selected %d, selected %d keys\", selected, selector.selectedKeys().size()); emptySelects = 0; Iterator<SelectionKey> iterator = selector.selectedKeys().iterator(); while(iterator.hasNext()) { SelectionKey sk = iterator.next(); handleIO(sk); iterator.remove(); } } handleOperationalTasks(); }  protected void handleWokenUpSelector() { }  private void handleOperationalTasks() throws IOException { checkPotentiallyTimedOutConnection(); if (!shutDown && !reconnectQueue.isEmpty()) { attemptReconnects(); } if (!retryOps.isEmpty()) { ArrayList<Operation> operations = new ArrayList<Operation>(retryOps); retryOps.clear(); redistributeOperations(operations); } handleShutdownQueue(); }  private void handleEmptySelects() { getLogger().debug(\"No selectors ready, interrupted: %b\", Thread.interrupted()); if (++emptySelects > DOUBLE_CHECK_EMPTY) { for (SelectionKey sk : selector.keys()) { getLogger().debug(\"%s has %s, interested in %s\", sk, sk.readyOps(), sk.interestOps()); if (sk.readyOps() != 0) { getLogger().debug(\"%s has a ready op, handling IO\", sk); handleIO(sk); } else { lostConnection((MemcachedNode) sk.attachment()); } } assert emptySelects < EXCESSIVE_EMPTY : \"Too many empty selects\"; } }  private void handleShutdownQueue() throws IOException { for (MemcachedNode qa : nodesToShutdown) { if (!addedQueue.contains(qa)) { nodesToShutdown.remove(qa); metrics.decrementCounter(SHUTD_QUEUE_METRIC); Collection<Operation> notCompletedOperations = qa.destroyInputQueue(); if (qa.getChannel() != null) { qa.getChannel().close(); qa.setSk(null); if (qa.getBytesRemainingToWrite() > 0) { getLogger().warn(\"Shut down with %d bytes remaining to write\", qa.getBytesRemainingToWrite()); } getLogger().debug(\"Shut down channel %s\", qa.getChannel()); } redistributeOperations(notCompletedOperations); } } }  private void checkPotentiallyTimedOutConnection() { boolean stillCheckingTimeouts = true; while (stillCheckingTimeouts) { try { for (SelectionKey sk : selector.keys()) { MemcachedNode mn = (MemcachedNode) sk.attachment(); if (mn.getContinuousTimeout() > timeoutExceptionThreshold) { getLogger().warn(\"%s exceeded continuous timeout threshold\", sk); lostConnection(mn); } } stillCheckingTimeouts = false; } catch(ConcurrentModificationException e) { getLogger().warn(\"Retrying selector keys after \" + \"ConcurrentModificationException caught\", e); continue; } } }  private void handleInputQueue() { if (!addedQueue.isEmpty()) { getLogger().debug(\"Handling queue\"); Collection<MemcachedNode> toAdd = new HashSet<MemcachedNode>(); Collection<MemcachedNode> todo = new HashSet<MemcachedNode>(); MemcachedNode qaNode; while ((qaNode = addedQueue.poll()) != null) { todo.add(qaNode); } for (MemcachedNode node : todo) { boolean readyForIO = false; if (node.isActive()) { if (node.getCurrentWriteOp() != null) { readyForIO = true; getLogger().debug(\"Handling queued write %s\", node); } } else { toAdd.add(node); } node.copyInputQueue(); if (readyForIO) { try { if (node.getWbuf().hasRemaining()) { handleWrites(node); } } catch (IOException e) { getLogger().warn(\"Exception handling write\", e); lostConnection(node); } } node.fixupOps(); } addedQueue.addAll(toAdd); } }  public boolean addObserver(final ConnectionObserver obs) { return connObservers.add(obs); }  public boolean removeObserver(final ConnectionObserver obs) { return connObservers.remove(obs); }  private void connected(final MemcachedNode node) { assert node.getChannel().isConnected() : \"Not connected.\"; int rt = node.getReconnectCount(); node.connected(); for (ConnectionObserver observer : connObservers) { observer.connectionEstablished(node.getSocketAddress(), rt); } }  private void lostConnection(final MemcachedNode node) { queueReconnect(node); for (ConnectionObserver observer : connObservers) { observer.connectionLost(node.getSocketAddress()); } }  boolean belongsToCluster(final MemcachedNode node) { for (MemcachedNode n : locator.getAll()) { if (n.getSocketAddress().equals(node.getSocketAddress())) { return true; } } return false; }  private void handleIO(final SelectionKey sk) { MemcachedNode node = (MemcachedNode) sk.attachment(); try { getLogger().debug(\"Handling IO for: %s (r=%s, w=%s, c=%s, op=%s)\", sk, sk.isReadable(), sk.isWritable(), sk.isConnectable(), sk.attachment()); if (sk.isConnectable() && belongsToCluster(node)) { getLogger().debug(\"Connection state changed for %s\", sk); final SocketChannel channel = node.getChannel(); if (channel.finishConnect()) { finishConnect(sk, node); } else { assert !channel.isConnected() : \"connected\"; } } else { handleReadsAndWrites(sk, node); } } catch (ClosedChannelException e) { if (!shutDown) { getLogger().info(\"Closed channel and not shutting down. Queueing\" + \" reconnect on %s\", node, e); lostConnection(node); } } catch (ConnectException e) { getLogger().info(\"Reconnecting due to failure to connect to %s\", node, e); queueReconnect(node); } catch (OperationException e) { node.setupForAuth(); getLogger().info(\"Reconnection due to exception handling a memcached \" + \"operation on %s. This may be due to an authentication failure.\", node, e); lostConnection(node); } catch (Exception e) { node.setupForAuth(); getLogger().info(\"Reconnecting due to exception on %s\", node, e); lostConnection(node); } node.fixupOps(); }  private void handleReadsAndWrites(final SelectionKey sk, final MemcachedNode node) throws IOException { if (sk.isValid() && sk.isReadable()) { handleReads(node); } if (sk.isValid() && sk.isWritable()) { handleWrites(node); } }  private void finishConnect(final SelectionKey sk, final MemcachedNode node) throws IOException { if (verifyAliveOnConnect) { final CountDownLatch latch = new CountDownLatch(1); final OperationFuture<Boolean> rv = new OperationFuture<Boolean>(\"noop\", latch, 2500, listenerExecutorService); NoopOperation testOp = opFact.noop(new OperationCallback() { public void receivedStatus(OperationStatus status) { rv.set(status.isSuccess(), status); } @Override public void complete() { latch.countDown(); } }); testOp.setHandlingNode(node); testOp.initialize(); checkState(); insertOperation(node, testOp); node.copyInputQueue(); boolean done = false; if (sk.isValid()) { long timeout = TimeUnit.MILLISECONDS.toNanos( connectionFactory.getOperationTimeout()); long stop = System.nanoTime() + timeout; while (stop > System.nanoTime()) { handleWrites(node); handleReads(node); if(done = (latch.getCount() == 0)) { break; } } } if (!done || testOp.isCancelled() || testOp.hasErrored() || testOp.isTimedOut()) { throw new ConnectException(\"Could not send noop upon connect! \" + \"This may indicate a running, but not responding memcached \" + \"instance.\"); } } connected(node); addedQueue.offer(node); if (node.getWbuf().hasRemaining()) { handleWrites(node); } }  private void handleWrites(final MemcachedNode node) throws IOException { node.fillWriteBuffer(shouldOptimize); boolean canWriteMore = node.getBytesRemainingToWrite() > 0; while (canWriteMore) { int wrote = node.writeSome(); metrics.updateHistogram(OVERALL_AVG_BYTES_WRITE_METRIC, wrote); node.fillWriteBuffer(shouldOptimize); canWriteMore = wrote > 0 && node.getBytesRemainingToWrite() > 0; } }  private void handleReads(final MemcachedNode node) throws IOException { Operation currentOp = node.getCurrentReadOp(); if (currentOp instanceof TapAckOperationImpl) { node.removeCurrentReadOp(); return; } ByteBuffer rbuf = node.getRbuf(); final SocketChannel channel = node.getChannel(); int read = channel.read(rbuf); metrics.updateHistogram(OVERALL_AVG_BYTES_READ_METRIC, read); if (read < 0) { currentOp = handleReadsWhenChannelEndOfStream(currentOp, node, rbuf); } while (read > 0) { getLogger().debug(\"Read %d bytes\", read); rbuf.flip(); while (rbuf.remaining() > 0) { if (currentOp == null) { throw new IllegalStateException(\"No read operation.\"); } long timeOnWire = System.nanoTime() - currentOp.getWriteCompleteTimestamp(); metrics.updateHistogram(OVERALL_AVG_TIME_ON_WIRE_METRIC, (int)(timeOnWire / 1000)); metrics.markMeter(OVERALL_RESPONSE_METRIC); synchronized(currentOp) { readBufferAndLogMetrics(currentOp, rbuf, node); } currentOp = node.getCurrentReadOp(); } rbuf.clear(); read = channel.read(rbuf); node.completedRead(); } }  private void readBufferAndLogMetrics(final Operation currentOp, final ByteBuffer rbuf, final MemcachedNode node) throws IOException { currentOp.readFromBuffer(rbuf); if (currentOp.getState() == OperationState.COMPLETE) { getLogger().debug(\"Completed read op: %s and giving the next %d \" + \"bytes\", currentOp, rbuf.remaining()); Operation op = node.removeCurrentReadOp(); assert op == currentOp : \"Expected to pop \" + currentOp + \" got \" + op; if (op.hasErrored()) { metrics.markMeter(OVERALL_RESPONSE_FAIL_METRIC); } else { metrics.markMeter(OVERALL_RESPONSE_SUCC_METRIC); } } else if (currentOp.getState() == OperationState.RETRY) { handleRetryInformation(currentOp.getErrorMsg()); getLogger().debug(\"Reschedule read op due to NOT_MY_VBUCKET error: \" + \"%s \", currentOp); ((VBucketAware) currentOp).addNotMyVbucketNode( currentOp.getHandlingNode()); Operation op = node.removeCurrentReadOp(); assert op == currentOp : \"Expected to pop \" + currentOp + \" got \" + op; retryOperation(currentOp); metrics.markMeter(OVERALL_RESPONSE_RETRY_METRIC); } }  private Operation handleReadsWhenChannelEndOfStream(final Operation currentOp, final MemcachedNode node, final ByteBuffer rbuf) throws IOException { if (currentOp instanceof TapOperation) { currentOp.getCallback().complete(); ((TapOperation) currentOp).streamClosed(OperationState.COMPLETE); getLogger().debug(\"Completed read op: %s and giving the next %d bytes\", currentOp, rbuf.remaining()); Operation op = node.removeCurrentReadOp(); assert op == currentOp : \"Expected to pop \" + currentOp + \" got \" + op; return node.getCurrentReadOp(); } else { throw new IOException(\"Disconnected unexpected, will reconnect.\"); } }  static String dbgBuffer(ByteBuffer b, int size) { StringBuilder sb = new StringBuilder(); byte[] bytes = b.array(); for (int i = 0; i < size; i++) { char ch = (char) bytes[i]; if (Character.isWhitespace(ch) || Character.isLetterOrDigit(ch)) { sb.append(ch); } else { sb.append(\"\\\\x\"); sb.append(Integer.toHexString(bytes[i] & 0xff)); } } return sb.toString(); }  protected void handleRetryInformation(final byte[] retryMessage) { getLogger().debug(\"Got RETRY message: \" + new String(retryMessage) + \", but not handled.\"); }  protected void queueReconnect(final MemcachedNode node) { if (shutDown) { return; } getLogger().warn(\"Closing, and reopening %s, attempt %d.\", node, node.getReconnectCount()); if (node.getSk() != null) { node.getSk().cancel(); assert !node.getSk().isValid() : \"Cancelled selection key is valid\"; } node.reconnecting(); try { if (node.getChannel() != null && node.getChannel().socket() != null) { node.getChannel().socket().close(); } else { getLogger().info(\"The channel or socket was null for %s\", node); } } catch (IOException e) { getLogger().warn(\"IOException trying to close a socket\", e); } node.setChannel(null); long delay = (long) Math.min(maxDelay, Math.pow(2, node.getReconnectCount()) * 1000); long reconnectTime = System.currentTimeMillis() + delay; while (reconnectQueue.containsKey(reconnectTime)) { reconnectTime++; } reconnectQueue.put(reconnectTime, node); metrics.incrementCounter(RECON_QUEUE_METRIC); node.setupResend(); if (failureMode == FailureMode.Redistribute) { redistributeOperations(node.destroyInputQueue()); } else if (failureMode == FailureMode.Cancel) { cancelOperations(node.destroyInputQueue()); } }  private void cancelOperations(final Collection<Operation> ops) { for (Operation op : ops) { op.cancel(); } }  public void redistributeOperations(final Collection<Operation> ops) { for (Operation op : ops) { redistributeOperation(op); } }  public void redistributeOperation(Operation op) { if (op.isCancelled() || op.isTimedOut()) { return; } if (op.getCloneCount() >= MAX_CLONE_COUNT) { getLogger().warn(\"Cancelling operation \" + op + \"because it has been \" + \"retried (cloned) more than \" + MAX_CLONE_COUNT + \"times.\"); op.cancel(); return; } "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.io.IOException; import java.net.SocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.SocketChannel; import java.util.Collection; import net.spy.memcached.ops.Operation;  public interface MemcachedNode {  void copyInputQueue();  Collection<Operation> destroyInputQueue();  void setupResend();  void fillWriteBuffer(boolean optimizeGets);  void transitionWriteItem();  Operation getCurrentReadOp();  Operation removeCurrentReadOp();  Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  void insertOp(Operation o);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  boolean isAuthenticated();  long lastReadDelta();  void completedRead();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); MemcachedConnection getConnection(); void setConnection(MemcachedConnection connection); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.io.IOException; import java.net.SocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.SocketChannel; import java.util.Collection; import net.spy.memcached.ops.Operation; public class MemcachedNodeROImpl implements MemcachedNode { private final MemcachedNode root; public MemcachedNodeROImpl(MemcachedNode n) { super(); root = n; } @Override public String toString() { return root.toString(); } public void addOp(Operation op) { throw new UnsupportedOperationException(); } public void insertOp(Operation op) { throw new UnsupportedOperationException(); } public void connected() { throw new UnsupportedOperationException(); } public void copyInputQueue() { throw new UnsupportedOperationException(); } public void fillWriteBuffer(boolean optimizeGets) { throw new UnsupportedOperationException(); } public void fixupOps() { throw new UnsupportedOperationException(); } public int getBytesRemainingToWrite() { return root.getBytesRemainingToWrite(); } public SocketChannel getChannel() { throw new UnsupportedOperationException(); } public Operation getCurrentReadOp() { throw new UnsupportedOperationException(); } public Operation getCurrentWriteOp() { throw new UnsupportedOperationException(); } public ByteBuffer getRbuf() { throw new UnsupportedOperationException(); } public int getReconnectCount() { return root.getReconnectCount(); } public int getSelectionOps() { return root.getSelectionOps(); } public SelectionKey getSk() { throw new UnsupportedOperationException(); } public SocketAddress getSocketAddress() { return root.getSocketAddress(); } public ByteBuffer getWbuf() { throw new UnsupportedOperationException(); } public boolean hasReadOp() { return root.hasReadOp(); } public boolean hasWriteOp() { return root.hasReadOp(); } public boolean isActive() { return root.isActive(); } public void reconnecting() { throw new UnsupportedOperationException(); } public void registerChannel(SocketChannel ch, SelectionKey selectionKey) { throw new UnsupportedOperationException(); } public Operation removeCurrentReadOp() { throw new UnsupportedOperationException(); } public Operation removeCurrentWriteOp() { throw new UnsupportedOperationException(); } public void setChannel(SocketChannel to) { throw new UnsupportedOperationException(); } public void setSk(SelectionKey to) { throw new UnsupportedOperationException(); } public void setupResend() { throw new UnsupportedOperationException(); } public void transitionWriteItem() { throw new UnsupportedOperationException(); } public int writeSome() throws IOException { throw new UnsupportedOperationException(); } public Collection<Operation> destroyInputQueue() { throw new UnsupportedOperationException(); } public void authComplete() { throw new UnsupportedOperationException(); } public void setupForAuth() { throw new UnsupportedOperationException(); } public int getContinuousTimeout() { throw new UnsupportedOperationException(); } public void setContinuousTimeout(boolean isIncrease) { throw new UnsupportedOperationException(); } public boolean isAuthenticated() { throw new UnsupportedOperationException(); } public long lastReadDelta() { throw new UnsupportedOperationException(); } public void completedRead() { throw new UnsupportedOperationException(); } @Override public MemcachedConnection getConnection() { throw new UnsupportedOperationException(); } @Override public void setConnection(MemcachedConnection connection) { throw new UnsupportedOperationException(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.util.Collection; import java.util.Iterator; import java.util.List;  public interface NodeLocator {  MemcachedNode getPrimary(String k);  Iterator<MemcachedNode> getSequence(String k);  Collection<MemcachedNode> getAll();  NodeLocator getReadonlyCopy();  void updateLocator(final List<MemcachedNode> nodes); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public enum ObserveResponse {  UNINITIALIZED((byte) 0xff),  MODIFIED((byte) 0xfe),  FOUND_PERSISTED((byte) 0x01),  FOUND_NOT_PERSISTED((byte) 0x00),  NOT_FOUND_PERSISTED((byte) 0x80),  NOT_FOUND_NOT_PERSISTED((byte) 0x81); private final byte value; ObserveResponse(byte b) { value = b; } public static ObserveResponse valueOf(byte b) { switch (b) { case (byte) 0x00: return ObserveResponse.FOUND_NOT_PERSISTED; case (byte) 0x01: return ObserveResponse.FOUND_PERSISTED; case (byte) 0x80: return ObserveResponse.NOT_FOUND_PERSISTED; case (byte) 0x81: return ObserveResponse.NOT_FOUND_NOT_PERSISTED; case (byte) 0xfe: return ObserveResponse.MODIFIED; default: return ObserveResponse.UNINITIALIZED; } } public byte getResponse() { return value; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import net.spy.memcached.ops.CASOperation; import net.spy.memcached.ops.ConcatenationOperation; import net.spy.memcached.ops.ConcatenationType; import net.spy.memcached.ops.DeleteOperation; import net.spy.memcached.ops.FlushOperation; import net.spy.memcached.ops.GetAndTouchOperation; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.GetlOperation; import net.spy.memcached.ops.GetsOperation; import net.spy.memcached.ops.KeyedOperation; import net.spy.memcached.ops.Mutator; import net.spy.memcached.ops.MutatorOperation; import net.spy.memcached.ops.NoopOperation; import net.spy.memcached.ops.ObserveOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.ReplicaGetOperation; import net.spy.memcached.ops.ReplicaGetsOperation; import net.spy.memcached.ops.SASLAuthOperation; import net.spy.memcached.ops.SASLMechsOperation; import net.spy.memcached.ops.SASLStepOperation; import net.spy.memcached.ops.StatsOperation; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.ops.StoreType; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.ops.TouchOperation; import net.spy.memcached.ops.UnlockOperation; import net.spy.memcached.ops.VersionOperation; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.TapOpcode; import javax.security.auth.callback.CallbackHandler; import java.util.Collection; import java.util.Map;  public interface OperationFactory {  NoopOperation noop(OperationCallback cb);  DeleteOperation delete(String key, DeleteOperation.Callback callback);  DeleteOperation delete(String key, long cas, DeleteOperation.Callback callback);  UnlockOperation unlock(String key, long casId, OperationCallback operationCallback);  ObserveOperation observe(String key, long casId, int index, ObserveOperation.Callback operationCallback);  FlushOperation flush(int delay, OperationCallback operationCallback);  GetAndTouchOperation getAndTouch(String key, int expiration, GetAndTouchOperation.Callback cb);  GetOperation get(String key, GetOperation.Callback callback);  ReplicaGetOperation replicaGet(String key, int index, ReplicaGetOperation.Callback callback);  ReplicaGetsOperation replicaGets(String key, int index, ReplicaGetsOperation.Callback callback);  GetlOperation getl(String key, int exp, GetlOperation.Callback callback);  GetsOperation gets(String key, GetsOperation.Callback callback);  GetOperation get(Collection<String> keys, GetOperation.Callback cb);  StatsOperation keyStats(String key, StatsOperation.Callback cb);  MutatorOperation mutate(Mutator m, String key, long by, long def, int exp, OperationCallback cb);  StatsOperation stats(String arg, StatsOperation.Callback cb);  StoreOperation store(StoreType storeType, String key, int flags, int exp, byte[] data, StoreOperation.Callback cb);  TouchOperation touch(String key, int expiration, OperationCallback cb);  ConcatenationOperation cat(ConcatenationType catType, long casId, String key, byte[] data, OperationCallback cb);  CASOperation cas(StoreType t, String key, long casId, int flags, int exp, byte[] data, StoreOperation.Callback cb);  VersionOperation version(OperationCallback cb);  SASLMechsOperation saslMechs(OperationCallback cb);  SASLAuthOperation saslAuth(String[] mech, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb);  SASLStepOperation saslStep(String[] mech, byte[] challenge, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb);  Collection<Operation> clone(KeyedOperation op); /** * Creates a tap backfill stream. * * See <a href=\"http:"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public class OperationTimeoutException extends RuntimeException { private static final long serialVersionUID = 1479557202445843619L; public OperationTimeoutException(String message) { super(message); } public OperationTimeoutException(String message, Throwable cause) { super(message, cause); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public enum PersistTo {  ZERO(0),  MASTER(1),  ONE(1),  TWO(2),  THREE(3),  FOUR(4); private final int value; PersistTo(int val) { value = val; } public int getValue() { return value; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached;  public enum ReplicateTo {  ZERO(0),  ONE(1),  TWO(2),  THREE(3); private final int value; ReplicateTo(int val) { value = val; } public int getValue() { return value; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.io.IOException; import java.net.InetSocketAddress; import java.util.Arrays; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.concurrent.BlockingQueue; import java.util.concurrent.CountDownLatch; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit; import javax.naming.ConfigurationException; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.ResponseMessage; import net.spy.memcached.tapmessage.TapAck; import net.spy.memcached.tapmessage.TapOpcode; import net.spy.memcached.tapmessage.TapStream;  public class TapClient { protected BlockingQueue<Object> rqueue; protected final HashMap<TapStream, TapConnectionProvider> omap; protected long messagesRead; private List<InetSocketAddress> addrs;  public TapClient(InetSocketAddress... ia) { this(Arrays.asList(ia)); }  public TapClient(List<InetSocketAddress> addrs) { this.rqueue = new LinkedBlockingQueue<Object>(); this.omap = new HashMap<TapStream, TapConnectionProvider>(); this.addrs = addrs; this.messagesRead = 0; }  public ResponseMessage getNextMessage() { return getNextMessage(10, TimeUnit.SECONDS); }  public ResponseMessage getNextMessage(long time, TimeUnit timeunit) { try { Object m = rqueue.poll(time, timeunit); if (m == null) { return null; } else if (m instanceof ResponseMessage) { return (ResponseMessage) m; } else if (m instanceof TapAck) { TapAck ack = (TapAck) m; tapAck(ack.getConn(), ack.getNode(), ack.getOpcode(), ack.getOpaque(), ack.getCallback()); return null; } else { throw new RuntimeException(\"Unexpected tap message type\"); } } catch (InterruptedException e) { shutdown(); return null; } }  public boolean hasMoreMessages() { if (!rqueue.isEmpty()) { return true; } else { synchronized (omap) { Iterator<TapStream> itr = omap.keySet().iterator(); while (itr.hasNext()) { TapStream ts = itr.next(); if (ts.isCompleted() || ts.isCancelled() || ts.hasErrored()) { omap.get(ts).shutdown(); omap.remove(ts); } } if (omap.size() > 0) { return true; } } } return false; }  public TapStream tapCustom(final String id, final RequestMessage message) throws ConfigurationException, IOException { final TapConnectionProvider conn = new TapConnectionProvider(addrs); final TapStream ts = new TapStream(); conn.broadcastOp(new BroadcastOpFactory() { public Operation newOp(final MemcachedNode n, final CountDownLatch latch) { Operation op = conn.getOpFactory().tapCustom(id, message, new TapOperation.Callback() { public void receivedStatus(OperationStatus status) { } public void gotData(ResponseMessage tapMessage) { rqueue.add(tapMessage); messagesRead++; } public void gotAck(MemcachedNode node, TapOpcode opcode, int opaque) { rqueue.add(new TapAck(conn, node, opcode, opaque, this)); } public void complete() { latch.countDown(); } }); ts.addOp((TapOperation)op); return op; } }); synchronized (omap) { omap.put(ts, conn); } return ts; }  public TapStream tapDump(final String id) throws IOException, ConfigurationException { final TapConnectionProvider conn = new TapConnectionProvider(addrs); final TapStream ts = new TapStream(); conn.broadcastOp(new BroadcastOpFactory() { public Operation newOp(final MemcachedNode n, final CountDownLatch latch) { Operation op = conn.getOpFactory().tapDump(id, new TapOperation.Callback() { public void receivedStatus(OperationStatus status) { } public void gotData(ResponseMessage tapMessage) { rqueue.add(tapMessage); messagesRead++; } public void gotAck(MemcachedNode node, TapOpcode opcode, int opaque) { rqueue.add(new TapAck(conn, node, opcode, opaque, this)); } public void complete() { latch.countDown(); } }); ts.addOp((TapOperation)op); return op; } }); synchronized (omap) { omap.put(ts, conn); } return ts; } private void tapAck(TapConnectionProvider conn, MemcachedNode node, TapOpcode opcode, int opaque, OperationCallback cb) { final Operation op = conn.getOpFactory().tapAck(opcode, opaque, cb); conn.addTapAckOp(node, op); }  public void shutdown() { synchronized (omap) { for (Map.Entry<TapStream, TapConnectionProvider> me : omap.entrySet()) { me.getValue().shutdown(); } } }  public long getMessagesRead() { return messagesRead; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached; import java.io.IOException; import java.net.InetSocketAddress; import java.net.SocketAddress; import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import net.spy.memcached.auth.AuthDescriptor; import net.spy.memcached.auth.AuthThreadMonitor; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.transcoders.TranscodeService;  public class TapConnectionProvider extends SpyObject implements ConnectionObserver { protected volatile boolean shuttingDown = false; protected final MemcachedConnection conn; protected final OperationFactory opFact; protected final TranscodeService tcService; protected final AuthDescriptor authDescriptor; protected final AuthThreadMonitor authMonitor = new AuthThreadMonitor();  public TapConnectionProvider(InetSocketAddress... ia) throws IOException { this(new BinaryConnectionFactory(), Arrays.asList(ia)); }  public TapConnectionProvider(List<InetSocketAddress> addrs) throws IOException { this(new BinaryConnectionFactory(), addrs); }  public TapConnectionProvider(ConnectionFactory cf, List<InetSocketAddress> addrs) throws IOException { if (cf == null) { throw new NullPointerException(\"Connection factory required\"); } if (addrs == null) { throw new NullPointerException(\"Server list required\"); } if (addrs.isEmpty()) { throw new IllegalArgumentException( \"You must have at least one server to connect to\"); } if (cf.getOperationTimeout() <= 0) { throw new IllegalArgumentException(\"Operation timeout must be positive.\"); } tcService = new TranscodeService(cf.isDaemon()); cf.getDefaultTranscoder(); opFact = cf.getOperationFactory(); assert opFact != null : \"Connection factory failed to make op factory\"; conn = cf.createConnection(addrs); assert conn != null : \"Connection factory failed to make a connection\"; authDescriptor = cf.getAuthDescriptor(); if (authDescriptor != null) { addObserver(this); } } public void addTapAckOp(MemcachedNode node, final Operation op) { conn.addOperation(node, op); } public CountDownLatch broadcastOp(final BroadcastOpFactory of) { if (shuttingDown) { throw new IllegalStateException(\"Shutting down\"); } return conn.broadcastOperation(of, conn.getLocator().getAll()); }  public boolean addObserver(ConnectionObserver obs) { boolean rv = conn.addObserver(obs); if (rv) { for (MemcachedNode node : conn.getLocator().getAll()) { if (node.isActive()) { obs.connectionEstablished(node.getSocketAddress(), -1); } } } return rv; }  public boolean removeObserver(ConnectionObserver obs) { return conn.removeObserver(obs); } public void connectionEstablished(SocketAddress sa, int reconnectCount) { if (authDescriptor != null) { if (authDescriptor.authThresholdReached()) { this.shutdown(); } else { authMonitor.authConnection(conn, opFact, authDescriptor, findNode(sa)); } } } private MemcachedNode findNode(SocketAddress sa) { MemcachedNode node = null; for (MemcachedNode n : conn.getLocator().getAll()) { if (n.getSocketAddress().equals(sa)) { node = n; } } assert node != null : \"Couldn't find node connected to \" + sa; return node; } public void connectionLost(SocketAddress sa) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.auth; import javax.security.auth.callback.CallbackHandler;  public class AuthDescriptor { private final String[] mechs; private final CallbackHandler cbh; private int authAttempts; private int allowedAuthAttempts;  public AuthDescriptor(String[] m, CallbackHandler h) { mechs = m; cbh = h; authAttempts = 0; String authThreshhold = System.getProperty(\"net.spy.memcached.auth.AuthThreshold\"); if (authThreshhold != null) { allowedAuthAttempts = Integer.parseInt(authThreshhold); } else { allowedAuthAttempts = -1; "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.auth; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference; import net.spy.memcached.KeyUtil; import net.spy.memcached.MemcachedConnection; import net.spy.memcached.MemcachedNode; import net.spy.memcached.OperationFactory; import net.spy.memcached.compat.SpyThread; import net.spy.memcached.compat.log.Level; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationStatus;  public class AuthThread extends SpyThread {  public static final int AUTH_ROUNDTRIP_THRESHOLD = 250;  public static final int AUTH_TOTAL_THRESHOLD = 1000; public static final String MECH_SEPARATOR = \" \"; private final MemcachedConnection conn; private final AuthDescriptor authDescriptor; private final OperationFactory opFact; private final MemcachedNode node; public AuthThread(MemcachedConnection c, OperationFactory o, AuthDescriptor a, MemcachedNode n) { conn = c; opFact = o; authDescriptor = a; node = n; start(); } protected String[] listSupportedSASLMechanisms(AtomicBoolean done) { final CountDownLatch listMechsLatch = new CountDownLatch(1); final AtomicReference<String> supportedMechs = new AtomicReference<String>(); Operation listMechsOp = opFact.saslMechs(new OperationCallback() { @Override public void receivedStatus(OperationStatus status) { if(status.isSuccess()) { supportedMechs.set(status.getMessage()); getLogger().debug(\"Received SASL supported mechs: \" + status.getMessage()); } else { getLogger().warn(\"Received non-success response for SASL mechs: \" + status); } } @Override public void complete() { listMechsLatch.countDown(); } }); conn.insertOperation(node, listMechsOp); try { if (!conn.isShutDown()) { listMechsLatch.await(); } else { done.set(true); "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.auth; import java.util.HashMap; import java.util.Map; import net.spy.memcached.MemcachedConnection; import net.spy.memcached.MemcachedNode; import net.spy.memcached.OperationFactory; import net.spy.memcached.compat.SpyObject;  public class AuthThreadMonitor extends SpyObject { private final Map<Object, AuthThread> nodeMap; public AuthThreadMonitor() { nodeMap = new HashMap<Object, AuthThread>(); }  public synchronized void authConnection(MemcachedConnection conn, OperationFactory opFact, AuthDescriptor authDescriptor, MemcachedNode node) { interruptOldAuth(node); AuthThread newSASLAuthenticator = new AuthThread(conn, opFact, authDescriptor, node); nodeMap.put(node, newSASLAuthenticator); }  public synchronized void interruptAllPendingAuth(){ for (AuthThread toStop : nodeMap.values()) { if (toStop.isAlive()) { getLogger().warn(\"Connection shutdown in progress - interrupting \" + \"waiting authentication thread.\"); toStop.interrupt(); } } } private void interruptOldAuth(MemcachedNode nodeToStop) { AuthThread toStop = nodeMap.get(nodeToStop); if (toStop != null) { if (toStop.isAlive()) { getLogger().warn( \"Incomplete authentication interrupted for node \" + nodeToStop); toStop.interrupt(); } nodeMap.remove(nodeToStop); } }  protected Map<Object, AuthThread> getNodeMap() { return nodeMap; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.auth; import java.io.IOException; import javax.security.auth.callback.Callback; import javax.security.auth.callback.CallbackHandler; import javax.security.auth.callback.NameCallback; import javax.security.auth.callback.PasswordCallback; import javax.security.auth.callback.TextOutputCallback; import javax.security.auth.callback.UnsupportedCallbackException;  public class PlainCallbackHandler implements CallbackHandler { private final String username; private final char[] password;  public PlainCallbackHandler(String u, String p) { username = u; password = p.toCharArray(); } public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException { for (Callback cb : callbacks) { if (cb instanceof TextOutputCallback) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat; import java.io.Closeable; import net.spy.memcached.compat.log.Logger; import net.spy.memcached.compat.log.LoggerFactory;  public final class CloseUtil { private static Logger logger = LoggerFactory.getLogger(CloseUtil.class); private CloseUtil() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat; import net.spy.memcached.compat.log.Logger; import net.spy.memcached.compat.log.LoggerFactory;  public class SpyObject extends Object { private transient Logger logger = null;  public SpyObject() { super(); }  protected Logger getLogger() { if (logger == null) { logger = LoggerFactory.getLogger(getClass()); } return (logger); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat; import net.spy.memcached.compat.log.Logger; import net.spy.memcached.compat.log.LoggerFactory;  public class SpyThread extends Thread { private transient Logger logger = null; "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat; import java.util.ArrayList; import java.util.Collection; import java.util.IdentityHashMap; import java.util.concurrent.Callable; import java.util.concurrent.CountDownLatch; import java.util.concurrent.CyclicBarrier;  public class SyncThread<T> extends SpyThread { private final Callable<T> callable; private final CyclicBarrier barrier; private final CountDownLatch latch; private Throwable throwable = null; private T rv = null;  public SyncThread(CyclicBarrier b, Callable<T> c) { super(\"SyncThread\"); setDaemon(true); callable = c; barrier = b; latch = new CountDownLatch(1); start(); }  @Override public void run() { try { barrier.await(); rv = callable.call(); } catch (Throwable t) { throwable = t; } latch.countDown(); }  public T getResult() throws Throwable { latch.await(); if (throwable != null) { throw throwable; } return rv; }  public static <T> Collection<SyncThread<T>> getCompletedThreads(int num, Callable<T> callable) throws InterruptedException { Collection<SyncThread<T>> rv = new ArrayList<SyncThread<T>>(num); CyclicBarrier barrier = new CyclicBarrier(num); for (int i = 0; i < num; i++) { rv.add(new SyncThread<T>(barrier, callable)); } for (SyncThread<T> t : rv) { t.join(); } return rv; }  public static <T> int getDistinctResultCount(int num, Callable<T> callable) throws Throwable { IdentityHashMap<T, Object> found = new IdentityHashMap<T, Object>(); Collection<SyncThread<T>> threads = getCompletedThreads(num, callable); for (SyncThread<T> s : threads) { found.put(s.getResult(), new Object()); } return found.size(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log;  public abstract class AbstractLogger implements Logger { private final String name;  protected AbstractLogger(String nm) { super(); if (nm == null) { throw new NullPointerException(\"Logger name may not be null.\"); } name = nm; }  public String getName() { return (name); }  public Throwable getThrowable(Object[] args) { Throwable rv = null; if (args.length > 0) { if (args[args.length - 1] instanceof Throwable) { rv = (Throwable) args[args.length - 1]; } } return rv; }  public abstract boolean isDebugEnabled();  public abstract boolean isInfoEnabled();  public void trace(Object message, Throwable exception) { log(Level.TRACE, message, exception); }  public void trace(String message, Object... args) { if (isDebugEnabled()) { trace(String.format(message, args), getThrowable(args)); } }  public void trace(Object message) { trace(message, null); }  public void debug(Object message, Throwable exception) { log(Level.DEBUG, message, exception); }  public void debug(String message, Object... args) { if (isDebugEnabled()) { debug(String.format(message, args), getThrowable(args)); } }  public void debug(Object message) { debug(message, null); }  public void info(Object message, Throwable exception) { log(Level.INFO, message, exception); }  public void info(String message, Object... args) { if (isInfoEnabled()) { info(String.format(message, args), getThrowable(args)); } }  public void info(Object message) { info(message, null); }  public void warn(Object message, Throwable exception) { log(Level.WARN, message, exception); }  public void warn(String message, Object... args) { warn(String.format(message, args), getThrowable(args)); }  public void warn(Object message) { warn(message, null); }  public void error(Object message, Throwable exception) { log(Level.ERROR, message, exception); }  public void error(String message, Object... args) { error(String.format(message, args), getThrowable(args)); }  public void error(Object message) { error(message, null); }  public void fatal(Object message, Throwable exception) { log(Level.FATAL, message, exception); }  public void fatal(String message, Object... args) { fatal(String.format(message, args), getThrowable(args)); }  public void fatal(Object message) { fatal(message, null); }  public void log(Level level, Object message) { log(level, message, null); }  public abstract void log(Level level, Object message, Throwable e); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log; import java.text.SimpleDateFormat; import java.util.Date;  public class DefaultLogger extends AbstractLogger { private final SimpleDateFormat df;  public DefaultLogger(String name) { super(name); df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); }  @Override public boolean isTraceEnabled() { return (false); }  @Override public boolean isDebugEnabled() { return (false); }  @Override public boolean isInfoEnabled() { return (true); }  @Override public synchronized void log(Level level, Object message, Throwable e) { if (level == Level.INFO || level == Level.WARN || level == Level.ERROR || level == Level.FATAL) { System.err.printf(\"%s %s %s: %s\\n\", df.format(new Date()), level.name(), getName(), message); if (e != null) { e.printStackTrace(); } } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log;  public enum Level {  TRACE,  DEBUG,  INFO,  WARN,  ERROR,  FATAL;  @Override public String toString() { return (\"{LogLevel: \" + name() + \"}\"); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log; import org.apache.log4j.Logger; /** * Logging implementation using <a * href=\"http:"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log;  public interface Logger {  String getName();  boolean isDebugEnabled();  boolean isInfoEnabled();  boolean isTraceEnabled();  void log(Level level, Object message, Throwable exception);  void log(Level level, Object message);  void trace(Object message, Throwable exception);  void trace(Object message);  void trace(String message, Object... args);  void debug(Object message, Throwable exception);  void debug(Object message);  void debug(String message, Object... args);  void info(Object message, Throwable exception);  void info(Object message);  void info(String message, Object... args);  void warn(Object message, Throwable exception);  void warn(Object message);  void warn(String message, Object... args);  void error(Object message, Throwable exception);  void error(Object message);  void error(String message, Object... args);  void fatal(Object message, Throwable exception);  void fatal(Object message);  void fatal(String message, Object... args); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; /** * Factory to get logger instances. * * The system property <code>net.spy.log.LoggerImpl</code> should point * to an implementation of net.spy.compat.log.Logger to use. * * <p> * Depending on how and where this was compiled, a sun logger (jdk 1.4) and/or * <a href=\"http:"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log; /** * Logging Implementation using the <a href=\"http:"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.compat.log;  public class SunLogger extends AbstractLogger { private final java.util.logging.Logger sunLogger;  public SunLogger(String name) { super(name); "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import net.spy.memcached.compat.SpyObject; import java.util.ArrayList; import java.util.List; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future;  public abstract class AbstractListenableFuture <T, L extends GenericCompletionListener> extends SpyObject implements ListenableFuture<T, L> {  private final ExecutorService service;  private List<GenericCompletionListener<? extends Future<T>>> listeners;  protected AbstractListenableFuture(ExecutorService executor) { service = executor; listeners = new ArrayList<GenericCompletionListener<? extends Future<T>>>(); }  protected ExecutorService executor() { return service; }  protected Future<T> addToListeners( final GenericCompletionListener<? extends Future<T>> listener) { if (listener == null) { throw new IllegalArgumentException(\"The listener can't be null.\"); } synchronized(this) { listeners.add(listener); } if(isDone()) { notifyListeners(); } return this; }  protected void notifyListener(final ExecutorService executor, final Future<?> future, final GenericCompletionListener listener) { executor.submit(new Runnable() { @Override public void run() { try { listener.onComplete(future); } catch(Throwable t) { getLogger().warn( \"Exception thrown wile executing \" + listener.getClass().getName() + \".operationComplete()\", t); } } }); }  protected void notifyListeners() { notifyListeners(this); }  protected void notifyListeners(final Future<?> future) { final List<GenericCompletionListener<? extends Future<T>>> copy = new ArrayList<GenericCompletionListener<? extends Future<T>>>(); synchronized(this) { copy.addAll(listeners); listeners = new ArrayList<GenericCompletionListener<? extends Future<T>>>(); } for (GenericCompletionListener<? extends Future<? super T>> listener : copy) { notifyListener(executor(), future, listener); } }  protected Future<T> removeFromListeners( GenericCompletionListener<? extends Future<T>> listener) { if (listener == null) { throw new IllegalArgumentException(\"The listener can't be null.\"); } if (!isDone()) { synchronized(this) { listeners.remove(listener); } } return this; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.concurrent.ThreadFactory; import java.util.concurrent.atomic.AtomicInteger;  public class BasicThreadFactory implements ThreadFactory { private static final AtomicInteger POOL_NUMBER = new AtomicInteger(1); private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; private final boolean daemon; public BasicThreadFactory(String name, boolean daemon) { this.namePrefix = name + \"-\" + POOL_NUMBER.getAndIncrement() + \"-\"; this.daemon = daemon; } public Thread newThread(Runnable r) { Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement()); t.setDaemon(daemon); return t; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.concurrent.ExecutionException; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import net.spy.memcached.ops.OperationStatus;  public interface BulkFuture<V> extends Future<V> {  boolean isTimeout();  V getSome(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException;  OperationStatus getStatus();  Future<V> addListener(BulkGetCompletionListener listener);  Future<V> removeListener(BulkGetCompletionListener listener); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal;  public interface BulkGetCompletionListener extends GenericCompletionListener<BulkGetFuture<?>> { }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.concurrent.CancellationException; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import net.spy.memcached.MemcachedConnection; import net.spy.memcached.compat.log.LoggerFactory; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  public class BulkGetFuture<T> extends AbstractListenableFuture<Map<String, T>, BulkGetCompletionListener> implements BulkFuture<Map<String, T>> { private final Map<String, Future<T>> rvMap; private final Collection<Operation> ops; private final CountDownLatch latch; private OperationStatus status; private boolean cancelled = false; private boolean timeout = false; public BulkGetFuture(Map<String, Future<T>> m, Collection<Operation> getOps, CountDownLatch l, ExecutorService service) { super(service); rvMap = m; ops = getOps; latch = l; status = null; } public boolean cancel(boolean ign) { boolean rv = false; for (Operation op : ops) { rv |= op.getState() == OperationState.WRITE_QUEUED; op.cancel(); } for (Future<T> v : rvMap.values()) { v.cancel(ign); } cancelled = true; status = new OperationStatus(false, \"Cancelled\", StatusCode.CANCELLED); notifyListeners(); return rv; } public Map<String, T> get() throws InterruptedException, ExecutionException { try { return get(Long.MAX_VALUE, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { throw new RuntimeException(\"Timed out waiting forever\", e); } }  public Map<String, T> getSome(long to, TimeUnit unit) throws InterruptedException, ExecutionException { Collection<Operation> timedoutOps = new HashSet<Operation>(); Map<String, T> ret = internalGet(to, unit, timedoutOps); if (timedoutOps.size() > 0) { timeout = true; LoggerFactory.getLogger(getClass()).warn( new CheckedOperationTimeoutException(\"Operation timed out: \", timedoutOps).getMessage()); } return ret; }  public Map<String, T> get(long to, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { Collection<Operation> timedoutOps = new HashSet<Operation>(); Map<String, T> ret = internalGet(to, unit, timedoutOps); if (timedoutOps.size() > 0) { this.timeout = true; throw new CheckedOperationTimeoutException(\"Operation timed out.\", timedoutOps); } return ret; }  private Map<String, T> internalGet(long to, TimeUnit unit, Collection<Operation> timedoutOps) throws InterruptedException, ExecutionException { if (!latch.await(to, unit)) { for (Operation op : ops) { if (op.getState() != OperationState.COMPLETE) { MemcachedConnection.opTimedOut(op); timedoutOps.add(op); } else { MemcachedConnection.opSucceeded(op); } } } for (Operation op : ops) { if (op.isCancelled()) { throw new ExecutionException(new CancellationException(\"Cancelled\")); } if (op.hasErrored()) { throw new ExecutionException(op.getException()); } } Map<String, T> m = new HashMap<String, T>(); for (Map.Entry<String, Future<T>> me : rvMap.entrySet()) { m.put(me.getKey(), me.getValue().get()); } return m; } public OperationStatus getStatus() { if (status == null) { try { get(); } catch (InterruptedException e) { status = new OperationStatus(false, \"Interrupted\", StatusCode.INTERRUPTED); Thread.currentThread().interrupt(); } catch (ExecutionException e) { return status; } } return status; } public void setStatus(OperationStatus s) { status = s; } public boolean isCancelled() { return cancelled; } public boolean isDone() { return latch.getCount() == 0; }  public boolean isTimeout() { return timeout; } @Override public Future<Map<String, T>> addListener( BulkGetCompletionListener listener) { super.addToListeners((GenericCompletionListener) listener); return this; } @Override public Future<Map<String, T>> removeListener( BulkGetCompletionListener listener) { super.removeFromListeners((GenericCompletionListener) listener); return this; }  public void signalComplete() { notifyListeners(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.Collection; import java.util.Collections; import java.util.concurrent.TimeoutException; import net.spy.memcached.MemcachedNode; import net.spy.memcached.ops.Operation;  public class CheckedOperationTimeoutException extends TimeoutException { private static final long serialVersionUID = 139074906690883031L; private final Collection<Operation> operations;  public CheckedOperationTimeoutException(String message, Operation op) { this(message, Collections.singleton(op)); } public CheckedOperationTimeoutException(String message, Collection<Operation> ops) { super(createMessage(message, ops)); operations = ops; } private static String createMessage(String message, Collection<Operation> ops) { StringBuilder rv = new StringBuilder(message); rv.append(\" - failing node\"); rv.append(ops.size() == 1 ? \": \" : \"s: \"); boolean first = true; for (Operation op : ops) { if (first) { first = false; } else { rv.append(\", \"); } MemcachedNode node = op == null ? null : op.getHandlingNode(); rv.append(node == null ? \"<unknown>\" : node.getSocketAddress()); } return rv.toString(); }  public Collection<Operation> getOperations() { return operations; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.EventListener; import java.util.concurrent.Future;  public interface GenericCompletionListener<F extends Future<?>> extends EventListener {  void onComplete(F future) throws Exception; }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal;  public interface GetCompletionListener extends GenericCompletionListener<GetFuture<?>> { }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationStatus;  public class GetFuture<T> extends AbstractListenableFuture<T, GetCompletionListener> implements Future<T> { private final OperationFuture<Future<T>> rv; public GetFuture(CountDownLatch l, long opTimeout, String key, ExecutorService service) { super(service); this.rv = new OperationFuture<Future<T>>(key, l, opTimeout, service); } public boolean cancel(boolean ign) { boolean result = rv.cancel(ign); notifyListeners(); return result; } public T get() throws InterruptedException, ExecutionException { Future<T> v = rv.get(); return v == null ? null : v.get(); } public T get(long duration, TimeUnit units) throws InterruptedException, TimeoutException, ExecutionException { Future<T> v = rv.get(duration, units); return v == null ? null : v.get(); } public OperationStatus getStatus() { return rv.getStatus(); } public void set(Future<T> d, OperationStatus s) { rv.set(d, s); } public void setOperation(Operation to) { rv.setOperation(to); } public boolean isCancelled() { return rv.isCancelled(); } public boolean isDone() { return rv.isDone(); } @Override public GetFuture<T> addListener(GetCompletionListener listener) { super.addToListeners((GenericCompletionListener) listener); return this; } @Override public GetFuture<T> removeListener(GetCompletionListener listener) { super.removeFromListeners((GenericCompletionListener) listener); return this; }  public void signalComplete() { notifyListeners(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.concurrent.ExecutionException; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException;  public class ImmediateFuture implements Future<Boolean> { private final Boolean value; private final ExecutionException exception; public ImmediateFuture(Boolean returnValue) { value = returnValue; exception = null; } public ImmediateFuture(Exception e) { value = null; exception = new ExecutionException(e); } public boolean cancel(boolean mayInterruptIfRunning) { return false; } public Boolean get() throws InterruptedException, ExecutionException { if (exception != null) { throw exception; } return value; } public Boolean get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { if (exception != null) { throw exception; } return value; } public boolean isCancelled() { return false; } public boolean isDone() { return true; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.concurrent.Future;  public interface ListenableFuture<T, L extends GenericCompletionListener> extends Future<T> {  Future<T> addListener(L listener);  Future<T> removeListener(L listener); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal;  public interface OperationCompletionListener extends GenericCompletionListener<OperationFuture<?>> { }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.concurrent.CancellationException; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicReference; import net.spy.memcached.MemcachedConnection; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  public class OperationFuture<T> extends AbstractListenableFuture<T, OperationCompletionListener> implements Future<T> { private final CountDownLatch latch; private final AtomicReference<T> objRef; protected OperationStatus status; private final long timeout; private Operation op; private final String key; private Long cas;  public OperationFuture(String k, CountDownLatch l, long opTimeout, ExecutorService service) { this(k, l, new AtomicReference<T>(null), opTimeout, service); }  public OperationFuture(String k, CountDownLatch l, AtomicReference<T> oref, long opTimeout, ExecutorService service) { super(service); latch = l; objRef = oref; status = null; timeout = opTimeout; key = k; cas = null; }  public boolean cancel(boolean ign) { assert op != null : \"No operation\"; op.cancel(); notifyListeners(); return op.getState() == OperationState.WRITE_QUEUED; }  public boolean cancel() { assert op != null : \"No operation\"; op.cancel(); notifyListeners(); return op.getState() == OperationState.WRITE_QUEUED; }  public T get() throws InterruptedException, ExecutionException { try { return get(timeout, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { throw new RuntimeException(\"Timed out waiting for operation\", e); } }  public T get(long duration, TimeUnit units) throws InterruptedException, TimeoutException, ExecutionException { if (!latch.await(duration, units)) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.internal; import java.util.Iterator;  public class SingleElementInfiniteIterator<T> implements Iterator<T> { private final T element;  public SingleElementInfiniteIterator(T element) { this.element = element; } public boolean hasNext() { return true; } public T next() { return element; } public void remove() { throw new UnsupportedOperationException(\"Cannot remove from this \" + \"iterator.\"); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.metrics;  public abstract class AbstractMetricCollector implements MetricCollector { @Override public void decrementCounter(String name) { decrementCounter(name, 1); } @Override public void incrementCounter(String name) { incrementCounter(name, 1); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.metrics; import com.codahale.metrics.*; import org.slf4j.LoggerFactory; import java.io.File; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.TimeUnit;  public final class DefaultMetricCollector extends AbstractMetricCollector {  public static final String DEFAULT_REPORTER_TYPE = \"console\";  public static final String DEFAULT_REPORTER_INTERVAL = \"30\";  public static final String DEFAULT_REPORTER_OUTDIR = \"\";  private MetricRegistry registry;  private ConcurrentHashMap<String, Counter> counters;  private ConcurrentHashMap<String, Meter> meters;  private ConcurrentHashMap<String, Histogram> histograms;  public DefaultMetricCollector() { registry = new MetricRegistry(); counters = new ConcurrentHashMap<String, Counter>(); meters = new ConcurrentHashMap<String, Meter>(); histograms = new ConcurrentHashMap<String, Histogram>(); initReporter(); }  private void initReporter() { String reporterType = System.getProperty(\"net.spy.metrics.reporter.type\", DEFAULT_REPORTER_TYPE); String reporterInterval = System.getProperty(\"net.spy.metrics.reporter.interval\", DEFAULT_REPORTER_INTERVAL); String reporterDir = System.getProperty(\"net.spy.metrics.reporter.outdir\", DEFAULT_REPORTER_OUTDIR); if(reporterType.equals(\"console\")) { final ConsoleReporter reporter = ConsoleReporter.forRegistry(registry) .convertRatesTo(TimeUnit.SECONDS) .convertDurationsTo(TimeUnit.SECONDS) .build(); reporter.start(Integer.parseInt(reporterInterval), TimeUnit.SECONDS); } else if (reporterType.equals(\"jmx\")) { final JmxReporter reporter = JmxReporter.forRegistry(registry) .convertRatesTo(TimeUnit.SECONDS) .convertDurationsTo(TimeUnit.SECONDS) .build(); reporter.start(); } else if (reporterType.equals(\"csv\")) { final CsvReporter reporter = CsvReporter.forRegistry(registry) .convertRatesTo(TimeUnit.SECONDS) .convertDurationsTo(TimeUnit.SECONDS) .build(new File(reporterDir)); reporter.start(Integer.parseInt(reporterInterval), TimeUnit.SECONDS); } else if (reporterType.equals(\"slf4j\")) { final Slf4jReporter reporter = Slf4jReporter.forRegistry(registry) .convertRatesTo(TimeUnit.SECONDS) .convertDurationsTo(TimeUnit.SECONDS) .outputTo(LoggerFactory.getLogger(MetricCollector.class)) .build(); reporter.start(Integer.parseInt(reporterInterval), TimeUnit.SECONDS); } else { throw new IllegalStateException(\"Unknown Metrics Reporter Type: \" + reporterType); } } @Override public void addCounter(String name) { if (!counters.containsKey(name)) { counters.put(name, registry.counter(name)); } } @Override public void removeCounter(String name) { if (!counters.containsKey(name)) { registry.remove(name); counters.remove(name); } } @Override public void incrementCounter(String name, int amount) { if (counters.containsKey(name)) { counters.get(name).inc(amount); } } @Override public void decrementCounter(String name, int amount) { if (counters.containsKey(name)) { counters.get(name).dec(amount); } } @Override public void addMeter(String name) { if (!meters.containsKey(name)) { meters.put(name, registry.meter(name)); } } @Override public void removeMeter(String name) { if (meters.containsKey(name)) { meters.remove(name); } } @Override public void markMeter(String name) { if (meters.containsKey(name)) { meters.get(name).mark(); } } @Override public void addHistogram(String name) { if (!histograms.containsKey(name)) { histograms.put(name, registry.histogram(name)); } } @Override public void removeHistogram(String name) { if (histograms.containsKey(name)) { histograms.remove(name); } } @Override public void updateHistogram(String name, int amount) { if (histograms.containsKey(name)) { histograms.get(name).update(amount); } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.metrics;  public interface MetricCollector {  void addCounter(String name);  void removeCounter(String name);  void incrementCounter(String name);  void incrementCounter(String name, int amount);  void decrementCounter(String name);  void decrementCounter(String name, int amount);  void addMeter(String name);  void removeMeter(String name);  void markMeter(String name);  void addHistogram(String name);  void removeHistogram(String name);  void updateHistogram(String name, int amount); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.metrics;  public enum MetricType {  OFF,  PERFORMANCE,  DEBUG }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.metrics;  public final class NoopMetricCollector extends AbstractMetricCollector { @Override public void addCounter(String name) { return; } @Override public void removeCounter(String name) { return; } @Override public void incrementCounter(String name, int amount) { return; } @Override public void decrementCounter(String name, int amount) { return; } @Override public void addMeter(String name) { return; } @Override public void removeMeter(String name) { return; } @Override public void markMeter(String name) { return; } @Override public void addHistogram(String name) { return; } @Override public void removeHistogram(String name) { return; } @Override public void updateHistogram(String name, int amount) { return; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue;  public class ArrayOperationQueueFactory implements OperationQueueFactory { private final int capacity;  public ArrayOperationQueueFactory(int cap) { super(); capacity = cap; }  public BlockingQueue<Operation> create() { return new ArrayBlockingQueue<Operation>(capacity); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import net.spy.memcached.MemcachedNode; import net.spy.memcached.OperationFactory; import java.util.ArrayList; import java.util.Collection;  public abstract class BaseOperationFactory implements OperationFactory { private String first(Collection<String> keys) { return keys.iterator().next(); } public Collection<Operation> clone(KeyedOperation op) { assert (op.getState() == OperationState.WRITE_QUEUED || op.getState() == OperationState.RETRY) : \"Who passed me an operation in the \" + op.getState() + \"state?\"; assert !op.isCancelled() : \"Attempted to clone a canceled op\"; assert !op.hasErrored() : \"Attempted to clone an errored op\"; Collection<Operation> rv = new ArrayList<Operation>(op.getKeys().size()); if (op instanceof GetOperation) { rv.addAll(cloneGet(op)); } else if (op instanceof ReplicaGetOperation) { rv.addAll(cloneGet(op)); } else if (op instanceof ReplicaGetsOperation) { ReplicaGetsOperation.Callback callback = (ReplicaGetsOperation.Callback) op.getCallback(); for (String k : op.getKeys()) { rv.add(replicaGets(k, ((ReplicaGetsOperation) op).getReplicaIndex(), callback)); } } else if (op instanceof GetsOperation) { GetsOperation.Callback callback = (GetsOperation.Callback) op.getCallback(); for (String k : op.getKeys()) { rv.add(gets(k, callback)); } } else if (op instanceof CASOperation) { CASOperation cop = (CASOperation) op; rv.add(cas(cop.getStoreType(), first(op.getKeys()), cop.getCasValue(), cop.getFlags(), cop.getExpiration(), cop.getData(), (StoreOperation.Callback) cop.getCallback())); } else if(op instanceof DeleteOperation) { rv.add(delete(first(op.getKeys()), (DeleteOperation.Callback)op.getCallback())); } else if (op instanceof MutatorOperation) { MutatorOperation mo = (MutatorOperation) op; rv.add(mutate(mo.getType(), first(op.getKeys()), mo.getBy(), mo.getDefault(), mo.getExpiration(), op.getCallback())); } else if (op instanceof StoreOperation) { StoreOperation so = (StoreOperation) op; rv.add(store(so.getStoreType(), first(op.getKeys()), so.getFlags(), so.getExpiration(), so.getData(), (StoreOperation.Callback) op.getCallback())); } else if (op instanceof ConcatenationOperation) { ConcatenationOperation c = (ConcatenationOperation) op; rv.add(cat(c.getStoreType(), c.getCasValue(), first(op.getKeys()), c.getData(), c.getCallback())); } else if(op instanceof GetAndTouchOperation) { GetAndTouchOperation gt = (GetAndTouchOperation) op; rv.add(getAndTouch(first(gt.getKeys()), gt.getExpiration(), (GetAndTouchOperation.Callback) gt.getCallback())); } else if (op instanceof TouchOperation) { TouchOperation tt = (TouchOperation) op; rv.add(touch(first(tt.getKeys()), tt.getExpiration(), tt.getCallback())); } else if (op instanceof GetlOperation) { GetlOperation gl = (GetlOperation) op; rv.add(getl(first(gl.getKeys()), gl.getExpiration(), (GetlOperation.Callback) gl.getCallback())); } else if (op instanceof ObserveOperation) { ObserveOperation oo = (ObserveOperation) op; rv.add(observe(first(oo.getKeys()), oo.getCasValue(), oo.getIndex(), (ObserveOperation.Callback) oo.getCallback())); } else { assert false : \"Unhandled operation type: \" + op.getClass(); } if (op instanceof VBucketAware) { VBucketAware vop = (VBucketAware) op; if (!vop.getNotMyVbucketNodes().isEmpty()) { for (Operation operation : rv) { if (operation instanceof VBucketAware) { Collection<MemcachedNode> notMyVbucketNodes = vop.getNotMyVbucketNodes(); ((VBucketAware) operation).setNotMyVbucketNodes(notMyVbucketNodes); } } } } return rv; } protected abstract Collection<? extends Operation> cloneGet(KeyedOperation op); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface CASOperation extends KeyedOperation {  StoreType getStoreType();  long getCasValue();  int getFlags();  int getExpiration();  byte[] getData(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import net.spy.memcached.CASResponse;  public class CASOperationStatus extends OperationStatus { private final CASResponse casResponse; public CASOperationStatus(boolean success, String msg, CASResponse cres, StatusCode code) { super(success, msg, code); casResponse = cres; }  public CASResponse getCASResponse() { return casResponse; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public class CancelledOperationStatus extends OperationStatus { public CancelledOperationStatus() { super(false, \"cancelled\", StatusCode.CANCELLED); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface ConcatenationOperation extends KeyedOperation {  ConcatenationType getStoreType();  long getCasValue();  byte[] getData(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public enum ConcatenationType {  append,  prepend }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface DeleteOperation extends KeyedOperation {  interface Callback extends OperationCallback {  void gotData(long cas); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface FlushOperation extends Operation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface GetAndTouchOperation extends KeyedOperation {  interface Callback extends OperationCallback {  void gotData(String key, int flags, long cas, byte[] data); }  int getExpiration(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface GetOperation extends KeyedOperation {  interface Callback extends OperationCallback {  void gotData(String key, int flags, byte[] data); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface GetlOperation extends KeyedOperation {  interface Callback extends OperationCallback {  void gotData(String key, int flags, long cas, byte[] data); } int getExpiration(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface GetsOperation extends KeyedOperation {  interface Callback extends OperationCallback {  void gotData(String key, int flags, long cas, byte[] data); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.util.Collection;  public interface KeyedOperation extends Operation {  Collection<String> getKeys(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue;  public class LinkedOperationQueueFactory implements OperationQueueFactory {  public BlockingQueue<Operation> create() { return new LinkedBlockingQueue<Operation>(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public class MultiGetOperationCallback extends MultiOperationCallback implements GetOperation.Callback { public MultiGetOperationCallback(OperationCallback original, int todo) { super(original, todo); } public void gotData(String key, int flags, byte[] data) { ((GetOperation.Callback) originalCallback).gotData(key, flags, data); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public class MultiGetsOperationCallback extends MultiOperationCallback implements GetsOperation.Callback { public MultiGetsOperationCallback(OperationCallback original, int todo) { super(original, todo); } public void gotData(String key, int flags, long cas, byte[] data) { ((GetsOperation.Callback) originalCallback).gotData(key, flags, cas, data); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.util.concurrent.atomic.AtomicInteger;  public abstract class MultiOperationCallback implements OperationCallback { private OperationStatus mostRecentStatus = null; private final AtomicInteger remaining; protected final OperationCallback originalCallback;  public MultiOperationCallback(OperationCallback original, int todo) { if (original instanceof MultiOperationCallback) { original = ((MultiOperationCallback) original).originalCallback; } originalCallback = original; remaining = new AtomicInteger(todo); } public void complete() { if (remaining.decrementAndGet() == 0) { originalCallback.receivedStatus(mostRecentStatus); originalCallback.complete(); } } public void receivedStatus(OperationStatus status) { mostRecentStatus = status; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public class MultiReplicaGetOperationCallback extends MultiOperationCallback implements ReplicaGetOperation.Callback { public MultiReplicaGetOperationCallback(OperationCallback original, int todo) { super(original, todo); } public void gotData(String key, int flags, byte[] data) { ((ReplicaGetOperation.Callback) originalCallback).gotData(key, flags, data); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public enum Mutator {  incr,  decr }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface MutatorOperation extends KeyedOperation {  Mutator getType();  long getBy();  long getDefault();  int getExpiration(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface NoopOperation extends Operation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import net.spy.memcached.MemcachedNode; import net.spy.memcached.ObserveResponse;  public interface ObserveOperation extends KeyedOperation {  long getCasValue();  int getIndex();  interface Callback extends OperationCallback {  void gotData(String key, long cas, MemcachedNode node, ObserveResponse or); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.io.IOException; import java.nio.ByteBuffer; import net.spy.memcached.MemcachedNode;  public interface Operation {  boolean isCancelled();  boolean hasErrored();  OperationException getException();  OperationCallback getCallback();  void cancel();  OperationState getState();  ByteBuffer getBuffer();  void writing();  void writeComplete();  void initialize();  void readFromBuffer(ByteBuffer data) throws IOException;  void handleRead(ByteBuffer data);  MemcachedNode getHandlingNode();  void setHandlingNode(MemcachedNode to);  void timeOut();  boolean isTimedOut();  boolean isTimedOut(long ttlMillis);  boolean isTimedOutUnsent();  long getWriteCompleteTimestamp();  byte[] getErrorMsg();  void addClone(Operation op);  int getCloneCount();  void setCloneCount(int count); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface OperationCallback {  void receivedStatus(OperationStatus status);  void complete(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public enum OperationErrorType {  GENERAL,  CLIENT,  SERVER; }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.io.IOException;  public class OperationException extends IOException { private static final long serialVersionUID = 1524499960923239786L; private final OperationErrorType type;  public OperationException() { super(); type = OperationErrorType.GENERAL; }  public OperationException(OperationErrorType eType, String msg) { super(msg); type = eType; }  public OperationErrorType getType() { return type; } @Override public String toString() { String rv = null; if (type == OperationErrorType.GENERAL) { rv = \"OperationException: \" + type; } else { rv = \"OperationException: \" + type + \": \" + getMessage(); } return rv; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.util.concurrent.BlockingQueue;  public interface OperationQueueFactory {  BlockingQueue<Operation> create(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public enum OperationState {  WRITE_QUEUED,  WRITING,  READING,  COMPLETE,  RETRY }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public class OperationStatus { private final boolean isSuccess; private final String message; private final StatusCode statusCode; public OperationStatus(boolean success, String msg) { this(success, msg, null); } public OperationStatus(boolean success, String msg, StatusCode code) { isSuccess = success; message = msg; statusCode = code; }  public boolean isSuccess() { return isSuccess; }  public String getMessage() { return message; }  public StatusCode getStatusCode() { return statusCode; } @Override public String toString() { return \"{OperationStatus success=\" + isSuccess + \": \" + message + \"}\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface ReplicaGetOperation extends KeyedOperation {  interface Callback extends OperationCallback {  void gotData(String key, int flags, byte[] data); } int getReplicaIndex(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface ReplicaGetsOperation extends KeyedOperation {  interface Callback extends OperationCallback {  void gotData(String key, int flags, long cas, byte[] data); } int getReplicaIndex(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface SASLAuthOperation extends Operation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface SASLMechsOperation extends Operation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface SASLStepOperation extends Operation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface StatsOperation extends Operation {  interface Callback extends OperationCallback {  void gotStat(String name, String val); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public enum StatusCode { SUCCESS, ERR_NOT_FOUND, ERR_EXISTS, ERR_2BIG, ERR_INVAL, ERR_NOT_STORED, ERR_DELTA_BADVAL, ERR_NOT_MY_VBUCKET, ERR_UNKNOWN_COMMAND, ERR_NO_MEM, ERR_NOT_SUPPORTED, ERR_INTERNAL, ERR_BUSY, ERR_TEMP_FAIL, CANCELLED, INTERRUPTED, TIMEDOUT, ERR_CLIENT; public static StatusCode fromBinaryCode(int code) { switch(code) { case 0x00: return SUCCESS; case 0x01: return ERR_NOT_FOUND; case 0x02: return ERR_EXISTS; case 0x03: return ERR_2BIG; case 0x04: return ERR_INVAL; case 0x05: return ERR_NOT_STORED; case 0x06: return ERR_DELTA_BADVAL; case 0x07: return ERR_NOT_MY_VBUCKET; case 0x81: return ERR_UNKNOWN_COMMAND; case 0x82: return ERR_NO_MEM; case 0x83: return ERR_NOT_SUPPORTED; case 0x84: return ERR_INTERNAL; case 0x85: return ERR_BUSY; case 0x86: return ERR_TEMP_FAIL; default: return ERR_CLIENT; } } public static StatusCode fromAsciiLine(String line) { if (line.equals(\"STORED\") || line.equals(\"DELETED\")) { return SUCCESS; } else if (line.equals(\"NOT_STORED\")) { return ERR_NOT_STORED; } else if (line.equals(\"EXISTS\")) { return ERR_EXISTS; } else if (line.equals(\"NOT_FOUND\")) { return ERR_NOT_FOUND; } else if (line.equals(\"ERROR\") || line.matches(\"^(CLIENT|SERVER)_ERROR.*\")) { return ERR_INTERNAL; } else { return ERR_CLIENT; } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface StoreOperation extends KeyedOperation {  StoreType getStoreType();  int getFlags();  int getExpiration();  byte[] getData();  interface Callback extends OperationCallback {  void gotData(String key, long cas); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public enum StoreType {  set,  add,  replace }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import net.spy.memcached.MemcachedNode; import net.spy.memcached.tapmessage.ResponseMessage; import net.spy.memcached.tapmessage.TapOpcode;  public interface TapOperation extends Operation {  interface Callback extends OperationCallback {  void gotData(ResponseMessage message); void gotAck(MemcachedNode node, TapOpcode opcode, int opaque); } void streamClosed(OperationState state); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public class TimedOutOperationStatus extends OperationStatus { public TimedOutOperationStatus() { super(false, \"timed out\", StatusCode.TIMEDOUT); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface TouchOperation extends KeyedOperation {  int getExpiration(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface UnlockOperation extends KeyedOperation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops; import java.util.Collection; import net.spy.memcached.MemcachedNode;  public interface VBucketAware { void setVBucket(String key, short vbucket); short getVBucket(String key); Collection<MemcachedNode> getNotMyVbucketNodes(); void addNotMyVbucketNode(MemcachedNode node); void setNotMyVbucketNodes(Collection<MemcachedNode> nodes); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.ops;  public interface VersionOperation extends Operation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol; import java.io.IOException; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.concurrent.atomic.AtomicLong; import net.spy.memcached.MemcachedNode; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.ops.CancelledOperationStatus; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationErrorType; import net.spy.memcached.ops.OperationException; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.ops.TimedOutOperationStatus;  public abstract class BaseOperationImpl extends SpyObject implements Operation {  public static final OperationStatus CANCELLED = new CancelledOperationStatus(); public static final OperationStatus TIMED_OUT= new TimedOutOperationStatus(); private volatile OperationState state = OperationState.WRITE_QUEUED; private ByteBuffer cmd = null; private boolean cancelled = false; private OperationException exception = null; protected OperationCallback callback = null; private volatile MemcachedNode handlingNode = null; private volatile boolean timedout; private long creationTime; private boolean timedOutUnsent = false; protected Collection<MemcachedNode> notMyVbucketNodes = new HashSet<MemcachedNode>(); private long writeCompleteTimestamp;  private List<Operation> clones = Collections.synchronizedList(new ArrayList<Operation>());  private volatile int cloneCount; public BaseOperationImpl() { super(); creationTime = System.nanoTime(); }  public final OperationCallback getCallback() { return callback; }  protected void setCallback(OperationCallback to) { callback = to; } public final synchronized boolean isCancelled() { return cancelled; } public final boolean hasErrored() { return exception != null; } public final OperationException getException() { return exception; } public final synchronized void cancel() { cancelled = true; synchronized (clones) { Iterator<Operation> i = clones.iterator(); while(i.hasNext()) { i.next().cancel(); } } wasCancelled(); callback.receivedStatus(CANCELLED); callback.complete(); }  protected void wasCancelled() { getLogger().debug(\"was cancelled.\"); } public final synchronized OperationState getState() { return state; } public final synchronized ByteBuffer getBuffer() { return cmd; }  protected final synchronized void setBuffer(ByteBuffer to) { assert to != null : \"Trying to set buffer to null\"; cmd = to; cmd.mark(); }  protected final synchronized void transitionState(OperationState newState) { getLogger().debug(\"Transitioned state from %s to %s\", state, newState); state = newState; "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  public class GetCallbackWrapper implements GetOperation.Callback { private static final OperationStatus END = new OperationStatus(true, \"END\", StatusCode.SUCCESS); private boolean completed = false; private int remainingKeys = 0; private GetOperation.Callback cb = null; public GetCallbackWrapper(int k, GetOperation.Callback c) { super(); remainingKeys = k; cb = c; } public void gotData(String key, int flags, byte[] data) { assert !completed : \"Got data for a completed wrapped op\"; cb.gotData(key, flags, data); if (--remainingKeys == 0) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Map; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.OperationStatus;  public class ProxyCallback implements GetOperation.Callback { private final Map<String, Collection<GetOperation.Callback>> callbacks = new HashMap<String, Collection<GetOperation.Callback>>(); private final Collection<GetOperation.Callback> allCallbacks = new ArrayList<GetOperation.Callback>(); public void addCallbacks(GetOperation o) { GetOperation.Callback c = new GetCallbackWrapper(o.getKeys().size(), (GetOperation.Callback) o.getCallback()); allCallbacks.add(c); for (String s : o.getKeys()) { Collection<GetOperation.Callback> cbs = callbacks.get(s); if (cbs == null) { cbs = new ArrayList<GetOperation.Callback>(); callbacks.put(s, cbs); } cbs.add(c); } } public void gotData(String key, int flags, byte[] data) { Collection<GetOperation.Callback> cbs = callbacks.get(key); assert cbs != null : \"No callbacks for key \" + key; for (GetOperation.Callback c : cbs) { c.gotData(key, flags, data); } } public void receivedStatus(OperationStatus status) { for (GetOperation.Callback c : allCallbacks) { c.receivedStatus(status); } } public void complete() { for (GetOperation.Callback c : allCallbacks) { c.complete(); } } public int numKeys() { return callbacks.size(); } public int numCallbacks() { return allCallbacks.size(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol; import java.io.IOException; import java.net.SocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.SocketChannel; import java.util.ArrayList; import java.util.Collection; import java.util.concurrent.BlockingQueue; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import net.spy.memcached.ConnectionFactory; import net.spy.memcached.FailureMode; import net.spy.memcached.MemcachedConnection; import net.spy.memcached.MemcachedNode; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationState; import net.spy.memcached.protocol.binary.TapAckOperationImpl;  public abstract class TCPMemcachedNodeImpl extends SpyObject implements MemcachedNode { private final SocketAddress socketAddress; private final ByteBuffer rbuf; private final ByteBuffer wbuf; protected final BlockingQueue<Operation> writeQ; private final BlockingQueue<Operation> readQ; private final BlockingQueue<Operation> inputQueue; private final long opQueueMaxBlockTime; private final long authWaitTime; private final ConnectionFactory connectionFactory; private AtomicInteger reconnectAttempt = new AtomicInteger(1); private SocketChannel channel; private int toWrite = 0; protected Operation optimizedOp = null; private volatile SelectionKey sk = null; private boolean shouldAuth = false; private CountDownLatch authLatch; private ArrayList<Operation> reconnectBlocked; private long defaultOpTimeout; private volatile long lastReadTimestamp = System.nanoTime(); private MemcachedConnection connection; "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.net.SocketAddress; import java.nio.channels.SocketChannel; import java.util.concurrent.BlockingQueue; import net.spy.memcached.ConnectionFactory; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationState; import net.spy.memcached.protocol.ProxyCallback; import net.spy.memcached.protocol.TCPMemcachedNodeImpl;  public final class AsciiMemcachedNodeImpl extends TCPMemcachedNodeImpl { public AsciiMemcachedNodeImpl(SocketAddress sa, SocketChannel c, int bufSize, BlockingQueue<Operation> rq, BlockingQueue<Operation> wq, BlockingQueue<Operation> iq, Long opQueueMaxBlockTimeNs, long dt, long at, ConnectionFactory fa) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import net.spy.memcached.ops.BaseOperationFactory; import net.spy.memcached.ops.CASOperation; import net.spy.memcached.ops.ConcatenationOperation; import net.spy.memcached.ops.ConcatenationType; import net.spy.memcached.ops.DeleteOperation; import net.spy.memcached.ops.FlushOperation; import net.spy.memcached.ops.GetAndTouchOperation; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.GetlOperation; import net.spy.memcached.ops.GetsOperation; import net.spy.memcached.ops.KeyedOperation; import net.spy.memcached.ops.MultiGetOperationCallback; import net.spy.memcached.ops.Mutator; import net.spy.memcached.ops.MutatorOperation; import net.spy.memcached.ops.NoopOperation; import net.spy.memcached.ops.ObserveOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.ReplicaGetOperation; import net.spy.memcached.ops.ReplicaGetsOperation; import net.spy.memcached.ops.SASLAuthOperation; import net.spy.memcached.ops.SASLMechsOperation; import net.spy.memcached.ops.SASLStepOperation; import net.spy.memcached.ops.StatsOperation; import net.spy.memcached.ops.StatsOperation.Callback; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.ops.StoreType; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.ops.TouchOperation; import net.spy.memcached.ops.UnlockOperation; import net.spy.memcached.ops.VersionOperation; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.TapOpcode; import javax.security.auth.callback.CallbackHandler; import java.util.ArrayList; import java.util.Collection; import java.util.Map;  public class AsciiOperationFactory extends BaseOperationFactory { public DeleteOperation delete(String key, DeleteOperation.Callback cb) { return new DeleteOperationImpl(key, cb); } public DeleteOperation delete(String key, long cas, DeleteOperation.Callback cb) { throw new UnsupportedOperationException(\"Delete with CAS is not supported \" + \"for ASCII protocol\"); } public FlushOperation flush(int delay, OperationCallback cb) { return new FlushOperationImpl(delay, cb); } public GetAndTouchOperation getAndTouch(String key, int expiration, GetAndTouchOperation.Callback cb) { throw new UnsupportedOperationException(\"Get and touch is not supported \" + \"for ASCII protocol\"); } public GetOperation get(String key, GetOperation.Callback cb) { return new GetOperationImpl(key, cb); } public GetOperation get(Collection<String> keys, GetOperation.Callback cb) { return new GetOperationImpl(keys, cb); } public GetlOperation getl(String key, int exp, GetlOperation.Callback cb) { return new GetlOperationImpl(key, exp, cb); } public ObserveOperation observe(String key, long casId, int index, ObserveOperation.Callback cb) { throw new UnsupportedOperationException(\"Observe is not supported \" + \"for ASCII protocol\"); } public UnlockOperation unlock(String key, long casId, OperationCallback cb) { return new UnlockOperationImpl(key, casId, cb); } public GetsOperation gets(String key, GetsOperation.Callback cb) { return new GetsOperationImpl(key, cb); } public StatsOperation keyStats(String key, Callback cb) { throw new UnsupportedOperationException(\"Key stats are not supported \" + \"for ASCII protocol\"); } public MutatorOperation mutate(Mutator m, String key, long by, long exp, int def, OperationCallback cb) { return new MutatorOperationImpl(m, key, by, cb); } public StatsOperation stats(String arg, StatsOperation.Callback cb) { return new StatsOperationImpl(arg, cb); } public StoreOperation store(StoreType storeType, String key, int flags, int exp, byte[] data, StoreOperation.Callback cb) { return new StoreOperationImpl(storeType, key, flags, exp, data, cb); } public TouchOperation touch(String key, int expiration, OperationCallback cb) { return new TouchOperationImpl(key, expiration, cb); } public VersionOperation version(OperationCallback cb) { return new VersionOperationImpl(cb); } public NoopOperation noop(OperationCallback cb) { return new VersionOperationImpl(cb); } public CASOperation cas(StoreType type, String key, long casId, int flags, int exp, byte[] data, StoreOperation.Callback cb) { return new CASOperationImpl(key, casId, flags, exp, data, cb); } public ConcatenationOperation cat(ConcatenationType catType, long casId, String key, byte[] data, OperationCallback cb) { return new ConcatenationOperationImpl(catType, key, data, cb); } @Override protected Collection<? extends Operation> cloneGet(KeyedOperation op) { Collection<Operation> rv = new ArrayList<Operation>(); GetOperation.Callback callback = new MultiGetOperationCallback(op.getCallback(), op.getKeys().size()); for (String k : op.getKeys()) { rv.add(get(k, callback)); } return rv; } public SASLMechsOperation saslMechs(OperationCallback cb) { throw new UnsupportedOperationException(\"SASL is not supported for \" + \"ASCII protocol\"); } public SASLStepOperation saslStep(String[] mech, byte[] challenge, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb) { throw new UnsupportedOperationException(\"SASL is not supported for \" + \"ASCII protocol\"); } public SASLAuthOperation saslAuth(String[] mech, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb) { throw new UnsupportedOperationException(\"SASL is not supported for \" + \"ASCII protocol\"); } @Override public TapOperation tapBackfill(String id, long date, OperationCallback cb) { throw new UnsupportedOperationException(\"Tap is not supported for ASCII\" + \" protocol\"); } @Override public TapOperation tapCustom(String id, RequestMessage message, OperationCallback cb) { throw new UnsupportedOperationException(\"Tap is not supported for ASCII\" + \" protocol\"); } @Override public TapOperation tapAck(TapOpcode opcode, int opaque, OperationCallback cb) { throw new UnsupportedOperationException(\"Tap is not supported for ASCII\" + \" protocol\"); } @Override public TapOperation tapDump(String id, OperationCallback cb) { throw new UnsupportedOperationException(\"Tap is not supported for ASCII\" + \" protocol\"); } @Override public ReplicaGetOperation replicaGet(String key, int index, ReplicaGetOperation.Callback callback) { throw new UnsupportedOperationException(\"Replica get is not supported \" + \"for ASCII protocol\"); } @Override public ReplicaGetsOperation replicaGets(String key, int index, ReplicaGetsOperation.Callback callback) { throw new UnsupportedOperationException(\"Replica gets is not supported \" + \"for ASCII protocol\"); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Collections; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.GetAndTouchOperation; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.GetlOperation; import net.spy.memcached.ops.GetsOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.util.StringUtils;  public abstract class BaseGetOpImpl extends OperationImpl { private static final OperationStatus END = new OperationStatus(true, \"END\", StatusCode.SUCCESS); private static final OperationStatus NOT_FOUND = new OperationStatus(false, \"NOT_FOUND\", StatusCode.ERR_NOT_FOUND); private static final OperationStatus LOCK_ERROR = new OperationStatus(false, \"LOCK_ERROR\", StatusCode.ERR_TEMP_FAIL); private static final byte[] RN_BYTES = \"\\r\\n\".getBytes(); private final String cmd; private final Collection<String> keys; private String currentKey = null; protected final int exp; private final byte[] expBytes; private long casValue = 0; private int currentFlags = 0; private byte[] data = null; private int readOffset = 0; private byte lookingFor = '\\0'; private boolean hasValue; public BaseGetOpImpl(String c, OperationCallback cb, Collection<String> k) { super(cb); cmd = c; keys = k; exp = 0; expBytes = null; hasValue = false; } public BaseGetOpImpl(String c, int e, OperationCallback cb, String k) { super(cb); cmd = c; keys = Collections.singleton(k); exp = e; expBytes = String.valueOf(e).getBytes(); hasValue = false; }  public final Collection<String> getKeys() { return keys; } @Override public final void handleLine(String line) { if (line.equals(\"END\")) { getLogger().debug(\"Get complete!\"); if (hasValue) { getCallback().receivedStatus(END); } else { getCallback().receivedStatus(NOT_FOUND); } transitionState(OperationState.COMPLETE); data = null; } else if (line.startsWith(\"VALUE \")) { getLogger().debug(\"Got line %s\", line); String[] stuff = line.split(\" \"); assert stuff[0].equals(\"VALUE\"); currentKey = stuff[1]; currentFlags = Integer.parseInt(stuff[2]); data = new byte[Integer.parseInt(stuff[3])]; if (stuff.length > 4) { casValue = Long.parseLong(stuff[4]); } readOffset = 0; hasValue = true; getLogger().debug(\"Set read type to data\"); setReadType(OperationReadType.DATA); } else if (line.equals(\"LOCK_ERROR\")) { getCallback().receivedStatus(LOCK_ERROR); transitionState(OperationState.COMPLETE); } else { assert false : \"Unknown line type: \" + line; } } @Override public final void handleRead(ByteBuffer b) { assert currentKey != null; assert data != null; "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Collections; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  abstract class BaseStoreOperationImpl extends OperationImpl { private static final int OVERHEAD = 32; private static final OperationStatus STORED = new OperationStatus(true, \"STORED\", StatusCode.SUCCESS); protected final String type; protected final String key; protected final int flags; protected final int exp; protected final byte[] data; public BaseStoreOperationImpl(String t, String k, int f, int e, byte[] d, OperationCallback cb) { super(cb); type = t; key = k; flags = f; exp = e; data = d; } @Override public void handleLine(String line) { assert getState() == OperationState.READING : \"Read ``\" + line + \"'' when in \" + getState() + \" state\"; getCallback().receivedStatus(matchStatus(line, STORED)); transitionState(OperationState.COMPLETE); } @Override public void initialize() { ByteBuffer bb = ByteBuffer.allocate(data.length + KeyUtil.getKeyBytes(key).length + OVERHEAD); setArguments(bb, type, key, flags, exp, data.length); assert bb.remaining() >= data.length + 2 : \"Not enough room in buffer,\" + \" need another \" + (2 + data.length - bb.remaining()); bb.put(data); bb.put(CRLF); bb.flip(); setBuffer(bb); } @Override protected void wasCancelled() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Collections; import net.spy.memcached.CASResponse; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.CASOperation; import net.spy.memcached.ops.CASOperationStatus; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.ops.StoreType; class CASOperationImpl extends OperationImpl implements CASOperation { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import net.spy.memcached.ops.ConcatenationOperation; import net.spy.memcached.ops.ConcatenationType; import net.spy.memcached.ops.OperationCallback;  public class ConcatenationOperationImpl extends BaseStoreOperationImpl implements ConcatenationOperation { private final ConcatenationType concatType; public ConcatenationOperationImpl(ConcatenationType t, String k, byte[] d, OperationCallback cb) { super(t.name(), k, 0, 0, d, cb); concatType = t; } public long getCasValue() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Collections; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.DeleteOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  final class DeleteOperationImpl extends OperationImpl implements DeleteOperation { private static final int OVERHEAD = 32; private static final OperationStatus DELETED = new OperationStatus(true, \"DELETED\", StatusCode.SUCCESS); private static final OperationStatus NOT_FOUND = new OperationStatus(false, \"NOT_FOUND\", StatusCode.ERR_NOT_FOUND); private final String key; public DeleteOperationImpl(String k, OperationCallback cb) { super(cb); key = k; } @Override public void handleLine(String line) { getLogger().debug(\"Delete of %s returned %s\", key, line); getCallback().receivedStatus(matchStatus(line, DELETED, NOT_FOUND)); transitionState(OperationState.COMPLETE); } @Override public void initialize() { ByteBuffer b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length + OVERHEAD); setArguments(b, \"delete\", key); b.flip(); setBuffer(b); } public Collection<String> getKeys() { return Collections.singleton(key); } @Override public String toString() { return \"Cmd: delete Key: \" + key; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import net.spy.memcached.ops.FlushOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  final class FlushOperationImpl extends OperationImpl implements FlushOperation { private static final byte[] FLUSH = \"flush_all\\r\\n\".getBytes(); private static final OperationStatus OK = new OperationStatus(true, \"OK\", StatusCode.SUCCESS); private final int delay; public FlushOperationImpl(int d, OperationCallback cb) { super(cb); delay = d; } @Override public void handleLine(String line) { getLogger().debug(\"Flush completed successfully\"); getCallback().receivedStatus(matchStatus(line, OK)); transitionState(OperationState.COMPLETE); } @Override public void initialize() { ByteBuffer b = null; if (delay == -1) { b = ByteBuffer.wrap(FLUSH); } else { b = ByteBuffer.allocate(32); b.put((\"flush_all \" + delay + \"\\r\\n\").getBytes()); b.flip(); } setBuffer(b); } @Override public String toString() { return \"Cmd: flush_all Delay: \" + delay; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import net.spy.memcached.ops.GetAndTouchOperation;  public class GetAndTouchOperationImpl extends BaseGetOpImpl implements GetAndTouchOperation { public GetAndTouchOperationImpl(String c, int e, GetAndTouchOperation.Callback cb, String k) { super(c, e, cb, k); } @Override public int getExpiration() { return exp; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import net.spy.memcached.ops.GetOperation;  class GetOperationImpl extends BaseGetOpImpl implements GetOperation { private static final String CMD = \"get\"; public GetOperationImpl(String key, GetOperation.Callback c) { super(CMD, c, Collections.singleton(key)); } public GetOperationImpl(Collection<String> k, GetOperation.Callback c) { super(CMD, c, new HashSet<String>(k)); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import net.spy.memcached.ops.GetlOperation;  class GetlOperationImpl extends BaseGetOpImpl implements GetlOperation { private static final String CMD = \"getl\"; private final int exp; public GetlOperationImpl(String key, int exp, GetlOperation.Callback c) { super(CMD, exp, c, key); this.exp = exp; } @Override public int getExpiration() { return exp; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.util.Collections; import net.spy.memcached.ops.GetsOperation;  class GetsOperationImpl extends BaseGetOpImpl implements GetsOperation { private static final String CMD = \"gets\"; public GetsOperationImpl(String key, GetsOperation.Callback cb) { super(CMD, cb, Collections.singleton(key)); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Collections; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.Mutator; import net.spy.memcached.ops.MutatorOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  final class MutatorOperationImpl extends OperationImpl implements MutatorOperation { public static final int OVERHEAD = 32; private static final OperationStatus NOT_FOUND = new OperationStatus(false, \"NOT_FOUND\", StatusCode.ERR_NOT_FOUND); private final Mutator mutator; private final String key; private final long amount; public MutatorOperationImpl(Mutator m, String k, long amt, OperationCallback c) { super(c); mutator = m; key = k; amount = amt; } @Override public void handleLine(String line) { getLogger().debug(\"Result: %s\", line); OperationStatus found = null; if (line.equals(\"NOT_FOUND\")) { found = NOT_FOUND; } else { found = new OperationStatus(true, line, StatusCode.SUCCESS); } getCallback().receivedStatus(found); transitionState(OperationState.COMPLETE); } @Override public void initialize() { int size = KeyUtil.getKeyBytes(key).length + OVERHEAD; ByteBuffer b = ByteBuffer.allocate(size); setArguments(b, mutator.name(), key, amount); b.flip(); setBuffer(b); } @Override protected void wasCancelled() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.nio.ByteBuffer; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationErrorType; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.protocol.BaseOperationImpl;  abstract class OperationImpl extends BaseOperationImpl implements Operation { protected static final byte[] CRLF = { '\\r', '\\n' }; private static final String CHARSET = \"UTF-8\"; private final ByteArrayOutputStream byteBuffer = new ByteArrayOutputStream(); private OperationReadType readType = OperationReadType.LINE; private boolean foundCr; private byte[] errorMsg; protected OperationImpl() { } protected OperationImpl(OperationCallback cb) { callback = cb; }  protected final OperationStatus matchStatus(String line, OperationStatus... statii) { OperationStatus rv = null; for (OperationStatus status : statii) { if (line.equals(status.getMessage())) { rv = status; } } if (rv == null) { rv = new OperationStatus(false, line, StatusCode.fromAsciiLine(line)); } return rv; }  protected final OperationReadType getReadType() { return readType; }  protected final void setReadType(OperationReadType to) { readType = to; }  protected final void setArguments(ByteBuffer bb, Object... args) { boolean wasFirst = true; for (Object o : args) { if (wasFirst) { wasFirst = false; } else { bb.put((byte) ' '); } bb.put(KeyUtil.getKeyBytes(String.valueOf(o))); } bb.put(CRLF); } OperationErrorType classifyError(String line) { OperationErrorType rv = null; if (line.startsWith(\"ERROR\")) { rv = OperationErrorType.GENERAL; } else if (line.startsWith(\"CLIENT_ERROR\")) { rv = OperationErrorType.CLIENT; } else if (line.startsWith(\"SERVER_ERROR\")) { rv = OperationErrorType.SERVER; } return rv; } @Override public void readFromBuffer(ByteBuffer data) throws IOException { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii;  enum OperationReadType {  LINE,  DATA }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.util.HashSet; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.protocol.ProxyCallback;  final class OptimizedGetImpl extends GetOperationImpl { private final ProxyCallback pcb;  public OptimizedGetImpl(GetOperation firstGet) { super(new HashSet<String>(), new ProxyCallback()); pcb = (ProxyCallback) getCallback(); addOperation(firstGet); }  public void addOperation(GetOperation o) { getKeys().addAll(o.getKeys()); pcb.addCallbacks(o); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import java.util.Arrays; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatsOperation; import net.spy.memcached.ops.StatusCode;  final class StatsOperationImpl extends OperationImpl implements StatsOperation { private static final OperationStatus END = new OperationStatus(true, \"END\", StatusCode.SUCCESS); private static final byte[] MSG = \"stats\\r\\n\".getBytes(); private final byte[] msg; private final StatsOperation.Callback cb; public StatsOperationImpl(String arg, StatsOperation.Callback c) { super(c); cb = c; if (arg == null) { msg = MSG; } else { msg = (\"stats \" + arg + \"\\r\\n\").getBytes(); } } @Override public void handleLine(String line) { if (line.equals(\"END\")) { cb.receivedStatus(END); transitionState(OperationState.COMPLETE); } else { String[] parts = line.split(\" \", 3); assert parts.length == 3; cb.gotStat(parts[1], parts[2]); } } @Override public void initialize() { setBuffer(ByteBuffer.wrap(msg)); } @Override protected void wasCancelled() { cb.receivedStatus(CANCELLED); } @Override public String toString() { return \"Cmd: \" + Arrays.toString(msg); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.ops.StoreType;  final class StoreOperationImpl extends BaseStoreOperationImpl implements StoreOperation { private final StoreType storeType; public StoreOperationImpl(StoreType t, String k, int f, int e, byte[] d, OperationCallback cb) { super(t.name(), k, f, e, d, cb); storeType = t; } public StoreType getStoreType() { return storeType; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.ops.TouchOperation; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Collections;  final class TouchOperationImpl extends OperationImpl implements TouchOperation { private static final int OVERHEAD = 9; private static final OperationStatus OK = new OperationStatus(true, \"TOUCHED\", StatusCode.SUCCESS); private final String key; private final int exp; public TouchOperationImpl(String k, int t, OperationCallback cb) { super(cb); key = k; exp = t; } "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Collections; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.ops.UnlockOperation;  final class UnlockOperationImpl extends OperationImpl implements UnlockOperation { private static final int OVERHEAD = 32; private static final OperationStatus UNLOCKED = new OperationStatus(true, \"UNLOCKED\", StatusCode.SUCCESS); private static final OperationStatus NOT_FOUND = new OperationStatus(false, \"NOT_FOUND\", StatusCode.ERR_NOT_FOUND); private static final String CMD = \"unl\"; private final String key; private final long cas; public UnlockOperationImpl(String k, long casId, OperationCallback cb) { super(cb); key = k; cas = casId; } @Override public void handleLine(String line) { getLogger().debug(\"Unlock of %s returned %s\", key, line); getCallback().receivedStatus(matchStatus(line, UNLOCKED, NOT_FOUND)); transitionState(OperationState.COMPLETE); } @Override public void initialize() { ByteBuffer b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length + OVERHEAD); setArguments(b, CMD, key, cas); b.flip(); setBuffer(b); } @Override public Collection<String> getKeys() { return Collections.singleton(key); } @Override public String toString() { return \"Cmd: \" + CMD + \" Key: \" + key + \" Cas Value: \" + cas; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.ascii; import java.nio.ByteBuffer; import net.spy.memcached.ops.NoopOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.ops.VersionOperation;  final class VersionOperationImpl extends OperationImpl implements VersionOperation, NoopOperation { private static final byte[] REQUEST = \"version\\r\\n\".getBytes(); public VersionOperationImpl(OperationCallback c) { super(c); } @Override public void handleLine(String line) { assert line.startsWith(\"VERSION \"); getCallback().receivedStatus(new OperationStatus(true, line.substring(\"VERSION \".length()), StatusCode.SUCCESS)); transitionState(OperationState.COMPLETE); } @Override public void initialize() { setBuffer(ByteBuffer.wrap(REQUEST)); } @Override public String toString() { return \"Cmd: version\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.net.SocketAddress; import java.nio.channels.SocketChannel; import java.util.concurrent.BlockingQueue; import net.spy.memcached.ConnectionFactory; import net.spy.memcached.ops.CASOperation; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.protocol.ProxyCallback; import net.spy.memcached.protocol.TCPMemcachedNodeImpl;  public class BinaryMemcachedNodeImpl extends TCPMemcachedNodeImpl { private static final int MAX_GET_OPTIMIZATION_COUNT = 4096; private static final int MAX_SET_OPTIMIZATION_COUNT = 65535; private static final int MAX_SET_OPTIMIZATION_BYTES = 2 * 1024 * 1024; public BinaryMemcachedNodeImpl(SocketAddress sa, SocketChannel c, int bufSize, BlockingQueue<Operation> rq, BlockingQueue<Operation> wq, BlockingQueue<Operation> iq, Long opQueueMaxBlockTimeNs, boolean waitForAuth, long dt, long at, ConnectionFactory fa) { super(sa, c, bufSize, rq, wq, iq, opQueueMaxBlockTimeNs, waitForAuth, dt, at, fa); } @Override protected void optimize() { Operation firstOp = writeQ.peek(); if (firstOp instanceof GetOperation) { optimizeGets(); } else if (firstOp instanceof CASOperation) { optimizeSets(); } } private void optimizeGets() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.BaseOperationFactory; import net.spy.memcached.ops.CASOperation; import net.spy.memcached.ops.ConcatenationOperation; import net.spy.memcached.ops.ConcatenationType; import net.spy.memcached.ops.DeleteOperation; import net.spy.memcached.ops.FlushOperation; import net.spy.memcached.ops.GetAndTouchOperation; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.GetOperation.Callback; import net.spy.memcached.ops.GetlOperation; import net.spy.memcached.ops.GetsOperation; import net.spy.memcached.ops.KeyedOperation; import net.spy.memcached.ops.MultiGetOperationCallback; import net.spy.memcached.ops.MultiGetsOperationCallback; import net.spy.memcached.ops.MultiReplicaGetOperationCallback; import net.spy.memcached.ops.Mutator; import net.spy.memcached.ops.MutatorOperation; import net.spy.memcached.ops.NoopOperation; import net.spy.memcached.ops.ObserveOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.ReplicaGetOperation; import net.spy.memcached.ops.ReplicaGetsOperation; import net.spy.memcached.ops.SASLAuthOperation; import net.spy.memcached.ops.SASLMechsOperation; import net.spy.memcached.ops.SASLStepOperation; import net.spy.memcached.ops.StatsOperation; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.ops.StoreType; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.ops.TouchOperation; import net.spy.memcached.ops.UnlockOperation; import net.spy.memcached.ops.VersionOperation; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.TapOpcode; import javax.security.auth.callback.CallbackHandler; import java.util.ArrayList; import java.util.Collection; import java.util.Map;  public class BinaryOperationFactory extends BaseOperationFactory { public DeleteOperation delete(String key, DeleteOperation.Callback operationCallback) { return new DeleteOperationImpl(key, operationCallback); } public DeleteOperation delete(String key, long cas, DeleteOperation.Callback operationCallback) { return new DeleteOperationImpl(key, cas, operationCallback); } public UnlockOperation unlock(String key, long casId, OperationCallback cb) { return new UnlockOperationImpl(key, casId, cb); } public ObserveOperation observe(String key, long casId, int index, ObserveOperation.Callback cb) { return new ObserveOperationImpl(key, casId, index, cb); } public FlushOperation flush(int delay, OperationCallback cb) { return new FlushOperationImpl(cb); } public GetAndTouchOperation getAndTouch(String key, int expiration, GetAndTouchOperation.Callback cb) { return new GetAndTouchOperationImpl(key, expiration, cb); } public GetOperation get(String key, Callback callback) { return new GetOperationImpl(key, callback); } public ReplicaGetOperation replicaGet(String key, int index, ReplicaGetOperation.Callback callback) { return new ReplicaGetOperationImpl(key, index, callback); } public ReplicaGetsOperation replicaGets(String key, int index, ReplicaGetsOperation.Callback callback) { return new ReplicaGetsOperationImpl(key, index, callback); } public GetOperation get(Collection<String> value, Callback cb) { return new MultiGetOperationImpl(value, cb); } public GetlOperation getl(String key, int exp, GetlOperation.Callback cb) { return new GetlOperationImpl(key, exp, cb); } public GetsOperation gets(String key, GetsOperation.Callback cb) { return new GetsOperationImpl(key, cb); } public StatsOperation keyStats(String key, StatsOperation.Callback cb) { return new KeyStatsOperationImpl(key, cb); } public MutatorOperation mutate(Mutator m, String key, long by, long def, int exp, OperationCallback cb) { return new MutatorOperationImpl(m, key, by, def, exp, cb); } public StatsOperation stats(String arg, net.spy.memcached.ops.StatsOperation.Callback cb) { return new StatsOperationImpl(arg, cb); } public StoreOperation store(StoreType storeType, String key, int flags, int exp, byte[] data, StoreOperation.Callback cb) { return new StoreOperationImpl(storeType, key, flags, exp, data, 0, cb); } public TouchOperation touch(String key, int expiration, OperationCallback cb) { return new TouchOperationImpl(key, expiration, cb); } public VersionOperation version(OperationCallback cb) { return new VersionOperationImpl(cb); } public NoopOperation noop(OperationCallback cb) { return new NoopOperationImpl(cb); } public CASOperation cas(StoreType type, String key, long casId, int flags, int exp, byte[] data, StoreOperation.Callback cb) { return new StoreOperationImpl(type, key, flags, exp, data, casId, cb); } public ConcatenationOperation cat(ConcatenationType catType, long casId, String key, byte[] data, OperationCallback cb) { return new ConcatenationOperationImpl(catType, key, data, casId, cb); } @Override protected Collection<? extends Operation> cloneGet(KeyedOperation op) { Collection<Operation> rv = new ArrayList<Operation>(); GetOperation.Callback getCb = null; GetsOperation.Callback getsCb = null; ReplicaGetOperation.Callback replicaGetCb = null; if (op.getCallback() instanceof GetOperation.Callback) { getCb = new MultiGetOperationCallback(op.getCallback(), op.getKeys().size()); } else if(op.getCallback() instanceof ReplicaGetOperation.Callback) { replicaGetCb = new MultiReplicaGetOperationCallback(op.getCallback(), op.getKeys().size()); } else { getsCb = new MultiGetsOperationCallback(op.getCallback(), op.getKeys().size()); } for (String k : op.getKeys()) { if(getCb != null) { rv.add(get(k, getCb)); } else if(getsCb != null) { rv.add(gets(k, getsCb)); } else { rv.add(replicaGet(k, ((ReplicaGetOperationImpl)op).getReplicaIndex() ,replicaGetCb)); } } return rv; } public SASLAuthOperation saslAuth(String[] mech, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb) { return new SASLAuthOperationImpl(mech, serverName, props, cbh, cb); } public SASLMechsOperation saslMechs(OperationCallback cb) { return new SASLMechsOperationImpl(cb); } public SASLStepOperation saslStep(String[] mech, byte[] challenge, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb) { return new SASLStepOperationImpl(mech, challenge, serverName, props, cbh, cb); } public TapOperation tapBackfill(String id, long date, OperationCallback cb) { return new TapBackfillOperationImpl(id, date, cb); } public TapOperation tapCustom(String id, RequestMessage message, OperationCallback cb) { return new TapCustomOperationImpl(id, message, cb); } public TapOperation tapAck(TapOpcode opcode, int opaque, OperationCallback cb) { return new TapAckOperationImpl(opcode, opaque, cb); } public TapOperation tapDump(String id, OperationCallback cb) { return new TapDumpOperationImpl(id, cb); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.ConcatenationOperation; import net.spy.memcached.ops.ConcatenationType; import net.spy.memcached.ops.OperationCallback; class ConcatenationOperationImpl extends SingleKeyOperationImpl implements ConcatenationOperation { private static final int APPEND = 0x0e; private static final int PREPEND = 0x0f; private final long cas; private final ConcatenationType catType; private final byte[] data; private static byte cmdMap(ConcatenationType t) { byte rv; switch (t) { case append: rv = APPEND; break; case prepend: rv = PREPEND; break; default: rv = DUMMY_OPCODE; } "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.DeleteOperation; class DeleteOperationImpl extends SingleKeyOperationImpl implements DeleteOperation { private static final byte CMD = 0x04; private final long cas; public DeleteOperationImpl(String k, DeleteOperation.Callback cb) { this(k, 0, cb); } public DeleteOperationImpl(String k, long c, DeleteOperation.Callback cb) { super(CMD, generateOpaque(), k, cb); cas = c; } @Override public void initialize() { prepareBuffer(key, cas, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { super.decodePayload(pl); ((DeleteOperation.Callback) getCallback()).gotData(responseCas); } @Override public String toString() { return super.toString() + \" Cas: \" + cas; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.FlushOperation; import net.spy.memcached.ops.OperationCallback; class FlushOperationImpl extends OperationImpl implements FlushOperation { private static final byte CMD = 0x08; private final int delay; public FlushOperationImpl(OperationCallback cb) { this(0, cb); } public FlushOperationImpl(int d, OperationCallback cb) { super(CMD, generateOpaque(), cb); delay = d; } @Override public void initialize() { prepareBuffer(\"\", 0, EMPTY_BYTES, delay); } @Override public String toString() { return super.toString() + \" Delay: \" + delay; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.GetAndTouchOperation;  public class GetAndTouchOperationImpl extends SingleKeyOperationImpl implements GetAndTouchOperation { static final byte GAT_CMD = 0x1d;  static final int EXTRA_HDR_LEN = 4; private final int exp; public GetAndTouchOperationImpl(String k, int e, GetAndTouchOperation.Callback cb) { super(GAT_CMD, generateOpaque(), k, cb); exp = e; } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES, exp); } @Override protected void decodePayload(byte[] pl) { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN]; System.arraycopy(pl, EXTRA_HDR_LEN, data, 0, pl.length - EXTRA_HDR_LEN); GetAndTouchOperation.Callback gcb = (GetAndTouchOperation.Callback) getCallback(); gcb.gotData(key, flags, responseCas, data); getCallback().receivedStatus(STATUS_OK); } @Override public String toString() { return super.toString() + \" Exp: \" + exp; } @Override public int getExpiration() { return exp; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.GetOperation;  class GetOperationImpl extends SingleKeyOperationImpl implements GetOperation { static final byte GET_CMD = 0x00;  static final int EXTRA_HDR_LEN = 4; public GetOperationImpl(String k, GetOperation.Callback cb) { super(GET_CMD, generateOpaque(), k, cb); } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN]; System.arraycopy(pl, EXTRA_HDR_LEN, data, 0, pl.length - EXTRA_HDR_LEN); GetOperation.Callback gcb = (GetOperation.Callback) getCallback(); gcb.gotData(key, flags, data); getCallback().receivedStatus(STATUS_OK); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.GetlOperation;  public class GetlOperationImpl extends SingleKeyOperationImpl implements GetlOperation { static final byte GETL_CMD = (byte) 0x94;  static final int EXTRA_HDR_LEN = 4; private final int exp; public GetlOperationImpl(String k, int e, GetlOperation.Callback cb) { super(GETL_CMD, generateOpaque(), k, cb); exp = e; } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES, exp); } @Override protected void decodePayload(byte[] pl) { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN]; System.arraycopy(pl, EXTRA_HDR_LEN, data, 0, pl.length - EXTRA_HDR_LEN); GetlOperation.Callback gcb = (GetlOperation.Callback) getCallback(); gcb.gotData(key, flags, responseCas, data); getCallback().receivedStatus(STATUS_OK); } @Override public String toString() { return super.toString() + \" Exp: \" + exp; } @Override public int getExpiration() { return exp; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.GetsOperation;  public class GetsOperationImpl extends SingleKeyOperationImpl implements GetsOperation { static final byte GET_CMD = 0x00;  static final int EXTRA_HDR_LEN = 4; public GetsOperationImpl(String k, GetsOperation.Callback cb) { super(GET_CMD, generateOpaque(), k, cb); } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN]; System.arraycopy(pl, EXTRA_HDR_LEN, data, 0, pl.length - EXTRA_HDR_LEN); GetsOperation.Callback gcb = (GetsOperation.Callback) getCallback(); gcb.gotData(key, flags, responseCas, data); getCallback().receivedStatus(STATUS_OK); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.io.IOException; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatsOperation;  public class KeyStatsOperationImpl extends SingleKeyOperationImpl implements StatsOperation { private static final byte CMD = 0x10; public KeyStatsOperationImpl(String key, StatsOperation.Callback c) { super(CMD, generateOpaque(), key, c); } @Override public void initialize() { String keyval = \"key \" + key + \" \" + getVBucket(key); prepareBuffer(keyval, 0, EMPTY_BYTES); } @Override protected void finishedPayload(byte[] pl) throws IOException { if (keyLen > 0) { final byte[] keyBytes = new byte[keyLen]; final byte[] data = new byte[pl.length - keyLen]; System.arraycopy(pl, 0, keyBytes, 0, keyLen); System.arraycopy(pl, keyLen, data, 0, pl.length - keyLen); Callback cb = (Callback) getCallback(); cb.gotStat(new String(keyBytes, \"UTF-8\"), new String(data, \"UTF-8\")); } else { OperationStatus status = getStatusForErrorCode(errorCode, pl); getCallback().receivedStatus(status); transitionState(OperationState.COMPLETE); } resetInput(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.io.IOException; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import static net.spy.memcached.protocol.binary.GetOperationImpl.EXTRA_HDR_LEN; public class MultiGetOperationImpl extends MultiKeyOperationImpl implements GetOperation { private static final byte CMD_GETQ = 0x09; private final Map<Integer, String> keys = new HashMap<Integer, String>(); private final Map<Integer, byte[]> bkeys = new HashMap<Integer, byte[]>(); private final Map<String, Integer> rkeys = new HashMap<String, Integer>(); private final int terminalOpaque = generateOpaque(); private final List<String> retryKeys = new ArrayList<String>(); public MultiGetOperationImpl(Collection<String> k, OperationCallback cb) { super(DUMMY_OPCODE, -1, cb); for (String s : new HashSet<String>(k)) { addKey(s); } }  protected int addKey(String k) { Integer rv = rkeys.get(k); if (rv == null) { rv = generateOpaque(); keys.put(rv, k); bkeys.put(rv, KeyUtil.getKeyBytes(k)); rkeys.put(k, rv); synchronized (vbmap) { vbmap.put(k, new Short((short) 0)); } } return rv; } @Override public void initialize() { int size = (1 + keys.size()) * MIN_RECV_PACKET; for (byte[] b : bkeys.values()) { size += b.length; } "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.Map; import net.spy.memcached.MemcachedNode; import net.spy.memcached.ops.KeyedOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.VBucketAware; import net.spy.memcached.util.StringUtils;  abstract class MultiKeyOperationImpl extends OperationImpl implements VBucketAware, KeyedOperation { protected final Map<String, Short> vbmap; protected MultiKeyOperationImpl(byte c, int o, OperationCallback cb) { super(c, o, cb); vbmap = Collections.synchronizedMap(new HashMap<String, Short>()); } public Collection<String> getKeys() { return vbmap.keySet(); } public Collection<MemcachedNode> getNotMyVbucketNodes() { return notMyVbucketNodes; } public void addNotMyVbucketNode(MemcachedNode node) { notMyVbucketNodes.add(node); } public void setNotMyVbucketNodes(Collection<MemcachedNode> nodes) { notMyVbucketNodes = nodes; } public void setVBucket(String k, short vb) { assert vbmap.containsKey(k) : \"Key \" + k + \" not contained in operation\"; vbmap.put(k, Short.valueOf(vb)); } public short getVBucket(String k) { assert vbmap.containsKey(k) : \"Key \" + k + \" not contained in operation\"; return vbmap.get(k); } @Override public String toString() { synchronized (vbmap) { return super.toString() + \" Keys: \" + StringUtils.join(getKeys(), \" \"); } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.Mutator; import net.spy.memcached.ops.MutatorOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; class MutatorOperationImpl extends SingleKeyOperationImpl implements MutatorOperation { private static final byte CMD_INCR = 0x05; private static final byte CMD_DECR = 0x06; private final Mutator mutator; private final long by; private final int exp; private final long def; public MutatorOperationImpl(Mutator m, String k, long b, long d, int e, OperationCallback cb) { super(m == Mutator.incr ? CMD_INCR : CMD_DECR, generateOpaque(), k, cb); assert d >= 0 : \"Default value is below zero\"; mutator = m; by = b; exp = e; def = d; } @Override public void initialize() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.NoopOperation; import net.spy.memcached.ops.OperationCallback;  class NoopOperationImpl extends OperationImpl implements NoopOperation { static final byte CMD = 0x0a; public NoopOperationImpl(OperationCallback cb) { super(CMD, generateOpaque(), cb); } @Override public void initialize() { prepareBuffer(\"\", 0, EMPTY_BYTES); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.KeyUtil; import net.spy.memcached.ObserveResponse; import net.spy.memcached.ops.ObserveOperation; import net.spy.memcached.ops.OperationCallback; class ObserveOperationImpl extends SingleKeyOperationImpl implements ObserveOperation { private static final byte CMD = (byte) 0x92; private final long cas; private final int index; private byte keystate = (byte)0xff; private long retCas = 0; public ObserveOperationImpl(String k, long c, int i, OperationCallback cb) { super(CMD, generateOpaque(), k, cb); cas = c; index = i; } @Override public void initialize() { byte[] keyBytes = KeyUtil.getKeyBytes(key); prepareBuffer(\"\", 0x0, EMPTY_BYTES, (short) index, (short) keyBytes.length, keyBytes); } @Override public String toString() { return super.toString() + \" Cas: \" + cas; } @Override protected void decodePayload(byte[] pl) { final short keylen = (short) decodeShort(pl, 2); keystate = (byte) decodeByte(pl, keylen+4); retCas = (long) decodeLong(pl, keylen+5); ObserveResponse r = ObserveResponse.valueOf(keystate); ((ObserveOperation.Callback) getCallback()).gotData(key, retCas, getHandlingNode(), r); getCallback().receivedStatus(STATUS_OK); } @Override public long getCasValue() { return cas; } @Override public int getIndex() { return index; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.io.IOException; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.util.concurrent.atomic.AtomicInteger; import net.spy.memcached.CASResponse; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.CASOperationStatus; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationErrorType; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.protocol.BaseOperationImpl;  public abstract class OperationImpl extends BaseOperationImpl implements Operation { protected static final byte REQ_MAGIC = (byte) 0x80; protected static final byte RES_MAGIC = (byte) 0x81; protected static final byte DUMMY_OPCODE = (byte)0xff; protected static final int MIN_RECV_PACKET = 24;  protected static final int SUCCESS = 0x00; protected static final int ERR_NOT_FOUND = 0x01; protected static final int ERR_EXISTS = 0x02; protected static final int ERR_2BIG = 0x03; protected static final int ERR_INVAL = 0x04; protected static final int ERR_NOT_STORED = 0x05; protected static final int ERR_DELTA_BADVAL = 0x06; protected static final int ERR_NOT_MY_VBUCKET = 0x07; protected static final int ERR_UNKNOWN_COMMAND = 0x81; protected static final int ERR_NO_MEM = 0x82; protected static final int ERR_NOT_SUPPORTED = 0x83; protected static final int ERR_INTERNAL = 0x84; protected static final int ERR_BUSY = 0x85; protected static final int ERR_TEMP_FAIL = 0x86; protected static final byte[] EMPTY_BYTES = new byte[0]; protected static final OperationStatus STATUS_OK = new CASOperationStatus( true, \"OK\", CASResponse.OK, StatusCode.SUCCESS); private static final AtomicInteger SEQ_NUMBER = new AtomicInteger(0); "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.Collections; import net.spy.memcached.ops.GetOperation; import net.spy.memcached.ops.VBucketAware; import net.spy.memcached.protocol.ProxyCallback;  final class OptimizedGetImpl extends MultiGetOperationImpl { private final ProxyCallback pcb;  public OptimizedGetImpl(GetOperation firstGet) { super(Collections.<String>emptySet(), new ProxyCallback()); pcb = (ProxyCallback) getCallback(); addOperation(firstGet); }  public void addOperation(GetOperation o) { pcb.addCallbacks(o); for (String k : o.getKeys()) { addKey(k); setVBucket(k, ((VBucketAware) o).getVBucket(k)); } } public int size() { return pcb.numKeys(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.io.IOException; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import net.spy.memcached.KeyUtil; import net.spy.memcached.ops.CASOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StoreType; import net.spy.memcached.ops.VBucketAware;  public class OptimizedSetImpl extends MultiKeyOperationImpl { private static final OperationCallback NOOP_CALLBACK = new NoopCallback(); private final int terminalOpaque = generateOpaque(); private final Map<Integer, OperationCallback> callbacks = new HashMap<Integer, OperationCallback>(); private final List<CASOperation> ops = new ArrayList<CASOperation>(); "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.ReplicaGetOperation;  public class ReplicaGetOperationImpl extends SingleKeyOperationImpl implements ReplicaGetOperation { static final byte REPLICA_GET_CMD = (byte)0x83; private final int replicaIndex;  static final int EXTRA_HDR_LEN = 4; public ReplicaGetOperationImpl(String k, int index, ReplicaGetOperation.Callback cb) { super(REPLICA_GET_CMD, generateOpaque(), k, cb); replicaIndex = index; } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN - keyLen]; System.arraycopy(pl, (EXTRA_HDR_LEN + keyLen), data, 0, pl.length - EXTRA_HDR_LEN - keyLen); ReplicaGetOperation.Callback gcb = (ReplicaGetOperation.Callback) getCallback(); gcb.gotData(key, flags, data); getCallback().receivedStatus(STATUS_OK); } public int getReplicaIndex() { return replicaIndex; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.ReplicaGetsOperation;  public class ReplicaGetsOperationImpl extends SingleKeyOperationImpl implements ReplicaGetsOperation { static final byte REPLICA_GET_CMD = (byte)0x83; private final int replicaIndex;  static final int EXTRA_HDR_LEN = 4; public ReplicaGetsOperationImpl(String k, int index, Callback cb) { super(REPLICA_GET_CMD, generateOpaque(), k, cb); replicaIndex = index; } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN - keyLen]; System.arraycopy(pl, (EXTRA_HDR_LEN + keyLen), data, 0, pl.length - EXTRA_HDR_LEN - keyLen); Callback gcb = (Callback) getCallback(); gcb.gotData(key, flags, responseCas, data); getCallback().receivedStatus(STATUS_OK); } public int getReplicaIndex() { return replicaIndex; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.Map; import javax.security.auth.callback.CallbackHandler; import javax.security.sasl.SaslClient; import javax.security.sasl.SaslException; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.SASLAuthOperation;  public class SASLAuthOperationImpl extends SASLBaseOperationImpl implements SASLAuthOperation { private static final byte CMD = 0x21; public SASLAuthOperationImpl(String[] m, String s, Map<String, ?> p, CallbackHandler h, OperationCallback c) { super(CMD, m, EMPTY_BYTES, s, p, h, c); } @Override protected byte[] buildResponse(SaslClient sc) throws SaslException { return sc.hasInitialResponse() ? sc.evaluateChallenge(challenge) : EMPTY_BYTES; } @Override public String toString() { return \"SASL auth operation\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.io.IOException; import java.util.Map; import javax.security.auth.callback.CallbackHandler; import javax.security.sasl.Sasl; import javax.security.sasl.SaslClient; import javax.security.sasl.SaslException; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode;  public abstract class SASLBaseOperationImpl extends OperationImpl { private static final byte SASL_CONTINUE = 0x21; protected final String[] mech; protected final byte[] challenge; protected final String serverName; protected final Map<String, ?> props; protected final CallbackHandler cbh; public SASLBaseOperationImpl(byte c, String[] m, byte[] ch, String s, Map<String, ?> p, CallbackHandler h, OperationCallback cb) { super(c, generateOpaque(), cb); mech = m; challenge = ch; serverName = s; props = p; cbh = h; } @Override public void initialize() { try { SaslClient sc = Sasl.createSaslClient(mech, null, \"memcached\", serverName, props, cbh); byte[] response = buildResponse(sc); String mechanism = sc.getMechanismName(); getLogger().debug(\"Using SASL auth mechanism: \" + mechanism); prepareBuffer(mechanism, 0, response); } catch (SaslException e) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.SASLMechsOperation; import net.spy.memcached.ops.StatusCode; class SASLMechsOperationImpl extends OperationImpl implements SASLMechsOperation { private static final byte CMD = 0x20; public SASLMechsOperationImpl(OperationCallback cb) { super(CMD, generateOpaque(), cb); } @Override public void initialize() { prepareBuffer(\"\", 0, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { getCallback().receivedStatus(new OperationStatus(true, new String(pl), StatusCode.SUCCESS)); } @Override public String toString() { return \"SASL mechs operation\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.Map; import javax.security.auth.callback.CallbackHandler; import javax.security.sasl.SaslClient; import javax.security.sasl.SaslException; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.SASLStepOperation;  public class SASLStepOperationImpl extends SASLBaseOperationImpl implements SASLStepOperation { private static final byte CMD = 0x22; public SASLStepOperationImpl(String[] m, byte[] ch, String s, Map<String, ?> p, CallbackHandler h, OperationCallback c) { super(CMD, m, ch, s, p, h, c); } @Override protected byte[] buildResponse(SaslClient sc) throws SaslException { return sc.evaluateChallenge(challenge); } @Override public String toString() { return \"SASL steps operation\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.Collection; import java.util.Collections; import net.spy.memcached.MemcachedNode; import net.spy.memcached.ops.KeyedOperation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.VBucketAware;  abstract class SingleKeyOperationImpl extends OperationImpl implements VBucketAware, KeyedOperation { protected final String key; protected SingleKeyOperationImpl(byte c, int o, String k, OperationCallback cb) { super(c, o, cb); key = k; } public Collection<String> getKeys() { return Collections.singleton(key); } public Collection<MemcachedNode> getNotMyVbucketNodes() { return notMyVbucketNodes; } public void addNotMyVbucketNode(MemcachedNode node) { notMyVbucketNodes.add(node); } public void setNotMyVbucketNodes(Collection<MemcachedNode> nodes) { notMyVbucketNodes = nodes; } public void setVBucket(String k, short vb) { assert k.equals(key) : (k + \" doesn't match the key \" + key + \" for this operation\"); vbucket = vb; } public short getVBucket(String k) { assert k.equals(key) : (k + \" doesn't match the key \" + key + \" for this operation\"); return vbucket; } @Override public String toString() { return super.toString() + \" Key: \" + key; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.io.IOException; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatsOperation;  public class StatsOperationImpl extends OperationImpl implements StatsOperation { private static final byte CMD = 0x10; private final String key; public StatsOperationImpl(String arg, StatsOperation.Callback c) { super(CMD, generateOpaque(), c); key = (arg == null) ? \"\" : arg; } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES); } @Override protected void finishedPayload(byte[] pl) throws IOException { if (keyLen > 0) { final byte[] keyBytes = new byte[keyLen]; final byte[] data = new byte[pl.length - keyLen]; System.arraycopy(pl, 0, keyBytes, 0, keyLen); System.arraycopy(pl, keyLen, data, 0, pl.length - keyLen); Callback cb = (Callback) getCallback(); cb.gotStat(new String(keyBytes, \"UTF-8\"), new String(data, \"UTF-8\")); } else { OperationStatus status = getStatusForErrorCode(errorCode, pl); getCallback().receivedStatus(status); transitionState(OperationState.COMPLETE); } resetInput(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.CASOperation; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.ops.StoreType; class StoreOperationImpl extends SingleKeyOperationImpl implements StoreOperation, CASOperation { private static final byte SET = 0x01; private static final byte ADD = 0x02; private static final byte REPLACE = 0x03; static final byte SETQ = 0x11; static final byte ADDQ = 0x12; static final byte REPLACEQ = 0x13; "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.nio.ByteBuffer; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.TapMagic; import net.spy.memcached.tapmessage.TapOpcode;  public class TapAckOperationImpl extends TapOperationImpl { private final TapOpcode opcode; private final int opaque; TapAckOperationImpl(TapOpcode opcode, int opaque, OperationCallback cb) { super(cb); this.opcode = opcode; this.opaque = opaque; } @Override public void initialize() { RequestMessage message = new RequestMessage(); message.setMagic(TapMagic.PROTOCOL_BINARY_RES); message.setOpcode(opcode); message.setOpaque(opaque); setBuffer(message.getBytes()); } @Override public void readFromBuffer(ByteBuffer data) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.UUID; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.TapMagic; import net.spy.memcached.tapmessage.TapOpcode; import net.spy.memcached.tapmessage.TapRequestFlag;  public class TapBackfillOperationImpl extends TapOperationImpl implements TapOperation { private final String id; private final long date; TapBackfillOperationImpl(String id, long date, OperationCallback cb) { super(cb); this.id = id; this.date = date; } @Override public void initialize() { RequestMessage message = new RequestMessage(); message.setMagic(TapMagic.PROTOCOL_BINARY_REQ); message.setOpcode(TapOpcode.REQUEST); message.setFlags(TapRequestFlag.BACKFILL); message.setFlags(TapRequestFlag.SUPPORT_ACK); message.setFlags(TapRequestFlag.FIX_BYTEORDER); if (id != null) { message.setName(id); } else { message.setName(UUID.randomUUID().toString()); } message.setBackfill(date); setBuffer(message.getBytes()); } @Override public void streamClosed(OperationState state) { transitionState(state); } @Override public String toString() { return \"Cmd: tap dump Flags: backfill,ack\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.UUID; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.TapRequestFlag;  public class TapCustomOperationImpl extends TapOperationImpl implements TapOperation { private final String id; private final RequestMessage message; TapCustomOperationImpl(String id, RequestMessage message, OperationCallback cb) { super(cb); this.id = id; this.message = message; } @Override public void initialize() { message.setFlags(TapRequestFlag.FIX_BYTEORDER); if (id != null) { message.setName(id); } else { message.setName(UUID.randomUUID().toString()); } setBuffer(message.getBytes()); } @Override public void streamClosed(OperationState state) { transitionState(state); } @Override public String toString() { return \"Cmd: tap custom\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.util.UUID; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.tapmessage.RequestMessage; import net.spy.memcached.tapmessage.TapMagic; import net.spy.memcached.tapmessage.TapOpcode; import net.spy.memcached.tapmessage.TapRequestFlag;  public class TapDumpOperationImpl extends TapOperationImpl implements TapOperation { private final String id; TapDumpOperationImpl(String id, OperationCallback cb) { super(cb); this.id = id; } @Override public void initialize() { RequestMessage message = new RequestMessage(); message.setMagic(TapMagic.PROTOCOL_BINARY_REQ); message.setOpcode(TapOpcode.REQUEST); message.setFlags(TapRequestFlag.DUMP); message.setFlags(TapRequestFlag.SUPPORT_ACK); message.setFlags(TapRequestFlag.FIX_BYTEORDER); if (id != null) { message.setName(id); } else { message.setName(UUID.randomUUID().toString()); } setBuffer(message.getBytes()); } @Override public void streamClosed(OperationState state) { transitionState(state); } @Override public String toString() { return \"Cmd: tap dump Flags: dump,ack\"; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import java.io.IOException; import java.nio.ByteBuffer; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.TapOperation; import net.spy.memcached.tapmessage.BaseMessage; import net.spy.memcached.tapmessage.ResponseMessage; import net.spy.memcached.tapmessage.TapOpcode; import net.spy.memcached.tapmessage.TapResponseFlag;  public abstract class TapOperationImpl extends OperationImpl implements TapOperation { private int bytesProcessed; private int bodylen; private byte[] header; private byte[] message; static final byte CMD = 0; protected TapOperationImpl(OperationCallback cb) { super(CMD, generateOpaque(), cb); this.header = new byte[BaseMessage.HEADER_LENGTH]; this.message = null; } public abstract void initialize(); @Override public void readFromBuffer(ByteBuffer data) throws IOException { while (data.remaining() > 0) { if (bytesProcessed < BaseMessage.HEADER_LENGTH) { header[bytesProcessed] = data.get(); bytesProcessed++; } else { if (message == null) { bodylen = decodeInt(header, 8); message = new byte[BaseMessage.HEADER_LENGTH + bodylen]; System.arraycopy(header, 0, message, 0, BaseMessage.HEADER_LENGTH); } if (bytesProcessed < message.length) { message[bytesProcessed] = data.get(); bytesProcessed++; } if (bytesProcessed >= message.length) { ResponseMessage response = new ResponseMessage(message); for (TapResponseFlag flag : response.getFlags()) { if (flag == TapResponseFlag.TAP_ACK) { ((Callback) getCallback()).gotAck(getHandlingNode(), response.getOpcode(), response.getOpaque()); } } if (response.getOpcode() != TapOpcode.OPAQUE && response.getOpcode() != TapOpcode.NOOP) { ((Callback) getCallback()).gotData(response); } message = null; bytesProcessed = 0; } } } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.TouchOperation;  public class TouchOperationImpl extends SingleKeyOperationImpl implements TouchOperation { static final byte CMD = 0x1c; private final int exp; protected TouchOperationImpl(String k, int e, OperationCallback cb) { super(CMD, generateOpaque(), k, cb); exp = e; } @Override public void initialize() { prepareBuffer(key, 0, EMPTY_BYTES, exp); } @Override protected void decodePayload(byte[] pl) { getCallback().receivedStatus(STATUS_OK); } @Override public int getExpiration() { return exp; } @Override public String toString() { return super.toString() + \" Exp: \" + exp; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.UnlockOperation; class UnlockOperationImpl extends SingleKeyOperationImpl implements UnlockOperation { private static final byte CMD = (byte) 0x95; private final long cas; public UnlockOperationImpl(String k, long c, OperationCallback cb) { super(CMD, generateOpaque(), k, cb); cas = c; } @Override public void initialize() { prepareBuffer(key, cas, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { getCallback().receivedStatus(STATUS_OK); } @Override public String toString() { return super.toString() + \" Cas: \" + cas; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.protocol.binary; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; import net.spy.memcached.ops.VersionOperation; class VersionOperationImpl extends OperationImpl implements VersionOperation { private static final byte CMD = 0x0b; public VersionOperationImpl(OperationCallback cb) { super(CMD, generateOpaque(), cb); } @Override public void initialize() { prepareBuffer(\"\", 0, EMPTY_BYTES); } @Override protected void decodePayload(byte[] pl) { getCallback().receivedStatus(new OperationStatus(true, new String(pl), StatusCode.SUCCESS)); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.spring; import java.util.Collection; import java.util.concurrent.TimeUnit; import net.spy.memcached.AddrUtil; import net.spy.memcached.ConnectionFactoryBuilder; import net.spy.memcached.ConnectionFactoryBuilder.Locator; import net.spy.memcached.ConnectionFactoryBuilder.Protocol; import net.spy.memcached.ConnectionObserver; import net.spy.memcached.FailureMode; import net.spy.memcached.HashAlgorithm; import net.spy.memcached.MemcachedClient; import net.spy.memcached.OperationFactory; import net.spy.memcached.auth.AuthDescriptor; import net.spy.memcached.ops.OperationQueueFactory; import net.spy.memcached.transcoders.Transcoder; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.InitializingBean;  @SuppressWarnings(\"rawtypes\") public class MemcachedClientFactoryBean implements FactoryBean, InitializingBean, DisposableBean { private final ConnectionFactoryBuilder connectionFactoryBuilder = new ConnectionFactoryBuilder(); private String servers; private long shutdownTimeoutSeconds = 0; private MemcachedClient client; @Override public Object getObject() throws Exception { return client; } @Override public Class<?> getObjectType() { return MemcachedClient.class; } @Override public boolean isSingleton() { return true; } @Override public void afterPropertiesSet() throws Exception { client = new MemcachedClient(connectionFactoryBuilder.build(), AddrUtil.getAddresses(servers)); } @Override public void destroy() throws Exception { if(shutdownTimeoutSeconds > 0) { client.shutdown(shutdownTimeoutSeconds, TimeUnit.SECONDS); } else { client.shutdown(); } } public void setServers(final String newServers) { this.servers = newServers; } public void setAuthDescriptor(final AuthDescriptor to) { connectionFactoryBuilder.setAuthDescriptor(to); } public void setDaemon(final boolean d) { connectionFactoryBuilder.setDaemon(d); } public void setFailureMode(final FailureMode fm) { connectionFactoryBuilder.setFailureMode(fm); } public void setHashAlg(final HashAlgorithm to) { connectionFactoryBuilder.setHashAlg(to); } public void setInitialObservers(final Collection<ConnectionObserver> obs) { connectionFactoryBuilder.setInitialObservers(obs); } public void setLocatorType(final Locator l) { connectionFactoryBuilder.setLocatorType(l); } public void setMaxReconnectDelay(final long to) { connectionFactoryBuilder.setMaxReconnectDelay(to); } public void setOpFact(final OperationFactory f) { connectionFactoryBuilder.setOpFact(f); } public void setOpQueueFactory(final OperationQueueFactory q) { connectionFactoryBuilder.setOpQueueFactory(q); } public void setOpQueueMaxBlockTime(final long t) { connectionFactoryBuilder.setOpQueueMaxBlockTime(t); } public void setOpTimeout(final long t) { connectionFactoryBuilder.setOpTimeout(t); } public void setProtocol(final Protocol prot) { connectionFactoryBuilder.setProtocol(prot); } public void setReadBufferSize(final int to) { connectionFactoryBuilder.setReadBufferSize(to); } public void setReadOpQueueFactory(final OperationQueueFactory q) { connectionFactoryBuilder.setReadOpQueueFactory(q); } public void setShouldOptimize(final boolean o) { connectionFactoryBuilder.setShouldOptimize(o); } public void setTimeoutExceptionThreshold(final int to) { connectionFactoryBuilder.setTimeoutExceptionThreshold(to); } public void setTranscoder(final Transcoder<Object> t) { connectionFactoryBuilder.setTranscoder(t); } public void setUseNagleAlgorithm(final boolean to) { connectionFactoryBuilder.setUseNagleAlgorithm(to); } public void setWriteOpQueueFactory(final OperationQueueFactory q) { connectionFactoryBuilder.setWriteOpQueueFactory(q); }  public void setShutdownTimeoutSeconds(long shutdownTimeoutSeconds) { this.shutdownTimeoutSeconds = shutdownTimeoutSeconds; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage; import java.nio.ByteBuffer; import net.spy.memcached.compat.SpyObject;  public abstract class BaseMessage extends SpyObject { private static final int MAGIC_OFFSET = 0; private static final int OPCODE_OFFSET = 1; private static final int KEYLENGTH_OFFSET = 2; private static final int EXTRALENGTH_OFFSET = 4; private static final int DATATYPE_OFFSET = 5; private static final int VBUCKET_OFFSET = 6; private static final int TOTALBODY_OFFSET = 8; private static final int OPAQUE_OFFSET = 12; private static final int CAS_OFFSET = 16; public static final int HEADER_LENGTH = 24; protected TapMagic magic; protected TapOpcode opcode; protected short keylength; protected byte extralength; protected byte datatype; protected short vbucket; protected int totalbody; protected int opaque; protected long cas; protected BaseMessage() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage;  public class MessageBuilder { private RequestMessage message; public MessageBuilder() { this.message = new RequestMessage(); message.setMagic(TapMagic.PROTOCOL_BINARY_REQ); message.setOpcode(TapOpcode.REQUEST); } public void doBackfill(long date) { message.setBackfill(date); message.setFlags(TapRequestFlag.BACKFILL); } public void doDump() { message.setFlags(TapRequestFlag.DUMP); } public void specifyVbuckets(short[] vbucketlist) { message.setVbucketlist(vbucketlist); message.setFlags(TapRequestFlag.LIST_VBUCKETS); } public void supportAck() { message.setFlags(TapRequestFlag.SUPPORT_ACK); } public void keysOnly() { message.setFlags(TapRequestFlag.KEYS_ONLY); } public void takeoverVbuckets(short[] vbucketlist) { message.setVbucketlist(vbucketlist); message.setFlags(TapRequestFlag.TAKEOVER_VBUCKETS); } public RequestMessage getMessage() { return message; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage; import java.nio.ByteBuffer; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.UUID;  public class RequestMessage extends BaseMessage{ private boolean hasBackfill; private boolean hasVBucketList; private boolean hasVBucketCheckpoints; private boolean hasFlags; private List<TapRequestFlag> flagList; private short[] vblist; private String name; private long backfilldate; private Map<Short, Long> vBucketCheckpoints;  public RequestMessage() { flagList = new LinkedList<TapRequestFlag>(); vblist = new short[0]; vBucketCheckpoints = new HashMap<Short, Long>(); name = UUID.randomUUID().toString(); backfilldate = -1; totalbody += name.length(); keylength = (short) name.length(); }  public void setFlags(TapRequestFlag f) { if (!flagList.contains(f)) { if (!hasFlags) { hasFlags = true; extralength += 4; totalbody += 4; } if (f.equals(TapRequestFlag.BACKFILL)) { hasBackfill = true; totalbody += 8; } if (f.equals(TapRequestFlag.LIST_VBUCKETS) || f.equals(TapRequestFlag.TAKEOVER_VBUCKETS)) { hasVBucketList = true; totalbody += 2; } if (f.equals(TapRequestFlag.CHECKPOINT)) { hasVBucketCheckpoints = true; totalbody += 2; } flagList.add(f); } }  public List<TapRequestFlag> getFlags() { return flagList; }  public void setBackfill(long date) { backfilldate = date; }  public void setVbucketlist(short[] vbs) { int oldSize = (vblist.length + 1) * 2; int newSize = (vbs.length + 1) * 2; totalbody += newSize - oldSize; vblist = vbs; }  public void setvBucketCheckpoints(Map<Short, Long> vbchkpnts) { int oldSize = (vBucketCheckpoints.size()) * 10; int newSize = (vbchkpnts.size()) * 10; totalbody += newSize - oldSize; vBucketCheckpoints = vbchkpnts; }  public void setName(String n) { if (n.length() > 65535) { throw new IllegalArgumentException(\"Tap name too long\"); } totalbody += n.length() - name.length(); keylength = (short) n.length(); name = n; }  @Override public ByteBuffer getBytes() { ByteBuffer bb = ByteBuffer.allocate(HEADER_LENGTH + getTotalbody()); bb.put(magic.getMagic()); bb.put(opcode.getOpcode()); bb.putShort(keylength); bb.put(extralength); bb.put(datatype); bb.putShort(vbucket); bb.putInt(totalbody); bb.putInt(opaque); bb.putLong(cas); if (hasFlags) { int flag = 0; for (int i = 0; i < flagList.size(); i++) { flag |= flagList.get(i).getFlags(); } bb.putInt(flag); } bb.put(name.getBytes()); if (hasBackfill) { bb.putLong(backfilldate); } if (hasVBucketList) { bb.putShort((short) vblist.length); for (int i = 0; i < vblist.length; i++) { bb.putShort(vblist[i]); } } if (hasVBucketCheckpoints) { bb.putShort((short)vBucketCheckpoints.size()); for (Short vBucket : vBucketCheckpoints.keySet()) { bb.putShort(vBucket); bb.putLong(vBucketCheckpoints.get(vBucket)); } } return (ByteBuffer) bb.flip(); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage; import java.nio.ByteBuffer; import java.util.LinkedList; import java.util.List; import net.spy.memcached.CachedData; import net.spy.memcached.transcoders.SerializingTranscoder;  public class ResponseMessage extends BaseMessage { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage; import net.spy.memcached.MemcachedNode; import net.spy.memcached.TapConnectionProvider; import net.spy.memcached.ops.OperationCallback;  public class TapAck { private final TapConnectionProvider conn; private final TapOpcode opcode; private final int opaque; private final MemcachedNode node; private final OperationCallback cb; public TapAck(TapConnectionProvider conn, MemcachedNode node, TapOpcode opcode, int opaque, OperationCallback cb) { this.conn = conn; this.node = node; this.opcode = opcode; this.opaque = opaque; this.cb = cb; } public TapConnectionProvider getConn() { return conn; } public MemcachedNode getNode() { return node; } public TapOpcode getOpcode() { return opcode; } public int getOpaque() { return opaque; } public OperationCallback getCallback() { return cb; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage;  public enum TapMagic {  PROTOCOL_BINARY_REQ((byte) 0x80),  PROTOCOL_BINARY_RES((byte) 0x81);  private byte magic;  TapMagic(byte magic) { this.magic = magic; } public static TapMagic getMagicByByte(byte b) { if (b == PROTOCOL_BINARY_REQ.magic) { return TapMagic.PROTOCOL_BINARY_REQ; } else if (b == PROTOCOL_BINARY_RES.magic) { return TapMagic.PROTOCOL_BINARY_RES; } else { throw new IllegalArgumentException(\"Bad magic value\"); } } public byte getMagic() { return magic; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage;  public enum TapOpcode {  NOOP((byte) 0x0a),  SASLLIST((byte) 0x20),  SASLAUTH((byte) 0x21),  REQUEST((byte) 0x40),  MUTATION((byte) 0x41),  DELETE((byte) 0x42),  FLUSH((byte) 0x43),  OPAQUE((byte) 0x44),  VBUCKETSET((byte) 0x45),  START_CHECKPOINT((byte) 0x46),  END_CHECKPOINT((byte) 0x47);  private byte opcode;  TapOpcode(byte opcode) { this.opcode = opcode; } public byte getOpcode() { return opcode; } public static TapOpcode getOpcodeByByte(byte b) { if (b == TapOpcode.DELETE.opcode) { return TapOpcode.DELETE; } else if (b == TapOpcode.FLUSH.opcode) { return TapOpcode.DELETE; } else if (b == TapOpcode.MUTATION.opcode) { return TapOpcode.MUTATION; } else if (b == TapOpcode.NOOP.opcode) { return TapOpcode.NOOP; } else if (b == TapOpcode.OPAQUE.opcode) { return TapOpcode.OPAQUE; } else if (b == TapOpcode.REQUEST.opcode) { return TapOpcode.REQUEST; } else if (b == TapOpcode.SASLAUTH.opcode) { return TapOpcode.SASLAUTH; } else if (b == TapOpcode.SASLLIST.opcode) { return TapOpcode.SASLLIST; } else if (b == TapOpcode.VBUCKETSET.opcode) { return TapOpcode.VBUCKETSET; } else if (b == TapOpcode.START_CHECKPOINT.opcode) { return TapOpcode.START_CHECKPOINT; } else if (b == TapOpcode.END_CHECKPOINT.opcode) { return TapOpcode.END_CHECKPOINT; } else { return null; } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage; import java.util.LinkedList; import java.util.List;  public enum TapRequestFlag {  BACKFILL((int) 0x01),  DUMP((int) 0x02),  LIST_VBUCKETS((int) 0x04),  TAKEOVER_VBUCKETS((int) 0x08),  SUPPORT_ACK((int) 0x10),  KEYS_ONLY((int) 0x20),  CHECKPOINT((int) 0x40),  FIX_BYTEORDER((int) 0x100);  private int flag;  TapRequestFlag(int flag) { this.flag = flag; } public static List<TapRequestFlag> getFlags(int f) { List<TapRequestFlag> flags = new LinkedList<TapRequestFlag>(); if ((f & TapRequestFlag.BACKFILL.flag) != 0) { flags.add(TapRequestFlag.BACKFILL); } if ((f & TapRequestFlag.DUMP.flag) != 0) { flags.add(TapRequestFlag.DUMP); } if ((f & TapRequestFlag.LIST_VBUCKETS.flag) != 0) { flags.add(TapRequestFlag.LIST_VBUCKETS); } if ((f & TapRequestFlag.TAKEOVER_VBUCKETS.flag) != 0) { flags.add(TapRequestFlag.TAKEOVER_VBUCKETS); } if ((f & TapRequestFlag.SUPPORT_ACK.flag) != 0) { flags.add(TapRequestFlag.SUPPORT_ACK); } if ((f & TapRequestFlag.KEYS_ONLY.flag) != 0) { flags.add(TapRequestFlag.KEYS_ONLY); } if ((f & TapRequestFlag.CHECKPOINT.flag) != 0) { flags.add(TapRequestFlag.CHECKPOINT); } return flags; } public int getFlags() { return flag; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage; import java.util.LinkedList; import java.util.List;  public enum TapResponseFlag {  TAP_ACK((short) 0x01),  TAP_NO_VALUE((short) 0x02),  TAP_FLAG_NETWORK_BYTE_ORDER((short) 0x04);  private short flag;  TapResponseFlag(short flag) { this.flag = flag; } public static List<TapResponseFlag> getFlags(short f) { List<TapResponseFlag> flags = new LinkedList<TapResponseFlag>(); if ((f & TapResponseFlag.TAP_ACK.flag) != 0) { flags.add(TapResponseFlag.TAP_ACK); } if ((f & TapResponseFlag.TAP_NO_VALUE.flag) != 0) { flags.add(TapResponseFlag.TAP_NO_VALUE); } if ((f & TapResponseFlag.TAP_FLAG_NETWORK_BYTE_ORDER.flag) != 0) { flags.add(TapResponseFlag.TAP_FLAG_NETWORK_BYTE_ORDER); } return flags; } public short getFlags() { return flag; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage; import java.util.LinkedList; import java.util.List; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.TapOperation;  public class TapStream { private final List<TapOperation> ops;  public TapStream() { ops = new LinkedList<TapOperation>(); }  public void cancel() { for (TapOperation op : ops) { op.cancel(); } }  public boolean isCompleted() { for (TapOperation op : ops) { if (!op.getState().equals(OperationState.COMPLETE)) { return false; } } return true; }  public boolean isCancelled() { for (TapOperation op : ops) { if (!op.isCancelled()) { return false; } } return true; }  public boolean hasErrored() { for (TapOperation op : ops) { if (!op.hasErrored()) { return false; } } return true; }  public void addOp(TapOperation op) { ops.add(op); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.tapmessage;  public final class Util { private Util() { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.UnsupportedEncodingException; import java.util.zip.GZIPInputStream; import java.util.zip.GZIPOutputStream; import net.spy.memcached.CachedData; import net.spy.memcached.compat.CloseUtil; import net.spy.memcached.compat.SpyObject;  public abstract class BaseSerializingTranscoder extends SpyObject {  public static final int DEFAULT_COMPRESSION_THRESHOLD = 16384; private static final String DEFAULT_CHARSET = \"UTF-8\"; protected int compressionThreshold = DEFAULT_COMPRESSION_THRESHOLD; protected String charset = DEFAULT_CHARSET; private final int maxSize;  public BaseSerializingTranscoder(int max) { super(); maxSize = max; } public boolean asyncDecode(CachedData d) { return false; }  public void setCompressionThreshold(int to) { compressionThreshold = to; }  public void setCharset(String to) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import net.spy.memcached.CachedData; import net.spy.memcached.compat.SpyObject;  public final class IntegerTranscoder extends SpyObject implements Transcoder<Integer> { private static final int FLAGS = SerializingTranscoder.SPECIAL_INT; private final TranscoderUtils tu = new TranscoderUtils(true); public boolean asyncDecode(CachedData d) { return false; } public CachedData encode(java.lang.Integer l) { return new CachedData(FLAGS, tu.encodeInt(l), getMaxSize()); } public Integer decode(CachedData d) { if (FLAGS == d.getFlags()) { return tu.decodeInt(d.getData()); } else { return null; } } public int getMaxSize() { return CachedData.MAX_SIZE; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import net.spy.memcached.CachedData; import net.spy.memcached.compat.SpyObject;  public final class LongTranscoder extends SpyObject implements Transcoder<Long> { private static final int FLAGS = SerializingTranscoder.SPECIAL_LONG; private final TranscoderUtils tu = new TranscoderUtils(true); public boolean asyncDecode(CachedData d) { return false; } public CachedData encode(java.lang.Long l) { return new CachedData(FLAGS, tu.encodeLong(l), getMaxSize()); } public Long decode(CachedData d) { if (FLAGS == d.getFlags()) { return tu.decodeLong(d.getData()); } else { getLogger().error( \"Unexpected flags for long: \" + d.getFlags() + \" wanted \" + FLAGS); return null; } } public int getMaxSize() { return CachedData.MAX_SIZE; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import java.util.Date; import net.spy.memcached.CachedData; import net.spy.memcached.util.StringUtils;  public class SerializingTranscoder extends BaseSerializingTranscoder implements Transcoder<Object> { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.Future; import java.util.concurrent.FutureTask; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicBoolean; import net.spy.memcached.CachedData; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.internal.BasicThreadFactory;  public class TranscodeService extends SpyObject { private final ThreadPoolExecutor pool; public TranscodeService(boolean daemon) { pool = new ThreadPoolExecutor(1, 10, 60L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(100), new BasicThreadFactory( \"transcoder\", daemon), new ThreadPoolExecutor.DiscardPolicy()); }  public <T> Future<T> decode(final Transcoder<T> tc, final CachedData cachedData) { assert !pool.isShutdown() : \"Pool has already shut down.\"; TranscodeService.Task<T> task = new TranscodeService.Task<T>(new Callable<T>() { public T call() { return tc.decode(cachedData); } }); if (tc.asyncDecode(cachedData)) { this.pool.execute(task); } return task; }  public void shutdown() { pool.shutdown(); }  public boolean isShutdown() { return pool.isShutdown(); } private static class Task<T> extends FutureTask<T> { private final AtomicBoolean isRunning = new AtomicBoolean(false); public Task(Callable<T> callable) { super(callable); } @Override public T get() throws InterruptedException, ExecutionException { this.run(); return super.get(); } @Override public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { this.run(); return super.get(timeout, unit); } @Override public void run() { if (this.isRunning.compareAndSet(false, true)) { super.run(); } } } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import net.spy.memcached.CachedData;  public interface Transcoder<T> {  boolean asyncDecode(CachedData d);  CachedData encode(T o);  T decode(CachedData d);  int getMaxSize(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders;  public final class TranscoderUtils { private final boolean packZeros;  public TranscoderUtils(boolean pack) { super(); packZeros = pack; } public byte[] encodeNum(long l, int maxBytes) { byte[] rv = new byte[maxBytes]; for (int i = 0; i < rv.length; i++) { int pos = rv.length - i - 1; rv[pos] = (byte) ((l >> (8 * i)) & 0xff); } if (packZeros) { int firstNon0 = 0; "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import java.util.Date; import net.spy.memcached.CachedData; import net.spy.memcached.util.StringUtils;  public class WhalinTranscoder extends BaseSerializingTranscoder implements Transcoder<Object> { static final int SPECIAL_BYTE = 1; static final int SPECIAL_BOOLEAN = 8192; static final int SPECIAL_INT = 4; static final int SPECIAL_LONG = 16384; static final int SPECIAL_CHARACTER = 16; static final int SPECIAL_STRING = 32; static final int SPECIAL_STRINGBUFFER = 64; static final int SPECIAL_FLOAT = 128; static final int SPECIAL_SHORT = 256; static final int SPECIAL_DOUBLE = 512; static final int SPECIAL_DATE = 1024; static final int SPECIAL_STRINGBUILDER = 2048; static final int SPECIAL_BYTEARRAY = 4096; static final int COMPRESSED = 2; static final int SERIALIZED = 8; private final TranscoderUtils tu = new TranscoderUtils(false); public WhalinTranscoder() { super(CachedData.MAX_SIZE); }  public Object decode(CachedData d) { byte[] data = d.getData(); Object rv = null; if ((d.getFlags() & COMPRESSED) != 0) { data = decompress(d.getData()); } if ((d.getFlags() & SERIALIZED) != 0) { rv = deserialize(data); } else { int f = d.getFlags() & ~COMPRESSED; switch (f) { case SPECIAL_BOOLEAN: rv = Boolean.valueOf(this.decodeBoolean(data)); break; case SPECIAL_INT: rv = Integer.valueOf(tu.decodeInt(data)); break; case SPECIAL_SHORT: rv = Short.valueOf((short) tu.decodeInt(data)); break; case SPECIAL_LONG: rv = Long.valueOf(tu.decodeLong(data)); break; case SPECIAL_DATE: rv = new Date(tu.decodeLong(data)); break; case SPECIAL_BYTE: rv = Byte.valueOf(tu.decodeByte(data)); break; case SPECIAL_FLOAT: rv = new Float(Float.intBitsToFloat(tu.decodeInt(data))); break; case SPECIAL_DOUBLE: rv = new Double(Double.longBitsToDouble(tu.decodeLong(data))); break; case SPECIAL_BYTEARRAY: rv = data; break; case SPECIAL_STRING: rv = decodeString(data); break; case SPECIAL_STRINGBUFFER: rv = new StringBuffer(decodeString(data)); break; case SPECIAL_STRINGBUILDER: rv = new StringBuilder(decodeString(data)); break; case SPECIAL_CHARACTER: rv = decodeCharacter(data); break; default: getLogger().warn(\"Cannot handle data with flags %x\", f); } } return rv; } public CachedData encode(Object o) { byte[] b = null; int flags = 0; if (o instanceof String) { b = encodeString((String) o); flags |= SPECIAL_STRING; if (StringUtils.isJsonObject((String) o)) { return new CachedData(flags, b, getMaxSize()); } } else if (o instanceof StringBuffer) { flags |= SPECIAL_STRINGBUFFER; b = encodeString(String.valueOf(o)); } else if (o instanceof StringBuilder) { flags |= SPECIAL_STRINGBUILDER; b = encodeString(String.valueOf(o)); } else if (o instanceof Long) { b = tu.encodeLong((Long) o); flags |= SPECIAL_LONG; } else if (o instanceof Integer) { b = tu.encodeInt((Integer) o); flags |= SPECIAL_INT; } else if (o instanceof Short) { b = tu.encodeInt((Short) o); flags |= SPECIAL_SHORT; } else if (o instanceof Boolean) { b = this.encodeBoolean((Boolean) o); flags |= SPECIAL_BOOLEAN; } else if (o instanceof Date) { b = tu.encodeLong(((Date) o).getTime()); flags |= SPECIAL_DATE; } else if (o instanceof Byte) { b = tu.encodeByte((Byte) o); flags |= SPECIAL_BYTE; } else if (o instanceof Float) { b = tu.encodeInt(Float.floatToIntBits((Float) o)); flags |= SPECIAL_FLOAT; } else if (o instanceof Double) { b = tu.encodeLong(Double.doubleToLongBits((Double) o)); flags |= SPECIAL_DOUBLE; } else if (o instanceof byte[]) { b = (byte[]) o; flags |= SPECIAL_BYTEARRAY; } else if (o instanceof Character) { b = tu.encodeInt((Character) o); flags |= SPECIAL_CHARACTER; } else { b = serialize(o); flags |= SERIALIZED; } assert b != null; if (b.length > compressionThreshold) { byte[] compressed = compress(b); if (compressed.length < b.length) { getLogger().debug(\"Compressed %s from %d to %d\", o.getClass().getName(), b.length, compressed.length); b = compressed; flags |= COMPRESSED; } else { getLogger().info(\"Compression increased the size of %s from %d to %d\", o.getClass().getName(), b.length, compressed.length); } } return new CachedData(flags, b, getMaxSize()); } protected Character decodeCharacter(byte[] b) { return Character.valueOf((char) tu.decodeInt(b)); } public byte[] encodeBoolean(boolean b) { byte[] rv = new byte[1]; rv[0] = (byte) (b ? 1 : 0); return rv; } public boolean decodeBoolean(byte[] in) { assert in.length == 1 : \"Wrong length for a boolean\"; return in[0] == 1; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.transcoders; import java.io.UnsupportedEncodingException; import java.util.Date; import net.spy.memcached.CachedData; import net.spy.memcached.util.StringUtils;  public class WhalinV1Transcoder extends BaseSerializingTranscoder implements Transcoder<Object> { public static final int SPECIAL_BYTE = 1; public static final int SPECIAL_BOOLEAN = 2; public static final int SPECIAL_INTEGER = 3; public static final int SPECIAL_LONG = 4; public static final int SPECIAL_CHARACTER = 5; public static final int SPECIAL_STRING = 6; public static final int SPECIAL_STRINGBUFFER = 7; public static final int SPECIAL_FLOAT = 8; public static final int SPECIAL_SHORT = 9; public static final int SPECIAL_DOUBLE = 10; public static final int SPECIAL_DATE = 11; public static final int SPECIAL_STRINGBUILDER = 12; public static final int COMPRESSED = 2; public static final int SERIALIZED = 8; public WhalinV1Transcoder() { super(CachedData.MAX_SIZE); } public CachedData encode(Object o) { byte[] b = null; int flags = 0; if (o instanceof String) { b = encodeW1String((String) o); if (StringUtils.isJsonObject((String) o)) { return new CachedData(flags, b, getMaxSize()); } } else if (o instanceof StringBuffer) { b = encodeStringBuffer((StringBuffer) o); } else if (o instanceof StringBuilder) { b = encodeStringbuilder((StringBuilder) o); } else if (o instanceof Long) { b = encodeLong((Long) o); } else if (o instanceof Integer) { b = encodeInteger((Integer) o); } else if (o instanceof Short) { b = encodeShort((Short) o); } else if (o instanceof Boolean) { b = encodeBoolean((Boolean) o); } else if (o instanceof Date) { b = encodeLong(((Date) o).getTime(), SPECIAL_DATE); } else if (o instanceof Byte) { b = encodeByte((Byte) o); } else if (o instanceof Float) { b = encodeFloat((Float) o); } else if (o instanceof Double) { b = encodeDouble((Double) o); } else if (o instanceof Character) { b = encodeCharacter((Character) o); } else { b = serialize(o); flags |= SERIALIZED; } assert b != null; if (b.length > compressionThreshold) { byte[] compressed = compress(b); if (compressed.length < b.length) { getLogger().info(\"Compressed %s from %d to %d\", o.getClass().getName(), b.length, compressed.length); b = compressed; flags |= COMPRESSED; } else { getLogger().info(\"Compression increased the size of %s from %d to %d\", o.getClass().getName(), b.length, compressed.length); } } return new CachedData(flags, b, getMaxSize()); } public Object decode(CachedData d) { byte[] data = d.getData(); Object rv = null; if ((d.getFlags() & COMPRESSED) != 0) { data = decompress(d.getData()); } if ((d.getFlags() & SERIALIZED) != 0) { rv = deserialize(data); } else { int f = data[0]; switch (f) { case SPECIAL_BOOLEAN: rv = decodeBoolean(data); break; case SPECIAL_INTEGER: rv = decodeInteger(data); break; case SPECIAL_SHORT: rv = decodeShort(data); break; case SPECIAL_LONG: rv = decodeLong(data); break; case SPECIAL_DATE: rv = new Date(decodeLong(data)); break; case SPECIAL_BYTE: rv = decodeByte(data); break; case SPECIAL_FLOAT: rv = decodeFloat(data); break; case SPECIAL_DOUBLE: rv = decodeDouble(data); break; case SPECIAL_STRING: rv = decodeW1String(data); break; case SPECIAL_STRINGBUFFER: rv = new StringBuffer(decodeW1String(data)); break; case SPECIAL_STRINGBUILDER: rv = new StringBuilder(decodeW1String(data)); break; case SPECIAL_CHARACTER: rv = decodeCharacter(data); break; default: getLogger().warn(\"Cannot handle data with flags %x\", f); } } return rv; } private Short decodeShort(byte[] data) { return Short.valueOf((short) decodeInteger(data).intValue()); } private Byte decodeByte(byte[] in) { assert in.length == 2 : \"Wrong length for a byte\"; byte value = in[1]; return Byte.valueOf(value); } private Integer decodeInteger(byte[] in) { assert in.length == 5 : \"Wrong length for an int\"; return Integer.valueOf((int) decodeLong(in).longValue()); } private Float decodeFloat(byte[] in) { assert in.length == 5 : \"Wrong length for a float\"; Integer l = decodeInteger(in); return Float.valueOf(Float.intBitsToFloat(l.intValue())); } private Double decodeDouble(byte[] in) { assert in.length == 9 : \"Wrong length for a double\"; Long l = decodeLong(in); return Double.valueOf(Double.longBitsToDouble(l.longValue())); } private Boolean decodeBoolean(byte[] in) { assert in.length == 2 : \"Wrong length for a boolean\"; return Boolean.valueOf(in[1] == 1); } private Long decodeLong(byte[] in) { long rv = 0L; for (int idx = 1; idx < in.length; idx++) { byte i = in[idx]; rv = (rv << 8) | (i < 0 ? 256 + i : i); } return Long.valueOf(rv); } private Character decodeCharacter(byte[] b) { return Character.valueOf((char) decodeInteger(b).intValue()); } private String decodeW1String(byte[] b) { try { return new String(b, 1, b.length - 1, charset); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } } private byte[] encodeByte(Byte value) { byte[] b = new byte[2]; b[0] = SPECIAL_BYTE; b[1] = value.byteValue(); return b; } private byte[] encodeBoolean(Boolean value) { byte[] b = new byte[2]; b[0] = SPECIAL_BOOLEAN; b[1] = (byte) (value.booleanValue() ? 1 : 0); return b; } private byte[] encodeInteger(Integer value) { byte[] b = encodeNum(value, 4); b[0] = SPECIAL_INTEGER; return b; } private byte[] encodeLong(Long value, int type) { byte[] b = encodeNum(value, 8); b[0] = (byte) type; return b; } private byte[] encodeLong(Long value) { return encodeLong(value, SPECIAL_LONG); } private byte[] encodeShort(Short value) { byte[] b = encodeInteger((int) value.shortValue()); b[0] = SPECIAL_SHORT; return b; } private byte[] encodeFloat(Float value) { byte[] b = encodeInteger(Float.floatToIntBits(value)); b[0] = SPECIAL_FLOAT; return b; } private byte[] encodeDouble(Double value) { byte[] b = encodeLong(Double.doubleToLongBits(value)); b[0] = SPECIAL_DOUBLE; return b; } private byte[] encodeCharacter(Character value) { byte[] result = encodeInteger((int) value.charValue()); result[0] = SPECIAL_CHARACTER; return result; } private byte[] encodeStringBuffer(StringBuffer value) { byte[] b = encodeW1String(value.toString()); b[0] = SPECIAL_STRINGBUFFER; return b; } private byte[] encodeStringbuilder(StringBuilder value) { byte[] b = encodeW1String(value.toString()); b[0] = SPECIAL_STRINGBUILDER; return b; } private byte[] encodeW1String(String value) { byte[] svalue = null; try { svalue = value.getBytes(charset); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } byte[] result = new byte[svalue.length + 1]; System.arraycopy(svalue, 0, result, 1, svalue.length); result[0] = SPECIAL_STRING; return result; } private byte[] encodeNum(long l, int maxBytes) { byte[] rv = new byte[maxBytes + 1]; for (int i = 0; i < rv.length - 1; i++) { int pos = rv.length - i - 1; rv[pos] = (byte) ((l >> (8 * i)) & 0xff); } return rv; } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.util; import java.util.Iterator; import java.util.Map; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import net.spy.memcached.MemcachedClientIF; import net.spy.memcached.compat.SpyObject; import net.spy.memcached.internal.ImmediateFuture;  public class CacheLoader extends SpyObject { private final ExecutorService executorService; private final StorageListener storageListener; private final MemcachedClientIF client; private final int expiration;  public CacheLoader(MemcachedClientIF c) { this(c, null, null, 0); }  public CacheLoader(MemcachedClientIF c, ExecutorService es, StorageListener sl, int exp) { super(); client = c; executorService = es; storageListener = sl; expiration = exp; }  public <T> Future<?> loadData(Iterator<Map.Entry<String, T>> i) { Future<Boolean> mostRecent = null; while (i.hasNext()) { Map.Entry<String, T> e = i.next(); mostRecent = push(e.getKey(), e.getValue()); watch(e.getKey(), mostRecent); } return mostRecent == null ? new ImmediateFuture(true) : mostRecent; }  public <T> Future<?> loadData(Map<String, T> map) { return loadData(map.entrySet().iterator()); }  public <T> Future<Boolean> push(String k, T value) { Future<Boolean> rv = null; while (rv == null) { try { rv = client.set(k, expiration, value); } catch (IllegalStateException ex) { "}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.util; import net.spy.memcached.KetamaNodeKeyFormatter; import net.spy.memcached.MemcachedNode;  public class DefaultKetamaNodeLocatorConfiguration implements KetamaNodeLocatorConfiguration { private final int numReps = 160; private final KetamaNodeKeyFormatter ketamaNodeKeyFormatter;  public DefaultKetamaNodeLocatorConfiguration() { ketamaNodeKeyFormatter = new KetamaNodeKeyFormatter(); }  public DefaultKetamaNodeLocatorConfiguration(KetamaNodeKeyFormatter nodeKeyFormatter) { ketamaNodeKeyFormatter = nodeKeyFormatter; }  public int getNodeRepetitions() { return numReps; }  public String getKeyForNode(MemcachedNode node, int repetition) { return ketamaNodeKeyFormatter.getKeyForNode(node, repetition); } }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.util; import net.spy.memcached.MemcachedNode;  public interface KetamaNodeLocatorConfiguration {  String getKeyForNode(MemcachedNode node, int repetition);  int getNodeRepetitions(); }"}
{"name": "dustin/java-memcached-client", "content": " package net.spy.memcached.util; import net.spy.memcached.KeyUtil; import net.spy.memcached.MemcachedClientIF; import java.util.Collection; import java.util.Iterator; import java.util.regex.Pattern;  public final class StringUtils {  private static final Pattern decimalPattern = Pattern.compile(\"^-?\\\\d+$\");  private static final int MAX_KEY_LENGTH = MemcachedClientIF.MAX_KEY_LENGTH;  private static final IllegalArgumentException KEY_TOO_LONG_EXCEPTION = new IllegalArgumentException(\"Key is too long (maxlen = \" + MAX_KEY_LENGTH + ')');  private static final IllegalArgumentException KEY_EMPTY_EXCEPTION = new IllegalArgumentException(\"Key must contain at least one character.\");  static { KEY_TOO_LONG_EXCEPTION.setStackTrace(new StackTraceElement[0]); KEY_EMPTY_EXCEPTION.setStackTrace(new StackTraceElement[0]); }  private StringUtils() { throw new UnsupportedOperationException(); }  public static String join(final Collection<String> chunks, final String delimiter) { StringBuilder sb = new StringBuilder(); if (!chunks.isEmpty()) { Iterator<String> itr = chunks.iterator(); sb.append(itr.next()); while (itr.hasNext()) { sb.append(delimiter); sb.append(itr.next()); } } return sb.toString(); }  public static boolean isJsonObject(final String s) { if (s == null || s.isEmpty()) { return false; } if (s.startsWith(\"{\") || s.startsWith(\"[\") || \"true\".equals(s) || \"false\".equals(s) || \"null\".equals(s) || decimalPattern.matcher(s).matches()) { return true; } return false; }  public static void validateKey(final String key, final boolean binary) { byte[] keyBytes = KeyUtil.getKeyBytes(key); int keyLength = keyBytes.length; if (keyLength > MAX_KEY_LENGTH) { throw KEY_TOO_LONG_EXCEPTION; } if (keyLength == 0) { throw KEY_EMPTY_EXCEPTION; } if(!binary) { for (byte b : keyBytes) { if (b == ' ' || b == '\\n' || b == '\\r' || b == 0) { throw new IllegalArgumentException( \"Key contains invalid characters: ``\" + key + \"''\"); } } } } }"}
{"name": "rictic/code_swarm", "content": "import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.UnsupportedEncodingException; import java.net.URL; import java.net.URLConnection; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class AvatarFetcher { protected CodeSwarmConfig cfg; public int size; public AvatarFetcher(CodeSwarmConfig cfg) { this.cfg = cfg; size = cfg.getPositiveIntProperty(\"AvatarSize\"); } public String fetchUserImage(String username) { throw new RuntimeException(\"Override fetchUserImage in your Avatar Fetcher\"); } protected static String getFilename(String key){ return \"image_cache/\" + key; } protected static boolean imageCached(String key) { return new File(getFilename(key)).exists(); } protected static String getImage(String key, URL url) { String filename = getFilename(key); if (!imageCached(key)){ boolean successful = fetchImage(filename, url); if (!successful) return null; } return filename; } protected static boolean fetchImage(String filename, URL url) { try { new File(\"image_cache\").mkdirs(); URLConnection con = url.openConnection(); InputStream input = con.getInputStream(); FileOutputStream output = new FileOutputStream(filename); int length = con.getContentLength(); if (length == -1){ "}
{"name": "rictic/code_swarm", "content": "/* Copyright 2008 Michael Ogawa This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/* Copyright 2008 Michael Ogawa This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/** * Copyright 2008 Michael Ogawa * * This file is part of code_swarm. * * code_swarm is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * code_swarm is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.util.regex.Matcher; import java.util.regex.Pattern; public class FreebaseAvatarFetcher extends AvatarFetcher{ public FreebaseAvatarFetcher(CodeSwarmConfig cfg) { super(cfg); } static private Pattern imageIDPattern = Pattern.compile(\"\\\"image:id\\\"\\\\s*:\\\\s*\\\"(.*?)\\\"\"); private static String readURLToString(URL url) { try { URLConnection con = url.openConnection(); BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream())); StringBuilder sb = new StringBuilder(); int length = con.getContentLength(); if (length == -1){ "}
{"name": "rictic/code_swarm", "content": "import java.net.MalformedURLException; import java.net.URL; import java.util.regex.Pattern; import java.util.regex.Matcher; public class GravatarFetcher extends AvatarFetcher { public GravatarFetcher(CodeSwarmConfig cfg) { super(cfg); } public String fetchUserImage(String username) { String email = getEmail(username); String hash = md5Hex(email); try { return getImage(hash, new URL(\"http:"}
{"name": "rictic/code_swarm", "content": "import java.io.File; public class LocalAvatar extends AvatarFetcher { public String dir = \"\"; public String empty_pic = null; public LocalAvatar(CodeSwarmConfig cfg) { super(cfg); dir = cfg.getStringProperty(\"LocalAvatarDirectory\"); empty_pic = cfg.getStringProperty(\"LocalAvatarDefaultPic\"); } public String fetchUserImage(String username) { String filename = dir+username+\".png\"; File f = new File(filename); if(f.exists()) return filename; return dir+empty_pic; } }"}
{"name": "rictic/code_swarm", "content": "/* This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "public class NoAvatar extends AvatarFetcher { public NoAvatar(CodeSwarmConfig cfg) { super(cfg); } public String fetchUserImage(String username) { return null; } }"}
{"name": "rictic/code_swarm", "content": "import javax.vecmath.Vector2f; /** * Copyright 2008 code_swarm project team * * This file is part of code_swarm. * * code_swarm is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * code_swarm is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/** * Copyright 2008 code_swarm project team * * This file is part of code_swarm. * * code_swarm is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * code_swarm is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/** * Copyright 2008 code_swarm project team * * This file is part of code_swarm. * * code_swarm is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * code_swarm is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/** * Copyright 2008 Michael Ogawa * * This file is part of code_swarm. * * code_swarm is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * code_swarm is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "  package org.codeswarm.dependencies.sun.tools.javac.util;  public class Pair<A, B> { public final A fst; public final B snd; public Pair(A fst, B snd) { this .fst = fst; this .snd = snd; } public String toString() { return \"Pair[\" + fst + \",\" + snd + \"]\"; } private static boolean equals(Object x, Object y) { return (x == null && y == null) || (x != null && x.equals(y)); } public boolean equals(Object other) { return other instanceof Pair && equals(fst, ((Pair) other).fst) && equals(snd, ((Pair) other).snd); } public int hashCode() { if (fst == null) return (snd == null) ? 0 : snd.hashCode() + 1; else if (snd == null) return fst.hashCode() + 2; else return fst.hashCode() * 17 + snd.hashCode(); } public static <A, B> Pair<A, B> of(A a, B b) { return new Pair<A, B>(a, b); } }"}
{"name": "rictic/code_swarm", "content": "/* This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/* This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/* This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/* This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/* This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "rictic/code_swarm", "content": "/* This file is part of code_swarm. code_swarm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. code_swarm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with code_swarm. If not, see <http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Alexander Coles (Ikonoklastik Productions). * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "package org.nbgit; public interface GitRepository { public static final String REVISION_BASE = \"BASE\"; "}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2008 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2008 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2008 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2008 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2008 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2008 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2008 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2008 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "package org.nbgit.ui.log; /* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Alexander Coles (Ikonoklastik Productions). * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "package org.nbgit.ui.status; import java.awt.event.ActionEvent; import java.util.ArrayList; import java.util.List; import javax.swing.SwingUtilities; import org.netbeans.api.project.Project; import org.netbeans.api.project.ProjectInformation; import org.netbeans.api.project.ProjectUtils; import org.netbeans.api.project.ui.OpenProjects; import org.netbeans.modules.versioning.spi.VCSContext; import org.openide.nodes.AbstractNode; import org.openide.nodes.Children; import org.openide.nodes.Node; import org.openide.util.HelpCtx; import org.openide.util.NbBundle; import org.openide.util.RequestProcessor; import org.openide.util.actions.SystemAction;  public class ShowAllChangesAction extends SystemAction { public ShowAllChangesAction() { } public String getName() { return NbBundle.getMessage(ShowAllChangesAction.class, \"CTL_MenuItem_ShowAllChanges_Label\"); "}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "package org.nbgit.ui.status; import java.io.File; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.logging.Level; import javax.swing.Action; import org.nbgit.StatusInfo; import org.nbgit.Git; import org.nbgit.ui.GitFileNode; import org.nbgit.ui.diff.DiffAction; import org.nbgit.util.GitUtils; import org.nbgit.util.HtmlFormatter; import org.openide.filesystems.FileObject; import org.openide.filesystems.FileUtil; import org.openide.loaders.DataObject; import org.openide.loaders.DataObjectNotFoundException; import org.openide.nodes.AbstractNode; import org.openide.nodes.Children; import org.openide.nodes.Sheet; import org.openide.util.NbBundle; import org.openide.util.RequestProcessor; import org.openide.util.lookup.Lookups;  public class SyncFileNode extends AbstractNode { private GitFileNode node; static final String COLUMN_NAME_NAME = \"name\"; "}
{"name": "myabc/nbgit", "content": "package org.nbgit.ui.status; import java.awt.Color; import java.awt.Component; import java.awt.Point; import java.awt.event.ActionEvent; import java.awt.event.KeyEvent; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.io.File; import java.lang.reflect.InvocationTargetException; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.logging.Level; import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.BorderFactory; import javax.swing.JComponent; import javax.swing.JMenuItem; import javax.swing.JPopupMenu; import javax.swing.JScrollPane; import javax.swing.JSeparator; import javax.swing.JTable; import javax.swing.KeyStroke; import javax.swing.ListSelectionModel; import javax.swing.SwingUtilities; import javax.swing.UIManager; import javax.swing.event.AncestorEvent; import javax.swing.event.AncestorListener; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import javax.swing.table.DefaultTableCellRenderer; import org.nbgit.StatusInfo; import org.nbgit.StatusCache; import org.nbgit.Git; import org.nbgit.GitAnnotator; import org.nbgit.GitModuleConfig; import org.nbgit.util.GitUtils; import org.nbgit.ui.commit.CommitAction; import org.nbgit.ui.commit.ExcludeFromCommitAction; import org.nbgit.ui.diff.DiffAction; import org.nbgit.ui.log.SearchHistoryAction; import org.nbgit.ui.update.RevertModificationsAction; import org.nbgit.util.HtmlFormatter; import org.netbeans.modules.versioning.spi.VCSContext; import org.netbeans.modules.versioning.util.FilePathCellRenderer; import org.netbeans.modules.versioning.util.TableSorter; import org.openide.awt.Mnemonics; import org.openide.awt.MouseUtils; import org.openide.explorer.view.NodeTableModel; import org.openide.nodes.Node; import org.openide.nodes.PropertySupport.ReadOnly; import org.openide.util.NbBundle; import org.openide.windows.TopComponent;  class SyncTable implements MouseListener, ListSelectionListener, AncestorListener { private NodeTableModel tableModel; private JTable table; private JScrollPane component; private SyncFileNode[] nodes = new SyncFileNode[0]; private String[] tableColumns; private TableSorter sorter;  private static final Map<String, String[]> columnLabels = new HashMap<String, String[]>(4); { ResourceBundle loc = NbBundle.getBundle(SyncTable.class); columnLabels.put(SyncFileNode.COLUMN_NAME_BRANCH, new String[]{ loc.getString(\"CTL_VersioningView_Column_Branch_Title\"), "}
{"name": "myabc/nbgit", "content": "package org.nbgit.ui.status; import java.awt.Component; import java.awt.Container; import java.awt.Dimension; import java.awt.Font; import java.awt.FontMetrics; import java.awt.Graphics2D; import java.awt.GridBagConstraints; import java.awt.Insets; import java.awt.LayoutManager; import java.awt.event.ActionListener; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.awt.image.BufferedImage; import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.io.File; import java.io.IOException; import java.util.HashSet; import java.util.Set; import java.util.logging.Level; import java.util.prefs.PreferenceChangeEvent; import java.util.prefs.PreferenceChangeListener; import javax.swing.AbstractButton; import javax.swing.JComponent; import javax.swing.JPanel; import javax.swing.JProgressBar; import javax.swing.JSeparator; import javax.swing.JToggleButton; import javax.swing.SwingUtilities; import javax.swing.UIDefaults; import javax.swing.UIManager; import javax.swing.border.CompoundBorder; import org.netbeans.api.progress.ProgressHandle; import org.netbeans.api.progress.ProgressHandleFactory; import org.nbgit.Git; import org.nbgit.GitModuleConfig; import org.nbgit.GitProgressSupport; import org.nbgit.StatusInfo; import org.nbgit.StatusCache; import org.nbgit.task.StatusTask; import org.nbgit.ui.GitFileNode; import org.nbgit.ui.commit.CommitAction; import org.nbgit.ui.diff.DiffAction; import org.nbgit.ui.diff.Setup; import org.nbgit.ui.update.UpdateAction; import org.nbgit.util.GitUtils; import org.netbeans.modules.versioning.spi.VCSContext; import org.netbeans.modules.versioning.util.NoContentPanel; import org.openide.LifecycleManager; import org.openide.explorer.ExplorerManager; import org.openide.nodes.Node; import org.openide.util.Exceptions; import org.openide.util.NbBundle; import org.openide.util.RequestProcessor; import org.openide.windows.TopComponent; import org.eclipse.jgit.lib.Constants; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.Repository;  class VersioningPanel extends JPanel implements ExplorerManager.Provider, PreferenceChangeListener, PropertyChangeListener, ActionListener { private ExplorerManager explorerManager; private final GitVersioningTopComponent parentTopComponent; private final Git git; private VCSContext context; private int displayStatuses; private String branchInfo; private SyncTable syncTable; private RequestProcessor.Task refreshViewTask; private Thread refreshViewThread; private GitProgressSupport gitProgressSupport; private static final RequestProcessor rp = new RequestProcessor(\"GitView\", 1, true); "}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2009 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Imran M Yousuf <imyousuf@smartitengineering.com> * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved. * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "  package org.nbgit.util.exclude; import java.util.EnumSet;  public class FnMatch { public static enum Flag {  NOESCAPE,  PATHNAME,  PERIOD,  LEADING_DIR,  CASEFOLD } private static final int RANGE_ERROR = -1; private static final int RANGE_NOMATCH = 0; public static boolean fnmatch(String pattern, String string, EnumSet<Flag> flags) { return match(pattern, 0, string, 0, flags); } public static boolean fnmatch(String pattern, String string, int stringPos, Flag flag) { return match(pattern, 0, string, stringPos, EnumSet.of(flag)); } public static boolean fnmatch(String pattern, String string, int stringPos) { return match(pattern, 0, string, stringPos, EnumSet.noneOf(Flag.class)); } public static boolean fnmatch(String pattern, String string) { return fnmatch(pattern, string, 0); } private static boolean match(String pattern, int patternPos, String string, int stringPos, EnumSet<Flag> flags) { char c; while (true) { if (patternPos >= pattern.length()) { if (flags.contains(Flag.LEADING_DIR) && string.charAt(stringPos) == '/') { return true; } return stringPos == string.length(); } c = pattern.charAt(patternPos++); switch (c) { case '?': if (stringPos >= string.length()) { return false; } if (string.charAt(stringPos) == '/' && flags.contains(Flag.PATHNAME)) { return false; } if (hasLeadingPeriod(string, stringPos, flags)) { return false; } ++stringPos; continue; case '*':  while (patternPos < pattern.length() && (c = pattern.charAt(patternPos)) == '*') { patternPos++; } if (hasLeadingPeriod(string, stringPos, flags)) { return false; }  if (patternPos == pattern.length()) { if (flags.contains(Flag.PATHNAME)) { return flags.contains(Flag.LEADING_DIR) || string.indexOf('/', stringPos) == -1; } return true; } else if (c == '/' && flags.contains(Flag.PATHNAME)) { stringPos = string.indexOf('/', stringPos); if (stringPos == -1) { return false; } continue; }  while (stringPos < string.length()) { if (flags.contains(Flag.PERIOD)) { flags = EnumSet.copyOf(flags); flags.remove(Flag.PERIOD); } if (match(pattern, patternPos, string, stringPos, flags)) { return true; } if (string.charAt(stringPos) == '/' && flags.contains(Flag.PATHNAME)) { break; } ++stringPos; } return false; case '[': if (stringPos >= string.length()) { return false; } if (string.charAt(stringPos) == '/' && flags.contains(Flag.PATHNAME)) { return false; } if (hasLeadingPeriod(string, stringPos, flags)) { return false; } int result = matchRange(pattern, patternPos, string.charAt(stringPos), flags); if (result == RANGE_ERROR)  { break; } if (result == RANGE_NOMATCH) { return false; } patternPos = result; ++stringPos; continue; case '\\\\': if (!flags.contains(Flag.NOESCAPE)) { if (patternPos >= pattern.length()) { c = '\\\\'; } else { c = pattern.charAt(patternPos++); } } break; } if (stringPos >= string.length()) { return false; } if (c != string.charAt(stringPos) && !(flags.contains(Flag.CASEFOLD) && Character.toLowerCase(c) == Character.toLowerCase(string.charAt(stringPos)))) { return false; } ++stringPos; }  } private static boolean hasLeadingPeriod(String string, int stringPos, EnumSet<Flag> flags) { if (stringPos > string.length() - 1) return false; return (stringPos == 0 || (flags.contains(Flag.PATHNAME) && string.charAt(stringPos - 1) == '/')) && string.charAt(stringPos) == '.' && flags.contains(Flag.PERIOD); } private static int matchRange(String pattern, int patternPos, char test, EnumSet<Flag> flags) { boolean negate, ok; char c, c2; if (patternPos >= pattern.length()) { return RANGE_ERROR; }  c = pattern.charAt(patternPos); negate = c == '!' || c == '^'; if (negate) { ++patternPos; } if (flags.contains(Flag.CASEFOLD)) { test = Character.toLowerCase(test); }  ok = false; while (true) { if (patternPos >= pattern.length()) { return RANGE_ERROR; } c = pattern.charAt(patternPos++); if (c == ']') { break; } if (c == '\\\\' && !flags.contains(Flag.NOESCAPE)) { c = pattern.charAt(patternPos++); } if (c == '/' && flags.contains(Flag.PATHNAME)) { return RANGE_NOMATCH; } if (flags.contains(Flag.CASEFOLD)) { c = Character.toLowerCase(c); } if (pattern.charAt(patternPos) == '-' && patternPos + 1 < pattern.length() && (c2 = pattern.charAt(patternPos + 1)) != ']') { patternPos += 2; if (c2 == '\\\\' && !flags.contains(Flag.NOESCAPE)) { if (patternPos >= pattern.length()) { return RANGE_ERROR; } c = pattern.charAt(patternPos++); } if (flags.contains(Flag.CASEFOLD)) { c2 = Character.toLowerCase(c2); } if (c <= test && test <= c2) { ok = true; } } else if (c == test) { ok = true; } } return ok == negate ? RANGE_NOMATCH : patternPos; } }"}
{"name": "myabc/nbgit", "content": "/* * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. * * Copyright 2009 Jonas Fonseca <fonseca@diku.dk> * * The contents of this file are subject to the terms of either the GNU * General Public License Version 2 only (\"GPL\") or the Common * Development and Distribution License(\"CDDL\") (collectively, the * \"License\"). You may not use this file except in compliance with the * License. You can obtain a copy of the License at * http:"}
{"name": "myabc/nbgit", "content": "package org.nbgit.util.exclude; import java.util.Vector; public class PathPatternList { private final Vector<PathPattern> patterns = new Vector<PathPattern>(); private final String basePath; public PathPatternList(String basePath) { this.basePath = basePath; } public void add(String patternString) { PathPattern pattern = PathPattern.create(patternString); if (pattern.isExclude()) { patterns.add(pattern); } else { patterns.add(0, pattern); } } public PathPattern findPattern(String path, boolean isDirectory) { for (PathPattern pattern : patterns) { if (pattern.matches(path, isDirectory, basePath)) { return pattern; } } return null; } @Override public String toString() { StringBuilder builder = new StringBuilder(getClass().getSimpleName()); builder.append(\"[\"); builder.append(basePath); builder.append(\"; \"); builder.append(patterns.size()); builder.append(\"]\"); return builder.toString(); } }"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": ""}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj; public class DbSessionClosedException extends DbException { private static final long serialVersionUID = 1L; public DbSessionClosedException(DbSession session, String message, Throwable cause) { super(session, message, cause); } public DbSessionClosedException(DbSession session, String message) { super(session, message); } public DbSessionClosedException(DbSession session, Throwable cause) { super(session, cause); } public DbSessionClosedException(DbSession session) { super(session); } }"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.support; import org.adbcj.DbException; import org.adbcj.DbSession; public class ActiveRequestIncomplete extends DbException { private static final long serialVersionUID = 1L; public ActiveRequestIncomplete(DbSession session, String message) { super(session, message); } }"}
{"name": "mheath/adbcj", "content": "package org.adbcj.support;  public enum ByteOrder { BIG_ENDIAN, LITTLE_ENDIAN }"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.support; import java.io.InputStream; import java.io.IOException; import java.io.EOFException; import java.nio.charset.Charset;  public class DecoderInputStream extends InputStream { private final InputStream in; private int limit = Integer.MAX_VALUE; private ByteOrder byteOrder = ByteOrder.BIG_ENDIAN; public DecoderInputStream(InputStream in) { this(in, Integer.MAX_VALUE); } public DecoderInputStream(InputStream in, int limit) { this.in = in; this.limit = limit; } public int available() throws IOException { return in.available(); } public void close() throws IOException { in.close(); } public void mark(int readlimit) { in.mark(readlimit); } public boolean markSupported() { return in.markSupported(); } @Override public int read() throws IOException { int i = in.read(); if (i >= 0) { limit--; } assertLimit(); return i; } private void assertLimit() { if (limit < 0) { throw new IllegalStateException(\"Read too many bytes\"); } } @Override public int read(byte[] b, int off, int len) throws IOException { int i = in.read(b, off, len); limit -= i; assertLimit(); return i; } @Override public long skip(long n) throws IOException { long i = in.skip(n); limit -= i; assertLimit(); return i; } public void reset() throws IOException { in.reset(); } public int getLimit() { return limit; } public void setLimit(int limit) { this.limit = limit; } public ByteOrder getByteOrder() { return byteOrder; } public void setByteOrder(ByteOrder byteOrder) { this.byteOrder = byteOrder; } public byte readByte() throws IOException { int ch = read(); if (ch < 0) { throw new EOFException(); } return (byte) (ch); } public int readInt() throws IOException { int ch1 = read(); int ch2 = read(); int ch3 = read(); int ch4 = read(); if ((ch1 | ch2 | ch3 | ch4) < 0) { throw new EOFException(); } return (byteOrder == ByteOrder.BIG_ENDIAN) ? ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0)) : ((ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0)); } public int readUnsignedShort() throws IOException { int ch1 = in.read(); int ch2 = in.read(); if ((ch1 | ch2) < 0) { throw new EOFException(); } return (byteOrder == ByteOrder.BIG_ENDIAN) ? (ch1 << 8) + (ch2 << 0) : (ch2 << 8) + (ch1 << 0); } public final short readShort() throws IOException { int ch1 = in.read(); int ch2 = in.read(); if ((ch1 | ch2) < 0) { throw new EOFException(); } return (byteOrder == ByteOrder.BIG_ENDIAN) ? (short)((ch1 << 8) + (ch2 << 0)) : (short)((ch2 << 8) + (ch1 << 0)); }  public String readString(Charset charset) throws IOException { "}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.support; import java.io.OutputStream; import java.io.IOException;  public class EncoderOutputStream extends OutputStream { private final OutputStream out; private int limit; private ByteOrder byteOrder = ByteOrder.BIG_ENDIAN; public EncoderOutputStream(OutputStream out) { this.out = out; } @Override public void close() throws IOException { out.close(); } @Override public void flush() throws IOException { out.flush(); } @Override public void write(byte[] b) throws IOException { out.write(b, 0, b.length); } @Override public void write(byte[] b, int off, int len) throws IOException { limit -= len; assertLimit(); out.write(b, off, len); } private void assertLimit() { if (limit < 0) { throw new IllegalStateException(\"Exceeded write limit\"); } } @Override public void write(int b) throws IOException { limit--; out.write(b); } public ByteOrder getByteOrder() { return byteOrder; } public void setByteOrder(ByteOrder byteOrder) { this.byteOrder = byteOrder; } public int getLimit() { return limit; } public void setLimit(int limit) { this.limit = limit; } public void writeInt(int v) throws IOException { if (byteOrder == ByteOrder.BIG_ENDIAN) { out.write((v >>> 24) & 0xFF); out.write((v >>> 16) & 0xFF); out.write((v >>> 8) & 0xFF); out.write(v & 0xFF); } else { out.write(v & 0xFF); out.write((v >>> 8) & 0xFF); out.write((v >>> 16) & 0xFF); out.write((v >>> 24) & 0xFF); } } public void writeShort(short v) throws IOException { if (byteOrder == ByteOrder.BIG_ENDIAN) { out.write((v >>> 8) & 0xFF); out.write(v & 0xFF); } else { out.write(v & 0xFF); out.write((v >>> 8) & 0xFF); } } }"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.mysql.codec; import java.util.EnumSet; import java.util.Set; import org.adbcj.Connection; import org.adbcj.ConnectionManager; import org.adbcj.DbException; import org.adbcj.DbFuture; import org.adbcj.DbSessionClosedException; import org.adbcj.DbSessionFuture; import org.adbcj.PreparedStatement; import org.adbcj.Result; import org.adbcj.ResultEventHandler; import org.adbcj.support.AbstractDbSession; import org.adbcj.support.DefaultDbFuture; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public abstract class AbstractMySqlConnection extends AbstractDbSession implements Connection { private static final Logger logger = LoggerFactory.getLogger(AbstractMySqlConnection.class); private final AbstractMySqlConnectionManager connectionManager; private final int id; private final LoginCredentials credentials; private Request<Void> closeRequest; "}
{"name": "mheath/adbcj", "content": "package org.adbcj.mysql.codec; import java.util.HashSet; import java.util.Properties; import java.util.Set; import java.util.concurrent.atomic.AtomicInteger; import org.adbcj.Connection; import org.adbcj.ConnectionManager; import org.adbcj.DbException; import org.adbcj.DbFuture; import org.adbcj.support.DefaultDbFuture; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public abstract class AbstractMySqlConnectionManager implements ConnectionManager { private static final Logger logger = LoggerFactory.getLogger(AbstractMySqlConnectionManager.class); private final LoginCredentials credentials; private final AtomicInteger id = new AtomicInteger(); private final Set<AbstractMySqlConnection> connections = new HashSet<AbstractMySqlConnection>(); private DbFuture<Void> closeFuture = null; private volatile boolean pipeliningEnabled = true; public AbstractMySqlConnectionManager(String username, String password, String schema, Properties properties) { this.credentials = new LoginCredentials(username, password, schema); } public synchronized DbFuture<Void> close(boolean immediate) throws DbException { if (isClosed()) { return closeFuture; } "}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.mysql.codec; import java.util.LinkedList; import java.util.List; import org.adbcj.Connection; import org.adbcj.DbException; import org.adbcj.Result; import org.adbcj.ResultSet; import org.adbcj.Value; import org.adbcj.support.DefaultDbFuture; import org.adbcj.support.DefaultResult; import org.adbcj.support.AbstractDbSession.Request; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class ProtocolHandler { private final Logger logger = LoggerFactory.getLogger(ProtocolHandler.class); public void connectionClosed(AbstractMySqlConnection connection) throws Exception { logger.trace(\"IoSession closed\"); connection.doClose(); }  public Throwable handleException(AbstractMySqlConnection connection, Throwable cause) throws Exception { logger.debug(\"Caught exception: \", cause); DbException dbException = DbException.wrap(connection, cause); if (connection != null) { DefaultDbFuture<Connection> connectFuture = connection.getConnectFuture(); if (!connectFuture.isDone()) { connectFuture.setException(dbException); return null; } Request<?> activeRequest = connection.getActiveRequest(); if (activeRequest != null) { if (!activeRequest.isDone()) { try { activeRequest.error(dbException); return null; } catch (Throwable e) { return e; } } } } return dbException; } public void messageReceived(AbstractMySqlConnection connection, Object message) throws Exception { logger.trace(\"Received message: {}\", message); if (message instanceof ServerGreeting) { handleServerGreeting(connection, (ServerGreeting)message); } else if (message instanceof OkResponse) { handleOkResponse(connection, (OkResponse)message); } else if (message instanceof ErrorResponse) { handleErrorResponse(connection, (ErrorResponse)message); } else if (message instanceof ResultSetResponse) { handleResultSetResponse(connection, (ResultSetResponse)message); } else if (message instanceof ResultSetFieldResponse) { handleResultSetFieldResponse(connection, (ResultSetFieldResponse)message); } else if (message instanceof ResultSetRowResponse) { handleResultSetRowResponse(connection, (ResultSetRowResponse)message); } else if (message instanceof EofResponse) { handleEofResponse(connection, (EofResponse)message); } else { throw new IllegalStateException(\"Unable to handle message of type: \" + message.getClass().getName()); } } private void handleServerGreeting(AbstractMySqlConnection connection, ServerGreeting serverGreeting) { "}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* This file is part of ADBCJ. ADBCJ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. ADBCJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with ADBCJ. If not, see <http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.mysql.netty; import java.util.LinkedList; import java.util.List; import org.jboss.netty.channel.ChannelEvent; import org.jboss.netty.channel.ChannelHandlerContext; import org.jboss.netty.channel.ChannelPipelineCoverage; import org.jboss.netty.channel.ChannelUpstreamHandler; import org.jboss.netty.channel.MessageEvent; @ChannelPipelineCoverage(\"one\") class MessageQueuingHandler implements ChannelUpstreamHandler { private ChannelHandlerContext context; "}
{"name": "mheath/adbcj", "content": "package org.adbcj.mysql.netty; import java.net.URI; import java.net.URISyntaxException; import java.util.Properties; import org.adbcj.ConnectionManager; import org.adbcj.ConnectionManagerFactory; import org.adbcj.DbException; public class MySqlConnectionManagerFactory implements ConnectionManagerFactory { public static final String PROTOCOL = \"mysqlnetty\"; public static final int DEFAULT_PORT = 3306; @Override public ConnectionManager createConnectionManager(String url, String username, String password, Properties properties) throws DbException { try {  URI uri = new URI(url); "}
{"name": "mheath/adbcj", "content": "package org.adbcj.mysql.netty; import org.adbcj.Connection; import org.adbcj.mysql.codec.AbstractMySqlConnection; import org.adbcj.mysql.codec.AbstractMySqlConnectionManager; import org.adbcj.mysql.codec.ClientRequest; import org.adbcj.mysql.codec.LoginCredentials; import org.adbcj.support.DefaultDbFuture; import org.jboss.netty.channel.Channel; public class MysqlConnection extends AbstractMySqlConnection { private final Channel channel; private final DefaultDbFuture<Connection> connectFuture; public MysqlConnection(AbstractMySqlConnectionManager connectionManager, LoginCredentials credentials, Channel channel, DefaultDbFuture<Connection> connectFuture) { super(connectionManager, credentials); this.channel = channel; this.connectFuture = connectFuture; } @Override public DefaultDbFuture<Connection> getConnectFuture() { return connectFuture; } @Override protected boolean isTransportClosing() { return !channel.isOpen(); } @Override public void write(ClientRequest request) { channel.write(request); } }"}
{"name": "mheath/adbcj", "content": "package org.adbcj.mysql.netty; import java.io.InputStream; import java.net.InetSocketAddress; import java.util.Properties; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import org.adbcj.Connection; import org.adbcj.mysql.codec.AbstractMySqlConnectionManager; import org.adbcj.mysql.codec.ClientRequest; import org.adbcj.mysql.codec.MySqlClientDecoder; import org.adbcj.mysql.codec.MySqlClientEncoder; import org.adbcj.mysql.codec.ProtocolHandler; import org.adbcj.support.DefaultDbFuture; import org.jboss.netty.bootstrap.ClientBootstrap; import org.jboss.netty.buffer.ChannelBuffer; import org.jboss.netty.buffer.ChannelBufferInputStream; import org.jboss.netty.buffer.ChannelBufferOutputStream; import org.jboss.netty.buffer.ChannelBuffers; import org.jboss.netty.channel.Channel; import org.jboss.netty.channel.ChannelDownstreamHandler; import org.jboss.netty.channel.ChannelEvent; import org.jboss.netty.channel.ChannelFactory; import org.jboss.netty.channel.ChannelFuture; import org.jboss.netty.channel.ChannelFutureListener; import org.jboss.netty.channel.ChannelHandlerContext; import org.jboss.netty.channel.ChannelPipeline; import org.jboss.netty.channel.ChannelPipelineCoverage; import org.jboss.netty.channel.ChannelPipelineFactory; import org.jboss.netty.channel.ChannelStateEvent; import org.jboss.netty.channel.Channels; import org.jboss.netty.channel.ExceptionEvent; import org.jboss.netty.channel.MessageEvent; import org.jboss.netty.channel.SimpleChannelHandler; import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory; import org.jboss.netty.handler.codec.frame.FrameDecoder; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class MysqlConnectionManager extends AbstractMySqlConnectionManager { private static final Logger logger = LoggerFactory.getLogger(MysqlConnectionManager.class); private static final String QUEUE_HANDLER = MysqlConnectionManager.class.getName() + \".queueHandler\"; private static final String ENCODER = MysqlConnectionManager.class.getName() + \".encoder\"; private static final String DECODER = MysqlConnectionManager.class.getName() + \".decoder\"; private final ExecutorService executorService; private final ClientBootstrap bootstrap; public MysqlConnectionManager(String host, int port, String username, String password, String schema, Properties properties) { super(username, password, schema, properties); executorService = Executors.newCachedThreadPool(); ChannelFactory factory = new NioClientSocketChannelFactory(executorService, executorService); bootstrap = new ClientBootstrap(factory); init(host, port); } public MysqlConnectionManager(String host, int port, String username, String password, String schema, Properties properties, ChannelFactory factory) { super(username, password, schema, properties); executorService = null; bootstrap = new ClientBootstrap(factory); init(host, port); } private void init(String host, int port) { bootstrap.setPipelineFactory(new ChannelPipelineFactory() { @Override public ChannelPipeline getPipeline() throws Exception { ChannelPipeline pipeline = Channels.pipeline(); pipeline.addFirst(QUEUE_HANDLER, new MessageQueuingHandler()); pipeline.addLast(DECODER, new Decoder()); pipeline.addLast(ENCODER, new Encoder()); return pipeline; } }); bootstrap.setOption(\"tcpNoDelay\", true); bootstrap.setOption(\"keepAlive\", true); bootstrap.setOption(\"remoteAddress\", new InetSocketAddress(host, port)); } @Override protected void dispose() { if (executorService != null) { executorService.shutdownNow(); } } @Override protected DefaultDbFuture<Connection> createConnectionFuture() { final ChannelFuture channelFuture = bootstrap.connect(); return new MysqlConnectFuture(channelFuture); } class MysqlConnectFuture extends DefaultDbFuture<Connection> { private final ChannelFuture channelFuture; public MysqlConnectFuture(ChannelFuture channelFuture) { this.channelFuture = channelFuture; channelFuture.addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { logger.debug(\"Connect completed\"); Channel channel = future.getChannel(); MysqlConnection connection = new MysqlConnection(MysqlConnectionManager.this, getCredentials(), channel, MysqlConnectFuture.this); channel.getPipeline().addLast(\"handler\", new Handler(connection)); MessageQueuingHandler queuingHandler = channel.getPipeline().get(MessageQueuingHandler.class); synchronized (queuingHandler) { queuingHandler.flush(); channel.getPipeline().remove(queuingHandler); } } }); } @Override protected boolean doCancel(boolean mayInterruptIfRunning) { return channelFuture.cancel(); } } } @ChannelPipelineCoverage(\"one\") class Decoder extends FrameDecoder { private final MySqlClientDecoder decoder = new MySqlClientDecoder(); @Override protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception { InputStream in = new ChannelBufferInputStream(buffer); try { return decoder.decode(in, false); } finally { in.close(); } } } @ChannelPipelineCoverage(\"all\") class Encoder implements ChannelDownstreamHandler { private final MySqlClientEncoder encoder = new MySqlClientEncoder(); public void handleDownstream(ChannelHandlerContext context, ChannelEvent event) throws Exception { if (!(event instanceof MessageEvent)) { context.sendDownstream(event); return; } MessageEvent e = (MessageEvent) event; if (!(e.getMessage() instanceof ClientRequest)) { context.sendDownstream(event); return; } ChannelBuffer buffer = ChannelBuffers.buffer(1024); ChannelBufferOutputStream out = new ChannelBufferOutputStream(buffer); encoder.encode((ClientRequest) e.getMessage(), out); Channels.write(context, e.getFuture(), buffer); } } @ChannelPipelineCoverage(\"one\") class Handler extends SimpleChannelHandler { private final MysqlConnection connection; private final ProtocolHandler handler = new ProtocolHandler(); public Handler(MysqlConnection connection) { this.connection = connection; } @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { handler.messageReceived(connection, e.getMessage()); } @Override public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception { Throwable t = handler.handleException(connection, e.getCause()); if (t != null) { "}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.postgresql.codec; import java.nio.charset.Charset;  public class ConnectionState { private final String databaseName; "}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.postgresql.codec; import org.adbcj.postgresql.codec.frontend.StartupMessage; import org.adbcj.postgresql.codec.frontend.SimpleFrontendMessage; import org.adbcj.postgresql.codec.frontend.FrontendMessageType; import org.adbcj.postgresql.codec.backend.AbstractBackendMessage; import org.adbcj.postgresql.codec.backend.AuthenticationMessage; import org.adbcj.postgresql.codec.backend.CommandCompleteMessage; import org.adbcj.postgresql.codec.backend.DataRowMessage; import org.adbcj.postgresql.codec.backend.ErrorResponseMessage; import org.adbcj.postgresql.codec.backend.KeyMessage; import org.adbcj.postgresql.codec.backend.ReadyMessage; import org.adbcj.postgresql.codec.backend.RowDescriptionMessage; import org.adbcj.support.AbstractDbSession; import org.adbcj.support.DefaultDbFuture; import org.adbcj.support.DefaultResult; import org.adbcj.Connection; import org.adbcj.DbException; import org.adbcj.Value; import org.adbcj.Field; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.Map; import java.util.HashMap; import java.util.Collections;  public class ProtocolHandler { private final Logger logger = LoggerFactory.getLogger(ProtocolHandler.class); private final AbstractConnectionManager connectionManager; public ProtocolHandler(AbstractConnectionManager connectionManager) { this.connectionManager = connectionManager; } public void connectionOpened(AbstractConnection connection) { Map<ConfigurationVariable, String> parameters = new HashMap<ConfigurationVariable, String>(); parameters.put(ConfigurationVariable.CLIENT_ENCODING, \"UNICODE\"); parameters.put(ConfigurationVariable.DATE_STYLE, \"ISO\"); connection.write(new StartupMessage(connectionManager.getUsername(), connectionManager.getDatabase(), parameters)); } "}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.postgresql.mina; import org.adbcj.postgresql.codec.AbstractConnection; import org.adbcj.postgresql.codec.AbstractConnectionManager; import org.adbcj.postgresql.codec.frontend.AbstractFrontendMessage; import org.apache.mina.core.session.IoSession;  public class MinaConnection extends AbstractConnection { private final MinaConnectionManager.PgConnectFuture connectFuture; private final IoSession session; public MinaConnection(AbstractConnectionManager connectionManager, MinaConnectionManager.PgConnectFuture connectFuture, IoSession session) { super(connectionManager); this.connectFuture = connectFuture; this.session = session; } public MinaConnectionManager.PgConnectFuture getConnectFuture() { return connectFuture; } @Override protected boolean isConnectionClosing() { return session.isClosing(); } @Override protected void write(AbstractFrontendMessage message) { session.write(message); } @Override protected void write(AbstractFrontendMessage[] messages) { session.write(messages); } }"}
{"name": "mheath/adbcj", "content": "package org.adbcj.postgresql.mina; import org.adbcj.postgresql.codec.AbstractConnectionManager; import org.adbcj.postgresql.codec.backend.BackendMessageDecoder; import org.adbcj.postgresql.codec.backend.AbstractBackendMessage; import org.adbcj.postgresql.codec.frontend.FrontendMessageEncoder; import org.adbcj.postgresql.codec.frontend.AbstractFrontendMessage; import org.adbcj.postgresql.mina.IoHandler; import org.adbcj.postgresql.mina.IoSessionUtil; import org.adbcj.support.DefaultDbFuture; import org.adbcj.support.DecoderInputStream; import org.adbcj.Connection; import org.adbcj.DbFuture; import org.adbcj.DbException; import org.apache.mina.core.session.IoSession; import org.apache.mina.core.session.IoSessionInitializer; import org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder; import org.apache.mina.core.future.ConnectFuture; import org.apache.mina.core.buffer.IoBuffer; import org.apache.mina.filter.codec.ProtocolDecoder; import org.apache.mina.filter.codec.ProtocolCodecFactory; import org.apache.mina.filter.codec.ProtocolEncoder; import org.apache.mina.filter.codec.ProtocolCodecFilter; import org.apache.mina.filter.codec.ProtocolEncoderOutput; import org.apache.mina.filter.codec.ProtocolDecoderOutput; import org.apache.mina.filter.codec.CumulativeProtocolDecoder; import org.apache.mina.transport.socket.nio.NioSocketConnector; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.Properties; import java.net.InetSocketAddress; import java.io.OutputStream;  public class MinaConnectionManager extends AbstractConnectionManager { public static final String CODEC_NAME = AbstractConnectionManager.class.getName() + \".codec\"; private final Logger logger = LoggerFactory.getLogger(AbstractConnectionManager.class); private final NioSocketConnector socketConnector; "}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "/* * Copyright (c) 2007 Mike Heath. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mheath/adbcj", "content": "package org.adbcj.postgresql.netty; import org.adbcj.DbFuture; import org.adbcj.DbException; import org.adbcj.support.DecoderInputStream; import org.adbcj.support.DefaultDbFuture; import org.adbcj.postgresql.codec.AbstractConnectionManager; import org.adbcj.postgresql.codec.ConnectionState; import org.adbcj.postgresql.codec.AbstractConnection; import org.adbcj.postgresql.codec.ProtocolHandler; import org.adbcj.postgresql.codec.backend.BackendMessageDecoder; import org.adbcj.postgresql.codec.backend.AbstractBackendMessage; import org.adbcj.postgresql.codec.frontend.FrontendMessageEncoder; import org.adbcj.postgresql.codec.frontend.AbstractFrontendMessage; import org.jboss.netty.channel.ChannelFactory; import org.jboss.netty.channel.Channels; import org.jboss.netty.channel.ChannelPipelineCoverage; import org.jboss.netty.channel.ChannelHandlerContext; import org.jboss.netty.channel.Channel; import org.jboss.netty.channel.ChannelDownstreamHandler; import org.jboss.netty.channel.ChannelEvent; import org.jboss.netty.channel.MessageEvent; import org.jboss.netty.channel.ChannelFuture; import org.jboss.netty.channel.ChannelFutureListener; import org.jboss.netty.channel.ChannelPipeline; import org.jboss.netty.channel.SimpleChannelHandler; import org.jboss.netty.channel.ExceptionEvent; import org.jboss.netty.channel.ChannelStateEvent; import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory; import org.jboss.netty.bootstrap.ClientBootstrap; import org.jboss.netty.handler.codec.frame.FrameDecoder; import org.jboss.netty.buffer.ChannelBuffer; import org.jboss.netty.buffer.ChannelBufferInputStream; import org.jboss.netty.buffer.ChannelBuffers; import org.jboss.netty.buffer.ChannelBufferOutputStream; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.Properties; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.net.InetSocketAddress; import java.io.InputStream;  public class NettyConnectionManager extends AbstractConnectionManager { private static final Logger logger = LoggerFactory.getLogger(NettyConnectionManager.class); private static final String QUEUE_HANDLER = NettyConnectionManager.class.getName() + \".queueHandler\"; private static final String ENCODER = NettyConnectionManager.class.getName() + \".encoder\"; private static final String DECODER = NettyConnectionManager.class.getName() + \".decoder\"; private final ExecutorService executorService; private final ClientBootstrap bootstrap; "}
{"name": "mheath/adbcj", "content": "package org.adbcj.postgresql.netty; import org.adbcj.ConnectionManager; import org.adbcj.DbException; import org.adbcj.ConnectionManagerFactory; import java.util.Properties; import java.net.URI; import java.net.URISyntaxException;  public class NettyConnectionManagerFactory implements ConnectionManagerFactory { public static final String PROTOCOL = \"postgresql-netty\"; public static final int DEFAULT_PORT = 5432; public ConnectionManager createConnectionManager(String url, String username, String password, Properties properties) throws DbException { try {  URI uri = new URI(url); "}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001-2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "package org.apache.batik.svggen.font; import java.io.*; public class RandomAccessFileEmulator extends DataInputStream{ public RandomAccessFileEmulator(byte[] byteArray, String accesMode){ super(new ByteArrayInputStream(byteArray)); } public void seek(long n) throws IOException{ reset(); skip(n); } }"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001,2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 2001 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* Copyright 1999-2003 The Apache Software Foundation Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:"}
{"name": "rikrd/geomerative", "content": "/* * The SEI Software Open Source License, Version 1.0 * * Copyright (c) 2004, Solution Engineering, Inc. * All rights reserved. * * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * 2. The end-user documentation included with the redistribution, * if any, must include the following acknowledgment: * \"This product includes software developed by the * Solution Engineering, Inc. (http:"}
{"name": "rikrd/geomerative", "content": "/* * The SEI Software Open Source License, Version 1.0 * * Copyright (c) 2004, Solution Engineering, Inc. * All rights reserved. * * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * 2. The end-user documentation included with the redistribution, * if any, must include the following acknowledgment: * \"This product includes software developed by the * Solution Engineering, Inc. (http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "rikrd/geomerative", "content": "/** Copyright 2004-2008 Ricard Marxer <email@ricardmarxer.com> This file is part of Geomerative. Geomerative is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Geomerative is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Geomerative. If not, see <http:"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package calculator; import limelight.java.JavaProp; import limelight.ui.events.panel.PanelEvent; import limelight.util.Util; public class Button { public void press(PanelEvent event) { JavaProp prop = (JavaProp)event.getProp(); JavaProp screen = prop.getScene().findProp(\"lcd\"); String text = prop.getText(); if(\"c\".equals(text)) screen.setText(\"\"); else if(\"=\".equals(text)) screen.setText(\"Screw this!\"); else screen.setText(screen.getText() + text); } public void createButtons(PanelEvent event) { JavaProp buttons = (JavaProp)event.getProp(); String labels = \"1 2 3 + 4 5 6 - 7 8 9 * c 0 = /\"; for(String label : labels.split(\" \")) buttons.add(new JavaProp(Util.toMap(\"name\", \"calcButton\", \"text\", label))); } }"}
{"name": "slagyr/limelight", "content": "package calculator; import limelight.events.Event; public class Production { public void printEvent(Event e) { System.out.println(\"e = \" + e); } }"}
{"name": "slagyr/limelight", "content": "package devtool; import limelight.events.Event; import limelight.model.Production; import limelight.model.Stage; import limelight.ui.events.panel.PanelEvent; import limelight.util.Opts; import java.util.List; public class Devtool { public void refresh(Event e) { PanelEvent event = (PanelEvent)e; final Production production = event.getRecipient().getRoot().getProduction(); final List<Stage> stages = production.getTheater().getStages(); for(Stage stage : stages) { production.openScene(stage.getScene().getResourceLoader().getRoot(), stage, new Opts()); } "}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package utilities; import limelight.Context; import limelight.model.Production; import limelight.model.Stage; import limelight.ui.events.panel.PanelEvent; import limelight.ui.model.Scene; import limelight.util.Opts; import java.util.List; public class Rigger { public static class ReloadAllButton { public void pressed(PanelEvent event) { final List<Production> productions = Context.instance().studio.getProductions(); for(Production production : productions) { production.reIlluminate(); production.loadRootStyles(); final List<Stage> stages = production.getTheater().getStages(); for(Stage stage : stages) { final Scene scene = stage.getScene(); if(scene != null) production.openScene(scene.getAbsoluteName(), stage.getName(), new Opts()); } } } } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.builtin.players; import limelight.ui.events.panel.PanelEvent; import limelight.ui.model.PropPanel; import limelight.ui.model.inputs.CheckBoxPanel; public class CheckBox { private PropPanel propPanel; private CheckBoxPanel checkBoxPanel; public void install(PanelEvent event) { checkBoxPanel = new CheckBoxPanel(); propPanel = (PropPanel)event.getRecipient(); propPanel.add(checkBoxPanel); propPanel.getBackstage().put(\"check-box\", this); } public PropPanel getPropPanel() { return propPanel; } public CheckBoxPanel getCheckBoxPanel() { return checkBoxPanel; } public boolean isChecked() { return checkBoxPanel.isSelected(); } public boolean isSelected() { return checkBoxPanel.isSelected(); } public void setChecked(boolean b) { checkBoxPanel.setSelected(b); } public void setSelected(boolean b) { checkBoxPanel.setSelected(b); } }"}
{"name": "slagyr/limelight", "content": "package limelight.builtin.players; import limelight.ui.events.panel.PanelEvent; import limelight.ui.model.PropPanel; import limelight.ui.model.inputs.DropDownPanel; import java.util.Collection; import java.util.List; public class DropDown { private PropPanel propPanel; private DropDownPanel dropDownPanel; public void install(PanelEvent event) { dropDownPanel = new DropDownPanel(); propPanel = (PropPanel)event.getRecipient(); propPanel.add(dropDownPanel); propPanel.getBackstage().put(\"drop-down\", this); } public PropPanel getPropPanel() { return propPanel; } public DropDownPanel getDropDownPanel() { return dropDownPanel; } public void setChoices(Collection<?> choices) { dropDownPanel.setChoices(choices); } public List<?> getChoices() { return dropDownPanel.getChoices(); } public void setValue(Object value) { dropDownPanel.setSelectedChoice(value); } public Object getValue() { return dropDownPanel.getSelectedChoice(); } }"}
{"name": "slagyr/limelight", "content": "package limelight.builtin.players; import limelight.ui.events.panel.CastEvent; import limelight.ui.model.PropPanel; import java.util.HashMap; import java.util.Map; public class Form { private PropPanel propPanel; public void install(CastEvent event) { propPanel = (PropPanel)event.getRecipient(); propPanel.getBackstage().put(\"form\", this); } public Map<String, Object> getData() { return new HashMap<String, Object>(); } }"}
{"name": "slagyr/limelight", "content": "package limelight.builtin.players; import limelight.ui.events.panel.PanelEvent; import limelight.ui.model.ImagePanel; import limelight.ui.model.PropPanel; public class Image { private PropPanel propPanel; private ImagePanel imagePanel; public void install(PanelEvent event) { imagePanel = new ImagePanel(); propPanel = (PropPanel) event.getRecipient(); propPanel.add(imagePanel); propPanel.getBackstage().put(\"image\", this); } public PropPanel getPropPanel() { return propPanel; } public ImagePanel getImagePanel() { return imagePanel; } public void setFilename(String path) { imagePanel.setFilename(path); } public String getFilename() { return imagePanel.getFilename(); } public void setRotation(double angle) { imagePanel.setRotation(angle); } public double getRotation() { return imagePanel.getRotation(); } public boolean isScaled() { return imagePanel.isScaled(); } public void setScaled(boolean value) { imagePanel.setScaled(value); } }"}
{"name": "slagyr/limelight", "content": "package limelight.builtin.players; import limelight.ui.events.panel.PanelEvent; import limelight.ui.model.PropPanel; import limelight.ui.model.inputs.RadioButtonPanel; public class RadioButton { private PropPanel propPanel; private RadioButtonPanel buttonPanel; public void install(PanelEvent event) { buttonPanel = new RadioButtonPanel(); propPanel = (PropPanel)event.getRecipient(); propPanel.add(buttonPanel); propPanel.getBackstage().put(\"radio-button\", this); } public PropPanel getPropPanel() { return propPanel; } public RadioButtonPanel getButtonPanel() { return buttonPanel; } public boolean isSelected() { return buttonPanel.isSelected(); } public void setSelected(boolean b) { buttonPanel.setSelected(b); } public void select() { buttonPanel.setSelected(true); } public String getGroup() { return buttonPanel.getGroup(); } public void setGroup(String group) { buttonPanel.setGroup(group); } }"}
{"name": "slagyr/limelight", "content": "package limelight.builtin.players; import limelight.ui.events.panel.PanelEvent; import limelight.ui.model.PropPanel; import limelight.ui.model.inputs.TextAreaPanel; public class TextArea { public void install(PanelEvent event) { TextAreaPanel input = new TextAreaPanel(); final PropPanel panel = (PropPanel)event.getRecipient(); panel.add(input); } }"}
{"name": "slagyr/limelight", "content": "package limelight.builtin.players; import limelight.ui.events.panel.PanelEvent; import limelight.ui.model.PropPanel; import limelight.ui.model.inputs.TextBoxPanel; public class TextBox { public TextBoxPanel textBoxPanel; public PropPanel propPanel; public void install(PanelEvent event) { textBoxPanel = new TextBoxPanel(); propPanel = (PropPanel)event.getRecipient(); propPanel.add(textBoxPanel); propPanel.getBackstage().put(\"text-box\", this); } public PropPanel getPropPanel() { return propPanel; } public TextBoxPanel getTextBoxPanel() { return textBoxPanel; } public boolean isPassword() { return textBoxPanel.isInPasswordMode(); } public void setPassword(boolean b) { textBoxPanel.setInPasswordMode(b); } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.commands; import limelight.About; import java.util.Map; public class VersionCommand extends Command { private static Arguments arguments = new Arguments(); @Override public void doExecute(Map<String, String> args) { say(\"limelight \" + About.version); } @Override public String description() { return \"Prints current version\"; } @Override public String name() { return \"version\"; } @Override public Arguments getArguments() { return arguments; } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.java; import limelight.LimelightException; import limelight.events.Event; import limelight.events.EventHandler; import limelight.model.api.Player; import limelight.ui.events.panel.CastEvent; import limelight.ui.model.PropPanel; import limelight.util.Options; import limelight.util.StringUtil; import org.w3c.dom.Element; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.Map; public class JavaPlayer implements Player { private Class<?> playerClass; private String path; private Element element; private String eventsPrefix; private String name; public JavaPlayer(String name, String path, Class<?> playerClass, Element element, String eventsPrefix) { this.name = name; this.path = path; this.playerClass = playerClass; this.element = element; this.eventsPrefix = eventsPrefix; } public Object instantiatePlayer() { try { final Constructor constructor = playerClass.getConstructor(); return constructor.newInstance(); } catch(Exception e) { throw new LimelightException(e); } } public Object cast(PropPanel prop) { EventHandler eventHandler = prop.getEventHandler(); Object player = cast(eventHandler); invokeCastEvents(player, prop, element); return player; } public Object cast(EventHandler eventHandler) { Object player = instantiatePlayer(); applyEvents(player, element, eventsPrefix, eventHandler); return player; } public String getPath() { return path; } public String getName() { return name; } public Map<String, Object> applyOptions(PropPanel prop, Map<String, Object> options) { Object hand = prop.getBackstage().get(name); if(hand != null) Options.apply(hand, options); return options; } private void invokeCastEvents(Object player, PropPanel prop, Element playerElement) { final CastEvent castEvent = new CastEvent(prop); for(Element child : Xml.loadChildElements(playerElement)) { if(\"onCast\".equals(child.getNodeName())) { String methodName = child.getTextContent().trim(); final Method method = findMethod(methodName); new JavaEventAction(player, method).invoke(castEvent); } } } public void applyEvents(Object player, Element element, String eventsPrefix, EventHandler eventHandler) { for(Element eventElement : Xml.loadChildElements(element)) { String name = eventElement.getNodeName(); String methodName = eventElement.getTextContent(); addEventActionFor(player, eventsPrefix, name, methodName, eventHandler); } } public void addEventActionFor(Object player, String eventPrefix, String eventName, String methodName, EventHandler eventHandler) { String eventClassName = eventPrefix + StringUtil.capitalCamelCase(eventName.substring(2)) + \"Event\"; if(\"limelight.ui.events.panel.CastEvent\".equals(eventClassName)) return; Class<? extends Event> eventClass; try { eventClass = (Class<? extends Event>) Class.forName(eventClassName); } catch(Exception e) { throw new LimelightException(e); } if(eventClass == null) return; Method eventMethod = findMethod(methodName); final JavaEventAction action = new JavaEventAction(player, eventMethod); eventHandler.add(eventClass, action); } public Method findMethod(String methodName) { for(Method method : playerClass.getMethods()) { if(methodName.equals(method.getName())) return method; } throw new NoSuchMethodError(methodName + \" for \" + playerClass); } public Class<?> getPlayerClass() { return playerClass; } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.model; import limelight.styles.RichStyle; import java.util.Map; public interface StylesSource { String getPath(); Map<String, RichStyle> getStyles(); }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.model.api; import limelight.ui.model.PropPanel; import java.util.Map; public interface Player { Object cast(PropPanel prop); String getPath(); String getName(); Map<String, Object> applyOptions(PropPanel prop, Map<String, Object> options); }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.ui; public class PanelUtil { public static int depthOf(Panel panel) { if(panel == null) return -1; else return depthOf(panel, 0); } private static int depthOf(Panel panel, int depth) { if(panel.getParent() == null) return depth; else return depthOf(panel.getParent(), depth + 1); } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.ui.events.panel; import limelight.ui.Panel; public class IlluminatedEvent extends PanelEvent { public IlluminatedEvent(Panel panel) { setSource(panel); } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.ui.model; import limelight.Log; import limelight.ui.Panel; public class Layouts { public static void on(Panel panel) { layoutPanel(panel); } public static void on(Panel panel, Layout layout) { panel.resetNeededLayout(); panel.markAsNeedingLayout(layout); layoutPanel(panel); } private static void layoutPanel(Panel panel) { if(panel.needsLayout()) { final Layout layout = panel.resetNeededLayout(); layout.doExpansion(panel); layoutChildren(panel); layout.doContraction(panel); layout.doFinalization(panel); } else layoutChildren(panel); } private static void layoutChildren(Panel panel) { if(panel instanceof ParentPanel) { ParentPanel parent = (ParentPanel) panel; for(Panel child : parent.getChildren()) on(child); } } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.ui.model; import limelight.ui.Panel; import java.util.Map; public abstract class SimpleLayout implements Layout { public void doExpansion(Panel panel) { } public void doContraction(Panel panel) { } public void doFinalization(Panel panel) { } public boolean overides(Layout other) { return false; } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.ui.model.text.masking; public class IdentityMask implements TextMask { public static final TextMask instance = new IdentityMask(); public String mask(String text) { return text; } }"}
{"name": "slagyr/limelight", "content": "package limelight.ui.model.text.masking; public class PasswordMask implements TextMask { public static final TextMask instance = new PasswordMask(); public String mask(String text) { StringBuilder builder = new StringBuilder(); for(int i = 0; i < text.length(); i++) builder.append((char)0x2022); return builder.toString(); } }"}
{"name": "slagyr/limelight", "content": "package limelight.ui.model.text.masking; public interface TextMask { public String mask(String text); }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.ui.ninepatch; import limelight.ui.model.Drawable; import limelight.util.Box; import java.awt.*; import java.awt.image.BufferedImage; import java.awt.image.Raster; public class NinePatch implements Drawable { private BufferedImage image = null; private Info info; private NinePatch(BufferedImage image, Info info) { this.image = image; this.info = info; } public static NinePatch load(BufferedImage image) { Info info = Info.inspect(image); return new NinePatch(image, info); } public Image getImage() { return image; } public void draw(Graphics2D graphics, int x, int y, int width, int height) { int midWidth = width - (info.topLeftBounds.width + info.topRightBounds.width); int midHeight = height - (info.topLeftBounds.height + info.bottomLeftBounds.height); int x2 = x + info.topLeftBounds.width; int x3 = x2 + midWidth; int y2 = y + info.topLeftBounds.height; int y3 = y2 + midHeight; "}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.util; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; public class NullLock implements Lock { public static Lock instance = new NullLock(); public void lock() { } public void lockInterruptibly() throws InterruptedException { } public boolean tryLock() { return true; } public boolean tryLock(long l, TimeUnit timeUnit) throws InterruptedException { return true; } public void unlock() { } public Condition newCondition() { return null; } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": "package limelight.util; public class Pair<A, B> { public A a; public B b; public Pair(A a, B b) { this.a = a; this.b = b; } }"}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "slagyr/limelight", "content": ""}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import oauth.signpost.basic.DefaultOAuthConsumer; import oauth.signpost.basic.DefaultOAuthProvider; public interface AuthConstants { public static final String CONSUMER_KEY = \"YOUR_CONSUMER_KEY\"; public static final String CONSUMER_SECRET = \"YOUR_CONSUMER_SECRET\"; public static final String REQUEST_URL = \"http:"}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import java.io.IOException; import java.net.URL; import java.util.concurrent.ConcurrentHashMap; import android.graphics.Bitmap; import android.graphics.BitmapFactory; public class BitmapCache { private static BitmapCache instance = null; private ConcurrentHashMap<URL, Bitmap> cache = new ConcurrentHashMap<URL, Bitmap>(); private BitmapCache() { } public static BitmapCache getInstance() { if (instance == null) { instance = new BitmapCache(); } return instance; } public boolean containsURL(URL url) { return cache.containsKey(url); } public Bitmap get(URL url) { return cache.get(url); } public Bitmap load(URL url) throws IOException { if (containsURL(url)) { return get(url); } Bitmap bitmap = BitmapFactory.decodeStream(url.openStream()); cache.put(url, bitmap); return bitmap; } }"}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import android.content.Context; import android.content.SharedPreferences; import android.content.SharedPreferences.Editor; public class Config { public static final String PREFS_NAME = \"TwitterDroidPrefs\"; private SharedPreferences settings; private Editor editor; public static Config getConfig(Context context) { return new Config(context); } private Config(Context context) { settings = context.getSharedPreferences(PREFS_NAME, 0); editor = settings.edit(); } "}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import oauth.signpost.exception.OAuthCommunicationException; import oauth.signpost.exception.OAuthExpectationFailedException; import oauth.signpost.exception.OAuthMessageSignerException; import oauth.signpost.exception.OAuthNotAuthorizedException; import android.app.Activity; import android.content.Intent; import android.net.Uri; import android.os.Bundle; public class ConfigActivity extends Activity implements AuthConstants { public static final int CONFIG_UPDATE_REQUEST = 0; public static void requestUpdate(Activity parent) { Intent configure = new Intent(parent, ConfigActivity.class); parent.startActivity(configure); } @Override public void onCreate(Bundle icicle) { super.onCreate(icicle); "}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import android.app.Activity; import android.app.AlertDialog; import android.app.ProgressDialog; import android.net.Uri; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.view.View.OnClickListener; import android.widget.EditText; import android.widget.ListView; import android.widget.ImageView; import jtwitter.TwitterResponse; public class StatusActivity extends Activity { private static final int MENU_CONFIGURE_ID = Menu.FIRST; private ProgressDialog activeProgress; private TwitterService twitter = null; "}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import java.util.HashMap; import java.util.Map; import android.content.Context; import android.database.DataSetObserver; import android.graphics.Bitmap; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.LinearLayout; import android.widget.ListAdapter; import android.widget.TextView; import android.widget.ImageView.ScaleType; import android.widget.LinearLayout.LayoutParams; import jtwitter.TwitterEntry; import jtwitter.TwitterResponse; public class StatusAdapter implements ListAdapter { private final TwitterResponse statuses; private final Map<Integer,View> views = new HashMap<Integer,View>(); public StatusAdapter(Context context, TwitterResponse statuses) { this.statuses = statuses; for (int i = 0; i < statuses.getNumberOfItems(); i++) views.put(i, makeUserStatusView(context, statuses.getItemAt(i))); } public boolean areAllItemsEnabled() { return true; } public boolean isEnabled(int position) { return true; } public boolean hasStableIds() { return true; } public int getItemViewType(int position) { return 0; } public int getViewTypeCount() { return 1; } public boolean isEmpty() { return getCount() == 0; } public int getCount() { return statuses.getNumberOfItems(); } public Object getItem(int position) { return statuses.getItemAt(position); } public long getItemId(int position) { return statuses.getItemAt(position).getId(); } public View getView(int position, View convertView, ViewGroup parent) { return views.get(position); } public void registerDataSetObserver(DataSetObserver observer) { } public void unregisterDataSetObserver(DataSetObserver observer) { } "}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import oauth.signpost.OAuth; import oauth.signpost.exception.OAuthCommunicationException; import oauth.signpost.exception.OAuthExpectationFailedException; import oauth.signpost.exception.OAuthMessageSignerException; import oauth.signpost.exception.OAuthNotAuthorizedException; import android.net.Uri; public class TwitterAuth implements AuthConstants { private String accessKey = \"\"; private String accessSecret = \"\"; public TwitterAuth(Uri uri) { String verifier = uri.getQueryParameter(OAuth.OAUTH_VERIFIER); try { provider.retrieveAccessToken(consumer, verifier); accessKey = consumer.getToken(); accessSecret = consumer.getTokenSecret(); } catch (OAuthMessageSignerException e) { e.printStackTrace(); } catch (OAuthNotAuthorizedException e) { e.printStackTrace(); } catch (OAuthExpectationFailedException e) { e.printStackTrace(); } catch (OAuthCommunicationException e) { e.printStackTrace(); } } public String getAccessKey() { return accessKey; } public String getAccessSecret() { return accessSecret; } }"}
{"name": "fbrunel/twitterdroid", "content": "package com.fredbrunel.android.twitter; import android.os.Handler; import android.os.Message; import jtwitter.TwitterConnection; import jtwitter.TwitterConnectionException; import jtwitter.TwitterResponse; public class TwitterService { public static final int RESPONSE_OK = 0; public static final int RESPONSE_KO = 1; public static final int RESPONSE_CONN_KO = 2; public static final int REQUEST_FRIENDS_TIMELINE = 10; public static final int REQUEST_STATUS_UPDATE = 11; private TwitterConnection twitter; public TwitterService(String accessKey, String accessSecret) { this.twitter = new TwitterConnection(accessKey, accessSecret); } public void requestFriendsTimeline(Handler response) { new Thread(new DoGetFriendsTimeline(response)).start(); } public void requestUpdateStatus(String text, Handler response) { new Thread(new DoStatusUpdate(text, response)).start(); } "}
{"name": "fbrunel/twitterdroid", "content": " package jtwitter; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLEncoder; import java.text.ParseException; import javax.xml.parsers.ParserConfigurationException; import oauth.signpost.exception.OAuthCommunicationException; import oauth.signpost.exception.OAuthExpectationFailedException; import oauth.signpost.exception.OAuthMessageSignerException; import org.xml.sax.SAXException; import com.fredbrunel.android.twitter.AuthConstants;  public class TwitterConnection implements AuthConstants { public static final String PUBLIC_TIMELINE_URL = \"http:"}
{"name": "fbrunel/twitterdroid", "content": "package jtwitter; import java.io.IOException; import java.net.HttpURLConnection; public class TwitterConnectionException extends Exception { private HttpURLConnection conn; public TwitterConnectionException(HttpURLConnection conn, Throwable cause) { super(cause); this.conn = conn; } public int getResponseCode() { try { return conn.getResponseCode(); } catch (IOException e) { return -1; } } public String getResponseMessage() { try { return conn.getResponseMessage(); } catch (IOException e) { return null; } } }"}
{"name": "fbrunel/twitterdroid", "content": " package jtwitter; import java.net.MalformedURLException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Locale; public class TwitterEntry { "}
{"name": "fbrunel/twitterdroid", "content": " package jtwitter; import java.io.IOException; import java.io.InputStream; import java.io.StringReader; import java.net.MalformedURLException; import java.text.ParseException; import java.util.HashMap; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import org.w3c.dom.Document; import org.w3c.dom.NodeList; import org.xml.sax.SAXException; import org.xml.sax.InputSource;  public class TwitterResponse { private static final String TOP_LEVEL_NODE_NAME = \"status\"; "}
{"name": "fbrunel/twitterdroid", "content": " package jtwitter; import java.net.URL; import java.net.MalformedURLException;  public class TwitterUser { "}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "mhroth/jvsthost", "content": "/* * Copyright 2007 - 2009 Martin Roth (mhroth@gmail.com) * Matthew Yee-King * * This file is part of JVstHost. * * JVstHost is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JVstHost is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with JVstHost. If not, see <http:"}
{"name": "britt/hivedb", "content": "package org.hivedb; import java.util.Collection; import org.hivedb.meta.Assigner; import org.hivedb.meta.Node; import org.hivedb.util.Lists;  public class BucketAssigner implements Assigner { private int bucketCount = 1024; public BucketAssigner() {} public BucketAssigner(int bucketCount) { this.bucketCount = bucketCount; } public Node chooseNode(Collection<Node> nodes, Object value) { return getNode(nodes, getBucket(value)); } public Collection<Node> chooseNodes(Collection<Node> nodes, Object value) { return Lists.newList(new Node[]{chooseNode(nodes, value)}); } private Node getNode(Collection<Node> nodes, int bucket) { return Lists.newList(nodes).get(bucket % nodes.size()); } private int getBucket(Object value) { return castAsNumber(value).intValue() % getBucketCount(); } private Number castAsNumber(Object value) { if(value.getClass() == Integer.class || value.getClass() == int.class) return (Integer)value; else if(value.getClass() == Long.class || value.getClass() == long.class) return (Long)value; else throw new UnsupportedOperationException(String.format(\"Cannot convert object of type %s, the object must be a number.\", value.getClass())); } public int getBucketCount() { return bucketCount; } public void setBucketCount(int bucketCount) { this.bucketCount = bucketCount; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb; import org.hivedb.meta.AccessType; import org.hivedb.meta.Node; import org.hivedb.meta.directory.DirectoryFacade; import org.hivedb.meta.directory.KeySemaphore; import org.hivedb.meta.persistence.DataSourceProvider; import org.hivedb.meta.persistence.HiveDataSourceProvider; import org.hivedb.util.Preconditions; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Unary; import javax.sql.DataSource; import java.sql.Connection; import java.sql.SQLException; import java.util.ArrayList; import java.util.Collection; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; public class ConnectionManager { private DirectoryFacade directory; private HiveDataSourceProvider dataSourceProvider; private Map<Integer, DataSource> nodeDataSources; private JdbcDaoSupportCacheImpl cache; private Hive hive; public ConnectionManager(DirectoryFacade directory, Hive hive, HiveDataSourceProvider provider) { this.hive = hive; this.directory = directory; this.dataSourceProvider = provider; this.cache = new JdbcDaoSupportCacheImpl(directory, hive, provider); this.nodeDataSources = getDataSourceMap(hive.getNodes(), provider); } public static Map<Integer, DataSource> getDataSourceMap(Collection<Node> nodes, DataSourceProvider dataSourceProvider) { Map<Integer, DataSource> dataSources = new ConcurrentHashMap<Integer, DataSource>(); for (Node node : nodes) dataSources.put(node.getId(), dataSourceProvider.getDataSource(node.getUri())); return dataSources; } private Connection getConnection(KeySemaphore semaphore, AccessType intention) throws HiveLockableException, SQLException { if (intention == AccessType.ReadWrite) Preconditions.isWritable(hive, semaphore, hive.getNode(semaphore.getNodeId())); return nodeDataSources.get(semaphore.getNodeId()).getConnection(); } public Collection<Connection> getByPartitionKey(Object primaryIndexKey, AccessType intent) throws SQLException, HiveLockableException { Collection<Connection> connections = new ArrayList<Connection>(); for (KeySemaphore semaphore : directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey)) connections.add(getConnection(semaphore, intent)); return connections; } public Collection<Connection> getByResourceId(String resourceName, Object resourceId, AccessType intent) throws HiveLockableException, SQLException { Collection<Connection> connections = new ArrayList<Connection>(); for (KeySemaphore semaphore : directory.getKeySemaphoresOfResourceId(resourceName, resourceId)) connections.add(getConnection(semaphore, intent)); return connections; } public Collection<Connection> getBySecondaryIndexKey(String secondaryIndexName, String resourceName, Object secondaryIndexKey, AccessType intent) throws HiveLockableException, SQLException { if (AccessType.ReadWrite == intent) throw new UnsupportedOperationException(\"Writes must be performed using the primary index key.\"); Collection<Connection> connections = new ArrayList<Connection>(); Collection<KeySemaphore> keySemaphores = directory.getKeySemaphoresOfSecondaryIndexKey(resourceName, secondaryIndexName, secondaryIndexKey); keySemaphores = Filter.getUnique(keySemaphores, new Unary<KeySemaphore, Integer>() { public Integer f(KeySemaphore item) { return item.getNodeId(); } }); for (KeySemaphore semaphore : keySemaphores) connections.add(getConnection(semaphore, intent)); return connections; } public JdbcDaoSupportCache daoSupport() { return cache; } public DataSource addNode(Node node) { nodeDataSources.put(node.getId(), dataSourceProvider.getDataSource(node)); cache.addNode(node); return nodeDataSources.get(node.getId()); } public DataSource removeNode(Node node) { cache.removeNode(node); return nodeDataSources.remove(node.getId()); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb; public class DirectoryCorruptionException extends HiveRuntimeException { public DirectoryCorruptionException(String message) { super(message); } public DirectoryCorruptionException(String message, Exception inner) { super(message, inner); }  private static final long serialVersionUID = 1L; }"}
{"name": "britt/hivedb", "content": " package org.hivedb; import org.hivedb.meta.*; import org.hivedb.meta.directory.*; import org.hivedb.meta.persistence.*; import org.hivedb.util.HiveUtils; import org.hivedb.util.Preconditions; import org.hivedb.util.database.DriverLoader; import org.hivedb.util.database.HiveDbDialect; import org.hivedb.util.database.Schemas; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Predicate; import javax.sql.DataSource; import java.util.*;  public class Hive extends Observable implements Synchronizeable, Observer, Lockable, Nameable { "}
{"name": "britt/hivedb", "content": " package org.hivedb; @SuppressWarnings(\"serial\") public class HiveException extends Exception { public static final String CONNECTION_VALIDATION_ERROR = \"Connection validator error\"; public HiveException(String message) { super(message); } public HiveException(String message, Exception inner) { super(message,inner); } } "}
{"name": "britt/hivedb", "content": "package org.hivedb; public class HiveKeyNotFoundException extends HiveRuntimeException {  private static final long serialVersionUID = 4084768603355365229L; private Object key; public Object getKey() { return key; } public HiveKeyNotFoundException(String message) { super(message); } public HiveKeyNotFoundException(String message, Object key) { super(message); this.key = key; } public HiveKeyNotFoundException(String message, Object key, Exception inner) { super(message, inner); this.key = key; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb; @SuppressWarnings(\"serial\") public class HiveLockableException extends HiveException { public HiveLockableException(String message) { super(message); } public HiveLockableException(String message, Exception inner) { super(message,inner); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb;  @SuppressWarnings(\"serial\") public class HiveRuntimeException extends RuntimeException { public HiveRuntimeException(Exception inner) { super(inner); } public HiveRuntimeException(String message) { super(message); } public HiveRuntimeException(String message, Exception inner) { super(message,inner); } }"}
{"name": "britt/hivedb", "content": " package org.hivedb; import java.util.Collection; import java.util.Observable; import java.util.Observer; import javax.sql.DataSource; import org.hivedb.meta.persistence.HiveBasicDataSource; import org.hivedb.meta.persistence.HiveSemaphoreDao;  public class HiveSyncDaemon extends Thread { private Observable hiveStatus; private long lastRun = 0; private String hiveUri; private int lastRevision = Integer.MIN_VALUE; private int sleepPeriodMs = 5000; @SuppressWarnings(\"unchecked\") public static HiveSyncDaemon startDaemon(String uri, int sleepPeriodMs, Collection observers) { HiveSyncDaemon daemon = new HiveSyncDaemon(uri, sleepPeriodMs, observers); daemon.start(); return daemon; } public HiveSyncDaemon(String uri, int sleepPeriodMs, Collection<Observer> observers) { this(uri, observers); this.sleepPeriodMs = sleepPeriodMs; } public HiveSyncDaemon(String uri, Collection<Observer> observers) { hiveUri = uri; hiveStatus = new HiveUpdateStatus(); for(Observer o : observers) hiveStatus.addObserver(o); } private DataSource cachedDataSource = null; private DataSource getDataSource() { if (cachedDataSource == null) { cachedDataSource = new HiveBasicDataSource(hiveUri); } return cachedDataSource; } private int getLatestRevision() { return new HiveSemaphoreDao(getDataSource()).get().getRevision(); } public synchronized void detectChanges() { int latestRevision = getLatestRevision(); if (lastRevision != latestRevision) hiveStatus.notifyObservers(); lastRevision = latestRevision; } public void run() { while (true) { try { detectChanges(); lastRun = System.currentTimeMillis(); } catch (Exception e) {} try { sleep(getConfiguredSleepPeriodMs()); } catch (InterruptedException e) {} } }  public boolean isRunning() { return ((System.currentTimeMillis() - lastRun) < 2 * getConfiguredSleepPeriodMs()); } public int getConfiguredSleepPeriodMs() { return sleepPeriodMs; } public void setSleepPeriodMs(int ms) { this.sleepPeriodMs = ms; } class HiveUpdateStatus extends Observable { public void notifyObservers() { super.setChanged(); super.notifyObservers(); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb; import org.hivedb.meta.AccessType; import org.springframework.jdbc.core.simple.SimpleJdbcDaoSupport; import java.util.Collection; public interface JdbcDaoSupportCache { public Collection<SimpleJdbcDaoSupport> get(Object primaryIndexKey, AccessType intention) throws HiveLockableException; public Collection<SimpleJdbcDaoSupport> get(String resource, String secondaryIndex, Object secondaryIndexKey, AccessType intention) throws HiveLockableException; public Collection<SimpleJdbcDaoSupport> get(String resource, Object resourceId, AccessType intention) throws HiveLockableException; public SimpleJdbcDaoSupport getUnsafe(String nodeName); public Collection<SimpleJdbcDaoSupport> getAllUnsafe(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb; import org.hivedb.meta.AccessType; import org.hivedb.meta.Node; import org.hivedb.meta.directory.DirectoryFacade; import org.hivedb.meta.directory.KeySemaphore; import org.hivedb.meta.directory.KeySemaphoreImpl; import org.hivedb.meta.persistence.DataSourceProvider; import org.hivedb.util.Preconditions; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Unary; import org.springframework.jdbc.core.simple.SimpleJdbcDaoSupport; import javax.sql.DataSource; import java.util.ArrayList; import java.util.Collection; import java.util.Map; import java.util.concurrent.ConcurrentHashMap;  public class JdbcDaoSupportCacheImpl implements JdbcDaoSupportCache { private Map<Integer, SimpleJdbcDaoSupport> jdbcDaoSupports; private DirectoryFacade directory; private DataSourceProvider dataSourceProvider; private Hive hive; public JdbcDaoSupportCacheImpl(DirectoryFacade directory, Hive hive, DataSourceProvider dataSourceProvider) { this.hive = hive; this.directory = directory; this.dataSourceProvider = dataSourceProvider; this.jdbcDaoSupports = getDataSourceMap(hive.getNodes(), dataSourceProvider); } public static Map<Integer, SimpleJdbcDaoSupport> getDataSourceMap(Collection<Node> nodes, DataSourceProvider dataSourceProvider) { Map<Integer, SimpleJdbcDaoSupport> jdbcDaoSupports = new ConcurrentHashMap<Integer, SimpleJdbcDaoSupport>(); for (Node node : nodes) jdbcDaoSupports.put(node.getId(), makeDaoSupport(node, dataSourceProvider)); return jdbcDaoSupports; } public static SimpleJdbcDaoSupport makeDaoSupport(Node node, DataSourceProvider provider) { return new DataNodeJdbcDaoSupport(provider.getDataSource(node.getUri())); } public SimpleJdbcDaoSupport addNode(Node node) { jdbcDaoSupports.put(node.getId(), makeDaoSupport(node, dataSourceProvider)); return jdbcDaoSupports.get(node.getId()); } public SimpleJdbcDaoSupport removeNode(Node node) { return jdbcDaoSupports.remove(node.getId()); } private SimpleJdbcDaoSupport get(KeySemaphore semaphore, AccessType intention) throws HiveLockableException { Node node = null; node = hive.getNode(semaphore.getNodeId()); if (intention == AccessType.ReadWrite) Preconditions.isWritable(node, semaphore); if (jdbcDaoSupports.containsKey(semaphore.getNodeId())) return jdbcDaoSupports.get(semaphore.getNodeId()); throw new HiveKeyNotFoundException(\"Could not find dataSource for \", semaphore); }  public Collection<SimpleJdbcDaoSupport> get(Object primaryIndexKey, final AccessType intention) throws HiveLockableException { Collection<KeySemaphore> semaphores = directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey); Collection<SimpleJdbcDaoSupport> supports = new ArrayList<SimpleJdbcDaoSupport>(); for (KeySemaphore semaphore : semaphores) supports.add(get(semaphore, intention)); return supports; }  public Collection<SimpleJdbcDaoSupport> get(String resource, String secondaryIndex, Object secondaryIndexKey, final AccessType intention) throws HiveLockableException { Collection<KeySemaphore> keySemaphores = directory.getKeySemaphoresOfSecondaryIndexKey(resource, secondaryIndex, secondaryIndexKey); keySemaphores = Filter.getUnique(keySemaphores, new Unary<KeySemaphore, Integer>() { public Integer f(KeySemaphore item) { return item.getNodeId(); } }); Collection<SimpleJdbcDaoSupport> supports = new ArrayList<SimpleJdbcDaoSupport>(); for (KeySemaphore semaphore : keySemaphores) supports.add(get(semaphore, intention)); return supports; } private static class DataNodeJdbcDaoSupport extends SimpleJdbcDaoSupport { public DataNodeJdbcDaoSupport(DataSource dataSource) { this.setDataSource(dataSource); } } public SimpleJdbcDaoSupport getUnsafe(String nodeName) { try { Node node = hive.getNode(nodeName); KeySemaphore semaphore = new KeySemaphoreImpl(null, node.getId(), node.getStatus()); return get(semaphore, AccessType.ReadWrite); } catch (HiveException e) { "}
{"name": "britt/hivedb", "content": "package org.hivedb; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Predicate; import java.util.Arrays; public interface Lockable { public enum Status { writable(0), readOnly(1), unavailable(2); private final int value; "}
{"name": "britt/hivedb", "content": "package org.hivedb; import org.hivedb.meta.Assigner; import org.hivedb.meta.Node; import java.util.*; public class RandomAssigner implements Assigner { private Random random = new Random(new Date().getTime()); public Node chooseNode(Collection<Node> nodes, Object value) { if (nodes.size() == 0) throw new HiveRuntimeException(\"The Hive has no Nodes; the Assigner cannot make a choice.\"); else return new ArrayList<Node>(nodes).get(random.nextInt(nodes.size())); } public Collection<Node> chooseNodes(Collection<Node> nodes, Object value) { return Arrays.asList(new Node[]{chooseNode(nodes, value)}); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Collection; import org.hivedb.meta.persistence.TableInfo; import org.springframework.jdbc.core.RowMapper;  public abstract class Schema { private String name;  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public Schema(String name) { this.name = name; }  public abstract Collection<TableInfo> getTables(String uri); @Override public boolean equals(Object obj) { if (obj instanceof Schema) { return name.equals(((Schema) obj).getName()); } return false; } public static class TrueRowMapper implements RowMapper { public Object mapRow(ResultSet rs, int rowNumber) throws SQLException { return true; } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb; public interface Synchronizeable { public boolean sync(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb;  public class UnsupportedDialectException extends RuntimeException { private static final long serialVersionUID = 1L; public UnsupportedDialectException(String msg) { super(msg); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.Map; import org.hivedb.util.Lists; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Maps; import org.hivedb.util.functional.Predicate; public class AnnotationHelper { @SuppressWarnings(\"unchecked\") public static<T extends Annotation> T getFirstInstanceOfAnnotation(Class entityClass, Class<T> annotationClass) { Method m = getFirstMethodWithAnnotation(entityClass, annotationClass); return m == null ? null : m.getAnnotation(annotationClass); } @SuppressWarnings(\"unchecked\") public static<T extends Annotation> Method getFirstMethodWithAnnotation(Class entityClass, Class<T> annotationClass) { return Atom.getFirstOrNull(getAllMethodsWithAnnotation(entityClass, annotationClass)); } @SuppressWarnings(\"unchecked\") public static List<Method> getAllMethodsWithAnnotation(Class entityClass, Class annotationClass) { return getAllMethodsWithAnnotations(entityClass, Collections.singleton(annotationClass)); } @SuppressWarnings(\"unchecked\") public static List<Method> getAllMethodsWithAnnotations(Class entityClass, Collection<Class> annotationClasses) { List<Method> methods = Lists.newArrayList(); for(Method method : entityClass.getMethods()) { Method targetMethod = method; if( !method.getDeclaringClass().equals(entityClass)) { try { method.getDeclaringClass().getMethod(method.getName(), method.getParameterTypes()); } catch (SecurityException e) { throw new RuntimeException(e); } catch (NoSuchMethodException e) { throw new RuntimeException(e); } } for (Class annotationClass : annotationClasses ) if(targetMethod.getAnnotation(annotationClass) != null) { methods.add(method); break; } } return methods; } @SuppressWarnings(\"unchecked\") public static Map<Annotation, Object> getAllAnnotatedElements(Class clazz) { Map<Annotation, Object> elements = Maps.newHashMap(); for(Annotation a : clazz.getAnnotations()) elements.put(a, clazz); elements.putAll(getAllAnnotatedConstructors(clazz)); elements.putAll(getAllAnnotatedMethods(clazz)); elements.putAll(getAllAnnotatedFields(clazz)); return elements; } @SuppressWarnings(\"unchecked\") public static Map<? extends Annotation, ? extends Object> getAllAnnotatedMethods(Class clazz) { Map<Annotation, Object> elements = Maps.newHashMap(); for(Method m : clazz.getMethods()) for(Annotation a : m.getAnnotations()) elements.put(a, m); return elements; } @SuppressWarnings(\"unchecked\") public static Map<Annotation, Object> getAllAnnotatedConstructors(Class clazz) { Map<Annotation, Object> elements = Maps.newHashMap(); for(Constructor c : clazz.getConstructors()) for(Annotation a : c.getAnnotations()) elements.put(a, c); return elements; } @SuppressWarnings(\"unchecked\") public static Map<? extends Annotation, ? extends Object> getAllAnnotatedFields(Class clazz) { Map<Annotation, Object> elements = Maps.newHashMap(); for(Field f : clazz.getDeclaredFields()) for(Annotation a : f.getAnnotations()) elements.put(a, f); return elements; } @SuppressWarnings(\"unchecked\") public static<T> T getAnnotationDeeply(Class clazz, String property, Class<? extends T> annotationClass) { return getAnnotationDeeply(ReflectionTools.getGetterOfProperty(clazz, property), annotationClass); } @SuppressWarnings(\"unchecked\") public static<T> T getAnnotationDeeply(Method method, Class<? extends T> annotationClass) { if (method.getAnnotation((Class)annotationClass) != null) return (T)method.getAnnotation((Class)annotationClass); final Method ownerMethod = ReflectionTools.getMethodOfOwner(method); Class<T> owner = (Class<T>) ownerMethod.getDeclaringClass(); if (!owner.equals(method.getDeclaringClass())) return (T)ownerMethod.getAnnotation((Class)annotationClass); return null; } @SuppressWarnings(\"unchecked\") public static<T> T getMethodArgumentAnnotationDeeply(Method method, int argumentIndex, final Class<? extends T> annotationClass) { return (T)Filter.grepSingleOrNull( new Predicate<Annotation>() { public boolean f(Annotation annoation) { return ReflectionTools.doesImplementOrExtend(annoation.getClass(), annotationClass); } }, Arrays.asList(method.getParameterAnnotations()[argumentIndex])); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface DataIndexDelegate { String value(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface EntityId {}"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface EntityVersion {}"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface GeneratedClass { String value() default \"\"; }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface GeneratorIgnore {}"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Index { IndexType type() default IndexType.Hive; String name() default \"\"; }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface IndexDelegate { String value(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.PARAMETER) public @interface IndexParam { String value(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface IndexParamPagingPair {  int startIndexIndex();  int maxResultsIndex(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface IndexParamPairs {  int[] value(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; public enum IndexType { Hive, Delegates, Data, Partition, None }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface PartitionIndex { String value() default \"\"; }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Resource { String value(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Validate {  String value(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; import org.hivedb.annotations.IndexType; import java.io.Serializable; import java.util.Collection; import java.util.EnumSet; public interface EntityConfig { String getPrimaryIndexKeyPropertyName(); String getPartitionDimensionName(); Object getPrimaryIndexKey(Object instance); String getIdPropertyName(); Serializable getId(Object instance); Collection<EntityIndexConfig> getEntityIndexConfigs(); EntityIndexConfig getEntityIndexConfig(String propertyName); EntityIndexConfig getPrimaryIndexKeyEntityIndexConfig(); Collection<EntityIndexConfig> getEntityIndexConfigs(EnumSet<IndexType> indexTypes); Collection<EntityIndexConfig> getEntityIndexConfigs(IndexType indexType); String getResourceName(); boolean isPartitioningResource(); Class<?> getRepresentedInterface(); Class<?> getPrimaryKeyClass(); Class<?> getIdClass(); "}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; import org.hivedb.annotations.AnnotationHelper; import org.hivedb.annotations.Index; import org.hivedb.annotations.IndexType; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Filter.BinaryPredicate; import org.hivedb.util.functional.Predicate; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.io.Serializable; import java.lang.reflect.Method; import java.util.Collection; import java.util.EnumSet; public class EntityConfigImpl implements EntityConfig { private Class<?> representedInterface; private String partitionDimensionName, resourceName, primaryIndexKeyPropertyName, idPropertyName, versionPropertyName; private Collection<EntityIndexConfig> entityIndexConfigs; private boolean isPartitioningResource; private Collection<Class<?>> associatedClasses; public static EntityConfig createEntity( Class<?> representedInterface, String partitionDimensionName, String resourceName, String primaryIndexPropertyName, String idPropertyName, String versionPropertyName, Collection<EntityIndexConfig> indexConfigs) { return new EntityConfigImpl( representedInterface, partitionDimensionName, resourceName, primaryIndexPropertyName, idPropertyName, versionPropertyName, indexConfigs, false); }  public static EntityConfig createPartitioningResourceEntity( Class<?> representedInterface, String partitionDimensionName, String idPropertyName, String versionPropertyName, Collection<EntityIndexConfig> secondaryIndexIdentifiables) { return new EntityConfigImpl( representedInterface, partitionDimensionName, partitionDimensionName, idPropertyName, idPropertyName, versionPropertyName, secondaryIndexIdentifiables, true); } public EntityConfigImpl( Class<?> representedInterface, String partitionDimensionName, String resourceName, String primaryIndexKeyPropertyName, String idPropertyName, String versionPropertyName, Collection<EntityIndexConfig> entityIndexConfigs, boolean isPartitioningResource) { this.representedInterface = representedInterface; this.partitionDimensionName = partitionDimensionName; this.resourceName = resourceName; this.primaryIndexKeyPropertyName = primaryIndexKeyPropertyName; this.idPropertyName = idPropertyName; this.entityIndexConfigs = entityIndexConfigs; this.isPartitioningResource = isPartitioningResource; this.versionPropertyName = versionPropertyName; this.associatedClasses = findAssociatedClasses(representedInterface); } private Collection<Class<?>> findAssociatedClasses(final Class<?> representedInterface) { "}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; import java.util.Collection; public interface EntityHiveConfig extends HiveConfig { public Collection<EntityConfig> getEntityConfigs(); public EntityConfig getEntityConfig(Class<?> clazz); public EntityConfig getEntityConfig(String clazz); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; import org.hivedb.annotations.IndexType; import org.hivedb.util.validators.Validator; import java.util.Collection; public interface EntityIndexConfig { Collection<Object> getIndexValues(Object entityInstance); String getIndexName(); String getInnerClassPropertyName(); "}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; public interface EntityIndexConfigDelegator { EntityConfig getDelegateEntityConfig(); Object stubEntityInstance(Object entityId, Object primaryIndexKey); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; import org.hivedb.HiveRuntimeException; import org.hivedb.annotations.Index; import org.hivedb.annotations.IndexType; import org.hivedb.annotations.PartitionIndex; import org.hivedb.annotations.Validate; import org.hivedb.util.InstanceCollectionValueGetter; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.database.SqlUtils; import org.hivedb.util.functional.Actor; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import org.hivedb.util.validators.NonNullValidator; import org.hivedb.util.validators.Validator; import java.util.Collection; public class EntityIndexConfigImpl implements EntityIndexConfig {  @SuppressWarnings(\"unchecked\") public EntityIndexConfigImpl( final Class entityInterface, final String propertyName) { this.propertyName = propertyName; this.indexName = propertyName; this.indexType = resolveIndexType(entityInterface, propertyName); this.secondaryIndexCollectionGetter = new InstanceCollectionValueGetter() { public Collection<Object> get(Object instance) { if (!getValidator().isValid(instance, propertyName)) getValidator().throwInvalid(instance, propertyName); return Actor.forceCollection(ReflectionTools.invokeGetter(instance, propertyName)); }}; this.indexClass = ReflectionTools.getPropertyTypeOrPropertyCollectionItemType(entityInterface, propertyName); this.validator = resolveValidator(entityInterface, propertyName); }  public EntityIndexConfigImpl( final Class<?> entityInterface, final String propertyName, final String innerClassPropertyName) { this.propertyName = propertyName; this.innerClassPropertyName = innerClassPropertyName; this.indexName = SqlUtils.singularize(propertyName) + ReflectionTools.capitalize(innerClassPropertyName); this.indexType = ReflectionTools.getGetterOfProperty(entityInterface, propertyName).getAnnotation(Index.class).type(); this.secondaryIndexCollectionGetter = new InstanceCollectionValueGetter() { @SuppressWarnings(\"unchecked\") public Collection<Object> get(Object instance) { if (!getValidator().isValid(instance, propertyName)) getValidator().throwInvalid(instance, propertyName); return Transform.map(new Unary<Object, Object>() { public Object f(Object collectionItem) { return ReflectionTools.invokeGetter(collectionItem, innerClassPropertyName); }}, (Collection<Object>)ReflectionTools.invokeGetter(instance, propertyName)); }}; this.indexClass = ReflectionTools.getPropertyType( ReflectionTools.getCollectionItemType(entityInterface, propertyName), innerClassPropertyName); this.validator = resolveValidator(entityInterface, propertyName); } @SuppressWarnings(\"unchecked\") private IndexType resolveIndexType(final Class entityInterface, final String propertyName) { Index annotation = ReflectionTools.getGetterOfProperty(entityInterface, propertyName).getAnnotation(Index.class); if (annotation != null) return annotation.type(); if (ReflectionTools.getGetterOfProperty(entityInterface, propertyName).getAnnotation(PartitionIndex.class) != null) return IndexType.Partition; return IndexType.None; } @SuppressWarnings(\"unchecked\") private Validator resolveValidator(final Class entityInterface, final String propertyName) { Validate annotation = (Validate) ReflectionTools.getGetterOfProperty(entityInterface, propertyName).getAnnotation(Validate.class); if (annotation != null) try { return (Validator) Class.forName(annotation.value()).newInstance(); } catch (Exception e) { throw new HiveRuntimeException(e); } return nonNullValidator; } private static Validator nonNullValidator = new NonNullValidator(); private String indexName; public String getIndexName() { return indexName; } private String propertyName; public String getPropertyName() { return propertyName; } private String innerClassPropertyName; public String getInnerClassPropertyName() { if (innerClassPropertyName == null) throw new RuntimeException(String.format(\"EntityIndexConfig's property %s is not a collection property, but is being treated like one\", propertyName)); return innerClassPropertyName; } private InstanceCollectionValueGetter secondaryIndexCollectionGetter; public Collection<Object> getIndexValues(Object instance) { return secondaryIndexCollectionGetter.get(instance); } private Class<?> indexClass; public Class<?> getIndexClass() { return indexClass; } private IndexType indexType; public IndexType getIndexType() { return indexType; } private Validator validator; public Validator getValidator() { return validator; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; import org.hivedb.annotations.IndexType; import org.hivedb.util.classgen.GeneratedClassFactory; import org.hivedb.util.classgen.GeneratedInstanceInterceptor; public class EntityIndexConfigProxy extends EntityIndexConfigImpl implements EntityIndexConfigDelegator { private EntityConfig delegateEntityConfig;  @SuppressWarnings(\"unchecked\") public EntityIndexConfigProxy( final Class entityInterface, final String propertyName, final EntityConfig delegateEntityConfig) { super(entityInterface, propertyName); this.delegateEntityConfig = delegateEntityConfig; }  public EntityIndexConfigProxy( final Class<?> entityInterface, final String propertyName, final String innerClassPropertyName, final EntityConfig delegateEntityConfig) { super(entityInterface, propertyName, innerClassPropertyName); this.delegateEntityConfig = delegateEntityConfig; } public IndexType getIndexType() { return IndexType.Delegates; } public EntityConfig getDelegateEntityConfig() { return delegateEntityConfig; } public Object stubEntityInstance(Object entityId, Object primaryIndexKey) { Object instance = GeneratedClassFactory.newInstance(this.getDelegateEntityConfig().getRepresentedInterface()); GeneratedInstanceInterceptor.setProperty(instance, this.getDelegateEntityConfig().getIdPropertyName(), entityId); GeneratedInstanceInterceptor.setProperty(instance, this.getDelegateEntityConfig().getPrimaryIndexKeyPropertyName(), primaryIndexKey); return instance; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; public interface HiveConfig { String getPartitionDimensionName(); Class<?> getPartitionDimensionType(); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.configuration; import org.apache.commons.dbcp.BasicDataSource; import org.hivedb.Schema; import org.hivedb.meta.persistence.TableInfo; import org.hivedb.util.Templater; import org.hivedb.util.database.Schemas; import java.util.ArrayList; import java.util.Collection;  public class HiveConfigurationSchema extends Schema { private String dbURI;  public HiveConfigurationSchema(String dbURI) { this(); this.dbURI = dbURI; } public HiveConfigurationSchema() { super(\"Hive configuration schema\"); } private String getCreateNode() { return Templater.render(\"sql/node_configuration.vsql\", Schemas.getContext(dbURI)); } private String getCreateHive() { return Templater.render(\"sql/hive_semaphore.vsql\", Schemas.getContext(dbURI)); } private String getCreatePartitionDimension() { return Templater.render(\"sql/partition_dimension_configuration.vsql\", Schemas.getContext(dbURI)); } private String getCreateSecondaryIndex() { return Templater.render(\"sql/secondary_index_configuration.vsql\", Schemas.getContext(dbURI)); } private String getCreateResource() { return Templater.render(\"sql/resource_configuration.vsql\", Schemas.getContext(dbURI)); } public void install() { Schemas.install(this, dbURI); BasicDataSource ds = new BasicDataSource(); ds.setUrl(dbURI); } public String[] getCreateStatements() { return new String[]{ getCreateHive(), getCreateNode(), getCreatePartitionDimension(), getCreateSecondaryIndex(), getCreateResource()}; } @Override public Collection<TableInfo> getTables(String uri) { Collection<TableInfo> TableInfos = new ArrayList<TableInfo>(); TableInfos.add(new TableInfo(\"semaphore_metadata\", getCreateHive())); TableInfos.add(new TableInfo(\"node_metadata\", getCreateNode())); TableInfos.add(new TableInfo(\"partition_dimension_metadata\", getCreatePartitionDimension())); TableInfos.add(new TableInfo(\"secondary_index_metadata\", getCreateSecondaryIndex())); TableInfos.add(new TableInfo(\"resource_metadata\", getCreateResource())); return TableInfos; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.configuration; import org.hivedb.HiveRuntimeException; import org.hivedb.util.Lists; import org.hivedb.util.functional.DebugMap; import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.Map; public class PluralHiveConfig implements EntityHiveConfig { private Map<String,EntityConfig> indexConfigurations = new DebugMap<String, EntityConfig>(); private String dimensionName; private Class<?> dimensionClass; public PluralHiveConfig(Map<String, EntityConfig> map, String dimensionName, Class<?> dimensionClass) { this.indexConfigurations = map; this.dimensionClass = dimensionClass; this.dimensionName = dimensionName; } @SuppressWarnings(\"unchecked\") public EntityConfig getEntityConfig(Class<?> clazz) { EntityConfig config = indexConfigurations.get(clazz.getName()); if(config == null){ List<Class> ancestors = getAncestors(clazz); for(Class ancestor : ancestors) { if(indexConfigurations.containsKey(ancestor.getName())){ config = indexConfigurations.get(ancestor.getName()); break; } } } return config; } @SuppressWarnings(\"unchecked\") public EntityConfig getEntityConfig(String className) { Class clazz = null; try { clazz = Class.forName(className); } catch (ClassNotFoundException e) { throw new HiveRuntimeException(e.getMessage(),e); } return getEntityConfig(clazz); } @SuppressWarnings(\"unchecked\") private List<Class> getAncestors(Class<?> clazz) { List<Class> ancestors = Lists.newArrayList(); if (!clazz.isInterface()) ancestors.add(clazz.getSuperclass()); ancestors.addAll(Arrays.asList(clazz.getInterfaces())); return ancestors; } public void add(String className, EntityConfig config) { this.indexConfigurations.put(className, config); } public Collection<EntityConfig> getEntityConfigs() { return indexConfigurations.values(); } public String getPartitionDimensionName() { return this.dimensionName; } public Class<?> getPartitionDimensionType() { return this.dimensionClass; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.*; import org.hibernate.criterion.Order; import org.hibernate.criterion.Projections; import org.hibernate.criterion.Restrictions; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.HiveRuntimeException; import org.hivedb.annotations.AnnotationHelper; import org.hivedb.annotations.DataIndexDelegate; import org.hivedb.annotations.IndexType; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityIndexConfig; import org.hivedb.configuration.EntityIndexConfigDelegator; import org.hivedb.configuration.EntityIndexConfigImpl; import org.hivedb.util.Lists; import org.hivedb.util.classgen.GenerateInstance; import org.hivedb.util.classgen.GeneratedClassFactory; import org.hivedb.util.classgen.GeneratedInstanceInterceptor; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.*; import org.hivedb.util.functional.Filter; import java.io.Serializable; import java.lang.reflect.Method; import java.util.*; import java.util.Map.Entry; public class BaseDataAccessObject implements DataAccessObject<Object, Serializable> { private final Log log = LogFactory.getLog(BaseDataAccessObject.class); private static int CHUNK_SIZE = 10; private final HiveSessionFactory factory; private final EntityConfig config; private final Class<?> clazz; private Hive hive; private EntityIndexConfig partitionIndexEntityIndexConfig; public Hive getHive() { return hive; } public void setHive(Hive hive) { this.hive = hive; } public BaseDataAccessObject(EntityConfig config, Hive hive, HiveSessionFactory factory) { this.clazz = config.getRepresentedInterface(); this.config = config; this.factory = factory; this.hive = hive; } public Boolean exists(Serializable id) { return hive.directory().doesResourceIdExist(config.getResourceName(), id); } public Object get(final Serializable id) { try { QueryCallback query = new QueryCallback() { public Collection<Object> execute(Session session) { Object fetched = get(id, session); if (fetched == null && exists(id)) { try { hive.directory().deleteResourceId(config.getResourceName(), id); } catch (HiveLockableException e) { log.warn(String.format(\"%s with id %s exists in the directory but not on the data node. Unable to cleanup record because Hive was read-only.\", config.getResourceName(), id)); } log.warn(String.format(\"%s with id %s exists in the directory but not on the data node. Directory record removed.\", config.getResourceName(), id)); } return Collections.singletonList(fetched); } }; Object fetched = Atom.getFirstOrThrow(queryInTransaction(query, getSession())); if (fetched == null && exists(id)) { try { hive.directory().deleteResourceId(config.getResourceName(), id); } catch (HiveLockableException e) { log.warn(String.format(\"%s with id %s exists in the directory but not on the data node. Unable to cleanup record because Hive was read-only.\", config.getResourceName(), id)); } log.warn(String.format(\"%s with id %s exists in the directory but not on the data node. Directory record removed.\", config.getResourceName(), id)); } return fetched; } catch (NoSuchElementException e) { "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.shards.strategy.access.SequentialShardAccessStrategy; import org.hivedb.Hive; import org.hivedb.configuration.EntityHiveConfig; import java.io.Serializable; import java.util.Collection; public class BaseDataAccessObjectFactory<T, ID extends Serializable> implements DataAccessObjectFactory<T, ID> { Hive hive; EntityHiveConfig entityHiveConfig; Collection<Class<?>> mappedClasses; Class<T> representedClass; public BaseDataAccessObjectFactory(EntityHiveConfig entityHiveConfig, Collection<Class<?>> mappedClasses, Class<T> representedClass, Hive hive) { this.entityHiveConfig = entityHiveConfig; this.mappedClasses = mappedClasses; this.representedClass = representedClass; this.hive = hive; } @SuppressWarnings(\"unchecked\") public DataAccessObject<T, ID> create() { return (DataAccessObject<T, ID>) new BaseDataAccessObject( entityHiveConfig.getEntityConfig(representedClass), hive, new HiveSessionFactoryBuilderImpl( entityHiveConfig, mappedClasses, hive, new SequentialShardAccessStrategy())); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.HiveRuntimeException; import org.hivedb.annotations.*; import org.hivedb.configuration.*; import org.hivedb.management.HiveConfigurationSchemaInstaller; import org.hivedb.meta.PartitionDimension; import org.hivedb.meta.SecondaryIndex; import org.hivedb.meta.persistence.CachingDataSourceProvider; import org.hivedb.util.Lists; import org.hivedb.util.PrimitiveUtils; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.database.JdbcTypeMapper; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Predicate; import org.springframework.beans.BeanUtils; import java.lang.reflect.Method; import java.util.*; public class ConfigurationReader { private Map<String, EntityConfig> hiveConfigs = new HashMap<String, EntityConfig>(); private PartitionDimension dimension = null; public ConfigurationReader(PartitionDimension partitionDimension) { dimension = partitionDimension; } public ConfigurationReader(Class<?>... classes) { for (Class<?> clazz : classes) if (isHiveEntity(clazz)) configure(clazz); } public ConfigurationReader(Collection<Class<?>> classes) { for (Class<?> clazz : classes) if (isHiveEntity(clazz)) configure(clazz); } private boolean isHiveEntity(Class<?> clazz) { return clazz.isAnnotationPresent(Resource.class); } public EntityConfig configure(Class<?> clazz) { EntityConfig config = readConfiguration(clazz); if (dimension == null) dimension = extractPartitionDimension(clazz); else if (!dimension.getName().equals(config.getPartitionDimensionName())) throw new UnsupportedOperationException( String.format(\"You are trying to configure on object from partition dimension %s into a Hive configured to use partition dimension %s. This is not supported. Use a separate configuration for each dimension.\", config.getPartitionDimensionName(), dimension.getName())); hiveConfigs.put(clazz.getName(), config); return config; } @SuppressWarnings(\"unchecked\") public static PartitionDimension extractPartitionDimension(Class clazz) { Method partitionIndexMethod = AnnotationHelper.getFirstMethodWithAnnotation(clazz, PartitionIndex.class); return new PartitionDimension(getPartitionDimensionName(clazz), JdbcTypeMapper.primitiveTypeToJdbcType(partitionIndexMethod.getReturnType())); } public static EntityConfig readConfiguration(Class<?> clazz) { PartitionDimension dimension = extractPartitionDimension(clazz); Method versionMethod = AnnotationHelper.getFirstMethodWithAnnotation(clazz, EntityVersion.class); Method resourceIdMethod = AnnotationHelper.getFirstMethodWithAnnotation(clazz, EntityId.class); Method partitionIndexMethod = AnnotationHelper.getFirstMethodWithAnnotation(clazz, PartitionIndex.class); String primaryIndexPropertyName = getIndexNameForMethod(partitionIndexMethod); String idPropertyName = getIndexNameForMethod(resourceIdMethod); String versionPropertyName = versionMethod == null ? null : getIndexNameForMethod(versionMethod); List<EntityIndexConfig> indexes = createIndexMethods(clazz, resourceIdMethod); EntityConfig config = new EntityConfigImpl( clazz, dimension.getName(), getResourceName(clazz), primaryIndexPropertyName, idPropertyName, versionPropertyName, indexes, partitionIndexMethod.getName().equals(resourceIdMethod.getName()) ); return config; } private static List<EntityIndexConfig> createIndexMethods(Class<?> clazz, Method resourceIdMethod) { Collection<Method> indexMethods = getIndexMethods(clazz, resourceIdMethod); List<EntityIndexConfig> indexes = Lists.newArrayList(); for (Method indexMethod : indexMethods) if (isCollectionPropertyOfAComplexType(clazz, indexMethod)) if (isIndexDelegate(indexMethod)) indexes.add(new EntityIndexConfigProxy(clazz, getSecondaryIndexName(indexMethod), getIndexPropertyOfCollectionType(ReflectionTools.getCollectionItemType(clazz, ReflectionTools.getPropertyNameOfAccessor(indexMethod))), readConfiguration(getHiveForeignKeyIndexClass(indexMethod)))); else indexes.add(new EntityIndexConfigImpl(clazz, getSecondaryIndexName(indexMethod), getIndexPropertyOfCollectionType(ReflectionTools.getCollectionItemType(clazz, ReflectionTools.getPropertyNameOfAccessor(indexMethod))))); else if (isIndexDelegate(indexMethod)) indexes.add(new EntityIndexConfigProxy(clazz, getSecondaryIndexName(indexMethod), readConfiguration(getHiveForeignKeyIndexClass(indexMethod)))); else indexes.add(new EntityIndexConfigImpl(clazz, getSecondaryIndexName(indexMethod))); return indexes; } @SuppressWarnings(\"unchecked\") private static Collection<Method> getIndexMethods(Class<?> clazz, final Method resourceIdMethod) { return Filter.grep(new Predicate<Method>() { public boolean f(Method method) { return !method.equals(resourceIdMethod); } }, AnnotationHelper.getAllMethodsWithAnnotations(clazz, (Collection) Arrays.asList(Index.class, PartitionIndex.class))); } private static boolean isIndexDelegate(Method indexMethod) { return indexMethod.getAnnotation(IndexDelegate.class) != null; } private static Class<?> getHiveForeignKeyIndexClass(Method indexMethod) { try { return Class.forName(indexMethod.getAnnotation(IndexDelegate.class).value()); } catch (ClassNotFoundException e) { throw new RuntimeException(\"Class not found \" + indexMethod.getAnnotation(IndexDelegate.class).value()); } } private static boolean isCollectionPropertyOfAComplexType(Class<?> clazz, Method indexMethod) { return ReflectionTools.isCollectionProperty(clazz, ReflectionTools.getPropertyNameOfAccessor(indexMethod)) && !PrimitiveUtils.isPrimitiveClass(ReflectionTools.getCollectionItemType(clazz, ReflectionTools.getPropertyNameOfAccessor(indexMethod))); } @SuppressWarnings(\"unchecked\") private static String getIndexPropertyOfCollectionType(Class collectionType) { try { return ReflectionTools.getPropertyNameOfAccessor(AnnotationHelper.getFirstMethodWithAnnotation(collectionType, Index.class)); } catch (Exception e) { throw new RuntimeException(String.format(\"Unable to find an Index annotation for collection type %s\", collectionType.getName())); } } public Collection<EntityConfig> getConfigurations() { return hiveConfigs.values(); } public EntityConfig getEntityConfig(String className) { return hiveConfigs.get(className); } public EntityHiveConfig getHiveConfiguration() { EntityConfig prototype = Atom.getFirstOrThrow(hiveConfigs.values()); return new PluralHiveConfig(hiveConfigs, prototype.getPartitionDimensionName(), prototype.getPrimaryKeyClass()); } public void install(String uri) { new HiveConfigurationSchemaInstaller(uri).run(); install(Hive.load(uri, CachingDataSourceProvider.getInstance())); } public void install(Hive hive) { Hive target = hive; if (hive.getPartitionDimension() == null) { target = Hive.create(hive.getUri(), dimension.getName(), dimension.getColumnType(), CachingDataSourceProvider.getInstance(), null); } for (EntityConfig config : hiveConfigs.values()) installConfiguration(config, target); } public void installConfiguration(EntityConfig config, Hive hive) { try { "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import java.util.Collection; import java.util.Map; public interface DataAccessObject<T, ID> {  public T get(ID id);  public Collection<T> findByProperty(String propertyName, Object value); public Collection<T> findByProperty(String propertyName, Object value, Integer firstResult, Integer maxResults); public Collection<T> findByPropertyRange(String propertyName, Object minValue, Object maxValue); public Collection<T> findByPropertyRange(String propertyName, Object minValue, Object maxValue, Integer firstResult, Integer maxResults);  public Collection<T> findByProperties(String partitioningPropertyName, Map<String, Object> propertyNameValueMap); public Collection<T> findByProperties(String partitioningPropertyName, Map<String, Object> propertyNameValueMap, Integer firstResult, Integer maxResults); public Collection<Object> getPropertyValue(String propertyName, int firstResult, int maxResults); public Integer getCount(String propertyName, Object propertyValue); public Integer getCountByRange(String propertyName, Object minValue, Object maxValue); public Integer getCountByProperties(String partitioningPropertyName, Map<String, Object> propertyNameValueMap); public Integer getCountByProperties(String partitioningPropertyName, Map<String, Object> propertyNameValueMap, Integer firstResult, Integer maxResults);  public T save(T entity);  public Collection<T> saveAll(Collection<T> collection);  public ID delete(ID id);  public Boolean exists(ID id);  public Class<T> getRespresentedClass(); "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import java.io.Serializable; public interface DataAccessObjectFactory<T, ID extends Serializable> { DataAccessObject<T, ID> create(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import java.lang.reflect.Method; import java.util.Arrays; import java.util.Collection; import java.util.Map; import org.hivedb.annotations.GeneratedClass; import org.hivedb.annotations.IndexDelegate; import org.hivedb.annotations.IndexType; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.configuration.EntityIndexConfig; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.classgen.GeneratedClassFactory; import org.hivedb.util.classgen.GeneratedImplementation; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Pair; import org.hivedb.util.functional.Predicate; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; public class EntityResolver { private EntityHiveConfig entityHiveConfig; public EntityResolver(EntityHiveConfig entityHiveConfig) { this.entityHiveConfig = entityHiveConfig; } public Collection<Class<?>> getEntityClasses() { return Transform.map(new Unary<EntityConfig, Class<?>>() { public Class<?> f(EntityConfig entityConfig) { return entityConfig.getRepresentedInterface(); }}, this.entityHiveConfig.getEntityConfigs()); } "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import java.lang.reflect.Method; import org.hibernate.HibernateException; import org.hibernate.PropertyNotFoundException; import org.hibernate.engine.SessionFactoryImplementor; import org.hibernate.property.BasicPropertyAccessor; import org.hibernate.property.Setter; import org.hivedb.util.classgen.GeneratedInstanceInterceptor; public class GeneratedAccessor extends BasicPropertyAccessor { @SuppressWarnings(\"unchecked\") @Override public Setter getSetter(Class theClass, String propertyName) throws PropertyNotFoundException { return new GeneratedInstanceSetter(propertyName); } public static class GeneratedInstanceSetter implements Setter { private static final long serialVersionUID = 1L; private String propertyName; public GeneratedInstanceSetter(String propertyName) { this.propertyName = propertyName; } public Method getMethod() { "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.annotations.IndexType; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityIndexConfig; import org.hivedb.configuration.EntityIndexConfigDelegator; import org.hivedb.util.functional.*; import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; public class HiveIndexer { private Hive hive; public HiveIndexer(Hive hive) { this.hive = hive; } public void insert(final EntityConfig config, final Object entity) throws HiveLockableException { try { conditionallyInsertPrimaryIndexKey(config, entity); hive.directory().insertResourceId(config.getResourceName(), config.getId(entity), config.getPrimaryIndexKey(entity)); conditionallyInsertDelegatedResourceIndexes(config, entity); insertSecondaryIndexes(config, entity); } catch (RuntimeException e) { hive.directory().deleteResourceId(config.getResourceName(), config.getId(entity)); throw e; } } public void conditionallyInsertPrimaryIndexKey(final EntityConfig config, final Object entity) throws HiveLockableException { if (!hive.directory().doesPrimaryIndexKeyExist(config.getPrimaryIndexKey(entity))) hive.directory().insertPrimaryIndexKey(config.getPrimaryIndexKey(entity)); } private void conditionallyInsertDelegatedResourceIndexes(EntityConfig config, Object entity) throws HiveLockableException { for (EntityIndexConfig entityIndexConfig : config.getEntityIndexConfigs()) if (entityIndexConfig.getIndexType().equals(IndexType.Delegates)) { final EntityIndexConfigDelegator delegateEntityConfig = ((EntityIndexConfigDelegator) entityIndexConfig); for (Object value : entityIndexConfig.getIndexValues(entity)) if (!hive.directory().doesResourceIdExist(delegateEntityConfig.getDelegateEntityConfig().getResourceName(), value)) insert( delegateEntityConfig.getDelegateEntityConfig(), delegateEntityConfig.stubEntityInstance(value, config.getPrimaryIndexKey(entity))); } } private void insertSecondaryIndexes(final EntityConfig config, final Object entity) throws HiveLockableException { Map<String, Collection<Object>> secondaryIndexMap = Transform.toMap( Filter.grep( new Filter.NotNullPredicate<Entry<String, Collection<Object>>>(), Transform.map( new Unary<EntityIndexConfig, Entry<String, Collection<Object>>>() { public Entry<String, Collection<Object>> f(EntityIndexConfig entityIndexConfig) { if (entityIndexConfig.getIndexValues(entity) == null) "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.CallbackException; import org.hibernate.EmptyInterceptor; import org.hibernate.EntityMode; import org.hibernate.Interceptor; import org.hibernate.shards.util.InterceptorDecorator; import org.hibernate.type.Type; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.annotations.AnnotationHelper; import org.hivedb.annotations.EntityId; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.util.classgen.GeneratedClassFactory; import org.hivedb.util.classgen.GeneratedInstanceInterceptor; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Predicate; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import org.springframework.beans.BeanUtils; import java.io.Serializable; import java.lang.reflect.Method; import java.util.Arrays; import java.util.Iterator; public class HiveInterceptorDecorator extends InterceptorDecorator implements Interceptor { private EntityHiveConfig hiveConfig; private HiveIndexer indexer; @SuppressWarnings(\"unchecked\") @Override public Object instantiate(String entityName, EntityMode entityMode, Serializable id) throws CallbackException { Class<?> clazz; try { clazz = Class.forName(entityName); } catch (ClassNotFoundException e) { throw new CallbackException(String.format(\"Unable to load class for %s\", entityName), e); } if (EntityResolver.generatesImplementation(clazz)) return getInstance(GeneratedClassFactory.getGeneratedClass(clazz)); else if (EntityResolver.isGeneratedImplementation(clazz)) { Class generatingClass = Filter.grepSingle(new Predicate<Class>() { public boolean f(Class item) { return EntityResolver.generatesImplementation(item); } }, Arrays.asList(clazz.getInterfaces())); Object instance = getInstance(GeneratedClassFactory.getGeneratedClass(generatingClass)); Method idMethod = AnnotationHelper.getFirstMethodWithAnnotation(generatingClass, EntityId.class); if (idMethod != null) GeneratedInstanceInterceptor.setProperty(instance, BeanUtils.findPropertyForMethod(idMethod).getName(), id); return instance; } else return super.instantiate(entityName, entityMode, id); } private Object getInstance(Class<?> clazz) { try { return clazz.newInstance(); } catch (InstantiationException e) { throw new CallbackException(e); } catch (IllegalAccessException e) { throw new CallbackException(e); } } public HiveInterceptorDecorator(EntityHiveConfig hiveConfig, Hive hive) { this(EmptyInterceptor.INSTANCE, hiveConfig, hive); } public HiveInterceptorDecorator(Interceptor interceptor, EntityHiveConfig hiveConfig, Hive hive) { super(interceptor); this.hiveConfig = hiveConfig; this.indexer = new HiveIndexer(hive); } @Override public Boolean isTransient(Object entity) { Class<?> clazz = new EntityResolver(hiveConfig).resolveEntityInterface(entity.getClass()); if (clazz != null) return !indexer.exists(this.hiveConfig.getEntityConfig(clazz), entity); return super.isTransient(entity); } @SuppressWarnings(\"unchecked\") private Class resolveEntityClass(Class clazz) { return ReflectionTools.whichIsImplemented( clazz, Transform.map(new Unary<EntityConfig, Class>() { public Class f(EntityConfig entityConfig) { return entityConfig.getRepresentedInterface(); } }, hiveConfig.getEntityConfigs())); } @Override public void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) throws CallbackException { try { final Class<?> resolvedEntityClass = resolveEntityClass(entity.getClass()); if (resolvedEntityClass != null) indexer.delete(hiveConfig.getEntityConfig(entity.getClass()), entity); } catch (HiveLockableException e) { throw new CallbackException(e); } super.onDelete(entity, id, state, propertyNames, types); } @SuppressWarnings(\"unchecked\") @Override public void postFlush(Iterator entities) throws CallbackException { while (entities.hasNext()) { Object entity = entities.next(); Class<?> resolvedClass = resolveEntityClass(entity.getClass()); if (resolvedClass != null) { final EntityConfig entityConfig = hiveConfig.getEntityConfig(resolvedClass); if (indexer.exists(entityConfig, entity)) updateIndexes(entity); else insertIndexes(entity); } } super.postFlush(entities); } private void updateIndexes(Object entity) { try { final Class<?> resolvedEntityClass = resolveEntityClass(entity.getClass()); if (resolvedEntityClass != null) { final EntityConfig entityConfig = hiveConfig.getEntityConfig(entity.getClass()); if (indexer.idExists(entityConfig, entityConfig.getId(entity))) indexer.updatePartitionDimensionIndexIfNeeded(hiveConfig.getEntityConfig(resolvedEntityClass), entity); indexer.update(entityConfig, entity); } } catch (HiveLockableException e) { throw new CallbackException(e); } } private void insertIndexes(Object entity) { try { final Class<?> resolvedEntityClass = resolveEntityClass(entity.getClass()); if (resolvedEntityClass != null) indexer.insert(hiveConfig.getEntityConfig(resolvedEntityClass), entity); } catch (HiveLockableException e) { throw new CallbackException(e); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.Interceptor; import org.hibernate.Session; public interface HiveSessionFactory { public Session openSession(); public Session openSession(Interceptor interceptor); public Session openSession(Object primaryIndexKey); public Session openSession(Object primaryIndexKey, Interceptor interceptor); public Session openSession(String resource, Object resourceId); public Session openSession(String resource, Object resourceId, Interceptor interceptor); public Session openSession(String resource, String indexName, Object secondaryIndexKey); public Session openSession(String resource, String indexName, Object secondaryIndexKey, Interceptor interceptor); public Session openAllShardsSession();  public Interceptor getDefaultInterceptor(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.shards.session.ShardedSessionFactory; public interface HiveSessionFactoryBuilder { public ShardedSessionFactory getSessionFactory(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.Interceptor; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; import org.hibernate.dialect.H2Dialect; import org.hibernate.dialect.MySQLInnoDBDialect; import org.hibernate.shards.Shard; import org.hibernate.shards.ShardId; import org.hibernate.shards.ShardedConfiguration; import org.hibernate.shards.cfg.ConfigurationToShardConfigurationAdapter; import org.hibernate.shards.cfg.ShardConfiguration; import org.hibernate.shards.session.ShardedSessionFactory; import org.hibernate.shards.session.ShardedSessionImpl; import org.hibernate.shards.strategy.ShardStrategy; import org.hibernate.shards.strategy.ShardStrategyFactory; import org.hibernate.shards.strategy.ShardStrategyImpl; import org.hibernate.shards.strategy.access.ShardAccessStrategy; import org.hibernate.shards.util.Lists; import org.hibernate.shards.util.Maps; import org.hivedb.Hive; import org.hivedb.HiveKeyNotFoundException; import org.hivedb.Synchronizeable; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.meta.Node; import org.hivedb.meta.persistence.CachingDataSourceProvider; import org.hivedb.util.Combiner; import org.hivedb.util.database.DriverLoader; import org.hivedb.util.database.HiveDbDialect; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Filter.BinaryPredicate; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Transform.IdentityFunction; import org.hivedb.util.functional.Unary; import java.util.*; import java.util.Map.Entry; "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.shards.ShardId; import org.hibernate.shards.strategy.resolution.ShardResolutionStrategy; import org.hibernate.shards.strategy.selection.ShardResolutionStrategyData; import org.hibernate.shards.util.Lists; import org.hivedb.Hive; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.configuration.EntityIndexConfig; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.util.Collection; import java.util.List; public class HiveShardResolver implements ShardResolutionStrategy { private EntityHiveConfig hiveConfig; private Hive hive; public HiveShardResolver(EntityHiveConfig hiveConfig, Hive hive) { this.hiveConfig = hiveConfig; this.hive = hive; } @SuppressWarnings(\"unchecked\") public List<ShardId> selectShardIdsFromShardResolutionStrategyData(ShardResolutionStrategyData data) { final Class clazz; try { clazz = Class.forName(data.getEntityName()); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } final Class<?> resolvedEntityInterface = new EntityResolver(hiveConfig).resolveToEntityOrRelatedEntity(clazz); if (resolvedEntityInterface != null) { EntityConfig config = hiveConfig.getEntityConfig(resolvedEntityInterface); Collection<Integer> ids = (config.isPartitioningResource()) ? hive.directory().getNodeIdsOfPrimaryIndexKey(data.getId()) : hive.directory().getNodeIdsOfResourceId(config.getResourceName(), data.getId()); return Lists.newArrayList(Transform.map(nodeIdToShardIdConverter(), ids)); } else { "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.shards.ShardId; import org.hibernate.shards.strategy.selection.ShardSelectionStrategy; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.HiveRuntimeException; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.util.Collection; public class HiveShardSelector implements ShardSelectionStrategy { private EntityHiveConfig hiveConfig; private Hive hive; public HiveShardSelector(EntityHiveConfig hiveConfig, Hive hive) { this.hiveConfig = hiveConfig; this.hive = hive; } "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.Session; import java.util.Collection; public interface QueryCallback { public Collection<Object> execute(Session session); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.HibernateException; import org.hibernate.Session; import org.hibernate.shards.session.OpenSessionEvent; import java.sql.SQLException; public class RecordNodeOpenSessionEvent implements OpenSessionEvent { public static ThreadLocal<String> node = new ThreadLocal<String>(); public static String getNode() { return node.get(); } public static void setNode(Session session) { node.set(getNode(session)); } public void onOpenSession(Session session) { setNode(session); } @SuppressWarnings(\"deprecation\") private static String getNode(Session session) { String node = \"\"; if (session != null) { try { node = session.connection().getMetaData().getURL(); } catch (SQLException ex) { } catch (HibernateException ex) { } } return node; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate; import org.hibernate.Session; public interface SessionCallback { public void execute(Session session); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified; import java.util.Collection; import java.util.Map; public interface DataAccessObject<T, ID> {  public T get(ID id);  public Boolean exists(ID id);  public Collection<T> find(Map<String, Object> properties);  public Collection<T> find(Map<String, Object> properties, Integer offSet, Integer maxResultSetSize); public Collection<T> findInRange(String propertyName, Object minValue, Object maxValue); public Collection<T> findInRange(String propertyName, Object minValue, Object maxValue, Integer offSet, Integer maxResultSetSize); public Integer getCount(Map<String, Object> properties); public Integer getCountInRange(String propertyName, Object minValue, Object maxValue);  public T save(T entity);  public Collection<T> saveAll(Collection<T> collection);  public ID delete(ID id);  public Class<T> getRespresentedClass(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.Criteria; import org.hibernate.HibernateException; import org.hibernate.LockMode; import org.hibernate.Session; import org.hibernate.criterion.Projections; import org.hibernate.criterion.Restrictions; import org.hibernate.exception.ConstraintViolationException; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.configuration.EntityConfig; import org.hivedb.hibernate.QueryCallback; import org.hivedb.hibernate.SessionCallback; import org.hivedb.hibernate.simplified.session.HiveCriteria; import org.hivedb.hibernate.simplified.session.HiveCriteriaImpl; import org.hivedb.hibernate.simplified.session.HiveSessionFactory; import org.hivedb.util.classgen.ReflectionTools; import java.io.Serializable; import java.util.Collection; import java.util.Map;  "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.FlushMode; import org.hibernate.Session; import org.hibernate.Transaction; import org.hivedb.hibernate.QueryCallback; import org.hivedb.hibernate.RecordNodeOpenSessionEvent; import org.hivedb.hibernate.SessionCallback; import org.hivedb.util.Lists; import org.hivedb.util.functional.Atom; import java.io.Serializable; import java.util.Collection; import java.util.Collections; public class HibernateTransactionHelper { private final static Log log = LogFactory.getLog(HibernateTransactionHelper.class); public Object querySingleInTransaction(QueryCallback callback, Session session) { Collection<Object> results = Lists.newArrayList(); try { session.setFlushMode(FlushMode.MANUAL); Transaction tx = session.beginTransaction(); results = callback.execute(session); tx.commit(); } catch( RuntimeException e ) { log.debug(\"queryInTransaction: Error on data node \" + RecordNodeOpenSessionEvent.getNode(), e); throw e; } finally { session.close(); } return Atom.getFirstOrNull(results); } public Collection<Object> queryInTransaction(QueryCallback callback, Session session) { Collection<Object> results = Lists.newArrayList(); try { session.setFlushMode(FlushMode.MANUAL); Transaction tx = session.beginTransaction(); results = callback.execute(session); tx.commit(); } catch( RuntimeException e ) { log.debug(\"queryInTransaction: Error on data node \" + RecordNodeOpenSessionEvent.getNode(), e); throw e; } finally { session.close(); } return results; } public void updateInTransaction(SessionCallback callback, Session session) { Transaction tx = null; try { tx = session.beginTransaction(); callback.execute(session); tx.commit(); } catch( RuntimeException e ) { log.debug(\"doInTransaction: Error on data node \" + RecordNodeOpenSessionEvent.getNode(), e); if(tx != null) tx.rollback(); throw e; } finally { session.close(); } } public<ID extends Serializable> QueryCallback newGetCallback(final ID id, final Class<?> clazz) { return new QueryCallback() { public Collection<Object> execute(Session session) { return Collections.singletonList(session.get(clazz, id)); } }; } public<T> SessionCallback newSaveCallback(final T entity, final Class<T> clazz) { return new SessionCallback() { public void execute(Session session) { session.saveOrUpdate(clazz.getName(), entity); } }; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified; import org.hibernate.CallbackException; import org.hibernate.EmptyInterceptor; import org.hibernate.Interceptor; import org.hibernate.shards.util.InterceptorDecorator; import org.hibernate.type.Type; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.hibernate.EntityResolver; import org.hivedb.hibernate.HiveIndexer; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.io.Serializable; import java.util.Iterator; public class HiveInterceptorDecorator extends InterceptorDecorator implements Interceptor { private EntityHiveConfig hiveConfig; private HiveIndexer indexer; public HiveInterceptorDecorator(EntityHiveConfig hiveConfig, Hive hive) { this(EmptyInterceptor.INSTANCE, hiveConfig, hive); } public HiveInterceptorDecorator(Interceptor interceptor, EntityHiveConfig hiveConfig, Hive hive) { super(interceptor); this.hiveConfig = hiveConfig; this.indexer = new HiveIndexer(hive); } @Override public Boolean isTransient(Object entity) { Class<?> clazz = new EntityResolver(hiveConfig).resolveEntityInterface(entity.getClass()); if (clazz != null) return !indexer.exists(this.hiveConfig.getEntityConfig(clazz), entity); return super.isTransient(entity); } @SuppressWarnings(\"unchecked\") private Class resolveEntityClass(Class clazz) { return ReflectionTools.whichIsImplemented( clazz, Transform.map(new Unary<EntityConfig, Class>() { public Class f(EntityConfig entityConfig) { return entityConfig.getRepresentedInterface(); } }, hiveConfig.getEntityConfigs())); } @Override public void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) throws CallbackException { try { final Class<?> resolvedEntityClass = resolveEntityClass(entity.getClass()); if (resolvedEntityClass != null) indexer.delete(hiveConfig.getEntityConfig(entity.getClass()), entity); } catch (HiveLockableException e) { throw new CallbackException(e); } super.onDelete(entity, id, state, propertyNames, types); } @SuppressWarnings(\"unchecked\") @Override public void postFlush(Iterator entities) throws CallbackException { while (entities.hasNext()) { Object entity = entities.next(); Class<?> resolvedClass = resolveEntityClass(entity.getClass()); if (resolvedClass != null) { final EntityConfig entityConfig = hiveConfig.getEntityConfig(resolvedClass); if (indexer.exists(entityConfig, entity)) updateIndexes(entity); else insertIndexes(entity); } } super.postFlush(entities); } private void updateIndexes(Object entity) { try { final Class<?> resolvedEntityClass = resolveEntityClass(entity.getClass()); if (resolvedEntityClass != null) { final EntityConfig entityConfig = hiveConfig.getEntityConfig(entity.getClass()); if (indexer.idExists(entityConfig, entityConfig.getId(entity))) indexer.updatePartitionDimensionIndexIfNeeded(hiveConfig.getEntityConfig(resolvedEntityClass), entity); indexer.update(entityConfig, entity); } } catch (HiveLockableException e) { throw new CallbackException(e); } } private void insertIndexes(Object entity) { try { final Class<?> resolvedEntityClass = resolveEntityClass(entity.getClass()); if (resolvedEntityClass != null) indexer.insert(hiveConfig.getEntityConfig(resolvedEntityClass), entity); } catch (HiveLockableException e) { throw new CallbackException(e); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified; import org.apache.log4j.Logger; import org.hibernate.HibernateException; import org.hibernate.action.Executable; import org.hibernate.event.PostDeleteEvent; import org.hibernate.event.PostDeleteEventListener; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.hibernate.HiveIndexer; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.io.Serializable;  public class PostDeleteEventListenerImpl implements PostDeleteEventListener { private static final Logger log = Logger.getLogger(PostInsertEventListenerImpl.class); private final EntityHiveConfig hiveConfig; private final HiveIndexer indexer; public PostDeleteEventListenerImpl(EntityHiveConfig hiveConfig, Hive hive) { this.hiveConfig = hiveConfig; indexer = new HiveIndexer(hive); } public void onPostDelete(final PostDeleteEvent event) { event.getSession().getActionQueue().execute(new Executable() { public void afterTransactionCompletion(boolean success) { if (success) { deleteIndexes(event.getEntity()); } } public void beforeExecutions() throws HibernateException { "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified; import org.apache.log4j.Logger; import org.hibernate.HibernateException; import org.hibernate.action.Executable; import org.hibernate.event.PostInsertEvent; import org.hibernate.event.PostInsertEventListener; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.hibernate.HiveIndexer; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.io.Serializable;  public class PostInsertEventListenerImpl implements PostInsertEventListener { private static final Logger log = Logger.getLogger(PostInsertEventListenerImpl.class); private final EntityHiveConfig hiveConfig; private final HiveIndexer indexer; public PostInsertEventListenerImpl(EntityHiveConfig hiveConfig, Hive hive) { this.hiveConfig = hiveConfig; indexer = new HiveIndexer(hive); } public void onPostInsert(final PostInsertEvent event) { event.getSession().getActionQueue().execute(new Executable() { public void afterTransactionCompletion(boolean success) { if (success) { insertIndexes(event.getEntity()); } } public void beforeExecutions() throws HibernateException { "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified; import org.apache.log4j.Logger; import org.hibernate.HibernateException; import org.hibernate.action.Executable; import org.hibernate.event.PostUpdateEvent; import org.hibernate.event.PostUpdateEventListener; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.hibernate.HiveIndexer; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.io.Serializable;  public class PostUpdateEventListenerImpl implements PostUpdateEventListener { private static final Logger log = Logger.getLogger(PostUpdateEventListenerImpl.class); private final EntityHiveConfig hiveConfig; private final HiveIndexer indexer; public PostUpdateEventListenerImpl(EntityHiveConfig hiveConfig, Hive hive) { this.hiveConfig = hiveConfig; indexer = new HiveIndexer(hive); } public void onPostUpdate(final PostUpdateEvent event) { event.getSession().getActionQueue().execute(new Executable() { public void afterTransactionCompletion(boolean success) { if (success) { updateIndexes(event.getEntity()); } } public void beforeExecutions() throws HibernateException { "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.configuration; public interface CollectionIndexConfig extends IndexConfig { String getInnerClassIdPropertyName(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.configuration; import org.hivedb.annotations.IndexType; import org.hivedb.configuration.EntityIndexConfig; import java.util.Collection; import java.util.EnumSet; public interface EntityConfig<T> { String getPartitionKeyPropertyName(); String getPartitionDimensionName(); EntityIndexConfig getPartitionEntityIndexConfig(); Class<?> getPartitionKeyClass(); String getIdPropertyName(); Collection<EntityIndexConfig> getEntityIndexConfigs(); EntityIndexConfig getEntityIndexConfig(String propertyName); Collection<EntityIndexConfig> getEntityIndexConfigs(EnumSet<IndexType> indexTypes); Collection<EntityIndexConfig> getEntityIndexConfigs(IndexType indexType); String getResourceName(); boolean isPartitioningResource(); Class<T> getEntityClass(); Class<?> getIdClass(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.configuration; import org.hivedb.configuration.EntityConfig; import java.util.Collection; public interface HiveConfig { public String getPartitionDimensionName(); public Class<?> getPartitionDimensionType(); public Collection<EntityConfig> getEntityConfigs(); public EntityConfig getEntityConfig(Class<?> clazz); public EntityConfig getEntityConfig(String clazz); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.configuration; import org.hivedb.annotations.IndexType; import org.hivedb.util.validators.Validator; public interface IndexConfig { String getIndexName(); String getPropertyName(); Class<?> getIndexClass(); IndexType getIndexType(); Validator getValidator(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.session; import org.hibernate.Criteria; public interface HiveCriteria extends Criteria { public Criteria addRangeRestriction(String propertyName, Object minValue, Object maxValue); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.session; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.*; import org.hibernate.criterion.Criterion; import org.hibernate.criterion.Order; import org.hibernate.criterion.Projection; import org.hibernate.criterion.Restrictions; import org.hibernate.transform.ResultTransformer; import org.hivedb.util.classgen.ReflectionTools; import java.io.Serializable; import java.util.List; public class HiveCriteriaImpl implements HiveCriteria, Serializable { private final static Log log = LogFactory.getLog(HiveCriteriaImpl.class); private Criteria criteria; private Class<?> clazz; public HiveCriteriaImpl(Criteria criteria, Class<?> clazz) { this.criteria = criteria; this.clazz = clazz; } public Criteria addRangeRestriction(String propertyName, Object minValue, Object maxValue) { if (ReflectionTools.isComplexCollectionItemProperty(clazz, propertyName)) { criteria.createCriteria(propertyName).add(Restrictions.between(\"id\", minValue, maxValue)); } else { criteria.add(Restrictions.between(propertyName, minValue, maxValue)); } return this; } public String getAlias() { return criteria.getAlias(); } public Criteria setProjection(Projection projection) { criteria.setProjection(projection); return this; } public Criteria add(Criterion criterion) { criteria.add(criterion); return this; } public Criteria addOrder(Order order) { criteria.addOrder(order); return this; } public Criteria setFetchMode(String s, FetchMode fetchMode) { criteria.setFetchMode(s, fetchMode); return this; } public Criteria setLockMode(LockMode lockMode) { criteria.setLockMode(lockMode); return this; } public Criteria setLockMode(String s, LockMode lockMode) { criteria.setLockMode(s, lockMode); return this; } public Criteria createAlias(String s, String s1) { return criteria.createAlias(s, s1); } public Criteria createAlias(String s, String s1, int i) { return criteria.createAlias(s, s1, i); } public Criteria createCriteria(String s) { return criteria.createCriteria(s); } public Criteria createCriteria(String s, int i) { return criteria.createCriteria(s, i); } public Criteria createCriteria(String s, String s1) { return criteria.createCriteria(s, s1); } public Criteria createCriteria(String s, String s1, int i) { return criteria.createCriteria(s, s1, i); } public Criteria setResultTransformer(ResultTransformer resultTransformer) { criteria.setResultTransformer(resultTransformer); return this; } public Criteria setMaxResults(int i) { criteria.setMaxResults(i); return this; } public Criteria setFirstResult(int i) { criteria.setFirstResult(i); return this; } public Criteria setFetchSize(int i) { criteria.setFetchSize(i); return this; } public Criteria setTimeout(int i) { criteria.setTimeout(i); return this; } public Criteria setCacheable(boolean b) { criteria.setCacheable(b); return this; } public Criteria setCacheRegion(String s) { criteria.setCacheRegion(s); return this; } public Criteria setComment(String s) { criteria.setComment(s); return this; } public Criteria setFlushMode(FlushMode flushMode) { criteria.setFlushMode(flushMode); return this; } public Criteria setCacheMode(CacheMode cacheMode) { criteria.setCacheMode(cacheMode); return this; } public List list() throws HibernateException { return criteria.list(); } public ScrollableResults scroll() { return criteria.scroll(); } public ScrollableResults scroll(ScrollMode scrollMode) { return criteria.scroll(scrollMode); } public Object uniqueResult() throws HibernateException { return criteria.uniqueResult(); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.session; import org.hibernate.Session; import org.hibernate.Interceptor; public interface HiveSessionFactory { public Session openSession(); public Session openSession(Interceptor interceptor); public Session openSession(Object primaryIndexKey); public Session openSession(Object primaryIndexKey, Interceptor interceptor); public Session openSession(String resource, Object resourceId); public Session openSession(String resource, Object resourceId, Interceptor interceptor); public Session openSession(String resource, String indexName, Object secondaryIndexKey); public Session openSession(String resource, String indexName, Object secondaryIndexKey, Interceptor interceptor); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.session; public interface HiveSessionFactoryBuilder { HiveSessionFactory getSessionFactory(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.session; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.Interceptor; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.shards.Shard; import org.hibernate.shards.session.ShardedSessionFactory; import org.hibernate.shards.session.ShardedSessionImpl; import org.hivedb.Hive; import org.hivedb.HiveRuntimeException; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.hibernate.RecordNodeOpenSessionEvent; import org.hivedb.hibernate.simplified.HiveInterceptorDecorator; import org.hivedb.meta.Node; import org.hivedb.util.functional.*; import java.sql.SQLException; import java.util.Collection; import java.util.HashMap; import java.util.Map; "}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.session; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.cfg.Configuration; import org.hibernate.shards.ShardId; import org.hibernate.shards.ShardedConfiguration; import org.hibernate.shards.cfg.ShardConfiguration; import org.hibernate.shards.session.ShardedSessionFactory; import org.hibernate.shards.strategy.ShardStrategy; import org.hibernate.shards.strategy.ShardStrategyFactory; import org.hibernate.shards.strategy.ShardStrategyImpl; import org.hibernate.shards.strategy.access.ShardAccessStrategy; import org.hivedb.Hive; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.hibernate.ConfigurationReader; import org.hivedb.hibernate.HiveShardResolver; import org.hivedb.hibernate.HiveShardSelector; import org.hivedb.hibernate.simplified.session.configuration.NodeConfiguration; import org.hivedb.meta.Node; import org.hivedb.util.Lists; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.util.*; public class SingletonHiveSessionFactoryBuilder implements HiveSessionFactoryBuilder, Observer { private final static Log log = LogFactory.getLog(SingletonHiveSessionFactoryBuilder.class); private HiveSessionFactory factory = null; private Hive hive; private List<Class<?>> persistableClasses; private Properties overrides; private ShardAccessStrategy accessStrategy; private EntityHiveConfig hiveConfig; public SingletonHiveSessionFactoryBuilder(Hive hive, List<Class<?>> persistableClasses, ShardAccessStrategy accessStrategy) { this(hive, persistableClasses, accessStrategy, new Properties()); } public SingletonHiveSessionFactoryBuilder(Hive hive, List<Class<?>> persistableClasses, ShardAccessStrategy accessStrategy, Properties overrides) { this.hive = hive; this.persistableClasses = persistableClasses; this.overrides = overrides; this.accessStrategy = accessStrategy; this.hiveConfig = new ConfigurationReader(this.persistableClasses).getHiveConfiguration(); } public HiveSessionFactory getSessionFactory() { if(factory == null) factory = buildSessionFactory(); return factory; } private HiveSessionFactory buildSessionFactory() { log.info(\"Building HiveSessionFactory\"); Collection<NodeConfiguration> nodeConfigs = getNodeConfigurations(); Collection<ShardConfiguration> shardConfigs = Transform.map(new Unary<NodeConfiguration, ShardConfiguration>(){ public ShardConfiguration f(NodeConfiguration item) { log.info(\"Adding node: \" + item.getNode().getUri()); return item.toShardConfig(); } },nodeConfigs); ShardedSessionFactory shardedFactory = new ShardedConfiguration( buildPrototypeConfiguration(Atom.getFirstOrThrow(nodeConfigs)), Lists.newList(shardConfigs), buildShardStrategyFactory()).buildShardedSessionFactory(); logIterable(\"Adding class:\", persistableClasses); logMap(\"Overriding: \", overrides); return new HiveSessionFactoryImpl(shardedFactory, hive, hiveConfig); } private ShardStrategyFactory buildShardStrategyFactory() { return new ShardStrategyFactory() { public ShardStrategy newShardStrategy(List<ShardId> shardIds) { return new ShardStrategyImpl( new HiveShardSelector(hiveConfig,hive), new HiveShardResolver(hiveConfig,hive), accessStrategy); } }; } private Configuration buildPrototypeConfiguration(Configuration config) { for(Class clazz : persistableClasses) config.addClass(clazz); config.setProperty(\"hibernate.session_factory_name\", \"factory:prototype\"); return config; } private Collection<NodeConfiguration> getNodeConfigurations() { return Transform.map(new Unary<Node,NodeConfiguration>(){ public NodeConfiguration f(Node item) { return (NodeConfiguration) new NodeConfiguration(item, overrides).configure(); } }, hive.getNodes()); } public void update(Observable o, Object arg) { log.info(\"Update received\"); HiveSessionFactory newFactory = buildSessionFactory(); synchronized(this) { this.factory = newFactory; } } private void logIterable(String prefix, Iterable<?> iterable) { for(Object o : iterable) { log.info(String.format(\"%s %s\", prefix, o)); } } private void logMap(String prefix, Map<?,?> map) { for(Map.Entry e : map.entrySet()) { log.info(String.format(\"%s %s => %s\", prefix, e.getKey(), e.getValue())); } } public Hive getHive() { return hive; } public Properties getOverrides() { return overrides; } public List<Class<?>> getPersistableClasses() { return persistableClasses; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.hibernate.simplified.session.configuration; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.cfg.Configuration; import org.hibernate.shards.cfg.ConfigurationToShardConfigurationAdapter; import org.hibernate.shards.cfg.ShardConfiguration; import org.hivedb.meta.Node; import org.hivedb.util.database.DialectTools; import org.hivedb.util.database.DriverLoader; import java.util.Map; import java.util.Properties; public class NodeConfiguration extends Configuration { private final static Log log = LogFactory.getLog(NodeConfiguration.class); private Node node; private Properties overrides = new Properties(); public NodeConfiguration(Node node){ super(); this.node = node; } public NodeConfiguration(Node node, Properties overrides) { this.node = node; this.overrides = overrides; } @Override public Configuration configure() { super.configure(); setProperty(\"hibernate.session_factory_name\", \"factory:\"+node.getName()); setProperty(\"hibernate.dialect\", DialectTools.getHibernateDialect(node.getDialect()).getName()); setProperty(\"hibernate.connection.driver_class\", DriverLoader.getDriverClass(node.getDialect())); setProperty(\"hibernate.connection.url\", node.getUri()); setProperty(\"hibernate.connection.shard_id\", node.getId().toString()); setProperty(\"hibernate.shard.enable_cross_shard_relationship_checks\", \"true\"); for(Map.Entry<Object,Object> prop : overrides.entrySet()) setProperty(prop.getKey().toString(), prop.getValue().toString()); return this; } public ShardConfiguration toShardConfig() { return new ConfigurationToShardConfigurationAdapter(configure()); } public Node getNode() { return node; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management; import javax.sql.DataSource; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.support.incrementer.DataFieldMaxValueIncrementer;  public class H2KeyAuthority extends JdbcKeyAuthority { public H2KeyAuthority(Class keySpace, Class returnType) { super(keySpace, returnType); setIncrementer(this.getIncrementer()); } private DataFieldMaxValueIncrementer getIncrementer() { return new DerbyDataFieldMaxValueIncrementer(); } private static class DerbyDataFieldMaxValueIncrementer implements DataFieldMaxValueIncrementer { static int nextInt = 0; static long nextLong = 0; public int nextIntValue() throws DataAccessException { return ++nextInt; } public long nextLongValue() throws DataAccessException { return ++nextLong; } public String nextStringValue() throws DataAccessException { throw new RuntimeException(\"Strings are not supported\"); } }; protected void createSchema() {} }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management; import org.hivedb.HiveRuntimeException; import org.hivedb.configuration.HiveConfigurationSchema; import org.hivedb.meta.persistence.CachingDataSourceProvider; import org.hivedb.meta.persistence.HiveSemaphoreDao; import org.hivedb.util.GetOpt; import org.hivedb.util.database.Schemas; import java.sql.Connection; import java.sql.DriverManager; import java.util.Map; public class HiveConfigurationSchemaCommandLineInstaller implements Runnable { private String uri; public HiveConfigurationSchemaCommandLineInstaller(String uri) { this.uri = uri; } public void run() { try { Schemas.install(new HiveConfigurationSchema(), uri); new HiveSemaphoreDao(CachingDataSourceProvider.getInstance().getDataSource(uri)).create(); } catch (Exception e) { throw new HiveRuntimeException(e.getMessage(), e); } } public static void main(String[] argz) { GetOpt opt = new GetOpt(); opt.add(\"host\", true); opt.add(\"db\", true); opt.add(\"user\", true); opt.add(\"pw\", true); Map<String, String> argMap = opt.toMap(argz); if (!opt.validate()) throw new IllegalArgumentException( \"Usage: java -jar hivedb-installer.jar -host <host> -db <database name> -user <username> -pw <password>\"); else { try { "}
{"name": "britt/hivedb", "content": "package org.hivedb.management; import org.hivedb.HiveRuntimeException; import org.hivedb.configuration.HiveConfigurationSchema; import org.hivedb.meta.persistence.CachingDataSourceProvider; import org.hivedb.meta.persistence.HiveSemaphoreDao; import org.hivedb.util.GetOpt; import java.sql.Connection; import java.sql.DriverManager; import java.util.Map; public class HiveConfigurationSchemaInstaller implements Runnable { private String uri; public HiveConfigurationSchemaInstaller(String uri) { this.uri = uri; } public void run() { try { new HiveConfigurationSchema(uri).install(); new HiveSemaphoreDao(CachingDataSourceProvider.getInstance().getDataSource(uri)).create(); } catch (Exception e) { throw new HiveRuntimeException(e.getMessage(), e); } } public static void main(String[] argz) { GetOpt opt = new GetOpt(); opt.add(\"host\", true); opt.add(\"db\", true); opt.add(\"user\", true); opt.add(\"pw\", true); Map<String, String> argMap = opt.toMap(argz); if (!opt.validate()) throw new IllegalArgumentException( \"Usage: java -jar hivedb-installer.jar -host <host> -db <database name> -user <username> -pw <password>\"); else { try { "}
{"name": "britt/hivedb", "content": "package org.hivedb.management; import javax.sql.DataSource; import org.hivedb.HiveRuntimeException; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.support.incrementer.DataFieldMaxValueIncrementer;  public class JdbcKeyAuthority implements KeyAuthority { DataFieldMaxValueIncrementer incrementer = null; private Class returnType = null; private Class keySpace = null; "}
{"name": "britt/hivedb", "content": "package org.hivedb.management; "}
{"name": "britt/hivedb", "content": "package org.hivedb.management; public interface KeyAuthorityCreator { KeyAuthority create(Class keySpace, Class returnType); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management; import org.hivedb.util.database.HiveDbDialect; public class KeyAuthorityFactory { public static KeyAuthority create( HiveDbDialect dialect, Class keySpace, Class<?> returnType) { if (dialect.equals(HiveDbDialect.MySql)) return new JdbcKeyAuthority(keySpace, returnType); if (dialect.equals(HiveDbDialect.H2)) return new MemoryKeyAuthority().create(keySpace, returnType); throw new RuntimeException(String.format(\"Unknown HiveDbDialect %s\", dialect.name())); } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.management; import org.hivedb.util.functional.Generator; public class MemoryKeyAuthority implements KeyAuthorityCreator { public KeyAuthority create(Class keySpace, final Class returnType) { final Generator incrementor; if (returnType.equals(int.class) || returnType.equals(Integer.class)) incrementor = new Generator<Integer>() { private int i=0;; public Integer generate() { return ++i; } }; else if (returnType.equals(long.class) || returnType.equals(Long.class)) incrementor = new Generator<Long>() { private long i=0;; public Long generate() { return ++i; } }; else throw new RuntimeException(\"Only Integers and Longs are supported\"); return new KeyAuthority() { public Object nextAvailableKey() { return increment(); } @SuppressWarnings(\"unchecked\") private Object increment() { return incrementor.generate(); } }; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management; import javax.sql.DataSource; import org.springframework.jdbc.support.incrementer.DataFieldMaxValueIncrementer; import org.springframework.jdbc.support.incrementer.MySQLMaxValueIncrementer;  public class MySqlKeyAuthority<T extends Number> extends JdbcKeyAuthority { public MySqlKeyAuthority(DataSource ds, Class keySpace, Class returnType) { super(keySpace, returnType); this.setDataSource(ds); setIncrementer(this.getIncrementer(ds)); } private DataFieldMaxValueIncrementer getIncrementer(DataSource ds) { MySQLMaxValueIncrementer incrementer = new MySQLMaxValueIncrementer(); incrementer.setCacheSize(100); incrementer.setDataSource(ds); incrementer.setIncrementerName(getKeyspaceTableName()); incrementer.setColumnName(COLUMN_NAME); return incrementer; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management; import org.hivedb.Hive; import org.hivedb.hibernate.ConfigurationReader; import org.hivedb.meta.persistence.CachingDataSourceProvider; import java.util.List; "}
{"name": "britt/hivedb", "content": "package org.hivedb.management.migration; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.meta.Node; import org.hivedb.meta.PartitionDimension; import org.hivedb.meta.directory.DbDirectory; import org.hivedb.meta.directory.KeySemaphore; import org.hivedb.util.Lists; import org.hivedb.util.functional.Collect; import org.hivedb.util.functional.Pair; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.util.Collection; import java.util.List; public class HiveMigrator implements Migrator { private Hive hive; private PartitionDimension dimension; public HiveMigrator(Hive hive) { this.hive = hive; this.dimension = hive.getPartitionDimension(); } @SuppressWarnings(\"unchecked\") public void deepNodeToNodeCopy(Object migrant, Node origin, Node destination, PartitionKeyMover mover) { try { "}
{"name": "britt/hivedb", "content": "package org.hivedb.management.migration; import java.util.Collection; public interface KeyLocator<I,R> { public Collection<R> findAll(I parent); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management.migration; public class MigrationException extends RuntimeException { public MigrationException() {} public MigrationException(Exception innerException) {super(innerException);} public MigrationException(String msg) {super(msg);} public MigrationException(String msg, Exception innerException) {super(msg, innerException);}  private static final long serialVersionUID = 44048207672206567L; }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management.migration; public class MigrationPlanningException extends Exception {  private static final long serialVersionUID = -3126324251753631617L; public MigrationPlanningException(){ super(\"Unable to compute a valid migration plan.\"); } public MigrationPlanningException(String message) { super(message); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management.migration; import java.util.Collection; public interface Migrator {  @SuppressWarnings(\"unchecked\") public abstract void migrate(Object key, Collection<String> destinationNames, PartitionKeyMover mover); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management.migration; import org.hivedb.meta.Node; public interface Mover<T> { public void copy(T item, Node node); public T get(Object id, Node node); public void delete(T item, Node node); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.management.migration; import java.util.Collection; import java.util.Map.Entry; public interface PartitionKeyMover<T> extends Mover<T> { public Collection<Entry<Mover, KeyLocator>> getDependentMovers(); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta;  public enum AccessType { Read, ReadWrite }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta; import java.util.Collection; public interface Assigner { Node chooseNode(Collection<Node> nodes, Object value); Collection<Node> chooseNodes(Collection<Node> nodes, Object value); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta; import org.hivedb.Lockable; public interface HiveSemaphore extends Lockable { void setRevision(int revision); void setStatus(Status status); int getRevision(); void incrementRevision(); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta; import org.hivedb.Lockable;  public class HiveSemaphoreImpl implements HiveSemaphore { private Lockable.Status status = Lockable.Status.writable; private int revision = 0; public HiveSemaphoreImpl() { } public void setRevision(int revision) { this.revision = revision; } public HiveSemaphoreImpl(Lockable.Status status, int revision) { this.status = status; this.revision = revision; } public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } public int getRevision() { return revision; } public void incrementRevision() { revision++; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta; public interface IdAndNameIdentifiable<T> extends Identifiable<T>, Nameable { }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta; public interface Identifiable<F> { F getId(); void setId(F field); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta; public interface Nameable { String getName(); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta; import org.hivedb.Lockable; import org.hivedb.util.HiveUtils; import org.hivedb.util.database.HiveDbDialect; import org.hivedb.util.database.JdbcUriFormatter;  public class Node implements Comparable<Node>, Cloneable, IdAndNameIdentifiable<Integer>, Lockable { private int id,port; private String name, host,databaseName, username, password, options; private Status status = Status.writable; private double capacity; private HiveDbDialect dialect; public Node(int id, String name, String databaseName, String host, HiveDbDialect dialect) { this(name, databaseName, host, dialect); this.id = id; } public Node(String name, String databaseName, String host, HiveDbDialect dialect){ this.name = name; this.databaseName = databaseName; this.host = host; this.dialect = dialect; } public Node() {} public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getHost() { return host; } public void setHost(String host) { this.host = host; } public String getDatabaseName() { return databaseName; } public void setDatabaseName(String databaseName) { this.databaseName = databaseName; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getOptions() { return options; } public void setOptions(String options) { this.options = options; } public HiveDbDialect getDialect() { return dialect; } public void setDialect(HiveDbDialect dialect) { this.dialect = dialect; } public void setId(int id) { this.id = id; } public Integer getId() { return id; } public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } public String getUri() { return new JdbcUriFormatter(this).getUri(); } public double getCapacity() { return capacity; } public void setCapacity(double capacity) { this.capacity = capacity; } public void updateId(int id) { this.id = id; } public String getName() { return name; } public void setId(Integer id) { this.id = id; } public void setName(String name) { this.name = name; } public boolean equals(Object obj) { return obj.hashCode() == hashCode(); } public int hashCode() { return HiveUtils.makeHashCode(new Object[] { id,port,name, host,databaseName, username, password, options,status,capacity,dialect }); } public String toString() { return HiveUtils.toDeepFormatedString(this, \"Id\", getId(), \"Name\", getName(), \"Uri\", getUri(), \"Status\", status ); } public int compareTo(Node o) { return getUri().compareTo(o.getUri()); } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta; import org.hivedb.Hive; import org.hivedb.HiveKeyNotFoundException; import org.hivedb.util.HiveUtils; import org.hivedb.util.database.JdbcTypeMapper; import java.util.ArrayList; import java.util.Collection;  public class PartitionDimension implements Comparable<PartitionDimension>, Cloneable, IdAndNameIdentifiable<Integer> { private int id; private String name; private int columnType; private String indexUri; private Collection<Resource> resources;  public PartitionDimension(String name, int columnType, Collection<Resource> resources) { this(Hive.NEW_OBJECT_ID, name, columnType, null, resources); }  public PartitionDimension(String name, int columnType) { this(name, columnType, new ArrayList<Resource>()); }  public PartitionDimension(int id, String name, int columnType, String indexUri, Collection<Resource> resources) { super(); this.id = id; this.name = name; this.columnType = columnType; this.indexUri = indexUri; this.resources = insetResources(resources); } private Collection<Resource> insetResources( Collection<Resource> resources) { for (Resource resource : resources) resource.setPartitionDimension(this); return resources; } public int getColumnType() { return columnType; } public void setColumnType(int columnType) { this.columnType = columnType; } public Integer getId() { return id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getIndexUri() { return indexUri; } public void setIndexUri(String indexUri) { this.indexUri = indexUri; } public Collection<Resource> getResources() { return resources; } public Resource getResource(String resourceName) { for (Resource resource : resources) if (resource.getName().equalsIgnoreCase(resourceName)) return resource; throw new HiveKeyNotFoundException(\"Resource with name \" + resourceName + \" not found.\", resourceName); }  public void updateId(int id) { this.id = id; } public boolean equals(Object obj) { return obj.hashCode() == hashCode(); } public int hashCode() { return HiveUtils.makeHashCode(new Object[] { name, columnType, indexUri, resources }); } public String toString() { String columnType = null; try { columnType = JdbcTypeMapper.jdbcTypeToString(getColumnType()); } catch (Exception e) { columnType = \"Error resolving column type: \" + e.getMessage(); } return HiveUtils.toDeepFormatedString(this, \"Id\", getId(), \"Name\", getName(), \"IndexUri\", getIndexUri(), \"ColumnType\", columnType, \"Resources\", getResources()); } public int compareTo(PartitionDimension o) { return getName().compareTo(o.getName()); } public Object clone() { return new PartitionDimension(name, columnType); } public void setId(Integer id) { this.id = id; } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta; import org.hivedb.Hive; import org.hivedb.HiveRuntimeException; import org.hivedb.meta.persistence.ColumnInfo; import org.hivedb.util.HiveUtils; import java.util.ArrayList; import java.util.Collection;  public class Resource implements Comparable<Resource>, IdAndNameIdentifiable<Integer> { private int id; private PartitionDimension partitionDimension; private Collection<SecondaryIndex> secondaryIndexes = null; private ColumnInfo columnInfo; private ResourceIndex idIndex; private boolean isPartitioningResource;  public Resource(String name, int columnType, boolean isPartitioningResource) { this(Hive.NEW_OBJECT_ID, name, columnType, isPartitioningResource, new ArrayList<SecondaryIndex>()); }  public Resource(String name, int columnType, boolean isPartitioningResource, Collection<SecondaryIndex> secondaryIndexes) { this(Hive.NEW_OBJECT_ID, name, columnType, isPartitioningResource, secondaryIndexes); }  public Resource(int id, String name, int columnType, boolean isPartitioningResource, Collection<SecondaryIndex> secondaryIndexes) { this.id = id; this.columnInfo = new ColumnInfo(name, columnType); this.isPartitioningResource = isPartitioningResource; this.secondaryIndexes = insetThisInstance(secondaryIndexes); this.idIndex = new ResourceIndex(name, columnType); idIndex.setResource(this); } private Collection<SecondaryIndex> insetThisInstance(Collection<SecondaryIndex> secondaryIndexes) { for (SecondaryIndex secondaryindex : secondaryIndexes) secondaryindex.setResource(this); return secondaryIndexes; } public Integer getId() { return id; } public String getName() { return columnInfo.getName(); } public void setName(String name) { this.columnInfo = new ColumnInfo(name, columnInfo.getColumnType()); } public PartitionDimension getPartitionDimension() { return partitionDimension; } public boolean isPartitioningResource() { return isPartitioningResource; } public void setIsPartitioningResource(boolean value) { isPartitioningResource = value; } public void setPartitionDimension(PartitionDimension partitionDimension) { this.partitionDimension = partitionDimension; } public Collection<SecondaryIndex> getSecondaryIndexes() { return secondaryIndexes; } public SecondaryIndex getSecondaryIndex(String secondaryIndexName) { for (SecondaryIndex secondaryIndex : getSecondaryIndexes()) if (secondaryIndex.getName().equalsIgnoreCase(secondaryIndexName)) return secondaryIndex; throw new HiveRuntimeException(String.format(\"Secondary index %s of resource %s of partitition dimension %s not found.\", secondaryIndexName, getName(), getPartitionDimension().getName())); }  public void updateId(int id) { this.id = id; } public boolean equals(Object obj) { return obj.hashCode() == hashCode(); } public int hashCode() { return HiveUtils.makeHashCode(new Object[]{ getName(), HiveUtils.makeHashCode(secondaryIndexes) }); } public String toString() { return HiveUtils.toDeepFormatedString(this, \"Id\", getId(), \"Name\", getName(), \"SecondaryIndexes\", getSecondaryIndexes()); } public int compareTo(Resource o) { return getName().compareTo(o.getName()); } public Object clone() { return new Resource(columnInfo.getName(), columnInfo.getColumnType(), isPartitioningResource, secondaryIndexes); } public ResourceIndex getIdIndex() { return idIndex; } public int getColumnType() { return getIdIndex().getColumnInfo().getColumnType(); } public void setSecondaryIndexes(Collection<SecondaryIndex> secondaryIndexes) { this.secondaryIndexes = secondaryIndexes; } public void setId(Integer field) { this.id = field; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta; import org.hivedb.Hive; public class ResourceIndex extends SecondaryIndex { public ResourceIndex(String name, int type) { this(Hive.NEW_OBJECT_ID,name,type); } public ResourceIndex(int id, String name, int type) { super(id, name, type); } @Override public String getTableName() { return getTableName(this.getName(), \"id\");} }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta; import org.hivedb.Hive; import org.hivedb.meta.persistence.ColumnInfo; import org.hivedb.util.HiveUtils;  public class SecondaryIndex implements Comparable<SecondaryIndex>, IdAndNameIdentifiable<Integer> { private int id; private Resource resource; private ColumnInfo columnInfo;  public SecondaryIndex(String name, int type) { this(Hive.NEW_OBJECT_ID, name, type); }  public SecondaryIndex(int id, String name, int type) { this.id = id; this.columnInfo = new ColumnInfo(name, type); } public Integer getId() { return id; }  public String getName() { return this.getColumnInfo().getName(); } public String getTableName() { return getTableName(this, this.getResource()); } public ColumnInfo getColumnInfo() { return columnInfo; } public void setColumnInfo(ColumnInfo columnInfo) { this.columnInfo = columnInfo; } public Resource getResource() { return resource; } public void setResource(Resource resource) { this.resource = resource; }  public void updateId(int id) { this.id = id; } public boolean equals(Object obj) { return obj.hashCode() == hashCode(); } public int hashCode() { return HiveUtils.makeHashCode(new Object[]{ columnInfo }); } public String toString() { return HiveUtils.toDeepFormatedString(this, \"ColumnInfo\", getColumnInfo()); } public int compareTo(SecondaryIndex o) { return getName().compareTo(o.getName()); } public Object clone() { return new SecondaryIndex(getColumnInfo().getName(), getColumnInfo().getColumnType()); } public static String getTableName(SecondaryIndex secondaryIndex, Resource resource) { return getTableName(secondaryIndex.getColumnInfo().getName(), resource.getName()); } public static String getTableName(String index, String resource) { return resource + \".\" + index; } public void setId(Integer field) { this.id = field; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import org.hivedb.util.database.Statements; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import org.springframework.jdbc.core.PreparedStatementCreatorFactory; import org.springframework.jdbc.core.simple.SimpleJdbcDaoSupport; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.TransactionCallback; import java.util.Collection; import java.util.Map; import java.util.Map.Entry;  public class BatchIndexWriter extends SimpleJdbcDaoSupport { private DbDirectory directory; private IndexSqlFormatter sql; public BatchIndexWriter(DbDirectory directory) { this.directory = directory; this.sql = new IndexSqlFormatter(); this.setDataSource(directory.getDataSource()); } public Integer insertSecondaryIndexKeys(final Map<SecondaryIndex, Collection<Object>> secondaryIndexValueMap, final Object resourceId) { return (Integer) directory.newTransaction().execute(new TransactionCallback() { public Integer doInTransaction(TransactionStatus status) { return Transform.flatMap(new Unary<Map.Entry<SecondaryIndex, Collection<Object>>, Collection<Object>>() { public Collection<Object> f(final Entry<SecondaryIndex, Collection<Object>> secondaryIndexKeysEntry) { return Transform.map(new Unary<Object, Object>() { public Object f(Object secondaryIndexKey) { return directory.insertSecondaryIndexKeyNoTransaction(secondaryIndexKeysEntry.getKey(), secondaryIndexKey, resourceId); } }, secondaryIndexKeysEntry.getValue()); } }, secondaryIndexValueMap.entrySet()).size(); } }); } public Integer deleteSecondaryIndexKeys(final Map<SecondaryIndex, Collection<Object>> secondaryIndexValueMap, final Object resourceId) { return (Integer) directory.newTransaction().execute(new TransactionCallback() { public Integer doInTransaction(TransactionStatus status) { return Transform.flatMap(new Unary<Map.Entry<SecondaryIndex, Collection<Object>>, Collection<Object>>() { public Collection<Object> f(final Entry<SecondaryIndex, Collection<Object>> secondaryIndexKeysEntry) { return Transform.map(new Unary<Object, Object>() { public Object f(Object secondaryIndexKey) { return directory.deleteSecondaryIndexKeyNoTransaction(secondaryIndexKeysEntry.getKey(), secondaryIndexKey, resourceId); } }, secondaryIndexKeysEntry.getValue()); } }, secondaryIndexValueMap.entrySet()).size(); } }); } public Integer deleteAllSecondaryIndexKeysOfResourceId(final Resource resource, Object id) { final Object[] parameters = new Object[]{id}; return (Integer) directory.newTransaction().execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus arg0) { Integer rowsAffected = 0; for (SecondaryIndex secondaryIndex : resource.getSecondaryIndexes()) { PreparedStatementCreatorFactory deleteIndexFactory = Statements.newStmtCreatorFactory(sql.deleteAllSecondaryIndexKeysForResourceId(secondaryIndex), resource.getColumnType()); rowsAffected += getJdbcTemplate().update(deleteIndexFactory.newPreparedStatementCreator(parameters)); } return rowsAffected; } }); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.DirectoryCorruptionException; import org.hivedb.HiveKeyNotFoundException; import org.hivedb.Lockable.Status; import org.hivedb.meta.Node; import org.hivedb.meta.PartitionDimension; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import org.hivedb.meta.persistence.CachingDataSourceProvider; import org.hivedb.util.QuickCache; import org.hivedb.util.database.JdbcTypeMapper; import org.hivedb.util.database.RowMappers; import org.hivedb.util.database.Schemas; import org.hivedb.util.database.Statements; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Delay; import org.hivedb.util.functional.Unary; import org.springframework.dao.EmptyResultDataAccessException; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.simple.SimpleJdbcDaoSupport; import org.springframework.jdbc.core.support.JdbcDaoSupport; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.TransactionCallback; import org.springframework.transaction.support.TransactionTemplate; import javax.sql.DataSource; import java.sql.Types; import java.util.Collection; import java.util.Map; public class DbDirectory extends SimpleJdbcDaoSupport implements NodeResolver, Directory { private static QuickCache cache = new QuickCache(); private PartitionDimension partitionDimension; private IndexSqlFormatter sql = new IndexSqlFormatter(); public DbDirectory(PartitionDimension dimension, DataSource dataSource) { this.partitionDimension = dimension; this.setDataSource(dataSource); } public DbDirectory(PartitionDimension dimension) { this.partitionDimension = dimension; this.setDataSource(CachingDataSourceProvider.getInstance().getDataSource(dimension.getIndexUri())); } public PartitionDimension getPartitionDimension() { return this.partitionDimension; } public Object insertPrimaryIndexKey(final Node node, final Object primaryIndexKey) { return newTransaction().execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus arg0) { int[] types = new int[]{JdbcTypeMapper.primitiveTypeToJdbcType(primaryIndexKey.getClass()), Types.INTEGER}; Object[] parameters = new Object[]{primaryIndexKey, node.getId()}; if (lockPrimaryKeyForInsert(primaryIndexKey, node)) doUpdate(sql.insertPrimaryIndexKey(partitionDimension), types, parameters); return primaryIndexKey; } }); } public Object insertSecondaryIndexKey(final SecondaryIndex secondaryIndex, final Object secondaryIndexKey, final Object resourceId) { return newTransaction().execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus arg0) { return insertSecondaryIndexKeyNoTransaction(secondaryIndex, secondaryIndexKey, resourceId); } }); } Object insertSecondaryIndexKeyNoTransaction(final SecondaryIndex secondaryIndex, final Object secondaryIndexKey, final Object resourceId) { Object[] parameters = new Object[]{secondaryIndexKey, resourceId}; int[] types = new int[]{secondaryIndex.getColumnInfo().getColumnType(), secondaryIndex.getResource().getColumnType()}; if (lockSecondaryIndexKey(secondaryIndex, secondaryIndexKey, resourceId)) doUpdate(sql.insertSecondaryIndexKey(secondaryIndex), types, parameters); return secondaryIndexKey; } public Object updatePrimaryIndexKeyReadOnly(final Object primaryIndexKey, final boolean isReadOnly) { return newTransaction().execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus arg0) { Object[] parameters = new Object[]{isReadOnly, primaryIndexKey}; int[] types = new int[]{Types.BOOLEAN, JdbcTypeMapper.primitiveTypeToJdbcType(primaryIndexKey.getClass())}; lockPrimaryKeyForUpdate(primaryIndexKey); doUpdate(sql.updateReadOnlyOfPrimaryIndexKey(partitionDimension), types, parameters); return primaryIndexKey; } }); } public Object updatePrimaryIndexKeyOfResourceId(final Resource resource, final Object resourceId, final Object newPrimaryIndexKey) { return newTransaction().execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus arg0) { Object[] parameters = new Object[]{newPrimaryIndexKey, resourceId}; int[] types = new int[]{ JdbcTypeMapper.primitiveTypeToJdbcType(newPrimaryIndexKey.getClass()), resource.getColumnType() }; lockResourceId(resource, resourceId); doUpdate(sql.updateResourceId(resource), types, parameters); return resourceId; } }); } public void deletePrimaryIndexKey(final Object primaryIndexKey) { for (Resource resource : getPartitionDimension().getResources()) { if (!resource.isPartitioningResource()) for (Object resourceId : getResourceIdsOfPrimaryIndexKey(resource, primaryIndexKey)) { deleteResourceId(resource, resourceId); } else batch().deleteAllSecondaryIndexKeysOfResourceId(resource, primaryIndexKey); } newTransaction().execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus arg0) { lockPrimaryKeyForUpdate(primaryIndexKey); doUpdate( sql.deletePrimaryIndexKey(partitionDimension), new int[]{JdbcTypeMapper.primitiveTypeToJdbcType(primaryIndexKey.getClass())}, new Object[]{primaryIndexKey}); return primaryIndexKey; } }); } public void deleteSecondaryIndexKey(final SecondaryIndex secondaryIndex, final Object secondaryIndexKey, final Object resourceId) { newTransaction().execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus arg0) { return deleteSecondaryIndexKeyNoTransaction(secondaryIndex, secondaryIndexKey, resourceId); } }); } Object deleteSecondaryIndexKeyNoTransaction(final SecondaryIndex secondaryIndex, final Object secondaryIndexKey, final Object resourceId) { Object[] parameters = new Object[]{secondaryIndexKey, resourceId}; int[] types = new int[]{ secondaryIndex.getColumnInfo().getColumnType(), JdbcTypeMapper.primitiveTypeToJdbcType(resourceId.getClass()) }; lockSecondaryIndexKey(secondaryIndex, secondaryIndexKey, resourceId); doUpdate(sql.deleteSingleSecondaryIndexKey(secondaryIndex), types, parameters); return secondaryIndexKey; } @SuppressWarnings(\"unchecked\") public boolean doesPrimaryIndexKeyExist(Object primaryIndexKey) { Collection count = doRead(sql.checkExistenceOfPrimaryKey(partitionDimension), new Object[]{primaryIndexKey}, RowMappers.newTrueRowMapper()); return count.size() > 0; } public Collection<KeySemaphore> getKeySemamphoresOfPrimaryIndexKey(Object primaryIndexKey) { return doRead(sql.selectKeySemaphoreOfPrimaryIndexKey(partitionDimension), new Object[]{primaryIndexKey}, new KeySemaphoreRowMapper()); } public boolean doesResourceIdExist(Resource resource, Object resourceId) { if (resource.isPartitioningResource()) return doesPrimaryIndexKeyExist(resourceId); Collection<Object> count = doRead( sql.checkExistenceOfResourceIndexSql(resource.getIdIndex()), new Object[]{resourceId}, RowMappers.newTrueRowMapper()); return count.size() > 0; } public boolean doesSecondaryIndexKeyExist(SecondaryIndex secondaryIndex, Object secondaryIndexKey, Object resourceId) { Collection<Object> count = doRead( sql.checkExistenceOfSecondaryIndexSql(secondaryIndex), new Object[]{secondaryIndexKey, resourceId}, RowMappers.newTrueRowMapper()); return count.size() > 0; } public Collection<KeySemaphore> getKeySemaphoresOfSecondaryIndexKey(SecondaryIndex secondaryIndex, Object secondaryIndexKey) { return doRead( sql.selectKeySemaphoresOfSecondaryIndexKey(secondaryIndex), new Object[]{secondaryIndexKey}, new KeySemaphoreRowMapper()); } @SuppressWarnings(\"unchecked\") public Collection<KeySemaphore> getKeySemaphoresOfResourceId(Resource resource, Object resourceId) { return (Collection<KeySemaphore>) (resource.isPartitioningResource() ? getKeySemamphoresOfPrimaryIndexKey(resourceId) : doRead( sql.selectKeySemaphoresOfResourceId(resource), new Object[]{resourceId}, new KeySemaphoreRowMapper())); } public Collection<Object> getPrimaryIndexKeysOfSecondaryIndexKey(SecondaryIndex secondaryIndex, Object secondaryIndexKey) { return doRead( sql.selectPrimaryIndexKeysOfSecondaryIndexKey(secondaryIndex), new Object[]{secondaryIndexKey}, RowMappers.newObjectRowMapper(secondaryIndex.getResource().getPartitionDimension().getColumnType())); } public Collection<Object> getSecondaryIndexKeysOfPrimaryIndexKey(SecondaryIndex secondaryIndex, Object primaryIndexKey) { return doRead( sql.selectSecondaryIndexKeysOfPrimaryKey(secondaryIndex), new Object[]{primaryIndexKey}, RowMappers.newObjectRowMapper(secondaryIndex.getColumnInfo().getColumnType())); } public void deleteResourceId(final Resource resource, final Object id) { "}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hivedb.meta.persistence.DataSourceProvider; import org.hivedb.meta.persistence.PartitionDimensionDao; import javax.sql.DataSource; public class DbDirectoryFactory implements DirectoryProvider { private final static Log log = LogFactory.getLog(DbDirectoryFactory.class); private DataSourceProvider provider; public DbDirectoryFactory(DataSourceProvider provider) { this.provider = provider; } public DbDirectory getDirectory(String hiveConfigurationUri) { DataSource dataSource = provider.getDataSource(hiveConfigurationUri); return new DbDirectory(new PartitionDimensionDao(dataSource).get(), dataSource); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.meta.Node; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import java.util.Collection; import java.util.Map; public interface Directory { boolean doesPrimaryIndexKeyExist(Object primaryIndexKey); Collection<KeySemaphore> getKeySemamphoresOfPrimaryIndexKey(Object primaryIndexKey); void deletePrimaryIndexKey(Object primaryIndexKey); Collection<KeySemaphore> getKeySemaphoresOfResourceId(Resource resource, Object id); void deleteResourceId(Resource resource, Object id); boolean doesSecondaryIndexKeyExist(SecondaryIndex index, Object secondaryIndexKey, Object resourceId); void deleteSecondaryIndexKey(SecondaryIndex index, Object secondaryIndexKey, Object resourceId); boolean doesResourceIdExist(Resource resource, Object resourceId); Collection<KeySemaphore> getKeySemaphoresOfSecondaryIndexKey(SecondaryIndex secondaryIndex, Object secondaryIndexKey); Object insertPrimaryIndexKey(Node node, Object primaryIndexKey); Object insertResourceId(Resource resource, Object id, Object primaryIndexKey); Object insertSecondaryIndexKey(SecondaryIndex secondaryIndex, Object secondaryIndexKey, Object resourceId); Object updatePrimaryIndexKeyOfResourceId(Resource r, Object resourceId, Object newPrimaryIndexKey); Object updatePrimaryIndexKeyReadOnly(Object primaryIndexKey, boolean readOnly); Object getPrimaryIndexKeyOfResourceId(Resource resource, Object resourceId); void deleteSecondaryIndexKeys(Map<SecondaryIndex, Collection<Object>> secondaryIndexValueMap, Object resourceId); Object insertSecondaryIndexKeys(Map<SecondaryIndex, Collection<Object>> secondaryIndexValueMap, Object resourceId); Collection getSecondaryIndexKeysOfResourceId(SecondaryIndex secondaryIndex, Object id); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.HiveLockableException; import java.util.Collection; import java.util.Map; public interface DirectoryFacade { public boolean doesPrimaryIndexKeyExist(Object primaryIndexKey); public Collection<Integer> getNodeIdsOfPrimaryIndexKey(Object primaryIndexKey); public Collection<KeySemaphore> getKeySemamphoresOfPrimaryIndexKey(Object primaryIndexKey); "}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.Lockable; import org.hivedb.meta.Assigner; import org.hivedb.meta.PartitionDimension; public interface DirectoryFacadeProvider { DirectoryFacade getDirectoryFacade(String hiveConfigurationUri, Assigner assigner, Lockable semaphore, PartitionDimension partitionDimension); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; public interface DirectoryProvider { DbDirectory getDirectory(String hiveConfigurationUri); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.HiveKeyNotFoundException; import org.hivedb.HiveLockableException; import org.hivedb.HiveRuntimeException; import org.hivedb.Lockable; import org.hivedb.Lockable.Status; import org.hivedb.meta.Assigner; import org.hivedb.meta.Node; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import org.hivedb.util.Lists; import org.hivedb.util.Preconditions; import org.hivedb.util.functional.*; import java.util.Collection; import java.util.Map; import java.util.Map.Entry; public class DirectoryWrapper implements DirectoryFacade { private Directory directory; private Assigner assigner; private Collection<Node> nodes; private Collection<Resource> resources; private Lockable semaphore; public DirectoryWrapper(Directory directory, Assigner assigner, Collection<Node> nodes, Collection<Resource> resources, Lockable semaphore) { this.assigner = assigner; this.directory = directory; this.nodes = nodes; this.resources = resources; this.semaphore = semaphore; } public void deletePrimaryIndexKey(Object primaryIndexKey) throws HiveLockableException { if (!directory.doesPrimaryIndexKeyExist(primaryIndexKey)) throw new HiveKeyNotFoundException(\"The primary index key \" + primaryIndexKey + \" does not exist\", primaryIndexKey); Preconditions.isWritable(directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey), semaphore); directory.deletePrimaryIndexKey(primaryIndexKey); } public void deleteResourceId(String resource, Object id) throws HiveLockableException { if (getResource(resource).isPartitioningResource()) throw new HiveRuntimeException(String.format(\"Attempt to delete a resource id of resource %s, which is a partitioning dimension. It can only be deleted as a primary index key\", id)); Preconditions.isWritable(directory.getKeySemaphoresOfResourceId(getResource(resource), id), semaphore); directory.deleteResourceId(getResource(resource), id); } private Resource getResource(final String resourceName) { return Filter.grepSingle(new Predicate<Resource>() { public boolean f(Resource item) { return item.getName().equalsIgnoreCase(resourceName); } }, resources); } private SecondaryIndex getSecondaryIndex(String resourceName, String secondaryIndexName) { return getResource(resourceName).getSecondaryIndex(secondaryIndexName); } public void deleteSecondaryIndexKey(String resource, String secondaryIndex, Object secondaryIndexKey, Object resourceId) throws HiveLockableException { SecondaryIndex index = getSecondaryIndex(resource, secondaryIndex); Preconditions.isWritable(directory.getKeySemaphoresOfResourceId(getResource(resource), resourceId), semaphore); if (!directory.doesSecondaryIndexKeyExist(index, secondaryIndexKey, resourceId)) throw new HiveKeyNotFoundException( String.format( \"Secondary index key %s of secondary index %s does not exist\", secondaryIndexKey, index.getName()), secondaryIndexKey); directory.deleteSecondaryIndexKey(index, secondaryIndexKey, resourceId); } public boolean doesPrimaryIndexKeyExist(Object primaryIndexKey) { return directory.doesPrimaryIndexKeyExist(primaryIndexKey); } public boolean doesResourceIdExist(String resource, Object resourceId) { return directory.doesResourceIdExist(getResource(resource), resourceId); } public boolean doesSecondaryIndexKeyExist(String resource, String secondaryIndex, Object secondaryIndexKey, Object resourceId) { return directory.doesSecondaryIndexKeyExist(getSecondaryIndex(resource, secondaryIndex), secondaryIndexKey, resourceId); } public Collection<KeySemaphore> getKeySemamphoresOfPrimaryIndexKey(Object primaryIndexKey) { return directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey); } public Collection<KeySemaphore> getKeySemaphoresOfResourceId(String resource, Object resourceId) { return directory.getKeySemaphoresOfResourceId(getResource(resource), resourceId); } public Collection<KeySemaphore> getKeySemaphoresOfSecondaryIndexKey(String resource, String secondaryIndex, Object secondaryIndexKey) { return directory.getKeySemaphoresOfSecondaryIndexKey(getSecondaryIndex(resource, secondaryIndex), secondaryIndexKey); } public Collection<Integer> getNodeIdsOfPrimaryIndexKey(Object primaryIndexKey) { return Transform.map(semaphoreToId(), directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey)); } public Collection<Integer> getNodeIdsOfResourceId(String resource, Object id) { return Transform.map(semaphoreToId(), directory.getKeySemaphoresOfResourceId(getResource(resource), id)); } public Collection<Integer> getNodeIdsOfSecondaryIndexKey(String resource, String secondaryIndex, Object secondaryIndexKey) { return Transform.map(semaphoreToId(), directory.getKeySemaphoresOfSecondaryIndexKey(getSecondaryIndex(resource, secondaryIndex), secondaryIndexKey)); } public boolean getReadOnlyOfPrimaryIndexKey(Object primaryIndexKey) { Collection<Boolean> locks = Transform.map(semaphoreToReadOnly(), directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey)); Preconditions.isNotEmpty(locks, String.format(\"Unable to find partitionKey %s \", primaryIndexKey)); return Lists.or(locks); } public boolean getReadOnlyOfResourceId(String resource, Object id) { Collection<Boolean> locks = Transform.map(semaphoreToReadOnly(), directory.getKeySemaphoresOfResourceId(getResource(resource), id)); Preconditions.isNotEmpty(locks, String.format(\"Unable to find resource %s with id = %s \", resource, id)); return Lists.or(locks); } public void insertPrimaryIndexKey(Object primaryIndexKey) throws HiveLockableException { Collection<Node> writableNodes = Filter.grep(new Predicate<Node>() { public boolean f(Node item) { return item.getStatus() == Lockable.Status.writable; } }, nodes); Node node = assigner.chooseNode(writableNodes, primaryIndexKey); Preconditions.isWritable(semaphore, node); directory.insertPrimaryIndexKey(node, primaryIndexKey); } public void insertResourceId(String resource, Object id, Object primaryIndexKey) throws HiveLockableException { if (getResource(resource).isPartitioningResource()) { insertPrimaryIndexKey(primaryIndexKey); } else { Collection<KeySemaphore> semaphores = directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey); Preconditions.isWritable(semaphores, semaphore); directory.insertResourceId(getResource(resource), id, primaryIndexKey); } } public void insertSecondaryIndexKey(String resource, String secondaryIndex, Object secondaryIndexKey, Object resourceId) throws HiveLockableException { Collection<KeySemaphore> semaphores = directory.getKeySemaphoresOfResourceId(getResource(resource), resourceId); Preconditions.isWritable(semaphores, semaphore); directory.insertSecondaryIndexKey(getSecondaryIndex(resource, secondaryIndex), secondaryIndexKey, resourceId); } public void updatePrimaryIndexKeyOfResourceId(String resource, Object resourceId, Object newPrimaryIndexKey) throws HiveLockableException { Preconditions.isWritable(directory.getKeySemamphoresOfPrimaryIndexKey(newPrimaryIndexKey), semaphore); final Resource r = getResource(resource); if (r.isPartitioningResource()) throw new HiveRuntimeException(String.format(\"Resource %s is a partitioning dimension, you cannot update its primary index key because it is the resource id\", r.getName())); directory.updatePrimaryIndexKeyOfResourceId(r, resourceId, newPrimaryIndexKey); } public void updatePrimaryIndexKeyReadOnly(Object primaryIndexKey, boolean isReadOnly) throws HiveLockableException { Collection<KeySemaphore> semaphores = directory.getKeySemamphoresOfPrimaryIndexKey(primaryIndexKey); Preconditions.isWritable(getNodesForSemaphores(semaphores), semaphore); directory.updatePrimaryIndexKeyReadOnly(primaryIndexKey, isReadOnly); } private Collection<Node> getNodesForSemaphores(Collection<KeySemaphore> sempahores) { return Transform.map(new Unary<KeySemaphore, Node>() { public Node f(final KeySemaphore semaphore) { return Filter.grepSingle(new Predicate<Node>() { public boolean f(Node node) { return semaphore.getNodeId() == node.getId(); } }, nodes); } }, sempahores); } public static Unary<KeySemaphore, Integer> semaphoreToId() { return new Unary<KeySemaphore, Integer>() { public Integer f(KeySemaphore item) { return item.getNodeId(); } }; } public static Unary<KeySemaphore, Boolean> semaphoreToReadOnly() { return new Unary<KeySemaphore, Boolean>() { public Boolean f(KeySemaphore item) { return item.getStatus().equals(Status.readOnly); } }; } public Object getPrimaryIndexKeyOfResourceId(String name, Object resourceId) { return getResource(name).isPartitioningResource() ? resourceId : directory.getPrimaryIndexKeyOfResourceId(getResource(name), resourceId); }  public Collection getSecondaryIndexKeysWithResourceId(String resource, String secondaryIndex, Object id) { return directory.getSecondaryIndexKeysOfResourceId(getSecondaryIndex(resource, secondaryIndex), id); }  public void deleteSecondaryIndexKeys(final String resource, Map<String, Collection<Object>> secondaryIndexValueMap, Object resourceId) throws HiveLockableException { Preconditions.isWritable(directory.getKeySemaphoresOfResourceId(getResource(resource), resourceId), semaphore); directory.deleteSecondaryIndexKeys(stringMapToIndexValueMap(resource, secondaryIndexValueMap), resourceId); } public void insertSecondaryIndexKeys(String resource, Map<String, Collection<Object>> secondaryIndexValueMap, Object resourceId) throws HiveLockableException { Preconditions.isWritable(directory.getKeySemaphoresOfResourceId(getResource(resource), resourceId), semaphore); directory.insertSecondaryIndexKeys(stringMapToIndexValueMap(resource, secondaryIndexValueMap), resourceId); } private Map<SecondaryIndex, Collection<Object>> stringMapToIndexValueMap(final String resource, final Map<String, Collection<Object>> map) { return Transform.toMap( Transform.map( new Unary<Entry<String, Collection<Object>>, Entry<SecondaryIndex, Collection<Object>>>() { public Entry<SecondaryIndex, Collection<Object>> f(Entry<String, Collection<Object>> item) { return new Pair<SecondaryIndex, Collection<Object>>( getSecondaryIndex(resource, item.getKey()), item.getValue()); } }, map.entrySet())); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hivedb.Lockable; import org.hivedb.meta.Assigner; import org.hivedb.meta.Node; import org.hivedb.meta.PartitionDimension; import org.hivedb.meta.persistence.DataSourceProvider; import org.hivedb.meta.persistence.NodeDao; import javax.sql.DataSource; import java.util.Collection; public class DirectoryWrapperFactory implements DirectoryFacadeProvider { private final static Log log = LogFactory.getLog(DirectoryWrapperFactory.class); private DirectoryProvider directoryProvider; private DataSourceProvider dataSourceProvider; public DirectoryWrapperFactory(DirectoryProvider directoryProvider, DataSourceProvider dataSourceProvider) { this.dataSourceProvider = dataSourceProvider; this.directoryProvider = directoryProvider; } public DirectoryFacade getDirectoryFacade(String hiveConfigurationUri, Assigner assigner, Lockable semaphore, PartitionDimension partitionDimension) { DataSource dataSource = dataSourceProvider.getDataSource(hiveConfigurationUri); Collection<Node> nodes = new NodeDao(dataSource).loadAll(); return new DirectoryWrapper( directoryProvider.getDirectory(hiveConfigurationUri), assigner, nodes, partitionDimension.getResources(), semaphore); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.meta.PartitionDimension; import org.hivedb.meta.Resource; import org.hivedb.meta.ResourceIndex; import org.hivedb.meta.SecondaryIndex; import org.hivedb.util.database.Schemas;  public class IndexSqlFormatter {  public String insertPrimaryIndexKey(PartitionDimension partitionDimension) { return String.format( \"insert into %s (id, node, status) values(?, ?, 0)\", Schemas.getPrimaryIndexTableName(partitionDimension)); } public String selectKeySemaphoreOfPrimaryIndexKey(PartitionDimension partitionDimension) { return String.format(\"select id,node,status from %s where id = ?\", Schemas.getPrimaryIndexTableName(partitionDimension)); } public String selectResourceIdsOfPrimaryIndexKey(ResourceIndex resourceIndex) { return String.format(\"select id from %s where pkey = ?\", Schemas.getResourceIndexTableName(resourceIndex.getResource())); } public String checkExistenceOfPrimaryKey(PartitionDimension partitionDimension) { return String.format(\"select id from %s where id = ?\", Schemas.getPrimaryIndexTableName(partitionDimension)); } public String updateReadOnlyOfPrimaryIndexKey(PartitionDimension partitionDimension) { return String.format(\"update %s set status = ? where id = ?\", Schemas.getPrimaryIndexTableName(partitionDimension)); } public String deletePrimaryIndexKey(PartitionDimension partitionDimension) { return String.format(\"delete from %s where id = ?\", Schemas.getPrimaryIndexTableName(partitionDimension)); }  public String insertSecondaryIndexKey(SecondaryIndex secondaryIndex) { return String.format(\"insert into %s (id, pkey) values(?, ?)\", Schemas.getSecondaryIndexTableName(secondaryIndex)); } public String selectSecondaryIndexKeysOfPrimaryKey(SecondaryIndex secondaryIndex) { if (ResourceIndex.class.isInstance(secondaryIndex)) "}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.Lockable; public interface KeySemaphore extends Lockable { Object getKey(); int getNodeId(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.Lockable; import org.hivedb.util.HiveUtils; import java.io.Serializable; public class KeySemaphoreImpl implements KeySemaphore, Serializable { private Status status; private int nodeId; private Object key; public KeySemaphoreImpl(Object key, int nodeId) { this(key, nodeId, Lockable.Status.writable); } public KeySemaphoreImpl(Object key, int nodeId, Lockable.Status status) { this.nodeId = nodeId; this.status = status; this.key = key; } public Object getKey() { return key; } public int getNodeId() { return nodeId; } public boolean equals(Object obj) { return obj.hashCode() == hashCode(); } public int hashCode() { return HiveUtils.makeHashCode(new Object[]{ nodeId, status }); } public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.hivedb.Lockable; import org.springframework.jdbc.core.simple.ParameterizedRowMapper; import java.sql.ResultSet; import java.sql.SQLException; @SuppressWarnings(\"unchecked\") public class KeySemaphoreRowMapper implements ParameterizedRowMapper { public Object mapRow(ResultSet rs, int arg1) throws SQLException { return new KeySemaphoreImpl(rs.getObject(\"id\"), rs.getInt(\"node\"), resolveStatus(rs)); } private Lockable.Status resolveStatus(ResultSet rs) throws SQLException { return Lockable.Status.getByValue(rs.getInt(\"status\")); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import java.util.Collection; import org.hivedb.meta.*; public interface NodeResolver {  public PartitionDimension getPartitionDimension();  public boolean doesPrimaryIndexKeyExist(Object primaryIndexKey);  public boolean doesResourceIdExist(Resource resource, Object id);  public Collection<KeySemaphore> getKeySemamphoresOfPrimaryIndexKey(Object primaryIndexKey);  public boolean doesSecondaryIndexKeyExist(SecondaryIndex secondaryIndex, Object secondaryIndexKey, Object resourceId);  public Collection<KeySemaphore> getKeySemaphoresOfSecondaryIndexKey(SecondaryIndex secondaryIndex, Object secondaryIndexKey);  @SuppressWarnings(\"unchecked\") public Collection getPrimaryIndexKeysOfSecondaryIndexKey(SecondaryIndex secondaryIndex, Object secondaryIndexKey);  @SuppressWarnings(\"unchecked\") public Collection getResourceIdsOfSecondaryIndexKey(SecondaryIndex secondaryIndex, Object secondaryIndexKey);  @SuppressWarnings(\"unchecked\") public Collection getSecondaryIndexKeysOfPrimaryIndexKey(SecondaryIndex secondaryIndex, Object primaryIndexKey);  @SuppressWarnings(\"unchecked\") public Collection getSecondaryIndexKeysOfResourceId(SecondaryIndex secondaryIndex, Object id);  public Object getPrimaryIndexKeyOfResourceId(Resource resource, Object id); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; public interface ResourceKeySemaphore extends KeySemaphore { Object getPrimaryIndexKey(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class ResourceKeySemaphoreImpl implements ResourceKeySemaphore { private final static Log log = LogFactory.getLog(ResourceKeySemaphoreImpl.class); private Object resourceId; private KeySemaphore keySemaphore; public ResourceKeySemaphoreImpl(KeySemaphore keySemaphore, Object resourceId) { this.keySemaphore = keySemaphore; this.resourceId = resourceId; } public Object getKey() { return resourceId; } public int getNodeId() { return keySemaphore.getNodeId(); } public Status getStatus() { return keySemaphore.getStatus(); } public Object getPrimaryIndexKey() { return keySemaphore.getKey(); } public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof ResourceKeySemaphoreImpl)) return false; ResourceKeySemaphoreImpl that = (ResourceKeySemaphoreImpl) o; if (keySemaphore != null ? !keySemaphore.equals(that.keySemaphore) : that.keySemaphore != null) return false; if (resourceId != null ? !resourceId.equals(that.resourceId) : that.resourceId != null) return false; return true; } public int hashCode() { int result; result = (resourceId != null ? resourceId.hashCode() : 0); result = 31 * result + (keySemaphore != null ? keySemaphore.hashCode() : 0); return result; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.sql.ResultSet; import java.sql.SQLException; public class ResourceKeySemaphoreRowMapper extends KeySemaphoreRowMapper { private final static Log log = LogFactory.getLog(ResourceKeySemaphoreRowMapper.class); @Override public Object mapRow(ResultSet rs, int arg1) throws SQLException { return new ResourceKeySemaphoreImpl((KeySemaphore) super.mapRow(rs, arg1), rs.getObject(\"primaryIndexKey\")); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; public interface SecondaryIndexKeySemaphore extends ResourceKeySemaphore { Object getResourceId(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class SecondaryIndexKeySemaphoreImpl implements SecondaryIndexKeySemaphore{ private final static Log log = LogFactory.getLog(SecondaryIndexKeySemaphoreImpl.class); private ResourceKeySemaphore semaphore; private Object secondaryIndexKey; public SecondaryIndexKeySemaphoreImpl(ResourceKeySemaphore semaphore, Object secondaryIndexKey) { this.semaphore = semaphore; this.secondaryIndexKey = secondaryIndexKey; } public Object getResourceId() { return semaphore.getKey(); } public Object getPrimaryIndexKey() { return semaphore.getPrimaryIndexKey(); } public Object getKey() { return this.secondaryIndexKey; } public int getNodeId() { return semaphore.getNodeId(); } public Status getStatus() { return semaphore.getStatus(); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.directory; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.sql.ResultSet; import java.sql.SQLException; public class SecondaryIndexKeySemaphoreRowMapper extends ResourceKeySemaphoreRowMapper { private final static Log log = LogFactory.getLog(SecondaryIndexKeySemaphoreRowMapper.class); @Override public Object mapRow(ResultSet rs, int arg1) throws SQLException { return new SecondaryIndexKeySemaphoreImpl((ResourceKeySemaphore) super.mapRow(rs, arg1), rs.getObject(\"resourceId\")); } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hivedb.meta.Node; import javax.sql.DataSource; import java.util.HashMap; import java.util.Map; public class CachingDataSourceProvider implements HiveDataSourceProvider { private static final Log log = LogFactory.getLog(CachingDataSourceProvider.class); private static CachingDataSourceProvider INSTANCE = new CachingDataSourceProvider(); private Map<String, DataSource> cache = new HashMap<String, DataSource>(); private HiveBasicDataSourceProvider delegate; private CachingDataSourceProvider() { this.delegate = new HiveBasicDataSourceProvider(); } public DataSource getDataSource(Node node) { return getDataSource(node.getUri()); }  public void close() { delegate.close(); } public DataSource getDataSource(String uri) { DataSource ds = cache.get(uri); if (ds == null) { ds = delegate.getDataSource(uri); cache.put(uri, ds); } return ds; } public static CachingDataSourceProvider getInstance() { return INSTANCE; } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import org.hivedb.util.HiveUtils; import org.hivedb.util.database.JdbcTypeMapper;  public class ColumnInfo { private String name; private int columnType; public ColumnInfo(String name, int columnType) { super(); this.name = name; this.columnType = columnType; } public int getColumnType() { return columnType; } public String getName() { return name; } public int hashCode() { return HiveUtils.makeHashCode(new Object[] { name, columnType }); } public String toString() { String columnType = null; try { columnType = JdbcTypeMapper.jdbcTypeToString(getColumnType()); } catch (Exception e) { columnType = \"Error resolving column type: \" + e.getMessage(); } return HiveUtils.toDeepFormatedString(this, \"Name\", getName(), \"ColumnType\", columnType); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.persistence; import javax.sql.DataSource; public interface DataSourceProvider { public DataSource getDataSource(String uri); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.persistence; import com.mchange.v2.c3p0.ComboPooledDataSource; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hivedb.util.HiveUtils; import javax.sql.DataSource; import java.io.PrintWriter; import java.sql.Connection; import java.sql.SQLException; public class HiveBasicDataSource implements DataSource, Cloneable { private Log log = LogFactory.getLog(HiveBasicDataSource.class); private ComboPooledDataSource comboPooledDataSource; public HiveBasicDataSource() { comboPooledDataSource = new ComboPooledDataSource(); } public void close() { comboPooledDataSource.close(); } public HiveBasicDataSource(String hiveUri) { this(); comboPooledDataSource.setJdbcUrl(hiveUri); log.debug(String.format(\"HiveBasicDataSource created: %s\", comboPooledDataSource.toString())); } public String getUrl() { "}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hivedb.HiveRuntimeException; import org.hivedb.meta.Node; import org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy; import javax.sql.DataSource; import java.util.Collection; import java.util.HashSet; public class HiveBasicDataSourceProvider implements HiveDataSourceProvider { private Log log = LogFactory.getLog(HiveBasicDataSource.class); private Collection<HiveBasicDataSource> dataSourcesToClose; public HiveBasicDataSourceProvider() { dataSourcesToClose = new HashSet<HiveBasicDataSource>(); } public DataSource getDataSource(Node node) { return getDataSource(node.getUri()); }  public void close() { HiveRuntimeException exceptionWhileClosing = null; for (HiveBasicDataSource dataSource : dataSourcesToClose) { try { dataSource.close(); } catch (Exception e) { exceptionWhileClosing = new HiveRuntimeException(\"Error closing datasources. Possibly more than one cause.\", e); } } if (exceptionWhileClosing != null) { throw exceptionWhileClosing; } } public DataSource getDataSource(String uri) { HiveBasicDataSource ds = new HiveBasicDataSource(uri); LazyConnectionDataSourceProxy dataSourceProxy = new LazyConnectionDataSourceProxy(ds); dataSourcesToClose.add(ds); return dataSourceProxy; } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import org.hivedb.meta.Node; import javax.sql.DataSource;  public interface HiveDataSourceProvider extends DataSourceProvider { public DataSource getDataSource(Node node);  public void close(); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import org.hivedb.HiveRuntimeException; import org.hivedb.Lockable.Status; import org.hivedb.meta.HiveSemaphore; import org.hivedb.meta.HiveSemaphoreImpl; import org.springframework.dao.EmptyResultDataAccessException; import org.springframework.jdbc.BadSqlGrammarException; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.support.JdbcDaoSupport; import org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy; import javax.sql.DataSource; import java.sql.ResultSet; import java.sql.SQLException;  public class HiveSemaphoreDao extends JdbcDaoSupport { public HiveSemaphoreDao(DataSource ds) { this.setDataSource(ds); } "}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import org.hivedb.Schema; import org.hivedb.meta.PartitionDimension; import org.hivedb.util.database.Schemas; import java.util.Collection;  public class IndexSchema extends Schema { private PartitionDimension partitionDimension;  public IndexSchema(PartitionDimension partitionDimension) { super(\"Hive index schema\"); this.partitionDimension = partitionDimension; } public PartitionDimension getPartitionDimension() { return partitionDimension; } @Override public Collection<TableInfo> getTables(String uri) { return Schemas.getTables(partitionDimension); } @Override public boolean equals(Object obj) { if (obj instanceof IndexSchema) { return super.equals(obj) && partitionDimension.equals(((IndexSchema) obj).getPartitionDimension()); } return false; } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Types; import java.util.ArrayList; import java.util.List; import javax.sql.DataSource; import org.hivedb.HiveRuntimeException; import org.hivedb.Lockable.Status; import org.hivedb.meta.Node; import org.hivedb.util.Lists; import org.hivedb.util.Strings; import org.hivedb.util.database.DialectTools; import org.hivedb.util.database.HiveDbDialect; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.PreparedStatementCreatorFactory; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.support.JdbcDaoSupport; import org.springframework.jdbc.support.GeneratedKeyHolder; import org.springframework.jdbc.support.KeyHolder;  public class NodeDao extends JdbcDaoSupport { public NodeDao(DataSource ds) { this.setDataSource(ds); } public Node create(Node newObject) { KeyHolder generatedKey = new GeneratedKeyHolder(); JdbcTemplate j = getJdbcTemplate(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory(insertSql(),getTypes()); creatorFactory.setReturnGeneratedKeys(true); int rows = j.update(creatorFactory.newPreparedStatementCreator(getParameters(newObject)), generatedKey); if (rows != 1) throw new HiveRuntimeException(\"Unable to create Resource: \" + getParameters(newObject)); if (generatedKey.getKeyList().size() == 0) throw new HiveRuntimeException(\"Unable to retrieve generated primary key\"); newObject.updateId(generatedKey.getKey().intValue()); return newObject; } public List<Node> loadAll() { JdbcTemplate t = getJdbcTemplate(); ArrayList<Node> results = new ArrayList<Node>(); for (Object result : t.query(\"SELECT * FROM node_metadata\", new NodeRowMapper())) { results.add((Node)result); } return results; } public Node findById(int id) { JdbcTemplate t = getJdbcTemplate(); return (Node) t.queryForObject(\"SELECT * FROM node_metadata WHERE id = ?\", new Object[] { id }, new NodeRowMapper()); } public Node update(Node node) { JdbcTemplate j = getJdbcTemplate(); Object[] params = new Object[getFields().length+1]; int[] types = new int[params.length]; Lists.copyInto(getParameters(node), params); Lists.copyInto(getTypes(), types); params[params.length-1] = node.getId(); types[types.length-1] = Types.INTEGER; PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory(updateSql(),types); int rows = j.update(creatorFactory.newPreparedStatementCreator(params)); if (rows != 1) throw new HiveRuntimeException(\"Unable to update node with id: \" + node.getId()); return node; } public Node delete(Node node) { Object[] parameters = new Object[] { node.getId()}; JdbcTemplate j = getJdbcTemplate(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( \"DELETE from node_metadata where id=?\", new int[] { Types.INTEGER }); int rows = j.update(creatorFactory .newPreparedStatementCreator(parameters)); if (rows != 1) throw new HiveRuntimeException(\"Unable to delete node for id: \" + node.getId()); return node; } protected class NodeRowMapper implements RowMapper { public Object mapRow(ResultSet rs, int rowNumber) throws SQLException { Node node = new Node( rs.getInt(\"id\"), rs.getString(\"name\"), rs.getString(\"database_name\"), rs.getString(\"host\"), rs.getString(\"dialect\") == null ? HiveDbDialect.MySql : DialectTools.stringToDialect(rs.getString(\"dialect\")) ); node.setStatus(Status.getByValue(rs.getInt(\"status\"))); node.setUsername(rs.getString(\"username\")); node.setPassword(rs.getString(\"password\")); node.setPort(rs.getInt(\"port\")); node.setCapacity(rs.getInt(\"capacity\")); node.setOptions(rs.getString(\"options\")); return node; } } private String insertSql(){ String[] questionMarks = new String[getFields().length]; for(int i=0; i< questionMarks.length; i++) questionMarks[i] = \"?\"; return String.format(\"INSERT INTO node_metadata (%s) VALUES (%s)\", Strings.join(\",\", getFields()), Strings.join(\",\", questionMarks)); } private String updateSql() { String[] fields = Transform.map(new Unary<String, String>(){ public String f(String item) { return String.format(\"%s=?\", item); }}, Lists.newList(getFields())).toArray(new String[]{}); return String.format(\"UPDATE node_metadata set %s where id=?\", Strings.join(\",\", fields)); } "}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import org.hivedb.HiveRuntimeException; import org.hivedb.meta.PartitionDimension; import org.hivedb.meta.Resource; import org.hivedb.util.database.JdbcTypeMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.PreparedStatementCreatorFactory; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.support.JdbcDaoSupport; import org.springframework.jdbc.support.GeneratedKeyHolder; import org.springframework.jdbc.support.KeyHolder; import javax.sql.DataSource; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Types; import java.util.ArrayList; import java.util.List;  public class PartitionDimensionDao extends JdbcDaoSupport { public PartitionDimensionDao(DataSource ds) { this.setDataSource(ds); } public Integer create(PartitionDimension newObject) { Object[] parameters; parameters = new Object[]{newObject.getName(), newObject.getIndexUri(), JdbcTypeMapper.jdbcTypeToString(newObject.getColumnType())}; KeyHolder generatedKey = new GeneratedKeyHolder(); JdbcTemplate j = getJdbcTemplate(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( \"INSERT INTO partition_dimension_metadata (name,index_uri,db_type) VALUES (?,?,?)\", new int[]{Types.VARCHAR, Types.VARCHAR, Types.VARCHAR}); creatorFactory.setReturnGeneratedKeys(true); int rows = j.update(creatorFactory .newPreparedStatementCreator(parameters), generatedKey); if (rows != 1) throw new HiveRuntimeException(\"Unable to create Partition Dimension: \" + parameters); if (generatedKey.getKeyList().size() == 0) throw new HiveRuntimeException(\"Unable to retrieve generated primary key\"); newObject.updateId(generatedKey.getKey().intValue()); "}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Types; import java.util.ArrayList; import java.util.List; import javax.sql.DataSource; import org.hivedb.HiveRuntimeException; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import org.hivedb.util.database.JdbcTypeMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.PreparedStatementCreatorFactory; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.support.JdbcDaoSupport; import org.springframework.jdbc.support.GeneratedKeyHolder; import org.springframework.jdbc.support.KeyHolder;  public class ResourceDao extends JdbcDaoSupport { private DataSource ds; public ResourceDao(DataSource ds) { this.ds = ds; this.setDataSource(ds); } public List<Resource> loadAll() { JdbcTemplate t = getJdbcTemplate(); ArrayList<Resource> results = new ArrayList<Resource>(); for (Object si : t.query(\"SELECT * FROM resource_metadata\", new ResourceRowMapper())) { results.add((Resource)si); } return results; } public Integer create(Resource newResource) { int columnType = newResource.getIdIndex().getColumnInfo().getColumnType(); Object[] parameters = new Object[] { newResource.getName(), newResource.getPartitionDimension().getId(), JdbcTypeMapper.jdbcTypeToString(columnType),newResource.isPartitioningResource()}; KeyHolder generatedKey = new GeneratedKeyHolder(); JdbcTemplate j = getJdbcTemplate(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( \"INSERT INTO resource_metadata (name,dimension_id,db_type,is_partitioning_resource) VALUES (?,?,?,?)\", new int[] {Types.VARCHAR,Types.INTEGER,Types.VARCHAR,Types.BIT}); creatorFactory.setReturnGeneratedKeys(true); int rows = j.update(creatorFactory .newPreparedStatementCreator(parameters), generatedKey); if (rows != 1) throw new HiveRuntimeException(\"Unable to create Resource: \" + parameters); if (generatedKey.getKeyList().size() == 0) throw new HiveRuntimeException(\"Unable to retrieve generated primary key\"); newResource.updateId(generatedKey.getKey().intValue()); "}
{"name": "britt/hivedb", "content": " package org.hivedb.meta.persistence; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Types; import java.util.ArrayList; import java.util.List; import javax.sql.DataSource; import org.hivedb.HiveRuntimeException; import org.hivedb.meta.SecondaryIndex; import org.hivedb.util.database.JdbcTypeMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.PreparedStatementCreatorFactory; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.support.JdbcDaoSupport; import org.springframework.jdbc.support.GeneratedKeyHolder; import org.springframework.jdbc.support.KeyHolder;  public class SecondaryIndexDao extends JdbcDaoSupport { public SecondaryIndexDao(DataSource ds) { this.setDataSource(ds); } public Integer create(SecondaryIndex newObject) { Object[] parameters; parameters = new Object[] { newObject.getResource().getId(), newObject.getColumnInfo().getName(), JdbcTypeMapper.jdbcTypeToString(newObject.getColumnInfo() .getColumnType()) }; KeyHolder generatedKey = new GeneratedKeyHolder(); JdbcTemplate j = getJdbcTemplate(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( \"INSERT INTO secondary_index_metadata (resource_id,column_name,db_type) VALUES (?,?,?)\", new int[] { Types.INTEGER, Types.VARCHAR, Types.VARCHAR }); creatorFactory.setReturnGeneratedKeys(true); int rows = j.update(creatorFactory .newPreparedStatementCreator(parameters), generatedKey); if (rows != 1) throw new HiveRuntimeException(\"Unable to create secondary index: \" + parameters); if (generatedKey.getKeyList().size() == 0) throw new HiveRuntimeException(\"Unable to retrieve generated primary key\"); newObject.updateId(generatedKey.getKey().intValue()); return new Integer(newObject.getId()); } public List<SecondaryIndex> loadAll() { JdbcTemplate t = getJdbcTemplate(); ArrayList<SecondaryIndex> results = new ArrayList<SecondaryIndex>(); for (Object si : t.query(\"SELECT * FROM secondary_index_metadata\", new SecondaryIndexRowMapper())) { results.add((SecondaryIndex) si); } return results; } class SecondaryIndexRowMapper implements RowMapper { public Object mapRow(ResultSet rs, int index) throws SQLException{ int jdbcType = Types.OTHER; jdbcType = JdbcTypeMapper.parseJdbcType(rs.getString(\"db_type\")); SecondaryIndex si = new SecondaryIndex(rs.getInt(\"id\"), rs.getString(\"column_name\"), jdbcType); return si; } } public void update(SecondaryIndex secondaryIndex) { Object[] parameters; parameters = new Object[] { secondaryIndex.getResource().getId(), secondaryIndex.getColumnInfo().getName(), JdbcTypeMapper.jdbcTypeToString(secondaryIndex.getColumnInfo().getColumnType()), secondaryIndex.getId()}; KeyHolder generatedKey = new GeneratedKeyHolder(); JdbcTemplate j = getJdbcTemplate(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( \"UPDATE secondary_index_metadata SET resource_id=?,column_name=?,db_type=? WHERE id=?\", new int[] { Types.INTEGER, Types.VARCHAR, Types.VARCHAR, Types.INTEGER }); creatorFactory.setReturnGeneratedKeys(true); int rows = j.update(creatorFactory .newPreparedStatementCreator(parameters), generatedKey); if (rows != 1) throw new HiveRuntimeException(\"Unable to update secondary index: \" + secondaryIndex.getId()); } public void delete(SecondaryIndex secondaryIndex) { Object[] parameters; parameters = new Object[] { secondaryIndex.getId()}; JdbcTemplate j = getJdbcTemplate(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( \"DELETE FROM secondary_index_metadata WHERE id=?\", new int[] { Types.INTEGER }); int rows = j.update(creatorFactory .newPreparedStatementCreator(parameters)); if (rows != 1) throw new HiveRuntimeException(\"Unable to delete secondary index for id: \" + secondaryIndex.getId()); } public List<SecondaryIndex> findByResource(int id) { JdbcTemplate t = getJdbcTemplate(); ArrayList<SecondaryIndex> results = new ArrayList<SecondaryIndex>(); for (Object si : t.query(\"SELECT * FROM secondary_index_metadata WHERE resource_id = ?\", new Object[] { id }, new SecondaryIndexRowMapper())) { results.add((SecondaryIndex) si); } return results; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.meta.persistence; import org.hivedb.util.HiveUtils; public class TableInfo { private String name; private String createStatement; public TableInfo(String name, String stmt){ setName(name); setCreateStatement(stmt); } public String getCreateStatement() { return createStatement; } public String getDeleteAllStatement() { return String.format(\"delete from %s\", name); } public void setCreateStatement(String createStatement) { this.createStatement = createStatement; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int hashCode() { return HiveUtils.makeHashCode( new Object[] {getName(), getCreateStatement()} ); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import org.hibernate.shards.strategy.access.ShardAccessStrategy; import org.hivedb.Hive; import org.hivedb.configuration.EntityConfig; import org.hivedb.hibernate.*; import java.io.Serializable; import java.util.Collection; import java.util.Collections; import java.util.List; public class BaseClassDaoService<T,ID extends Serializable> implements ClassDaoService<T,ID> { protected EntityConfig config; protected DataAccessObject<Object, Serializable> dao; @SuppressWarnings(\"unchecked\") public static BaseClassDaoService create(Class<?> clazz, Hive hive, ShardAccessStrategy strategy) { ConfigurationReader reader = new ConfigurationReader(clazz); List classes = Collections.singletonList(clazz); HiveSessionFactory factory = new HiveSessionFactoryBuilderImpl(hive.getUri(), classes, strategy); BaseDataAccessObject dao = new BaseDataAccessObject(reader.getEntityConfig(clazz.getName()), hive, factory); return new BaseClassDaoService(reader.getEntityConfig(clazz.getName()), dao); } public BaseClassDaoService(EntityConfig config, DataAccessObject<Object, Serializable> dao) { this.config = config; this.dao = dao; } @SuppressWarnings(\"unchecked\") public ID delete(ID id) { return (ID) dao.delete(id); } public boolean exists(ID id) { return dao.exists(id); } @SuppressWarnings(\"unchecked\") public T get(ID id) { return (T) dao.get(id); } @SuppressWarnings(\"unchecked\") public Collection<T> getByReference(String property, Object referenceKey) { return (Collection<T>) dao.findByProperty(property, referenceKey); } @SuppressWarnings(\"unchecked\") public Collection<T> getByReferenceRange(String property, Object start, Object end) { return (Collection<T>) dao.findByPropertyRange(property, start, end); } public String getPersistedClass() { return config.getRepresentedInterface().getName(); } @SuppressWarnings(\"unchecked\") public T save(T obj) { return (T) dao.save(obj); } @SuppressWarnings(\"unchecked\") public Collection<T> saveAll(Collection<T> instances) { return (Collection<T>) dao.saveAll((Collection<Object>)instances); } "}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import java.io.Serializable; import java.util.Collection; "}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import java.util.Collection; import javax.jws.WebMethod; import javax.jws.WebResult; import javax.jws.WebService; @WebService public interface DataGenerationService { @WebMethod @WebResult public Collection<String> listClasses(); @WebMethod @WebResult public Collection<Long> generate(String clazz, Integer partitionKeyCount, Integer instanceCount); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hibernate.shards.strategy.access.SequentialShardAccessStrategy; import org.hibernate.shards.util.Lists; import org.hibernate.shards.util.Maps; import org.hivedb.Hive; import org.hivedb.annotations.Resource; import org.hivedb.configuration.EntityConfig; import org.hivedb.hibernate.*; import org.hivedb.util.PrimitiveUtils; import org.hivedb.util.classgen.GenerateInstance; import org.hivedb.util.classgen.GeneratePrimitiveValue; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Generator; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import javax.jws.WebService; import java.io.Serializable; import java.util.Collection; import java.util.List; import java.util.Map; @WebService(endpointInterface = \"org.hivedb.services.DataGenerationService\") public class DataGenerationServiceImpl implements DataGenerationService { private ConfigurationReader config; private Map<Class, DataAccessObject<Object, Serializable>> daos = Maps.newHashMap(); private Log log = LogFactory.getLog(DataGenerationServiceImpl.class); public DataGenerationServiceImpl(Collection<Class<?>> classes, Hive hive) { config = new ConfigurationReader(classes); List<Class<?>> hiveSessionClasses = Lists.newArrayList(); hiveSessionClasses.addAll(new EntityResolver(config.getHiveConfiguration()).getEntityClasses()); HiveSessionFactory factory = new HiveSessionFactoryBuilderImpl(config.getHiveConfiguration(), classes, hive, new SequentialShardAccessStrategy()); for (Class clazz : hiveSessionClasses) { if (clazz.getAnnotation(Resource.class) != null) { daos.put(clazz, new BaseDataAccessObject(config.getEntityConfig(clazz.getName()), hive, factory)); } } }  public Collection<String> listClasses() { return Transform.map(new Unary<EntityConfig, String>() { public String f(EntityConfig item) { return item.getRepresentedInterface().getName(); } }, config.getConfigurations()); }  public Collection<Long> generate(String clazz, Integer partitionKeyCount, Integer instanceCount) { Collection<Long> ids = Lists.newArrayList(); try { EntityConfig entityConfig = config.getEntityConfig(clazz); Generator<Object> pKeyGenerator; if (PrimitiveUtils.isPrimitiveClass(entityConfig.getPrimaryKeyClass())) pKeyGenerator = new GeneratePrimitiveValue<Object>((Class<Object>) entityConfig.getPrimaryKeyClass()); else pKeyGenerator = new GenerateInstance<Object>((Class<Object>) entityConfig.getPrimaryKeyClass()); for (int i = 0; i < partitionKeyCount; i++) { Object pkey = pKeyGenerator.generate(); DataAccessObject<Object, Serializable> dao = daos.get(entityConfig.getRepresentedInterface()); GenerateInstance<Object> instanceGenerator = new GenerateInstance<Object>((Class<Object>) entityConfig.getRepresentedInterface()); for (int j = 0; j < instanceCount; j++) { Object instance = instanceGenerator.generate(); ReflectionTools.invokeSetter(instance, entityConfig.getPrimaryIndexKeyPropertyName(), pkey); dao.save(instance); Serializable id = entityConfig.getId(instance); if (Number.class.isAssignableFrom(id.getClass())) { ids.add(Long.parseLong(id.toString())); } else throw new UnsupportedOperationException(\"This implementation can only generate classes with numeric ids.\"); } } } catch (RuntimeException e) { log.fatal(e); log.fatal(e.getMessage()); throw e; } return ids; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import java.util.Collection; import javax.jws.WebMethod; import javax.jws.WebService; "}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.HiveRuntimeException; import org.hivedb.Schema; import org.hivedb.meta.Node; import org.hivedb.util.database.DialectTools; import org.hivedb.util.database.HiveDbDialect; import org.hivedb.util.database.Schemas; import org.hivedb.util.functional.Maps; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import javax.jws.WebService; import java.util.Arrays; import java.util.Collection; import java.util.Map; import java.util.NoSuchElementException; @WebService(endpointInterface = \"org.hivedb.services.InstallService\") public class InstallServiceImpl implements InstallService { private Map<String, Schema> schemata = Maps.newHashMap(); private Hive hive; public InstallServiceImpl(Collection<Schema> schemata, Hive hive) { this.hive = hive; for (Schema s : schemata) this.schemata.put(s.getName(), s); } public void addSchema(Schema schema) { schemata.put(schema.getName(), schema); } public Collection<Schema> getSchemata() { return schemata.values(); } public Boolean install(String schemaName, String nodeName, String dbName, String host, String dialect, String user, String password) { return install(schemaName, getOrAddNode(nodeName, dbName, host, dialect, user, password).getName()); } private Node getOrAddNode(String nodeName, String dbName, String host, String dialect, String user, String password) { Node node; try { node = hive.getNode(nodeName); } catch (NoSuchElementException e) { node = new Node(nodeName, dbName, host, DialectTools.stringToDialect(dialect)); node.setUsername(user); node.setPassword(password); try { hive.addNode(node); } catch (HiveLockableException e1) { throw new HiveRuntimeException(\"Hive was locked read-only.\", e1); } } return node; } public Collection<String> listDialects() { return Transform.map(new Unary<HiveDbDialect, String>() { public String f(HiveDbDialect item) { return DialectTools.dialectToString(item); } }, Arrays.asList(HiveDbDialect.values())); } public Collection<String> listSchemas() { return schemata.keySet(); } public Boolean install(String schemaName, String nodeName) { Schema s = schemata.get(schemaName); String uri = hive.getNode(nodeName).getUri(); Schemas.install(s, uri); return true; } public Boolean installAll(String nodeName) { Boolean installed = true; for (String s : schemata.keySet()) installed &= install(s, nodeName); return installed; } public Boolean installAll(String nodeName, String dbName, String host, String dialect, String user, String password) { return installAll(getOrAddNode(nodeName, dbName, host, dialect, user, password).getName()); } public Boolean addNode(String nodeName, String dbName, String host, String dialect, String user, String password) { try { Node node = new Node(nodeName, dbName, host, DialectTools.stringToDialect(dialect)); node.setUsername(user); node.setPassword(password); hive.addNode(node); return true; } catch (HiveLockableException e) { throw new HiveRuntimeException(\"hive was locked read-only\", e); } } public Collection<String> listNodes() { return Transform.map(new Unary<Node, String>() { public String f(Node item) { return item.getName(); } }, hive.getNodes()); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; public interface Service<T,S extends ServiceResponse<T,C>,C extends ServiceContainer<T>, COL extends Iterable<T>, F> { }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; public interface ServiceContainer<T> { T getInstance(); int getVersion(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import java.io.Serializable; public class ServiceContainerImpl<T> implements ServiceContainer<T>, Serializable { private static final long serialVersionUID = 1L; private T instance; private int version; public ServiceContainerImpl() {} public ServiceContainerImpl(T instance, int version) { this.instance = instance; this.version = version; } public T getInstance() { return instance; } public void setInstance(T instance) { this.instance = instance; } public int getVersion() { return version; } public void setVersion(int version) { this.version = version; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import java.util.Collection; public interface ServiceResponse<T,C extends ServiceContainer<T>> { Collection<C> getContainers(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.services; import java.io.Serializable; import java.util.Arrays; import java.util.Collection; import org.hivedb.configuration.EntityConfig; import org.hivedb.util.Lists; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; public class ServiceResponseImpl<T> implements ServiceResponse<T,ServiceContainer<T>>, Serializable { private static final long serialVersionUID = 1L; private Collection<ServiceContainer<T>> containers = Lists.newArrayList(); public ServiceResponseImpl() {} public ServiceResponseImpl(final EntityConfig config, Collection<T> instances) { this.containers = Transform.map(new Unary<T, ServiceContainer<T>>(){ public ServiceContainer<T> f(T item) { return new ServiceContainerImpl<T>(item, config.getVersion(item)); }}, instances); } public ServiceResponseImpl(final EntityConfig config, T... instances) { this(config, Arrays.asList(instances)); } public ServiceResponseImpl(Collection<ServiceContainer<T>> containers) { this.containers = containers; } public Collection<ServiceContainer<T>> getContainers() { return containers; } public void setContainers(Collection<ServiceContainer<T>> containers) { this.containers = containers; } public Collection<T> getInstances() { return Transform.map(new Unary<ServiceContainer<T>, T>(){ public T f(ServiceContainer<T> item) { return item.getInstance(); }}, containers); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.util.functional.Amass; import org.hivedb.util.functional.GetFunction; import org.hivedb.util.functional.SetFunction; public abstract class AccessorFunction<F> implements GetFunction<F>, SetFunction<F> { public int hashCode() { return Amass.makeHashCode(new Object[] { get().hashCode(), getFieldClass().hashCode() }); } public boolean equals(Object obj) { return obj.hashCode() == this.hashCode(); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.junit.Assert;import static org.junit.Assert.fail;import static org.junit.Assert.assertEquals; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Toss; import org.hivedb.util.functional.Transform; import java.util.Stack; public class AssertUtils { public static abstract class UndoableToss extends ThrowableUndoable implements Toss { }  public static void assertThrows(Toss toss) { try { toss.f(); } catch (Exception e) { return; } fail(\"Expected exception but none occured\"); }  public static void assertThrows(Toss toss, Class<? extends Exception> exceptionType) { try { toss.f(); } catch (Exception e) { if (e.getClass().equals(exceptionType)) "}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.Hive; import org.hivedb.HiveLockableException; import org.hivedb.Schema; import org.hivedb.management.HiveConfigurationSchemaInstaller; import org.hivedb.meta.Node; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import org.hivedb.meta.persistence.HiveDataSourceProvider; import org.hivedb.util.database.DialectTools; import org.hivedb.util.database.HiveDbDialect; import org.hivedb.util.database.JdbcTypeMapper; import org.hivedb.util.database.Schemas; import java.lang.reflect.InvocationTargetException; import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.Map;  public class BourneHive { private HiveDbDialect dialect; private Hive hive; public Hive getHive() { return hive; } public BourneHive(Map<String, String> dimension, HiveDataSourceProvider dataSourceProvider) { this(dimension, dataSourceProvider, HiveDbDialect.H2); } public BourneHive(Map<String, String> dimension, HiveDataSourceProvider dataSourceProvider, HiveDbDialect dialect) { this.dialect = dialect; new HiveConfigurationSchemaInstaller(DialectTools.getHiveTestUri(dialect)).run(); String name = dimension.get(\"name\"); int type = JdbcTypeMapper.parseJdbcType(stringToVarchar(dimension.get(\"type\"))); hive = Hive.create(DialectTools.getHiveTestUri(dialect), name, type, dataSourceProvider, null); } @SuppressWarnings(\"unchecked\") public BourneHive addNodes(List<Map<String, ?>> nodes) { for (Map<String, ?> node : nodes) { String name = (String) node.get(\"name\"); try { hive.addNode(getNode(name)); } catch (HiveLockableException ex) { throw new RuntimeException(ex); } installSchemas(hive.getNode(name), (List<Map<String, String>>) node.get(\"schemas\")); } return this; } private void installSchemas(Node node, List<Map<String, String>> schemas) { if (schemas != null) { for (Map<String, String> schema : schemas) { installSchema(node, schema); } } } @SuppressWarnings(\"unchecked\") public BourneHive addResources(List<Map<String, ?>> resources) { if (resources != null) { for (Map<String, ?> resource : resources) { String name = (String) resource.get(\"name\"); int type = JdbcTypeMapper.parseJdbcType(stringToVarchar((String) resource.get(\"type\"))); Collection<SecondaryIndex> secondaryIndexes = getSecondaryIndexes((List<Map<String, String>>) resource.get(\"indexes\")); boolean isPartitioningResource = hive.getPartitionDimension().getName().equals(name) && hive.getPartitionDimension().getColumnType() == type; try { hive.addResource(new Resource(name, type, isPartitioningResource, secondaryIndexes)); } catch (HiveLockableException ex) { throw new RuntimeException(ex); } } } return this; } private Collection<SecondaryIndex> getSecondaryIndexes(List<Map<String, String>> indexes) { Collection<SecondaryIndex> secondaryIndexes = new ArrayList<SecondaryIndex>(); if (indexes != null) { for (Map<String, String> index : indexes) { String name = index.get(\"name\"); String type = index.get(\"type\"); SecondaryIndex secondaryIndex = new SecondaryIndex(name, JdbcTypeMapper.parseJdbcType(stringToVarchar(type))); secondaryIndexes.add(secondaryIndex); } } return secondaryIndexes; } @SuppressWarnings(\"unchecked\") private void installSchema(Node node, Map<String, String> schema) { Class<? extends Schema> schemaClass = null; try { schemaClass = (Class<? extends Schema>) Class.forName(schema.get(\"class\")); } catch (ClassNotFoundException ex) { throw new RuntimeException(ex); } Schemas.install(getSchemaInstance(schemaClass), node.getUri()); } private Schema getSchemaInstance(Class<? extends Schema> schemaClass) { try { return (Schema) schemaClass.getMethod(\"getInstance\", new Class[]{}).invoke(null, new Object[]{}); } catch (IllegalAccessException ex) { throw new RuntimeException(ex); } catch (InvocationTargetException ex) { throw new RuntimeException(ex); } catch (NoSuchMethodException ex) { throw new RuntimeException(ex); } } private String stringToVarchar(String type) { return type.equalsIgnoreCase(\"String\") ? \"VARCHAR\" : type; } private Node getNode(String name) { switch (dialect) { case H2: return new Node(name, String.format(\"%s;LOCK_MODE=3\", name), \"mem\", dialect); case MySql: return new Node(name, name, \"localhost\", dialect); default: throw new RuntimeException(\"Unsupported dialect: \" + dialect); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.Set; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.Filter; import org.hivedb.util.functional.Predicate; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; "}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; public class Converters { public static byte[] getBytes(InputStream inputStream) { ByteArrayOutputStream out = new ByteArrayOutputStream(1024); byte[] buffer = new byte[1024]; int len; try { while((len = inputStream.read(buffer)) >= 0) out.write(buffer, 0, len); inputStream.reset(); out.close(); } catch (IOException e) { throw new RuntimeException(e); } return out.toByteArray(); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; public interface DeepHashCode {  int deepHashCode(Object obj); int shallowHashCode(Object obj); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import org.hivedb.util.functional.Pair; public class FilteringStringBuilder { private StringBuilder s; private Map<String, StringBuilderFilter> filters; public FilteringStringBuilder() { this(new StringBuilder()); } public FilteringStringBuilder(StringBuilder s) { this.filters = new HashMap<String, StringBuilderFilter>(); this.s = s; this.addFilter(\"replace\", replace()); this.addFilter(\"format\", format()); } public FilteringStringBuilder append(Object o) { s.append(o); return this; } public FilteringStringBuilder filter(String name, String input, Object... args) { return this.append(filters.get(name).apply(input, args)); } public FilteringStringBuilder addFilter(String name, StringBuilderFilter filter) { this.filters.put(name, filter); return this; } public StringBuilderFilter getFilter(String key) { return filters.get(key); } public String toString() { return s.toString(); } public static StringBuilderFilter format() { return new StringBuilderFilter() { public String apply(String text, Object... args) { return !\"\".equals(text) ? String.format(args[0].toString(), text) : \"\"; }}; } @SuppressWarnings(\"unchecked\") public static StringBuilderFilter getMapEntry(final Map map) { return new StringBuilderFilter(){ public String apply(String text, Object... args) { return map.containsKey(text) ? map.get(text).toString() : \"\"; }}; } public static StringBuilderFilter replace() { return new StringBuilderFilter(){ public String apply(String text, Object... args) { return text.replace(args[0].toString(), args[1].toString()); }}; } public StringBuilderFilterChain chain(String text) { return new StringBuilderFilterChain(text); } public interface StringBuilderFilter { public String apply(String text, Object... args); } public class StringBuilderFilterChain { List<Pair<StringBuilderFilter, Object[]>> chain = new ArrayList<Pair<StringBuilderFilter,Object[]>>(); String input; public StringBuilderFilterChain(String input) { this.input = input; } public StringBuilderFilterChain add(String name, Object... args) { chain.add(new Pair<StringBuilderFilter, Object[]>(filters.get(name), args)); return this; } public String execute() { String output = input; "}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Hashtable; import java.util.Map; public class GetOpt { Map<String,Key> keys; Map<String,String> lastProcessed; public GetOpt() { this.keys = new Hashtable<String, Key>(); } public GetOpt(String format) { this.keys = extractKeys(format); } public Map<String, String> toMap(String[] argz) { Map<String,String> argumentMap = new Hashtable<String, String>(); Integer unnamedArgumentCount = 0; for(int i=0; i<argz.length; i++) { if(isFlag(argz[i])) { if(keys.get(trimFlag(argz[i])).requiresArgument && i != argz.length-1) argumentMap.put(trimFlag(argz[i]), argz[++i]); else argumentMap.put(trimFlag(argz[i]), \"\"); } else { argumentMap.put(unnamedArgumentCount.toString(), argz[i].trim()); unnamedArgumentCount++; } } lastProcessed = argumentMap; return argumentMap; } public Map<String,String> getLast() {return lastProcessed;} public boolean validate() { return validateArgumentMap(this.lastProcessed, keys); } public static boolean validateArgumentMap(Map<String,String> argz, Map<String,Key> keys) { boolean isValid = true; for(Key key : keys.values()) isValid &= key.requiresArgument ? !\"\".equals(argz.get(key.value)) : \"\".equals(argz.get(key.value)); return isValid; } public void add(String value, boolean requiresArgument) { this.keys.put(value, new Key(value, requiresArgument)); } private Map<String,Key> extractKeys(String format) { String[] flags = format.split(\",\"); Map<String,Key> keys = new Hashtable<String, Key>(); for(String s : flags) { keys.put(trimFormatString(s),new Key(trimFormatString(s), needsArgument(s))); } return keys; } public static boolean isFlag(String s) { return s.startsWith(\"-\"); } private String trimFormatString(String s) { return s.trim().replaceAll(\":\", \"\"); } private boolean needsArgument(String s) { return s.trim().endsWith(\":\"); } private String trimFlag(String s) { s = s.trim(); while(isFlag(s)) { s = s.replaceFirst(\"-\", \"\"); } return s; } private class Key { private boolean requiresArgument; private String value; public Key(String value, boolean requiresArgument) { this.value = value; this.requiresArgument = requiresArgument; } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.Hive; import org.hivedb.Schema; import org.hivedb.meta.Node; import org.hivedb.util.database.DialectTools; import org.hivedb.util.database.DriverLoader; import org.hivedb.util.database.Schemas; import java.sql.DriverManager; import java.sql.SQLException;  public class HiveDestructor { public void destroy(Hive hive) { for (Node node : hive.getNodes()) { destroy(node); } Schemas.uninstall(hive.getPartitionDimension()); for (Node node : hive.getNodes()) { if (!node.getUri().equals(hive.getUri())) { shutdown(node); } } shutdown(hive); } private void destroy(Node node) { for (Schema schema : Schemas.getDataSchemas(node.getUri())) { Schemas.uninstall(schema, node.getUri()); } } private void shutdown(Hive hive) { DriverLoader.initializeDriver(hive.getUri()); try { DriverManager.getConnection(hive.getUri()).createStatement().execute(DialectTools.getDropDatabase(hive.getDialect(), hive.getName())); } catch (SQLException ex) { throw new RuntimeException(ex); } } private void shutdown(Node node) { DriverLoader.initializeDriver(node.getUri()); try { DriverManager.getConnection(node.getUri()).createStatement().execute(DialectTools.getDropDatabase(node.getDialect(), node.getName())); } catch (SQLException ex) { throw new RuntimeException(ex); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Collection; import java.util.Map; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; public class HiveDiff { Collection<Resource> missingResources; Map<Resource, Collection<SecondaryIndex>> missingSecondaryIndexes; public HiveDiff( Collection<Resource> missingResources, Map<Resource, Collection<SecondaryIndex>> missingSecondaryIndexes) { this.missingResources = missingResources; this.missingSecondaryIndexes = missingSecondaryIndexes; } public Collection<Resource> getMissingResources() { return missingResources; } public Map<Resource, Collection<SecondaryIndex>> getMissingSecondaryIndexes() { return missingSecondaryIndexes; } @Override public String toString() { return String.format( \"Missing resources: %s\\n\"+ \"Missing secondary indexes: %s\\n\", missingResources, missingSecondaryIndexes); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.Hive; import org.hivedb.HiveKeyNotFoundException; import org.hivedb.HiveLockableException; import org.hivedb.annotations.IndexType; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.configuration.EntityIndexConfig; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import org.hivedb.util.database.JdbcTypeMapper; import org.hivedb.util.functional.*; import java.util.ArrayList; import java.util.Collection; import java.util.Map; import java.util.Map.Entry;  public class HiveSyncer { private Hive hive; public HiveSyncer(Hive hive) { this.hive = hive; }  public HiveDiff syncHive(EntityHiveConfig entityHiveConfig) throws HiveLockableException { HiveDiff hiveDiff = diffHive(entityHiveConfig); for(Resource resource: hiveDiff.getMissingResources()) hive.addResource(resource); for(Entry<Resource, Collection<SecondaryIndex>> entry : hiveDiff.getMissingSecondaryIndexes().entrySet()) for(SecondaryIndex index: entry.getValue()) hive.addSecondaryIndex(entry.getKey(), index); return hiveDiff; }  public HiveDiff diffHive(final EntityHiveConfig updater) { Collection<Resource> missingResources = Lists.newArrayList(); Map<Resource, Collection<SecondaryIndex>> indexMap = Maps.newHashMap(); for(EntityConfig config : updater.getEntityConfigs()) { try { Resource resource = hive.getPartitionDimension().getResource(config.getResourceName()); for(EntityIndexConfig indexConfig : getHiveIndexes(config)) { try { resource.getSecondaryIndex(indexConfig.getIndexName()); } catch(HiveKeyNotFoundException ex) { if(!indexMap.containsKey(resource)) indexMap.put(resource, new ArrayList<SecondaryIndex>()); indexMap.get(resource).add(configToIndex().f(indexConfig)); } } } catch(HiveKeyNotFoundException e) { Resource resource = new Resource( config.getResourceName(), JdbcTypeMapper.primitiveTypeToJdbcType(config.getIdClass()), config.isPartitioningResource()); missingResources.add(resource); indexMap.put(resource, Transform.map(configToIndex(), config.getEntityIndexConfigs())); } } return new HiveDiff(missingResources, indexMap); } private Unary<EntityIndexConfig, SecondaryIndex> configToIndex() { return new Unary<EntityIndexConfig, SecondaryIndex>(){ public SecondaryIndex f(EntityIndexConfig item) { return new SecondaryIndex(item.getIndexName(), JdbcTypeMapper.primitiveTypeToJdbcType(item.getIndexClass())); }}; } private static Collection<? extends EntityIndexConfig> getHiveIndexes(final EntityConfig entityConfig) { return Filter.grep(new Predicate<EntityIndexConfig>() { public boolean f(EntityIndexConfig entityIndexConfig) { return entityIndexConfig.getIndexType().equals(IndexType.Hive); }}, entityConfig.getEntityIndexConfigs()); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.Hive; import org.hivedb.meta.Node; import org.hivedb.meta.directory.KeySemaphore; import org.hivedb.util.functional.Transform; import org.hivedb.util.functional.Unary; import java.util.*; public class HiveUtils {  public static int makeHashCode(Object... objects) { return makeHashCode(Arrays.asList(objects)); } public static int makeHashCode(Collection<?> collection) { String result = \"\"; for (Object object : collection) if (object != null) result += (object instanceof Collection ? new HashSet<Object>((Collection<?>) object).hashCode() : object.hashCode()); return result.hashCode(); } static int globalDeepFormatedStringTabLevel = 0; public static String toDeepFormatedString(Object target, Object... alteringKeyValues) { String tabs = makeTabs(globalDeepFormatedStringTabLevel); String formatString = \"\\n\" + tabs + \"%s (HashCode:%s)\\n\"; Object[] values = new Object[2 + alteringKeyValues.length / 2]; values[0] = target.getClass().getSimpleName(); values[1] = target.hashCode(); tabs = makeTabs(++globalDeepFormatedStringTabLevel); for (int i = 0; i < alteringKeyValues.length; i += 2) { formatString += \"\\n\" + tabs + alteringKeyValues[i] + \":%s\"; values[i / 2 + 2] = alteringKeyValues[i + 1] instanceof Collection ? toDeepFormatedStringOfCollection(Arrays.asList(alteringKeyValues[i + 1])) : alteringKeyValues[i + 1]; } globalDeepFormatedStringTabLevel--; return String.format(formatString, values); } public static String toDeepFormatedStringOfCollection(Collection<Object> collection) { String tabs = makeTabs(++globalDeepFormatedStringTabLevel); Set<Object> set = new TreeSet<Object>(collection); Object[] objects = new Object[1 + set.size()]; String formatString = \"[(Collection HashCode:%s)\\n\"; objects[0] = set.hashCode(); Iterator<?> iterator = set.iterator(); for (int i = 1; i < objects.length; i++) { objects[i] = iterator.next(); formatString += tabs + \"%s\" + (iterator.hasNext() ? \", \" : \"\"); } formatString += \"]\"; globalDeepFormatedStringTabLevel--; return String.format(formatString, objects); } private static String makeTabs(int count) { String tabs = \"\"; for (int i = 0; i < count; i++) tabs += \"\\t\"; return tabs; } public static Collection<Node> getNodesForSemaphores(Collection<KeySemaphore> semaphores, final Hive hive) { return Transform.map(new Unary<KeySemaphore, Node>() { public Node f(KeySemaphore item) { return hive.getNode(item.getNodeId()); } }, semaphores); } public static <T> T defaultTo(T obj, T value) { return obj == null ? value : obj; } public static boolean empty(String s) { return s == null || \"\".equals(s); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Collection; import org.hivedb.meta.IdAndNameIdentifiable; public class IdentifiableUtils { public static boolean isNameUnique(Collection<IdAndNameIdentifiable> collection, String itemName) { for (IdAndNameIdentifiable collectionItem : collection) if (itemName.equals(collectionItem.getName())) return false; return true; }  public static boolean isNameUnique(Collection<IdAndNameIdentifiable> collection, IdAndNameIdentifiable item) { String itemName = ((IdAndNameIdentifiable) item).getName(); for (IdAndNameIdentifiable collectionItem : collection) if (itemName.equals((collectionItem).getName()) && collectionItem.getId() != item.getId()) return false; return true; } public static boolean isIdPresent(Collection<IdAndNameIdentifiable> collection, IdAndNameIdentifiable item) { for (IdAndNameIdentifiable collectionItem : collection) if (item.getId() == collectionItem.getId()) return true; return false; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.Hive; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.meta.PartitionDimension; import org.hivedb.util.database.Schemas; public class InstallHiveIndexSchema { public static PartitionDimension install(final EntityHiveConfig entityHiveConfig, Hive hive) { try { "}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Collection; public interface InstanceCollectionValueGetter { Collection<Object> get(Object instance); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.*; public class Lists { public static <T> List<T> newArrayList() { return new ArrayList<T>(); } public static <T> List<T> newList(T... items) { return Arrays.asList(items); } public static <T> T random(Collection<T> items) { int pick = new Random().nextInt(items.size()); List<T> list = new ArrayList<T>(items); return list.get(pick); } public static <T> List<T> newList(Collection<T> items) { List<T> list = new ArrayList<T>(); list.addAll(items); return list; } public static <T> T[] copyInto(T[] source, T[] target) { for (int i = 0; i < source.length; i++) target[i] = source[i]; return target; } public static int[] copyInto(int[] source, int[] target) { for (int i = 0; i < source.length; i++) target[i] = source[i]; return target; } public static boolean or(Iterable<Boolean> bools) { boolean b = false; for (Boolean v : bools) b |= v; return b; } public static boolean or(boolean... bools) { boolean b = false; for (Boolean v : bools) b |= v; return b; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Map; import org.apache.cxf.aegis.type.java5.IgnoreProperty; public interface MapBacked { @IgnoreProperty public abstract Map getMap(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Map; import org.hivedb.util.functional.Maps; public class Mapper implements MapBacked { public Mapper() { this.map = Maps.newHashMap(); } private Map map = Maps.newHashMap(); public Map getMap() { if(map == null) map = Maps.newHashMap(); return map;} public void setMap(Map map) {this.map = map;} }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.util.functional.Amass;  public abstract class NamedAccessorFunction<T> extends AccessorFunction<T> { private String name; public NamedAccessorFunction(String name) { this.name = name; } @Override public int hashCode() { return Amass.makeHashCode(new Object[] { name.hashCode(), getFieldClass().hashCode() }); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.HiveKeyNotFoundException; import org.hivedb.HiveLockableException; import org.hivedb.HiveRuntimeException; import org.hivedb.Lockable; import org.hivedb.meta.IdAndNameIdentifiable; import org.hivedb.meta.Identifiable; import java.util.Collection; public class Preconditions { @SuppressWarnings(\"unchecked\") public static<T extends IdAndNameIdentifiable> boolean isNameUnique(Collection<T> collection, String name) { return IdentifiableUtils.isNameUnique((Collection<IdAndNameIdentifiable>) collection, name); } @SuppressWarnings(\"unchecked\") public static<T extends IdAndNameIdentifiable> void nameIsUnique(Collection<T> collection, T item) { if(!IdentifiableUtils.isNameUnique((Collection<IdAndNameIdentifiable>) collection, item)) throw new HiveRuntimeException( String.format(\"%s with name %s already exists\", item.getClass().getSimpleName(), item.getName())); } @SuppressWarnings(\"unchecked\") public static<T extends Identifiable> void idIsPresentInList(Collection<T> collection, T item) { if(!IdentifiableUtils.isIdPresent((Collection<IdAndNameIdentifiable>)collection, (IdAndNameIdentifiable) item)) throw new HiveKeyNotFoundException( String.format(\"Could not find %s with id %s\", item.getClass().getSimpleName(), item.getId()), item); } public static void isWritable(Collection<? extends Lockable> lockables, Lockable... moreLockables) throws HiveLockableException { for(Lockable lockable : lockables) isWritable(lockable); isWritable(moreLockables); } public static void isWritable(Lockable... lockables) throws HiveLockableException { for(Lockable lockable : lockables) isWritable(lockable); } public static void isWritable(Lockable lockable) throws HiveLockableException { if(lockable.getStatus() != Lockable.Status.writable) throw new HiveLockableException( String.format(\"This operation is invalid because the %s is currently set to status %s.\", lockable.getClass().getSimpleName(), lockable.getStatus())); } public static void isNotEmpty(Collection c, String message) throws HiveKeyNotFoundException { if(c == null || c.size() == 0) throw new HiveKeyNotFoundException(message); } public static void isNotNull(Object... objects) { for(Object o : objects) if(o == null) {throw new HiveRuntimeException(\"Precondition violated an object was null.\");} } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.util.functional.Binary; import org.hivedb.util.classgen.ReflectionTools; import java.io.InputStream; import java.math.BigDecimal; import java.sql.Blob; import java.text.DateFormat; import java.text.ParseException; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; public class PrimitiveUtils { static Date date; static { Calendar calendar = GregorianCalendar.getInstance(); calendar.clear(); date = calendar.getTime(); } public static boolean isUndefinedId(Object id) { return getUndefinedValue(id.getClass()).equals(id); } public static Object getUndefinedValue(Class clazz) { if (isInteger(clazz)) return 0; if (isLong(clazz)) return 0L; if (isShort(clazz)) return (short) 0; if (isDouble(clazz)) return (double) 0; if (isFloat(clazz)) return (float) 0; if (isBigDecimal(clazz)) return BigDecimal.ZERO; if (isString(clazz)) return \"\"; if (isDate(clazz)) { return date; } throw new RuntimeException(String.format(\"Class %s not supported\", clazz.getSimpleName())); } public static Object getPrimitiveEquivalent(Object value) { if (isInteger(value.getClass())) return (int)(Integer)value; if (isLong(value.getClass())) return (long)(Long)value; if (isShort(value.getClass())) return (short)(Short)value; if (isDouble(value.getClass())) return (double)(Double)value; if (isFloat(value.getClass())) return (float)(Float)value; return value; } public static<T> T getMinValue(Class<T> clazz) { if (isInteger(clazz)) return (T)new Integer(Integer.MIN_VALUE); if (isLong(clazz)) return (T)new Long(Long.MIN_VALUE); if (isShort(clazz)) return (T)new Short(Short.MIN_VALUE); if (isDouble(clazz)) return (T)new Double(Double.MIN_VALUE); if (isFloat(clazz)) return (T)new Float(Float.MIN_VALUE); throw new RuntimeException(String.format(\"Class %s not supported\", clazz.getSimpleName())); } public static<T> T getMaxValue(Class<T> clazz) { if (isInteger(clazz)) return (T)new Integer(Integer.MAX_VALUE); if (isLong(clazz)) return (T)new Long(Long.MAX_VALUE); if (isShort(clazz)) return (T)new Short(Short.MAX_VALUE); if (isDouble(clazz)) return (T)new Double(Double.MAX_VALUE); if (isFloat(clazz)) return (T)new Float(Float.MAX_VALUE); throw new RuntimeException(String.format(\"Class %s not supported\", clazz.getSimpleName())); } public static Binary getMinFunction(final Class<?> clazz) { return new Binary() { public Object f(Object t1, Object t2) { if (isInteger(clazz)) return Math.min((Integer)t1, (Integer)t2); if (isLong(clazz)) return Math.min((Long)t1, (Long)t2); if (isFloat(clazz)) return Math.min((Float)t1, (Float)t2); if (isDouble(clazz)) return Math.min((Double)t1, (Double)t2); throw new RuntimeException(String.format(\"Class %s not supported\", clazz.getSimpleName())); }}; } public static Binary getMaxFunction(final Class<?> clazz) { return new Binary() { public Object f(Object t1, Object t2) { if (isInteger(clazz)) return Math.max((Integer)t1, (Integer)t2); if (isLong(clazz)) return Math.max((Long)t1, (Long)t2); if (isFloat(clazz)) return Math.max((Float)t1, (Float)t2); if (isDouble(clazz)) return Math.max((Double)t1, (Double)t2); throw new RuntimeException(String.format(\"Class %s not supported\", clazz.getSimpleName())); }}; } public static <T> T copyInstance(T instance) { if (isInteger(instance.getClass())) return (T) new Integer(((Integer)instance).intValue()); if (isLong(instance.getClass())) return (T) new Long(((Long)instance).longValue()); if (isShort(instance.getClass())) return (T) new Short(((Short)instance).shortValue()); if (isDouble(instance.getClass())) return (T) new Double(((Double)instance).doubleValue()); if (isFloat(instance.getClass())) return (T) new Float(((Float)instance).floatValue()); if (isBigDecimal(instance.getClass())) { return (T) ((BigDecimal)instance).multiply(new BigDecimal(new Integer(1))); } if (isString(instance.getClass())) return (T)new String((String)instance); "}
{"name": "britt/hivedb", "content": " package org.hivedb.util; public interface PropertyAccessor { void set(String property, Object value); Object get(String property); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.beans.PropertyChangeListener; public interface PropertyChangeListenerRegistrar { void addPropertyChangeListener(PropertyChangeListener listener); void removePropertyChangeListener(PropertyChangeListener listener); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.util.Hashtable; import java.util.Map; import org.hivedb.util.functional.Delay; public class QuickCache { Map<Object, Object> cache = new Hashtable<Object, Object>(); @SuppressWarnings(\"unchecked\") public<T> T get(Object key, Delay<T> delay) { if (!cache.containsKey(key)) cache.put(key, delay.f()); return (T) cache.get(key); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.util.List; import java.util.Iterator; public class Strings { private final static Log log = LogFactory.getLog(Strings.class); public static String join(String separator, String... strings) { StringBuilder sb = new StringBuilder(); List<String> list = Lists.newList(strings); Iterator<String> itr = list.iterator(); while (itr.hasNext()) { sb.append(itr.next()); if (itr.hasNext()) sb.append(separator); } return sb.toString(); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import java.io.IOException; import java.io.StringWriter; import java.util.Properties; import org.apache.velocity.Template; import org.apache.velocity.app.Velocity; import org.apache.velocity.context.Context; import org.apache.velocity.exception.MethodInvocationException; import org.apache.velocity.exception.ParseErrorException; import org.apache.velocity.exception.ResourceNotFoundException; import org.hivedb.HiveRuntimeException; public class Templater { public static String render(String templateFile, Context context) { try { Velocity.init(getDefaultVelocityProperties()); } catch (Exception e) { throw new HiveRuntimeException(\"Failed to initialize Velocity templatng engine.\"); } Template template = null; try { template = Velocity.getTemplate(templateFile); } catch (ResourceNotFoundException e) { throw new HiveRuntimeException(\"Unable to locate template: \" + templateFile); } catch (ParseErrorException e) { throw new HiveRuntimeException(\"Error parsing template: \" + templateFile); } catch (Exception e) { throw new RuntimeException(e); } StringWriter writer = new StringWriter(); try { template.merge(context, writer); } catch (Exception e) { throw new HiveRuntimeException(e); } return writer.toString(); } public static Properties getDefaultVelocityProperties() { Properties p = new Properties(); p.setProperty( \"resource.loader\", \"class\" ); p.setProperty( \"class.resource.loader.class\", \"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\" ); return p; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util; import org.hivedb.Hive; import org.hivedb.meta.persistence.CachingDataSourceProvider; import org.hivedb.meta.persistence.HiveDataSourceProvider; import org.hivedb.util.database.DialectTools; import org.hivedb.util.database.HiveDbDialect; import org.ho.yaml.Yaml; import java.io.FileNotFoundException; import java.io.FileReader; import java.util.List; import java.util.Map;  public class YamlHiveCreator { private HiveDataSourceProvider dataSourceProvider = CachingDataSourceProvider.getInstance(); private HiveDbDialect dialect; public YamlHiveCreator(HiveDbDialect dialect) { try { Class.forName(DialectTools.getDriver(dialect)); } catch (Exception ex) { throw new RuntimeException(String.format(\"Error initalizing the %s server.\", dialect), ex); } this.dialect = dialect; } @SuppressWarnings(\"unchecked\") public Hive load(String configFile) throws FileNotFoundException { Map<String, Map<String, ?>> configs = (Map<String, Map<String, ?>>) Yaml.load(new FileReader(configFile)); if (configs == null || configs.size() != 1) { throw new RuntimeException(String.format(\"Zero or multipe hives defined in %s\", configFile)); } return load(configs.values().iterator().next()); } @SuppressWarnings(\"unchecked\") private Hive load(Map<String, ?> config) { Map<String, String> dimension = (Map<String, String>) config.get(\"dimension\"); List<Map<String, ?>> nodes = (List<Map<String, ?>>) config.get(\"nodes\"); List<Map<String, ?>> resources = (List<Map<String, ?>>) config.get(\"resources\"); return new BourneHive(dimension, dataSourceProvider, dialect).addNodes(nodes).addResources(resources).getHive(); } public static void main(String[] args) throws FileNotFoundException { if (args.length != 4 || getDialect(args) == null || getConfigFile(args) == null) { usage(); } else { new YamlHiveCreator(getDialect(args)).load(getConfigFile(args)); } } private static String getConfigFile(String args[]) { if (args[0].equalsIgnoreCase(\"-yml\")) { return args[1]; } else if (args[2].equalsIgnoreCase(\"-yml\")) { return args[3]; } return null; } private static HiveDbDialect getDialect(String dialect) { return HiveDbDialect.valueOf(dialect); } private static HiveDbDialect getDialect(String args[]) { if (args[0].equalsIgnoreCase(\"-dialect\")) { return getDialect(args[1]); } else if (args[2].equalsIgnoreCase(\"-dialect\")) { return getDialect(args[3]); } return null; } public static void usage() { System.out.println(new StringBuilder(\"USAGE: java -cp hivedb.jar org.hivedb.util.YamlHiveCreator -dialect [h2|mysql] -yml <path_to_yaml_config>\")); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import net.sf.cglib.proxy.Factory; import org.hivedb.annotations.GeneratorIgnore; import org.hivedb.util.*; import org.hivedb.util.QuickCache; import org.hivedb.util.functional.*; import org.springframework.beans.BeanUtils; import java.lang.reflect.Method; import java.util.Arrays; import java.util.Collection; public class GenerateInstance<T> implements Generator<T> { private final int COLLECTION_SIZE = 3; private Class<T> clazz; private Collection<Class<?>> excludedClasses = defaultExcludedClasses(); public GenerateInstance(Class<T> clazz) { this.clazz = clazz; } public T generateAndCopyProperties(Object templateInstance) { if (PrimitiveUtils.isPrimitiveClass(clazz)) throw new RuntimeException(String.format(\"Attempt to generate instance and copy properties of a primitive class: %s\", clazz.getName())); T instance = newInstance(); for( Method getter : ReflectionTools.getGetters(clazz)) { if (belongsToExcludedClass(getter)) continue; else { String propertyName = BeanUtils.findPropertyForMethod(getter).getName(); final Object value = ReflectionTools.invokeGetter(templateInstance, propertyName); if (ReflectionTools.isCollectionProperty(clazz, propertyName)) { Collection<Object> collection = value == null ? Lists.newArrayList() : (Collection<Object>)value; final Class<?> itemClass = ReflectionTools.getCollectionItemType(clazz, propertyName); final GenerateInstance<Object> generateInstance = new GenerateInstance<Object>((Class<Object>) itemClass); GeneratedInstanceInterceptor.setProperty( instance, propertyName, Transform.map(new Unary<Object,Object>() { public Object f(Object item) { return PrimitiveUtils.isPrimitiveClass(itemClass) ? item : generateInstance.generateAndCopyProperties(item); }}, collection)); } else if(value == null) continue; else if(PrimitiveUtils.isPrimitiveClass(value.getClass())) GeneratedInstanceInterceptor.setProperty( instance, propertyName, value); else GeneratedInstanceInterceptor.setProperty( instance, propertyName, new GenerateInstance<Object>((Class<Object>) getter.getReturnType()).generateAndCopyProperties(value)); } } return instance; } static QuickCache primitiveGenerators = new QuickCache(); "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import org.hivedb.util.PrimitiveUtils; import org.hivedb.util.functional.Generate; import org.hivedb.util.functional.Generator; import org.hivedb.util.functional.NumberIterator; import java.util.Collection; public class GenerateInstanceCollection<T> implements Generator<Collection<T>> { private Class<T> collectionItemClazz; private int size; public GenerateInstanceCollection(Class<T> collectionItemClazz, int size) { this.collectionItemClazz = collectionItemClazz; this.size = size; } @SuppressWarnings(\"unchecked\") public Collection<T> generate() { return PrimitiveUtils.isPrimitiveClass(collectionItemClazz) ? new GeneratePrimitiveCollection(collectionItemClazz, size).generate() : Generate.create(new GenerateInstance<T>(this.collectionItemClazz), new NumberIterator(size)); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import org.hivedb.util.functional.Generate; import org.hivedb.util.functional.Generator; import org.hivedb.util.functional.NumberIterator; import java.util.Collection; public class GeneratePrimitiveCollection<F> implements Generator<Collection<F>> { private Class<F> collectionItemClazz; private int size; public GeneratePrimitiveCollection(Class<F> collectionItemClazz, int size) { this.collectionItemClazz = collectionItemClazz; this.size = size; } @SuppressWarnings(\"unchecked\") public Collection<F> generate() { return Generate.create(new GeneratePrimitiveValue<F>(this.collectionItemClazz), new NumberIterator(size)); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import org.hivedb.util.PrimitiveUtils; import org.hivedb.util.functional.Generator; import java.math.BigDecimal; import java.util.Calendar; import java.util.GregorianCalendar; import java.util.Random; public class GeneratePrimitiveValue<F> implements Generator<F> { Class<F> clazz; static Random random; public GeneratePrimitiveValue(Class<F> clazz) { this.clazz = clazz; this.random = new Random(); } @SuppressWarnings(\"unchecked\")  public F generate() { if (PrimitiveUtils.isInteger(clazz)) return (F)new Integer(Math.abs(random.nextInt(Integer.MAX_VALUE))); else if (PrimitiveUtils.isLong(clazz)) return (F)new Long(Math.abs(random.nextLong())); else if (PrimitiveUtils.isShort(clazz)) return (F)new Short((short)Math.abs(random.nextInt(Integer.MAX_VALUE >> 16))); else if (PrimitiveUtils.isDouble(clazz)) return (F)new Double(Math.floor(Math.abs(random.nextDouble()))+.1); else if (PrimitiveUtils.isFloat(clazz)) return (F)new Float(Math.floor(Math.abs(random.nextFloat()))+.1); else if (PrimitiveUtils.isBigDecimal(clazz)) return (F)new BigDecimal(Math.floor(Math.abs(random.nextFloat()))+.1); else if (PrimitiveUtils.isString(clazz)) return (F)new String(\"String\"+Math.abs(random.nextInt())); else if (PrimitiveUtils.isDate(clazz)) { final long min = maxTime + random.nextInt(); calendar.setTimeInMillis(min); return (F)calendar.getTime(); } else if (PrimitiveUtils.isBoolean(clazz)) return (F)(random.nextInt() % 2 == 0 ? Boolean.TRUE : Boolean.FALSE); else if (PrimitiveUtils.isObject(clazz)) return (F)new Integer(-1); throw new RuntimeException(String.format(\"Class %s not supported\", clazz.getSimpleName())); } static Calendar calendar; static long maxTime; static { calendar = GregorianCalendar.getInstance(); maxTime = calendar.getTimeInMillis(); random = new Random(System.currentTimeMillis()); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import net.sf.cglib.proxy.Callback; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import org.hivedb.util.Mapper; import org.hivedb.util.PropertyAccessor; import org.hivedb.util.classgen.ReflectionTools; import java.util.Map; public class GeneratedClassFactory { private static MethodInterceptor getDefaultInterceptor(Class clazz) { return new GeneratedInstanceInterceptor(clazz); } public static<T> Class<? extends T> getGeneratedClass(final Class<T> clazz, MethodInterceptor interceptor) { "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import java.util.Map; public interface GeneratedImplementation {  Class retrieveUnderlyingInterface();  Map retrieveMap(); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.classgen; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import org.hivedb.HiveRuntimeException; import org.hivedb.annotations.AnnotationHelper; import org.hivedb.annotations.EntityId; import org.hivedb.util.DeepHashCode; import org.hivedb.util.PropertyAccessor; import org.hivedb.util.PropertyChangeListenerRegistrar; import org.hivedb.util.classgen.ReflectionTools; import org.hivedb.util.functional.Amass; import org.hivedb.util.functional.Atom; import org.hivedb.util.functional.DebugMap; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.lang.reflect.Method; import java.util.Hashtable; import java.util.Map; public class GeneratedInstanceInterceptor implements MethodInterceptor { private Class clazz; private Map map = new Hashtable(); private PropertyChangeSupport propertySupport; public GeneratedInstanceInterceptor(Class clazz) { this.clazz = clazz; } public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { String name = method.getName(); Implementor implementor = new Implementor(obj); "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import org.hibernate.shards.strategy.access.ShardAccessStrategy; import org.hibernate.shards.util.Lists; import org.hivedb.Hive; import org.hivedb.HiveRuntimeException; import org.hivedb.annotations.AnnotationHelper; import org.hivedb.annotations.IndexParam; import org.hivedb.annotations.IndexParamPagingPair; import org.hivedb.annotations.IndexParamPairs; import org.hivedb.configuration.EntityConfig; import org.hivedb.configuration.EntityHiveConfig; import org.hivedb.hibernate.*; import org.hivedb.services.Service; import org.hivedb.services.ServiceContainer; import org.hivedb.services.ServiceResponse; import org.hivedb.util.PrimitiveUtils; import org.hivedb.util.functional.*; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.*; import java.util.Map.Entry; public class GeneratedServiceInterceptor implements MethodInterceptor, Service { public static Service load(String className, String serviceClassName, String serviceResponseClassName, String serviceContainerClassName, Hive hive, EntityHiveConfig entityHiveConfig, ShardAccessStrategy strategy) { try { return load(Class.forName(className), Class.forName(serviceClassName), Class.forName(serviceResponseClassName), Class.forName(serviceContainerClassName), hive, entityHiveConfig, strategy); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } } public static Service load(Class clazz, Class serviceClass, Class serviceResponseClass, Class serviceContainerClass, Hive hive, EntityHiveConfig entityHiveConfig, ShardAccessStrategy strategy) { EntityConfig config = entityHiveConfig.getEntityConfig(clazz.getCanonicalName()); List<Class<?>> classes = Lists.newArrayList(); classes.addAll(new EntityResolver(entityHiveConfig).getEntityClasses()); HiveSessionFactory factory = new HiveSessionFactoryBuilderImpl(entityHiveConfig, hive, strategy); DataAccessObject dao = new BaseDataAccessObject(config, hive, factory); return (Service) GeneratedClassFactory.newInstance(serviceClass, new GeneratedServiceInterceptor(clazz, serviceClass, serviceResponseClass, serviceContainerClass, dao, config)); } public static Service load(Class clazz, Class serviceClass, Class serviceResponseClass, Class serviceContainerClass, Hive hive, ConfigurationReader reader, ShardAccessStrategy strategy) { return load(clazz, serviceClass, serviceResponseClass, serviceContainerClass, hive, reader.getHiveConfiguration(), strategy); } Class clazz; Class serviceClass; Class serviceResponseClass; Class serviceContainerClass; DataAccessObject dao; EntityConfig config; public GeneratedServiceInterceptor(Class clazz, Class serviceClass, Class serviceResponseClass, Class serviceContainerClass, DataAccessObject dao, EntityConfig config) { this.clazz = clazz; this.serviceClass = serviceClass; this.serviceResponseClass = serviceResponseClass; this.serviceContainerClass = serviceContainerClass; this.dao = dao; this.config = config; } public Collection<Object> unProxy(Collection<Object> classInstances) { return Transform.map(new Unary<Object, Object>() { public Object f(Object item) { return unProxy(item); } }, classInstances); } public Object unProxy(Object instance) { return new GenerateInstance(clazz).generateAndCopyProperties(instance); } public boolean exists(Object id) { return dao.exists(id); } public String getPersistedClass() { return clazz.getName(); } public Object delete(Object id) { dao.delete(id); return id; } public ServiceResponse get(Object id) { final Object instance = dao.get(id); return formulateResponse((Collection<Object>) (instance != null ? Arrays.asList(instance) : Collections.emptyList())); } public ServiceResponse save(Object instance) { return formulateResponse(dao.save(unProxy(instance))); } public ServiceResponse saveAll(Iterable instances) { return formulateResponse(dao.saveAll((Collection) unProxy((Collection) instances))); } @SuppressWarnings(\"unchecked\") private ServiceResponse formulateResponse(Object... instances) { return formulateResponse(Arrays.asList(instances)); } @SuppressWarnings(\"unchecked\") private ServiceResponse formulateResponse(Collection instances) { validateNonNull(instances); ServiceResponse serviceResponse = createServiceResponse(instances); return serviceResponse; } public ServiceResponse createServiceResponse(Collection instances) { ServiceResponse serviceResponse = (ServiceResponse) GeneratedClassFactory.newInstance(serviceResponseClass); GeneratedInstanceInterceptor.setProperty(serviceResponse, \"containers\", Transform.map(new Unary<Object, ServiceContainer>() { public ServiceContainer f(Object item) { return createServiceContainer(item, config.getVersion(item)); } }, instances)); return serviceResponse; } public ServiceContainer createServiceContainer(Object instance, Integer version) { ServiceContainer serviceContainer = (ServiceContainer) GeneratedClassFactory.newInstance(serviceContainerClass); "}
{"name": "britt/hivedb", "content": " package org.hivedb.util.classgen; import net.sf.cglib.core.DefaultNamingPolicy; import net.sf.cglib.core.Predicate; import org.hivedb.annotations.GeneratedClass; class ImplNamer extends DefaultNamingPolicy { private Class representedInterface; public ImplNamer(Class representedInterface) { this.representedInterface = representedInterface; } public String getClassName(String prefix, String source, Object key, Predicate names) { return representedInterface.getAnnotation(GeneratedClass.class) != null ? removeClass(representedInterface.getCanonicalName()) + ((GeneratedClass) representedInterface.getAnnotation(GeneratedClass.class)).value() : super.getClassName(prefix, source, key, names); } private String removeClass(String prefix) { return prefix.substring(0,prefix.lastIndexOf(\".\")+1); "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.classgen; import org.hivedb.HiveRuntimeException; import org.hivedb.util.functional.*; import org.hivedb.util.functional.Joiner.ConcatStrings; import org.hivedb.util.PropertyAccessor; import org.hivedb.util.PrimitiveUtils; import java.lang.reflect.*; import java.util.*; public class ReflectionTools { public interface SetterWrapper { void invoke(Object instance, Object value); Method getRealSetter(); } public static final class Descriptor { private final Class<?> clazz; private final Collection<Method> deepMethods; private final Collection<Method> declaredPublicMethods; private final Map<Method, SetterWrapper> accessors; private final Map<Method, String> propertyByGetter; private final Map<String, Method> getterByProperty; private final Map<String, Class<?>> ownerByProperty; private final Map<Method, Map<Class<?>, SetterWrapper>> settersByGetter; private final Map<SetterWrapper, String> propertyBySetter; private Method rawSetter; Descriptor(final Class<?> clazz) { this.clazz = clazz; deepMethods = Collections.unmodifiableCollection(ReflectionTools.getDeepMethods(clazz)); declaredPublicMethods = new HashSet<Method>(); for (Method method : clazz.getDeclaredMethods()) { if ((method.getModifiers() & Modifier.PUBLIC) == Modifier.PUBLIC) { declaredPublicMethods.add(method); } } Map<String, Class<?>> cache = new HashMap<String, Class<?>>(); accessors = new HashMap<Method, SetterWrapper>(); for (final Method method : clazz.getMethods()) { if (ReflectionTools.isGetter(method)) { final String propertyName = formPropertyNameFromGetter(method); if (cache.containsKey(propertyName)) { "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.database; import org.hibernate.dialect.H2Dialect; import org.hibernate.dialect.MySQLInnoDBDialect; import org.hivedb.UnsupportedDialectException; public class DialectTools { public static final String MYSQL = \"MySQL\"; public static final String DERBY = \"Derby\"; public static final String H2 = \"H2\";  public static String getNumericPrimaryKeySequenceModifier(HiveDbDialect dialect) { String statement = \"\"; if (dialect == HiveDbDialect.MySql) statement = \"int not null auto_increment primary key\"; else if (dialect == HiveDbDialect.H2) statement = \"int not null auto_increment primary key\"; else if (dialect == HiveDbDialect.Derby) statement = \"int not null generated always as identity primary key\"; else throw new UnsupportedDialectException(\"Unsupported dialect: \" + dialect.toString()); return statement; }  public static String getBooleanTypeForDialect(HiveDbDialect dialect) { if (dialect.equals(HiveDbDialect.MySql) || dialect.equals(HiveDbDialect.H2)) return \"BOOLEAN\"; else if (dialect.equals(HiveDbDialect.Derby)) return \"INT\"; throw new UnsupportedDialectException(\"No option boolean option configured for \" + dialect.name()); } public static String dialectToString(HiveDbDialect dialect) { if(dialect == HiveDbDialect.H2) return H2; else if(dialect == HiveDbDialect.Derby) return DERBY; else if(dialect == HiveDbDialect.MySql) return MYSQL; else throw new UnsupportedDialectException(\"Unkown database dialect. HiveDB supports MySQL, H2 and Derby.\"); } public static HiveDbDialect stringToDialect(String dialect) { if(dialect.toLowerCase().equals(H2.toLowerCase())) return HiveDbDialect.H2; else if(dialect.toLowerCase().equals(DERBY.toLowerCase())) return HiveDbDialect.Derby; else if(dialect.toLowerCase().equals(MYSQL.toLowerCase())) return HiveDbDialect.MySql; else throw new UnsupportedDialectException(\"Unkown database dialect. HiveDB supports MySQL, H2 and Derby.\"); } public static String getDropDatabase(HiveDbDialect dialect, String name) { switch (dialect) { case H2: return \"SHUTDOWN\"; case MySql: return String.format(\"drop database %s\", name); default: return String.format(\"drop database %s\", name); } } public static String getDriver(HiveDbDialect dialect) { switch (dialect) { case H2: return \"org.h2.Driver\"; case MySql: return \"com.mysql.jdbc.Driver\"; default: throw new RuntimeException(\"Unsupported Dialect: \" + dialect); } } public static String getHiveTestUri(HiveDbDialect dialect) { switch (dialect) { case H2: return \"jdbc:h2:mem:testDb;LOCK_MODE=3\"; case MySql: return \"jdbc:mysql:"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.database; import java.util.HashMap; import org.hivedb.HiveRuntimeException; import org.hivedb.UnsupportedDialectException;  public class DriverLoader { private static HashMap<HiveDbDialect, String> defaultDrivers = null; static { defaultDrivers = new HashMap<HiveDbDialect, String>(); defaultDrivers.put(HiveDbDialect.MySql, \"com.mysql.jdbc.Driver\"); defaultDrivers.put(HiveDbDialect.Derby,\"org.apache.derby.jdbc.EmbeddedDriver\"); defaultDrivers.put(HiveDbDialect.H2,\"org.h2.Driver\"); } public static void loadByDialect(HiveDbDialect dialect) throws ClassNotFoundException { Class.forName(defaultDrivers.get(dialect)); } public static void load(String uri) throws ClassNotFoundException { loadByDialect(discernDialect(uri)); } public static String getDriverClass(HiveDbDialect dialect) { return defaultDrivers.get(dialect); }  public static HiveDbDialect discernDialect(String uri) { if (uri.startsWith(\"jdbc:mysql:\")) return HiveDbDialect.MySql; if (uri.startsWith(\"jdbc:derby:\")) return HiveDbDialect.Derby; if (uri.startsWith(\"jdbc:h2:\")) return HiveDbDialect.H2; throw new UnsupportedDialectException(\"Could not discern the HiveDbDialect from the uri \" + uri); } public static Object getDriverStringForDialect(HiveDbDialect dialect) { if(dialect == HiveDbDialect.MySql) return \"mysql\"; else if(dialect == HiveDbDialect.Derby) return \"derby\"; else if(dialect == HiveDbDialect.H2) return \"h2:mem\"; throw new UnsupportedDialectException(\"This dialect is not supported.\"); } public static String parseConnectionUrl(String uri) { HiveDbDialect discernDialect = discernDialect(uri); if (discernDialect == HiveDbDialect.MySql) return \"jdbc:mysql:"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.database; public enum HiveDbDialect { /** * http:"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.database; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Timestamp; import java.sql.Types; import java.util.Date; import org.hivedb.HiveRuntimeException; public class JdbcTypeMapper { public static String BIGINT = \"BIGINT\"; public static String CHAR = \"CHAR\"; public static String DATE = \"DATETIME\"; public static String DOUBLE = \"DOUBLE\"; public static String FLOAT = \"FLOAT\"; public static String INTEGER = \"INTEGER\"; public static String SMALLINT = \"SMALLINT\"; public static String TIMESTAMP = \"TIMESTAMP\"; public static String TINYINT = \"TINYINT\"; public static String VARCHAR = \"VARCHAR\"; public static String jdbcTypeToString(int jdbcType) { switch (jdbcType) { case Types.BIGINT: return BIGINT; case Types.CHAR: return CHAR; case Types.DATE: return DATE; case Types.DOUBLE: return DOUBLE; case Types.FLOAT: return FLOAT; case Types.INTEGER: return INTEGER; case Types.SMALLINT: return SMALLINT; case Types.TINYINT: return TINYINT; case Types.TIMESTAMP: return TIMESTAMP; case Types.VARCHAR: return VARCHAR; } throw new HiveRuntimeException(\"No known JDBC type: \" + jdbcType, null); } public static int parseJdbcType(String dbString) { String upperDbString = dbString.toUpperCase(); if (BIGINT.equals(upperDbString)) return Types.BIGINT; if (CHAR.equals(upperDbString)) return Types.CHAR; if (DATE.equals(upperDbString)) return Types.DATE; if (DOUBLE.equals(upperDbString)) return Types.DOUBLE; if (FLOAT.equals(upperDbString)) return Types.FLOAT; if (INTEGER.equals(upperDbString)) return Types.INTEGER; if (SMALLINT.equals(upperDbString)) return Types.SMALLINT; if (TIMESTAMP.equals(upperDbString)) return Types.TIMESTAMP; if (TINYINT.equals(upperDbString)) return Types.TINYINT; if (VARCHAR.equals(upperDbString)) return Types.VARCHAR; throw new HiveRuntimeException(\"No known JDBC type: \" + upperDbString); } public static int primitiveTypeToJdbcType(Class<?> classType) { if (classType.equals(int.class) || classType.equals(Integer.class)) return Types.INTEGER; if (classType.equals(short.class) || classType.equals(Short.class)) return Types.SMALLINT; if (classType.equals(long.class) || classType.equals(Long.class)) return Types.BIGINT; if (classType.equals(float.class) || classType.equals(Float.class)) return Types.FLOAT; if (classType.equals(double.class) || classType.equals(Double.class)) return Types.DOUBLE; if (classType.equals(String.class)) return Types.VARCHAR; if (classType.equals(Date.class)) return Types.DATE; if (classType.equals(Timestamp.class)) return Types.TIMESTAMP; if (classType.equals(char.class) || classType.equals(Character.class)) return Types.CHAR; throw new HiveRuntimeException(\"No known database type for class \" + classType.getCanonicalName(), null); } public static Class jdbcTypeToPrimitiveClass(Integer jdbcType) { if (jdbcType.equals(Types.INTEGER)) return Integer.class; if (jdbcType.equals(Types.SMALLINT)) return Short.class; if (jdbcType.equals(Types.BIGINT)) return Long.class; if (jdbcType.equals(Types.FLOAT)) return Float.class; if (jdbcType.equals(Types.DOUBLE)) return Double.class; if (jdbcType.equals(Types.VARCHAR)) return String.class; if (jdbcType.equals(Types.DATE)) return Date.class; if (jdbcType.equals(Types.TIMESTAMP)) return Timestamp.class; if (jdbcType.equals(Types.CHAR)) return Character.class; throw new HiveRuntimeException(\"No known database type for class \" + jdbcType); } public static void insertJdbcTypeParameter( PreparedStatement preparedStatement, int index, Object value) throws SQLException { Class classType = value.getClass(); if (classType.equals(int.class) || classType.equals(Integer.class)) preparedStatement.setInt(index, (Integer) value); if (classType.equals(short.class) || classType.equals(Short.class)) preparedStatement.setShort(index, (Short) value); else if (classType.equals(long.class) || classType.equals(Long.class)) preparedStatement.setLong(index, (Long) value); else if (classType.equals(float.class) || classType.equals(Float.class)) preparedStatement.setFloat(index, (Float) value); else if (classType.equals(double.class) || classType.equals(Double.class)) preparedStatement.setDouble(index, (Double) value); else if (classType.equals(String.class)) preparedStatement.setString(index, (String) value); else if (classType.equals(Date.class)) preparedStatement.setDate(index, new java.sql.Date(((Date) value) .getTime())); else if (classType.equals(Timestamp.class)) preparedStatement.setTimestamp(index, (Timestamp) value); else if (classType.equals(char.class) || classType.equals(Character.class)) preparedStatement.setString(index, value.toString()); else if (classType.equals(boolean.class) || classType.equals(Boolean.class)) preparedStatement.setBoolean(index, (Boolean) value); else throw new HiveRuntimeException(\"No known database type for class \" + classType.getCanonicalName(), null); }  public static Object getJdbcTypeResult(ResultSet resultSet, int index, int jdbcType) throws SQLException { switch (jdbcType) { case Types.BIGINT: return resultSet.getLong(index); case Types.CHAR: String str = resultSet.getString(index); return (str.length() == 1) ? str.toCharArray()[0] : null; case Types.DATE: return new Date(resultSet.getDate(index).getTime()); case Types.DOUBLE: return resultSet.getDouble(index); case Types.FLOAT: return resultSet.getFloat(index); case Types.INTEGER: return resultSet.getInt(index); case Types.SMALLINT: return resultSet.getShort(index); case Types.TIMESTAMP: return new Date(resultSet.getTime(index).getTime()); case Types.VARCHAR: return resultSet.getString(index); } throw new HiveRuntimeException(\"No known JDBC type: \" + jdbcType, null); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.database; import static org.hivedb.util.HiveUtils.empty; import java.util.Map; import java.util.Properties; import org.hivedb.meta.Node; import org.hivedb.util.FilteringStringBuilder; public class JdbcUriFormatter { private static final String OPTIONS = \"options\"; private static final String PASSWORD = \"password\"; private static final String USERNAME = \"username\"; private static final String PORT = \"port\"; private static final String DATABASE = \"database\"; private static final String HOST = \"host\"; private static final String DRIVER = \"driver\"; private Properties p; public JdbcUriFormatter(Node node) { this.p = getConnectionPropertiesFromNode(node); } public String getUri() { return new UriBuilder(p) .append(\"jdbc:\") .filter(\"get\", DRIVER).append(\":\") .chain(HOST).add(\"get\").add(\"format\", \""}
{"name": "britt/hivedb", "content": "package org.hivedb.util.database; import java.sql.ResultSet; import java.sql.SQLException; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.simple.ParameterizedRowMapper;  public class RowMappers { public static RowMapper newIntegerRowMapper() { return new IntegerRowMapper(); } public static RowMapper newBooleanRowMapper() { return new BooleanRowMapper(); } public static ParameterizedRowMapper newObjectRowMapper(int type) { return new ObjectRowMapper(type); } public static RowMapper newTrueRowMapper() { return new TrueRowMapper(); } static class IntegerRowMapper implements RowMapper { public Object mapRow(ResultSet rs, int rowNumber) throws SQLException { return rs.getInt(1); } } static class BooleanRowMapper implements RowMapper { public Object mapRow(ResultSet rs, int rowNumber) throws SQLException { return rs.getBoolean(1); } } static class ObjectRowMapper implements ParameterizedRowMapper { int jdbcType; public ObjectRowMapper(int jdbcType) { this.jdbcType = jdbcType; } public Object mapRow(ResultSet rs, int rowNumber) throws SQLException { return JdbcTypeMapper.getJdbcTypeResult(rs, 1, jdbcType); } } static class TrueRowMapper implements RowMapper { public Object mapRow(ResultSet rs, int rowNumber) throws SQLException { return true; } } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.database; import org.apache.velocity.VelocityContext; import org.apache.velocity.context.Context; import org.hivedb.Schema; import org.hivedb.Schema.TrueRowMapper; import org.hivedb.meta.PartitionDimension; import org.hivedb.meta.Resource; import org.hivedb.meta.SecondaryIndex; import org.hivedb.meta.persistence.CachingDataSourceProvider; import org.hivedb.meta.persistence.IndexSchema; import org.hivedb.meta.persistence.TableInfo; import org.hivedb.util.Templater; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.PreparedStatementCreatorFactory; import java.sql.SQLException; import java.util.*;  public class Schemas { private static Map<String, Set<Schema>> dataSchemas = new HashMap<String, Set<Schema>>(); private static Map<String, IndexSchema> indexSchemas = new HashMap<String, IndexSchema>(); public static Context getContext(String uri) { Context context = new VelocityContext(); context.put(\"dialect\", DriverLoader.discernDialect(uri)); for (HiveDbDialect d : HiveDbDialect.values()) { context.put(DialectTools.dialectToString(d).toLowerCase(), d); } context.put(\"booleanType\", DialectTools.getBooleanTypeForDialect(DriverLoader.discernDialect(uri))); context.put(\"sequenceModifier\", DialectTools.getNumericPrimaryKeySequenceModifier(DriverLoader.discernDialect(uri))); return context; } public static String getCreatePrimaryIndex(PartitionDimension partitionDimension) { Context context = getContext(partitionDimension.getIndexUri()); context.put(\"tableName\", getPrimaryIndexTableName(partitionDimension)); context.put(\"indexType\", addLengthForVarchar(JdbcTypeMapper.jdbcTypeToString(partitionDimension.getColumnType()))); return Templater.render(\"sql/primary_index.vsql\", context); } public static String getCreateSecondaryIndex(SecondaryIndex secondaryIndex, PartitionDimension partitionDimension) { Context context = getContext(partitionDimension.getIndexUri()); context.put(\"tableName\", getSecondaryIndexTableName(secondaryIndex)); context.put(\"indexType\", addLengthForVarchar(JdbcTypeMapper.jdbcTypeToString(secondaryIndex.getColumnInfo().getColumnType()))); context.put(\"resourceType\", addLengthForVarchar(JdbcTypeMapper.jdbcTypeToString(secondaryIndex.getResource().getColumnType()))); return Templater.render(\"sql/secondary_index.vsql\", context); } public static String getCreateResourceIndex(Resource resource, PartitionDimension partitionDimension) { Context context = getContext(partitionDimension.getIndexUri()); context.put(\"tableName\", getResourceIndexTableName(resource)); context.put(\"indexType\", addLengthForVarchar(JdbcTypeMapper.jdbcTypeToString(resource.getIdIndex().getColumnInfo().getColumnType()))); context.put(\"primaryIndexType\", addLengthForVarchar(JdbcTypeMapper.jdbcTypeToString(resource.getPartitionDimension().getColumnType()))); return Templater.render(\"sql/resource_index.vsql\", context); }  public static String getPrimaryIndexTableName(PartitionDimension partitionDimension) { return \"hive_primary_\" + partitionDimension.getName().toLowerCase(); }  public static String getSecondaryIndexTableName(SecondaryIndex secondaryIndex) { return \"hive_secondary_\" + secondaryIndex.getResource().getName().toLowerCase() + \"_\" + secondaryIndex.getColumnInfo().getName(); }  public static String getResourceIndexTableName(Resource resource) { return \"hive_resource_\" + resource.getName().toLowerCase(); } public static Collection<TableInfo> getTables(PartitionDimension partitionDimension) { Collection<TableInfo> TableInfos = new ArrayList<TableInfo>(); TableInfos.add(new TableInfo(getPrimaryIndexTableName(partitionDimension), getCreatePrimaryIndex(partitionDimension))); for (Resource resource : partitionDimension.getResources()) { if (!resource.isPartitioningResource()) TableInfos.add(new TableInfo(getResourceIndexTableName(resource), getCreateResourceIndex(resource, partitionDimension))); for (SecondaryIndex secondaryIndex : resource.getSecondaryIndexes()) TableInfos.add(new TableInfo( getSecondaryIndexTableName(secondaryIndex), getCreateSecondaryIndex(secondaryIndex, partitionDimension))); } return TableInfos; } public static String addLengthForVarchar(String type) { if (type.equals(\"VARCHAR\")) { return \"VARCHAR(255)\"; } return type; } public static String ifMySql(String sql, HiveDbDialect dialect) { return (dialect.equals(HiveDbDialect.MySql) ? sql : \"\"); } public static void install(Schema schema, String uri) { for (TableInfo table : schema.getTables(uri)) { createTable(table, uri); } if (dataSchemas.get(uri) == null) { dataSchemas.put(uri, new HashSet<Schema>()); } dataSchemas.get(uri).add(schema); } public static void uninstall(Schema schema, String uri) { for (TableInfo table : schema.getTables(uri)) { emptyTable(table, uri); } if (dataSchemas.get(uri) != null) { dataSchemas.get(uri).remove(schema); } } public static void install(PartitionDimension partitionDimension) { for (TableInfo table : getTables(partitionDimension)) { createTable(table, partitionDimension.getIndexUri()); } if (indexSchemas.get(partitionDimension.getIndexUri()) == null) { indexSchemas.put(partitionDimension.getIndexUri(), new IndexSchema(partitionDimension)); } } public static void uninstall(PartitionDimension partitionDimension) { for (TableInfo table : getTables(partitionDimension)) { emptyTable(table, partitionDimension.getIndexUri()); } indexSchemas.remove(partitionDimension.getIndexUri()); } public static Collection<Schema> getDataSchemas(String uri) { return dataSchemas.get(uri) == null ? new HashSet<Schema>() : Collections.unmodifiableCollection(new HashSet<Schema>(dataSchemas.get(uri))); } public static IndexSchema getIndexSchema(String uri) { return indexSchemas.get(uri); }  public static boolean tableExists(String tableName, String uri) { JdbcTemplate t = new JdbcTemplate(CachingDataSourceProvider.getInstance().getDataSource(uri)); try { t.query( \"select * from \" + tableName + ifMySql(\" LIMIT 1\",DriverLoader.discernDialect(uri)), new TrueRowMapper()); return true; } catch (Exception e) { return false; } }  public static void createTable(TableInfo table, String uri) { JdbcTemplate t = new JdbcTemplate(CachingDataSourceProvider.getInstance().getDataSource(uri)); if (! tableExists(table.getName(), uri)) { final String createStatement = table.getCreateStatement(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( createStatement); t.update(creatorFactory.newPreparedStatementCreator(new Object[] {})); } } public static void emptyTables(Schema schema, String uri) { for (TableInfo table : schema.getTables(uri)) { emptyTable(table, uri); } } public static void emptyTable(TableInfo table, String uri) { JdbcTemplate t = new JdbcTemplate(CachingDataSourceProvider.getInstance().getDataSource(uri)); if (tableExists(table.getName(), uri)) { final String createStatement = table.getDeleteAllStatement(); PreparedStatementCreatorFactory creatorFactory = new PreparedStatementCreatorFactory( createStatement); t.update(creatorFactory.newPreparedStatementCreator(new Object[] {})); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.database; public class SqlUtils { public static String camelToSql(String name) { return name.replaceAll(\"([A-Z])\", \"_$1\").toLowerCase(); } public static String singularize(String plural) { return plural.replaceAll(\"s$\", \"\"); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.database; import org.springframework.jdbc.core.PreparedStatementCreatorFactory; public class Statements {  public static PreparedStatementCreatorFactory newStmtCreatorFactory(String sql, int... types) { return new PreparedStatementCreatorFactory(sql, types); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.Collection; import java.util.Collections;  public abstract class Actor<T>{ private Object obj; public Actor(Object obj) { this.obj = obj; } public abstract void f(T t); @SuppressWarnings(\"unchecked\") public void perform() { if (obj instanceof Collection) for (T t : (Collection<T>)obj) f(t); else f((T)obj); } @SuppressWarnings(\"unchecked\") public static Collection<Object> forceCollection(Object obj) { if (obj == null) return Collections.emptyList(); if (obj instanceof Collection) return (Collection<Object>)obj; return Collections.singletonList(obj); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import org.hivedb.util.PrimitiveUtils; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.Map; public class Amass { public static<C,R> R join(Joiner<C,R> joiner, Iterable<C> iterable, R initialValue) { R result = null; for (C item : iterable) { if (result == null) result = initialValue; result = joiner.f(item,result); } return result; } public static<C,R> R min(final Unary<C,R> unary, Iterable<C> iterable, final Class<R> primitiveType) { return Amass.join( new Joiner<C, R>() { public R f(C c, R result) { return (R) PrimitiveUtils.getMinFunction(primitiveType).f(result, unary.f(c)); }}, iterable, PrimitiveUtils.getMinValue(primitiveType)); } public static<C,R> R max(final Unary<C,R> unary, Iterable<C> iterable, final Class<R> primitiveType) { return Amass.join( new Joiner<C, R>() { public R f(C c, R result) { return (R) PrimitiveUtils.getMaxFunction(primitiveType).f(result, unary.f(c)); }}, iterable, PrimitiveUtils.getMaxValue(primitiveType)); }  public static<C> C join(Joiner<C,C> joiner, Iterable<C> iterable) { C result = null; for (C item : iterable) { result = (result == null) ? item : joiner.f(item,result); } return result; } public static<C> String joinByToString(Joiner<C,String> joiner, Iterable<C> iterable) { String result = \"\"; for (C item : iterable) { result = (result == null) ? item.toString() : joiner.f(item,result); } return result; }  public static<C,R> R join(Joiner<C,R> joiner, Unary<C,R> firstCall, Iterable<C> iterable) { R result = null; for (C item : iterable) { result = (result == null) ?firstCall.f(item) :joiner.f(item,result); } return result; }  public static<C1,C2,R> R merge(Merger<C1,C2,R> merger, Iterable<C1> iterable1, Iterable<C2> iterable2, R initialValue) { R result = null; Iterator<C1> iterator1 = iterable1.iterator(); Iterator<C2> iterator2 = iterable2.iterator(); while (iterator1.hasNext() && iterator2.hasNext()) { if (result == null) result = initialValue; result = merger.f(iterator1.next(), iterator2.next(), result); } return result; }  @SuppressWarnings(\"unchecked\") public static <T> MergeResult mergeTerciary(Unary<T,T> leftOnly, Unary<T,T> both, Unary<T,T> rightOnly, Iterable<T> leftIterable, Iterable<T> rightIterable) { "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.*; public class Atom { public static<T> T getFirst(Iterable<? extends T> iterable) throws Exception { for (T item : iterable) return item; throw new Exception(\"Iterable has no items\"); } public static<T> T getFirstOrThrow(Iterable<? extends T> iterable) { for (T item : iterable) return item; throw new NoSuchElementException(\"Iterable has no items\"); } public static<T> T getFirstOrNull(Iterable<? extends T> iterable) { for (T item : iterable) return item; return null; } public static Object getFirstOrDefault(Iterable<?> iterable, Object defaultItem) { for (Object item : iterable) return item; return defaultItem; } public static Class<?> getClassFirstOrDefault(Iterable<?> iterable, Class<?> defaultClass) { for (Object item : iterable) return item.getClass(); return defaultClass; } public static<T> Collection<T> getRest(Iterable<? extends T> iterable) throws Exception { List<T> results = new ArrayList<T>(); for (T item: iterable) results.add(item); if (results.size() == 0) throw new Exception(\"Iterable has no items\"); results.remove(0); return results; } public static<T> Collection<T> getRestOrThrow(Iterable<? extends T> iterable) { try { return getRest(iterable); } catch (Exception e) { throw new NoSuchElementException(e.getMessage()); } } public static<T> T getFirst(T[] array) throws Exception { if(array.length == 0) throw new Exception(\"Array has no items\"); else return array[0]; } public static<T> T getFirstOrThrow(T[] array) { if(array.length == 0) throw new NoSuchElementException(\"Array has no items\"); else return array[0]; } public static<T> T getFirstOrNull(T[] array) { if(array.length == 0) return null; else return array[0]; } public static<T> T getLast(Iterable<? extends T> iterable) throws Exception { Iterator<? extends T> i = iterable.iterator(); T item = null; while( i.hasNext()) item = i.next(); if( item != null) return item; else throw new Exception(\"Iterable has no items\"); } public static<T> T getLastOrThrow(Iterable<? extends T> iterable) { Iterator<? extends T> i = iterable.iterator(); T item = null; while( i.hasNext()) item = i.next(); if( item != null) return item; else throw new NoSuchElementException(\"Iterable has no items\"); } public static<T> T getLastOrNull(Iterable<? extends T> iterable) { Iterator<? extends T> i = iterable.iterator(); T item = null; while( i.hasNext()) item = i.next(); return item; } public static<T> T getLast(T[] array) throws Exception { if(array.length > 0) return array[array.length-1]; else throw new Exception(\"Array has no items\"); } public static<T> T getLastOrThrow(T[] array) { if(array.length > 0) return array[array.length-1]; else throw new NoSuchElementException(\"Array has no items\"); } public static<T> T getLastOrNull(T[] array) { if(array.length > 0) return array[array.length-1]; else return null; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface Binary<I1, I2, R> { public abstract R f(I1 item1, I2 item2); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; import org.hibernate.shards.util.Lists; public class Collect { public static abstract class Function<R> {public abstract R f();} @SuppressWarnings(\"unchecked\") public static<R> Collection<R> create(Function<R> function, Iterator iterator) { List<R> list = new ArrayList<R>(); for (;iterator.hasNext();iterator.next()) list.add(function.f()); return list; } public static<I,R> Collection<R> amass(Unary<I,R> function, Iterable<I> iterable) { List<R> list = new ArrayList<R>(); Iterator<I> iterator = iterable.iterator(); while(iterator.hasNext()) list.add(function.f(iterator.next())); return list; } public static<T> Pair<Collection<T>,Collection<T>> diff(Collection<T> left, Collection<T> right) { Collection<T> leftOnly = new ArrayList<T>(); Collection<T> rightOnly = new ArrayList<T>(); for(T item : left) if(!right.contains(item)) leftOnly.add(item); for(T item : right) if(!left.contains(item)) rightOnly.add(item); return new Pair<Collection<T>, Collection<T>>(leftOnly,rightOnly); } @SuppressWarnings(\"unchecked\") public static<T> Collection<T> recastCollection(Collection<?> c) { Collection<T> recast = Lists.newArrayList(); for(Object o : c) recast.add((T) o); return recast; } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; import java.util.Collection; import java.util.Hashtable; import java.util.Map; import java.util.Set; import org.hivedb.util.classgen.ReflectionTools; public class DebugMap<K,V> implements Map<K,V> { protected Map<K,V> map; protected boolean showHashes; public DebugMap() { map = new Hashtable<K,V>(); } public DebugMap(Map<K,V> map) { this.map = map; } public DebugMap(Map<K,V> map, boolean showHashes) { this.map = map; this.showHashes = showHashes; } public void clear() { map.clear(); } public boolean containsKey(Object key) { return map.containsKey(key); } public boolean containsValue(Object value) { return map.containsValue(value); } public Set<java.util.Map.Entry<K, V>> entrySet() { return map.entrySet(); } public V get(Object key) { if (!map.containsKey(key)) throw new RuntimeException( String.format(\"Map does not contain the key %s.\\nHere are the map contents:%s\", key.toString(), this.toString())); return map.get(key); } public boolean isEmpty() { return map.isEmpty(); } public Set<K> keySet() { return map.keySet(); } public V put(K key, V value) { return map.put(key, value); } public void putAll(Map<? extends K, ? extends V> t) { map.putAll(t); } public V remove(Object key) { return map.remove(key); } public int size() { return map.size(); } public Collection<V> values() { return map.values(); } public String toString() { return (String)Amass.join( new Joiner.ConcatStrings<String>(\"\\n\"), Transform.map(new Unary<Entry<K,V>, String>() { public String f(Entry entry) { final Object key = entry.getKey(); final Object value = entry.getValue(); return (key != null ? key.toString() : \"null\") + \" -> \" + (value != null ? value.toString() : \"null\") + (showHashes ? \"(Hash: \" + makeHashCode(entry) + \")\" : \"\"); }}, map.entrySet()), \"\"); } private int makeHashCode(Entry entry) { if (entry.getValue() == null) return 0; return ReflectionTools.doesImplementOrExtend(entry.getValue().getClass(), Collection.class) ? Amass.makeHashCode((Collection)entry.getValue()) : entry.getValue().hashCode(); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface Delay<T> { T f(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class DelayForArgument<A, T> { public abstract T f(A a); private T delayed; public T advance(A a) { delayed = f(a); return delayed; } public T get() { return delayed; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface DelayedTry<T> { T f() throws Exception; }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class ExceptionalActor<T,E extends Exception> { private Object obj; public ExceptionalActor(Object obj) { this.obj = obj; } public abstract void f(T t) throws E; }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import org.hivedb.util.functional.Transform.IdentityFunction; import java.util.*; public abstract class Filter {  public abstract<T> Collection<T> f(Iterable<? extends T> iterable); public static<T> Collection<T> grep(Predicate<T> filterer, Iterable<? extends T> iterable) { List<T> list = new ArrayList<T>(); for (T item : iterable) if (filterer.f(item)) list.add(item); return list; } public static<T> Collection<T> grep(Predicate<T> filterer, T[] array) { return grep(filterer, Arrays.asList(array)); } public static<T> T grepSingle(Predicate<T> filterer, Iterable<? extends T> iterable) throws NoSuchElementException { T match = grepSingleOrNull(filterer, iterable); if (match != null) return match; throw new NoSuchElementException(\"No match found\"); } public static<T> T grepSingleOrNull(Predicate<T> filterer, Iterable<? extends T> iterable) throws NoSuchElementException { for (T item : iterable) if (filterer.f(item)) return item; return null; }  public static<T,R> Collection<T> grepUnique(Unary<T,R> unary, Iterable<? extends T> iterable) { Map<R,T> results = new Hashtable<R, T>(); for (T item : iterable) { R result = unary.f(item); if (!results.containsKey(result)) results.put(result, item); } return results.values(); } public static<T,R> Collection<T> grepUnique(Iterable<? extends T> iterable) { return grepUnique(new IdentityFunction<T>(), iterable); } public static<T> T getFirst(Iterable<? extends T> iterable) throws NoSuchElementException { Iterator<? extends T> iterator = iterable.iterator(); if (iterator.hasNext()) return iterator.next(); throw new NoSuchElementException(\"No first element of the iterable exists\"); } public static Boolean hasFirst(Iterable iterable) { return iterable.iterator().hasNext(); } public static<T> T getFirst(T[] array) throws NoSuchElementException { if (array.length > 0) return array[0]; throw new NoSuchElementException(\"No first element of the array exists\"); } public static Boolean hasFirst(Object[] array) { return array.length > 0; } public static<T> Boolean isMatch(final Predicate<T> filterer, Iterable<? extends T> iterable) { for (T item : iterable) if (filterer.f(item)) return true; return false; } public static<T> Boolean isMatch(final Predicate<T> filterer, T[] array) { return isMatch(filterer, Arrays.asList(array)); } "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public class Function { }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; public class Generate { public static<R> Collection<R> create(Generator<R> function, Iterator iterator) { List<R> list = new ArrayList<R>(); for (;iterator.hasNext();iterator.next()) list.add(function.generate()); return list; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface Generator<R> {public abstract R generate();}"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface GetFunction<T> { public abstract T get(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class GetSetFunction { public abstract Object get(); public abstract void set(Object value); public abstract Class getFieldClass(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.lang.reflect.Method; import java.util.Arrays; import org.hivedb.util.AccessorFunction; import org.hivedb.util.classgen.ReflectionTools; public class GetSetReflectionFunction { public static<T> AccessorFunction<Object> CreateFunction(final Class fieldClass, final T instance, final String memberName) { return new AccessorFunction<Object>() { public Object get() { return invokeGetter(instance, ReflectionTools.capitalize(memberName)); } public void set(Object value) { invokeSetter(instance, ReflectionTools.capitalize(memberName), value); } public Class getFieldClass() { return getGetterMethod(instance, ReflectionTools.capitalize(memberName)).getReturnType(); } }; } private static Object invokeGetter(Object instance, final String memberName) { try { return getGetterMethod(instance, memberName).invoke(instance, new Object[] {}); } catch (Exception exception) { throw new RuntimeException(\"Exception invoiking method get\" + memberName, exception); } } private static Method getGetterMethod(Object instance, final String memberName) { try { return instance.getClass().getMethod(\"get\"+memberName, new Class[] {}); } catch (Exception exception) { throw new RuntimeException(\"Exception looking up method get\" + memberName, exception); } } private static void invokeSetter(Object instance, String memberName, Object value) { String setterName = \"set\"+memberName; final String memberNameFinal = memberName; "}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; import org.hivedb.util.AccessorFunction; public class GetSetWrapperFunction<T> extends AccessorFunction<T> { Class<T> fieldClass; T fieldValue; public GetSetWrapperFunction(final Class<T> fieldClass, T fieldValue) { this.fieldClass = fieldClass; this.fieldValue = fieldValue; } public Class getFieldClass() { return fieldClass; } public T get() { return fieldValue; } public void set(T value) { fieldValue = value; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.sql.Timestamp; import java.util.Collection; import java.util.Date; import java.util.HashSet; import org.hivedb.util.classgen.ReflectionTools; public abstract class Joiner<C,R> { public abstract R f(C item, R result); public static class ConcatStrings<C> extends Joiner<C, String> { String separator; public ConcatStrings(String separator) { this.separator = separator; } public String f(C item, String result) { return result + separator + item.toString(); } }  public static class ConcatHashCodesOfValues extends Joiner<Object, String> { public String f(Object item, String result) { return (result != null ? result : \"\") + hashItem(item); } } public static String hashItem(Object item) { int hash; if (item == null) return \"\"; else if(ReflectionTools.doesImplementOrExtend(item.getClass(), Collection.class)) hash = new HashSet<Object>((Collection<Object>) item).hashCode(); else if (item instanceof Date) hash = new Long(((Date)item).getTime()).hashCode(); "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Map.Entry;  public class Maps { public static<K,V> Map<K,V> newHashMap() { return new HashMap<K, V>(); } public static<I1,I2,V,R> Map<I1, Map<I2, Entry<V,R>>> dig( final Ternary<I1,I2,V,R> mapper, final Unary<I2,V> getV, final Unary<I1,Collection<I2>> getI2Collection, final Collection<I1> collection ) { return Transform.toMap( new Transform.IdentityFunction<I1>(), new Unary<I1, Map<I2, Entry<V,R>>>() { public Map<I2, Entry<V,R>> f(final I1 i1) { return Transform.toMap( new Transform.IdentityFunction<I2>(), new Unary<I2, Entry<V,R>>() { public Entry<V,R> f(I2 i2) { V v = getV.f(i2); return new Pair<V,R>( v, mapper.f(i1, i2, v)); }}, getI2Collection.f(i1)); }}, collection); } public static<I1,I2,V,R> Map<I1, Map<I2, Entry<V,R>>> digMap( final Ternary<I1,I2,V,R> mapper, Map<I1, Map<I2, V>> map) { return Transform.toMap( new Transform.MapToKeyFunction<I1,Map<I2, V>>(), new Unary<Entry<I1,Map<I2, V>>, Map<I2, Entry<V,R>>>() { public Map<I2, Entry<V,R>> f(final Entry<I1,Map<I2, V>> entry1) { return Transform.toMap( new Transform.MapToKeyFunction<I2,V>(), new Unary<Entry<I2, V>, Entry<V,R>>() { public Entry<V,R> f(Entry<I2, V> entry2) { return new Pair<V,R>( entry2.getValue(), mapper.f(entry1.getKey(), entry2.getKey(), entry2.getValue())); }}, entry1.getValue().entrySet()); }}, map.entrySet()); }  public static<I1,I2,R> Map<I1, Collection<R>> digMapToCollection( final Binary<I1,I2,R> mapper, Map<I1, Collection<I2>> map) { return Transform.toMap( new Transform.MapToKeyFunction<I1,Collection<I2>>(), new Unary<Entry<I1,Collection<I2>>, Collection<R>>() { public Collection<R> f(final Entry<I1,Collection<I2>> entryI1I2) { return Transform.map(new Unary<I2,R>() { public R f(I2 i2) { return mapper.f(entryI1I2.getKey(), i2); }}, entryI1I2.getValue()); }}, map.entrySet()); }  public static<I1,I2,I3,R> Map<I1, Map<I2, Collection<R>>> digMapToCollection( final Ternary<I1,I2,I3,R> mapper, Map<I1, Map<I2, Collection<I3>>> map) { return Transform.toMap( new Transform.MapToKeyFunction<I1,Map<I2,Collection<I3>>>(), new Unary<Entry<I1,Map<I2, Collection<I3>>>, Map<I2, Collection<R>>>() { public Map<I2, Collection<R>> f(final Entry<I1,Map<I2, Collection<I3>>> entryI1I2) { return Transform.toMap( new Transform.MapToKeyFunction<I2, Collection<I3>>(), new Unary<Entry<I2, Collection<I3>>, Collection<R>>() { public Collection<R> f(final Entry<I2, Collection<I3>> entryI2I3) { return Transform.map(new Unary<I3,R>() { public R f(I3 i3) { return mapper.f(entryI1I2.getKey(), entryI2I3.getKey(), i3); }}, entryI2I3.getValue()); }}, entryI1I2.getValue().entrySet()); }}, map.entrySet()); }  public static<I1,I2,I3,I4,R> Map<I1, Map<I2, Map<I3, Collection<R>>>> digMapToCollection( final Quaternary<I1,I2,I3,I4,R> mapper, Map<I1, Map<I2, Map<I3, Collection<I4>>>> map) { return Transform.toMap( new Transform.MapToKeyFunction<I1,Map<I2, Map<I3,Collection<I4>>>>(), new Unary<Entry<I1,Map<I2, Map<I3,Collection<I4>>>>, Map<I2, Map<I3,Collection<R>>>>() { public Map<I2, Map<I3,Collection<R>>> f(final Entry<I1,Map<I2, Map<I3,Collection<I4>>>> entryI1I2) { return Transform.toMap( new Transform.MapToKeyFunction<I2, Map<I3,Collection<I4>>>(), new Unary<Entry<I2, Map<I3,Collection<I4>>>, Map<I3,Collection<R>>>() { public Map<I3,Collection<R>> f(final Entry<I2, Map<I3,Collection<I4>>> entryI2I3) { return Transform.toMap( new Transform.MapToKeyFunction<I3, Collection<I4>>(), new Unary<Entry<I3,Collection<I4>>, Collection<R>>() { public Collection<R> f(final Entry<I3,Collection<I4>> entryI3I4) { return Transform.map(new Unary<I4,R>() { public R f(I4 i4) { return mapper.f(entryI1I2.getKey(), entryI2I3.getKey(), entryI3I4.getKey(), i4); }}, entryI3I4.getValue()); }}, entryI2I3.getValue().entrySet()); }}, entryI1I2.getValue().entrySet()); }}, map.entrySet()); } public static<T> Map<Integer, T> hashCodeMap(Collection<T> items) { return Transform.toMap(new Unary<T, Integer>(){ public Integer f(T item) { return item.hashCode(); }}, new Transform.IdentityFunction<T>(), items); } public static<T> Map<Integer, T> hashCodeMap(T... items) { return hashCodeMap(Arrays.asList(items)); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface Merger<C1,C2,R> { R f(C1 item1, C2 item2, R result); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; import java.util.Iterator; public class NumberIterator implements Iterator<Integer>, Iterable<Integer> { int number; int current=0; public NumberIterator(int start, int end) { this.current = start; this.number = end; } public NumberIterator(int number) { this.number = number; } public boolean hasNext() { return current < number; } public Integer next() { return ++current; } public void remove() { } public Iterator<Integer> iterator() { return this; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.Collection; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.Map; import java.util.Set; class OrderedDebugMap<K,V> extends DebugMap<K,V> { public OrderedDebugMap() { map = new LinkedHashMap<K,V>(); } public void clear() { map.clear(); } public boolean containsKey(Object key) { return map.containsKey(key); } public boolean containsValue(Object value) { return map.containsValue(value); } public Set<java.util.Map.Entry<K, V>> entrySet() { return new LinkedHashSet<Entry<K,V>>( Transform.map(new Unary<K, Map.Entry<K,V>>() { public Map.Entry<K,V> f(K item) { return new Pair<K,V>(item, map.get(item)); }}, map.keySet())); } public V get(Object key) { if (!map.containsKey(key)) throw new RuntimeException( String.format(\"Map does not contain the key %s.\\nHere are the map contents:%s\", key.toString(), this.toString())); return map.get(key); } public boolean isEmpty() { return map.isEmpty(); } public Set<K> keySet() { return map.keySet(); } public V put(K key, V value) { return map.put(key, value); } public void putAll(Map<? extends K, ? extends V> t) { map.putAll(t); } public V remove(Object key) { return map.remove(key); } public int size() { return map.size(); } public Collection<V> values() { return map.values(); } public String toString() { return (String)Amass.join( new Joiner.ConcatStrings<String>(\"\\n\"), Transform.map(new Unary<Entry<K,V>, String>() { public String f(Entry<K,V> entry) { return entry.getKey().toString() + \" -> \" + entry.getValue().toString(); }}, map.entrySet())); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.Map.Entry; public class Pair<K,V> implements Entry<K,V> { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } public V setValue(V value) { this.value = value; return value; } public String toString() { return String.format(\"%s : %s\", getKey(), getValue()); } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; import java.util.Map; public class PairIterator<T> implements Iterator<Map.Entry<T,T>>, Iterable<Map.Entry<T,T>> { private int size; private List<T> pairs; private int current=0; public PairIterator(Collection<T> pairs) { this.pairs = new ArrayList<T>(pairs); if (pairs.size() % 2 != 0) throw new RuntimeException(String.format(\"Uneven number of items in collection: %s\", pairs)); this.size = pairs.size(); } public boolean hasNext() { return current < size; } public Map.Entry<T,T> next() { current+=2; return new Pair<T,T>(pairs.get(current-2), pairs.get(current-1)); } public void remove() { } public Iterator<Map.Entry<T,T>> iterator() { return this; } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; public interface Predicate<T> { public boolean f(final T item); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class Quaternary<I1, I2, I3, I4, R> { public abstract R f(I1 item1, I2 item2, I3 item3, I4 item4); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.Hashtable; import java.util.Map; public class QuickCache { Map<Object, Object> cache = new Hashtable<Object, Object>(); @SuppressWarnings(\"unchecked\") public<T> T get(Object key, Delay<T> delay) { if (!cache.containsKey(key)) cache.put(key, delay.f()); return (T) cache.get(key); } }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; import java.util.Collection; import java.util.Iterator; public class RingIteratorable<T> implements Iterator<T>, Iterable<T> { Collection<? extends T> collection; Iterator<? extends T> iterator; int stopAfterThisManyCalls = -1; int numberOfCalls; public RingIteratorable(Collection<? extends T> collection) { this.collection = collection; this.iterator = collection.iterator(); } public RingIteratorable(Collection<? extends T> collection, int stopAfterThisManyCalls) { this.collection = collection; this.iterator = collection.iterator(); this.stopAfterThisManyCalls = stopAfterThisManyCalls; } public boolean hasNext() { return (stopAfterThisManyCalls < 0 || numberOfCalls < stopAfterThisManyCalls); } public T next() { if (stopAfterThisManyCalls >=0) numberOfCalls++; if (!iterator.hasNext()) iterator = collection.iterator(); return iterator.next(); } public void remove() {} public Iterator<T> iterator() { return this; } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class Runtimer<T> implements DelayedTry<T> { public T go() { try { return f(); } catch (Exception e) { throw new RuntimeException(e); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface SetFunction<T> { public abstract void set(T value); public abstract Class getFieldClass(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class Ternary<I1, I2, I3, R> { public abstract R f(I1 item1, I2 item2, I3 item3); }"}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; public interface Toss { void f() throws Exception; }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Map.Entry; "}
{"name": "britt/hivedb", "content": " package org.hivedb.util.functional; import java.util.Collection; import java.util.Iterator; class TransformRingIterator<INPUT, OUTPUT> implements Iterator<OUTPUT> { Collection<INPUT> collection; Iterator<INPUT> iterator; Unary<INPUT,OUTPUT> transformFunction; public TransformRingIterator(Unary<INPUT,OUTPUT> transformFunction, Collection<INPUT> collection) { this.collection = collection; this.iterator = collection.iterator(); this.transformFunction = transformFunction; } public OUTPUT next() { if (!iterator.hasNext()) iterator = collection.iterator(); return transformFunction.f(iterator.next()); } public boolean hasNext() { return true; } public void remove() {} }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class TryCatch<T> { abstract T t() throws Exception; abstract T c(Exception e); public T go() { try { return t(); } catch (Exception e) { return c(e); } } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public abstract class TryFail<T> extends TryCatch<T> { T c(Exception e) { throw new RuntimeException(e); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface Unary<I,R> { public R f(I item); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; import java.util.Stack; /** * Creates an undoable statement. Override the function f() with code that includes one or more anonymous overrides of the internal class Undo. * Note that the use of the function name f indicates that the class only has one method to override, and so is essentially a functor. * After constructing Undoable call f() and then undo() to run all constructed instances of Undo. Or call cycle() which calls f() followed by undo(). * * Synopsis: * final Foo foo; * try { * new Undoable() { public void f() { * "}
{"name": "britt/hivedb", "content": "package org.hivedb.util.functional; public interface VoidDelay { void f(); }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.validators; import org.hivedb.HiveRuntimeException;  public class NoValidator implements Validator { public boolean isValid(Object instance, String propertyName) {return true;} public void throwInvalid(Object instance, String propertyName) { throw new HiveRuntimeException(\"TrueValidator should never throw\"); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.validators; import org.hivedb.HiveRuntimeException; import org.hivedb.util.classgen.ReflectionTools; public class NonEmptyStringValidator implements Validator { public boolean isValid(Object instance, String propertyName) { Object obj = ReflectionTools.invokeGetter(instance, propertyName); if (!(obj instanceof String)) throw new HiveRuntimeException(\"Expected an instance of type String, but got \" + obj.getClass().getSimpleName()); String s = (String)obj; return s != null && s.length() > 0; } public void throwInvalid(Object instance, String propertyName) { throw new HiveRuntimeException(String.format(\"Property %s of class %s is an empty string for instance %s\", propertyName, instance.getClass().getSimpleName(), instance.toString())); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.validators; import org.hivedb.HiveRuntimeException; import org.hivedb.util.classgen.ReflectionTools; public class NonNegativeValidator implements Validator { public boolean isValid(Object instance, String propertyName) { Object obj = ReflectionTools.invokeGetter(instance, propertyName); if (!(obj instanceof Number)) throw new HiveRuntimeException(\"Expected an instance of type Number, but got \" + obj.getClass().getSimpleName()); Number num = (Number)obj; return obj.getClass().equals(long.class) || num.getClass().equals(Long.class) ? num.longValue() >= 0l : num.doubleValue() >= 0.0; } public void throwInvalid(Object instance, String propertyName) { throw new HiveRuntimeException(String.format(\"Property %s of class %s is negative for instance %s\", propertyName, instance.getClass().getSimpleName(), instance.toString())); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.validators; import org.hivedb.HiveRuntimeException; import org.hivedb.util.classgen.ReflectionTools; public class NonNullValidator implements Validator { public boolean isValid(Object instance, String propertyName) { Object obj = ReflectionTools.invokeGetter(instance, propertyName); return obj != null; } public void throwInvalid(Object instance, String propertyName) { throw new HiveRuntimeException(String.format(\"Property %s of class %s is null for instance %s\", propertyName, instance.getClass().getSimpleName(), instance.toString())); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.validators; import org.hivedb.HiveRuntimeException; import org.hivedb.util.classgen.ReflectionTools; public class NonZeroValidator implements Validator { public boolean isValid(Object instance, String propertyName) { Object obj = ReflectionTools.invokeGetter(instance, propertyName); if (obj.getClass().equals(Long.class) || obj.getClass().equals(Long.class )) return ((Number)obj).longValue() > 0l; if (obj.getClass().equals(Integer.class) || obj.getClass().equals(int.class)) return ((Number)obj).intValue() > 0; if (obj.getClass().equals(Short.class) || obj.getClass().equals(short.class)) return ((Number)obj).shortValue() > 0; throw new RuntimeException(String.format(\"Cannot validate Number of class %s\", obj.getClass().getSimpleName())); } public void throwInvalid(Object instance, String propertyName) { throw new HiveRuntimeException(String.format(\"Property %s of class %s is zero for instance %s\", propertyName, instance.getClass().getSimpleName(), instance.toString())); } }"}
{"name": "britt/hivedb", "content": "package org.hivedb.util.validators; public interface Validator { public boolean isValid(Object instance, String propertyName); public void throwInvalid(Object instance, String propertyName); }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.rails.queues.deployers; import org.jboss.ruby.enterprise.queues.deployers.AbstractRubyQueuesScanningDeployer; import org.jboss.virtual.VirtualFileFilter; import org.jboss.virtual.VisitorAttributes; import org.jboss.virtual.plugins.vfs.helpers.SuffixMatchFilter; public class RailsQueuesScanningDeployer extends AbstractRubyQueuesScanningDeployer { private static final String APP_QUEUES = \"app/queues/\"; private static final VirtualFileFilter QUEUE_FILTER = new SuffixMatchFilter(\"_queue.rb\", VisitorAttributes.DEFAULT); public RailsQueuesScanningDeployer() { setPath( APP_QUEUES ); setFilter( QUEUE_FILTER ); } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.rails.web.deployers; public abstract class AbstractRailsRackUpScriptProvider implements RailsRackUpScriptProvider { private int majorVersion; private int minorVersion; private int tinyVersion; protected AbstractRailsRackUpScriptProvider(int majorVersion, int minorVersion, int tinyVersion) { this.majorVersion = majorVersion; this.minorVersion = minorVersion; this.tinyVersion = tinyVersion; } public int getMajorVersion() { return this.majorVersion; } public int getMinorVersion() { return this.minorVersion; } public int getTinyVersion() { return this.tinyVersion; } public int compareTo(RailsRackUpScriptProvider that) { if (this.getMajorVersion() > that.getMajorVersion()) { return 1; } if (this.getMajorVersion() < that.getMajorVersion()) { return -1; } if (this.getMinorVersion() > that.getMinorVersion()) { return 1; } if (this.getMinorVersion() < that.getMinorVersion()) { return -1; } if (this.getTinyVersion() > that.getTinyVersion()) { return 1; } if (this.getTinyVersion() < that.getTinyVersion()) { return -1; } return 0; } public String toString() { return \"[RailsRackUpScriptProvider: major=\" + this.majorVersion + \"; minor=\" + this.minorVersion + \"; tiny=\"+ this.tinyVersion + \"]\"; } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.rails.web.deployers; public interface RackUpScriptProvider { String getRackUpScript(String context); }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.rails.web.deployers; public interface RailsRackUpScriptProvider extends RackUpScriptProvider, Comparable<RailsRackUpScriptProvider> { int getMajorVersion(); int getMinorVersion(); int getTinyVersion(); }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.rails.web.v2_2; import org.jboss.rails.web.deployers.AbstractRailsRackUpScriptProvider; public class Rails_v2_2_RackUpScriptProvider extends AbstractRailsRackUpScriptProvider { public Rails_v2_2_RackUpScriptProvider() { super(2, 0, 0 ); } public String getRackUpScript(String context) { if ( context.endsWith( \"/\" ) ) { context = context.substring( 0, context.length() - 1 ); } String script = \"require %q(org/jboss/rails/web/v2_2/rails_rack_dispatcher)\\n\" + \"::Rack::Builder.new {\\n\" + \" run JBoss::Rails::Rack::Dispatcher.new(%q(\"+ context + \"))\\n\" + \"}.to_app\\n\"; return script; } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.rails.web.v2_3; import org.jboss.rails.web.deployers.AbstractRailsRackUpScriptProvider; public class Rails_v2_3_RackUpScriptProvider extends AbstractRailsRackUpScriptProvider { public Rails_v2_3_RackUpScriptProvider() { super(2, 3, 0); } public String getRackUpScript(String context) { if ( context.endsWith( \"/\" ) ) { context = context.substring( 0, context.length() - 1 ); } String script = \"RELATIVE_URL_ROOT=%q(\" + context + \")\\n\" + \"require %q(org/jboss/rails/web/v2_3/rails_rack_dispatcher)\\n\" + \"::Rack::Builder.new {\\n\" + \" run ActionController::Dispatcher.new\\n\" + \"}.to_app\\n\"; return script; } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.core.deployers; import java.io.IOException; import java.net.MalformedURLException; import java.net.URISyntaxException; import java.net.URL; import org.jboss.deployers.spi.deployer.DeploymentStages; import org.jboss.deployers.vfs.spi.deployer.AbstractSimpleVFSRealDeployer; import org.jboss.deployers.vfs.spi.structure.VFSDeploymentUnit; import org.jboss.ruby.core.runtime.metadata.RubyLoadPathMetaData; import org.jboss.ruby.core.runtime.metadata.RubyRuntimeMetaData; import org.jboss.virtual.VirtualFile; public abstract class AbstractRubyLoadPathDescriber<T> extends AbstractSimpleVFSRealDeployer<T>{ public AbstractRubyLoadPathDescriber(Class<T> input) { super( input ); setStage( DeploymentStages.DESCRIBE ); addInput( RubyRuntimeMetaData.class ); addOutput( RubyRuntimeMetaData.class ); } protected void addLoadPath(VFSDeploymentUnit unit, URL url) { RubyRuntimeMetaData runtimeMetaData = unit.getAttachment( RubyRuntimeMetaData.class ); if ( runtimeMetaData == null ) { runtimeMetaData = new RubyRuntimeMetaData(); unit.addAttachment( RubyRuntimeMetaData.class, runtimeMetaData ); } RubyLoadPathMetaData loadPath = new RubyLoadPathMetaData(); loadPath.setURL( url ); runtimeMetaData.appendLoadPath( loadPath ); } protected void addLoadPath(VFSDeploymentUnit unit, VirtualFile file) throws MalformedURLException, URISyntaxException { addLoadPath( unit, file.toURL() ); } protected void addLoadPath(VFSDeploymentUnit unit, String path) throws IOException, URISyntaxException { VirtualFile child = unit.getRoot().getChild( path ); if ( child != null ) { addLoadPath( unit, child ); } } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.core.deployers; import java.io.IOException; import java.net.URISyntaxException; import java.util.List; import org.jboss.deployers.spi.DeploymentException; import org.jboss.deployers.spi.deployer.DeploymentStages; import org.jboss.deployers.spi.deployer.helpers.AbstractDeployer; import org.jboss.deployers.structure.spi.DeploymentUnit; import org.jboss.deployers.vfs.spi.structure.VFSDeploymentUnit; import org.jboss.ruby.core.runtime.metadata.RubyLoadPathMetaData; import org.jboss.ruby.core.runtime.metadata.RubyRuntimeMetaData; import org.jboss.virtual.VirtualFile; import org.jboss.virtual.VirtualFileFilter; public abstract class AbstractRubyScanningDeployer extends AbstractDeployer { private String path; private VirtualFileFilter filter; private boolean addToLoadPath; public AbstractRubyScanningDeployer() { setStage( DeploymentStages.PARSE ); } public void setPath(String path) { setPath( path, true ); } public void setPath(String path, boolean addToLoadPath) { this.path = path; this.addToLoadPath = addToLoadPath; } public String getPath() { return this.path; } public void setAddToLoadPath(boolean addToLoadPath) { this.addToLoadPath = addToLoadPath; } public boolean isAddToLoadPath() { return this.addToLoadPath; } public void setFilter(VirtualFileFilter filter) { this.filter = filter; } public VirtualFileFilter getFilter() { return this.filter; } public void deploy(DeploymentUnit unit) throws DeploymentException { if (!(unit instanceof VFSDeploymentUnit)) { throw new DeploymentException(\"Deployment unit must be a VFSDeploymentUnit\"); } deploy((VFSDeploymentUnit) unit); } protected void deploy(VFSDeploymentUnit unit) throws DeploymentException { try { VirtualFile scanRoot = unit.getRoot().getChild(this.path); if (scanRoot == null) { return; } if ( this.isAddToLoadPath() ) { RubyRuntimeMetaData runtimeMetaData = unit.getAttachment( RubyRuntimeMetaData.class ); if ( runtimeMetaData == null ) { runtimeMetaData = new RubyRuntimeMetaData(); unit.addAttachment( RubyRuntimeMetaData.class, runtimeMetaData ); } RubyLoadPathMetaData loadPath = new RubyLoadPathMetaData( scanRoot.toURL() ); runtimeMetaData.appendLoadPath( loadPath ); } List<VirtualFile> children = null; if ( this.filter != null ) { children = scanRoot.getChildrenRecursively( this.filter ); } else { children = scanRoot.getChildrenRecursively(); } int prefixLength = scanRoot.getPathName().length(); for ( VirtualFile child : children ) { String relativePath = child.getPathName().substring( prefixLength ); deploy( unit, child, relativePath.substring(1) ); } } catch (IOException e) { throw new DeploymentException(e); } catch (URISyntaxException e) { throw new DeploymentException(e); } } protected abstract void deploy(VFSDeploymentUnit unit, VirtualFile file, String relativePath) throws DeploymentException; }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.core.deployers; import java.io.IOException; import java.net.URISyntaxException; import org.jboss.deployers.spi.DeploymentException; import org.jboss.deployers.vfs.spi.structure.VFSDeploymentUnit; public class SimpleRubyLoadPathDescriber<T> extends AbstractRubyLoadPathDescriber<T> { private String path; public SimpleRubyLoadPathDescriber(Class<T> input) { super( input ); } protected void setPath(String path) { this.path = path; } protected String getPath() { return this.path; } @Override public void deploy(VFSDeploymentUnit unit, T root) throws DeploymentException { try { addLoadPath(unit, this.path); } catch (IOException e) { throw new DeploymentException( e ); } catch (URISyntaxException e) { throw new DeploymentException( e ); } } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.client; import java.net.InetSocketAddress; public class RubyClient { public static final String DEFAULT_NAMING_HOST = \"localhost\"; public static final int DEFAULT_NAMING_PORT = 1099; private static final ThreadLocal<RubyClient> threadClient = new ThreadLocal<RubyClient>(); private String applicationName; private InetSocketAddress namingAddress; protected RubyClient(String applicationName, String namingHost, int namingPort) { this.applicationName = applicationName; this.namingAddress = new InetSocketAddress( namingHost, namingPort ); } public String getApplicationName() { return this.applicationName; } public InetSocketAddress getNamingAddress() { return this.namingAddress; } public String getNamingUrl() { return \"jnp:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.endpoints.metadata; import java.util.Collection; import java.util.HashMap; import java.util.Map; public class RubyEndpointsMetaData { private Map<String, RubyEndpointMetaData> endpoints = new HashMap<String,RubyEndpointMetaData>(); public RubyEndpointsMetaData() { } public void addEndpoint(RubyEndpointMetaData endpoint) { this.endpoints.put( endpoint.getName(), endpoint ); } public RubyEndpointMetaData getEndpointByName(String name) { return this.endpoints.get( name ); } public Collection<RubyEndpointMetaData> getEndpoints() { return this.endpoints.values(); } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.jobs.deployers; import java.util.Set; import org.jboss.beans.metadata.spi.BeanMetaData; import org.jboss.beans.metadata.spi.builder.BeanMetaDataBuilder; import org.jboss.deployers.spi.DeploymentException; import org.jboss.deployers.spi.deployer.DeploymentStages; import org.jboss.deployers.spi.deployer.helpers.AbstractDeployer; import org.jboss.deployers.structure.spi.DeploymentUnit; import org.jboss.ruby.enterprise.jobs.RubyScheduler; import org.jboss.ruby.enterprise.jobs.metadata.RubyJobMetaData; public class RubySchedulerDeployer extends AbstractDeployer { public RubySchedulerDeployer() { setAllInputs( true ); setStage( DeploymentStages.PRE_REAL ); } public void deploy(DeploymentUnit unit) throws DeploymentException { Set<? extends RubyJobMetaData> allMetaData = unit.getAllMetaData( RubyJobMetaData.class ); if ( allMetaData.isEmpty() ) { return; } String beanName = getBeanName(unit); BeanMetaDataBuilder builder = BeanMetaDataBuilder.createBuilder( beanName, RubyScheduler.class.getName() ); builder.addPropertyMetaData( \"name\", \"RubyScheduler$\" + unit.getSimpleName() ); BeanMetaData beanMetaData = builder.getBeanMetaData(); unit.addAttachment( BeanMetaData.class.getName() + \"$\" + RubyScheduler.class.getName(), beanMetaData ); } public static String getBeanName(DeploymentUnit unit) { return \"jboss.ruby.jobs.scheduler.\" + unit.getSimpleName(); } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.jobs.metadata; import java.util.HashMap; import java.util.Map; public class RubyJobsMetaData { private Map<String,RubyJobMetaData> jobs = new HashMap<String,RubyJobMetaData>(); public RubyJobsMetaData() { } public void addJob(RubyJobMetaData job) { this.jobs.put( job.getName(), job ); } public RubyJobMetaData getJobByName(String name) { return this.jobs.get( name ); } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues; import org.jboss.logging.Logger; public class BaseQueueRb { private Logger logger; public BaseQueueRb() { } public void setLogger(Logger logger) { this.logger = logger; } public Logger getLogger() { return this.logger; } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues; import javax.jms.Message; import javax.jms.MessageListener; import javax.jms.ObjectMessage; import org.jboss.logging.Logger; import org.jboss.ruby.core.runtime.spi.RubyRuntimePool; import org.jruby.Ruby; import org.jruby.RubyModule; import org.jruby.javasupport.JavaEmbedUtils; import org.jruby.runtime.builtin.IRubyObject; public class BaseRubyMessageListener implements MessageListener { private static final Object[] EMPTY_OBJECT_ARRAY = {}; private static final Logger log = Logger.getLogger(BaseRubyMessageListener.class); private RubyRuntimePool pool; private String queueClassName; private String classLocation; public BaseRubyMessageListener(RubyRuntimePool pool, String queueClassName, String classLocation) { this.pool = pool; this.queueClassName = queueClassName; this.classLocation = classLocation; } public void onMessage(Message message) { log.info(\"handling message: \" + message); Ruby ruby = null; try { ruby = this.pool.borrowRuntime(); loadQueueClassLocation(ruby); RubyModule queueClass = ruby.getClassFromPath(this.queueClassName); Object queueInstance = JavaEmbedUtils.invokeMethod(ruby, queueClass, \"new\", EMPTY_OBJECT_ARRAY, Object.class); log.info(\"queueInstance is \" + queueInstance + \" "}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues; import java.io.Serializable; import java.net.InetSocketAddress; import java.util.Hashtable; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.MessageProducer; import javax.jms.ObjectMessage; import javax.jms.Session; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import org.jboss.logging.Logger; import org.jboss.ruby.enterprise.client.RubyClient; import org.jruby.Ruby; import org.jruby.RubyModule; import org.jruby.javasupport.JavaEmbedUtils; import org.jruby.runtime.builtin.IRubyObject; public class RubyTaskQueueClient { private static final Logger log = Logger.getLogger(RubyTaskQueueClient.class); private String destinationName; private InetSocketAddress namingAddress; public RubyTaskQueueClient() { RubyClient currentClient = RubyClient.getClientForCurrentThread(); if ( currentClient != null ) { this.namingAddress = currentClient.getNamingAddress(); } } public RubyTaskQueueClient(String namingHost) { this( namingHost, 1099 ); } public RubyTaskQueueClient(String namingHost, int namingPort) { this.namingAddress = new InetSocketAddress( namingHost, namingPort ); } public void setDestinationName(String destinationName) { this.destinationName = destinationName; } public void enqueue(String taskName, Object payload) throws NamingException, JMSException { Hashtable<String, String> env = new Hashtable<String, String>(); if ( this.namingAddress != null ) { env.put(Context.INITIAL_CONTEXT_FACTORY, \"org.jnp.interfaces.NamingContextFactory\"); String namingUrl = \"jnp:"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.MessageConsumer; import javax.jms.Session; import javax.naming.InitialContext; import javax.naming.NamingException; import org.jboss.logging.Logger; import org.jboss.ruby.core.runtime.spi.RubyRuntimePool; public class RubyTaskQueueHandler { private static final Logger log = Logger.getLogger(RubyTaskQueueHandler.class); private String destinationName; private Connection connection; private boolean enabled; private RubyRuntimePool runtimePool; private String queueClassName; private String queueClassLocation; public RubyTaskQueueHandler() { this.enabled = true; } public void setQueueName(String destination) { this.destinationName = destination; } public String getQueueName() { return this.destinationName; } public boolean isEnabled() { return this.enabled; } public void setEnabled(boolean enabled) { this.enabled = enabled; } public void setRubyRuntimePool(RubyRuntimePool runtimePool) { this.runtimePool = runtimePool; } public RubyRuntimePool getRubyRuntimePool() { return this.runtimePool; } public void setQueueClassName(String queueClassName) { this.queueClassName = queueClassName; } public String getQueueClassName() { return this.queueClassName; } public void setQueueClassLocation(String queueClassLocation) { this.queueClassLocation = queueClassLocation; } public String getQueueClassLocation() { return this.queueClassLocation; } public void start() throws NamingException, JMSException { if (!enabled) { return; } InitialContext jndiContext = new InitialContext(); "}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues.deployers; import org.jboss.deployers.spi.DeploymentException; import org.jboss.deployers.spi.deployer.DeploymentStages; import org.jboss.deployers.vfs.spi.structure.VFSDeploymentUnit; import org.jboss.ruby.core.deployers.AbstractRubyScanningDeployer; import org.jboss.ruby.core.util.StringUtils; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueueMetaData; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueuesMetaData; import org.jboss.virtual.VirtualFile; import org.jboss.virtual.VirtualFileFilter; import org.jboss.virtual.VisitorAttributes; import org.jboss.virtual.plugins.vfs.helpers.SuffixMatchFilter; public class AbstractRubyQueuesScanningDeployer extends AbstractRubyScanningDeployer { private static final VirtualFileFilter QUEUE_FILTER = new SuffixMatchFilter(\"_queue.rb\", VisitorAttributes.DEFAULT); public AbstractRubyQueuesScanningDeployer() { addInput(RubyTaskQueuesMetaData.class); addOutput(RubyTaskQueuesMetaData.class); setStage( DeploymentStages.POST_PARSE ); } public void deploy(VFSDeploymentUnit unit, VirtualFile queueClassFile, String relativePath) throws DeploymentException { RubyTaskQueuesMetaData metaData = unit.getAttachment(RubyTaskQueuesMetaData.class); if (metaData == null) { metaData = new RubyTaskQueuesMetaData(); unit.addAttachment(RubyTaskQueuesMetaData.class, metaData); } String simplePath = relativePath.substring(0, relativePath.length() - 3); String rubyClassName = StringUtils.camelize(simplePath ); rubyClassName = rubyClassName.replaceAll(\"\\\\.\", \"::\"); RubyTaskQueueMetaData queueMetaData = metaData.getQueueByClassName(rubyClassName); if (queueMetaData == null) { queueMetaData = new RubyTaskQueueMetaData(); queueMetaData.setQueueClassName(rubyClassName); metaData.addQueue(queueMetaData); } queueMetaData.setQueueClassLocation(simplePath); } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues.deployers; import java.io.IOException; import java.util.Map; import org.jboss.deployers.spi.DeploymentException; import org.jboss.deployers.spi.deployer.helpers.AbstractParsingDeployer; import org.jboss.deployers.structure.spi.DeploymentUnit; import org.jboss.deployers.vfs.spi.structure.VFSDeploymentUnit; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueueMetaData; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueuesMetaData; import org.jboss.virtual.VirtualFile; import org.jruby.util.ByteList; import org.jvyamlb.YAML; public class QueuesYamlParsingDeployer extends AbstractParsingDeployer { public static final String FILENAME = \"queues.yml\"; public QueuesYamlParsingDeployer() { addOutput(RubyTaskQueuesMetaData.class); } public void deploy(DeploymentUnit unit) throws DeploymentException { if (unit instanceof VFSDeploymentUnit) { deploy((VFSDeploymentUnit) unit); } } protected void deploy(VFSDeploymentUnit unit) throws DeploymentException { VirtualFile metaData = unit.getMetaDataFile(FILENAME); if (metaData != null) { parse(unit, metaData); } } @SuppressWarnings(\"unchecked\") protected void parse(VFSDeploymentUnit unit, VirtualFile file) throws DeploymentException { log.info(\"parsing \" + file); RubyTaskQueuesMetaData queues = unit.getAttachment(RubyTaskQueuesMetaData.class); if (queues == null) { queues = new RubyTaskQueuesMetaData(); } try { Map<ByteList, Map<ByteList, Object>> results = (Map<ByteList, Map<ByteList, Object>>) YAML.load(file.openStream()); if (results != null) { for (ByteList queueClassNameBytes : results.keySet()) { String queueClassName = queueClassNameBytes.toString(); RubyTaskQueueMetaData queue = queues.getQueueByClassName(queueClassName); if (queue == null) { queue = new RubyTaskQueueMetaData(); queue.setQueueClassName(queueClassName); queues.addQueue(queue); } log.info(\"added queue: \" + queue); Map<ByteList, Object> details = results.get(queueClassNameBytes); log.info(\"details: \" + details); if (details != null) { ByteList enabledKey = ByteList.create(\"enabled\"); Boolean enabled = (Boolean) details.get(enabledKey); if (enabled != null) { queue.setEnabled(enabled.booleanValue()); } } } } } catch (IOException e) { throw new DeploymentException(e); } if (queues != null && !queues.empty()) { unit.addAttachment(RubyTaskQueuesMetaData.class, queues); } } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues.deployers; import org.jboss.beans.metadata.spi.BeanMetaData; import org.jboss.beans.metadata.spi.ValueMetaData; import org.jboss.beans.metadata.spi.builder.BeanMetaDataBuilder; import org.jboss.deployers.spi.DeploymentException; import org.jboss.deployers.vfs.spi.deployer.AbstractSimpleVFSRealDeployer; import org.jboss.deployers.vfs.spi.structure.VFSDeploymentUnit; import org.jboss.ruby.core.runtime.deployers.RubyRuntimePoolDeployer; import org.jboss.ruby.enterprise.queues.RubyTaskQueueHandler; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueueMetaData; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueuesMetaData; public class RubyTaskQueueHandlersDeployer extends AbstractSimpleVFSRealDeployer<RubyTaskQueuesMetaData> { public RubyTaskQueueHandlersDeployer() { super(RubyTaskQueuesMetaData.class); addOutput(BeanMetaData.class); } public void deploy(VFSDeploymentUnit unit, RubyTaskQueuesMetaData queuesMetaData) throws DeploymentException { for (RubyTaskQueueMetaData queueMetaData : queuesMetaData.getQueues()) { deploy(unit, queueMetaData); } } public void deploy(VFSDeploymentUnit unit, RubyTaskQueueMetaData queueMetaData) throws DeploymentException { String beanName = \"jboss.ruby.queue-handler.\" + unit.getSimpleName() + \".\" + queueMetaData.getQueueClassName(); BeanMetaDataBuilder builder = BeanMetaDataBuilder.createBuilder( beanName, RubyTaskQueueHandler.class.getName() ); String queueName = RubyTaskQueuesDeployer.getQueueName( unit, queueMetaData.getQueueClassName() ); builder.addPropertyMetaData( \"queueName\", queueName ); builder.addPropertyMetaData( \"enabled\", queueMetaData.isEnabled() ); builder.addPropertyMetaData( \"queueClassName\", queueMetaData.getQueueClassName() ); builder.addPropertyMetaData( \"queueClassLocation\", queueMetaData.getQueueClassLocation() ); String runtimePoolName = RubyRuntimePoolDeployer.getBeanName( unit ); ValueMetaData runtimePoolInject = builder.createInject( runtimePoolName ); builder.addPropertyMetaData( \"rubyRuntimePool\", runtimePoolInject ); builder.addDependency( RubyTaskQueuesDeployer.getObjectName( unit, queueMetaData.getQueueClassName() ) ); unit.addAttachment( BeanMetaData.class.getName() + \"$\" + beanName, builder.getBeanMetaData(), BeanMetaData.class ); } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues.deployers; import javax.management.MalformedObjectNameException; import javax.management.ObjectName; import org.apache.log4j.Logger; import org.jboss.deployers.spi.DeploymentException; import org.jboss.deployers.structure.spi.DeploymentUnit; import org.jboss.deployers.vfs.spi.deployer.AbstractSimpleVFSRealDeployer; import org.jboss.deployers.vfs.spi.structure.VFSDeploymentUnit; import org.jboss.jms.server.destination.QueueService; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueueMetaData; import org.jboss.ruby.enterprise.queues.metadata.RubyTaskQueuesMetaData; import org.jboss.system.metadata.ServiceAttributeMetaData; import org.jboss.system.metadata.ServiceConstructorMetaData; import org.jboss.system.metadata.ServiceDependencyMetaData; import org.jboss.system.metadata.ServiceMetaData; import org.jboss.system.metadata.ServiceTextValueMetaData; import org.jboss.system.metadata.ServiceValueMetaData; public class RubyTaskQueuesDeployer extends AbstractSimpleVFSRealDeployer<RubyTaskQueuesMetaData> { private static final Logger log = Logger.getLogger(RubyTaskQueuesDeployer.class ); private static final String SERVER_PEER_NAME = \"jboss.messaging:service=ServerPeer\"; public RubyTaskQueuesDeployer() { super(RubyTaskQueuesMetaData.class); addOutput(ServiceMetaData.class); } public void deploy(VFSDeploymentUnit unit, RubyTaskQueuesMetaData queuesMetaData) throws DeploymentException { for (RubyTaskQueueMetaData queueMetaData : queuesMetaData.getQueues()) { deploy(unit, queueMetaData); } } public void deploy(VFSDeploymentUnit unit, RubyTaskQueueMetaData queueMetaData) throws DeploymentException { ServiceMetaData metaData = new ServiceMetaData(); metaData.setCode(QueueService.class.getName()); String simpleQueueName = queueMetaData.getQueueClassName(); simpleQueueName = simpleQueueName.replaceAll(\"::\", \".\"); String queueObjectName = getObjectName(unit, queueMetaData.getQueueClassName() ); try { metaData.setObjectName(new ObjectName(queueObjectName)); } catch (MalformedObjectNameException e) { throw new DeploymentException(e); } metaData.setXMBeanDD(\"xmdesc/Queue-xmbean.xml\"); ServiceConstructorMetaData constructorMetaData = new ServiceConstructorMetaData(); constructorMetaData.setSignature(new String[] { Boolean.TYPE.getName() }); constructorMetaData.setParameters(new Object[] { Boolean.TRUE }); metaData.setConstructor(constructorMetaData); "}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues.metadata; public class RubyTaskQueueMetaData { private String queueClassName; private boolean enabled; private String queueClassLocation; public RubyTaskQueueMetaData() { this.enabled=true; } public boolean isEnabled() { return this.enabled; } public void setEnabled(boolean enabled) { this.enabled = enabled; } public void setQueueClassName(String queueClassName) { this.queueClassName = queueClassName; } public String getQueueClassName() { return this.queueClassName; } public void setQueueClassLocation(String queueClassLocation) { this.queueClassLocation = queueClassLocation; } public String getQueueClassLocation() { return this.queueClassLocation; } public String toString() { return \"[RubyTaskQueue: queueClassName=\" + queueClassName + \"; enabled=\" + enabled + \"]\"; } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "package org.jboss.ruby.enterprise.queues.metadata; import java.util.ArrayList; import java.util.List; public class RubyTaskQueuesMetaData { private List<RubyTaskQueueMetaData> queues = new ArrayList<RubyTaskQueueMetaData>(); public RubyTaskQueuesMetaData() { } public void addQueue(RubyTaskQueueMetaData queue) { this.queues.add( queue ); } public List<RubyTaskQueueMetaData> getQueues() { return this.queues; } public RubyTaskQueueMetaData getQueueByClassName(String queueClassName) { for ( RubyTaskQueueMetaData queue : this.queues ) { if ( queue.getQueueClassName().equals( queueClassName ) ) { return queue; } } return null; } public int size() { return this.queues.size(); } public boolean empty() { return size() == 0; } }"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2008, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bobmcwhirter/jboss-rails", "content": "/* * JBoss, Home of Professional Open Source * Copyright 2009, Red Hat Middleware LLC, and individual contributors * by the @authors tag. See the copyright.txt in the distribution for a * full listing of individual contributors. * * This is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as * published by the Free Software Foundation; either version 2.1 of * the License, or (at your option) any later version. * * This software is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this software; if not, write to the Free * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA * 02110-1301 USA, or see the FSF site: http:"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent;  public class AgentConfiguration { public static final int DEFAULT_PORT_NUMBER = 4443; public static final String DEFAULT_RC_WRAPPER_JAR_PATH = \"lib/selenium-grid-remote-control-standalone-1.0.1.jar\"; public static final String DEFAULT_RC_JAR_PATH = \"lib/selenium-server-1.0-SNAPSHOT.jar\"; private int port; private String remoteControlWrapperJarPath; private String remoteControlJarPath; public AgentConfiguration() { this.port = DEFAULT_PORT_NUMBER; this.remoteControlWrapperJarPath = DEFAULT_RC_WRAPPER_JAR_PATH; this.remoteControlJarPath = DEFAULT_RC_JAR_PATH; } public void setPort(int newPortNumber) { this.port = newPortNumber; } public Object getPort() { return port; } public String remoteControlWrapperJarPath() { return this.remoteControlWrapperJarPath; } public void setRemoteControlWrapperJarPath(String newRemoteControlWrapperJar) { this.remoteControlWrapperJarPath = newRemoteControlWrapperJar; } public Object remoteControlJarPath() { return this.remoteControlJarPath; } public void setRemoteControlJar(String newRemoteControlJarPath) { this.remoteControlJarPath = newRemoteControlJarPath; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory;  public class AgentRegistry { private static final Log LOGGER = LogFactory.getLog(AgentRegistry.class); private static AgentRegistry singleton; private AgentConfiguration agentConfiguration; public static synchronized AgentRegistry registry() { if (null == singleton) { singleton = new AgentRegistry(); } return singleton; } public synchronized AgentConfiguration agentConfiguration() { if (null == agentConfiguration) { agentConfiguration = new AgentConfiguration(); LOGGER.info(\"Loaded agent configuration:\\n\" + agentConfiguration); } return agentConfiguration; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import com.thoughtworks.selenium.grid.webserver.Resource; import com.thoughtworks.selenium.grid.HttpParameters;  public class AgentResource extends Resource { public String process(HttpParameters params) { return \"Selenium Grid Agent\"; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import com.thoughtworks.selenium.grid.webserver.WebServer;  public class AgentServer extends WebServer { public AgentServer(int port) { super(port, RouteResolver.class); } public static void main(String[] args) throws Exception { final AgentServer server; server = new AgentServer(4443); server.launch(); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import com.thoughtworks.selenium.grid.Join; import java.util.List; import java.util.LinkedList; import java.io.File;  public class Classpath { private final List<String> entries; public Classpath() { entries = new LinkedList<String>(); } public String[] entries() { return entries.toArray(new String[entries.size()]); } public void add(String newEntry) { entries.add(newEntry); } public String toString() { return new Join(entries, File.pathSeparator).toString(); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.PrintStream;  public class JVMHandle { private final Process process; public JVMHandle(Process process) throws IOException { this.process = process; } public int waitForProg(PrintStream outputStream) throws IOException { InputStream is = null; InputStreamReader isr = null; is = process.getInputStream(); isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) { outputStream.println(line); } return process.exitValue(); } public void kill() { process.destroy(); } public boolean alive() { try { process.exitValue(); return false; } catch (IllegalThreadStateException e) { return true; } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List;  public class JVMLauncher { private final Classpath classpath; private final String mainClass; public JVMLauncher(Classpath classpath, String mainClass) { this.classpath = classpath; this.mainClass = mainClass; } public JVMHandle launchNewJVM() throws IOException, InterruptedException { return new JVMHandle(newProcessBuilder().start()); } protected ProcessBuilder newProcessBuilder() { final ProcessBuilder builder; builder = new ProcessBuilder(command()); builder.redirectErrorStream(true); return builder; } protected Classpath classpath() { return classpath; } protected List<String> command() { final List<String> command; command = new ArrayList<String>(3); command.add(javaLauncherPath()); command.add(\"-cp\"); command.add(classpath.toString()); command.add(mainClass); return command; } protected String javaLauncherPath() { File javaLauncher; javaLauncher = new File(System.getProperty(\"java.home\") + \"/bin/java\" + executableSuffix()); return javaLauncher.getAbsolutePath(); } protected String executableSuffix() { return onWindows() ? \".exe\" : \"\"; } protected boolean onWindows() { return -1 != System.getProperty(\"os.name\").indexOf(\"Windows\"); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import com.thoughtworks.selenium.grid.webserver.Resource; import com.thoughtworks.selenium.grid.HttpParameters;  public class RemoteControlCommand extends Resource { public String process(HttpParameters params) { return null; } public RemoteControlConfiguration parseRemoteControlConfiguration(HttpParameters httpParameters) { final RemoteControlConfiguration configuration; configuration = new RemoteControlConfiguration(); if (null != httpParameters.get(\"port\")) { final Integer port; port = Integer.parseInt(httpParameters.get(\"port\")); configuration.setPort(port); } return configuration; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent;  public class RemoteControlConfiguration { private int port; public RemoteControlConfiguration() { this.port = 4444; } public int port() { return port; } public void setPort(int newPortNumber) { this.port = newPortNumber; } public String host() { return \"0.0.0.0\"; } public String environment() { return \"*chrome\"; } public String additionalSeleniumArgs() { return null; } public String hubURL() { return \"http:"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.agent; import com.thoughtworks.selenium.grid.webserver.Resource; import com.thoughtworks.selenium.grid.webserver.InvalidRouteException; import javax.servlet.http.HttpServletRequest;  public class RouteResolver implements com.thoughtworks.selenium.grid.webserver.RouteResolver { public Resource resolve(HttpServletRequest request) { final String path; path = request.getPathInfo(); if (\"/\".equals(path)) { return new AgentResource(); } else if (\"/remote-controls\".equals(path) && \"POST\".equals(request.getMethod())) { return new RemoteControlCommand(); } throw new InvalidRouteException(request.getPathInfo()); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub;  public class CommandParsingException extends RuntimeException { public CommandParsingException(String message) { super(message); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub;  public class Environment { private final String name; private final String browser; public Environment(String name, String browser) { if (null == name) { throw new IllegalArgumentException(\"name cannot be null\"); } this.name = name; this.browser = browser; } public String name() { return name; } public String browser() { return browser; } public String toString() { return \"[Environment name='\" + name + \"', browser='\" + browser + \"']\"; } public boolean equals(Object other) { if (this == other) { return true; } if (other == null || getClass() != other.getClass()) { return false; } final Environment otherRemoteControl = (Environment) other; return name.equals(otherRemoteControl.name); } public int hashCode() { return name.hashCode(); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  public class EnvironmentManager { private final Map<String, Environment> environmentMap; public EnvironmentManager() { this.environmentMap = new HashMap<String, Environment>(); } public List<Environment> environments() { return new ArrayList<Environment>(environmentMap.values()); } public void addEnvironment(Environment newEnvironment) { synchronized (environmentMap) { environmentMap.put(newEnvironment.name(), newEnvironment); } } public Environment environment(String environmentName) { synchronized (environmentMap) { return environmentMap.get(environmentName); } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub; import com.thoughtworks.selenium.grid.hub.remotecontrol.commands.NewBrowserSessionCommand; import com.thoughtworks.selenium.grid.hub.remotecontrol.commands.SeleneseCommand; import com.thoughtworks.selenium.grid.hub.remotecontrol.commands.TestCompleteCommand; import com.thoughtworks.selenium.grid.HttpParameters;  public class HttpCommandParser { public static final String NEW_BROWSER_SESSION = \"getNewBrowserSession\"; private static final String TEST_COMPLETE = \"testComplete\"; private final HttpParameters parameters; public HttpCommandParser(HttpParameters parameters) { this.parameters = parameters; } public SeleneseCommand parse(EnvironmentManager environmentManager) { final String command = parameters.get(\"cmd\"); if (command.equals(NEW_BROWSER_SESSION)) { final Environment environment; final String environmentName; environmentName = parameters.get(\"1\"); environment = environmentManager.environment(environmentName); if (null == environment) { throw new CommandParsingException(\"ERROR: Unknown environment '\" + environmentName + \"'\"); } parameters.put(\"1\", environment.browser()); return new NewBrowserSessionCommand(environment, parameters); } else if (command.equals(TEST_COMPLETE)) { return new TestCompleteCommand(retrieveSessionId(parameters), parameters); } else { return new SeleneseCommand(retrieveSessionId(parameters), parameters); } } public HttpParameters parameters() { return parameters; } protected String retrieveSessionId(HttpParameters parameters) { final String sessionId = parameters.get(\"sessionId\"); if (null == sessionId) { throw new CommandParsingException(\"ERROR: No sessionId provided. Most likely your original newBrowserSession command failed.\"); } return sessionId; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub; import com.thoughtworks.selenium.grid.configuration.EnvironmentConfiguration; import com.thoughtworks.selenium.grid.configuration.GridConfiguration; import com.thoughtworks.selenium.grid.configuration.ResourceLocator; import com.thoughtworks.selenium.grid.hub.remotecontrol.DynamicRemoteControlPool; import com.thoughtworks.selenium.grid.hub.remotecontrol.GlobalRemoteControlPool; import com.thoughtworks.selenium.grid.hub.management.LifecycleManager; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory;  public class HubRegistry { private static final Log LOGGER = LogFactory.getLog(HubRegistry.class); private static HubRegistry singleton; private DynamicRemoteControlPool pool; private EnvironmentManager environmentManager; private GridConfiguration gridConfiguration; private LifecycleManager lifecycleManager; public static synchronized HubRegistry registry() { if (null == singleton) { singleton = new HubRegistry(); } return singleton; } public synchronized DynamicRemoteControlPool remoteControlPool() { if (null == pool) { pool = new GlobalRemoteControlPool(); } return pool; } public synchronized EnvironmentManager environmentManager() { if (null == environmentManager) { environmentManager = new EnvironmentManager(); for (EnvironmentConfiguration envConfig :gridConfiguration().getHub().getEnvironments()) { environmentManager.addEnvironment(new Environment(envConfig.getName(), envConfig.getBrowser())); } } return environmentManager; } public synchronized GridConfiguration gridConfiguration() { if (null == gridConfiguration) { final String definition = new ResourceLocator(getClass()).retrieveContent(\"/grid_configuration.yml\"); gridConfiguration = GridConfiguration.parse(definition); LOGGER.info(\"Loaded grid configuration:\\n\" + gridConfiguration.toYAML()); } return gridConfiguration; } public synchronized LifecycleManager lifecycleManager() { if (null == lifecycleManager) { lifecycleManager = new LifecycleManager(); } return lifecycleManager; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub; import com.thoughtworks.selenium.grid.configuration.HubConfiguration; import com.thoughtworks.selenium.grid.hub.management.RegistrationServlet; import com.thoughtworks.selenium.grid.hub.management.UnregistrationServlet; import com.thoughtworks.selenium.grid.hub.management.LifecycleManagerServlet; import com.thoughtworks.selenium.grid.hub.management.console.ConsoleServlet; import org.mortbay.jetty.Server; import org.mortbay.jetty.handler.ContextHandlerCollection; import org.mortbay.jetty.servlet.Context; import org.mortbay.jetty.servlet.ServletHolder;  public class HubServer { public static void main(String[] args) throws Exception { final ContextHandlerCollection contexts; final HubConfiguration configuration; final Server server; final Context root; configuration = HubRegistry.registry().gridConfiguration().getHub(); server = new Server(configuration.getPort()); contexts = new ContextHandlerCollection(); server.setHandler(contexts); root = new Context(contexts, \"/\", Context.SESSIONS); "}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub; import com.thoughtworks.selenium.grid.hub.remotecontrol.DynamicRemoteControlPool; import com.thoughtworks.selenium.grid.Response; import com.thoughtworks.selenium.grid.HttpParameters; import com.thoughtworks.selenium.grid.hub.remotecontrol.commands.SeleneseCommand; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;  public class HubServlet extends HttpServlet { private final static Log logger = LogFactory.getLog(HubServer.class); protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { process(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { process(request, response); } protected void process(HttpServletRequest request, HttpServletResponse response) throws IOException { final Response remoteControlResponse; final HubRegistry registry; final HttpParameters parameters; registry = HubRegistry.registry(); parameters = requestParameters(request); remoteControlResponse = forward(parameters, registry.remoteControlPool(), registry.environmentManager()); reply(response, remoteControlResponse); } protected Response forward(HttpParameters parameters, DynamicRemoteControlPool pool, EnvironmentManager environmentManager) throws IOException { final SeleneseCommand command; final Response response; logger.info(\"Processing '\" + parameters.toString() + \"'\"); try { command = new HttpCommandParser(parameters).parse(environmentManager); response = command.execute(pool); } catch (CommandParsingException e) { logger.error(\"Failed to parse '\" + parameters.toString() + \"' : \" + e.getMessage()); return new Response(e.getMessage()); } logger.info(\"Responding with \" + response.statusCode() + \"/ '\" + response.body() + \"'\"); return response; } protected void reply(HttpServletResponse response, Response remoteControlResponse) throws IOException { response.setContentType(\"text/plain\"); response.setCharacterEncoding(\"UTF-8\"); response.setStatus(remoteControlResponse.statusCode()); response.getWriter().print(remoteControlResponse.body()); } @SuppressWarnings({\"unchecked\"}) protected HttpParameters requestParameters(HttpServletRequest request) { final HttpParameters parameters; parameters = new HttpParameters(request.getParameterMap()); return parameters; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management; import com.thoughtworks.selenium.grid.hub.HubRegistry; import javax.servlet.http.HttpServlet;  public class HubServlet extends HttpServlet {  protected HubRegistry registry() { return HubRegistry.registry(); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory;  public class LifecycleManager { private static final Log LOGGER = LogFactory.getLog(LifecycleManager.class); public void shutdown() { LOGGER.info(\"Shutting down Hub...\"); System.exit(0); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.ServletException; import java.io.IOException;  public class LifecycleManagerServlet extends HubServlet { private static final Log LOGGER = LogFactory.getLog(LifecycleManagerServlet.class); public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { final String action; action = request.getParameter(\"action\"); LOGGER.info(\"Requesting life cycle manager action : '\" + action + \"'\"); if (\"shutdown\".equals(action)) { registry().lifecycleManager().shutdown(); } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public abstract class RegistrationManagementServlet extends HubServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { process(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { process(request, response); } protected abstract void process(HttpServletRequest request, HttpServletResponse response) throws IOException; protected void writeSuccessfulResponse(HttpServletResponse response) throws IOException { response.setContentType(\"text/plain\"); response.setCharacterEncoding(\"UTF-8\"); response.setStatus(HttpServletResponse.SC_OK); response.getWriter().print(\"OK\"); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management; import com.thoughtworks.selenium.grid.hub.remotecontrol.DynamicRemoteControlPool; import com.thoughtworks.selenium.grid.hub.remotecontrol.RemoteControlProxy; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;  public class RegistrationServlet extends RegistrationManagementServlet { private static final Log LOGGER = LogFactory.getLog(RegistrationServlet.class); protected void process(HttpServletRequest request, HttpServletResponse response) throws IOException { final RemoteControlProxy newRemoteControl; final DynamicRemoteControlPool pool; LOGGER.info(\"Registering new remote control...\"); newRemoteControl = RemoteControlParser.parse(request); pool = registry().remoteControlPool(); pool.register(newRemoteControl); LOGGER.info(\"Registered \" + newRemoteControl); writeSuccessfulResponse(response); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management; import com.thoughtworks.selenium.grid.HttpClient; import com.thoughtworks.selenium.grid.hub.remotecontrol.RemoteControlProxy; import javax.servlet.http.HttpServletRequest;  public class RemoteControlParser { public static RemoteControlProxy parse(HttpServletRequest request) { final RemoteControlProxy remoteControl; final String portParameter; final String environment; final String host; final int port; host = request.getParameter(\"host\"); if (null == host || \"\".equals(host.trim())) { throw new IllegalStateException(\"You must specify a 'host' parameter\"); } portParameter = request.getParameter(\"port\"); if (null == portParameter || \"\".equals(portParameter.trim())) { throw new IllegalStateException(\"You must specify a 'port' parameter\"); } port = Integer.parseInt(portParameter); environment = request.getParameter(\"environment\"); if (null == environment || \"\".equals(environment.trim())) { throw new IllegalStateException(\"You must specify an 'environment' parameter\"); } remoteControl = new RemoteControlProxy(host, port, environment, 1, new HttpClient()); return remoteControl; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management; import com.thoughtworks.selenium.grid.hub.remotecontrol.DynamicRemoteControlPool; import com.thoughtworks.selenium.grid.hub.remotecontrol.RemoteControlProxy; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;  public class UnregistrationServlet extends RegistrationManagementServlet { private static final Log logger = LogFactory.getLog(UnregistrationServlet.class); protected void process(HttpServletRequest request, HttpServletResponse response) throws IOException { final RemoteControlProxy newRemoteControl; final DynamicRemoteControlPool pool; logger.info(\"Unregistering remote control...\"); newRemoteControl = RemoteControlParser.parse(request); pool = registry().remoteControlPool(); pool.unregister(newRemoteControl); logger.info(\"Unregistered \" + newRemoteControl); writeSuccessfulResponse(response); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management.console; import com.thoughtworks.selenium.grid.hub.HubRegistry; import com.thoughtworks.selenium.grid.hub.management.console.mvc.Controller; import com.thoughtworks.selenium.grid.hub.management.console.mvc.Page; import javax.servlet.ServletException; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ConsoleController extends Controller { public ConsoleController(HubRegistry registry) { super(registry); } public void process(HttpServletResponse response) throws ServletException, IOException { final Page page = list(); render(page, response); } public Page list() { final Page page; page = new Page(\"index.html\"); page.set(\"environments\", registry().environmentManager().environments()); page.set(\"availableRemoteControls\", registry().remoteControlPool().availableRemoteControls()); page.set(\"reservedRemoteControls\", registry().remoteControlPool().reservedRemoteControls()); return page; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management.console; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import com.thoughtworks.selenium.grid.hub.HubRegistry;  public class ConsoleServlet extends HttpServlet { private static final Log logger = LogFactory.getLog(ConsoleServlet.class); protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { logger.debug(\"Rendering console...\"); controller().process(response); } protected ConsoleController controller() { return new ConsoleController(HubRegistry.registry()); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management.console.mvc; import com.thoughtworks.selenium.grid.hub.HubRegistry; import javax.servlet.http.HttpServletResponse; import java.io.IOException;  public class Controller { private final HubRegistry registry; public Controller(HubRegistry registry) { this.registry = registry; } public void render(Page page, HttpServletResponse response) throws IOException { final Template template; final String content; template = templateResolver().get(page.template()); content = template.render(page.assigns()); response.setContentType(\"text/html\"); response.setCharacterEncoding(\"UTF-8\"); response.getWriter().print(content); } protected HubRegistry registry() { return registry; } protected TemplateResolver templateResolver() { return new TemplateResolver(getClass()); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management.console.mvc; import java.util.HashMap; import java.util.Map;  public class Page { private final String template; private final Map<String, Object> assigns; public Page(String template) { this.template = template; this.assigns = new HashMap<String, Object>(); } public String template() { return template; } public Map<String, Object> assigns() { return assigns; } public void set(String name, Object value) { this.assigns.put(name, value); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management.console.mvc;  public class RenderingException extends RuntimeException { public RenderingException(Throwable originalProblem) { super(originalProblem); } public RenderingException(String message) { super(message); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management.console.mvc; import freemarker.template.TemplateException; import java.io.IOException; import java.io.Reader; import java.io.StringReader; import java.io.StringWriter; import java.util.Map;  public class Template { private final freemarker.template.Template freemarkerTemplate; public Template(freemarker.template.Template freemarkerTemplate) { this.freemarkerTemplate = freemarkerTemplate; } public Template(Reader reader) throws IOException { this(new freemarker.template.Template(\"\", reader, null, null)); } public Template(String content) throws IOException { this(new StringReader(content)); } public String render(Map<String, Object> assigns) { final StringWriter out = new StringWriter(); try { freemarkerTemplate.process(assigns, out); } catch (TemplateException e) { throw new RenderingException(e); } catch (IOException e) { throw new RenderingException(e); } return out.toString(); } protected String content() throws IOException { final StringWriter writer = new StringWriter(); freemarkerTemplate.dump(writer); return writer.toString(); } protected freemarker.template.Template freemarkerTemplate() { return freemarkerTemplate; }  protected Template() { this.freemarkerTemplate = null; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.management.console.mvc; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.net.URL;  public class TemplateResolver { private final Class resourceRoot; public TemplateResolver(Class resourceRoot) { this.resourceRoot = resourceRoot; } public Template get(String templateName) { final Reader templateReader; try { templateReader = getContent(templateName); return new Template(new freemarker.template.Template(templateName, templateReader, null)); } catch (IOException e) { throw new RenderingException(e); } } protected Reader getContent(String templateName) throws IOException { final URL res = resourceRoot.getResource(templateName); if (null == res) { throw new RenderingException(\"Could not find '\" + templateName + \"' in classpath. Resolving from '\" + resourceRoot + \"'\"); } return new InputStreamReader(res.openStream()); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.remotecontrol; import java.util.List;  public interface DynamicRemoteControlPool extends RemoteControlPool { void register(RemoteControlProxy newRemoteControl); boolean unregister(RemoteControlProxy remoteControl); List<RemoteControlProxy> availableRemoteControls(); List<RemoteControlProxy> reservedRemoteControls(); }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.remotecontrol; import com.thoughtworks.selenium.grid.hub.Environment; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map;  public class GlobalRemoteControlPool implements DynamicRemoteControlPool { private static final Log LOGGER = LogFactory.getLog(GlobalRemoteControlPool.class); private final Map<String, RemoteControlProxy> remoteControlsBySessionIds; private final Map<String, RemoteControlProvisioner> provisionersByEnvironment; public GlobalRemoteControlPool() { this.remoteControlsBySessionIds = new HashMap<String, RemoteControlProxy>(); this.provisionersByEnvironment = new HashMap<String, RemoteControlProvisioner>(); } public void register(RemoteControlProxy newRemoteControl) { final RemoteControlProvisioner provisioner; synchronized(provisionersByEnvironment) { if (null == getProvisioner(newRemoteControl.environment())) { createNewProvisionerForEnvironment(newRemoteControl.environment()); } provisioner = getProvisioner(newRemoteControl.environment()); provisioner.add(newRemoteControl); } } public boolean unregister(RemoteControlProxy remoteControl) { final boolean status; synchronized(provisionersByEnvironment) { synchronized (remoteControlsBySessionIds) { status = getProvisioner(remoteControl.environment()).remove(remoteControl); if (remoteControlsBySessionIds.containsValue(remoteControl)) { removeFromSessionMap(remoteControl); } } } return status; } public RemoteControlProxy reserve(Environment environment) { return getProvisioner(environment.name()).reserve(); } public void associateWithSession(RemoteControlProxy remoteControl, String sessionId) { LOGGER.info(\"Associating session id='\" + sessionId + \"' =>\" + remoteControl + \" for environment \" + remoteControl.environment()); if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"Asssociating \" + sessionId + \" => \" + remoteControl); } synchronized (remoteControlsBySessionIds) { if (remoteControlsBySessionIds.containsKey(sessionId)) { throw new IllegalStateException( \"Session '\" + sessionId + \"' is already asssociated with \" + remoteControlsBySessionIds.get(sessionId)); } synchronized (remoteControlsBySessionIds) { remoteControlsBySessionIds.put(sessionId, remoteControl); } } if (LOGGER.isDebugEnabled()) { logSessionMap(); } } public RemoteControlProxy retrieve(String sessionId) { return getRemoteControlForSession(sessionId); } public void release(RemoteControlProxy remoteControl) { getProvisioner(remoteControl.environment()).release(remoteControl); } public void releaseForSession(String sessionId) { LOGGER.info(\"Releasing pool for session id='\" + sessionId + \"'\"); final RemoteControlProxy remoteControl; remoteControl = getRemoteControlForSession(sessionId); synchronized (remoteControlsBySessionIds) { remoteControlsBySessionIds.remove(sessionId); } getProvisioner(remoteControl.environment()).release(remoteControl); } public List<RemoteControlProxy> availableRemoteControls() { final List<RemoteControlProxy> availableRemoteControls; availableRemoteControls = new LinkedList<RemoteControlProxy>(); for (RemoteControlProvisioner provisioner : provisionersByEnvironment.values()) { availableRemoteControls.addAll(provisioner.availableRemoteControls()); } return availableRemoteControls; } public List<RemoteControlProxy> reservedRemoteControls() { final List<RemoteControlProxy> reservedRemoteControls; reservedRemoteControls = new LinkedList<RemoteControlProxy>(); for (RemoteControlProvisioner provisioner : provisionersByEnvironment.values()) { reservedRemoteControls.addAll(provisioner.reservedRemoteControls()); } return reservedRemoteControls; } protected RemoteControlProvisioner getProvisioner(String environment) { return provisionersByEnvironment.get(environment); } protected RemoteControlProxy getRemoteControlForSession(String sessionId) { return remoteControlsBySessionIds.get(sessionId); } protected void removeFromSessionMap(RemoteControlProxy remoteControl) { for (Map.Entry<String, RemoteControlProxy> entry : remoteControlsBySessionIds.entrySet()) { if (entry.getValue().equals(remoteControl)) { remoteControlsBySessionIds.remove(entry.getKey()); } } } protected void logSessionMap() { for (Map.Entry<String, RemoteControlProxy> entry : remoteControlsBySessionIds.entrySet()) { LOGGER.debug(entry.getKey() + \" => \" + entry.getValue()); } } protected void createNewProvisionerForEnvironment(String environemntName) { provisionersByEnvironment.put(environemntName, new RemoteControlProvisioner()); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.remotecontrol; import com.thoughtworks.selenium.grid.hub.Environment;  public interface RemoteControlPool {  RemoteControlProxy reserve(Environment environment);  void associateWithSession(RemoteControlProxy remoteControl, String sessionId);  RemoteControlProxy retrieve(String sessionId);  void release(RemoteControlProxy remoteControl);  void releaseForSession(String sessionId); }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.remotecontrol; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock;  public class RemoteControlProvisioner { private static final Log LOGGER = LogFactory.getLog(RemoteControlProvisioner.class); private final List<RemoteControlProxy> remoteControls; private final Lock remoteControlListLock; private final Condition remoteControlAvailable; public RemoteControlProvisioner() { remoteControls = new LinkedList<RemoteControlProxy>(); remoteControlListLock = new ReentrantLock(); remoteControlAvailable = remoteControlListLock.newCondition(); } public RemoteControlProxy reserve() { final RemoteControlProxy remoteControl; try { remoteControlListLock.lock(); if (remoteControls.isEmpty()) { return null; } remoteControl = blockUntilARemoteControlIsAvailable(); remoteControl.registerNewSession(); LOGGER.info(\"Reserved remote control\" + remoteControl); return remoteControl; } finally { remoteControlListLock.unlock(); } } public void release(RemoteControlProxy remoteControl) { try { remoteControlListLock.lock(); remoteControl.unregisterSession(); LOGGER.info(\"Released remote control\" + remoteControl); signalThatARemoteControlHasBeenMadeAvailable(); } finally { remoteControlListLock.unlock(); } } public void add(RemoteControlProxy newRemoteControl) { try { remoteControlListLock.lock(); if (remoteControls.contains(newRemoteControl)) { throw new IllegalStateException(\"attempting to add a remote control that is already registered: \" + newRemoteControl); } remoteControls.add(newRemoteControl); signalThatARemoteControlHasBeenMadeAvailable(); } finally { remoteControlListLock.unlock(); } } public boolean remove(RemoteControlProxy remoteControl) { try { remoteControlListLock.lock(); return remoteControls.remove(remoteControl); } finally { remoteControlListLock.unlock(); } }  public List<RemoteControlProxy> availableRemoteControls() { LinkedList<RemoteControlProxy> availableremoteControls; availableremoteControls = new LinkedList<RemoteControlProxy>(); for (RemoteControlProxy remoteControl : remoteControls) { if (remoteControl.canHandleNewSession()) { availableremoteControls.add(remoteControl); } } return Arrays.asList(availableremoteControls.toArray(new RemoteControlProxy[availableremoteControls.size()])); }  public List<RemoteControlProxy> reservedRemoteControls() { LinkedList<RemoteControlProxy> reservedRemoteControls; reservedRemoteControls = new LinkedList<RemoteControlProxy>(); for (RemoteControlProxy remoteControl : remoteControls) { if (remoteControl.concurrentSesssionCount() >= 1) { reservedRemoteControls.add(remoteControl); } } return Arrays.asList(reservedRemoteControls.toArray(new RemoteControlProxy[reservedRemoteControls.size()])); } protected RemoteControlProxy blockUntilARemoteControlIsAvailable() { RemoteControlProxy availableRemoteControl; while(true) { try { availableRemoteControl = findNextAvailableRemoteControl(); while (null == availableRemoteControl) { LOGGER.info(\"Waiting for an remote control...\"); waitForARemoteControlToBeAvailable(); availableRemoteControl = findNextAvailableRemoteControl(); } return availableRemoteControl; } catch (InterruptedException e) { LOGGER.error(\"Interrupted while reserving remote control\", e); } } }  protected RemoteControlProxy findNextAvailableRemoteControl() { for (RemoteControlProxy remoteControl : remoteControls) { if (remoteControl.canHandleNewSession()) { return remoteControl; } } return null; } protected void waitForARemoteControlToBeAvailable() throws InterruptedException { remoteControlAvailable.await(); } protected void signalThatARemoteControlHasBeenMadeAvailable() { remoteControlAvailable.signalAll(); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.remotecontrol; import com.thoughtworks.selenium.grid.HttpParameters; import com.thoughtworks.selenium.grid.Response; import com.thoughtworks.selenium.grid.HttpClient; import java.io.IOException;  public class RemoteControlProxy { private final int concurrentSessionMax; private int concurrentSessionCount; private final HttpClient httpClient; private final String environment; private final String host; private final int port; public RemoteControlProxy(String host, int port, String environment, int concurrentSessionMax, HttpClient httpClient) { if (null == host) { throw new IllegalArgumentException(\"host cannot be null\"); } if (null == environment) { throw new IllegalArgumentException(\"environment cannot be null\"); } this.host = host; this.port = port; this.environment = environment; this.concurrentSessionMax = concurrentSessionMax; this.concurrentSessionCount = 0; this.httpClient = httpClient; } public String host() { return host; } public int port() { return port; } public String environment() { return environment; } public String remoteControlURL() { return \"http:"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.remotecontrol.commands; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import com.thoughtworks.selenium.grid.hub.Environment; import com.thoughtworks.selenium.grid.HttpParameters; import com.thoughtworks.selenium.grid.Response; import com.thoughtworks.selenium.grid.hub.remotecontrol.RemoteControlPool; import com.thoughtworks.selenium.grid.hub.remotecontrol.RemoteControlProxy; import java.io.IOException; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class NewBrowserSessionCommand extends SeleneseCommand { private static final Pattern SESSION_ID_PATTERN = Pattern.compile(\"OK,([^,]*)\"); private static final Log logger = LogFactory.getLog(NewBrowserSessionCommand.class); private final Environment environment; public NewBrowserSessionCommand(Environment environment, HttpParameters parameters) { super(null, parameters); this.environment = environment; } public Response execute(RemoteControlPool pool) throws IOException { RemoteControlProxy remoteControl; final String sessionId; final Response response; remoteControl = pool.reserve(environment); if (null == remoteControl) { final String message = \"No available remote control for environment '\" + environment.name() + \"'\"; logger.warn(message); return new Response(message); } try { response = remoteControl.forward(parameters()); sessionId = parseSessionId(response.body()); if (null == sessionId) { pool.release(remoteControl); return new Response(\"Could not retrieve a new session\"); } pool.associateWithSession(remoteControl, sessionId); return response; } catch (Exception e) { logger.error(\"Problem while requesting new browser session\", e); pool.release(remoteControl); return new Response(e.getMessage()); } } protected String parseSessionId(String responseBody) { final Matcher matcher = SESSION_ID_PATTERN.matcher(responseBody); if (matcher.matches()) { return matcher.group(1); } return null; } public Environment environment() { return environment; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.hub.remotecontrol.commands; import com.thoughtworks.selenium.grid.hub.remotecontrol.RemoteControlPool; import com.thoughtworks.selenium.grid.hub.remotecontrol.RemoteControlProxy; import com.thoughtworks.selenium.grid.Response; import com.thoughtworks.selenium.grid.HttpParameters; import java.io.IOException;  public class SeleneseCommand { private final String sessionId; private final HttpParameters parameters; public SeleneseCommand(String sessionId, HttpParameters parameters) { this.sessionId = sessionId; this.parameters = parameters; } public String sessionId() { return sessionId; } public HttpParameters parameters() { return parameters; } public Response execute(RemoteControlPool pool) throws IOException { final RemoteControlProxy remoteControl; if (null == sessionId) { return new Response(\"Selenium Driver error: No sessionId provided for command '\" + parameters.toString() + \"'\"); } remoteControl = pool.retrieve(sessionId()); return remoteControl.forward(parameters()); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid; import org.apache.commons.httpclient.HttpMethod; import org.apache.commons.httpclient.methods.GetMethod; import org.apache.commons.httpclient.methods.PostMethod; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.io.IOException;  public class HttpClient { private static final Log logger = LogFactory.getLog(HttpClient.class); private final org.apache.commons.httpclient.HttpClient client; public HttpClient(org.apache.commons.httpclient.HttpClient client) { this.client = client; } public HttpClient() { this(new org.apache.commons.httpclient.HttpClient()); } public Response get(String url) throws IOException { return request(new GetMethod(url)); } public Response post(String url, HttpParameters parameters) throws IOException { return request(buildPostMethod(url, parameters)); } protected PostMethod buildPostMethod(String url, HttpParameters parameters) { final PostMethod postMethod; postMethod = new PostMethod(url); postMethod.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded; ; charset=UTF-8\"); for (String name : parameters.names()) { postMethod.setParameter(name, parameters.get(name)); } return postMethod; } protected Response request(HttpMethod method) throws IOException { final int statusCode; final String body; try { statusCode = client.executeMethod(method); body = new String(method.getResponseBody(), \"utf-8\"); logger.info(\"Remote Control replied with '\" + statusCode + \" / '\" + body + \"'\"); return new Response(statusCode, body); } finally { method.releaseConnection(); } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid; import java.util.HashMap; import java.util.Map; import java.util.Set; import java.util.TreeSet;  public class HttpParameters { private Map<String, String[]> parameterMap; public HttpParameters(Map<String, String[]> parameterMap) { this.parameterMap = parameterMap; } public HttpParameters() { this.parameterMap = new HashMap<String, String[]>(); } public String get(String name) { final String[] values = parameterMap.get(name); if (null == values || 0 == values.length) { return null; } return values[0]; } public void put(String name, String value) { parameterMap = new HashMap<String, String[]>(parameterMap); parameterMap.put(name, new String[]{value}); } public Set<String> names() { return parameterMap.keySet(); } public String toString() { final TreeSet<String> orderedNames; final StringBuilder builder; builder = new StringBuilder(150); orderedNames = new TreeSet<String>(); orderedNames.addAll(parameterMap.keySet()); for (String name : orderedNames) { builder.append(name); builder.append(\" => \\\"\"); builder.append(get((String) name)); builder.append(\"\\\", \"); } if (!parameterMap.isEmpty()) { builder.deleteCharAt(builder.length() - 1); builder.deleteCharAt(builder.length() - 1); } return builder.toString(); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.Reader; import java.io.Writer; import java.net.Socket;  public class IOHelper { private static final Log LOGGER = LogFactory.getLog(IOHelper.class);  public static void copyStream(InputStream in, Writer out, int copyBufferSize) throws IOException { InputStreamReader reader = null; try { reader = new InputStreamReader(in); copyStream(reader, out, copyBufferSize); } finally { close(reader); } out.flush(); }  public static void copyStream(Reader in, Writer out, int copyBufferSize) throws IOException { final char[] buffer; int bytesRead; buffer = new char[copyBufferSize]; while (in.ready()) { bytesRead = in.read(buffer); if (bytesRead < 0) {  break; } out.write(buffer, 0, bytesRead); } out.flush(); }  public static void close(InputStream is) { if (null != is) { try { is.close(); } catch (IOException e) { LOGGER.info(\"Ignoring exception while closing input stream '\" + is + \"'\", e); } } }  public static void close(Reader reader) { if (null != reader) { try { reader.close(); } catch (IOException e) { LOGGER.info(\"Ignoring exception while closing reader '\" + reader + \"'\", e); } } }  public static void close(Writer writer) { if (writer != null) { try { writer.close(); } catch (IOException e) { LOGGER.info(\"Ignoring exception while closing writer stream '\" + writer + \"'\", e); } } }  public static void close(OutputStream outputStream) { if (null != outputStream) { try { outputStream.close(); } catch (IOException e) { LOGGER.info(\"Ignoring exception while closing input stream '\" + outputStream + \"'\", e); } } }  public static void close(Socket socket) { if (null != socket) { try { socket.close(); } catch (IOException e) { LOGGER.info(\"Ignoring exception while closing input stream '\" + socket + \"'\", e); } } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid; import java.util.Collection;  public class Join extends Object { private final Collection collection; private final String separator; public Join(Collection collection, String separator) { this.collection = collection; this.separator = separator; } public String toString() { final StringBuffer joinedString; if (collection.isEmpty()) { return \"\"; } joinedString = new StringBuffer(); for (Object entry : collection) { joinedString.append(entry.toString()); joinedString.append(separator); } return joinedString.substring(0, joinedString.lastIndexOf(separator)); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid; public class Response { private final int statusCode; private final String body; public Response(String errorMessage) { this(200, \"ERROR: \" + errorMessage); } public Response(int statusCode, String body) { this.statusCode = statusCode; this.body = body; } public int statusCode() { return statusCode; } public String body() { return body; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.configuration;  public class EnvironmentConfiguration { private String name; private String browser; public EnvironmentConfiguration(String name, String browser) { this.name = name; this.browser = browser; } public EnvironmentConfiguration() { this(null, null); } public String getName() { return name; } public String getBrowser() { return browser; } public void setName(String name) { this.name = name; } public void setBrowser(String browser) { this.browser = browser; } public String toString() { return \"[EnvironmentConfiguration name='\" + name + \"', browser='\" + browser + \"']\"; } public boolean equals(Object other) { if (this == other) { return true; } if (other == null || getClass() != other.getClass()) { return false; } final EnvironmentConfiguration otherRemoteControl = (EnvironmentConfiguration) other; return compoundKey().equals(otherRemoteControl.compoundKey()); } public int hashCode() { return compoundKey().hashCode(); } protected String compoundKey() { return name + browser; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.configuration; import org.ho.yaml.Yaml; import java.io.Reader; import java.io.StringReader;  public class GridConfiguration { private HubConfiguration hub; public GridConfiguration() { this.hub = new HubConfiguration(); } public HubConfiguration getHub() { return hub; } public void setHub(HubConfiguration hub) { this.hub = hub; } public static GridConfiguration parse(String yamlDefinition) { return parse(new StringReader(yamlDefinition)); } public String toYAML() { return Yaml.dump(this, true); } protected static GridConfiguration parse(Reader yamlDefinition) { return Yaml.loadType(yamlDefinition, GridConfiguration.class); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.configuration;  public class HubConfiguration { private int port; private EnvironmentConfiguration[] environments; public HubConfiguration() { setPort(4444); environments = new EnvironmentConfiguration[] {}; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public EnvironmentConfiguration[] getEnvironments() { return environments; } public void setEnvironments(EnvironmentConfiguration[] environments) { this.environments = environments; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.configuration; import com.thoughtworks.selenium.grid.IOHelper; import java.io.IOException; import java.io.InputStream; import java.io.StringWriter; import java.net.URL;  public class ResourceLocator { private final Class root; private static final int COPY_BUFFER_SIZE = 1024;  public ResourceLocator(Class root) { this.root = root; } public String retrieveContent(String resourcePath) { final StringWriter writer = new StringWriter(); InputStream inputStream = null; URL resource; try { resource = root.getResource(resourcePath); if (null == resource) { throw new IllegalStateException(\"Could not find '\" + resourcePath + \"' in classpath. Root is \" + root); } inputStream = resource.openStream(); IOHelper.copyStream(inputStream, writer, COPY_BUFFER_SIZE); return writer.toString(); } catch (IOException e) { throw new RuntimeException(e); } finally { IOHelper.close(writer); IOHelper.close(inputStream); } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.webserver;  public class InvalidRouteException extends RuntimeException { private final String path; public InvalidRouteException(String path) { super(); this.path = path; } public String path() { return path; } public String toString() { return \"[InvalidRouteException path='\" + path + \"']\"; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.webserver; import com.thoughtworks.selenium.grid.HttpParameters; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;  public class MainServlet extends HttpServlet { private RouteResolver routeResolver; public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { final Resource resource; final String page; resource = routeResolver().resolve(request); page = resource.process(new HttpParameters(request.getParameterMap())); render(page, response); } public void render(String page, HttpServletResponse response) throws IOException { response.setContentType(\"text/plain\"); response.setCharacterEncoding(\"UTF-8\"); response.getWriter().print(page); } protected RouteResolver routeResolver() { if (null == routeResolver) { routeResolver = createRouteResolver(); } return routeResolver; } protected RouteResolver createRouteResolver() { final String routeResolverClassName; final Class routeResolverClass; routeResolverClassName = getServletConfig().getInitParameter(\"route_resolver\"); try { routeResolverClass = Class.forName(routeResolverClassName); return (RouteResolver) routeResolverClass.newInstance(); } catch (ClassNotFoundException e) { throw new RuntimeException(\"Could not find route resolver '\" + routeResolverClassName + \"'\", e); } catch (IllegalAccessException e) { throw new RuntimeException(\"Could not access class or its no-arg constructor '\" + routeResolverClassName + \"'\", e); } catch (InstantiationException e) { throw new RuntimeException(\"Could not find no arg constructor for '\" + routeResolverClassName + \"'\", e); } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.webserver; import com.thoughtworks.selenium.grid.HttpParameters;  public abstract class Resource { public abstract String process(HttpParameters params); }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.webserver; import javax.servlet.http.HttpServletRequest;  public interface RouteResolver { Resource resolve(HttpServletRequest request); }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.webserver; import org.mortbay.jetty.Server; import org.mortbay.jetty.handler.ContextHandlerCollection; import org.mortbay.jetty.servlet.Context; import org.mortbay.jetty.servlet.ServletHolder;  public class WebServer { private final int port; private final Class routeResolverClass; private Server httpServer; public WebServer(int port, Class routeResolverClass) { this.port = port; this.routeResolverClass = routeResolverClass; } public int port() { return port; } public void launch() throws Exception { createHttpServer(); startListeningForIncomingRequests(); waitForShutdown(); } protected void startListeningForIncomingRequests() throws Exception { httpServer().start(); } protected void waitForShutdown() throws InterruptedException { httpServer().join(); } protected void createHttpServer() { final ContextHandlerCollection contexts; final ServletHolder servletHolder; final Context root; httpServer = new Server(port); contexts = new ContextHandlerCollection(); httpServer.setHandler(contexts); root = new Context(contexts, \"/\", Context.SESSIONS); servletHolder = new ServletHolder(new MainServlet()); servletHolder.setInitParameter(\"route_resolver\", routeResolverClass().getName()); root.addServlet(servletHolder, \"/*\"); } protected Class routeResolverClass() { return routeResolverClass; } protected Server httpServer() { return httpServer; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol; import org.apache.commons.httpclient.methods.PostMethod; import org.apache.commons.httpclient.HttpClient; import java.io.IOException;  public class HubRequest { private final String environment; private final String targetURL; private final String host; private final String port; public HubRequest(String targetURL, String host, String port, String environment) { this.targetURL = targetURL; this.environment = environment; this.host = host; this.port = port; } public int execute() throws IOException { return new HttpClient().executeMethod(postMethod()); } public PostMethod postMethod() { final PostMethod postMethod = new PostMethod(targetURL); postMethod.addParameter(\"host\", host); postMethod.addParameter(\"port\", port); postMethod.addParameter(\"environment\", environment); return postMethod; } public String targetURL() { return targetURL; } public String environment() { return environment; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol; import java.util.ArrayList; import java.util.List;  public class OptionParser { public static class Options { private String host; private String port; private String environment; private String hubURL; private final List<String> seleniumServerOptions; protected Options() { this.host = \"localhost\"; this.port = \"5555\"; this.environment = \"*chrome\"; this.hubURL = \"http:"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.io.IOException;  public class RegistrationRequest extends HubRequest { private static final Log LOGGER = LogFactory.getLog(RegistrationRequest.class); public RegistrationRequest(String seleniumHubURL, String host, String port, String environment) { super(seleniumHubURL + \"/registration-manager/register\", host, port, environment); } public int execute() throws IOException { final int status; LOGGER.info(\"Registering to \" + targetURL()); status = super.execute(); if (200 != status) { throw new IllegalStateException(\"Could not register successfuly to \" + targetURL() + \" with environment '\" + environment() + \"'. Most likely this environment is not defined on the hub.\"); } return status; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.openqa.selenium.server.SeleniumServer; import java.io.IOException;  public class SelfRegisteringRemoteControl { private static final Log logger = LogFactory.getLog(SelfRegisteringRemoteControlLauncher.class); private final String seleniumHubURL; private final String environment; private final String host; private final String port; public SelfRegisteringRemoteControl(String seleniumHubURL, String environment, String host, String port) { this.seleniumHubURL = seleniumHubURL; this.environment = environment; this.host = host; this.port = port; } public void register() throws IOException { new RegistrationRequest(seleniumHubURL, host, port, environment).execute(); } public void unregister() throws IOException { new UnregistrationRequest(seleniumHubURL, host, port, environment).execute(); } public String hubURL() { return seleniumHubURL; } public String environment() { return environment; } public String host() { return host; } public String port() { return port; } public void launch(String[] args) throws Exception { logger.info(\"Starting selenium server with options:\"); for (String arg : args) { logger.info(arg); } SeleniumServer.main(args); } protected void ensureUnregisterOnExit() { Runtime.getRuntime().addShutdownHook(new Thread() { public void run() { try { unregister(); } catch (IOException e) { logger.error(\"Could not unregister \" + this, e); } } }); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.net.ConnectException;  public class SelfRegisteringRemoteControlLauncher { private static final Log logger = LogFactory.getLog(SelfRegisteringRemoteControlLauncher.class); public static void main(String[] args) throws Exception { final SelfRegisteringRemoteControl server; final OptionParser.Options options; options = new OptionParser().parseOptions(args); server = new SelfRegisteringRemoteControl( options.hubURL(), options.environment(), options.host(), options.port()); try { server.register(); server.ensureUnregisterOnExit(); server.launch(options.seleniumServerArgs()); } catch (ConnectException e) { logger.error(\"Could not contact the Selenium Hub at '\" + server.hubURL() + \"' : \" + e.getMessage() + \". Check that the Hub is running and check its status at \" + server.hubURL() + \"/console\"); throw e; } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.io.IOException;  public class UnregistrationRequest extends HubRequest { private static final Log logger = LogFactory.getLog(RegistrationRequest.class); public UnregistrationRequest(String seleniumHubURL, String host, String port, String environment) { super(seleniumHubURL + \"/registration-manager/unregister\", host, port, environment); } public int execute() throws IOException { logger.info(\"Unregistering from \" + targetURL()); return super.execute(); } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol.instrumentation; import com.thoughtworks.selenium.grid.remotecontrol.SelfRegisteringRemoteControl; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory;  public class EchoRemoteControl extends SelfRegisteringRemoteControl implements HttpRequestProcessor { private static final Log logger = LogFactory.getLog(SimplisticHttpServer.class); public EchoRemoteControl(String seleniumHubURL, String environment, String host, String port) { super(seleniumHubURL, environment, host, port); } public void launch(String[] args) throws Exception { new SimplisticHttpServer(5555, this).start(); } public static void main(String[] args) throws Exception { final EchoRemoteControl remoteControl = new EchoRemoteControl(\"http:"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol.instrumentation;  public interface HttpRequestProcessor { Response process(Request request); }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol.instrumentation; import com.thoughtworks.selenium.grid.IOHelper; import java.io.BufferedReader; import java.io.IOException; import java.io.StringWriter;  public class Request { private final static String CRLF = \"\\r\\n\"; private final String body; public Request(String body) { this.body = body; } public static Request parse(BufferedReader reader) throws IOException { readHeader(reader); return new Request(readBody(reader)); } public static void readHeader(BufferedReader reader) throws IOException { while (reader.ready()) { final String headerLine; headerLine = reader.readLine(); if (CRLF.equals(headerLine) || \"\".equals(headerLine)) { break; } } } public static String readBody(BufferedReader reader) throws IOException { final StringWriter body; body = new StringWriter(); IOHelper.copyStream(reader, body, 1024); return body.toString(); } public String body() { return body; } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol.instrumentation; import java.io.BufferedWriter; import java.io.IOException;  public class Response { private static final String CRLF = \"\\r\\n\"; private final String body; public Response(String body) { this.body = body; } public void write(BufferedWriter writer) throws IOException { writer.write(\"HTTP/1.0 200 OK\" + CRLF); writer.write(\"Server: Selenium Grid Echo Remote Control\" + CRLF); writer.write(\"Content-type: text/html\" + CRLF); "}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.remotecontrol.instrumentation; import com.thoughtworks.selenium.grid.IOHelper; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.ServerSocket; import java.net.Socket;  public class SimplisticHttpServer { private static final Log LOGGER = LogFactory.getLog(SimplisticHttpServer.class); private final HttpRequestProcessor requestProcessor; private final int port; public SimplisticHttpServer(int port, HttpRequestProcessor requestProcessor) { this.requestProcessor = requestProcessor; this.port = port; } public void start() throws Exception { final ServerSocket serverSocket; serverSocket = new ServerSocket(port); LOGGER.info(\"Now listening for incoming connections on \" + serverSocket.getLocalSocketAddress() + \":\" + serverSocket.getLocalPort()); while (true) { processHttpRequest(serverSocket.accept()); } } protected void processHttpRequest(Socket socket) throws Exception { BufferedReader reader = null; BufferedWriter writer = null; LOGGER.info(\"Accepted connection from\" + socket.getInetAddress() + \":\" + socket.getPort()); try { reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); requestProcessor.process(Request.parse(reader)).write(writer); } finally { IOHelper.close(writer); IOHelper.close(reader); IOHelper.close(socket); } } }"}
{"name": "bcotton/selenium-grid", "content": "package com.thoughtworks.selenium.grid.tools; import com.thoughtworks.selenium.DefaultSelenium; import com.thoughtworks.selenium.Selenium; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory;  public class ThreadSafeSeleniumSessionStorage { private final static Log LOGGER = LogFactory.getLog(ThreadSafeSeleniumSessionStorage.class);  private static ThreadLocal<Selenium> threadLocalSelenium = new ThreadLocal<Selenium>(); public static void startSeleniumSession(String seleniumHost, int seleniumPort, String browser, String webSite) { LOGGER.info(\"Contacting Selenium RC at \" + seleniumHost + \":\" + seleniumPort); threadLocalSelenium.set(new DefaultSelenium(seleniumHost, seleniumPort, browser, webSite)); session().start(); LOGGER.info(\"Got Selenese session:\" + session()); } public static void closeSeleniumSession() throws Exception { LOGGER.info(\"Closing Selenese session: \" + session()); if (null != session()) { session().stop(); resetSession(); } } public static Selenium session() { return threadLocalSelenium.get(); } public static void resetSession() { threadLocalSelenium.set(null); } }"}
{"name": "relevance/java-tdd", "content": "package examples; public class Calculator { private int result; public int add(int n) { return result += n; } public int subtract(int n) { return result -= n; } public int reset() { result = 0; return 0; } public int multiply(int n) { return result *= n; } public int divide(int n) { return result /= n; } }"}
{"name": "relevance/java-tdd", "content": "package examples; public class CatalogItem { private String id; private String description; public boolean equals(Object o) { if (o.getClass() != this.getClass()) return false; CatalogItem other = (CatalogItem) o; return (this.id.equals(other.id)) && (this.description.equals(other.description)); } public int hashCode() { return id.hashCode(); } }"}
{"name": "relevance/java-tdd", "content": "package examples; import java.util.Date; public class ExpiringCatalogItem extends CatalogItem { private Date startAvailable; private Date endAvailable; }"}
{"name": "relevance/java-tdd", "content": "package examples;  public class Largest { public static int largestBAD(int [] list) { int max=Integer.MAX_VALUE; if (list == null) { throw new RuntimeException(\"Null list\"); } for (int index = 0; index < list.length - 1; index++) { if (list[index] > max) { max = list[index]; } } return max; } public static int largest(int[] list) { int max=Integer.MIN_VALUE; if (list.length == 0) { throw new RuntimeException(\"Empty list\"); } for (int value : list) { if (value > max) { max = value; } } return max; } }"}
{"name": "relevance/java-tdd", "content": "package examples.family; import java.util.List; import java.util.ArrayList; public class Family { private List<Person> parents; private List<Person> children; public Family() { parents = new ArrayList<Person>(); children = new ArrayList<Person>(); } public Person getParent(int index) { return parents.get(index); } public void setParent(int index, Person element) { parents.set(index, element); } public List<Person> getParents() { return parents; } public List<Person> getChildren() { return children; } }"}
{"name": "relevance/java-tdd", "content": "package examples.family; public class Person { private String lastName; private String firstName; public Person() { } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getFullName() { return firstName + \" \" + lastName; } }"}
{"name": "relevance/java-tdd", "content": "package examples.iphone; public class Address { private String label; private String city; private String state; private String street; private String zipcode; public String getLabel() { return label; } public void setLabel(String label) { this.label = label; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getState() { return state; } public void setState(String state) { this.state = state; } public String getStreet() { return street; } public void setStreet(String street) { this.street = street; } public String getZipcode() { return zipcode; } public void setZipcode(String zipcode) { this.zipcode = zipcode; } }"}
{"name": "relevance/java-tdd", "content": "package examples.iphone; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class Contact { private String name; private List phoneNumbers; private List addresses; public Contact(String name){ this.name = name; phoneNumbers = new ArrayList(); addresses = new ArrayList(); } public String getName() { return name; } public List getPhoneNumbers() { return Collections.unmodifiableList(phoneNumbers); } public Contact addPhoneNumber(String label, String digits){ phoneNumbers.add(new PhoneNumber(label, digits)); return this; } public List getAddresses() { return Collections.unmodifiableList(addresses); } public Contact addAddress(String label, String street, String city, String state, String zipcode){ Address address = new Address(); address.setLabel(label); address.setStreet(street); address.setCity(city); address.setState(state); address.setZipcode(zipcode); addresses.add(address); return this; } }"}
{"name": "relevance/java-tdd", "content": "package examples.iphone; import org.jdom.Document; import org.jdom.Element; import org.jdom.JDOMException; import org.jdom.input.SAXBuilder; import java.io.IOException; import java.io.StringReader; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; public class IPhone { List contacts; public IPhone() { contacts = new ArrayList(); } public List getContacts(){ return Collections.unmodifiableList(contacts); } public int getNumberOfContacts() { return contacts.size(); } public int loadContact(String xml) { try { SAXBuilder builder = new SAXBuilder(); Document doc = builder.build(new StringReader(xml)); Element contactElement = doc.getRootElement(); List phoneNumbers = contactElement.getChildren(\"phoneNumber\"); List addresses = contactElement.getChildren(\"address\"); Contact contact = new Contact(contactElement.getAttributeValue(\"name\")); for (Iterator iterator = phoneNumbers.iterator(); iterator.hasNext();) { Element phoneElement = (Element) iterator.next(); contact.addPhoneNumber(phoneElement.getAttributeValue(\"label\"), phoneElement.getText()); } for (Iterator iterator = addresses.iterator(); iterator.hasNext();) { Element addressElement = (Element) iterator.next(); String label = addressElement.getAttributeValue(\"label\"); String street = addressElement.getChild(\"street\").getText(); String city = addressElement.getChild(\"city\").getText(); String state = addressElement.getChild(\"state\").getText(); String zipcode = addressElement.getChild(\"zipcode\").getText(); contact.addAddress(label, street, city, state, zipcode); } contacts.add(contact); } catch (JDOMException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return getNumberOfContacts(); } }"}
{"name": "relevance/java-tdd", "content": "package examples.iphone; public class PhoneNumber { private String label; private String digits; public PhoneNumber(String label, String digits) { this.label = label; this.digits = digits; } }"}
{"name": "relevance/java-tdd", "content": "package examples.ipod.after; import java.util.*; public class Ipod { private List<Song> songs; public static void main(String[] args) { Ipod iPod = new Ipod(); iPod.play(); } public Ipod() { songs = new ArrayList(); songs.add(new Song(\"All you need is love\", 229)); songs.add(new Song(\"I am the walrus\", 275)); songs.add(new Song(\"Hello, goodbye\", 210)); } public static String prettyTime(int value) { return String.format(\"%02d:%02d\", (value / 60), (value % 60)); } public void play() { int timeRemaining = totalDuration(); System.out.println(songs.size() + \" songs loaded.\"); System.out.println(Ipod.prettyTime(timeRemaining) + \" total playing time.\"); for (Iterator<Song> it = songs.iterator(); it.hasNext();) { Song song = it.next(); System.out.println(\"Now playing: \" + song.getName()); System.out.println(\"\\tTime remaining:\" + Ipod.prettyTime(timeRemaining)); timeRemaining -= song.getDuration(); } System.out.println(\"Playlist complete.\"); } public int totalDuration() { int totalDuration = 0; for (Iterator<Song> it = songs.iterator(); it.hasNext();) { totalDuration += it.next().getDuration(); } return totalDuration; } }"}
{"name": "relevance/java-tdd", "content": "package examples.ipod.after; public class Song extends Object { private final String name; private final int duration; public Song(String name, int duration) { this.name = name; this.duration = duration; } public String getName() { return name; } public int getDuration() { return duration; } }"}
{"name": "relevance/java-tdd", "content": "package examples.ipod.before; import java.util.LinkedHashMap; import java.util.Map; import java.util.Iterator; public class Ipod { public static void main(String[] args) { Ipod iPod = new Ipod(); iPod.play(); } public void play() { Map songs = new LinkedHashMap(); songs.put(\"All you need is love\", new Integer(229)); songs.put(\"I am the walrus\", new Integer(275)); songs.put(\"Hello, goodbye\", new Integer(210)); int totalDuration = 0; for (Iterator iterator = songs.values().iterator(); iterator.hasNext();) { Integer duration = (Integer) iterator.next(); totalDuration += duration.intValue(); } String prettyDuration = (totalDuration / 60) + \":\" + (totalDuration % 60); System.out.println(songs.size() + \" songs loaded.\"); System.out.println(prettyDuration + \" total playing time.\"); int timeRemaining = totalDuration; String prettyTimeRemaining = (timeRemaining / 60) + \":\" + (timeRemaining % 60); for (Iterator iterator = songs.keySet().iterator(); iterator.hasNext();) { String song = (String) iterator.next(); System.out.println(\"Now playing: \" + song); System.out.println(\"\\tTime remaining:\" + prettyTimeRemaining); timeRemaining -= ((Integer)songs.get(song)).intValue(); prettyTimeRemaining = (timeRemaining / 60) + \":\" + (timeRemaining % 60); } System.out.println(\"Playlist complete.\"); } }"}
{"name": "relevance/java-tdd", "content": "package examples.space; public interface CarefulRocket { public boolean dock(); public int addFuel(int requestedAmount); public void undock(); }"}
{"name": "relevance/java-tdd", "content": "package examples.space; public class IncrementalStation { "}
{"name": "relevance/java-tdd", "content": "package examples.space; public interface Rocket { public void dock(); public void attachFuelHose(); public void addFuel(int amount); public void detachFuelHose(); public void undock(); }"}
{"name": "relevance/java-tdd", "content": "package examples.space; public class Station { private int fuel; public void refuel(Rocket r, int amount) { r.dock(); r.attachFuelHose(); r.addFuel(amount); fuel -= amount; r.detachFuelHose(); r.undock(); } public int getFuel() { return fuel; } public void setFuel(int fuel) { this.fuel = fuel; } }"}
{"name": "relevance/java-tdd", "content": "package groovy; public interface OrderItem { int cost(); String display(); }"}
{"name": "relevance/java-tdd", "content": "package cobertura; import cobertura.Pizza; import java.util.ArrayList; import java.util.List; import java.util.Iterator; import java.math.BigDecimal; public class Order { private List<Pizza> pizzas = new ArrayList<Pizza>(); public void add(Pizza za) { pizzas.add(za); } public BigDecimal getSubtotal() { int subtotal = 0; for (Iterator<Pizza> it = pizzas.iterator(); it.hasNext();) { subtotal += it.next().getPrice(); } return new BigDecimal(subtotal); } public BigDecimal getTaxRate() { return new BigDecimal(\".065\"); } public BigDecimal getTax() { return getSubtotal().multiply(getTaxRate()); } public BigDecimal getTotal() { return getSubtotal().add(getTax()); } }"}
{"name": "relevance/java-tdd", "content": "package cobertura; import org.apache.commons.lang.StringUtils; import java.util.*; public class Pizza { private String size; private List<Topping> toppings; private Map sizes; private int baseCookTime; private Pizza(String size, int baseCookTime) { this.size = size; this.baseCookTime = baseCookTime; toppings = new ArrayList(); sizes = new HashMap(); sizes.put(\"Small\", new Integer(10)); sizes.put(\"Medium\", new Integer(15)); sizes.put(\"Large\", new Integer(20)); } public static Pizza small() { return new Pizza(\"Small\", 15); } public static Pizza medium() { return new Pizza(\"Medium\", 25); } public static Pizza large() { return new Pizza(\"Large\", 30); } public String getSize() { return size; } public void addTopping(String topping) { toppings.add(Topping.create(topping)); } public String getToppings() { return StringUtils.join(toppings, \", \"); } public int getPrice() { int price = ((Integer)sizes.get(getSize())).intValue(); for (Iterator<Topping> it = toppings.iterator(); it.hasNext();) { price += it.next().getPrice(); } return price; } public int getCookTime() { int time = baseCookTime; for (Iterator<Topping> it = toppings.iterator(); it.hasNext();) { time += it.next().getExtraCookTime(); } return time; } }"}
{"name": "relevance/java-tdd", "content": "package cobertura; import java.util.Set; import java.util.HashSet;  public class Topping { private String name; private int price; private int extraCookTime; private final static Set standardToppingNames; private Topping(String name, int price, int extraCookTime) { this.name = name; this.price = price; this.extraCookTime = extraCookTime; } static { standardToppingNames = new HashSet(); standardToppingNames.add(\"pepperoni\"); standardToppingNames.add(\"sausage\"); } public static Topping create(String name) { int price = standardToppingNames.contains(name) ? 1 : 2; int extraCookTime = standardToppingNames.contains(name) ? 0 : 2; return new Topping(name, price, extraCookTime); } public int getPrice() { return price; } public String toString() { return name; } public int getExtraCookTime() { return extraCookTime; } }"}
{"name": "relevance/java-tdd", "content": "package cobertura; import cobertura.Pizza; import java.util.ArrayList; import java.util.List; import java.util.Iterator; import java.math.BigDecimal; public class Order { private List<Pizza> pizzas = new ArrayList<Pizza>(); public void add(Pizza za) { pizzas.add(za); } public BigDecimal getSubtotal() { int subtotal = 0; for (Iterator<Pizza> it = pizzas.iterator(); it.hasNext();) { subtotal += it.next().getPrice(); } return new BigDecimal(subtotal); } public BigDecimal getTaxRate() { return new BigDecimal(\".065\"); } public BigDecimal getTax() { return getSubtotal().multiply(getTaxRate()); } public BigDecimal getTotal() { return getSubtotal().add(getTax()); } }"}
{"name": "relevance/java-tdd", "content": "package cobertura; import org.apache.commons.lang.StringUtils; import java.util.*; public class Pizza { private String size; private List<Topping> toppings; private Map sizes; private int baseCookTime; private Pizza(String size, int baseCookTime) { this.size = size; this.baseCookTime = baseCookTime; toppings = new ArrayList(); sizes = new HashMap(); sizes.put(\"Small\", new Integer(10)); sizes.put(\"Medium\", new Integer(15)); sizes.put(\"Large\", new Integer(20)); } public static Pizza small() { return new Pizza(\"Small\", 15); } public static Pizza medium() { return new Pizza(\"Medium\", 25); } public static Pizza large() { return new Pizza(\"Large\", 30); } public String getSize() { return size; } public void addTopping(String topping) { toppings.add(Topping.create(topping)); } public String getToppings() { return StringUtils.join(toppings, \", \"); } public int getPrice() { int price = ((Integer)sizes.get(getSize())).intValue(); for (Iterator<Topping> it = toppings.iterator(); it.hasNext();) { price += it.next().getPrice(); } return price; } public int getCookTime() { int time = baseCookTime; for (Iterator<Topping> it = toppings.iterator(); it.hasNext();) { time += it.next().getExtraCookTime(); } return time; } }"}
{"name": "relevance/java-tdd", "content": "package cobertura; import java.util.Set; import java.util.HashSet;  public class Topping { private String name; private int price; private int extraCookTime; private final static Set standardToppingNames; private Topping(String name, int price, int extraCookTime) { this.name = name; this.price = price; this.extraCookTime = extraCookTime; } static { standardToppingNames = new HashSet(); standardToppingNames.add(\"pepperoni\"); standardToppingNames.add(\"sausage\"); } public static Topping create(String name) { int price = standardToppingNames.contains(name) ? 1 : 2; int extraCookTime = standardToppingNames.contains(name) ? 0 : 2; return new Topping(name, price, extraCookTime); } public int getPrice() { return price; } public String toString() { return name; } public int getExtraCookTime() { return extraCookTime; } }"}
{"name": "relevance/java-tdd", "content": "import org.apache.commons.lang.StringUtils; import java.util.List; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; public class Order { List orderItems; public Order(){ orderItems = new ArrayList(); } public List addItem(OrderItem orderItem){ orderItems.add(orderItem); return Collections.unmodifiableList(orderItems); } public int totalCost(){ int cost = 0; for (Iterator iterator = orderItems.iterator(); iterator.hasNext();) { OrderItem orderItem = (OrderItem) iterator.next(); cost += orderItem.cost(); } return cost; } public String print(){ String out = \"\"; out += StringUtils.center(\"ORDER\", 40); out += \"\\n\"; for (Iterator iterator = orderItems.iterator(); iterator.hasNext();) { OrderItem orderItem = (OrderItem) iterator.next(); out += StringUtils.rightPad(orderItem.display(), 35, \".\"); out += \"$\" + StringUtils.leftPad(Integer.toString(orderItem.cost()), 4); out += \"\\n\"; } out += StringUtils.repeat(\" \", 35); out += StringUtils.repeat(\"-\", 5); out += \"\\n\"; out += StringUtils.repeat(\" \", 35); out += \"$\" + StringUtils.leftPad(Integer.toString(totalCost()), 4); out += \"\\n\"; return out; } }"}
{"name": "relevance/java-tdd", "content": "public interface OrderItem { public int cost(); public String display(); }"}
{"name": "relevance/java-tdd", "content": "public class OrderItemFake implements OrderItem { private final int cost; private final String display; public OrderItemFake(String display, int cost) { this.display = display; this.cost = cost; } public int cost() { return cost; } public String display() { return display; } }"}
{"name": "relevance/java-tdd", "content": "import org.apache.commons.lang.StringUtils; import java.util.List; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; public class Order { List orderItems; public Order(){ orderItems = new ArrayList(); } public List addItem(OrderItem orderItem){ orderItems.add(orderItem); return Collections.unmodifiableList(orderItems); } public int totalCost(){ int cost = 0; for (Iterator iterator = orderItems.iterator(); iterator.hasNext();) { OrderItem orderItem = (OrderItem) iterator.next(); cost += orderItem.cost(); } return cost; } public String print(){ String out = \"\"; out += StringUtils.center(\"ORDER\", 40); out += \"\\n\"; for (Iterator iterator = orderItems.iterator(); iterator.hasNext();) { OrderItem orderItem = (OrderItem) iterator.next(); out += StringUtils.rightPad(orderItem.display(), 35, \".\"); out += \"$\" + StringUtils.leftPad(Integer.toString(orderItem.cost()), 4); out += \"\\n\"; } out += StringUtils.repeat(\" \", 35); out += StringUtils.repeat(\"-\", 5); out += \"\\n\"; out += StringUtils.repeat(\" \", 35); out += \"$\" + StringUtils.leftPad(Integer.toString(totalCost()), 4); out += \"\\n\"; return out; } }"}
{"name": "relevance/java-tdd", "content": "public interface OrderItem { public int cost(); public String display(); }"}
{"name": "relevance/java-tdd", "content": "package mocking; import org.apache.commons.lang.StringUtils; import java.util.List; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; public class Order { List orderItems; public Order(){ orderItems = new ArrayList(); } public List addItem(OrderItem orderItem){ orderItems.add(orderItem); return Collections.unmodifiableList(orderItems); } public int totalCost(){ int cost = 0; for (Iterator iterator = orderItems.iterator(); iterator.hasNext();) { OrderItem orderItem = (OrderItem) iterator.next(); cost += orderItem.cost(); } return cost; } public String print(){ String out = \"\"; out += StringUtils.center(\"ORDER\", 40); out += \"\\n\"; for (Iterator iterator = orderItems.iterator(); iterator.hasNext();) { OrderItem orderItem = (OrderItem) iterator.next(); out += StringUtils.rightPad(orderItem.display(), 35, \".\"); out += \"$\" + StringUtils.leftPad(Integer.toString(orderItem.cost()), 4); out += \"\\n\"; } out += StringUtils.repeat(\" \", 35); out += StringUtils.repeat(\"-\", 5); out += \"\\n\"; out += StringUtils.repeat(\" \", 35); out += \"$\" + StringUtils.leftPad(Integer.toString(totalCost()), 4); out += \"\\n\"; return out; } }"}
{"name": "relevance/java-tdd", "content": "package mocking; public interface OrderItem { public int cost(); public String display(); }"}
{"name": "relevance/java-tdd", "content": "import java.util.Iterator; import java.util.ArrayList; import java.util.List; import java.math.BigDecimal; public class Order { private List<Pizza> pizzas = new ArrayList<Pizza>(); public void add(Pizza za) { pizzas.add(za); } public BigDecimal getSubtotal() { int subtotal = 0; for (Iterator<Pizza> it = pizzas.iterator(); it.hasNext();) { subtotal += it.next().getPrice(); } return new BigDecimal(subtotal); } public BigDecimal getTaxRate() { return new BigDecimal(\".065\"); } public BigDecimal getTax() { return getSubtotal().multiply(getTaxRate()); } public BigDecimal getTotal() { return getSubtotal().add(getTax()); } }"}
{"name": "relevance/java-tdd", "content": "import org.apache.commons.lang.StringUtils; import java.util.*; public class Pizza { private String size; private List<Topping> toppings; private Map sizes; private int baseCookTime; private Pizza(String size, int baseCookTime) { this.size = size; this.baseCookTime = baseCookTime; toppings = new ArrayList(); sizes = new HashMap(); sizes.put(\"Small\", new Integer(10)); sizes.put(\"Medium\", new Integer(15)); sizes.put(\"Large\", new Integer(20)); } public static Pizza small() { return new Pizza(\"Small\", 15); } public static Pizza medium() { return new Pizza(\"Medium\", 25); } public static Pizza large() { return new Pizza(\"Large\", 30); } public String getSize() { return size; } public void addTopping(String topping) { toppings.add(Topping.create(topping)); } public String getToppings() { return StringUtils.join(toppings, \", \"); } public int getPrice() { int price = ((Integer)sizes.get(getSize())).intValue(); for (Iterator<Topping> it = toppings.iterator(); it.hasNext();) { price += it.next().getPrice(); } return price; } public int getCookTime() { int time = baseCookTime; for (Iterator<Topping> it = toppings.iterator(); it.hasNext();) { time += it.next().getExtraCookTime(); } return time; } }"}
{"name": "relevance/java-tdd", "content": "import java.util.Set; import java.util.HashSet;  public class Topping { private String name; private int price; private int extraCookTime; private final static Set standardToppingNames; private Topping(String name, int price, int extraCookTime) { this.name = name; this.price = price; this.extraCookTime = extraCookTime; } static { standardToppingNames = new HashSet(); standardToppingNames.add(\"pepperoni\"); standardToppingNames.add(\"sausage\"); } public static Topping create(String name) { int price = standardToppingNames.contains(name) ? 1 : 2; int extraCookTime = standardToppingNames.contains(name) ? 0 : 2; return new Topping(name, price, extraCookTime); } public int getPrice() { return price; } public String toString() { return name; } public int getExtraCookTime() { return extraCookTime; } }"}
{"name": "relevance/java-tdd", "content": "package lab2.pizza; import java.util.ArrayList; import java.util.List; import java.util.Iterator; public class Order { public static void main(String[] args) { Order order = new Order(); order.placeOrder(); } public void placeOrder(){ Pizza pizza1 = Pizza.large(); pizza1.addTopping(\"cheese\"); pizza1.addTopping(\"peppers\"); pizza1.addTopping(\"onions\"); System.out.println(\"Pizza 1:\\t\" + pizza1.getToppings()); System.out.println(\"Cost:\\t\" + pizza1.getPrice()); Pizza pizza2 = Pizza.medium(); pizza2.addTopping(\"ham\"); pizza2.addTopping(\"pinapple\"); System.out.println(\"Pizza 2:\\t\" + pizza1.getToppings()); System.out.println(\"Cost:\\t\" + pizza1.getPrice()); List orders = new ArrayList(); orders.add(pizza1); orders.add(pizza2); int subtotal = 0; for (Iterator iterator = orders.iterator(); iterator.hasNext();) { Pizza pizza = (Pizza) iterator.next(); subtotal += pizza.getPrice(); } System.out.println(\"Subtotal:\\t\" + subtotal); System.out.println(\"Tax:\\t\" + (subtotal * 0.065)); System.out.println(\"Total:\\t\" + subtotal + (subtotal * 0.065)); } }"}
{"name": "relevance/java-tdd", "content": "import java.util.*; public class Pizza { private String size; private List toppings; private int price; private Map sizes; private Map standardToppings; private Pizza(String size) { this.size = size; toppings = new ArrayList(); sizes = new HashMap(); sizes.put(\"Small\", new Integer(10)); sizes.put(\"Medium\", new Integer(15)); sizes.put(\"Large\", new Integer(20)); standardToppings = new HashMap(); standardToppings.put(\"cheese\", new Integer(1)); standardToppings.put(\"pepperoni\", new Integer(1)); standardToppings.put(\"sausage\", new Integer(1)); } public static Pizza small() { return new Pizza(\"Small\"); } public static Pizza medium() { return new Pizza(\"Medium\"); } public static Pizza large() { return new Pizza(\"Large\"); } public String getSize() { return size; } public String addTopping(String topping) { toppings.add(topping); return topping; } public String getToppings() { String out = \"\"; for (Iterator iterator = toppings.iterator(); iterator.hasNext();) { String topping = (String) iterator.next(); out += topping + \", \"; } out = out.substring(0, (out.length() - 2)); return out; } public int getPrice() { price = 0; price = ((Integer)sizes.get(getSize())).intValue(); for (Iterator iterator = toppings.iterator(); iterator.hasNext();) { String topping = (String) iterator.next(); if(standardToppings.containsKey(topping)){ price += ((Integer)standardToppings.get(topping)).intValue(); } else{ price += 2; } } return price; } }"}
{"name": "relevance/java-tdd", "content": "package pizza.step2; public class Pizza { private final String size; public Pizza(String s) { size = s; } public Object getSize() { return size; } }"}
{"name": "relevance/java-tdd", "content": "package pizza.step3; public class Pizza { private final String size; private Pizza(String size) { this.size = size; } public static Pizza small() { return new Pizza(\"small\"); } public static Pizza medium() { return new Pizza(\"medium\"); } public static Pizza large() { return new Pizza(\"large\"); } public String getSize() { return size; } }"}
{"name": "relevance/java-tdd", "content": "package pizza.step5; import org.apache.commons.lang.StringUtils; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.HashMap; public class Pizza { private final String size; private List toppings; private Pizza(String size) { this.size = size; this.toppings = new ArrayList(); } public static Pizza small() { return new Pizza(\"small\"); } public static Pizza medium() { return new Pizza(\"medium\"); } public static Pizza large() { return new Pizza(\"large\"); } public String getSize() { return size; } public void addTopping(String s) { toppings.add(s); } public Object getToppings() { return StringUtils.join(toppings, \", \"); } }"}
{"name": "relevance/java-tdd", "content": "package pizza.step7; import org.apache.commons.lang.StringUtils; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.HashMap; public class Pizza { private final String size; private List toppings; private static final Map<String, Integer> basePrices; static { HashMap prices = new HashMap(); prices.put(\"small\", 10); prices.put(\"medium\", 15); prices.put(\"large\", 20); basePrices = prices; } private Pizza(String size) { this.size = size; this.toppings = new ArrayList(); } public static Pizza small() { return new Pizza(\"small\"); } public static Pizza medium() { return new Pizza(\"medium\"); } public static Pizza large() { return new Pizza(\"large\"); } public String getSize() { return size; } public void addTopping(String s) { toppings.add(s); } public Object getToppings() { return StringUtils.join(toppings, \", \"); } public int getPrice() { return getBasePrice() + getToppingPrice(); } private int getBasePrice() { return basePrices.get(getSize()); } private int getToppingPrice() { return toppings.size(); } }"}
{"name": "relevance/java-tdd", "content": "package examples;  public class Largest { public static int largest(int [] list) { int max=Integer.MAX_VALUE; if (list == null) { throw new RuntimeException(\"Null list\"); } for (int index = 0; index < list.length - 1; index++) { if (list[index] > max) { max = list[index]; } } return max; } }"}
{"name": "relevance/java-tdd", "content": "/** * Cobertura - http:"}
{"name": "aschearer/shade", "content": "package com.shade; import org.newdawn.slick.AppGameContainer; import org.newdawn.slick.GameContainer; import org.newdawn.slick.SlickException; import org.newdawn.slick.state.StateBasedGame; import org.newdawn.slick.util.Log; import com.shade.states.MasterState; public class Shade extends StateBasedGame { public static final String TITLE = \"Shade\"; private static final String[] ICONS = { \"icons/icon.16.gif\", \"icons/icon.32.gif\", \"icons/icon.64.gif\", \"icons/icon.128.gif\" }; public Shade() { super(TITLE); } @Override public void initStatesList(GameContainer container) throws SlickException { addState(new MasterState()); } public static void main(String[] args) { try { Shade s = new Shade(); AppGameContainer c = new AppGameContainer(s, 800, 600, false); c.setIcons(ICONS); c.setShowFPS(false); c.setTargetFrameRate(60); Log.setVerbose(true); c.start(); } catch (SlickException e) { e.printStackTrace(); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.base; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame;  public interface Animatable { public void render(StateBasedGame game, Graphics g); public void update(StateBasedGame game, int delta); }"}
{"name": "aschearer/shade", "content": "package com.shade.base;  public interface Entity extends Animatable {  public int getRole();  public void addToLevel(Level < ? > l);  public void removeFromLevel(Level < ? > l);  public void onCollision(Entity obstacle); public float getXCenter(); public float getYCenter(); }"}
{"name": "aschearer/shade", "content": "package com.shade.base; import org.newdawn.slick.state.StateBasedGame;  public interface Level<T extends Entity> {  public void add(T e);  public void remove(T e);  public Object[] getEntitiesByRole(int role);  public void clear(); public void update(StateBasedGame game, int delta); public T[] toArray(T[] a); }"}
{"name": "aschearer/shade", "content": "package com.shade.base.util; import com.shade.base.Animatable; import com.shade.base.Entity;  public interface State extends Animatable {  public boolean isNamed(Object o);  public void enter(); public int getRole();  public void onCollision(Entity obstacle); }"}
{"name": "aschearer/shade", "content": "package com.shade.base.util; import java.util.LinkedList; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; import com.shade.base.Entity;  public class StateManager implements Animatable { private LinkedList<State> states; private State currentState; public StateManager() { states = new LinkedList<State>(); currentState = null; }  public void add(State s) { states.add(s); if (currentState == null) { currentState = s; currentState.enter(); } }  public boolean enter(Object o) { for (State s : states) { if (s.isNamed(o)) { currentState = s; currentState.enter(); return true; } } return false; }  public State currentState() { return currentState; } public void update(StateBasedGame game, int delta) { currentState.update(game, delta); } public void onCollision(Entity obstacle) { currentState.onCollision(obstacle); } public void render(StateBasedGame game, Graphics g) { currentState.render(game, g); } public int getRole() { return currentState.getRole(); } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; public interface Button { public void addListener(ClickListener l); }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.state.StateBasedGame; public interface ClickListener { public void onClick(StateBasedGame game, Button clicked); }"}
{"name": "aschearer/shade", "content": "package com.shade.controls;  public interface ControlListener { public void fire(ControlSlice c); }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import com.shade.base.Animatable;  public interface ControlSlice extends Animatable { public void register(ControlListener c); }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import java.util.ArrayList; import java.util.List; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; import com.shade.entities.Basket; import com.shade.entities.Roles; import com.shade.entities.mushroom.Mushroom; public class CounterControl implements MushroomCounter, Animatable { private static final int X_OFFSET = 10; private static final int Y_OFFSET = 10; private static final int MUSHROOM_SCORE = 20; private static final int GOLD_MUSHROOM_SCORE = 3 * MUSHROOM_SCORE; "}
{"name": "aschearer/shade", "content": "package com.shade.controls; public class DayPhaseTimer { public static final float TRANSITION_TIME = 1f / 4; public static final float MAX_SHADOW = 0.4f; private int secondsPerDay; private int timeOfDay; private int startTime, runningTime; DayLightStatus daylight; public enum DayLightStatus { DAWN, DAY, DUSK, NIGHT } public DayPhaseTimer(int seconds) { startTime = 0; runningTime = 0; secondsPerDay = seconds; timeOfDay = 0; } public DayLightStatus getDaylightStatus() { return daylight; } public float timeLeft(){ timeOfDay = runningTime % (secondsPerDay/2); if(daylight == DayLightStatus.DUSK || daylight == DayLightStatus.DAWN){ return (timeOfDay-secondsPerDay * (1f / 2 - TRANSITION_TIME))/(secondsPerDay*TRANSITION_TIME); } else return timeOfDay/(0.5f*secondsPerDay*(1-TRANSITION_TIME)); } public void update(int delta) { runningTime += delta; int timeofday = (runningTime-startTime) % secondsPerDay; "}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; public class FadeInImage implements Animatable { private enum Status { INACTIVE, ACTIVE }; private Image sprite; private Color filter; private int x, y, width, height; private int delay, timer; private Status status; public FadeInImage(Image s, int x, int y, int delay) { this(s, x, y, s.getWidth(), s.getHeight(), delay); } public FadeInImage(Image s, int x, int y, int w, int h, int delay) { this.x = x; this.y = y; this.width = w; this.height = h; this.delay = delay; status = Status.INACTIVE; sprite = s; filter = new Color(Color.white); filter.a = 0; } public void render(StateBasedGame game, Graphics g) { sprite.draw(x, y, width, height, filter); } public void update(StateBasedGame game, int delta) { timer += delta; if (delay < timer) { status = Status.ACTIVE; } if (status != Status.ACTIVE) { return; } if (timer > 100 && filter.a < 1) { timer = 0; filter.a += .05f; } } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; public class FadeInText implements Animatable { private enum Status { INACTIVE, ACTIVE }; private String text; private TrueTypeFont font; private int x, y; private Color color; private int delay, timer; private Status status; public FadeInText(String text, TrueTypeFont font, int x, int y, int delay) { this.text = text; this.font = font; this.x = x; this.y = y; this.delay = delay; color = new Color(Color.white); color.a = 0; status = Status.INACTIVE; } public void render(StateBasedGame game, Graphics g) { font.drawString(x, y, text, color); } public void update(StateBasedGame game, int delta) { timer += delta; if (delay < timer) { status = Status.ACTIVE; } if (status != Status.ACTIVE) { return; } if (timer > 100 && color.a < 1) { timer = 0; color.a += .05f; } } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import java.util.LinkedList; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import sun.security.action.GetBooleanAction; import com.crash.Body; import com.crash.util.CrashGeom; import com.shade.entities.Basket; import com.shade.entities.Obstacle; import com.shade.entities.Player; import com.shade.entities.Roles; import com.shade.entities.mushroom.Mushroom; import com.shade.entities.mushroom.MushroomFactory; import com.shade.levels.Model; import com.shade.lighting.GlobalLight; import com.shade.lighting.LightMask; import com.shade.lighting.LuminousEntity; public class GameSlice { private GlobalLight light; private Model model; private MushroomFactory factory; private LightMask view; private LinkedList<MushroomCounter> controls; "}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable;  public class InstructionImage implements Animatable { private enum State { OFF, FADEIN, FADEOUT }; private float x, y; private int hideTimer, showTimer, alphaTimer; private int hideTime; private State state; private Image sprite; private Color filter; public InstructionImage(float x, float y, Image sprite) { this.x = x; this.y = y; this.sprite = sprite; state = State.OFF; filter = new Color(Color.white); filter.a = 0; }  public void setTimer(int time) { hideTime = time; } public void activate() { filter.a = 0; state = State.FADEIN; } public void deactivate() { state = State.FADEOUT; } public void render(StateBasedGame game, Graphics g) { sprite.draw(x, y, filter); } public void update(StateBasedGame game, int delta) { if (state == State.FADEIN) { hideTimer += delta; if (hideTime < hideTime) { return; } showTimer += delta; alphaTimer += delta; if (alphaTimer > 100 && filter.a < 1) { alphaTimer = 0; filter.a += .05f; } } if (state == State.FADEOUT && filter.a > 0) { alphaTimer += delta; if (alphaTimer > 100) { alphaTimer = 0; filter.a -= .1f; } } } public void reset() { state = State.OFF; filter.a = 0; } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable;  public class InstructionText implements Animatable { private enum State { OFF, FADEIN, FADEOUT }; private float x, y; private String message; private TrueTypeFont font; private int hideTimer, showTimer, alphaTimer; private int hideTime; private State state; private Color color; public InstructionText(float x, float y, String message, TrueTypeFont font) { this.x = x; this.y = y; this.message = message; this.font = font; state = State.OFF; color = new Color(Color.white); color.a = 0; }  public void setTimer(int time) { hideTime = time; } public void activate() { state = State.FADEIN; } public void deactivate() { state = State.FADEOUT; } public void render(StateBasedGame game, Graphics g) { font.drawString(x, y, message, color); } public void update(StateBasedGame game, int delta) { if (state == State.FADEIN) { hideTimer += delta; if (hideTime < hideTime) { return; } showTimer += delta; alphaTimer += delta; if (alphaTimer > 100 && color.a < 1) { alphaTimer = 0; color.a += .05f; } } if (state == State.FADEOUT && color.a > 0) { alphaTimer += delta; if (alphaTimer > 100) { alphaTimer = 0; color.a -= .1f; } } } public void reset() { state = State.OFF; color.a = 0; } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.state.StateBasedGame; public interface KeyListener { public void onPress(StateBasedGame game, int key); }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import java.util.prefs.Preferences; import com.shade.levels.LevelManager;  public class LevelLock { private static final String LEVELS_KEY = \"unlocked-levels\"; private static final String LEVEL_LOCKED = \"0\"; private static final String LEVEL_UNLOCKED = \"1\"; private static final String DELIMITER = \",\"; private static final String STRING_EMPTY = \"\"; private boolean[] unlocked; public LevelLock() { unlocked = new boolean[LevelManager.NUM_LEVELS]; unlocked[0] = true; unlocked = deserialize(); } private boolean[] deserialize() { Preferences prefs = Preferences.userNodeForPackage(this.getClass()); String serial = prefs.get(LEVELS_KEY, STRING_EMPTY); String[] levels = serial.split(DELIMITER); for (int i = 0; i < levels.length; i++) { if (levels[i].equals(LEVEL_UNLOCKED)) { unlocked[i] = true; } } return unlocked; } public boolean isUnlocked(int level) { return unlocked[level]; } public boolean allUnlocked() { for (int i = 0; i < unlocked.length; i++) { if (!unlocked[i]) { return false; } } return true; } public void unlock(int level) { if (unlocked[level]) { return; } unlocked[level] = true; save(); } public void save() { String[] levels = new String[unlocked.length]; for (int i = 0; i < unlocked.length; i++) { if (unlocked[i]) { levels[i] = LEVEL_UNLOCKED; } else { levels[i] = LEVEL_LOCKED; } } String serial = implode(levels, DELIMITER); Preferences prefs = Preferences.userNodeForPackage(this.getClass()); prefs.put(LEVELS_KEY, serial); } private String implode(String[] strings, String glue) { StringBuilder result = new StringBuilder(strings[1]); for (int i = 1; i < strings.length; i++) { result.append(DELIMITER); result.append(strings[i]); } return result.toString(); } public void resetLocks() { unlocked = new boolean[LevelManager.NUM_LEVELS]; unlocked[0] = true; save(); } public void freeFirst(int n) { resetLocks(); for (int i = 1; i < LevelManager.NUM_LEVELS; i++) { if (i < n) { unlocked[i] = true; } } save(); } public void testAndUnlockLevels() { int clear123 = 0; clear123 += SerialStats.read(\"level-1-clear\"); clear123 += SerialStats.read(\"level-2-clear\"); clear123 += SerialStats.read(\"level-3-clear\"); if (clear123 >= 1) { unlock(5); "}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.state.StateBasedGame; import com.shade.entities.Player; import com.shade.entities.mushroom.Mushroom; import com.shade.lighting.LuminousEntity; import com.shade.states.MasterState;  public class MeterControl implements ControlSlice, MushroomCounter { public static final float BASE_DAMAGE = 0.02f; public static final float BASE_EXPONENT = 1.0005f; public static final float GOLD_SCORE_MULTIPLIER = 40; public static final float SCORE_MULTIPLIER = 10; public static final float HEALTH_MULTIPLIER = 1f; public static final float BAR_MAX = 40f; public static final float BASE_RECHARGE = BAR_MAX / 4000f; "}
{"name": "aschearer/shade", "content": "package com.shade.controls; import com.shade.base.Animatable; import com.shade.entities.mushroom.Mushroom; public interface MushroomCounter extends Animatable {  public void onCollect(Mushroom shroomie); }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Graphics; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; public class ScoreControl implements Animatable { private float x, y; private TrueTypeFont font; private float totalScore, levelScore, currentScore; private boolean gameCleared; "}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Graphics; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; public class ScrollingText implements Animatable { private enum Status { IDLE, SCROLLING, OFFSCREEN } private static final float SCROLL_SPEED = -.5f; private String text; private TrueTypeFont font; private float x, y; private float target; private Status status; public ScrollingText(String text, TrueTypeFont font, float x, float y) { this.text = text; this.font = font; this.x = x; this.y = y; this.target = -20; status = Status.IDLE; } public void start() { status = Status.SCROLLING; } public void render(StateBasedGame game, Graphics g) { if (status != Status.OFFSCREEN) { font.drawString(x, y, text); } } public void update(StateBasedGame game, int delta) { if (x == 0) { x = (game.getContainer().getWidth() - font.getWidth(text)) / 2; } if (status == Status.SCROLLING) { y += SCROLL_SPEED; } if (y + font.getHeight() < target) { status = Status.IDLE; } if (y + font.getHeight() < 0) { status = Status.OFFSCREEN; } } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import java.util.prefs.Preferences; import com.shade.levels.LevelManager; public class SerialStats { public static int read(String stat) { Preferences stats = Preferences.userNodeForPackage(SerialStats.class); return stats.getInt(stat, 0); } public static void add(String stat, int value) { value += read(stat); write(stat, value); } public static void write(String stat, int value) { Preferences stats = Preferences.userNodeForPackage(SerialStats.class); stats.putInt(stat, value); } public static void reset(String stat) { write(stat, 0); } public static void resetAll() { for (int i = 0; i < LevelManager.NUM_LEVELS; i++) { String stat = \"level-\" + i + \"-clear\"; SerialStats.reset(stat); } SerialStats.reset(\"golden-mushrooms-collected\"); SerialStats.reset(\"mushrooms-collected\"); SerialStats.reset(\"level-mushrooms-collected\"); } public static void main(String[] args) { for (int i = 0; i < LevelManager.NUM_LEVELS; i++) { String stat = \"level-\" + i + \"-clear\"; SerialStats.reset(stat); } SerialStats.reset(\"golden-mushrooms-collected\"); SerialStats.reset(\"mushrooms-collected\"); SerialStats.reset(\"level-mushrooms-collected\"); } public static boolean allClear() { int beaten = 0; for (int i = 1; i < 11; i++) { beaten += SerialStats.read(\"level-\" + i + \"-clear\"); } return (beaten == 10); } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; import mdes.slick.animation.Easing; import mdes.slick.animation.Timeline; import mdes.slick.animation.entity.SizeEntity; import mdes.slick.animation.entity.renderable.ImageAlpha; import mdes.slick.animation.fx.AlphaFx; import mdes.slick.animation.fx.CompoundFx; import mdes.slick.animation.fx.SizeFx; public class SlickButton implements SizeEntity, Animatable, Button { private static Sound click, hover; private Timeline timeline; private ImageAlpha up, down; private float width, height; private float startWidth, startHeight; private float x, y; private boolean mouseInside, mouseDown; private ClickListener listener; private Object userData; static { try { click = new Sound(\"states/common/click.ogg\"); hover = new Sound(\"states/common/hover.ogg\"); } catch (SlickException e) { e.printStackTrace(); } } public SlickButton(int x, int y, Image u, Image d) throws SlickException { this.x = x; this.y = y; up = new ImageAlpha(u); down = new ImageAlpha(d); down.setAlpha(0f); width = u.getWidth(); height = u.getHeight(); startWidth = width; startHeight = height; final Easing fadeIn = Easing.CUBIC_OUT; final int durationIn = 500; AlphaFx upFadeIn = new AlphaFx(durationIn, up, 0f, 1f, fadeIn); AlphaFx downFadeIn = new AlphaFx(durationIn, down, 0f, 1f, fadeIn); final Easing fadeOut = Easing.LINEAR; final int durationOut = 500; AlphaFx upFadeOut = new AlphaFx(durationOut, up, 1f, 0f, fadeOut); AlphaFx downFadeOut = new AlphaFx(durationOut, down, 1f, 0f, fadeOut); CompoundFx fade1 = new CompoundFx(upFadeOut, downFadeIn); CompoundFx fade2 = new CompoundFx(upFadeIn, downFadeOut); float endWidth = startWidth * 1.1f; float endHeight = startHeight * 1.1f; SizeFx scale1 = new SizeFx(1000, this, startWidth, startHeight, endWidth, endHeight, Easing.ELASTIC_OUT); SizeFx scale2 = new SizeFx(400, this, endWidth, endHeight, startWidth, startHeight, Easing.CUBIC_OUT); timeline = new Timeline(); timeline.add(new CompoundFx(fade1, scale1)); timeline.add(new CompoundFx(fade2, scale2)); } public float getHeight() { return height; } public float getWidth() { return width; } public void setSize(float width, float height) { this.width = width; this.height = height; } public void render(StateBasedGame game, Graphics g) { up.draw(x, y, width, height); down.draw(x, y, width, height); } public void update(StateBasedGame game, int delta) { Input input = game.getContainer().getInput(); int mx = input.getMouseX(); int my = input.getMouseY(); boolean pressed = input.isMouseButtonDown(Input.MOUSE_LEFT_BUTTON); if (mx >= x && mx <= x + width && my >= y && my <= y + height) { if (!mouseInside) { mouseInside = true; onMouseEnter(); } } else { if (mouseInside) { mouseInside = false; onMouseExit(); } } if (pressed && !mouseDown && mouseInside) { mouseDown = true; press(); listener.onClick(game, this); } else if (!pressed && mouseDown) { mouseDown = false; } timeline.update(delta); } public void press() { click.play(); timeline.setActive(true); timeline.setRange(0, 1); timeline.restart(); } public void onMouseEnter() { hover.play(); timeline.setActive(true); timeline.setRange(0, 1); timeline.restart(); } public void onMouseExit() { timeline.setActive(true); timeline.setRange(1, 2); timeline.restart(); } public void reset() { timeline.rewind(); } public void addListener(ClickListener l) { listener = l; } public void setUserData(Object o) { userData = o; } public Object getUserData() { return userData; } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; public class StatMeter implements Animatable { private float x, y; private Image front, back; private float actual, current, total; private TrueTypeFont font; private String stat; private float rateOfChange; public StatMeter(TrueTypeFont f, float x, float y, int actual, int total) throws SlickException { font = f; this.x = x; this.y = y; this.current = 0; this.actual = actual; this.total = total; stat = actual + \"\"; rateOfChange = this.total / 5000; front = new Image(\"states/recap/meter-front.png\"); back = new Image(\"states/recap/meter-back.png\"); } public void render(StateBasedGame game, Graphics g) { back.draw(x, y); float w = front.getWidth(); float h = front.getHeight(); float adjustment = (w * (current / total)); front.draw(x, y, x + adjustment, y + h, 0, 0, adjustment, h); font.drawString(x + 8, y + 4, stat); } public void update(StateBasedGame game, int delta) { if (current < actual) { current += delta * rateOfChange; } } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import java.util.HashMap; import java.util.Map; public class StatsControl { private Map<String, Float> stats; public StatsControl() { stats = new HashMap<String, Float>(); } public void add(String name, float amount) { float current = 0; if (stats.containsKey(name)) { current = stats.get(name); } current += amount; stats.put(name, current); } public void replace(String name, float amount) { stats.put(name, amount); } public float getStat(String name) { return stats.get(name); } public void reset() { stats.clear(); } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls; import java.util.HashMap; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; import mdes.slick.animation.Easing; import mdes.slick.animation.Timeline; import mdes.slick.animation.entity.SizeEntity; import mdes.slick.animation.entity.renderable.ImageAlpha; import mdes.slick.animation.fx.AlphaFx; import mdes.slick.animation.fx.CompoundFx; public class TwoToneButton implements SizeEntity, Animatable, Button { private static Sound click, hover; private Timeline timeline; private ImageAlpha up, down; private float width, height; private float x, y; private boolean mouseInside, mouseDown; private ClickListener listener; private HashMap<Integer, KeyListener> keys; private boolean enabled; static { try { click = new Sound(\"states/common/click.ogg\"); hover = new Sound(\"states/common/hover.ogg\"); } catch (SlickException e) { e.printStackTrace(); } } public TwoToneButton(int x, int y, Image u, Image d) throws SlickException { this.x = x; this.y = y; enabled = true; keys = new HashMap<Integer, KeyListener>(); up = new ImageAlpha(u); down = new ImageAlpha(d); down.setAlpha(0f); width = u.getWidth(); height = u.getHeight(); final Easing fadeIn = Easing.CUBIC_OUT; final int durationIn = 250; AlphaFx upFadeIn = new AlphaFx(durationIn, up, 0f, 1f, fadeIn); AlphaFx downFadeIn = new AlphaFx(durationIn, down, 0f, 1f, fadeIn); final Easing fadeOut = Easing.LINEAR; final int durationOut = 250; AlphaFx upFadeOut = new AlphaFx(durationOut, up, 1f, 0f, fadeOut); AlphaFx downFadeOut = new AlphaFx(durationOut, down, 1f, 0f, fadeOut); CompoundFx fade1 = new CompoundFx(upFadeOut, downFadeIn); CompoundFx fade2 = new CompoundFx(upFadeIn, downFadeOut); timeline = new Timeline(); timeline.add(fade1); timeline.add(fade2); } public float getHeight() { return height; } public float getWidth() { return width; } public void setSize(float width, float height) { this.width = width; this.height = height; } public void register(int key, KeyListener l) { keys.put(key, l); } public void render(StateBasedGame game, Graphics g) { up.draw(x, y, width, height); down.draw(x, y, width, height); } public void update(StateBasedGame game, int delta) { Input input = game.getContainer().getInput(); checkMouse(game, input); for (int key : keys.keySet()) { if (input.isKeyPressed(key) && input.isKeyDown(key) && enabled) { keys.get(key).onPress(game, key); mouseDown = true; press(); } } timeline.update(delta); } private void checkMouse(StateBasedGame game, Input input) { int mx = input.getMouseX(); int my = input.getMouseY(); boolean pressed = input.isMouseButtonDown(Input.MOUSE_LEFT_BUTTON); if (mx >= x && mx <= x + width && my >= y && my <= y + height) { if (!mouseInside) { mouseInside = true; onMouseEnter(); } } else { if (mouseInside) { mouseInside = false; onMouseExit(); } } if (pressed && enabled && !mouseDown && mouseInside) { mouseDown = true; press(); listener.onClick(game, this); } else if (!pressed && mouseDown) { mouseDown = false; } } public void press() { click.play(); timeline.setActive(true); timeline.setRange(0, 2); timeline.restart(); } public void onMouseEnter() { hover.play(); "}
{"name": "aschearer/shade", "content": "package com.shade.controls.text; import org.newdawn.slick.Color; import org.newdawn.slick.Font; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame;  public class AlphaText extends Text { private enum State { FADEIN, FADEOUT; }; private State state; private FadeInText fadein; private FadeOutText fadeout; public AlphaText(String message, Font f, float x, float y) { this(message, f, new Color(Color.white), x, y); } public AlphaText(String message, Font f, Color c, float x, float y) { super(message, f, c, x, y); fadein = new FadeInText(message, f, c, x, y); fadeout = new FadeOutText(message, f, c, x, y); }  public void setDuration(int duration) { fadein.setDuration(duration); fadeout.setDuration(duration); }  public void setPause(int in, int out) { fadein.setPause(in); fadeout.setPause(out); }  @Override public void display(boolean yes) { if (yes) { state = State.FADEIN; fadein.display(yes); } else { state = State.FADEOUT; fadeout.display(yes); } } @Override public void render(StateBasedGame game, Graphics g) { if (state == State.FADEIN) { fadein.render(game, g); } if (state == State.FADEOUT) { fadeout.render(game, g); } } @Override public void update(StateBasedGame game, int delta) { if (state == State.FADEIN) { fadein.update(game, delta); } if (state == State.FADEOUT) { fadeout.update(game, delta); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls.text; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable;  public class AnImage implements Animatable { private static final float MAX_ALPHA = 1; private static final float MIN_ALPHA = 0; private float x, y; private Image sprite; private Color filter; public AnImage(Image i, float x, float y) { this(i, new Color(Color.white), x, y); } public AnImage(Image i, Color c, float x, float y) { sprite = i; filter = c; this.x = x; this.y = y; } public void render(StateBasedGame game, Graphics g) { sprite.draw(x, y, filter); }  public void update(StateBasedGame game, int delta) { "}
{"name": "aschearer/shade", "content": "package com.shade.controls.text; import org.newdawn.slick.Color; import org.newdawn.slick.Font; import org.newdawn.slick.state.StateBasedGame;  public class FadeInText extends Text { private static final int DEFAULT_DURATION = 1000; private float alphaChange; private boolean active; private int timer; public FadeInText(String message, Font f, float x, float y) { this(message, f, new Color(Color.white), x, y); } public FadeInText(String message, Font f, Color c, float x, float y) { super(message, f, c, x, y); display(false); setDuration(DEFAULT_DURATION); }  public void setDuration(int duration) { alphaChange = (float) 1 / duration; }  public void setPause(int duration) { timer = duration; }  @Override public void display(boolean yes) { if (!yes) { super.display(yes); } active = yes; } @Override public void update(StateBasedGame game, int delta) { timer -= delta; if (timer > 0) { return; } if (active) { tweak(alphaChange * delta); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls.text; import org.newdawn.slick.Color; import org.newdawn.slick.Font; import org.newdawn.slick.state.StateBasedGame;  public class FadeOutText extends Text { private static final int DEFAULT_DURATION = 1000; private float alphaChange; private boolean active; private int timer; public FadeOutText(String message, Font f, float x, float y) { this(message, f, new Color(Color.white), x, y); } public FadeOutText(String message, Font f, Color c, float x, float y) { super(message, f, c, x, y); display(true); setDuration(DEFAULT_DURATION); }  public void setDuration(int duration) { alphaChange = (float) 1 / duration; }  public void setPause(int duration) { timer = duration; }  @Override public void display(boolean yes) { if (yes) { super.display(yes); } active = !yes; } @Override public void update(StateBasedGame game, int delta) { timer -= delta; if (timer > 0) { return; } if (active) { tweak(alphaChange * delta); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.controls.text; import org.newdawn.slick.Color; import org.newdawn.slick.Font; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable;  public class Text implements Animatable { private static final float MAX_ALPHA = 1; private static final float MIN_ALPHA = 0; private float x, y; private String content; private Font font; private Color color;  public Text(String message, Font f, float x, float y) { this(message, f, new Color(Color.white), x, y); }  public Text(String message, Font f, Color c, float x, float y) { content = message; font = f; this.x = x; this.y = y; color = c; }  public void render(StateBasedGame game, Graphics g) { font.drawString(x, y, content, color); }  public void update(StateBasedGame game, int delta) { "}
{"name": "aschearer/shade", "content": "package com.shade.crash; import com.crash.Body; import com.shade.util.Geom; public class CrashGeom {  public static float distance2(Body one, Body two) { float x = one.getXCenter() - two.getXCenter(); x = x * x; float y = one.getYCenter() - two.getYCenter(); y = y * y; return (x + y); } public static float distance2(Body one, float x2, float y2) { float x = one.getXCenter() - x2; x = x * x; float y = one.getYCenter() - y2; y = y * y; return (x + y); } public static float distance(Body one, Body two) { return (float) Math.sqrt(distance2(one, two)); } public static float distance(Body one, float x2, float y2) { return (float) Math.sqrt(distance2(one, x2, y2)); } public static float calculateAngle(Body one, Body two) { float x1 = one.getXCenter(); float y1 = one.getYCenter(); float x2 = two.getXCenter(); float y2 = two.getYCenter(); return Geom.calculateAngle(x1, y1, x2, y2); } public static float calculateAngle(Body one, float x2, float y2) { float x1 = one.getXCenter(); float y1 = one.getYCenter(); return Geom.calculateAngle(x1, y1, x2, y2); } }"}
{"name": "aschearer/shade", "content": "package com.shade.crash; import java.util.Collections; import java.util.Comparator; import java.util.LinkedList; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.crash.Grid; import com.crash.Response; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.lighting.LuminousEntity;  public class CrashLevel implements Level<LuminousEntity> { private Grid grid; private LinkedList<LuminousEntity> entities; public CrashLevel(int w, int h, int c) { entities = new LinkedList<LuminousEntity>(); grid = new Grid(w, h, c); grid.setResponse(new Response() { public void respond(Body one, Body two) { Entity e1 = (Entity) one; Entity e2 = (Entity) two; e1.onCollision(e2); e2.onCollision(e1); } }); } public void add(LuminousEntity e) { e.addToLevel(this); entities.add(e); grid.add((Body) e); } public void remove(LuminousEntity e) { e.removeFromLevel(this); entities.remove(e); grid.remove((Body) e); } public Object[] getEntitiesByRole(int role) { LinkedList<LuminousEntity> players = new LinkedList<LuminousEntity>(); for (LuminousEntity e : entities) { if (e.getRole() == role) { players.add(e); } } return players.toArray(); } public void clear() { for (Entity e : entities) { e.removeFromLevel(this); } entities.clear(); grid.clear(); } public void update(StateBasedGame game, int delta) { grid.update(); for (int i = 0; i < entities.size(); i++) { entities.get(i).update(game, delta); } } public LuminousEntity[] toArray(LuminousEntity[] a) { return entities.toArray(a); } public LuminousEntity[] toArray() { return entities.toArray(new LuminousEntity[0]); } public boolean lineOfSight(Entity one, Entity two, Body... exceptions) { return grid.ray((Body) one, (Body) two, exceptions); } public LuminousEntity[] nearbyEntities(final Entity subject, int threshold) { int threshold2 = threshold * threshold; LinkedList<LuminousEntity> neighbors = new LinkedList<LuminousEntity>(); for (LuminousEntity e : entities) { if (CrashGeom.distance2((Body) subject, (Body) e) < threshold2) { neighbors.add(e); } } Collections.sort(neighbors, new Comparator<LuminousEntity>() { public int compare(LuminousEntity e1, LuminousEntity e2) { float d1 = CrashGeom.distance2((Body) subject, (Body) e1); float d2 = CrashGeom.distance2((Body) subject, (Body) e2); return (int) (d1 - d2); } }); return neighbors.toArray(new LuminousEntity[0]); } }"}
{"name": "aschearer/shade", "content": "package com.shade.crash; import com.crash.Body;  public interface Repelable {  public void repel(Body b); }"}
{"name": "aschearer/shade", "content": "package com.shade.entities; import java.util.LinkedList; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.controls.MushroomCounter; import com.shade.entities.mushroom.Mushroom; import com.shade.lighting.LuminousEntity; import com.shade.states.MasterState; public class Basket extends Linkable { private static final int BASKET_WIDTH = 65; private static final int BASKET_HEIGHT = 40; private static final int BASKET_DEPTH = 0; private Image sprite; private float luminosity; private LinkedList<MushroomCounter> counters; public Basket(int x, int y) throws SlickException { initShape(x, y, BASKET_WIDTH, BASKET_HEIGHT); initSprite(); counters = new LinkedList<MushroomCounter>(); } private void initSprite() throws SlickException { sprite = new Image(\"entities/basket/basket.png\"); } private void initShape(float x, float y, float w, float h) { shape = new Rectangle(x, y, w, h); } public void add(MushroomCounter c) { counters.add(c); } @SuppressWarnings(\"unchecked\") public void addToLevel(Level < ? > l) { } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PICKED_MUSHROOM.ordinal()) { Mushroom m = (Mushroom) obstacle; notifyCounters(m); m.detach(); } if(obstacle.getRole() == Roles.TREASURE.ordinal()){ Mushroom m = (Mushroom) obstacle; "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Polygon; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.util.Geom; public class Block extends Obstacle { public Block(int x, int y, int z, int d) throws SlickException { initShape(x, y, d, d); zindex = z; initSprite(); } private void initSprite() throws SlickException { sprite = new Image(\"entities/block/block.png\"); } private void initShape(int x, int y, int w, int h) { shape = new Rectangle(x, y, w, h); }  public Shape castShadow(float direction, float depth) { Vector2f v = Geom.calculateVector(zindex * depth, direction); Transform t = Transform.createTranslateTransform(v.x, v.y); Polygon extent = (Polygon) shape.transform(t); int index = findKeyPoint(v); Polygon shade = new Polygon(); for (int i = 1; i < 4; i++) { int c = (4 + index + i) % 4; float[] p = extent.getPoint(c); shade.addPoint(p[0], p[1]); } for (int i = 3; i > 0; i--) { int c = (4 + index + i) % 4; float[] p = shape.getPoint(c); shade.addPoint(p[0], p[1]); } return shade; }  private int findKeyPoint(Vector2f v) { int index = 0; if (v.y > 0) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.RoundedRectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.crash.Repelable; import com.shade.lighting.LuminousEntity; public class Dome extends Obstacle { public Dome(int x, int y, int z, int d) throws SlickException { initShape(x, y, d); zindex = z; initSprite(); } private void initSprite() throws SlickException { sprite = new Image(\"entities/dome/dome.png\"); } private void initShape(int x, int y, int r) { shape = new Circle(x, y, r); } public void render(StateBasedGame game, Graphics g) { sprite.draw(getX(), getY(), getWidth(), getHeight()); "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.geom.Polygon; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.levels.Model; import com.shade.util.Geom; public class Door extends Obstacle { private enum ActiveSide { TOP, RIGHT, BOTTOM, LEFT }; private static Sound open; private ActiveSide softspot; private int times, timer; private boolean swingOpen; private float x, y, width, height; private float heading; private float xPivot, yPivot; private Image door, arrow; static { try { open = new Sound(\"entities/door/open.ogg\"); } catch (SlickException e) { e.printStackTrace(); } } public Door(int x, int y, int z, int r) throws SlickException { softspot = ActiveSide.values()[r]; int w = (r == 0 || r == 2) ? 60 : 11; int h = (r == 1 || r == 3) ? 60 : 11; initShape(x, y, w, h); this.x = x; this.y = y; width = w; height = h; initPivot(r); initResources(r); zindex = z; } private void initResources(int r) throws SlickException { if (r == 0 || r == 2) { door = new Image(\"entities/door/door-horizontal.png\"); } if (r == 1 || r == 3) { door = new Image(\"entities/door/door-vertical.png\"); } arrow = new Image(\"entities/door/arrow.png\"); if (r == 0) { arrow.rotate(180); } if (r == 1) { arrow.rotate(-90); } if (r == 3) { arrow.rotate(90); } } private void initPivot(int r) { if (r == 0) { xPivot = getX() + getWidth(); yPivot = getYCenter(); } if (r == 1) { xPivot = getXCenter(); yPivot = getY() + getHeight(); } if (r == 2) { xPivot = getX(); yPivot = getYCenter(); } if (r == 3) { xPivot = getXCenter(); yPivot = getY(); } } private void initShape(int x, int y, int w, int h) { shape = new Rectangle(x, y, w, h); } public Shape castShadow(float direction, float depth) { Vector2f v = Geom.calculateVector(getZIndex() * depth, direction); Transform t = Transform.createTranslateTransform(v.x, v.y); Polygon extent = (Polygon) shape.transform(t); int index = 0; if (swingOpen) { float distance = Float.MAX_VALUE; for (int i = 0; i < extent.getPointCount(); i++) { float[] p = closestPoint(extent.getPoint(i), shape.getPoints()); float d = Geom.distance2(extent.getPoint(i), p[0], p[1]); if (d < distance) { index = i; distance = d; } } } else { if (v.y > 0) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.lighting.LuminousEntity;  public class Dummy extends Body implements LuminousEntity { private float x, y; private Image sprite; public Dummy(float x, float y, Image s) { this.x = x; this.y = y; sprite = s; float width = s.getWidth(); float height = s.getHeight(); shape = new Rectangle(x - width / 2, y - height / 2, width, height); } public Shape castShadow(float direction, float depth) { return null; } public float getLuminosity() { return 0; } public int getZIndex() { return 0; } public void setLuminosity(float l) { } public void addToLevel(Level<?> l) { } public int getRole() { return Roles.DUMMY.ordinal(); } public void onCollision(Entity obstacle) { } public void removeFromLevel(Level<?> l) { } public void render(StateBasedGame game, Graphics g) { sprite.drawCentered(x, y); } public void update(StateBasedGame game, int delta) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Polygon; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.util.Geom; public class Fence extends Obstacle { public Fence(int x, int y, int z, int r) throws SlickException { int w = (r == 0) ? 120 : 11; int h = (r == 0) ? 11 : 120; initShape(x, y, w, h); zindex = z; initSprite(w, h); } private void initShape(float x, float y, float w, float h) { shape = new Rectangle(x, y, w, h); } private void initSprite(float w, float h) throws SlickException { String path = \"entities/fence/fence.vertical.png\"; if (w > h) { path = \"entities/fence/fence.horizontal.png\"; } sprite = new Image(path); } public Shape castShadow(float direction, float depth) { Vector2f v = Geom.calculateVector(zindex * depth, direction); Transform t = Transform.createTranslateTransform(v.x, v.y); Polygon extent = (Polygon) shape.transform(t); int index = 0; if (v.y > 0) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import com.crash.Body; import com.shade.lighting.LuminousEntity;  public abstract class Linkable extends Body implements LuminousEntity { public Linkable prev, next;  public void attach(Linkable l) { if (next == null) { next = l; l.prev = this; return; } Linkable head = next; while (head.next != null) { head = head.next; } head.next = l; l.prev = head; }  public void detachAll(){ if(prev!= null) prev.next = null; if(next!=null)next.detachAll(); prev = null; next = null; }  public void detach() { if (prev != null) { prev.next = next; } if (next != null) { next.prev = prev; } prev = null; next = null; }  protected boolean contains(Linkable l) { Linkable head = next; while (head != null) { if (head.equals(l)) { return true; } head = head.next; } return false; }  protected void testAndWrap() { if (getXCenter() <= 5) { shape.setCenterX(795); } if (getXCenter() > 795) { shape.setCenterX(5); } if (getYCenter() <= 5) { shape.setCenterY(595); } if (getYCenter() > 595) { shape.setCenterY(5); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.state.StateBasedGame; public class MockPlayer extends Player { public MockPlayer(int x, int y) throws SlickException { super(x, y); invincibleTimer = 0; } @Override public void update(StateBasedGame game, int delta) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.crash.util.CrashGeom; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.crash.Repelable; import com.shade.levels.Model; import com.shade.lighting.LuminousEntity; abstract public class Obstacle extends Body implements LuminousEntity, Repelable{ public static int maxRank; protected Model model; protected int zindex; protected Image sprite; private int rank = -1; public int rank() { if (rank < 0) { calculateRank(); } return 1; "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.base.util.State; import com.shade.base.util.StateManager; import com.shade.crash.CrashLevel; import com.shade.crash.Repelable; import com.shade.entities.bird.Bird; import com.shade.entities.mushroom.Mushroom; import com.shade.entities.util.Sizzle2; import com.shade.entities.util.Sparkler; import com.shade.lighting.LuminousEntity; public class Player extends Linkable { public static final int INVINCIBLE_START = 3000; public static final float MIN_SPEED = 2.4f; public static final float MAX_SPEED = 3.6f; public static final float INITIAL_SPEED = MAX_SPEED / 2 + MIN_SPEED / 2; private static final int MUSHROOM_LIMIT = 3; private static final int PLAYER_HEIGHT = 3; private enum PlayerState { NORMAL, STUNNED }; private StateManager manager; protected Image normal; private float luminosity; private Sound register, damage; private boolean impeded; private float mileage; protected int invincibleTimer, flipper, flipthreshold; private Sizzle2[] sizzles; private float speed; public Player(int x, int y) throws SlickException { initShape(x, y); initResources(); initSizzles(); initStates(); invincibleTimer = INVINCIBLE_START; flipthreshold = 1; speed = INITIAL_SPEED; } public void initSizzles() { sizzles = new Sizzle2[8]; for (int i = 0; i < sizzles.length; i++) { int x = (int) (Math.cos(Math.PI * 2 * i / 8) * getWidth() * 2 / 5); int y = (int) (Math.sin(Math.PI * 2 * i / 8) * getHeight() * 2 / 5); try { sizzles[i] = new Sizzle2(this,10, x, y, \"entities/sparkle/puff.png\"); } catch (Exception e) { e.printStackTrace(); } } } private void sizzle(Graphics g) { for (int i = 0; i < sizzles.length; i++) { sizzles[i].animate(g); } } private void initShape(int x, int y) { shape = new Circle(x, y, 18); } private void initResources() throws SlickException { normal = new Image(\"entities/player/player.png\"); register = new Sound(\"entities/player/register.ogg\"); damage = new Sound(\"entities/player/hit.ogg\"); } private void initStates() { manager = new StateManager(); manager.add(new NormalState()); manager.add(new StunnedState()); } public void stun() { manager.enter(Player.PlayerState.STUNNED); damage.play(); } private class NormalState implements State { public boolean isNamed(Object state) { return state == PlayerState.NORMAL; } public void enter() { } public int getRole() { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; public enum Roles { PLAYER, MONSTER, BIRD, SPAWNLING, MUSHROOM, OBSTACLE, MOLE, BASKET, PICKED_MUSHROOM, DUMMY, SANDPIT, MOCK_PLAYER, TREASURE }"}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.lighting.LuminousEntity; public class SandPit extends Body implements LuminousEntity { private float luminosity; private Image sprite; public SandPit(int x, int y, int d, int o) throws SlickException { if (o == 0) { initCircle(x, y, d); } else { initSquare(x, y, d, d); } } private void initSquare(int x, int y, int w, int h) throws SlickException { shape = new Rectangle(x, y, w, h); sprite = new Image(\"entities/sandpit/square.png\"); } private void initCircle(int x, int y, int r) throws SlickException { shape = new Circle(x, y, r); sprite = new Image(\"entities/sandpit/circle.png\"); } public Shape castShadow(float direction, float depth) { return null; } public float getLuminosity() { return luminosity; } public int getZIndex() { return 0; } public void setLuminosity(float l) { luminosity = l; } public void addToLevel(Level<?> l) { } public int getRole() { return Roles.SANDPIT.ordinal(); } public void onCollision(Entity obstacle) { } public void removeFromLevel(Level<?> l) { } public void render(StateBasedGame game, Graphics g) { sprite.draw(getX(), getY(), getWidth(), getHeight() ); "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Polygon; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.states.MasterState; import com.shade.util.Geom; public class Slider extends Obstacle { private enum ActiveDirection { UP, RIGHT, DOWN, LEFT }; private float velocity; private ActiveDirection direction; private int timer; public Slider(int x, int y, int z, int r, int range, float speed) throws SlickException { int w = (r == 1 || r == 3) ? 65 : 11; int h = (r == 1 || r == 3) ? 11 : 65; initShape(x, y, w, h); zindex = z; initSprite(r); direction = ActiveDirection.values()[r]; velocity = (float) ((float) speed * (float) range / MasterState.SECONDS_OF_DAYLIGHT); } private void initShape(float x, float y, float w, float h) { shape = new Rectangle(x, y, w, h); } private void initSprite(int r) throws SlickException { if (r == 0 || r == 2) { sprite = new Image(\"entities/slider/slider.vertical.png\"); } else { sprite = new Image(\"entities/slider/slider.horizontal.png\"); } } public Shape castShadow(float direction, float depth) { Vector2f v = Geom.calculateVector(zindex * depth, direction); Transform t = Transform.createTranslateTransform(v.x, v.y); Polygon extent = (Polygon) shape.transform(t); int index = 0; if (v.y > 0) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.geom.Polygon; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.crash.Repelable; import com.shade.levels.Model; import com.shade.lighting.LuminousEntity; import com.shade.util.Geom; public class TransparentDoor extends Body implements LuminousEntity, Repelable { private enum ActiveSide { TOP, RIGHT, BOTTOM, LEFT }; private static Sound open; private ActiveSide softspot; private int zindex; private float luminosity; private int times, timer; private boolean active; private float x, y, width, height; private float heading; private float xPivot, yPivot; private Image door, arrow; static { try { open = new Sound(\"entities/door/open.ogg\"); } catch (SlickException e) { e.printStackTrace(); } } public TransparentDoor(int x, int y, int z, int r) throws SlickException { softspot = ActiveSide.values()[r]; int w = (r == 0 || r == 2) ? 60 : 11; int h = (r == 1 || r == 3) ? 60 : 11; initShape(x, y, w, h); this.x = x; this.y = y; width = w; height = h; initPivot(r); initResources(r); zindex = z; } private void initResources(int r) throws SlickException { if (r == 0 || r == 2) { door = new Image(\"entities/door/door-horizontal-translucent.png\"); } if (r == 1 || r == 3) { door = new Image(\"entities/door/door-vertical-translucent.png\"); } arrow = new Image(\"entities/door/arrow.png\"); if (r == 0) { arrow.rotate(180); } if (r == 1) { arrow.rotate(-90); } if (r == 3) { arrow.rotate(90); } } private void initPivot(int r) { if (r == 0) { xPivot = getX() + getWidth(); yPivot = getYCenter(); } if (r == 1) { xPivot = getXCenter(); yPivot = getY() + getHeight(); } if (r == 2) { xPivot = getX(); yPivot = getYCenter(); } if (r == 3) { xPivot = getXCenter(); yPivot = getY(); } } private void initShape(int x, int y, int w, int h) { shape = new Rectangle(x, y, w, h); } public Shape castShadow(float direction, float depth) { return null; /* Vector2f v = Geom.calculateVector(getZIndex() * depth, direction); Transform t = Transform.createTranslateTransform(v.x, v.y); Polygon extent = (Polygon) shape.transform(t); int index = 0; if (active) { float distance = Float.MAX_VALUE; for (int i = 0; i < extent.getPointCount(); i++) { float[] p = closestPoint(extent.getPoint(i), shape.getPoints()); float d = Geom.distance2(extent.getPoint(i), p[0], p[1]); if (d < distance) { index = i; distance = d; } } } else { if (v.y > 0) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Polygon; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.crash.Repelable; import com.shade.lighting.LuminousEntity; import com.shade.util.Geom; public class TransparentFence extends Fence { private Image sprite; public TransparentFence(int x, int y, int z, int r) throws SlickException { super(x,y,z,r); int w = (r == 0) ? 120 : 11; int h = (r == 0) ? 11 : 120; initShape(x, y, w, h); initSprite(w, h); } private void initShape(float x, float y, float w, float h) { shape = new Rectangle(x, y, w, h); } private void initSprite(float w, float h) throws SlickException { String path = \"entities/fence/fence.transparent.vertical.png\"; if (w > h) { path = \"entities/fence/fence.transparent.horizontal.png\"; } sprite = new Image(path); } public Shape castShadow(float direction, float depth) { return null; } public void render(StateBasedGame game, Graphics g) { sprite.draw(getX(), getY(), getWidth(), getHeight()); "}
{"name": "aschearer/shade", "content": "package com.shade.entities; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.RoundedRectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.geom.Transform; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.lighting.LuminousEntity; public class Umbrella extends Body implements LuminousEntity { private static final int RADIUS = 28; private static final int DEPTH = 5; private Image sprite; private int height; public Umbrella(int x, int y) throws SlickException { initShape(x, y, RADIUS); height = DEPTH; initSprite(); } private void initSprite() throws SlickException { sprite = new Image(\"entities/umbrella/umbrella.png\"); } private void initShape(int x, int y, int r) { shape = new Circle(x, y, r); } public void onCollision(Entity obstacle) { } public void render(StateBasedGame game, Graphics g) { sprite.draw(getX() - 1, getY() - 1, getWidth() + 2, getHeight() + 2); "}
{"name": "aschearer/shade", "content": "package com.shade.entities.bird; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class AttackingBird implements State { public static final int ATTACK_TIME = 1500; public static final int COOLDOWN_TIME = 500; private Bird bird; private Animation idling; private int timer; public AttackingBird(Bird me) throws SlickException { this.bird = me; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/bird/attack.png\", 40, 40); idling = new Animation(idles, 600); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { bird.attacking = true; if (!Bird.attack.playing()) { Bird.attack.play(); } timer = 0; idling.restart(); } public int getRole() { return Roles.MONSTER.ordinal(); } public boolean isNamed(Object o) { return o == Bird.States.ATTACKING; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.bird; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.base.util.StateManager; import com.shade.controls.DayPhaseTimer; import com.shade.crash.CrashLevel; import com.shade.crash.Repelable; import com.shade.entities.Basket; import com.shade.entities.Player; import com.shade.entities.Roles; import com.shade.entities.mushroom.Mushroom; import com.shade.levels.Model; import com.shade.lighting.LuminousEntity;  public final class Bird extends Body implements LuminousEntity { protected enum States { WAITING, RETURNING, ATTACKING, SLEEPING, MIGRATING } protected CrashLevel level; protected StateManager manager; protected Mushroom target; protected float heading; protected float range; protected float speed; protected boolean attacking; private float luminosity; protected static Sound alert, attack; static { try { alert = new Sound(\"entities/bird/alert.ogg\"); attack = new Sound(\"entities/bird/attack.ogg\"); } catch (SlickException e) { e.printStackTrace(); } } public Bird(int x, int y, int range, float speed) throws SlickException { heading = (float) (Math.PI); this.range = range; this.speed = speed; initShape(x, y); initStates(); } public boolean isAttacking() { return attacking; } private void initShape(float x, float y) { shape = new Circle(x, y, 21f); } private void initStates() throws SlickException { manager = new StateManager(); manager.add(new ReturningBird(this)); manager.add(new AttackingBird(this)); manager.add(new WaitingBird(this)); manager.add(new SleepingBird(this)); } protected void kill() { level.remove(this); } public void move(double rate) { float x = (float) (Math.cos(heading - Math.PI / 2) * speed * rate); float y = (float) (Math.sin(heading - Math.PI / 2) * speed * rate); nudge(x, y); } public float getLuminosity() { return luminosity; } public void setLuminosity(float l) { luminosity = l; } public void addToLevel(Level<?> l) { level = (CrashLevel) l; } public int getRole() { return Roles.BIRD.ordinal(); } public void onCollision(Entity obstacle) { manager.onCollision(obstacle); } public boolean canChase() { return playerInSight() && playerInRange(); } public boolean playerInSight() { Object[] o = level.getEntitiesByRole(Roles.PLAYER.ordinal()); if (o.length > 0) { Player p = (Player) o[0]; return level.lineOfSight(this, p, this, (Basket) level .getEntitiesByRole(Roles.BASKET.ordinal())[0]) && p.getLuminosity() > 0.6; } return false; } public boolean playerInRange() { Object[] o = level.getEntitiesByRole(Roles.PLAYER.ordinal()); if (o.length > 0) { Player p = (Player) o[0]; float distx = p.getXCenter() - getXCenter(); float disty = p.getYCenter() - getYCenter(); return Math.sqrt(distx * distx + disty * disty) < range; } return false; } public void render(StateBasedGame game, Graphics g) { g.rotate(getXCenter(), getYCenter(), (float) Math.toDegrees(heading)); manager.render(game, g); g.resetTransform(); } public void yawn() { Model mode = (Model) level; if (mode.getTimer().getDaylightStatus() == DayPhaseTimer.DayLightStatus.NIGHT) { manager.enter(States.SLEEPING); } } public void wake() { Model mode = (Model) level; if (mode.getTimer().getDaylightStatus() == DayPhaseTimer.DayLightStatus.DAWN) { manager.enter(States.WAITING); } } public void update(StateBasedGame game, int delta) { manager.update(game, delta); testAndWrap(); }  protected void testAndWrap() { if (getXCenter() <= 5) { shape.setCenterX(795); } if (getXCenter() > 795) { shape.setCenterX(5); } if (getYCenter() <= 5) { shape.setCenterY(595); } if (getYCenter() > 595) { shape.setCenterY(5); } } public Shape castShadow(float direction, float depth) { return null; } public int getZIndex() { return 20; } public int compareTo(LuminousEntity l) { return getZIndex() - l.getZIndex(); } public void removeFromLevel(Level<?> l) { level.remove(this); } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.bird; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.CrashLevel; import com.shade.entities.Roles;  public class ReturningBird implements State { private Bird bird; private Animation idling; private int timer; private Body nest; public ReturningBird(Bird me) throws SlickException { this.bird = me; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/bird/fly.png\", 40, 40); idling = new Animation(idles, 75); idling.setAutoUpdate(false); "}
{"name": "aschearer/shade", "content": "package com.shade.entities.bird; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class SleepingBird implements State { private Bird bird; private Animation idling; private int timer; public SleepingBird(Bird me) throws SlickException { this.bird = me; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/bird/fly.png\", 40, 40); idling = new Animation(false); idling.addFrame(idles.getSprite(0, 0), 300); idling.addFrame(idles.getSprite(1, 0), 300); idling.addFrame(idles.getSprite(2, 0), 300); idling.setPingPong(true); } public void enter() { timer = 0; idling.restart(); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Bird.States.SLEEPING; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.bird; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.Music; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Player; import com.shade.entities.Roles;  public class WaitingBird implements State { private Bird bird; private Animation idling; private int timer; public WaitingBird(Bird me) throws SlickException { this.bird = me; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/bird/fly.png\", 40, 40); idling = new Animation(idles, 125); idling.setAutoUpdate(false); "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mole; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.crash.CrashLevel; import com.shade.entities.Linkable; import com.shade.entities.Roles; import com.shade.lighting.LuminousEntity; public class Hole extends Linkable { private int timer; private float luminosity; private CrashLevel level; public Hole(float x, float y) { initShape(x, y); } private void initShape(float x, float y) { shape = new Circle(x, y, 15); } public float getLuminosity() { return luminosity; } public void setLuminosity(float l) { luminosity = l; } public int getZIndex() { return 0; } public Shape castShadow(float direction, float depth) { return null; } public void addToLevel(Level<?> l) { level = (CrashLevel) l; } public void removeFromLevel(Level<?> l) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mole; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class IdleMole implements State { private Mole mole; private Animation idling; private int timer; public IdleMole(Mole mole) throws SlickException { this.mole = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/mole/sniff.png\", 40, 40); idling = new Animation(idles, 300); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { timer = 0; idling.restart(); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Mole.States.IDLE; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.MUSHROOM.ordinal()) { mole.manager.enter(Mole.States.WORKING); } } public void render(StateBasedGame game, Graphics g) { idling.draw(mole.getX(), mole.getY(), mole.getWidth(), mole.getHeight()); } public void update(StateBasedGame game, int delta) { idling.update(delta); testTimer(delta); testForTarget(mole); } private void testTimer(int delta) { timer += delta; if (timer > 10000) { mole.kill(); } } private void testForTarget(Mole mole) { if (timer > 5000 && Util.foundTarget(mole)) { mole.manager.enter(Mole.States.WORKING); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.mole; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.base.util.StateManager; import com.shade.crash.CrashLevel; import com.shade.entities.Linkable; import com.shade.entities.mushroom.Mushroom; import com.shade.entities.util.MoleFactory; import com.shade.lighting.LuminousEntity;  public final class Mole extends Linkable { protected enum States { SPAWNING, IDLE, WORKING } protected CrashLevel level; protected StateManager manager; protected Mushroom target; protected float heading; private MoleFactory factory; private float luminosity; public Mole(float x, float y, MoleFactory factory) throws SlickException { this.factory = factory; heading = (float) (Math.PI); initShape(x, y); initStates(); } private void initShape(float x, float y) { shape = new Circle(x, y, 12f); } private void initStates() throws SlickException { manager = new StateManager(); manager.add(new SpawningMole(this)); manager.add(new IdleMole(this)); manager.add(new WorkerMole(this)); } protected boolean hasCollected(Mushroom m) { return contains(m); } protected void kill() { target = null; detachAll(); factory.remove(this); level.remove(this); } public float getLuminosity() { return luminosity; } public void setLuminosity(float l) { luminosity = l; } public void addToLevel(Level < ? > l) { level = (CrashLevel) l; } public void removeFromLevel(Level < ? > l) { factory.remove(this); } public int getRole() { return manager.getRole(); } public void onCollision(Entity obstacle) { manager.onCollision(obstacle); } public void render(StateBasedGame game, Graphics g) { g.rotate(getXCenter(), getYCenter(), (float) Math.toDegrees(heading)); manager.render(game, g); g.resetTransform(); } public void update(StateBasedGame game, int delta) { manager.update(game, delta); testAndWrap(); } public Shape castShadow(float direction, float depth) { return null; } public int getZIndex() { return 2; } public int compareTo(LuminousEntity l) { return getZIndex() - l.getZIndex(); } public int mushroomsCollected() { if (next == null) { return 0; } int i = 1; Linkable head = next; while (head.next != null) { i++; head = head.next; } return i; } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.mole; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class SpawningMole implements State { private Mole mole; private int timer; private boolean clear; public SpawningMole(Mole mole) { this.mole = mole; } public void enter() { timer = 0; clear = true; } public int getRole() { return Roles.SPAWNLING.ordinal(); } public boolean isNamed(Object o) { return o == Mole.States.SPAWNING; } public void onCollision(Entity obstacle) { clear = false; } public void render(StateBasedGame game, Graphics g) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mole; import com.shade.base.Entity; import com.shade.entities.mushroom.Mushroom; import com.shade.entities.Roles; import com.shade.lighting.LuminousEntity;  public class Util {  public static boolean foundTarget(Mole mole) { LuminousEntity[] entities = mole.level.nearbyEntities(mole, 200); int i = findValidTarget(entities, mole); if (i > 0) { mole.target = (Mushroom) entities[i]; return true; } return false; } private static int findValidTarget(LuminousEntity[] entities, Mole mole) { boolean lineOfSight = false; int i = 0; while (!lineOfSight && i < entities.length) { if (((Entity) entities[i]).getRole() == Roles.MUSHROOM.ordinal()) { lineOfSight = mole.level.lineOfSight(mole, entities[i], mole); } i++; } i--; return (lineOfSight) ? i : -1; } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.mole; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.CrashGeom; import com.shade.entities.Roles; import com.shade.entities.mushroom.Mushroom; import com.shade.util.Geom;  public class WorkerMole implements State { private static final int WORK_TIME = 5000; private Mole mole; private Animation working; private int timer; public WorkerMole(Mole mole) throws SlickException { this.mole = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet works = new SpriteSheet(\"entities/mole/move.png\", 40, 40); working = new Animation(works, 300); working.setAutoUpdate(false); } public void enter() { working.restart(); timer = 0; } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Mole.States.WORKING; } public void onCollision(Entity obstacle) { if (obstacle.equals(mole.target)) { mole.target = null; timer = 0; } if (obstacle.getRole() == Roles.OBSTACLE.ordinal()) { mole.kill(); } } public void render(StateBasedGame game, Graphics g) { working.draw(mole.getX(), mole.getY(), mole.getWidth(), mole .getHeight()); } public void update(StateBasedGame game, int delta) { working.update(delta); testTimer(delta); testForTarget(mole); testAndMove(mole); } private void testTimer(int delta) { timer += delta; if (timer > WORK_TIME) { mole.kill(); "}
{"name": "aschearer/shade", "content": "package com.shade.entities.monster; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Player; import com.shade.entities.Roles;  public class ChasingMonster implements State { private Monster monster; private Animation idling; private int timer; public ChasingMonster(Monster mole) throws SlickException { this.monster = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/mole/sniff.png\", 40, 40); idling = new Animation(idles, 300); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { timer = 0; idling.restart(); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Monster.States.CHASING; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { monster.manager.enter(Monster.States.WANDERING); } } public void render(StateBasedGame game, Graphics g) { idling.draw(monster.getX(), monster.getY(), monster.getWidth(), monster .getHeight()); } private void chase() { if (monster.playerInSight()) { Player p = (Player) monster.level.getEntitiesByRole(Roles.PLAYER .ordinal())[0]; float distx = p.getXCenter() - monster.getXCenter(); float disty = p.getYCenter() - monster.getYCenter(); monster.heading = (float) (Math.atan2(disty, distx) + Math.PI / 2); monster.move(1); } else monster.manager.enter(Monster.States.LOST); } public void update(StateBasedGame game, int delta) { idling.update(delta); chase(); testTimer(delta); } private void testTimer(int delta) { timer += delta; if (timer > 20000) { monster.manager.enter(Monster.States.PROWLING); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.monster; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class LostMonster implements State { private Monster monster; private Animation idling; private int timer; public LostMonster(Monster mole) throws SlickException { this.monster = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/mole/sniff.png\", 40, 40); idling = new Animation(idles, 300); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { timer = 0; idling.restart(); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Monster.States.LOST; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { monster.manager.enter(Monster.States.WANDERING); } } public void render(StateBasedGame game, Graphics g) { idling.draw(monster.getX(), monster.getY(), monster.getWidth(), monster.getHeight()); } public void update(StateBasedGame game, int delta) { idling.update(delta); testTimer(delta); } private void testTimer(int delta) { timer += delta; if (timer > 1000) { monster.manager.enter(Monster.States.PROWLING); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.monster; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.base.util.StateManager; import com.shade.controls.DayPhaseTimer; import com.shade.crash.CrashLevel; import com.shade.crash.Repelable; import com.shade.entities.Basket; import com.shade.entities.Player; import com.shade.entities.Roles; import com.shade.entities.mushroom.Mushroom; import com.shade.levels.Model; import com.shade.lighting.LuminousEntity;  public final class Monster extends Body implements LuminousEntity{ protected enum States { PROWLING, SLEEPING, LOST, CHASING, WANDERING, SNIFFING } protected CrashLevel level; protected StateManager manager; protected Mushroom target; protected float heading; protected float range; protected float speed; private float luminosity; public Monster(int x, int y, int range, float speed) throws SlickException { heading = (float) (Math.PI); this.range = range; this.speed = speed; initShape(x, y); initStates(); } private void initShape(float x, float y) { shape = new Circle(x, y, 18f); } private void initStates() throws SlickException { manager = new StateManager(); manager.add(new ProwlingMonster(this)); manager.add(new ChasingMonster(this)); manager.add(new SleepingMonster(this)); manager.add(new LostMonster(this)); manager.add(new SniffingMonster(this)); manager.add(new WanderingMonster(this)); } protected void kill() { level.remove(this); } public void move(double rate){ float x = (float)(Math.cos(heading-Math.PI/2)*speed*rate); float y = (float)(Math.sin(heading-Math.PI/2)*speed*rate); nudge(x,y); } public float getLuminosity() { return luminosity; } public void setLuminosity(float l) { luminosity = l; } public void addToLevel(Level < ? > l) { level = (CrashLevel) l; } public int getRole() { return Roles.MONSTER.ordinal(); } public void onCollision(Entity obstacle) { manager.onCollision(obstacle); if (obstacle.getRole() == Roles.OBSTACLE.ordinal()) { Repelable b = (Repelable) obstacle; b.repel(this); } } public boolean canChase(){ return playerInSight() && playerInRange(); } public boolean playerInSight(){ Player p = (Player)level.getEntitiesByRole(Roles.PLAYER.ordinal())[0]; return level.lineOfSight(this,p, this,(Basket)level.getEntitiesByRole(Roles.BASKET.ordinal())[0]) && p.getLuminosity()>0.6; } public boolean playerInRange(){ Player p = (Player)level.getEntitiesByRole(Roles.PLAYER.ordinal())[0]; float distx = p.getXCenter()-getXCenter(); float disty = p.getYCenter()-getYCenter(); return Math.sqrt(distx*distx+disty*disty)<range; } public void render(StateBasedGame game, Graphics g) { g.rotate(getXCenter(), getYCenter(), (float) Math.toDegrees(heading)); manager.render(game, g); g.resetTransform(); } public void yawn(){ Model mode = (Model)level; if(mode.getTimer().getDaylightStatus()==DayPhaseTimer.DayLightStatus.NIGHT){ manager.enter(States.SLEEPING); } } public void wake(){ Model mode = (Model)level; if(mode.getTimer().getDaylightStatus()==DayPhaseTimer.DayLightStatus.DAWN){ manager.enter(States.PROWLING); } } public void update(StateBasedGame game, int delta) { manager.update(game, delta); testAndWrap(); }  protected void testAndWrap() { if (getXCenter() <= 5) { shape.setCenterX(795); } if (getXCenter() > 795) { shape.setCenterX(5); } if (getYCenter() <= 5) { shape.setCenterY(595); } if (getYCenter() > 595) { shape.setCenterY(5); } } public Shape castShadow(float direction, float depth) { return null; } public int getZIndex() { return 2; } public int compareTo(LuminousEntity l) { return getZIndex() - l.getZIndex(); } public void removeFromLevel(Level<?> l) { level.remove(this); } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.monster; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class ProwlingMonster implements State { private Monster monster; private Animation idling; private int timer; public ProwlingMonster(Monster mole) throws SlickException { this.monster = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/mole/sniff.png\", 40, 40); idling = new Animation(idles, 300); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { timer = 0; monster.heading = (float)(Math.random()*Math.PI*2); idling.restart(); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Monster.States.PROWLING; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { monster.manager.enter(Monster.States.WANDERING); } } public void render(StateBasedGame game, Graphics g) { idling.draw(monster.getX(), monster.getY(), monster.getWidth(), monster.getHeight()); } public void update(StateBasedGame game, int delta) { idling.update(delta); hunt(); monster.yawn(); testTimer(delta); } private void hunt(){ monster.move(0.3); if(monster.canChase()){ monster.manager.enter(Monster.States.CHASING); } } private void testTimer(int delta) { timer += delta; if (timer > 3000) { if(Math.random()>0.8) monster.manager.enter(Monster.States.SNIFFING); else timer -= Math.random()*2500; } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.monster; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class SleepingMonster implements State { private Monster monster; private Animation idling; private Animation snores; private int timer; public SleepingMonster(Monster mole) throws SlickException { this.monster = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/mole/sleep.png\", 40, 40); SpriteSheet z = new SpriteSheet(\"entities/mole/z.png\",40,40); snores = new Animation(z,900); idling = new Animation(idles, 600); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { timer = 0; snores.restart(); idling.restart(); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Monster.States.SLEEPING; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { monster.manager.enter(Monster.States.WANDERING); } } public void render(StateBasedGame game, Graphics g) { snores.draw(monster.getX()+monster.getWidth()/2, monster.getY()+monster.getHeight()/2, monster.getWidth(), monster.getHeight()); idling.draw(monster.getX(), monster.getY(), monster.getWidth(), monster.getHeight()); } public void update(StateBasedGame game, int delta) { idling.update(delta); snores.update(delta); monster.wake(); testTimer(delta); } private void testTimer(int delta) { timer+=delta; } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.monster; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class SniffingMonster implements State { private Monster monster; private Animation idling; private int timer; public SniffingMonster(Monster mole) throws SlickException { this.monster = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/mole/sniff.png\", 40, 40); idling = new Animation(idles, 300); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { timer = 0; idling.restart(); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Monster.States.SNIFFING; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { monster.manager.enter(Monster.States.WANDERING); } } public void render(StateBasedGame game, Graphics g) { idling.draw(monster.getX(), monster.getY(), monster.getWidth(), monster .getHeight()); } public void update(StateBasedGame game, int delta) { idling.update(delta); hunt(); monster.yawn(); testTimer(delta); } private void hunt() { if (monster.canChase()) { monster.manager.enter(Monster.States.CHASING); } } private void testTimer(int delta) { timer += delta; if (timer > 1500) { if (Math.random() > 0.4) { monster.heading += (float) ((Math.random() - 0.5) * 3/2 * Math.PI); monster.manager.enter(Monster.States.SNIFFING); } else monster.manager.enter(Monster.States.PROWLING); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.monster; import org.newdawn.slick.Animation; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Player; import com.shade.entities.Roles;  public class WanderingMonster implements State { private Monster monster; private Animation idling; private int timer; public WanderingMonster(Monster mole) throws SlickException { this.monster = mole; initResources(); } private void initResources() throws SlickException { SpriteSheet idles = new SpriteSheet(\"entities/mole/sniff.png\", 40, 40); idling = new Animation(idles, 300); idling.setAutoUpdate(false); idling.setPingPong(true); } public void enter() { timer = 0; idling.restart(); Player p = (Player) monster.level.getEntitiesByRole(Roles.PLAYER .ordinal())[0]; float distx = p.getXCenter() - monster.getXCenter(); float disty = p.getYCenter() - monster.getYCenter(); monster.heading = (float) (Math.atan2(disty, distx) - Math.PI / 2); } public int getRole() { return Roles.MOLE.ordinal(); } public boolean isNamed(Object o) { return o == Monster.States.WANDERING; } public void onCollision(Entity obstacle) { if (obstacle.getRole() == Roles.PLAYER.ordinal()) { monster.manager.enter(Monster.States.WANDERING); } } public void render(StateBasedGame game, Graphics g) { idling.draw(monster.getX(), monster.getY(), monster.getWidth(), monster.getHeight()); } public void update(StateBasedGame game, int delta) { idling.update(delta); testTimer(delta); monster.move(0.5); } private void testTimer(int delta) { timer += delta; if (timer > 5000) { monster.manager.enter(Monster.States.SNIFFING); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import org.newdawn.slick.Graphics; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.Repelable; import com.shade.entities.Roles; import com.shade.util.Geom; public class CollectedShroom implements State { private Mushroom shroom; private boolean killed; private boolean blocked; public CollectedShroom(Mushroom mushroom) { shroom = mushroom; } public void enter() { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.Repelable; import com.shade.entities.Player; import com.shade.entities.Roles; public class FlyingShroom implements State { public static final int FLIGHT_TIME = 100; public static final double speed = 10; private Mushroom shroom; private int timer; private double angle; public FlyingShroom(Mushroom mushroom) { shroom = mushroom; } public void enter() { shroom.detach(); Player p = (Player)shroom.level.getEntitiesByRole(Roles.PLAYER.ordinal())[0]; float x = shroom.getXCenter(); float y = shroom.getYCenter(); float destx = p.getXCenter(); float desty = p.getYCenter(); float distx = destx-x; float disty = desty-y; angle = Math.random()*Math.PI+Math.atan2(disty,distx); timer = 0; } public int getRole() { return Roles.MUSHROOM.ordinal(); } public boolean isNamed(Object o) { return o == Mushroom.States.FLYING; } public void onCollision(Entity obstacle) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.base.util.StateManager; import com.shade.crash.CrashLevel; import com.shade.entities.Linkable; import com.shade.entities.util.Sparkler; import com.shade.lighting.LuminousEntity; import com.shade.states.MasterState; public class Mushroom extends Linkable { protected static final float SPEED = 3.2f; private static final float RADIUS = 3f; private static final float SCALE_INCREMENT = .02f; private static final float MAX_SCALE = 3.5f; private static final float MIN_SCALE = 2f; private Sparkler sparky; protected enum States { SPAWNING, NORMAL, PICKED, COLLECTED, FLYING }; protected enum Types { POISON, NORMAL, GOOD, RARE }; protected StateManager manager; protected float scale; private Types type; private Image mushroom; private float luminosity; private MushroomFactory factory; protected CrashLevel level; private static SpriteSheet sheet; protected static Sound spawning, picked, poisonPicked, collected; static { try { sheet = new SpriteSheet(\"entities/mushroom/mushrooms.png\", 40, 40); spawning = new Sound(\"entities/mushroom/sprout.ogg\"); picked = new Sound(\"entities/mushroom/picked.ogg\"); poisonPicked = new Sound(\"entities/mushroom/poison-picked.ogg\"); collected = new Sound(\"entities/mushroom/collected.ogg\"); } catch (SlickException e) { e.printStackTrace(); } } "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import java.util.LinkedList; import java.util.Queue; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.GameContainer; import org.newdawn.slick.SlickException; import com.crash.Body; import com.shade.entities.Basket; import com.shade.util.Geom; public class MushroomFactory {  private static final double[] distribution = { 0, .9, 0, .1 }; private static final double PROPENSITY = .002; private static final float BASKET_THRESHOLD = 10000; private static final float GOLD_BASKET_THRESHOLD = 20000; private static final int GOLD_RATIO_INVERSE =10;  private int floor; private double propensity;  private LinkedList<Mushroom> mushrooms;  private Queue<Integer> upcomingType;  public MushroomFactory(int floor) { this.floor = floor; this.propensity = PROPENSITY; mushrooms = new LinkedList<Mushroom>(); upcomingType = new LinkedList<Integer>(); }  public boolean active() { if (mushrooms.size() < floor) { return true; } return (Math.random() <= propensity); } public Mushroom getMushroom(GameContainer c, Shape shadow, Body b) throws SlickException { try { float x = randomX(c, shadow); float y = randomY(c, shadow); int t = nextType();"}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Linkable; import com.shade.entities.Roles; public class NormalShroom implements State { private Mushroom shroom; public NormalShroom(Mushroom mushroom) { shroom = mushroom; } public void enter() { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import org.newdawn.slick.Graphics; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.Repelable; import com.shade.entities.Roles; import com.shade.util.Geom; public class PickedShroom implements State { private Mushroom shroom; public PickedShroom(Mushroom mushroom) { shroom = mushroom; } public void enter() { } public int getRole() { return Roles.PICKED_MUSHROOM.ordinal(); } public boolean isNamed(Object o) { return o == Mushroom.States.PICKED; } public void onCollision(Entity obstacle) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class SpawningShroom implements State { private Mushroom shroom; private int timer; private boolean clear; private MushroomFactory factory; public SpawningShroom(Mushroom mushroom, MushroomFactory Factory) { shroom = mushroom; factory = Factory; } public void enter() { timer = 0; clear = true; shroom.setLuminosity(1f); } public int getRole() { return Roles.SPAWNLING.ordinal(); } public boolean isNamed(Object o) { return o == Mushroom.States.SPAWNING; } public void onCollision(Entity obstacle) { clear = false; } public void render(StateBasedGame game, Graphics g) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.mushroom; import java.util.Arrays; import com.crash.Body; import com.shade.crash.CrashGeom; import com.shade.entities.Linkable; public class WrappingUtils {  public static boolean overThreshold(Body shroom, Body target, float threshold) { float[] d = new float[3]; d[0] = CrashGeom.distance2(target, shroom); d[1] = d[0]; d[2] = d[0]; "}
{"name": "aschearer/shade", "content": "package com.shade.entities.treasure; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.Repelable; import com.shade.entities.Roles; import com.shade.entities.treasure.Treasure.States; import com.shade.util.Geom; public class CollectedTreasure implements State { private Treasure treasure; private boolean killed; public CollectedTreasure(Treasure t) { treasure = t; } public void enter() { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.treasure; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.Repelable; import com.shade.entities.Player; import com.shade.entities.Roles; public class FlyingTreasure implements State { public static final int FLIGHT_TIME = 100; public static final double speed = 10; private Treasure shroom; private int timer; private double angle; public FlyingTreasure(Treasure treasure) { shroom = treasure; } public void enter() { shroom.detach(); Player p = (Player)shroom.level.getEntitiesByRole(Roles.PLAYER.ordinal())[0]; float x = shroom.getXCenter(); float y = shroom.getYCenter(); float destx = p.getXCenter(); float desty = p.getYCenter(); float distx = destx-x; float disty = desty-y; angle = Math.random()*Math.PI+Math.atan2(disty,distx); timer = 0; } public int getRole() { return Roles.MUSHROOM.ordinal(); } public boolean isNamed(Object o) { return o == Treasure.States.FLYING; } public void onCollision(Entity obstacle) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.treasure; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Linkable; import com.shade.entities.Roles; public class NormalTreasure implements State { private Treasure treasure; public NormalTreasure(Treasure mushroom) { treasure = mushroom; } public void enter() { treasure.close(); } public int getRole() { return Roles.TREASURE.ordinal(); } public boolean isNamed(Object o) { return o == Treasure.States.NORMAL; } public void onCollision(Entity obstacle) { if (isPicker(obstacle)) { ((Linkable) obstacle).attach(treasure); if (treasure.prev != null) { treasure.manager.enter(Treasure.States.PICKED); if (treasure.isPoison()) { Treasure.poisonPicked.play(); } else { Treasure.picked.play(); } } } if (obstacle.getRole() == Roles.BASKET.ordinal()) { Treasure.collected.play(); treasure.detach(); treasure.kill(); } } private boolean isPicker(Entity obstacle) { return obstacle.getRole() == Roles.PLAYER.ordinal() || obstacle.getRole() == Roles.MOLE.ordinal(); } public void render(StateBasedGame game, Graphics g) { treasure.draw(g); } public void update(StateBasedGame game, int delta) { if (treasure.tooSmall()) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.treasure; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.geom.Vector2f; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.crash.Repelable; import com.shade.entities.Roles; import com.shade.entities.treasure.Treasure.States; import com.shade.util.Geom; public class PickedTreasure implements State { private Treasure treasure; public PickedTreasure(Treasure t) { treasure = t; } public void enter() { treasure.open(); } public int getRole() { return Roles.TREASURE.ordinal(); } public boolean isNamed(Object o) { return o == Treasure.States.PICKED; } public void onCollision(Entity obstacle) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.treasure; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Entity; import com.shade.base.util.State; import com.shade.entities.Roles;  public class ReturningTreasure implements State { private Treasure treasure; private int timer, failmer; private boolean clear; public ReturningTreasure(Treasure t) { treasure = t; } public void enter() { timer = 0; clear = true; treasure.detach(); treasure.scale = Treasure.MAX_SCALE; } public int getRole() { return Roles.SPAWNLING.ordinal(); } public boolean isNamed(Object o) { return o == Treasure.States.RETURNING; } public void onCollision(Entity obstacle) { clear = false; } public void render(StateBasedGame game, Graphics g) { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.treasure; import org.lwjgl.opengl.GL11; import org.newdawn.slick.Color; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.geom.Circle; import org.newdawn.slick.geom.Rectangle; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.crash.Body; import com.shade.base.Entity; import com.shade.base.Level; import com.shade.base.util.StateManager; import com.shade.crash.CrashLevel; import com.shade.crash.Repelable; import com.shade.entities.mushroom.Mushroom; import com.shade.entities.util.Sparkler; import com.shade.lighting.LuminousEntity; import com.shade.states.MasterState; public class Treasure extends Mushroom implements Repelable { protected static final float SPEED = 2.2f; private static final float RADIUS = 12f; public static final float MAX_SCALE = 1f; private static final float MIN_SCALE = 0.3f; public static final int SECONDS_OF_LIFE = 1700; public static final float SCALE_INCREMENT = (MAX_SCALE - MIN_SCALE) / SECONDS_OF_LIFE; private float spawn_x; private float spawn_y; private boolean open; protected boolean collect; private Sparkler sparky; private float sunAngle; protected enum States { RETURNING, NORMAL, PICKED, COLLECTED, FLYING }; protected enum Types { POISON, NORMAL, GOOD, RARE }; protected StateManager manager; protected float scale; private Types type; private float luminosity; protected CrashLevel level; private static SpriteSheet chestOpen; private static SpriteSheet chestClosed; protected static Sound spawning, picked, poisonPicked, collected; static { try { chestOpen = new SpriteSheet(\"entities/treasure/TreasureOpened.png\", 64, 51); chestClosed = new SpriteSheet( \"entities/treasure/TreasureClosed.png\", 39, 50); spawning = new Sound(\"entities/mushroom/sprout.ogg\"); picked = new Sound(\"entities/mushroom/picked.ogg\"); poisonPicked = new Sound(\"entities/mushroom/poison-picked.ogg\"); collected = new Sound(\"entities/mushroom/collected.ogg\"); } catch (SlickException e) { e.printStackTrace(); } } public Treasure(int x, int y, int z) throws SlickException { type = null; scale = MAX_SCALE; open = false; collect = false; initShape(x, y); spawn_x = shape.getX(); spawn_y = shape.getY(); initResources(); initStates(); sparky = new Sparkler(this,3); } private void initShape(float x, float y) { shape = new Rectangle(x, y, chestClosed.getWidth(), chestClosed .getHeight()); shape.setCenterX(x); shape.setCenterY(y); } public void open() { open = true; float centx = shape.getCenterX(); float centy = shape.getCenterY(); shape = new Circle(spawn_x, spawn_y, RADIUS * scale); shape.setCenterX(centx); shape.setCenterY(centy); } public void close() { open = false; float centx = shape.getCenterX(); float centy = shape.getCenterY(); shape = new Rectangle(spawn_x, spawn_y, chestClosed.getWidth(), chestClosed.getHeight()); shape.setCenterX(centx); shape.setCenterY(centy); scale = MAX_SCALE; } private void initResources() throws SlickException { "}
{"name": "aschearer/shade", "content": "package com.shade.entities.treasure; import java.util.Arrays; import com.crash.Body; import com.shade.crash.CrashGeom; import com.shade.entities.Linkable; public class Util {  protected static boolean overThreshold(Treasure shroom, Body target, float threshold) { float[] d = new float[3]; d[0] = CrashGeom.distance2(target, shroom); d[1] = d[0]; d[2] = d[0]; "}
{"name": "aschearer/shade", "content": "package com.shade.entities.util; import java.util.LinkedList; import org.newdawn.slick.GameContainer; import org.newdawn.slick.SlickException; import org.newdawn.slick.geom.Shape; import com.shade.entities.mole.Mole; public class MoleFactory { private int limit; private LinkedList<Mole> moles; public MoleFactory(int limit) { this.limit = limit; moles = new LinkedList<Mole>(); } public boolean active() { return moles.size() < limit; } public Mole getMole(GameContainer c, Shape shadow) throws SlickException { try { float x = randomX(c, shadow); float y = randomY(c, shadow); Mole m = new Mole(x, y, this); moles.add(m); return m; } catch (MoleFactoryException e) { return null; } } private float randomX(GameContainer c, Shape s) throws MoleFactoryException { float x = -1; int numTries = 0; while (x < 0 || x >= c.getWidth()) { x = (float) (s.getMaxX() - s.getX() * Math.random()); x += s.getX(); numTries++; if (numTries > 6) { throw new MoleFactoryException(\"Can't find valid point.\"); } } return x; } private float randomY(GameContainer c, Shape s) throws MoleFactoryException { float y = -1; int numTries = 0; while (y < 0 || y >= c.getHeight()) { y = (float) (s.getMaxY() - s.getY() * Math.random()); y += s.getY(); numTries++; if (numTries > 6) { throw new MoleFactoryException(\"Can't find valid point.\"); } } return y; } public void remove(Mole m) { moles.remove(m); } @SuppressWarnings(\"serial\") private class MoleFactoryException extends Exception { public MoleFactoryException(String message) { super(message); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.util; import org.lwjgl.opengl.GL11; import org.newdawn.slick.Color; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; public class Sizz { float x; float y; private SpriteSheet image; private float scale; private Sizzle2 daddy; private float increment; private float scale_max; private int startTime; private int time; public Sizz(float x, float y, float max_scale, float incr, int start, String source, Sizzle2 s) throws SlickException { daddy = s; time = 0; startTime = start; scale_max = max_scale; increment = incr; this.x = x; this.y = y; try{ image = new SpriteSheet(source, 20, 20); } catch (Exception e){ e.printStackTrace(); } } public void draw(){ if(x*y!=1&&time>startTime){ image.draw(x-image.getWidth()/2*scale, y-image.getHeight()/2*scale, scale, new Color(1f,1f,1f,(0.5f-scale)/0.75f+0.25f)); } } public void update(int delta){ time+=delta; if(scale<scale_max&&time>=startTime){ scale += (float)delta*increment; } else if(scale>=scale_max) renewPoint(); } private void renewPoint(){ time = 0; scale = 0.1f; float[] newPoint = daddy.getPoint(); if(newPoint!=null){ x = newPoint[0]; y = newPoint[1]; } } }"}
{"name": "aschearer/shade", "content": "package com.shade.entities.util; import java.util.ArrayList; import java.util.List; import org.lwjgl.opengl.GL11; import org.newdawn.slick.Graphics; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.SlickException; import com.crash.Body; import com.shade.states.MasterState; public class Sizzle2 { public static final float MAX_SCALEUP = 0.5f; public static final int MAX_SPARKLES = 50; public static final float increment = 0.002f; private ArrayList<Sizz> sparkles; "}
{"name": "aschearer/shade", "content": "package com.shade.entities.util; import java.util.ArrayList; import java.util.List; import org.lwjgl.opengl.GL11; import org.newdawn.slick.Graphics; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.SlickException; import com.crash.Body; public class Sparkler { private int sparkleCount; public static final float MAX_SCALEUP = 0.5f; public static final float increment = 0.001f; private Sparkle[] sparkles; "}
{"name": "aschearer/shade", "content": "package com.shade.levels; import org.newdawn.slick.SlickException;  public class LevelManager { public static final int NUM_LEVELS = 11;  private String[] levels = { \"levels/level-0.xml\", \"levels/level-1.xml\", \"levels/level-2.xml\", "}
{"name": "aschearer/shade", "content": "package com.shade.levels; import java.util.ArrayList; import java.util.HashMap; import org.newdawn.slick.SlickException; import org.newdawn.slick.util.xml.SlickXMLException; import org.newdawn.slick.util.xml.XMLElement; import org.newdawn.slick.util.xml.XMLElementList; import org.newdawn.slick.util.xml.XMLParser; import com.shade.entities.mushroom.MushroomFactory; import com.shade.lighting.LuminousEntity; import com.shade.util.Reflection; public class LevelSerial { private HashMap<String, String> mappings; private XMLElement root; public LevelSerial(String path) throws SlickException { XMLParser xml = new XMLParser(); root = xml.parse(path); mappings = new HashMap<String, String>(); mappings.put(\"Block\", \"com.shade.entities.Block\"); mappings.put(\"Dome\", \"com.shade.entities.Dome\"); mappings.put(\"Basket\", \"com.shade.entities.Basket\"); mappings.put(\"Player\", \"com.shade.entities.Player\"); mappings.put(\"MockPlayer\", \"com.shade.entities.MockPlayer\"); mappings.put(\"Fence\", \"com.shade.entities.Fence\"); mappings.put(\"Door\", \"com.shade.entities.Door\"); mappings.put(\"Monster\", \"com.shade.entities.monster.Monster\"); mappings.put(\"Bird\", \"com.shade.entities.bird.Bird\"); mappings.put(\"Sand\", \"com.shade.entities.SandPit\"); mappings.put(\"Slider\", \"com.shade.entities.Slider\"); mappings.put(\"TransparentDoor\", \"com.shade.entities.TransparentDoor\"); mappings.put(\"TransparentFence\", \"com.shade.entities.TransparentFence\"); mappings.put(\"Treasure\", \"com.shade.entities.treasure.Treasure\"); mappings.put(\"Bush\", \"com.shade.entities.Bush\"); mappings.put(\"Umbrella\", \"com.shade.entities.Umbrella\"); } public MushroomFactory factory() throws SlickXMLException { return new MushroomFactory(root.getIntAttribute(\"mushrooms\")); } public int par() throws SlickException { return root.getIntAttribute(\"par\"); } public LuminousEntity[] entities() throws SlickException { XMLElementList children = root.getChildren(); ArrayList<LuminousEntity> entities = new ArrayList<LuminousEntity>(); for (int i = 0; i < children.size(); i++) { entities.add(getEntityFrom(children.get(i))); } return entities.toArray(new LuminousEntity[0]); } private LuminousEntity getEntityFrom(XMLElement element) throws SlickException { String c = mappings.get(element.getName()); ArrayList<Object> args = new ArrayList<Object>(); args.add(element.getIntAttribute(\"x\")); args.add(element.getIntAttribute(\"y\")); if (!element.getAttribute(\"z\", \"NULL\").equals(\"NULL\")) { args.add(element.getIntAttribute(\"z\")); } if (!element.getAttribute(\"d\", \"NULL\").equals(\"NULL\")) { args.add(element.getIntAttribute(\"d\")); } if (!element.getAttribute(\"type\", \"NULL\").equals(\"NULL\")) { args.add(element.getIntAttribute(\"type\")); } if (!element.getAttribute(\"facing\", \"NULL\").equals(\"NULL\")) { args.add(element.getIntAttribute(\"facing\")); } if (!element.getAttribute(\"range\", \"NULL\").equals(\"NULL\")) { args.add(element.getIntAttribute(\"range\")); } if (!element.getAttribute(\"speed\", \"NULL\").equals(\"NULL\")) { args.add((float) element.getDoubleAttribute(\"speed\")); } return (LuminousEntity) Reflection.getInstance(c, args.toArray()); } }"}
{"name": "aschearer/shade", "content": "package com.shade.levels; import com.shade.controls.DayPhaseTimer; import com.shade.crash.CrashLevel; import com.shade.entities.mushroom.MushroomFactory; public abstract class Model extends CrashLevel { private DayPhaseTimer daytimer; public Model(int w, int h, int c) { super(w, h, c); } public abstract MushroomFactory getMushroomFactory(); public abstract int getPar(); public void setTimer(DayPhaseTimer t){ daytimer = t; } public DayPhaseTimer getTimer(){ return daytimer; } }"}
{"name": "aschearer/shade", "content": "package com.shade.levels; import org.newdawn.slick.SlickException; import com.shade.entities.mushroom.MushroomFactory; import com.shade.lighting.LuminousEntity;  public class Shell extends Model { private static final int WIDTH = 8; private static final int HEIGHT = 6; private static final int CELL = 100; private MushroomFactory factory; private int par; public Shell(String path) throws SlickException { super(WIDTH, HEIGHT, CELL); LevelSerial l = new LevelSerial(path); for (LuminousEntity e : l.entities()) { add(e); } factory = l.factory(); par = l.par(); } @Override public MushroomFactory getMushroomFactory() { return factory; } @Override public int getPar() { return par; } }"}
{"name": "aschearer/shade", "content": "package com.shade.lighting; import org.newdawn.slick.Color; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.geom.Shape; import org.newdawn.slick.state.StateBasedGame; import com.shade.controls.DayPhaseTimer; public class GlobalLight implements LightSource { private final float transitionAngle; private final int secondsPerDay; private int timeOfDay; private float angle, depth; private DayPhaseTimer timer; public GlobalLight(float depth, float angle, int duration, DayPhaseTimer t) { this.depth = depth; this.angle = angle; secondsPerDay = duration; transitionAngle = (float) (2 * Math.PI / secondsPerDay); timer = t; } public void render(StateBasedGame game, Graphics g, LuminousEntity... entities) { LightMask.resetStencil(); g.setColor(Color.black); for (LuminousEntity entity : entities) { Shape s = entity.castShadow(angle, depth); if (s != null) { g.fill(s); } } LightMask.keepStencil(); GameContainer c = game.getContainer(); if(timer.getDaylightStatus()==DayPhaseTimer.DayLightStatus.DAY) { g.setColor(new Color(0,0,0,1f)); } else { float factor = (1-timer.timeLeft())*0.4f; if(timer.getDaylightStatus()==DayPhaseTimer.DayLightStatus.NIGHT) factor = 0; if(timer.getDaylightStatus()==DayPhaseTimer.DayLightStatus.DAWN) factor = timer.timeLeft()*0.4f; g.setColor(new Color(0,0,0,0.6f+factor)); } g.fillRect(0, 0, c.getWidth(), c.getHeight()); g.setColor(Color.white); "}
{"name": "aschearer/shade", "content": "package com.shade.lighting; import java.util.Arrays; import java.util.LinkedList; import org.lwjgl.opengl.GL11; import org.newdawn.slick.Color; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.state.StateBasedGame; import com.shade.controls.DayPhaseTimer; import com.shade.entities.Roles;  public class LightMask {  private static final float MAGIC_ALPHA_VALUE = .65f; private static final float MAGIC_ARROW_VALUE = .1f; protected final static Color SHADE = new Color(0, 0, 0, .3f); public static final float MAX_DARKNESS = 0.4f; private DayPhaseTimer timer;  private int threshold; private LinkedList<LightSource> lights; public LightMask(int threshold, DayPhaseTimer time) { this.threshold = threshold; lights = new LinkedList<LightSource>(); timer = time; } public void add(LightSource light) { lights.add(light); } public void render(StateBasedGame game, Graphics g, LuminousEntity[] entities, Image... backgrounds) { renderLights(game, g, entities); renderBackgrounds(game, g, backgrounds); renderEntities(game, g, entities); "}
{"name": "aschearer/shade", "content": "package com.shade.lighting; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame;  public interface LightSource {  public void render(StateBasedGame game, Graphics g, LuminousEntity... entities);  public void update(StateBasedGame game, int delta); }"}
{"name": "aschearer/shade", "content": "package com.shade.lighting; import java.util.LinkedList; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame;  public class LightSourceProxy implements LightSource { private LinkedList<LightSource> lights; public LightSourceProxy() { lights = new LinkedList<LightSource>(); } public void add(LightSource l) { lights.add(l); } public void render(StateBasedGame game, Graphics g, LuminousEntity... entities) { for (LightSource light : lights) { light.render(game, g, entities); } } public void update(StateBasedGame game, int delta) { for (LightSource light : lights) { light.update(game, delta); } } }"}
{"name": "aschearer/shade", "content": "package com.shade.lighting; import org.newdawn.slick.geom.Shape; import com.shade.base.Entity;  public interface LuminousEntity extends Entity, Comparable<LuminousEntity> {  public int getZIndex();  public float getLuminosity();  public void setLuminosity(float l);  public Shape castShadow(float direction, float depth); }"}
{"name": "aschearer/shade", "content": "package com.shade.score; import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; import java.util.prefs.Preferences; import com.shade.levels.LevelManager;  public class BatchWriter { private static final String EMPTY_STRING = \"\"; private static final String SCORE_KEY = \"scores\"; private static final String SERVER = \"http:"}
{"name": "aschearer/shade", "content": "package com.shade.score;  public class FailSafeHighScoreReader implements HighScoreReader { private static final String SERVER = \"http:"}
{"name": "aschearer/shade", "content": "package com.shade.score; import java.util.prefs.Preferences; import com.shade.levels.LevelManager;  public class FailSafeHighScoreWriter implements HighScoreWriter { private static final String EMPTY_STRING = \"\"; private static final String SCORE_KEY = \"scores\"; private static final String SERVER = \"http:"}
{"name": "aschearer/shade", "content": "package com.shade.score; public interface HighScoreReader {  public String[][] getScores(int level, int limit); }"}
{"name": "aschearer/shade", "content": "package com.shade.score; public interface HighScoreWriter { public boolean write(String name, int score, int level, boolean special); }"}
{"name": "aschearer/shade", "content": "package com.shade.score; import java.io.IOException; import java.io.StringReader; import java.util.Collections; import java.util.Comparator; import java.util.LinkedList; import java.util.prefs.Preferences; import com.shade.util.CsvReader;  public class LocalHighScoreReader implements HighScoreReader { private static final String EMPTY_STRING = \"\"; private static final String SCORE_KEY = \"scores\"; private static final int NAME = 0; private static final int SCORE = 1; private static final int CLEAR = 2;  public String[][] getScores(int level, int limit) { Preferences prefs = Preferences.userNodeForPackage(this.getClass()); StringReader s = new StringReader(prefs.get(SCORE_KEY + level, EMPTY_STRING)); CsvReader reader = new CsvReader(s); LinkedList<String[]> rows = new LinkedList<String[]>(); try { while (reader.readRecord()) { String[] row = new String[3]; row[NAME] = reader.get(NAME); row[SCORE] = reader.get(SCORE); row[CLEAR] = reader.get(CLEAR); rows.add(row); } } catch (IOException e) { e.printStackTrace(); } Collections.sort(rows, new Comparator<String[]>() { public int compare(String[] s1, String[] s2) { return s1[SCORE].compareTo(s2[SCORE]); } }); return firstN(rows, limit); } private String[][] firstN(LinkedList<String[]> rows, int limit) { limit = (limit == 0) ? rows.size() : limit; int size = (rows.size() > limit) ? limit : rows.size(); String[][] n = new String[size][3]; for (int i = 0; i < size; i++) { n[i][NAME] = rows.get(i)[NAME]; n[i][SCORE] = rows.get(i)[SCORE]; n[i][CLEAR] = rows.get(i)[CLEAR]; } return n; } }"}
{"name": "aschearer/shade", "content": "package com.shade.score; import java.io.IOException; import java.io.StringWriter; import java.util.prefs.Preferences; import com.shade.util.CsvWriter; public class LocalHighScoreWriter implements HighScoreWriter { private static final String EMPTY_STRING = \"\"; private static final String SCORE_KEY = \"scores\"; private static final int NAME = 0; private static final int SCORE = 1; private static final int LEVEL = 2; private static final int SPECIAL = 3; private static final char COMMA = ','; public boolean write(String name, int score, int level, boolean special) { String[] row = new String[4]; row[NAME] = name; row[SCORE] = score + EMPTY_STRING; row[LEVEL] = level + EMPTY_STRING; row[SPECIAL] = (special) ? \"1\" : \"0\"; return write(row[NAME], row[SCORE], row[LEVEL], row[SPECIAL]); } protected boolean write(String name, String score, String level, String special) { Preferences prefs = Preferences.userNodeForPackage(this.getClass()); StringWriter stream = new StringWriter(); CsvWriter writer = new CsvWriter(stream, COMMA); String[] row = new String[] { name, score, level, special }; try { writer.writeRecord(row); "}
{"name": "aschearer/shade", "content": "package com.shade.score; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; import java.util.LinkedList; import com.shade.util.CsvReader;  public class RemoteHighScoreReader implements HighScoreReader { private String base; public RemoteHighScoreReader(String path) { base = path; } public String[][] getScores(int level, int limit) { try { String target = base + \"?num_scores=\" + URLEncoder.encode(\"\" + limit, \"US-ASCII\"); target += \"&level=\" + URLEncoder.encode(\"\" + level, \"US-ASCII\"); "}
{"name": "aschearer/shade", "content": "package com.shade.score; import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; public class RemoteHighScoreWriter implements HighScoreWriter { private String base; public RemoteHighScoreWriter(String path) { base = path; } public boolean write(String name, int score, int level, boolean special) { String s = (special) ? \"1\" : \"0\"; return write(name, score + \"\", level + \"\", s); } protected boolean write(String name, String score, String level, String special) { try { String content = \"name=\" + URLEncoder.encode(name, \"US-ASCII\"); content += \"&score=\" + score; content += \"&level=\" + level; content += \"&special=\" + special; URL url = new URL(base); URLConnection c = url.openConnection(); c.setConnectTimeout(2000); c.setDoOutput(true); OutputStreamWriter o = new OutputStreamWriter(c.getOutputStream()); "}
{"name": "aschearer/shade", "content": "package com.shade.states; import java.util.LinkedList; import java.util.Scanner; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import org.newdawn.slick.util.ResourceLoader; import com.centerkey.utils.BareBonesBrowserLaunch; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.ScrollingText; import com.shade.controls.SlickButton; import com.shade.util.ResourceManager; public class CreditState extends BasicGameState { private static final int CREDIT_DELAY = 1000; public static final int ID = 5; private static final String FEEDBACK_URL = \"http:"}
{"name": "aschearer/shade", "content": "package com.shade.states; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.gui.AbstractComponent; import org.newdawn.slick.gui.ComponentListener; import org.newdawn.slick.gui.TextField; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.SerialStats; import com.shade.controls.SlickButton; import com.shade.util.ResourceManager; import com.shade.score.FailSafeHighScoreWriter; import com.shade.score.HighScoreWriter; public class EnterScoreState extends BasicGameState { private static final String PROMPT_WINNER = \"Way to go! Er... what's your name?\"; private static final String PROMPT_LOSER = \"Nice try! Er... what's your name?\"; private static final String[] RESPONSES = { \"(Is that really a name?)\", \"Never heard of ya.\", \"Bet you can't beat me!\", \"Buffer Overflow at line 6.\", \"Cool guy, huh?\", \"You beat little Johnny!\", \"Go tell your friends!\" }; public static final int ID = 6; private MasterState master; private ResourceManager resource; private SlickButton play, highscores, back; private int timer; private TextField input; private String message; private HighScoreWriter writer; private boolean completed; "}
{"name": "aschearer/shade", "content": "package com.shade.states; import java.util.ArrayList; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import com.centerkey.utils.BareBonesBrowserLaunch; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.FadeInImage; import com.shade.controls.FadeInText; import com.shade.controls.SlickButton; import com.shade.util.ResourceManager; import com.shade.score.FailSafeHighScoreReader; public class HighscoreState extends BasicGameState { public static final int ID = 4; private static final String FEEDBACK_URL = \"http:"}
{"name": "aschearer/shade", "content": "package com.shade.states; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.ControlListener; import com.shade.controls.ControlSlice; import com.shade.controls.ScoreControl; import com.shade.controls.CounterControl; import com.shade.controls.MeterControl; import com.shade.controls.SerialStats; import com.shade.controls.SlickButton; import com.shade.controls.StatsControl; import com.shade.controls.DayPhaseTimer.DayLightStatus; import com.shade.levels.LevelManager; import com.shade.levels.Model; import com.shade.util.ResourceManager; public class InGameState extends BasicGameState { public static final int ID = 3; private StateBasedGame game; private MasterState master; private ResourceManager resource; private int currentLevel, totalLevelsPlayed; private Model level; private LevelManager levels; private MeterControl meter; private CounterControl counter; private SlickButton play, back; public StatsControl stats; public InGameState(MasterState m) throws SlickException { levels = new LevelManager(); master = m; resource = m.resource; resource.register(\"counter\", \"states/ingame/counter.png\"); resource.register(\"resume-up\", \"states/ingame/resume-up.png\"); resource.register(\"resume-down\", \"states/ingame/resume-down.png\"); resource.register(\"back-up\", \"states/common/back-up.png\"); resource.register(\"back-down\", \"states/common/back-down.png\"); initControls(); initButtons(); } @Override public int getID() { return ID; }  public void newGame() { currentLevel = 1; totalLevelsPlayed = 1; initLevel(); resetControls(); master.scorecard.reset(); stats.reset(); } public void newGame(int level) { currentLevel = level; totalLevelsPlayed = 1; initLevel(); resetControls(); master.scorecard.reset(); stats.reset(); }  public void nextLevel() { currentLevel++; totalLevelsPlayed++; initLevel(); resetControls(); master.scorecard.reset(); }  public void currentLevel() { initLevel(); master.scorecard.rollbackLevel(); resetControls(); } private void initLevel() { if (currentLevel < levels.size()) { level = levels.get(currentLevel); } }  private void resetControls() { meter.reset(); counter.reset(level.getPar()); } private void addBackControls() { master.control.add(counter); master.control.add(meter); } public void init(GameContainer container, StateBasedGame game) throws SlickException { throw new RuntimeException(\"InGameState was init'd!\"); } @Override public void enter(GameContainer container, StateBasedGame game) { this.game = game; master.timer.reset(); if (!master.dimmer.reversed()) { master.dimmer.rewind(); } master.control.load(level); master.music.fade(MasterState.SECONDS_OF_DAYLIGHT, .1f, false); addBackControls(); } private void safeExit(StateBasedGame game, int id) { master.control.flushControls(); master.control.killPlayer(); master.music.fade(2000, 1f, false); game.enterState(id); } public void exit(StateBasedGame game, int id) { "}
{"name": "aschearer/shade", "content": "package com.shade.states; import java.util.ArrayList; import java.util.Scanner; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import org.newdawn.slick.state.transition.FadeOutTransition; import org.newdawn.slick.util.ResourceLoader; import com.shade.base.Animatable; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.InstructionImage; import com.shade.controls.InstructionText; import com.shade.controls.KeyListener; import com.shade.controls.SlickButton; import com.shade.controls.TwoToneButton; import com.shade.util.ResourceManager; public class InstructionState extends BasicGameState { private static final int INSTRUCTION_STATE_DELAY = 1000; private static final int INSTRUCTION_BUFFER = 5000; public static final int ID = 7; private MasterState master; private ResourceManager resource; private SlickButton play, back; private TwoToneButton next, prev; private int timer; private InstructionSet instructions; private SpriteSheet instructionSheet; public InstructionState(MasterState m) throws SlickException { master = m; resource = m.resource; resource.register(\"backdrop\", \"states/instruction/backdrop.png\"); resource .register(\"instructions\", \"states/instruction/instructions.png\"); resource.register(\"skip-up\", \"states/instruction/skip-up.png\"); resource.register(\"skip-down\", \"states/instruction/skip-down.png\"); resource.register(\"next-up\", \"states/instruction/next-up.png\"); resource.register(\"next-down\", \"states/instruction/next-down.png\"); instructionSheet = new SpriteSheet(resource.get(\"instructions\"), 90, 90); initInstructions(master.jekyllSmall); } @Override public int getID() { return ID; } public void init(GameContainer container, StateBasedGame game) throws SlickException { throw new RuntimeException(\"CreditState was init'd!\"); } @Override public void enter(GameContainer container, StateBasedGame game) throws SlickException { initButtons(); timer = 0; instructions.reset(); "}
{"name": "aschearer/shade", "content": "package com.shade.states; import java.awt.Font; import java.io.InputStream; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.Music; import org.newdawn.slick.SlickException; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import org.newdawn.slick.state.transition.FadeInTransition; import org.newdawn.slick.util.ResourceLoader; import com.shade.controls.LevelLock; import com.shade.controls.ScoreControl; import com.shade.controls.DayPhaseTimer; import com.shade.controls.GameSlice; import com.shade.controls.SerialStats; import com.shade.lighting.GlobalLight; import com.shade.lighting.LightMask; import com.shade.util.ResourceManager; import com.shade.states.util.Dimmer; public class MasterState extends BasicGameState { public static final int ID = 1; public static final int STATE_TRANSITION_DELAY = 400; public static final int SECONDS_PER_DAY = 120000; public static final int SECONDS_OF_DAYLIGHT = SECONDS_PER_DAY / 2; public static final float SHADOW_THRESHOLD = .7f; public ResourceManager resource; public GameSlice control; public LevelLock levelsLock; public ScoreControl scorecard; public Dimmer dimmer; public DayPhaseTimer timer; public TrueTypeFont jekyllXSmall, jekyllSmall, jekyllMedium, jekyllLarge; public TrueTypeFont daisySmall, daisyMedium, daisyLarge, daisyXLarge; public Music music; @Override public int getID() { return ID; } public void init(GameContainer container, StateBasedGame game) throws SlickException { resource = new ResourceManager(); "}
{"name": "aschearer/shade", "content": "package com.shade.states; import java.util.ArrayList; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.SpriteSheet; import org.newdawn.slick.gui.AbstractComponent; import org.newdawn.slick.gui.ComponentListener; import org.newdawn.slick.gui.TextField; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import org.newdawn.slick.state.transition.FadeOutTransition; import com.shade.base.Animatable; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.FadeInImage; import com.shade.controls.FadeInText; import com.shade.controls.KeyListener; import com.shade.controls.SerialStats; import com.shade.controls.SlickButton; import com.shade.controls.StatMeter; import com.shade.controls.TwoToneButton; import com.shade.levels.LevelManager; import com.shade.score.FailSafeHighScoreReader; import com.shade.score.FailSafeHighScoreWriter; import com.shade.score.HighScoreWriter; import com.shade.util.ResourceManager; public class RecapState extends BasicGameState {  private static final int MAX_LEVEL_SCORE = 16000; private static final int MAX_LEVEL_COUNT = 80; private static final int MAX_GOLDEN_COUNT = 10; private static final String PASS_TEXT = \"Level Clear\"; private static final String FAIL_TEXT = \"Level Failed\"; public static final int ID = 9; private MasterState master; private InGameState level; private ResourceManager resource; private SlickButton nextLevel, replay, back; private TwoToneButton next, prev; private boolean completed; private String name; private FailSafeHighScoreReader reader; private HighScoreWriter writer; private boolean par; private StateBasedGame game; private int index; private int timer, lockFlipper; private String message; private StatGizmo stats; private ScoreGizmo scores; private InputGizmo input; private SpriteSheet statsIcons; private boolean unlocked; public RecapState(MasterState m) throws SlickException { master = m; resource = m.resource; resource.register(\"gameover-up\", \"states/recap/gameover-up.png\"); resource.register(\"gameover-down\", \"states/recap/gameover-down.png\"); resource.register(\"nextlevel-up\", \"states/recap/nextlevel-up.png\"); resource.register(\"nextlevel-down\", \"states/recap/nextlevel-down.png\"); resource.register(\"replay-up\", \"states/recap/replay-up.png\"); resource.register(\"replay-down\", \"states/recap/replay-down.png\"); resource.register(\"levels-up\", \"states/recap/levels-up.png\"); resource.register(\"levels-down\", \"states/recap/levels-down.png\"); resource.register(\"wreath\", \"states/recap/wreath.png\"); resource.register(\"unlocked\", \"states/recap/unlocked.png\"); statsIcons = new SpriteSheet(\"states/recap/icons.png\", 40, 40); reader = new FailSafeHighScoreReader(); writer = new FailSafeHighScoreWriter(); } @Override public int getID() { return ID; } public void init(GameContainer container, StateBasedGame game) throws SlickException { throw new RuntimeException(\"RecapState was init'd!\"); } public void enter(GameContainer container, StateBasedGame game) throws SlickException { this.game = game; timer = 0; lockFlipper = 0; index = 0; level = (InGameState) game.getState(InGameState.ID); par = level.parWasMet(); unlocked = master.levelsLock.newLevelUnlocked(); master.levelsLock.testAndUnlockLevels(); if (master.dimmer.reversed()) { master.dimmer.rewind(); } message = (par) ? PASS_TEXT : FAIL_TEXT; initButtons(); initFlowButtons(); initStats(); initScores(); initInput(container); "}
{"name": "aschearer/shade", "content": "package com.shade.states; import java.util.ArrayList; import java.util.Scanner; import org.newdawn.slick.Color; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.Image; import org.newdawn.slick.Input; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; import org.newdawn.slick.TrueTypeFont; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import org.newdawn.slick.util.ResourceLoader; import com.shade.base.Animatable; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.InstructionImage; import com.shade.controls.InstructionText; import com.shade.controls.KeyListener; import com.shade.controls.SerialStats; import com.shade.controls.SlickButton; import com.shade.controls.TwoToneButton; import com.shade.levels.LevelManager; import com.shade.util.ResourceManager; public class SelectState extends BasicGameState { public static final int ID = 10; private static final int LEVEL_STATE_DELAY = 600; private static final int LEVEL_BUFFER = 5000; private MasterState master; private InGameState level; private LevelManager manager; private ResourceManager resource; private SlickButton play, back; private TwoToneButton next, prev; private LevelSet levels; int currentLevel; private int timer; private Sound click; private StateBasedGame game; @Override public int getID() { return ID; } public SelectState(MasterState m) throws SlickException { master = m; resource = m.resource; resource.register(\"newgame-up\", \"states/select/newgame-up.png\"); resource.register(\"newgame-down\", \"states/select/newgame-down.png\"); resource.register(\"question-mark\", \"states/select/question-mark.png\"); resource.register(\"crown\", \"states/highscore/crown.png\"); click = new Sound(\"states/common/click.ogg\"); manager = new LevelManager(); } public void init(GameContainer container, StateBasedGame game) throws SlickException { throw new RuntimeException(\"SelectState was init'd!\"); } public void enter(GameContainer container, final StateBasedGame game) throws SlickException { this.game = game; level = (InGameState) game.getState(InGameState.ID); currentLevel = level.getCurrentLevel(); initLevels(master.jekyllMedium); if (master.dimmer.reversed()) { master.dimmer.rewind(); } initFlowButtons(); initButtons(); timer = 0; } public void render(GameContainer container, StateBasedGame game, Graphics g) throws SlickException { master.control.render(game, g, resource.get(\"background\")); g.setColor(Color.black); if (!master.levelsLock.isUnlocked(currentLevel)) { g.fillRect(0, 0, 800, 600); } g.setColor(Color.white); master.dimmer.render(game, g); resource.get(\"header\").draw(400, 0); resource.get(\"backdrop\").draw(0, 400); play.render(game, g); back.render(game, g); prev.render(game, g); next.render(game, g); renderInstructionStep(); if (!master.levelsLock.isUnlocked(currentLevel)) { resource.get(\"question-mark\").draw(310, 160); } if (currentLevel > 0 && SerialStats.read(\"level-\" + currentLevel + \"-clear\") == 1) { resource.get(\"crown\").draw(15, 412); } levels.render(game, g); resource.get(\"trim\").draw(); } private void renderInstructionStep() { master.jekyllXSmall.drawString(18, 495, (1 + currentLevel) + \" of \" + levels.size()); } public void update(GameContainer container, StateBasedGame game, int delta) throws SlickException { master.control.update(game, delta); master.dimmer.update(game, delta); resource.get(\"backdrop\").draw(0, 400); timer += delta; if (timer > MasterState.STATE_TRANSITION_DELAY) { play.update(game, delta); back.update(game, delta); prev.update(game, delta); next.update(game, delta); } prev.active(levels.started()); next.active(levels.finished()); levels.update(game, delta); } @Override public void keyPressed(int key, char c) { if (key == Input.KEY_ENTER) { click.play(); if (!master.levelsLock.isUnlocked(currentLevel)) { return; } level.newGame(currentLevel); if (currentLevel == 0) { game.enterState(InstructionState.ID); } else { game.enterState(InGameState.ID); } } } private void initButtons() throws SlickException { initPlayButton(); initBackButton(); } private void initPlayButton() throws SlickException { play = new SlickButton(620, 110, resource.get(\"play-up\"), resource .get(\"play-down\")); play.addListener(new ClickListener() { public void onClick(StateBasedGame game, Button clicked) { if (!master.levelsLock.isUnlocked(currentLevel)) { return; } level.newGame(currentLevel); if (currentLevel == 0) { game.enterState(InstructionState.ID); } else { game.enterState(InGameState.ID); } } }); } private void initBackButton() throws SlickException { back = new SlickButton(620, 130, resource.get(\"back-up\"), resource .get(\"back-down\")); back.addListener(new ClickListener() { public void onClick(StateBasedGame game, Button clicked) { game.enterState(TitleState.ID); master.dimmer.reverse(); } }); } private void initFlowButtons() throws SlickException { Image up = resource.get(\"next-up\"); Image down = resource.get(\"next-down\"); next = new TwoToneButton(760, 490, up, down); prev = new TwoToneButton(740, 490, up.getFlippedCopy(true, false), down .getFlippedCopy(true, false)); next.addListener(new ClickListener() { public void onClick(StateBasedGame game, Button clicked) { currentLevel++; levels.next(); master.control.load(manager.get(currentLevel)); master.control.killPlayer(); } }); next.register(Input.KEY_RIGHT, new KeyListener() { public void onPress(StateBasedGame game, int key) { currentLevel++; levels.next(); master.control.load(manager.get(currentLevel)); master.control.killPlayer(); } }); prev.addListener(new ClickListener() { public void onClick(StateBasedGame game, Button clicked) { currentLevel--; levels.prev(); master.control.load(manager.get(currentLevel)); master.control.killPlayer(); } }); prev.register(Input.KEY_LEFT, new KeyListener() { public void onPress(StateBasedGame game, int key) { currentLevel--; levels.prev(); master.control.load(manager.get(currentLevel)); master.control.killPlayer(); } }); } private void initLevels(TrueTypeFont f) throws SlickException { Scanner hints = new Scanner(ResourceLoader .getResourceAsStream(\"states/select/hints.txt\")); Image locked = new Image(\"states/select/locked.png\"); Scanner names = new Scanner(ResourceLoader .getResourceAsStream(\"states/select/levels.txt\")); Image unlocked = new Image(\"states/select/unlocked.png\"); levels = new LevelSet(); float x = 90; int n = 0; while (hints.hasNextLine()) { InstructionImage i = null; InstructionText t = null; if (master.levelsLock.isUnlocked(n)) { i = new InstructionImage(x, 425, unlocked); i.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER); t = new InstructionText(x + 100, 445, names.nextLine(), f); t.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER); hints.nextLine(); } else { i = new InstructionImage(x - 6, 425 + 11, locked); i.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER); t = new InstructionText(x + 100, 445, hints.nextLine(), f); t.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER); names.nextLine(); } levels.add(i, t); n++; } } private class LevelSet implements Animatable { private boolean finished; private ArrayList<InstructionImage> images; private ArrayList<InstructionText> text; public LevelSet() { images = new ArrayList<InstructionImage>(); text = new ArrayList<InstructionText>(); finished = (currentLevel == LevelManager.NUM_LEVELS - 1); } public void moveTo(int level) { currentLevel = level; for (int i = 0; i < text.size(); i++) { if (i == level) { images.get(i).activate(); text.get(i).activate(); } else { images.get(i).deactivate(); text.get(i).deactivate(); } } } public int current() { return currentLevel + 1; } public int size() { return text.size(); } public void add(InstructionImage i, InstructionText t) { if (text.size() == currentLevel) { t.activate(); i.activate(); } images.add(i); text.add(t); } public void next() { int last = currentLevel - 1; text.get(last).deactivate(); images.get(last).deactivate(); if (currentLevel < text.size()) { text.get(currentLevel).activate(); images.get(currentLevel).activate(); if (currentLevel == text.size() - 1) { finished = true; } } } public void prev() { int last = currentLevel + 1; text.get(last).deactivate(); images.get(last).deactivate(); text.get(currentLevel).activate(); images.get(currentLevel).activate(); if (finished) { finished = false; } } public void reset(int last) { images.get(last).reset(); text.get(last).reset(); images.get(currentLevel).activate(); text.get(currentLevel).activate(); } public void render(StateBasedGame game, Graphics g) { for (InstructionText s : text) { s.render(game, g); } for (InstructionImage i : images) { i.render(game, g); } } public void update(StateBasedGame game, int delta) { for (InstructionText s : text) { s.update(game, delta); } for (InstructionImage i : images) { i.update(game, delta); } } public boolean started() { return currentLevel == 0; } public boolean finished() { return finished; } } }"}
{"name": "aschearer/shade", "content": "package com.shade.states; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.SlickException; import org.newdawn.slick.state.BasicGameState; import org.newdawn.slick.state.StateBasedGame; import com.shade.controls.Button; import com.shade.controls.ClickListener; import com.shade.controls.SlickButton; import com.shade.levels.Shell; import com.shade.util.ResourceManager; import com.shade.states.CreditState; public class TitleState extends BasicGameState { public static final int ID = 2; private static final String LEVEL_ZERO = \"levels/level-0.xml\"; private MasterState master; private ResourceManager resource; private SlickButton play, highscores, credits; private int timer; public TitleState(MasterState m) throws SlickException { master = m; resource = m.resource; initButtons(); reset(); } @Override public int getID() { return ID; } public void init(GameContainer container, StateBasedGame game) throws SlickException { throw new RuntimeException(\"TitleState was init'd!\"); } private void reset() throws SlickException { master.control.load(new Shell(LEVEL_ZERO)); } @Override public void enter(GameContainer container, StateBasedGame game) throws SlickException { timer = 0; initButtons(); } "}
{"name": "aschearer/shade", "content": "package com.shade.states.util; import org.newdawn.slick.SlickException; import org.newdawn.slick.Sound; public class BirdCalls { private int lastPlayed; private Sound[] birds; public BirdCalls() throws SlickException { birds = new Sound[4]; birds[0] = new Sound(\"states/common/birds/bird1.ogg\"); birds[1] = new Sound(\"states/common/birds/bird2.ogg\"); birds[2] = new Sound(\"states/common/birds/bird3.ogg\"); birds[3] = new Sound(\"states/common/birds/bird4.ogg\"); } public void play() { int i = (int) Math.floor(Math.random() * birds.length); birds[i].play(); lastPlayed = i; } public boolean playing() { return birds[lastPlayed].playing(); } }"}
{"name": "aschearer/shade", "content": "package com.shade.states.util; import org.newdawn.slick.Color; import org.newdawn.slick.GameContainer; import org.newdawn.slick.Graphics; import org.newdawn.slick.state.StateBasedGame; import com.shade.base.Animatable; public class Dimmer implements Animatable { private static final float ALPHA_INC = .05f; private Color color; private float targetAlpha; private int timer; private boolean reversed; private boolean running; public Dimmer(float target) { color = new Color(Color.black); color.a = 0; targetAlpha = target; } public void render(StateBasedGame game, Graphics g) { g.setColor(color); GameContainer c = game.getContainer(); g.fillRect(0, 0, c.getWidth(), c.getHeight()); g.setColor(Color.white); } public void update(StateBasedGame game, int delta) { if (!running) { return; } timer += delta; if (!reversed && color.a < targetAlpha && timer > 100) { color.a += ALPHA_INC; timer = 0; } if (reversed && color.a >= 0 && timer > 100) { color.a -= ALPHA_INC; timer = 0; } clamp(); } private void clamp() { if (!reversed && color.a > targetAlpha) { color.a = targetAlpha; } if (reversed && color.a < 0) { color. a = 0; } } public boolean finished() { return color.a == targetAlpha; } public void reverse() { reversed = true; } public void reset() { timer = 0; color.a = 0; reversed = false; } public void rewind() { reversed = !reversed; } public boolean reversed() { return reversed; } public void fastforward() { timer = 0; color.a = targetAlpha; reversed = true; } public void run() { running = true; } public void stop() { running = false; } public boolean isRunning() { return running; } }"}
{"name": "aschearer/shade", "content": " package com.shade.util; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.nio.charset.Charset; import java.text.NumberFormat; import java.util.HashMap;  public class CsvReader { private Reader inputStream = null; private String fileName = null; "}
{"name": "aschearer/shade", "content": " package com.shade.util; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.io.Writer; import java.nio.charset.Charset;  public class CsvWriter { private PrintWriter outputStream = null; private String fileName = null; private boolean firstColumn = true; private boolean useCustomRecordDelimiter = false; private Charset charset = null; "}
{"name": "aschearer/shade", "content": "package com.shade.util; import org.newdawn.slick.geom.Vector2f;  public class Geom {  public static Vector2f calculateVector(float magnitude, float angle) { Vector2f v = new Vector2f(); v.x = (float) Math.sin(angle); v.x *= magnitude; v.y = (float) - Math.cos(angle); v.y *= magnitude; return v; }  public static float calculateAngle(float x, float y, float x1, float y1) { double angle = Math.atan2(y - y1, x - x1); return (float) angle + 1.5f; }  public static float distance2(float x, float y, float x1, float y1) { x = (float) Math.pow(x - x1, 2); y = (float) Math.pow(y - y1, 2); return (x + y); } public static float distance2(float[] p1, float x, float y) { return distance2(p1[0], p1[1], x, y); } }"}
{"name": "aschearer/shade", "content": "package com.shade.util; import org.newdawn.slick.GameContainer; import org.newdawn.slick.geom.Vector2f; public class LevelUtil { public static Vector2f randomPoint(GameContainer c) { Vector2f p = new Vector2f(); p.x = (float) Math.random() * (c.getWidth() - 20) + 10; p.y = (float) Math.random() * (c.getHeight() - 20) + 10; return p; } }"}
{"name": "aschearer/shade", "content": "package com.shade.util; import java.lang.reflect.Constructor; import org.newdawn.slick.SlickException; @SuppressWarnings(\"unchecked\") public class Reflection { public static Object getInstance(String name, Object... args) throws SlickException { try { Class c = Class.forName(name); Class[] params = extractTypes(args); Constructor constructor = c.getConstructor(params); return constructor.newInstance(args); } catch (Exception e) { throw new SlickException(\"Couldn't create new object.\", e); } } private static Class[] extractTypes(Object[] args) { Class[] types = new Class[args.length]; for (int i = 0; i < args.length; i++) { types[i] = getType(args[i].getClass()); } return types; } private static Class getType(Class c) { if (c.equals(Integer.class)) { return int.class; } if (c.equals(Float.class)) { return float.class; } return c; } }"}
{"name": "aschearer/shade", "content": "package com.shade.util; import java.util.HashMap; import org.newdawn.slick.Image; import org.newdawn.slick.SlickException;  public class ResourceManager { private HashMap<String, Image> resources; public ResourceManager() { resources = new HashMap<String, Image>(); } public boolean register(String name, String resource) throws SlickException { if (resources.containsKey(name)) { return false; } resources.put(name, new Image(resource)); return true; } public Image get(String resource) { return resources.get(resource); } }"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation; import java.util.LinkedHashMap; import java.util.Map; public class Chunk { private byte[] _bytes; private Map<String, String> _parameters; public Chunk(byte[] bytes) { this(bytes, new LinkedHashMap<String, String>()); } public Chunk(byte[] bytes, Map<String, String> parameters) { _bytes = bytes; _parameters = parameters; } public byte[] getBytes() { return _bytes; } public void setParameter(String name, String value) { _parameters.put(name, value); } public String getParameter(String name) { return _parameters.get(name); } public Map<String, String> getParameters() { return _parameters; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation; import java.io.*; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; import java.util.StringTokenizer; import java.util.regex.Pattern; public class Chunking { private static final String ASCII = \"US-ASCII\"; private static final byte[] CRLF = new byte[]{'\\r', '\\n'}; private static final String SIZE = \"0|[1-9A-F][0-9A-F]{0,6}|[1-7][0-9A-F]{7}\"; private static final String TOKEN = \"[^\\u0000-\\u0020()<>@,;:\\\\\\\\\\\"/\\\\[\\\\]?={}\\u007F-\\uFFFF]+\"; private static final String HEADER = \"(\" + SIZE + \")(;\" + TOKEN + \"=\" + TOKEN + \")*\\r\\n\"; private static final Pattern TOKEN_PATTERN = Pattern.compile(TOKEN); private static final Pattern HEADER_PATTERN = Pattern.compile(HEADER); private static boolean validToken(String token) { return TOKEN_PATTERN.matcher(token).matches(); } public static void writeChunk(OutputStream stream, Chunk chunk) throws IOException { stream.write(Integer.toHexString(chunk.getBytes().length).toUpperCase().getBytes(ASCII)); Iterator<Map.Entry<String, String>> iterator = chunk.getParameters().entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, String> entry = iterator.next(); String name = entry.getKey(); String value = entry.getValue(); if (!validToken(name)) { throw new IOException(\"Invalid parameter name '\" + name + \"'\"); } if (!validToken(value)) { throw new IOException(\"Invalid parameter value '\" + value + \"'\"); } stream.write(';'); stream.write(name.getBytes(ASCII)); stream.write('='); stream.write(value.getBytes(ASCII)); } stream.write(CRLF); stream.write(chunk.getBytes()); stream.write(CRLF); } public static Chunk readChunk(InputStream stream) throws IOException { String header = readLine(stream); if (header == null) { return null; } if (!HEADER_PATTERN.matcher(header).matches()) { throw new IOException(\"Chunk header corrupted\"); } StringTokenizer tokenizer = new StringTokenizer(header, \";=\\r\\n\"); int size = Integer.parseInt(tokenizer.nextToken(), 16); Map<String, String> parameters = new LinkedHashMap<String, String>(); while (tokenizer.hasMoreTokens()) { String name = tokenizer.nextToken(); String value = tokenizer.nextToken(); parameters.put(name, value); } byte[] bytes = new byte[size]; int total = 0; while (total < size) { int read = stream.read(bytes, total, size - total); if (read == -1) { throw new EOFException(\"Unexpected end of stream in chunk data\"); } total += read; } int cr = stream.read(); int lf = stream.read(); if (cr == -1 || cr == '\\r' && lf == -1) { throw new EOFException(\"Unexpected end of stream in chunk trailer\"); } else if (cr != '\\r' || lf != '\\n') { throw new IOException(\"Chunk trailer corrupted\"); } return new Chunk(bytes, parameters); } private static String readLine(InputStream stream) throws IOException { ByteArrayOutputStream header = new ByteArrayOutputStream(); while (true) { int b = stream.read(); if (b == -1) { if (header.size() == 0) { return null; } else { throw new EOFException(\"Unexpected end of stream in chunk header\"); } } header.write(b); if (b == '\\n') { return header.toString(ASCII); } } } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation;  public class Cool { public static void wait(Object object) { try { object.wait(); } catch (InterruptedException e) { unexpected(e); } } public static void sleep(long milliseconds) { try { Thread.sleep(milliseconds); } catch (InterruptedException e) { unexpected(e); } } public static void unexpected(Exception e) { throw new RuntimeException(\"Unexpected Exception was thrown.\", e); } public static void startDaemon(Runnable runnable) { Thread daemon = new Thread(runnable); daemon.setDaemon(true); daemon.start(); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation; import org.prevayler.foundation.serialization.JavaSerializer; import org.prevayler.foundation.serialization.Serializer; import java.io.*; public class DeepCopier {  public static Object deepCopy(Object original) { return deepCopy(original, new JavaSerializer()); }  public static Object deepCopy(Object original, Serializer serializer) { try { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); serializer.writeObject(byteOut, original); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); return serializer.readObject(byteIn); } catch (Exception e) { Cool.unexpected(e); return null; } }  public static <P> P deepCopyParallel(P original, Serializer serializer) throws Exception { PipedOutputStream outputStream = new PipedOutputStream(); PipedInputStream inputStream = new PipedInputStream(outputStream); Receiver<P> receiver = new Receiver<P>(inputStream, serializer); try { serializer.writeObject(outputStream, original); } finally { outputStream.close(); } return receiver.getResult(); } private static class Receiver<P> extends Thread { private InputStream _inputStream; private Serializer _serializer; private P _result; private Exception _exception; private Error _error; public Receiver(InputStream inputStream, Serializer serializer) { _inputStream = inputStream; _serializer = serializer; start(); } @SuppressWarnings(\"unchecked\") public void run() { try { _result = (P) _serializer.readObject(_inputStream); } catch (Exception e) { _exception = e; } catch (Error e) { _error = e; throw e; } try { "}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation; import java.io.File; import java.io.IOException; public class FileManager { public static File produceDirectory(String directoryPath) throws IOException { File directory = new File(directoryPath); produceDirectory(directory); return directory; } public static void produceDirectory(File directory) throws IOException { if (!directory.exists() && !directory.mkdirs()) throw new IOException(\"Directory doesn't exist and could not be created: \" + directory); if (!directory.isDirectory()) throw new IOException(\"Path exists but is not a directory: \" + directory); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation; import java.io.IOException; import java.io.OutputStream; public abstract class Guided { private final Turn _turn; protected Guided(Turn turn) { _turn = turn; } public void startTurn() { _turn.start(); } public void endTurn() { _turn.end(); } public void abortTurn(String message, Throwable cause) { _turn.abort(message, cause); } public abstract void writeTo(OutputStream stream) throws IOException; }"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation;  public class Turn {  public static Turn first() { return new Turn(true); } private Turn _next; private int _allowed; private Turn(boolean first) { _next = null; _allowed = first ? Integer.MAX_VALUE : 0; }  public synchronized Turn next() { if (_allowed < 0) { throw new IllegalStateException(\"All transaction processing is now aborted, probably due to an earlier IOException.\"); } if (_next == null) { _next = new Turn(false); } return _next; }  public synchronized void start() { while (_allowed == 0) { Cool.wait(this); } if (_allowed < 0) { throw new IllegalStateException(\"All transaction processing is now aborted, probably due to an earlier IOException.\"); } _allowed--; }  public void end() { next().allow(); } private synchronized void allow() { _allowed++; notifyAll(); }  public void abort(String message, Throwable cause) { Turn turn = this; while (turn != null) { turn = turn.die(); } throw new IllegalStateException(message, cause); } private synchronized Turn die() { _allowed = Integer.MIN_VALUE; notifyAll(); return _next; } }"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation.serialization; import org.prevayler.foundation.ObjectInputStreamWithClassLoader; import java.io.*;  public class JavaSerializer implements Serializer { private ClassLoader _loader; public JavaSerializer() { _loader = null; } public JavaSerializer(ClassLoader loader) { _loader = loader; } public void writeObject(OutputStream stream, Object object) throws IOException { ObjectOutputStream objects = new ObjectOutputStream(stream); objects.writeObject(object); objects.close(); } public Object readObject(InputStream stream) throws IOException, ClassNotFoundException { ObjectInputStream objects = new ObjectInputStreamWithClassLoader(stream, _loader); Object object = objects.readObject(); objects.close(); return object; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation.serialization; import java.io.InputStream; import java.io.OutputStream;  public interface Serializer {  public void writeObject(OutputStream stream, Object object) throws Exception;  public Object readObject(InputStream stream) throws Exception; }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.implementation; import org.prevayler.TransactionBase; import org.prevayler.foundation.Chunk; import org.prevayler.foundation.serialization.Serializer; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.Serializable; import java.util.Date; public abstract class Capsule<P, T extends TransactionBase> implements Serializable { private static final long serialVersionUID = -8253915186873598285L; private final byte[] _serialized; private transient T _directTransaction = null; protected Capsule(T transaction, Serializer journalSerializer, boolean transactionDeepCopyMode) { if (transactionDeepCopyMode == false) { _directTransaction = transaction; } try { ByteArrayOutputStream bytes = new ByteArrayOutputStream(); journalSerializer.writeObject(bytes, transaction); _serialized = bytes.toByteArray(); } catch (Exception exception) { throw new Error(\"Unable to serialize transaction\", exception); } } protected Capsule(byte[] serialized) { _serialized = serialized; }  public byte[] serialized() { return _serialized; }  @SuppressWarnings(\"unchecked\") public T deserialize(Serializer journalSerializer) { try { return (T) journalSerializer.readObject(new ByteArrayInputStream(_serialized)); } catch (Exception exception) { throw new Error(\"Unable to deserialize transaction\", exception); } }  public void executeOn(P prevalentSystem, Date executionTime, Serializer journalSerializer) { T transaction; if (_directTransaction != null) { transaction = _directTransaction; } else { transaction = deserialize(journalSerializer); } synchronized (prevalentSystem) { justExecute(transaction, prevalentSystem, executionTime); } }  protected abstract void justExecute(T transaction, P prevalentSystem, Date executionTime);  public abstract Capsule<P, T> cleanCopy(); Chunk toChunk() { Chunk chunk = new Chunk(_serialized); chunk.setParameter(\"withQuery\", String.valueOf(this instanceof TransactionWithQueryCapsule)); return chunk; } static <P> Capsule<P, ? extends TransactionBase> fromChunk(Chunk chunk) { boolean withQuery = Boolean.valueOf(chunk.getParameter(\"withQuery\")).booleanValue(); if (withQuery) { return new TransactionWithQueryCapsule<P, Object>(chunk.getBytes()); } else { return new TransactionCapsule<P>(chunk.getBytes()); } } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.implementation; import org.prevayler.Clock; import org.prevayler.Query; import org.prevayler.TransactionBase; import org.prevayler.foundation.Cool; import org.prevayler.foundation.DeepCopier; import org.prevayler.foundation.serialization.Serializer; import org.prevayler.implementation.publishing.TransactionPublisher; import org.prevayler.implementation.publishing.TransactionSubscriber; import org.prevayler.implementation.snapshot.GenericSnapshotManager; import java.io.File; import java.io.IOException; import java.util.Date; public class PrevalentSystemGuard<P> implements TransactionSubscriber<P> { private P _prevalentSystem; "}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.implementation; import org.prevayler.Transaction; import org.prevayler.foundation.serialization.Serializer; import java.util.Date; class TransactionCapsule<P> extends Capsule<P, Transaction<? super P>> { private static final long serialVersionUID = 3283271592697928351L; public TransactionCapsule(Transaction<? super P> transaction, Serializer journalSerializer, boolean transactionDeepCopyMode) { super(transaction, journalSerializer, transactionDeepCopyMode); } public TransactionCapsule(byte[] serialized) { super(serialized); } protected void justExecute(Transaction<? super P> transaction, P prevalentSystem, Date executionTime) { transaction.executeOn(prevalentSystem, executionTime); } public Capsule<P, Transaction<? super P>> cleanCopy() { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.implementation; import org.prevayler.foundation.Chunking; import org.prevayler.foundation.Guided; import org.prevayler.foundation.Turn; import java.io.IOException; import java.io.OutputStream; import java.util.Date; public class TransactionGuide<P> extends Guided { private final TransactionTimestamp<P> _transactionTimestamp; public TransactionGuide(TransactionTimestamp<P> transactionTimestamp, Turn pipelineTurn) { super(pipelineTurn); _transactionTimestamp = transactionTimestamp; } public TransactionTimestamp<P> timestamp() { return _transactionTimestamp; } public void checkSystemVersion(long expectedSystemVersion) { if (_transactionTimestamp.systemVersion() != expectedSystemVersion) { throw new IllegalStateException(\"Attempted to process \" + _transactionTimestamp.systemVersion() + \" when ready for \" + expectedSystemVersion); } } public Date executionTime() { return _transactionTimestamp.executionTime(); } public void writeTo(OutputStream stream) throws IOException { Chunking.writeChunk(stream, _transactionTimestamp.toChunk()); } }"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.implementation; import org.prevayler.TransactionWithQuery; import org.prevayler.foundation.serialization.Serializer; import java.util.Date; class TransactionWithQueryCapsule<P, R> extends Capsule<P, TransactionWithQuery<? super P, R>> { private static final long serialVersionUID = 78811627002206298L; private transient R _queryResult; private transient Exception _queryException; public TransactionWithQueryCapsule(TransactionWithQuery<? super P, R> transactionWithQuery, Serializer journalSerializer, boolean transactionDeepCopyMode) { super(transactionWithQuery, journalSerializer, transactionDeepCopyMode); } public TransactionWithQueryCapsule(byte[] serialized) { super(serialized); } protected void justExecute(TransactionWithQuery<? super P, R> transaction, P prevalentSystem, Date executionTime) { try { _queryResult = transaction.executeAndQuery(prevalentSystem, executionTime); } catch (RuntimeException rx) { _queryException = rx; throw rx; "}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.implementation.snapshot; import org.prevayler.foundation.serialization.JavaSerializer; import org.prevayler.foundation.serialization.Serializer; import org.prevayler.implementation.PrevalentSystemGuard; import org.prevayler.implementation.PrevaylerDirectory; import java.io.*; import java.util.Collections; import java.util.Iterator; import java.util.Map; public class GenericSnapshotManager<P> { private Map<String, ? extends Serializer> _strategies; private String _primarySuffix; private PrevaylerDirectory _directory; private PrevalentSystemGuard<P> _recoveredPrevalentSystem; public GenericSnapshotManager(Map<String, ? extends Serializer> snapshotSerializers, String primarySnapshotSuffix, P newPrevalentSystem, PrevaylerDirectory directory, Serializer journalSerializer) throws Exception { for (Iterator<String> iterator = snapshotSerializers.keySet().iterator(); iterator.hasNext(); ) { String suffix = iterator.next(); PrevaylerDirectory.checkValidSnapshotSuffix(suffix); } if (!snapshotSerializers.containsKey(primarySnapshotSuffix)) { throw new IllegalArgumentException(\"Primary suffix '\" + primarySnapshotSuffix + \"' does not appear in strategies map\"); } _strategies = snapshotSerializers; _primarySuffix = primarySnapshotSuffix; _directory = directory; _directory.produceDirectory(); File latestSnapshot = _directory.latestSnapshot(); long recoveredVersion = latestSnapshot == null ? 0 : PrevaylerDirectory.snapshotVersion(latestSnapshot); P recoveredPrevalentSystem = latestSnapshot == null ? newPrevalentSystem : readSnapshot(latestSnapshot); _recoveredPrevalentSystem = new PrevalentSystemGuard<P>(recoveredPrevalentSystem, recoveredVersion, journalSerializer); } GenericSnapshotManager(P newPrevalentSystem) { _strategies = Collections.singletonMap(\"snapshot\", new JavaSerializer()); _primarySuffix = \"snapshot\"; _directory = null; _recoveredPrevalentSystem = new PrevalentSystemGuard<P>(newPrevalentSystem, 0, new JavaSerializer()); } public Serializer primarySerializer() { return _strategies.get(_primarySuffix); } public PrevalentSystemGuard<P> recoveredPrevalentSystem() { return _recoveredPrevalentSystem; } public File writeSnapshot(P prevalentSystem, long version) throws Exception { File tempFile = _directory.createTempFile(\"snapshot\" + version + \"temp\", \"generatingSnapshot\"); writeSnapshot(prevalentSystem, tempFile); File permanent = snapshotFile(version); permanent.delete(); if (!tempFile.renameTo(permanent)) throw new IOException( \"Temporary snapshot file generated: \" + tempFile + \"\\nUnable to rename it permanently to: \" + permanent); return permanent; } private void writeSnapshot(P prevalentSystem, File snapshotFile) throws Exception { OutputStream out = new FileOutputStream(snapshotFile); try { primarySerializer().writeObject(out, prevalentSystem); } finally { out.close(); } } private File snapshotFile(long version) { return _directory.snapshotFile(version, _primarySuffix); } @SuppressWarnings(\"unchecked\") private P readSnapshot(File snapshotFile) throws Exception { String suffix = snapshotFile.getName().substring(snapshotFile.getName().indexOf('.') + 1); if (!_strategies.containsKey(suffix)) throw new IOException( snapshotFile.toString() + \" cannot be read; only \" + _strategies.keySet().toString() + \" supported\"); Serializer serializer = _strategies.get(suffix); FileInputStream in = new FileInputStream(snapshotFile); try { return (P) serializer.readObject(in); } finally { in.close(); } } }"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.demo1; import org.prevayler.Prevayler; import org.prevayler.PrevaylerFactory; import java.io.BufferedReader; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws Exception { printMessage(); Prevayler<NumberKeeper> prevayler = PrevaylerFactory.createPrevayler(new NumberKeeper(), \"demo1\"); new PrimeCalculator(prevayler).start(); } static private void printMessage() throws Exception { System.out.println(\"\\nRobustness Reminder: You can kill this process at any time.\\nWhen you restart the system, you will see that nothing was lost.\\nPress Enter to continue.\\n\"); (new BufferedReader(new InputStreamReader(System.in))).readLine(); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.demo1; import java.util.ArrayList; import java.util.List;  class NumberKeeper implements java.io.Serializable { private static final long serialVersionUID = 2253937139530882022L; private final List<Integer> numbers = new ArrayList<Integer>(); void keep(int nextNumber) { numbers.add(nextNumber); } List<Integer> numbers() { return numbers; } int lastNumber() { return numbers.isEmpty() ? 0 : numbers.get(numbers.size() - 1); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.demo1; import org.prevayler.Transaction; import java.util.Date;  class NumberStorageTransaction implements Transaction<NumberKeeper> { private static final long serialVersionUID = -2023934810496653301L; private int _numberToKeep; @SuppressWarnings(\"unused\") private NumberStorageTransaction() { } "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.demo1; import org.prevayler.Prevayler;  class PrimeCalculator { private final Prevayler<NumberKeeper> _prevayler; private final NumberKeeper _numberKeeper; PrimeCalculator(Prevayler<NumberKeeper> prevayler) { _prevayler = prevayler; _numberKeeper = prevayler.prevalentSystem(); } void start() throws Exception { int largestPrime = 0; int primesFound = 0; int primeCandidate = _numberKeeper.lastNumber() == 0 ? 2 : _numberKeeper.lastNumber() + 1; while (primeCandidate <= Integer.MAX_VALUE) { if (isPrime(primeCandidate)) { _prevayler.execute(new NumberStorageTransaction(primeCandidate)); largestPrime = primeCandidate; primesFound = _numberKeeper.numbers().size(); System.out.println(\"Primes found: \" + primesFound + \". Largest: \" + largestPrime); } primeCandidate++; } } private boolean isPrime(int candidate) {  if (candidate < 2) { return false; } if (candidate == 2) { return true; } if (candidate % 2 == 0) { return false; } int factor = 3; double square = Math.ceil(Math.sqrt(candidate)); while (factor <= square) { if (candidate % factor == 0) return false; factor += 2; } return true; } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.demos.jxpath; import org.apache.commons.jxpath.JXPathContext; import org.prevayler.Prevayler; import org.prevayler.PrevaylerFactory; import org.prevayler.demos.jxpath.commands.AddProject; import org.prevayler.demos.jxpath.commands.AddTask; import org.prevayler.demos.jxpath.model.Project; import org.prevayler.demos.jxpath.model.Task; import java.text.SimpleDateFormat; import java.util.Iterator;  public class Main {  public static void usage() { System.out.println( \"Usage: Main <list|proj|task|snap> <parameters>\\n\\n\" + \"Parameters:\\n\" + \" list: <xpath expression>\\n\" + \" proj: <id> <name>\\n\" + \" task: <id> <name> <start> <end> <projectId>\\n\" + \" snap\\n\\n\" + \"Note: dates should be entered in a locale-sensitive format (your locale is \" + System.getProperty(\"user.language\") + \"_\" + System.getProperty(\"user.country\") + \").\"); System.exit(0); }  public static void main(String[] args) { try { Prevayler<ProjectManagementSystem> prevayler = PrevaylerFactory.createPrevayler(new ProjectManagementSystem(), \"demoJXPath\"); if (args.length < 1) { usage(); } else if (\"list\".equalsIgnoreCase(args[0]) && args.length >= 2) { list(prevayler, args[1]); } else if (\"proj\".equalsIgnoreCase(args[0]) && args.length >= 3) { addProject(prevayler, args[1], args[2]); } else if (\"task\".equalsIgnoreCase(args[0]) && args.length >= 6) { addTask(prevayler, args[1], args[2], args[3], args[4], args[5]); } else if (\"snap\".equalsIgnoreCase(args[0])) { prevayler.takeSnapshot(); } else { usage(); } } catch (Exception e) { e.printStackTrace(); } }  private static void list(Prevayler<ProjectManagementSystem> prevayler, String xpathExp) { System.out.println(\"Executing XPath expression...\"); ProjectManagementSystem pms = prevayler.prevalentSystem(); JXPathContext context = JXPathContext.newContext(pms); Iterator<?> i = context.iterate(xpathExp); while (i.hasNext()) { Object obj = i.next(); System.out.println(obj.toString()); } }  private static void addProject( Prevayler<ProjectManagementSystem> prevayler, String id, String name) throws Exception { System.out.println( \"Adding project '\" + name + \"' (id '\" + id + \"')...\"); Project p = new Project(); p.setId(Integer.parseInt(id)); p.setName(name); AddProject cmd = new AddProject(); cmd.setProject(p); prevayler.execute(cmd); }  private static void addTask( Prevayler<ProjectManagementSystem> prevayler, String id, String name, String start, String end, String projectId) throws Exception { System.out.println( \"Adding task '\" + id + \"' to project '\" + projectId + \"'...\"); Task t = new Task(); t.setId(Integer.parseInt(id)); t.setName(name); t.setStart(SimpleDateFormat.getInstance().parse(start)); t.setEnd(SimpleDateFormat.getInstance().parse(end)); System.out.println(\"Start: \" + t.getStart()); System.out.println(\"End: \" + t.getEnd()); AddTask cmd = new AddTask(); cmd.setTask(t); cmd.setProjectId(Integer.parseInt(projectId)); prevayler.execute(cmd); } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.demos.jxpath; import java.io.Serializable; import java.util.ArrayList; import java.util.List; import org.prevayler.demos.jxpath.model.Project;  public class ProjectManagementSystem implements Serializable { private static final long serialVersionUID = -7896364970243693794L; private List<Project> projects; public ProjectManagementSystem() { projects = new ArrayList<Project>(); } public List<Project> getProjects() { return projects; } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.demos.jxpath.commands; import org.prevayler.Transaction; import org.prevayler.demos.jxpath.ProjectManagementSystem; import org.prevayler.demos.jxpath.model.Project; import java.util.Date;  public class AddProject implements Transaction<ProjectManagementSystem> { private static final long serialVersionUID = 4290539264132235963L; private Project project; public void executeOn(ProjectManagementSystem system, Date ignored) { if (project != null) { system.getProjects().add(project); } else { throw new RuntimeException(\"No project to add -- please call setProject()\"); } }  public Project getProject() { return project; }  public void setProject(Project project) { this.project = project; } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.demos.jxpath.commands; import org.prevayler.Transaction; import org.prevayler.demos.jxpath.ProjectManagementSystem; import org.prevayler.demos.jxpath.model.Project; import org.prevayler.demos.jxpath.model.Task; import java.util.ArrayList; import java.util.Date; import java.util.Iterator; import java.util.List;  public class AddTask implements Transaction<ProjectManagementSystem> { private static final long serialVersionUID = 8755505355908225763L; private Task task; private int projectId = Integer.MIN_VALUE; public void executeOn(ProjectManagementSystem system, Date ignored) { if (task != null && projectId != Integer.MIN_VALUE) { List<Project> projects = system.getProjects(); Iterator<Project> i = projects.iterator(); while (i.hasNext()) { Project p = i.next(); if (p.getId() == projectId) { List<Task> tasks = p.getTasks(); if (tasks == null) { tasks = new ArrayList<Task>(); } tasks.add(task); p.setTasks(tasks); break; } } } else { throw new RuntimeException(\"No project to add -- please call setProject()\"); } }  public int getProjectId() { return projectId; }  public Task getTask() { return task; }  public void setProjectId(int projectId) { this.projectId = projectId; }  public void setTask(Task task) { this.task = task; } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.demos.jxpath.model; import java.io.Serializable; import java.util.ArrayList; import java.util.List;  public class Project implements Serializable { private static final long serialVersionUID = -2877465670779650124L; private int id; private String name; private List<Task> tasks;  public Project() { tasks = new ArrayList<Task>(); }  public String getName() { return name; }  public List<Task> getTasks() { return tasks; }  public void setName(String name) { this.name = name; }  public void setTasks(List<Task> tasks) { this.tasks = tasks; }  public int getId() { return id; }  public void setId(int id) { this.id = id; } public String toString() { return \"Project Id: \" + id + \"\\n Name: \" + name + \"\\n Tasks:...\\n\" + tasks; } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.demos.jxpath.model; import java.io.Serializable; import java.util.Date;  public class Task implements Serializable { private static final long serialVersionUID = 1707816704776944347L; private int id; private String name; private Date start; private Date end;  public Date getEnd() { return end; }  public String getName() { return name; }  public Date getStart() { return start; }  public void setEnd(Date end) { this.end = end; }  public void setName(String name) { this.name = name; }  public void setStart(Date start) { this.start = start; }  public int getId() { return id; }  public void setId(int id) { this.id = id; } public String toString() { return \"\\n Task Id: \" + id + \"\\n Name: \" + name + \"\\nDate start: \" + start + \"\\n Date end: \" + end + \"\\n\"; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.service; import org.prevayler.Transaction; import java.io.Serializable; import java.util.Date; public class InitializeServiceTransaction implements Serializable, Transaction<Root> {  private static final long serialVersionUID = 1l; public void executeOn(Root root, Date executionTime) { root.setCreated(executionTime.getTime()); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.service; import java.io.Serializable; public class Root implements Serializable {  private static final long serialVersionUID = 1l; private Long created = null; public Long getCreated() { return created; } public void setCreated(Long created) { this.created = created; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.service; import org.prevayler.Prevayler; import org.prevayler.PrevaylerFactory; public class Service { public static void main(String[] args) throws Exception { Service.getInstance().open(); try { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability; import org.prevayler.demos.scalability.jdbc.JDBCQuerySubject; import org.prevayler.demos.scalability.jdbc.JDBCTransactionSubject; import org.prevayler.demos.scalability.prevayler.PrevaylerQuerySubject; import org.prevayler.demos.scalability.prevayler.PrevaylerTransactionSubject; import org.prevayler.foundation.serialization.JavaSerializer; import java.io.*; import java.util.Properties; public class Main { static private final Properties properties = new Properties(); static public void main(String[] args) { out(\"\\n=============================================================\"); out(\" Prevayler vs JDBC Scalability Tests \"); out(\"=============================================================\\n\"); out(\"If you have any trouble running the tests, just write to\"); out(\"prevayler-scalability@lists.sourceforge.net and we will be glad to help.\\n\"); try { out(\"Reading the properties file:\\n\" + propertiesFile().getAbsolutePath()); out(\"You can edit this file to configure the tests for the next run.\\n\"); properties.load(new FileInputStream(propertiesFile())); if (isPrevaylerQueryChosen()) runPrevaylerQuery(); if (isPrevaylerTransactionChosen()) runPrevaylerTransaction(); if (isJdbcQueryChosen()) runJdbcQuery(); if (isJdbcTransactionChosen()) runJdbcTransaction(); out(\"\\n\\n\\nFor better results, edit the properties file:\"); out(propertiesFile().getAbsolutePath()); out(\"\\nYou can publish your best results by mail to:\"); out(\"prevayler-scalability@lists.sourceforge.net. Please include info about your\"); out(\"processors (quantity, type, speed), compiler, VM, operating system and DBMS.\"); out(\"\"); out(\"Scalability test results are published on www.prevayler.org.\"); out(\"See you there.\\n\"); out(\"Klaus Wuestefeld and Daniel Santos.\\n\\n\"); } catch (Exception ex) { ex.printStackTrace(); } catch (OutOfMemoryError err) { ScalabilityTestRun.outOfMemory(); } } static private void runPrevaylerQuery() throws Exception { new QueryTestRun( new PrevaylerQuerySubject(), numberOfObjects(), prevaylerQueryThreadsMin(), prevaylerQueryThreadsMax() ); } static private void runPrevaylerTransaction() throws Exception { PrevaylerTransactionSubject subject = new PrevaylerTransactionSubject(prevaylerTransactionLogDirectory(), prevaylerJournalSerializer()); new TransactionTestRun( subject, numberOfObjects(), prevaylerTransactionThreadsMin(), prevaylerTransactionThreadsMax() ); if (isPrevaylerTransactionConsistencyChecked()) { out(\"Checking transaction log consistency.\"); if (!subject.isConsistent()) throw new RuntimeException(\"Transaction log consistency check failed.\"); out(\"Transaction log OK.\\n\"); } } static private void runJdbcQuery() { new QueryTestRun( new JDBCQuerySubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()), numberOfObjects(), jdbcQueryThreadsMin(), jdbcQueryThreadsMax() ); } static private void runJdbcTransaction() { new TransactionTestRun( new JDBCTransactionSubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()), numberOfObjects(), jdbcTransactionThreadsMin(), jdbcTransactionThreadsMax() ); } static private File propertiesFile() throws IOException { File result = new File(\"ScalabilityTest.properties\"); if (!result.exists()) { out(\"Creating the properties file.\"); createPropertiesFile(result); } return result; } static private void createPropertiesFile(File file) throws IOException { PrintStream stream = new PrintStream(new FileOutputStream(file)); try { stream.println( \"###########################################################\\n\" + \"# #\\n\" + \"# PREVAYLER VS JDBC SCALABILITY TEST PROPERTIES #\\n\" + \"# #\\n\" + \"###########################################################\\n\" + \"\\n\" + \"NumberOfObjects = ONE_HUNDRED_THOUSAND\\n\" + \"# NumberOfObjects = ONE_MILLION\\n\" + \"# NumberOfObjects = TEN_MILLION\\n\" + \"# NumberOfObjects = TWENTY_MILLION\\n\" + \"#\\n\" + \"# The results are only valid if both Prevayler and the\\n\" + \"# database can run the tests without paging memory to disk.\\n\" + \"#\\n\" + \"# Running the tests with one hundred thousand objects\\n\" + \"# (default option) requires approx. 128MB free RAM.\\n\" + \"# The VM must be started with a sufficient maximum heap\\n\" + \"# size or you will get an OutOfMemoryError.\\n\" + \"#\\n\" + \"# Example for Linux and Windows: java -Xmx128000000 ...\\n\" + \"#\\n\" + \"# (This can be set with the scalability.jvmarg property\\n\" + \"# in build.properties; see sample.build.properties for\\n\" + \"# examples.)\\n\" + \"#\\n\" + \"# Running the tests with one million objects requires\\n\" + \"# approx. 940MB free RAM.\\n\" + \"# Running the tests with ten million objects requires\\n\" + \"# approx. 9.4GB free RAM and a 64bit VM.\\n\" + \"#\\n\" + \"# IMPORTANT: Remember to shutdown all other non-vital\\n\" + \"# processes before running the tests. Even the database\\n\" + \"# process should be down while running the Prevayler tests\\n\" + \"# that do not use it.\\n\" + \"\\n\" + \"\\n\" + \"###########################################################\\n\" + \"# PREVAYLER QUERY TEST\\n\" + \"\\n\" + \"RunPrevaylerQueryTest = YES\\n\" + \"# RunPrevaylerQueryTest = NO\\n\" + \"\\n\" + \"PrevaylerQueryThreadsMinimum = 1\\n\" + \"PrevaylerQueryThreadsMaximum = 5\\n\" + \"# More threads can produce better results on\\n\" + \"# multi-processor machines.\\n\" + \"\\n\" + \"\\n\" + \"###########################################################\\n\" + \"# PREVAYLER TRANSACTION TEST\\n\" + \"\\n\" + \"RunPrevaylerTransactionTest = YES\\n\" + \"# RunPrevaylerTransactionTest = NO\\n\" + \"\\n\" + \"PrevaylerTransactionThreadsMinimum = 1\\n\" + \"PrevaylerTransactionThreadsMaximum = 5\\n\" + \"#\\n\" + \"# More threads can produce better results on machines with\\n\" + \"# multiple disks.\\n\" + \"\\n\" + \"TransactionTestCheckConsistency = YES\\n\" + \"# TransactionTestCheckConsistency = NO\\n\" + \"#\\n\" + \"# Verifies the integrity of the journal files produced in\\n\" + \"# your particular environment.\\n\" + \"\\n\" + \"TransactionLogDirectory = TransactionTest\\n\" + \"#\\n\" + \"# The full path name can be used. Example for Windows:\\n\" + \"# TransactionLogDirectory1 = c:\\\\\\\\temp\\\\\\\\TransactionTest\\n\" + \"# The back-slash (\\\\) is the escape character so you must\\n\" + \"# use two back-slashes (\\\\\\\\).\\n\" + \"\\n\" + \"PrevaylerJournalSerializer = \" + JavaSerializer.class.getName() + \"\\n\" + \"\\n\" + \"\\n\" + \"###########################################################\\n\" + \"# JDBC QUERY TEST\\n\" + \"\\n\" + \"RunJdbcQueryTest = NO\\n\" + \"# RunJdbcQueryTest = YES\\n\" + \"\\n\" + \"JdbcQueryThreadsMinimum = 1\\n\" + \"JdbcQueryThreadsMaximum = 5\\n\" + \"# More threads can produce better results on some machines.\\n\" + \"\\n\" + \"\\n\" + \"###########################################################\\n\" + \"# JDBC TRANSACTION TEST\\n\" + \"\\n\" + \"RunJdbcTransactionTest = NO\\n\" + \"# RunJdbcTransactionTest = YES\\n\" + \"\\n\" + \"JdbcTransactionThreadsMinimum = 1\\n\" + \"JdbcTransactionThreadsMaximum = 5\\n\" + \"# More threads can produce better results on some machines.\\n\" + \"\\n\" + \"\\n\" + \"###########################################################\\n\" + \"# JDBC CONNECTION\\n\" + \"# (necessary to run the JDBC tests)\\n\" + \"\\n\" + \"JdbcDriverClassName =\\n\" + \"JdbcConnectionURL =\\n\" + \"JdbcUser =\\n\" + \"JdbcPassword =\\n\" + \"# These two tables are necessary for the JDBC tests:\\n\" + \"# QUERY_TEST and TRANSACTION_TEST.\\n\" + \"# Both tables have the same column structure:\\n\" + \"# ID DECIMAL,\\n\" + \"# NAME VARCHAR2(8),\\n\" + \"# STRING1 VARCHAR2(1000),\\n\" + \"# BIGDECIMAL1 DECIMAL,\\n\" + \"# BIGDECIMAL2 DECIMAL,\\n\" + \"# DATE1 DATE,\\n\" + \"# DATE2 DATE.\\n\" + \"\\n\" + \"# IMPORTANT: For best results, create indices on the\\n\" + \"# QUERY_TEST.NAME and TRANSACTION_TEST.ID columns.\\n\" + \"# Do not create indices on any other column.\\n\" ); } finally { stream.close(); } } static private int numberOfObjects() { String property = property(\"NumberOfObjects\"); if (\"ONE_HUNDRED_THOUSAND\".equals(property)) return 100000; if (\"ONE_MILLION\".equals(property)) return 1000000; if (\"TEN_MILLION\".equals(property)) return 10000000; if (\"TWENTY_MILLION\".equals(property)) return 20000000; throw new RuntimeException(\"NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION.\"); } static private boolean isPrevaylerQueryChosen() { return booleanProperty(\"RunPrevaylerQueryTest\"); } static private int prevaylerQueryThreadsMin() { return intProperty(\"PrevaylerQueryThreadsMinimum\"); } static private int prevaylerQueryThreadsMax() { return intProperty(\"PrevaylerQueryThreadsMaximum\"); } static private boolean isPrevaylerTransactionChosen() { return booleanProperty(\"RunPrevaylerTransactionTest\"); } static private int prevaylerTransactionThreadsMin() { return intProperty(\"PrevaylerTransactionThreadsMinimum\"); } static private int prevaylerTransactionThreadsMax() { return intProperty(\"PrevaylerTransactionThreadsMaximum\"); } static private boolean isPrevaylerTransactionConsistencyChecked() { return booleanProperty(\"TransactionTestCheckConsistency\"); } static private String prevaylerTransactionLogDirectory() { String result = property(\"TransactionLogDirectory\"); out(\"\\n\\nPrevayler TransactionLog Directory: \" + result); return result; } static private String prevaylerJournalSerializer() { String result = properties.getProperty(\"PrevaylerJournalSerializer\"); if (result == null) result = JavaSerializer.class.getName(); out(\"\\n\\nPrevayler Journal Serializer: \" + result); return result; } static private boolean isJdbcQueryChosen() { return booleanProperty(\"RunJdbcQueryTest\"); } static private int jdbcQueryThreadsMin() { return intProperty(\"JdbcQueryThreadsMinimum\"); } static private int jdbcQueryThreadsMax() { return intProperty(\"JdbcQueryThreadsMaximum\"); } static private boolean isJdbcTransactionChosen() { return booleanProperty(\"RunJdbcTransactionTest\"); } static private int jdbcTransactionThreadsMin() { return intProperty(\"JdbcTransactionThreadsMinimum\"); } static private int jdbcTransactionThreadsMax() { return intProperty(\"JdbcTransactionThreadsMaximum\"); } static private String jdbcDriverClassName() { return property(\"JdbcDriverClassName\"); } static private String jdbcConnectionURL() { return property(\"JdbcConnectionURL\"); } static private String jdbcUser() { return property(\"JdbcUser\"); } static private String jdbcPassword() { return property(\"JdbcPassword\"); } static private String property(String name) { String result = properties.getProperty(name); if (result == null) throw new RuntimeException(\"Property \" + name + \" not found.\"); return result; } static private int intProperty(String name) { try { return Integer.valueOf(property(name)); } catch (NumberFormatException nfx) { out(\"NumberFormatException reading property \" + name); throw nfx; } } static private boolean booleanProperty(String name) { boolean result = \"yes\".equalsIgnoreCase(property(name)); if (result) return true; out(\"\\n\\n\\n\" + name + \" property is set to \" + property(name) + \".\"); out(\"This test will be skipped (see properties file).\"); return false; } static private void out(Object message) { System.out.println(message); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability; import java.util.List; public interface QueryConnection {  public List<Record> queryByName(String name); }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability; import java.io.Serializable; import java.math.BigDecimal; import java.util.Arrays; import java.util.Date; import java.util.Random; public class Record implements Serializable { private static final long serialVersionUID = 7098880197177237832L; private static final String largeString = generateLargeString(); private final long id; private final String name; private final String string1; private final BigDecimal bigDecimal1; private final BigDecimal bigDecimal2; private final long date1; private final long date2; private static final Random RANDOM = new Random(); public Record(long id) { this(id, RANDOM); } public Record(long id, Random random) { this( id, \"NAME\" + (id % 10000), (id % 10000) == 0 ? largeString + id : null, new BigDecimal(random.nextInt()), new BigDecimal(random.nextInt()), new Date(random.nextInt(10000000)), new Date(random.nextInt(10000000)) ); } public Record(long id, String name, String string1, BigDecimal bigDecimal1, BigDecimal bigDecimal2, Date date1, Date date2) { this.id = id; this.name = name; this.string1 = string1; this.bigDecimal1 = bigDecimal1; this.bigDecimal2 = bigDecimal2; this.date1 = date1.getTime(); this.date2 = date2.getTime(); } public long getId() { return id; } public String getName() { return name; } public String getString1() { return string1; } public BigDecimal getBigDecimal1() { return bigDecimal1; } public BigDecimal getBigDecimal2() { return bigDecimal2; } public Date getDate1() { return new Date(date1); } public Date getDate2() { return new Date(date2); } public int hashCode() { return (int) (id + name.hashCode() + (\"\" + string1).hashCode() + bigDecimal1.hashCode() + bigDecimal2.hashCode() + date1 + date2 ); } static private String generateLargeString() { char[] chars = new char[980]; Arrays.fill(chars, 'A'); return new String(chars); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability; import java.io.Serializable; import java.util.Random;  public class RecordIterator implements Serializable { private static final long serialVersionUID = 4278565982042966467L; private int nextRecordId = 0; private final int numberOfRecords; private final Random _random = new Random(0); public RecordIterator(int numberOfRecords) { this.numberOfRecords = numberOfRecords; } public boolean hasNext() { return nextRecordId < numberOfRecords; } public Record next() { indicateProgress(); return new Record(nextRecordId++, _random); } private void indicateProgress() { if (nextRecordId == 0) { out(\"Creating \" + numberOfRecords + \" objects...\"); return; } if (nextRecordId % 100000 == 0) out(\"\" + nextRecordId + \"...\"); } static private void out(Object message) { System.out.println(message); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability; public interface TransactionConnection { public void performTransaction(Record recordToInsert, Record recordToUpdate, long idToDelete); }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.jdbc; import org.prevayler.demos.scalability.QueryConnection; import org.prevayler.demos.scalability.Record; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.jdbc; import org.prevayler.demos.scalability.QueryConnection; public class JDBCQuerySubject extends JDBCScalabilitySubject<QueryConnection> { public JDBCQuerySubject(String jdbcDriverClassName, String connectionURL, String user, String password) { super(jdbcDriverClassName, connectionURL, user, password); } public QueryConnection createTestConnection() { return new JDBCQueryConnection(createConnection()); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.jdbc; import org.prevayler.demos.scalability.Record; import org.prevayler.demos.scalability.RecordIterator; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; "}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.jdbc; import org.prevayler.demos.scalability.TransactionConnection; public class JDBCTransactionSubject extends JDBCScalabilitySubject<TransactionConnection> { public JDBCTransactionSubject(String jdbcDriverClassName, String connectionURL, String user, String password) { super(jdbcDriverClassName, connectionURL, user, password); } public TransactionConnection createTestConnection() { return new JDBCTransactionConnection(createConnection()); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.Transaction; import org.prevayler.demos.scalability.RecordIterator; import java.util.Date; class AllRecordsReplacement<S extends ScalabilitySystem> implements Transaction<S> { private static final long serialVersionUID = 6283032417365727408L; private final int _records; AllRecordsReplacement(int records) { _records = records; } public void executeOn(S system, Date ignored) { system.replaceAllRecords(new RecordIterator(_records)); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.demos.scalability.QueryConnection; import org.prevayler.demos.scalability.Record; import java.util.List; class PrevaylerQueryConnection implements QueryConnection { private final QuerySystem querySystem; PrevaylerQueryConnection(QuerySystem querySystem) { this.querySystem = querySystem; } public List<Record> queryByName(String name) { return querySystem.queryByName(name); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.PrevaylerFactory; import org.prevayler.demos.scalability.QueryConnection; import java.io.File; import java.io.PrintStream; public class PrevaylerQuerySubject extends PrevaylerScalabilitySubject<QuerySystem, QueryConnection> { static final String PREVALENCE_BASE = \"QueryTest\"; public PrevaylerQuerySubject() throws Exception { if (new File(PREVALENCE_BASE).exists()) PrevalenceTest.delete(PREVALENCE_BASE); PrevaylerFactory<QuerySystem> factory = new PrevaylerFactory<QuerySystem>(); factory.configurePrevalentSystem(new QuerySystem()); factory.configurePrevalenceDirectory(PREVALENCE_BASE); prevayler = factory.create(); } public QueryConnection createTestConnection() { return new PrevaylerQueryConnection(prevayler.prevalentSystem()); } public void reportResourcesUsed(PrintStream out) { } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.Prevayler; import org.prevayler.demos.scalability.ScalabilityTestSubject; abstract class PrevaylerScalabilitySubject<S extends ScalabilitySystem, C> implements ScalabilityTestSubject<C> { protected Prevayler<S> prevayler; { System.gc(); } public String name() { return \"Prevayler\"; } public void replaceAllRecords(int records) { try { prevayler.execute(new AllRecordsReplacement<S>(records)); } catch (Exception ex) { ex.printStackTrace(); throw new RuntimeException(\"Unexpected Exception: \" + ex); } } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.Prevayler; import org.prevayler.demos.scalability.Record; import org.prevayler.demos.scalability.TransactionConnection; class PrevaylerTransactionConnection implements TransactionConnection { private final Prevayler<TransactionSystem> prevayler; PrevaylerTransactionConnection(Prevayler<TransactionSystem> prevayler) { this.prevayler = prevayler; } public void performTransaction(Record recordToInsert, Record recordToUpdate, long idToDelete) { try { prevayler.execute(new TestTransaction(recordToInsert, recordToUpdate, idToDelete)); } catch (Exception ex) { ex.printStackTrace(); throw new RuntimeException(\"Unexpected Exception: \" + ex); } } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.PrevaylerFactory; import org.prevayler.demos.scalability.TransactionConnection; import org.prevayler.foundation.serialization.Serializer; import java.io.File; import java.io.PrintStream; public class PrevaylerTransactionSubject extends PrevaylerScalabilitySubject<TransactionSystem, TransactionConnection> { private final String _journalDirectory; private final String _journalSerializer; public PrevaylerTransactionSubject(String journalDirectory, String journalSerializer) throws Exception { _journalDirectory = journalDirectory; _journalSerializer = journalSerializer; if (new File(_journalDirectory).exists()) PrevalenceTest.delete(_journalDirectory); initializePrevayler(); } public TransactionConnection createTestConnection() { return new PrevaylerTransactionConnection(prevayler); } public void reportResourcesUsed(PrintStream out) { int totalSize = 0; File[] files = new File(_journalDirectory).listFiles(); for (int i = 0; i < files.length; i++) { totalSize += files[i].length(); } out.println(\"Disk space used: \" + totalSize); } public boolean isConsistent() throws Exception { int expectedResult = prevayler.prevalentSystem().hashCode(); initializePrevayler(); "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.demos.scalability.Record; import org.prevayler.demos.scalability.RecordIterator; import java.util.*; class QuerySystem implements ScalabilitySystem { private static final long serialVersionUID = -8181198939095700706L; private Map<String, List<Record>> recordsByName = new HashMap<String, List<Record>>(); public List<Record> queryByName(String name) { return recordsByName.get(name); } public void replaceAllRecords(RecordIterator newRecords) { recordsByName.clear(); while (newRecords.hasNext()) { put(newRecords.next()); } makeReadOnly(); } private void put(Record newRecord) { List<Record> records = queryByName(newRecord.getName()); if (records == null) { records = new ArrayList<Record>(); recordsByName.put(newRecord.getName(), records); } records.add(newRecord); }  private void makeReadOnly() { Iterator<Map.Entry<String, List<Record>>> entries = recordsByName.entrySet().iterator(); while (entries.hasNext()) { Map.Entry<String, List<Record>> entry = entries.next(); entry.setValue(Collections.unmodifiableList(entry.getValue())); } } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.demos.scalability.RecordIterator; interface ScalabilitySystem extends java.io.Serializable { void replaceAllRecords(RecordIterator newRecords); }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.scalability.prevayler; import org.prevayler.demos.scalability.Record; import org.prevayler.demos.scalability.RecordIterator; import java.util.HashMap; import java.util.Map; class TransactionSystem implements ScalabilitySystem { private static final long serialVersionUID = 461535927650714306L; private final Map<Long, Record> recordsById = new HashMap<Long, Record>(); public void performTransaction(Record recordToInsert, Record recordToUpdate, long idToDelete) { synchronized (recordsById) { put(recordToInsert); put(recordToUpdate); recordsById.remove(Long.valueOf(idToDelete)); } } private Object put(Record newRecord) { return recordsById.put(newRecord.getId(), newRecord); } public void replaceAllRecords(RecordIterator newRecords) { recordsById.clear(); while (newRecords.hasNext()) { put(newRecords.next()); } } public int hashCode() { return recordsById.hashCode(); } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import java.io.Serializable; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Date;  public abstract class AbstractProxy<P> implements Serializable { private static final long serialVersionUID = 9121309710811270339L;  protected AbstractProxy(Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) { m_methodInfo = new MethodInfo(p_method); m_args = p_args; m_hint = p_hint; } private final MethodInfo m_methodInfo; private final Object[] m_args; private final TransactionHint<? super P> m_hint;  protected Object execute(P p_prevalentSystem, Date p_timestamp) throws Exception { try { m_hint.preExecute(p_prevalentSystem, getMethod(), m_args, p_timestamp); return getMethod().invoke(p_prevalentSystem, m_args); } catch (RuntimeException e) { throw e; } catch (InvocationTargetException e) { Throwable e2 = e.getTargetException(); if (e2 instanceof Exception) { throw (Exception) e2; } else { throw (Error) e2; } } } private Method getMethod() throws Exception { return m_methodInfo.getMethod(); } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import java.io.Serializable; import java.lang.reflect.Method;  public class MethodInfo implements Serializable { private static final long serialVersionUID = -7565901432660010880L;  public MethodInfo(Method p_method) { m_name = p_method.getName(); Class<?>[] paramTypes = p_method.getParameterTypes(); m_argTypes = new String[paramTypes.length]; for (int i = 0; i < m_argTypes.length; ++i) { m_argTypes[i] = paramTypes[i].getName(); } m_className = p_method.getDeclaringClass().getName(); }  public Method getMethod() throws Exception { Class<?>[] args = new Class<?>[m_argTypes.length]; for (int i = 0; i < args.length; ++i) { args[i] = Class.forName(m_argTypes[i]); } return Class.forName(m_className).getMethod(m_name, args); } private final String m_name; private final String m_className; private final String[] m_argTypes; }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import java.lang.reflect.Method;  public class MethodNameTransactionTypeDeterminer implements TransactionType.Determiner { public TransactionType determineTransactionType(Method p_method) { String name = p_method.getName(); if (p_method.getReturnType() == Void.TYPE) { if (name.indexOf(\"transient\") != -1 || name.indexOf(\"Transient\") != -1) { "}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import org.prevayler.Prevayler; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy;  public class PrevaylerTransactionsFacade {  public static <P> P create(Class<P> p_intf, Prevayler<? extends P> p_prevayler) { return create(p_intf, p_prevayler, TransactionType.SIMPLE_DETERMINER, TransactionHint.NOOP_TRANSACTION_HINT); }  public static <P> P create(final Class<P> p_intf, final Prevayler<? extends P> p_prevayler, final TransactionType.Determiner p_determiner, final TransactionHint<? super P> p_hint) { return p_intf.cast(Proxy.newProxyInstance (p_intf.getClassLoader(), new Class<?>[]{p_intf}, new InvocationHandler() { public Object invoke(Object p_proxy, Method p_method, Object[] p_args) throws Throwable { return p_determiner.determineTransactionType(p_method) .execute(p_prevayler, p_method, p_args, p_hint); } })); } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import org.prevayler.Query; import java.lang.reflect.Method; import java.util.Date;  public class ProxyQuery<P> extends AbstractProxy<P> implements Query<P, Object> { private static final long serialVersionUID = 7773538966349888966L;  public ProxyQuery(Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) { super(p_method, p_args, p_hint); } public Object query(P p_prevalentSystem, Date p_timestamp) throws Exception { return execute(p_prevalentSystem, p_timestamp); } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import org.prevayler.Transaction; import java.lang.reflect.Method; import java.util.Date;  public class ProxyTransaction<P> extends AbstractProxy<P> implements Transaction<P> { private static final long serialVersionUID = -3720257876251185011L;  public ProxyTransaction(Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) { super(p_method, p_args, p_hint); } public void executeOn(P p_prevalentSystem, Date p_timestamp) { try { execute(p_prevalentSystem, p_timestamp); } catch (Exception e) { throw new RuntimeException(e); } } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import org.prevayler.TransactionWithQuery; import java.lang.reflect.Method; import java.util.Date;  public class ProxyTransactionWithQuery<P> extends AbstractProxy<P> implements TransactionWithQuery<P, Object> { private static final long serialVersionUID = -5012126657533926785L;  public ProxyTransactionWithQuery(Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) { super(p_method, p_args, p_hint); } public Object executeAndQuery(P p_prevalentSystem, Date p_timestamp) throws Exception { return execute(p_prevalentSystem, p_timestamp); } }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import java.io.Serializable; import java.lang.reflect.Method; import java.util.Date;  public interface TransactionHint<P> extends Serializable {  public static final TransactionHint<Object> NOOP_TRANSACTION_HINT = new TransactionHint<Object>() { private static final long serialVersionUID = -5478302343468894802L; public void preExecute(Object p_prevalentSystem, Method p_method, Object[] p_args, Date p_timestamp) throws Exception { } };  public void preExecute(P p_prevalentSystem, Method p_method, Object[] p_args, Date p_timestamp) throws Exception; }"}
{"name": "prevayler/prevayler", "content": " package org.prevayler.contrib.facade; import org.prevayler.Prevayler; import java.lang.reflect.Method;  public abstract class TransactionType {  public interface Determiner {  TransactionType determineTransactionType(Method p_method); }  public static final Determiner SIMPLE_DETERMINER = new Determiner() { public TransactionType determineTransactionType(Method p_method) { return TRANSACTION_WITH_QUERY; } };  public static final Determiner RETURN_TYPE_DETERMINER = new Determiner() { public TransactionType determineTransactionType(Method p_method) { return (p_method.getReturnType() != Void.TYPE) ? QUERY : TRANSACTION; } };  public abstract <P> Object execute(Prevayler<? extends P> p_prevayler, Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) throws Exception; public String toString() { return \"TransactionType{\" + m_name + \"}\"; } private TransactionType(String p_name) { m_name = p_name; } private final String m_name; public static final TransactionType QUERY = new TransactionType(\"QUERY\") {  public <P> Object execute(Prevayler<? extends P> p_prevayler, Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) throws Exception { return p_prevayler.execute(new ProxyQuery<P>(p_method, p_args, p_hint)); } }; public static final TransactionType TRANSACTION_WITH_QUERY = new TransactionType(\"TRANSACTION_WITH_QUERY\") {  public <P> Object execute(Prevayler<? extends P> p_prevayler, Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) throws Exception { return p_prevayler.execute(new ProxyTransactionWithQuery<P>(p_method, p_args, p_hint)); } }; public static final TransactionType TRANSACTION = new TransactionType(\"TRANSACTION\") {  public <P> Object execute(Prevayler<? extends P> p_prevayler, Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) throws Exception { p_prevayler.execute(new ProxyTransaction<P>(p_method, p_args, p_hint)); return null; } };  public static final TransactionType NOOP = new TransactionType(\"NOOP\") { public <P> Object execute(Prevayler<? extends P> p_prevayler, Method p_method, Object[] p_args, TransactionHint<? super P> p_hint) throws Exception { return null; } }; }"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.memento; import org.prevayler.util.memento.Memento; import org.prevayler.util.memento.MementoCollector; import java.util.ArrayList; import java.util.Date; import java.util.List;  public class Account implements java.io.Serializable { private static final long serialVersionUID = 1L; private long number; private String holder; private long balance = 0; private List<Transaction> transactionHistory = new ArrayList<Transaction>(); @SuppressWarnings(\"unused\") private Account() { } "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.memento; import org.prevayler.util.memento.Memento; import org.prevayler.util.memento.MementoCollector; import java.io.PrintWriter; import java.io.StringWriter; import java.util.*;  public class Bank implements java.io.Serializable { private static final long serialVersionUID = 6025629369302269753L; private long nextAccountNumber = 1; private Map<Long, Account> accountsByNumber = new HashMap<Long, Account>();  private class BankMemento extends Memento { private long nextAccountNumber; private Map<Long, Account> accountsByNumber; private BankMemento() { super(); nextAccountNumber = Bank.this.nextAccountNumber; accountsByNumber = new HashMap<Long, Account>(Bank.this.accountsByNumber); } protected void restore() { Bank.this.nextAccountNumber = nextAccountNumber; Bank.this.accountsByNumber.clear(); Bank.this.accountsByNumber.putAll(accountsByNumber); } protected Object getOwner() { return Bank.this; } }  public void createMemento(MementoCollector collector) { collector.addMemento(new BankMemento()); } public Account createAccount(String holder) throws Account.InvalidHolder { Account account = new Account(nextAccountNumber, holder); accountsByNumber.put(nextAccountNumber++, account); return account; } public void deleteAccount(long number) throws AccountNotFound { findAccount(number); accountsByNumber.remove(Long.valueOf(number)); } public List<Account> accounts() { List<Account> accounts = new ArrayList<Account>(accountsByNumber.values()); Collections.sort(accounts, new Comparator<Account>() { public int compare(Account acc1, Account acc2) { return acc1.number() < acc2.number() ? -1 : 1; } }); return accounts; } public Account findAccount(long number) throws AccountNotFound { Account account = searchAccount(number); if (account == null) throw new AccountNotFound(number); return account; } public void transfer(long sourceNumber, long destinationNumber, long amount, Date timestamp) throws AccountNotFound, Account.InvalidAmount { Account source = findAccount(sourceNumber); Account destination = findAccount(destinationNumber); source.withdraw(amount, timestamp); destination.deposit(amount, timestamp); } private Account searchAccount(long number) { return accountsByNumber.get(Long.valueOf(number)); } public class AccountNotFound extends Exception { private static final long serialVersionUID = 4463910784646858052L; AccountNotFound(long number) { super(\"Account not found: \" + Account.numberString(number) + \".\\nMight have been deleted.\"); } } public String toString() { StringWriter stringWriter = new StringWriter(); PrintWriter writer = new PrintWriter(stringWriter); Iterator<Account> iterator; iterator = accountsByNumber.values().iterator(); while (iterator.hasNext()) { writer.println(iterator.next()); } writer.flush(); return stringWriter.toString(); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.memento.commands; import org.prevayler.demos.memento.Account; import org.prevayler.demos.memento.Bank; import org.prevayler.util.memento.MementoCollector; import org.prevayler.util.memento.MementoTransaction; public class AccountCreation extends MementoTransaction { private static final long serialVersionUID = 591298522015413614L; private final String holder;  protected transient Bank bank; public AccountCreation(String holder) { this.holder = holder; } protected void findObjects(Bank prevalentSystem) { bank = prevalentSystem; } protected void checkPrecondition() { } protected void createMementos(MementoCollector collector) { bank.createMemento(collector); } protected Account execute(MementoCollector collector) throws Account.InvalidHolder { return bank.createAccount(holder); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.memento.commands; import org.prevayler.demos.memento.Account; import org.prevayler.demos.memento.Bank; import org.prevayler.util.memento.MementoCollector; import org.prevayler.util.memento.MementoTransaction; public class AccountDeletion extends MementoTransaction { private static final long serialVersionUID = -3883591469544966498L; private final long accountNumber;  protected transient Bank bank; public AccountDeletion(Account account) { accountNumber = account.number(); } protected void findObjects(Bank prevalentSystem) { bank = prevalentSystem; } protected void checkPrecondition() { } protected void createMementos(MementoCollector collector) { bank.createMemento(collector); } protected Account execute(MementoCollector collector) throws Bank.AccountNotFound { bank.deleteAccount(accountNumber); return null; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.memento.commands; import org.prevayler.demos.memento.Account; import org.prevayler.demos.memento.Bank; import org.prevayler.util.memento.MementoCollector; import org.prevayler.util.memento.MementoTransaction; import javax.swing.*; import java.util.Date; public class Deposit extends MementoTransaction { private static final long serialVersionUID = -154783426607714557L; private long accountNumber; private long amount;  private transient Account account; public Deposit(Account account, long amount) { this(account.number(), amount); } public Deposit(long accountNumber, long amount) { super(); this.accountNumber = accountNumber; this.amount = amount; } protected void findObjects(Bank prevalentSystem) throws Exception { if (JOptionPane.showConfirmDialog(null, \"Fail at Deposit::findObjects?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } account = prevalentSystem.findAccount(accountNumber); } protected void checkPrecondition() { if (JOptionPane.showConfirmDialog(null, \"Fail at Deposit::checkPrecondition?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } } protected void createMementos(MementoCollector collector) { if (JOptionPane.showConfirmDialog(null, \"Fail at Deposit::createMemento?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } account.createMemento(collector); } protected Account execute(MementoCollector collector) throws Exception { if (JOptionPane.showConfirmDialog(null, \"Fail at Deposit::execute?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } account.deposit(amount, new Date()); "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.memento.commands; import org.prevayler.demos.memento.Account; import org.prevayler.demos.memento.Bank; import org.prevayler.util.memento.MementoCollector; import org.prevayler.util.memento.MementoTransaction; public class Transfer extends MementoTransaction { private static final long serialVersionUID = -6700799319722269361L; private long sourceNumber; private long destinationNumber; private long amount;  private transient Bank bank; public Transfer(long sourceNumber, long destinationNumber, long amount) { super(); this.sourceNumber = sourceNumber; this.destinationNumber = destinationNumber; this.amount = amount; } protected void findObjects(Bank prevalentSystem) throws Exception { bank = prevalentSystem; } protected void checkPrecondition() { } protected void createMementos(MementoCollector collector) { } protected Account execute(MementoCollector collector) throws Exception { MementoTransaction command = new Withdrawal(sourceNumber, amount); command.execute(collector, bank); command = new Deposit(destinationNumber, amount); command.execute(collector, bank); return null; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.demos.memento.commands; import org.prevayler.demos.memento.Account; import org.prevayler.demos.memento.Bank; import org.prevayler.util.memento.MementoCollector; import org.prevayler.util.memento.MementoTransaction; import javax.swing.*; import java.util.Date; public class Withdrawal extends MementoTransaction { private static final long serialVersionUID = -1938471248356260702L; private long accountNumber; private long amount;  private transient Account account; public Withdrawal(long accountNumber, long amount) { super(); this.accountNumber = accountNumber; this.amount = amount; } protected void findObjects(Bank prevalentSystem) throws Exception { if (JOptionPane.showConfirmDialog(null, \"Fail at Withdrawal::findObjects?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } account = prevalentSystem.findAccount(accountNumber); } protected void checkPrecondition() throws Exception { if (JOptionPane.showConfirmDialog(null, \"Fail at Withdrawal::checkPrecondition?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } if (account.balance() < amount) { throw account.new InvalidAmount(\"Can not withdraw more than the balance\"); } } protected void createMementos(MementoCollector collector) { if (JOptionPane.showConfirmDialog(null, \"Fail at Withdrawal::createMemento?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } account.createMemento(collector); } protected Account execute(MementoCollector collector) throws Exception { if (JOptionPane.showConfirmDialog(null, \"Fail at Withdrawal::execute?\", \"Prevayler with rollback\", JOptionPane.YES_NO_OPTION) == 0) { throw new RuntimeException(); } account.withdraw(amount, new Date()); "}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.foundation.serialization; import com.thoughtworks.xstream.XStream; import java.io.*; /** * Writes and reads objects using XML. This serializer can be used for snapshots, journals or both. * <p/> * <p>This implementation requires the <a href=\"http:"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.cluster; import java.io.Serializable; public interface ClusterListener<P extends Serializable> { Object getState(); void setState(P prevalentSystem); Object receive(ClusteredTransaction<P> transaction); }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.cluster; import java.io.File; import java.io.Serializable; import org.prevayler.Clock; import org.prevayler.Prevayler; import org.prevayler.PrevaylerFactory; import org.prevayler.Query; import org.prevayler.SureTransactionWithQuery; import org.prevayler.Transaction; import org.prevayler.TransactionWithQuery; public class ClusteredPrevayler<P extends Serializable> implements Prevayler<P>, ClusterListener<P> { private PrevaylerFactory<P> factory; private String oldPrevalenceBase; private String newPrevalenceBase; private Node<P> node; private Prevayler<P> prevayler; public ClusteredPrevayler(PrevaylerFactory<P> factory, String oldPrevalenceBase, String newPrevalenceBase) throws InterruptedException { System.out.println(\"EXPERIMENTAL CODE! Spike for implementing a clustered homogenous (i.e. without a master) Prevayler using JavaGroups\"); System.out.println(\"For example, the clock is *not* properly synchronized across the cluster\"); System.out.println(\"This code will be thrown away when the real implementation is created\"); System.out.println(\"Prevalence base: \" + oldPrevalenceBase + \" and \" + newPrevalenceBase); this.factory = factory; this.oldPrevalenceBase = oldPrevalenceBase; this.newPrevalenceBase = newPrevalenceBase; this.node = new Node<P>(this); } public Object receive(ClusteredTransaction<P> transaction) { return transaction.executeOn(this); } public P getState() { System.out.println(\"Distributing system \" + prevalentSystem()); return prevalentSystem(); } public void setState(P prevalentSystem) { if (prevalentSystem != null) { backupOldLocalTransactionLogs(); factory.configurePrevalentSystem(prevalentSystem); } try { factory.configurePrevalenceDirectory(newPrevalenceBase); prevayler = factory.create(); System.out.println(\"Setting new system \" + prevayler.prevalentSystem()); System.out.println(\"Taking snapshot\"); prevayler.takeSnapshot(); } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(e.toString()); } } public P prevalentSystem() { return prevayler.prevalentSystem(); } public Clock clock() { return prevayler.clock(); } public void execute(Transaction<? super P> transaction) { ClusteredTransaction<P> clusterTransaction = new ClusteredTransaction<P>(transaction, clock().time()); System.out.println(\"ClusterTransaction created = \" + clusterTransaction); node.broadcast(clusterTransaction); } public <R> R execute(Query<? super P, R> sensitiveQuery) throws Exception { return prevayler.execute(sensitiveQuery); } public <R> R execute(TransactionWithQuery<? super P, R> transactionWithQuery) throws Exception { throw new UnsupportedOperationException(\"Not implemented\"); } public <R> R execute(SureTransactionWithQuery<? super P, R> sureTransactionWithQuery) { throw new UnsupportedOperationException(\"Not implemented\"); } public File takeSnapshot() throws Exception { return prevayler.takeSnapshot(); } public void close() { node.shutdown(); } private void backupOldLocalTransactionLogs() { System.out.println(\"Moving away old local transaction logs\"); File oldPrevalenceBaseFile = new File(oldPrevalenceBase); File[] files = oldPrevalenceBaseFile.listFiles(); if (files != null) { for (int i = 0; i < files.length; i++) { files[i].delete(); } } oldPrevalenceBaseFile.delete(); new File(newPrevalenceBase).renameTo(oldPrevalenceBaseFile); } public void executeBroadcastedTransaction(Transaction<? super P> transaction) { prevayler.execute(transaction); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.cluster; import java.io.Serializable; import java.util.Date; class ClusteredPrevaylerState<P extends Serializable> implements Serializable { private static final long serialVersionUID = 5823210882529956138L; private P system; private Date time; public ClusteredPrevaylerState(P system, Date time) { this.system = system; this.time = time; } public P getSystem() { return system; } public Date getTime() { return time; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.cluster; import org.prevayler.Transaction; import org.prevayler.cluster.ClusteredPrevayler; import java.io.Serializable; import java.util.Date; class ClusteredTransaction<P extends Serializable> implements Serializable { private static final long serialVersionUID = -3346683075172200979L; private Transaction<? super P> transaction; @SuppressWarnings(\"unused\") private Date executionTime; public ClusteredTransaction(Transaction<? super P> transaction, Date executionTime) { this.transaction = transaction; this.executionTime = executionTime; } public Object executeOn(ClusteredPrevayler<P> prevayler) { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.cluster; import org.jgroups.*; import org.jgroups.blocks.*; import org.jgroups.util.Util; import org.prevayler.cluster.ClusterListener; import java.io.Serializable; import java.util.Vector; public class Node<P extends Serializable> implements RequestHandler, MessageListener, MembershipListener { private static final String LOCK_ID = \"BroadCastLock\"; private static final String MESSAGE_CHANNEL_PROPERTIES = \"UDP(mcast_addr=228.8.8.8;mcast_port=45566;ip_ttl=32;\" + \"mcast_send_buf_size=150000;mcast_recv_buf_size=80000):\" + \"PING(timeout=2000;num_initial_members=3):\" + \"MERGE2(min_interval=5000;max_interval=10000):\" + \"FD_SOCK:\" + \"VERIFY_SUSPECT(timeout=1500):\" + \"pbcast.NAKACK(gc_lag=50;retransmit_timeout=300,600,1200,2400,4800):\" + \"UNICAST(timeout=5000):\" + \"pbcast.STABLE(desired_avg_gossip=20000):\" + \"FRAG(frag_size=4096;down_thread=false;up_thread=false):\" + \"pbcast.GMS(join_timeout=5000;join_retry_timeout=2000;\" + \"shun=false;print_local_addr=true):\" + \"pbcast.STATE_TRANSFER\"; static final String LOCK_CHANNEL_PROPERTIES = \"\" + \"UDP(mcast_addr=228.3.11.76;mcast_port=12345;ip_ttl=1;\" + \"mcast_send_buf_size=150000;mcast_recv_buf_size=80000)\" + \":PING(timeout=500;num_initial_members=1)\" + \":FD\" + \":VERIFY_SUSPECT(timeout=1500)\" + \":pbcast.NAKACK(gc_lag=50;retransmit_timeout=300,600,1200,2400,4800)\" + \":UNICAST(timeout=5000)\" + \":pbcast.STABLE(desired_avg_gossip=200)\" + \":FRAG(frag_size=4096)\" + \":pbcast.GMS(join_timeout=5000;join_retry_timeout=1000;\" + \"shun=false;print_local_addr=false)\"; private JChannel channel; private JChannel lockChannel; private MessageDispatcher dispatcher; private ClusterListener<P> listener; @SuppressWarnings(\"deprecation\") private DistributedLockManager distributedLockManager; private static final Object broadcastLock = new Object(); public Node() { this(null); } @SuppressWarnings(\"deprecation\") public Node(ClusterListener<P> listener) { try { lockChannel = new JChannel(LOCK_CHANNEL_PROPERTIES); distributedLockManager = new DistributedLockManager(new VotingAdapter(lockChannel), String.valueOf(System.currentTimeMillis())); lockChannel.connect(Node.class.getName() + \"Lock\"); Thread.sleep(1000); this.listener = listener; channel = new JChannel(MESSAGE_CHANNEL_PROPERTIES); channel.setOpt(Channel.GET_STATE_EVENTS, new Boolean(true)); dispatcher = new MessageDispatcher(channel, this, this, this); channel.connect(Node.class.getName()); acquireClusterWideLock(); channel.getState(null, 0); Thread.sleep(1000); } catch (Exception e) { throw new RuntimeException(e.toString()); } } public void viewAccepted(View view) { System.out.println(\"Members \" + view.size()); } public void suspect(Address suspected_mbr) { } public void block() { } public void receive(Message msg) { } public byte[] getState() { System.out.println(\"Getting state\"); if (listener != null) { try { return Util.objectToByteBuffer(listener.getState()); } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(e.toString()); } } return null; } @SuppressWarnings(\"unchecked\") public void setState(byte[] state) { System.out.println(\"Setting state\"); try { if (listener != null) { listener.setState((P) Util.objectFromByteBuffer(state)); } } catch (Exception e) { throw new RuntimeException(e.toString()); } finally { try { "}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package org.prevayler.util; import org.prevayler.Prevayler;  public interface SnapshotListener<P> {  public void snapshotStarted(Prevayler<P> prevayler, long prevaylerDate, long systemDate);  public void snapshotTaken(Prevayler<P> prevayler, long prevaylerDate, long systemDate);  public void snapshotException(Prevayler<P> prevayler, Exception exception, long prevaylerDate, long systemDate);  public void snapshotError(Prevayler<P> prevayler, Error error, long prevaylerDate, long systemDate);  public void snapshotShutdown(Prevayler<P> prevayler, long prevaylerDate, long systemDate); }"}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": ""}
{"name": "prevayler/prevayler", "content": "package junkyard;  import org.prevayler.socketserver.transactions.RemoteTransaction; import java.beans.PropertyDescriptor; import java.util.Date;  public abstract class BeanSetter<P, R, X> extends RemoteTransaction<P, R> { private static final long serialVersionUID = 8234726127210608176L; "}
{"name": "prevayler/prevayler", "content": "package junkyard;  import org.prevayler.socketserver.example.server.Todo; import org.prevayler.socketserver.example.server.TodoList; import org.prevayler.socketserver.util.Log; import java.beans.IntrospectionException; import java.beans.Introspector;  public class TodoBeanSetter extends BeanSetter<TodoList, Object, Todo> { private static final long serialVersionUID = -6479002926400060349L; "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.client;   public class CallbackAlreadyFreedException extends Exception { private static final long serialVersionUID = -2556517764679074639L;  public CallbackAlreadyFreedException(String string) { super(string); } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.client; class CallbackNode { public CallbackNode(String m, IModelCallback c) { message = m; callback = c; freed = false; } public String message; public IModelCallback callback; public boolean freed; }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.client;  import org.prevayler.socketserver.util.Log; import java.io.EOFException; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.net.Socket; import java.net.SocketException; import java.util.Iterator; import java.util.LinkedList;  public class CallbackThread extends Thread { private Socket socket; private LinkedList<CallbackNode> callbacks = new LinkedList<CallbackNode>();  public CallbackThread(String host, int port, Long connectionID) throws IOException { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.client;   public interface IModelCallback {  public abstract void happened(Long connectionID, String name, Object obj); }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.client;  import org.prevayler.Transaction; import org.prevayler.socketserver.server.RegisterCallback; import org.prevayler.socketserver.server.UnregisterCallback; import org.prevayler.socketserver.transactions.Disconnect; import org.prevayler.socketserver.transactions.ThrownException; import org.prevayler.socketserver.util.Log; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.net.Socket;  public class Remote<P> {  private static Remote<?> conn = null; @SuppressWarnings(\"unchecked\") public static <P> Remote<P> getConnection() { return (Remote<P>) conn; } public static void setConnection(Remote<?> conn) { Remote.conn = conn; }  public static void connect(String host, int port) throws IOException, ClassNotFoundException { conn = new Remote<Object>(host, port); } "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.example.client;  import org.prevayler.socketserver.util.Config; import java.util.Properties;  public class ClientConfig extends Config {  public String getConfigHeader() { return \"Todo client config\"; }  public Properties getDefaultProps() { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.example.client;  import org.prevayler.socketserver.client.IModelCallback; import org.prevayler.socketserver.client.Remote; import org.prevayler.socketserver.example.server.Todo; import org.prevayler.socketserver.example.server.TodoList; import org.prevayler.socketserver.example.transactions.CreateTodoBean; import org.prevayler.socketserver.example.transactions.ListTodos; import org.prevayler.socketserver.util.Config; import org.prevayler.socketserver.util.Log;  public class Main { public static synchronized void printList(Object todoList) { TodoList theList = (TodoList) todoList; Todo[] items = theList.toArray(); for (int i = 0; i < items.length; i++) { System.out.println(items[i].getId() + \"\\t\" + items[i].getDesc()); } System.out.println(); } private static char[] responses = {'A', 'E', 'L'}; private static char toUpperCase(char ch) { String result = \"\"; result += ch; result = result.toUpperCase(); return result.toCharArray()[0]; } private static boolean invalidResponse(char response) { boolean responseIsInvalid = true; for (int i = 0; i < responses.length && responseIsInvalid; i++) { if (responses[i] == response) { responseIsInvalid = false; } } return responseIsInvalid; } public static void printMenu() { System.out.println(\"L)ist todos; A)dd todo; E)xit\"); } public static void addTodo() { System.out.println(\"Please enter the todo item and press enter\"); String response = \"\"; try { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.example.server;  import java.io.Serializable;  public class Todo implements Serializable { private static final long serialVersionUID = 267470802978245143L; public Todo(int id) { this.id = id; desc = \"\"; } private int id;  public int getId() { return id; } private String desc;  public String getDesc() { return desc; }  public void setDesc(String desc) { this.desc = desc; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.example.server;  import java.io.Serializable; import java.util.Iterator; import java.util.TreeMap;  public class TodoList implements Serializable { private static final long serialVersionUID = 611510576162358132L; private TreeMap<Integer, Todo> todoList; private int nextID = 0; public TodoList() { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.example.transactions;  import org.prevayler.socketserver.example.server.Todo; import org.prevayler.socketserver.example.server.TodoList; import org.prevayler.socketserver.server.Notification; import org.prevayler.socketserver.transactions.RemoteTransaction; import java.util.Date;  public class CreateTodoBean extends RemoteTransaction<TodoList, Todo> { private static final long serialVersionUID = 5842396313023406292L; private String desc; public CreateTodoBean(String desc) { this.desc = desc; }  public Todo executeAndQuery(TodoList todoList, Date timestamp) throws Exception { Todo todo = todoList.newTodo(); todo.setDesc(desc); "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.example.transactions; import org.prevayler.socketserver.example.server.TodoList;  import org.prevayler.socketserver.transactions.RemoteTransaction; import java.util.Date;  public class ListTodos extends RemoteTransaction<TodoList, TodoList> { private static final long serialVersionUID = 6704075381825894559L;  public TodoList executeAndQuery(TodoList todoList, Date timestamp) throws Exception { return todoList; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import org.prevayler.Prevayler; import org.prevayler.TransactionWithQuery; import org.prevayler.socketserver.transactions.*; import org.prevayler.socketserver.transactions.IRemoteTransaction; import org.prevayler.socketserver.transactions.ThrownException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.net.Socket;  public class CommandThread<P> extends Thread { private Prevayler<P> prevayler; private Socket socket; private long myId;  public CommandThread(Prevayler<P> p, Socket s) { prevayler = p; socket = s; myId = Reaper.registerCommandThread(); }  private void handleRequests() throws Exception { boolean done = false; ObjectOutputStream o = null; ObjectInputStream i = null; "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import org.prevayler.Prevayler; import org.prevayler.PrevaylerFactory; import org.prevayler.socketserver.util.Log; import java.io.IOException; import java.net.ServerSocket;  public class Main { private static SnapshotThread<Object> snapshotThread; private static Prevayler<Object> prevayler; private static int port; "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import org.prevayler.socketserver.util.Log; import java.io.IOException; import java.net.ServerSocket; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map;  public class Notification extends Thread { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.net.Socket; import java.util.LinkedList; import java.util.List; import java.util.NoSuchElementException;  public class NotificationThread extends Thread { private Socket socket;  private Long id;  public Long getSocketId() { return id; }  public NotificationThread(Socket s) throws IOException, ClassNotFoundException { socket = s; ObjectInputStream in = new ObjectInputStream(socket.getInputStream()); id = (Long) in.readObject(); Reaper.registerNotificationThread(id, this); }  private List<Message> messageQueue = new LinkedList<Message>();  private class Message { public Message(Long senderId, String m, Object o) { this.senderId = senderId; message = m; obj = o; } public Long senderId; public String message; public Object obj; }  public synchronized void submit(Long senderId, String message, Object obj) { messageQueue.add(new Message(senderId, message, obj)); notifyAll(); }  private synchronized Message getMessage() { Message result; try { result = messageQueue.get(0); messageQueue.remove(0); } catch (NoSuchElementException e) { result = null; } return result; }  private synchronized void checkWait() throws Exception { if (messageQueue.isEmpty()) wait(); }  private void handleNotifications() throws Exception { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import java.util.HashMap; import java.util.Map;  public class Reaper { private static long id = 0; "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import java.io.Serializable;  public class RegisterCallback implements Serializable { private static final long serialVersionUID = 8519310803288063140L; public RegisterCallback(String m) { message = m; } public String message; }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import java.io.Serializable;  public class SerializableException extends Exception implements Serializable { private static final long serialVersionUID = 3828738999566221855L; }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import org.prevayler.socketserver.util.Config; import java.util.Properties;  public class ServerConfig extends Config {  public String getConfigHeader() { return \"Prevayler Server Config\"; }  public Properties getDefaultProps() { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import org.prevayler.Prevayler; import org.prevayler.socketserver.util.Log;  public class SnapshotThread<P> extends Thread { private Prevayler<P> prevayler; public SnapshotThread(Prevayler<P> persistenceEngine) { prevayler = persistenceEngine; }  public void run() { super.run(); Log.message(\"A system snapshot will be taken every 24h...\"); try { while (true) { Thread.sleep(1000 * 60 * 60 * 24); prevayler.takeSnapshot(); Log.message(\"Snapshot taken at \" + new java.util.Date() + \"...\"); } } catch (InterruptedException e) { Log.message(\"Snapshot thread interrupted; thread shutting down\"); } catch (Exception e) { Log.error(e, \"Fatal exception while taking snapshot\"); System.exit(1); } } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.server;  import java.io.Serializable;  public class UnregisterCallback implements Serializable { private static final long serialVersionUID = 6229582897207453812L; public UnregisterCallback(String m) { message = m; } public String message; }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.transactions;  import java.io.Serializable;  public class Disconnect implements Serializable { private static final long serialVersionUID = -1741757559289156466L; }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.transactions;   public interface IRemoteTransaction {  public void setSenderID(Long connectionID); }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.transactions;  import org.prevayler.Transaction; import org.prevayler.TransactionWithQuery; import java.util.Date;  public abstract class RemoteTransaction<P, R> implements Transaction<P>, TransactionWithQuery<P, R>, IRemoteTransaction { private static final long serialVersionUID = 6981598749107991872L; protected Long senderID;  public void setSenderID(Long connectionID) { this.senderID = connectionID; } public abstract R executeAndQuery(P prevalentSystem, Date timestamp) throws Exception; public void executeOn(P prevalentSystem, Date timestamp) { try { executeAndQuery(prevalentSystem, timestamp); } catch (Exception e) { } } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.transactions;  import java.io.Serializable;  public class ThrownException implements Serializable { private static final long serialVersionUID = -8906416107416314814L; public Exception exception; public ThrownException(Exception e) { exception = e; } }"}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.util;  import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.Properties;  public abstract class Config {  public Config() { init(); }  public Config(String propertyFile) { Config.propertyFile = propertyFile; init(); } private void init() { "}
{"name": "prevayler/prevayler", "content": "package org.prevayler.socketserver.util;   public class Log {  public static void error(Exception e, String message) { System.err.println(message); e.printStackTrace(); }  public static void message(String message) { System.out.println(message); }  public static void debug(String message) { System.out.println(message); } }"}
{"name": "macournoyer/min", "content": "package min; import jline.ConsoleReader; import min.lang.*; import java.io.IOException;  public class Min {  public static boolean debug = false; public static void main(String[] args) throws Exception { String code = null; String file = \"<eval>\"; Boolean launchREPL = false;  for (int i = 0; i < args.length; i++) { if (args[i].equals(\"-e\")) code = args[++i]; else if (args[i].equals(\"-d\")) debug = true; else if (args[i].equals(\"-h\")) usage(); else if (args[i].equals(\"--help\")) usage(); else if (args[i].equals(\"-x\")) launchREPL = true; else code = File.read(file = args[i]); }  new Bootstrap().run(); if(launchREPL) repl(); if (code == null) usage();  Message message = Message.parse(code, file); if (debug) System.out.println(message.fullName()); message.evalOn(MinObject.lobby); }  private static void usage() { System.out.println(\"usage: min [-d] < -e code | file.min >\"); System.out.println(\" -x REPL (experimental)\"); System.exit(1); } private static void repl() throws MinException, IOException { "}
{"name": "macournoyer/min", "content": "package min.lang; import java.util.ArrayList; import java.util.Properties; import java.io.InputStream; import java.io.IOException; public class Bootstrap { public void run() throws MinException { "}
{"name": "macournoyer/min", "content": "package min.lang; import java.util.ArrayList; public class Call extends MinObject { "}
{"name": "macournoyer/min", "content": "package min.lang; import java.io.IOException; import java.io.File; public class Dir extends MinObject { static public String current() throws MinException { try { return new File(\".\").getCanonicalPath(); } catch (IOException e) { throw new MinException(e); } } }"}
{"name": "macournoyer/min", "content": "package min.lang; import java.io.IOException; import java.io.FileInputStream; import java.nio.channels.FileChannel; import java.nio.MappedByteBuffer; public class File extends MinObject { "}
{"name": "macournoyer/min", "content": "package min.lang; "}
{"name": "macournoyer/min", "content": "package min.lang; public class Method extends MinObject { private Message message; private String[] argNames; public Method() { super(MinObject.method); } public Method(Call call) { this(); message = call.message.args.get(call.message.args.size() - 1); int nArgs = call.message.args.size() - 1; argNames = new String[nArgs]; for (int i = 0; i < nArgs; i++) argNames[i] = call.message.args.get(i).name; } public MinObject activate(Call call) throws MinException { return message.evalOn(makeContext(call)); } public MinObject callOn(MinObject on) throws MinException { return activate(new Call(on)); } private MinObject makeContext(Call call) throws MinException { MinObject context = call.receiver.clone(); context.asKind(\"MethodContext\"). slot(\"self\", call.receiver). slot(\"@\", call.receiver). slot(\"call\", call). slot(\"context\", context); for (int i = 0; i < argNames.length; i++) context.setSlot(argNames[i], call.evalArg(i)); return context; } }"}
{"name": "macournoyer/min", "content": "package min.lang; @SuppressWarnings(\"serial\") public class MinException extends Exception { public MinException(String message) { super(message); } public MinException(Throwable cause) { super(cause); } public MinException(String message, Throwable cause) { super(message, cause); } }"}
{"name": "macournoyer/min", "content": "package min.lang; import java.util.Collections; import java.util.HashMap; import java.util.ArrayList;  public class MinObject { static public MinObject base; static public MinObject lobby; static public MinObject object; static public MinObject call; static public MinObject message; static public MinObject method; static public MinObject string; static public MinObject number; static public MinObject array; static public MinObject nil; static public MinObject _true; static public MinObject _false; final ArrayList<MinObject> protos; private final HashMap<String, MinObject> slots; Object data; public MinObject(MinObject proto, Object data) { protos = new ArrayList<MinObject>(); if (proto != null) protos.add(proto); slots = new HashMap<String, MinObject>(); this.data = data; } public MinObject(MinObject proto) { this(proto, null); } public MinObject() { this(null, null); } public void appendProto(MinObject proto) { protos.add(proto); } public void prependProto(MinObject proto) { protos.add(0, proto); } public MinObject setSlot(String name, MinObject value) { "}
{"name": "macournoyer/min", "content": "package min.lang; import java.util.HashMap; public class Operator { final int precedence; private final int arity; private final boolean rightToLeft; static final HashMap<String, Operator> table = new HashMap<String, Operator>(); static final Operator nullOperator = new Operator(null, 0, 0, false); "}
{"name": "macournoyer/min", "content": "package min.lang; @SuppressWarnings(\"serial\") public class ParsingException extends MinException { public ParsingException(String message) { super(message); } public ParsingException(String message, String file, int line) { super(String.format(\"%s in %s:%d\", message, file, line)); } }"}
{"name": "macournoyer/min", "content": ""}
{"name": "macournoyer/min", "content": "package min.lang; import java.util.ArrayList; import java.util.LinkedList; /* The fancy message shuffler. * Based on the Shunting yard algorithm * see : http:"}
{"name": "macournoyer/min", "content": "package min.lang; @SuppressWarnings(\"serial\") public class SlotNotFound extends MinException { public SlotNotFound(String message) { super(message); } }"}
{"name": "sethm/symon", "content": "package com.loomcom.symon; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.util.Utils; import javax.swing.table.AbstractTableModel; import java.util.ArrayList; import java.util.TreeSet; public class Breakpoints extends AbstractTableModel { private TreeSet<Integer> breakpoints; private Simulator simulator; public Breakpoints(Simulator simulator) { this.breakpoints = new TreeSet<>(); this.simulator = simulator; } public boolean contains(int address) { return this.breakpoints.contains(address); } public void addBreakpoint(int address) { this.breakpoints .add(address); fireTableDataChanged(); } public void removeBreakpoint(int address) { this.breakpoints.remove(address); fireTableDataChanged(); } public void removeBreakpointAtIndex(int index) { if (index < 0) { return; } ArrayList<Integer> values = new ArrayList<>(breakpoints); int value = values.get(index); this.breakpoints.remove(value); fireTableDataChanged(); } public void refresh() { fireTableDataChanged(); } @Override public String getColumnName(int index) { if (index == 0) { return \"Address\"; } else { return \"Inst\"; } } @Override public int getRowCount() { return breakpoints.size(); } @Override public int getColumnCount() { return 2; } @Override public Object getValueAt(int rowIndex, int columnIndex) { ArrayList<Integer> values = new ArrayList<>(breakpoints); if (columnIndex == 0) { return \"$\" + Utils.wordToHex(values.get(rowIndex)); } else if (columnIndex == 1) { int address = values.get(rowIndex); try { return simulator.disassembleOpAtAddress(address); } catch (MemoryAccessException ex) { return \"???\"; } } else { return null; } } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon; import com.loomcom.symon.devices.Device; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.exceptions.MemoryRangeException; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.HashMap; import java.util.Map; import java.util.SortedSet; import java.util.TreeSet;  public class Bus { "}
{"name": "sethm/symon", "content": " package com.loomcom.symon; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.util.Utils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class Cpu implements InstructionTable { private final static Logger logger = LoggerFactory.getLogger(Cpu.class.getName());  public static final int P_CARRY = 0x01; public static final int P_ZERO = 0x02; public static final int P_IRQ_DISABLE = 0x04; public static final int P_DECIMAL = 0x08; public static final int P_BREAK = 0x10; "}
{"name": "sethm/symon", "content": "package com.loomcom.symon; import com.loomcom.symon.util.Utils;  public class CpuState {  public int a;  public int x;  public int y;  public int sp;  public int pc;  public int ir;  public int nextIr; public int[] args = new int[2]; public int[] nextArgs = new int[2]; public int instSize; public boolean opTrap; public boolean irqAsserted; public boolean nmiAsserted; public int lastPc;  public boolean carryFlag; public boolean negativeFlag; public boolean zeroFlag; public boolean irqDisableFlag; public boolean decimalModeFlag; public boolean breakFlag; public boolean overflowFlag; public long stepCounter = 0L; public CpuState() {}  @SuppressWarnings(\"CopyConstructorMissesField\") public CpuState(CpuState s) { this.a = s.a; this.x = s.x; this.y = s.y; this.sp = s.sp; this.pc = s.pc; this.ir = s.ir; this.nextIr = s.nextIr; this.lastPc = s.lastPc; this.args[0] = s.args[0]; this.args[1] = s.args[1]; this.nextArgs[0] = s.nextArgs[0]; this.nextArgs[1] = s.nextArgs[1]; this.instSize = s.instSize; this.opTrap = s.opTrap; this.nmiAsserted = s.nmiAsserted; this.irqAsserted = s.irqAsserted; this.carryFlag = s.carryFlag; this.negativeFlag = s.negativeFlag; this.zeroFlag = s.zeroFlag; this.irqDisableFlag = s.irqDisableFlag; this.decimalModeFlag = s.decimalModeFlag; this.breakFlag = s.breakFlag; this.overflowFlag = s.overflowFlag; this.stepCounter = s.stepCounter; }  public String toTraceEvent() { String opcode = Cpu.disassembleOp(ir, args); return getInstructionByteStatus() + \" \" + String.format(\"%-14s\", opcode) + \"A:\" + Utils.byteToHex(a) + \" \" + \"X:\" + Utils.byteToHex(x) + \" \" + \"Y:\" + Utils.byteToHex(y) + \" \" + \"F:\" + Utils.byteToHex(getStatusFlag()) + \" \" + \"S:1\" + Utils.byteToHex(sp) + \" \" + getProcessorStatusString() + \"\\n\"; }  public int getStatusFlag() { int status = 0x20; if (carryFlag) { status |= Cpu.P_CARRY; } if (zeroFlag) { status |= Cpu.P_ZERO; } if (irqDisableFlag) { status |= Cpu.P_IRQ_DISABLE; } if (decimalModeFlag) { status |= Cpu.P_DECIMAL; } if (breakFlag) { status |= Cpu.P_BREAK; } if (overflowFlag) { status |= Cpu.P_OVERFLOW; } if (negativeFlag) { status |= Cpu.P_NEGATIVE; } return status; } public String getInstructionByteStatus() { switch (Cpu.instructionSizes[ir]) { case 0: case 1: return Utils.wordToHex(lastPc) + \" \" + Utils.byteToHex(ir) + \" \"; case 2: return Utils.wordToHex(lastPc) + \" \" + Utils.byteToHex(ir) + \" \" + Utils.byteToHex(args[0]) + \" \"; case 3: return Utils.wordToHex(lastPc) + \" \" + Utils.byteToHex(ir) + \" \" + Utils.byteToHex(args[0]) + \" \" + Utils.byteToHex(args[1]); default: return null; } }  public String getProcessorStatusString() { return \"[\" + (negativeFlag ? 'N' : '.') + (overflowFlag ? 'V' : '.') + \"-\" + (breakFlag ? 'B' : '.') + (decimalModeFlag ? 'D' : '.') + (irqDisableFlag ? 'I' : '.') + (zeroFlag ? 'Z' : '.') + (carryFlag ? 'C' : '.') + \"]\"; } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon; public interface InstructionTable {  enum CpuBehavior {  NMOS_WITH_ROR_BUG,  NMOS_6502,  CMOS_6502,  CMOS_65816 }  enum Mode { ACC { public String toString() { return \"Accumulator\"; } }, AIX { public String toString() { return \"Absolute, X-Indexed Indirect\"; } }, ABS { public String toString() { return \"Absolute\"; } }, ABX { public String toString() { return \"Absolute, X-indexed\"; } }, ABY { public String toString() { return \"Absolute, Y-indexed\"; } }, IMM { public String toString() { return \"Immediate\"; } }, IMP { public String toString() { return \"Implied\"; } }, IND { public String toString() { return \"Indirect\"; } }, XIN { public String toString() { return \"X-indexed Indirect\"; } }, INY { public String toString() { return \"Indirect, Y-indexed\"; } }, REL { public String toString() { return \"Relative\"; } }, ZPG { public String toString() { return \"Zero Page\"; } }, ZPR { public String toString() { return \"Zero Page, Relative\"; } }, ZPX { public String toString() { return \"Zero Page, X-indexed\"; } }, ZPY { public String toString() { return \"Zero Page, Y-indexed\"; } }, ZPI { public String toString() { return \"Zero Page Indirect\"; } }, NUL { public String toString() { return \"NULL\"; } } } "}
{"name": "sethm/symon", "content": " package com.loomcom.symon; import com.loomcom.symon.machines.MulticompMachine; import com.loomcom.symon.machines.SimpleMachine; import com.loomcom.symon.machines.SymonMachine; import com.loomcom.symon.machines.BenEaterMachine; import org.apache.commons.cli.*; import java.util.Locale; import javax.swing.JOptionPane; import javax.swing.SwingUtilities; import javax.swing.UIManager; public class Main {  public static void main(String[] args) throws Exception { Class machineClass = SymonMachine.class; Options options = new Options(); options.addOption(new Option(\"m\", \"machine\", true, \"Specify machine type.\")); options.addOption(new Option(\"c\", \"cpu\", true, \"Specify CPU type.\")); options.addOption(new Option(\"r\", \"rom\", true, \"Specify ROM file.\")); options.addOption(new Option(\"b\", \"brk\", false, \"Halt on BRK\")); CommandLineParser parser = new DefaultParser(); try { CommandLine line = parser.parse(options, args); InstructionTable.CpuBehavior cpuBehavior = null; String romFile = null; boolean haltOnBreak = false; if (line.hasOption(\"machine\")) { String machine = line.getOptionValue(\"machine\").toLowerCase(Locale.ENGLISH); switch (machine) { case \"multicomp\": machineClass = MulticompMachine.class; break; case \"simple\": machineClass = SimpleMachine.class; break; case \"symon\": machineClass = SymonMachine.class; break; case \"beneater\": machineClass = BenEaterMachine.class; break; default: System.err.println(\"Could not start Symon. Unknown machine type \" + machine); return; } } if (line.hasOption(\"cpu\")) { String cpu = line.getOptionValue(\"cpu\").toLowerCase(Locale.ENGLISH); switch (cpu) { case \"6502\": cpuBehavior = InstructionTable.CpuBehavior.NMOS_6502; break; case \"65c02\": cpuBehavior = InstructionTable.CpuBehavior.CMOS_6502; break; case \"65c816\": cpuBehavior = InstructionTable.CpuBehavior.CMOS_65816; break; default: System.err.println(\"Could not start Symon. Unknown cpu type \" + cpu); return; } } if (line.hasOption(\"rom\")) { romFile = line.getOptionValue(\"rom\"); } if (line.hasOption(\"brk\")) { haltOnBreak = true; } while (true) { if (machineClass == null) { Object[] possibilities = {\"Symon\", \"Multicomp\", \"Simple\", \"BenEater\"}; String s = (String)JOptionPane.showInputDialog( null, \"Please choose the machine type to be emulated:\", \"Machine selection\", JOptionPane.PLAIN_MESSAGE, null, possibilities, \"Symon\"); if (s != null && s.equals(\"Multicomp\")) { machineClass = MulticompMachine.class; } else if (s != null && s.equals(\"Simple\")) { machineClass = SimpleMachine.class; } else if (s != null && s.equals(\"BenEater\")) { machineClass = BenEaterMachine.class; } else { machineClass = SymonMachine.class; } } if (cpuBehavior == null) { cpuBehavior = InstructionTable.CpuBehavior.NMOS_6502; } final Simulator simulator = new Simulator(machineClass, cpuBehavior, romFile, haltOnBreak); SwingUtilities.invokeLater(new Runnable() { @Override public void run() { try { UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon; import com.loomcom.symon.exceptions.*;  public class MemoryRange implements Comparable<MemoryRange> {  public int startAddress;  public int endAddress; public MemoryRange(int startAddress, int endAddress) throws MemoryRangeException { if (startAddress < 0 || endAddress < 0) { throw new MemoryRangeException(\"Addresses cannot be less than 0.\"); } if (startAddress >= endAddress) { throw new MemoryRangeException(\"End address must be greater \" + \"than start address.\"); } this.startAddress = startAddress; this.endAddress = endAddress; }  public int startAddress() { return startAddress; }  public int endAddress() { return endAddress; }  public boolean includes(int address) { return (address <= endAddress && address >= startAddress); }  public boolean overlaps(MemoryRange other) { return (this.includes(other.startAddress()) || other.includes(this.startAddress())); } "}
{"name": "sethm/symon", "content": " package com.loomcom.symon; import javax.swing.*; public interface Preferences { int DEFAULT_PROGRAM_LOAD_ADDRESS = 0x0300; JDialog getDialog(); int getProgramStartAddress(); boolean getHaltOnBreak(); void updateUi(); }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon; import com.loomcom.symon.devices.Memory; import com.loomcom.symon.exceptions.*; import com.loomcom.symon.machines.Machine; import com.loomcom.symon.ui.*; import com.loomcom.symon.ui.Console; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.management.monitor.CounterMonitor; import javax.swing.*; import javax.swing.border.EmptyBorder; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.SortedSet; import java.util.TreeSet;  public class Simulator { private final static Logger logger = LoggerFactory.getLogger(Simulator.class.getName()); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.exceptions.MemoryRangeException;  public abstract class Acia extends Device { private String name;  int baseAddress; boolean receiveIrqEnabled = false; boolean transmitIrqEnabled = false; boolean overrun = false; boolean interrupt = false; long lastTxWrite = 0; long lastRxRead = 0; int baudRate = 0; long baudRateDelay = 0;  int rxChar = 0; int txChar = 0; boolean rxFull = false; boolean txEmpty = true; public Acia(int address, int size, String name) throws MemoryRangeException { super(address, address + size - 1, name); this.name = name; this.baseAddress = address; }  private long calculateBaudRateDelay() { if (baudRate > 0) { "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.exceptions.MemoryRangeException;  public class Acia6551 extends Acia { public static final int ACIA_SIZE = 4; static final int DATA_REG = 0; static final int STAT_REG = 1; static final int CMND_REG = 2; static final int CTRL_REG = 3;  private int commandRegister; private int controlRegister; public Acia6551(int address) throws MemoryRangeException { super(address, ACIA_SIZE, \"ACIA\"); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.exceptions.MemoryRangeException;  public class Acia6850 extends Acia { public static final int ACIA_SIZE = 2; static final int STAT_REG = 0; "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.exceptions.MemoryRangeException; import java.io.IOException;  public class Crtc extends Device { "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.Bus; import com.loomcom.symon.MemoryRange; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.exceptions.MemoryRangeException; import java.util.HashSet; import java.util.Set;  public abstract class Device implements Comparable<Device> {  int size;  private MemoryRange memoryRange;  private String name;  private Bus bus;  private Set<DeviceChangeListener> deviceChangeListeners; public Device(int startAddress, int endAddress, String name) throws MemoryRangeException { this.memoryRange = new MemoryRange(startAddress, endAddress); this.size = endAddress - startAddress + 1; this.name = name; this.deviceChangeListeners = new HashSet<>(); }  public abstract void write(int address, int data) throws MemoryAccessException; public abstract int read(int address, boolean cpuAccess) throws MemoryAccessException; public abstract String toString(); public Bus getBus() { return this.bus; } public void setBus(Bus bus) { this.bus = bus; } public MemoryRange getMemoryRange() { return memoryRange; } public int endAddress() { return memoryRange.endAddress(); } @SuppressWarnings(\"unused\") public int startAddress() { return memoryRange.startAddress(); } public String getName() { return name; } @SuppressWarnings(\"unused\") public void setName(String name) { this.name = name; } public int getSize() { return size; } public void registerListener(DeviceChangeListener listener) { deviceChangeListeners.add(listener); } public void notifyListeners() { for (DeviceChangeListener listener : deviceChangeListeners) { listener.deviceStateChanged(); } }  public int compareTo(Device other) { if (other == null) { throw new NullPointerException(\"Cannot compare to null.\"); } if (this == other) { return 0; } return getMemoryRange().compareTo(other.getMemoryRange()); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; public interface DeviceChangeListener { void deviceStateChanged(); }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import java.io.*; import java.util.*; import com.loomcom.symon.exceptions.*; public class Memory extends Device { private boolean readOnly; private int[] mem;  private static final int DEFAULT_FILL = 0x00; public Memory(int startAddress, int endAddress, boolean readOnly) throws MemoryRangeException { super(startAddress, endAddress, (readOnly ? \"RO Memory\" : \"RW Memory\")); this.readOnly = readOnly; this.mem = new int[this.size]; this.fill(DEFAULT_FILL); } public Memory(int startAddress, int endAddress) throws MemoryRangeException { this(startAddress, endAddress, false); } public static Memory makeROM(int startAddress, int endAddress, File f) throws MemoryRangeException, IOException { Memory memory = new Memory(startAddress, endAddress, true); memory.loadFromFile(f); return memory; } public static Memory makeRAM(int startAddress, int endAddress) throws MemoryRangeException { return new Memory(startAddress, endAddress, false); } public void write(int address, int data) throws MemoryAccessException { if (readOnly) { throw new MemoryAccessException(\"Cannot write to read-only memory at address \" + address); } else { this.mem[address] = data; } }  public void loadFromFile(File file) throws MemoryRangeException, IOException { if (file.canRead()) { long fileSize = file.length(); if (fileSize > mem.length) { throw new MemoryRangeException(\"File will not fit in available memory.\"); } else { int i = 0; FileInputStream fis = new FileInputStream(file); BufferedInputStream bis = new BufferedInputStream(fis); DataInputStream dis = new DataInputStream(bis); while (dis.available() != 0) { mem[i++] = dis.readUnsignedByte(); } } } else { throw new IOException(\"Cannot open file \" + file); } } public int read(int address, boolean cpuAccess) throws MemoryAccessException { return this.mem[address]; } public void fill(int val) { Arrays.fill(this.mem, val); } public String toString() { return \"Memory: \" + getMemoryRange().toString(); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.exceptions.MemoryRangeException; public abstract class Pia extends Device { private final String name; public Pia(int startAddress, int endAddress, String name) throws MemoryRangeException { super(startAddress, endAddress, name); this.name = name; } @Override public String toString() { return name; } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.exceptions.MemoryRangeException; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.RandomAccessFile; import java.util.logging.Level; import java.util.logging.Logger;  public class SdController extends Device { private enum Status { IDLE, READ, WRITE } public static final int CONTROLLER_SIZE = 8; private final int SECTOR_SIZE = 512; private final static Logger logger = Logger.getLogger(SdController.class.getName()); private File sdImageFile; private int lba0, lba1, lba2; private int position; private Status status = Status.IDLE; private final byte[] readBuffer = new byte[SECTOR_SIZE]; private final byte[] writeBuffer = new byte[SECTOR_SIZE]; private int readPosition = 0; private int writePosition = 0; public SdController(int address) throws MemoryRangeException { super(address, address + CONTROLLER_SIZE - 1, \"SDCONTROLLER\"); sdImageFile = new File(\"sd.img\"); if (!sdImageFile.exists()) { sdImageFile = null; logger.log(Level.INFO, \"Could not find SD card image 'sd.img'\"); } } @Override public void write(int address, int data) throws MemoryAccessException { switch (address) { case 0: writeData(data); return; case 1: writeCommand(data); return; case 2: this.lba0 = data; return; case 3: this.lba1 = data; return; case 4: this.lba2 = data; } } @Override public int read(int address, boolean cpuAccess) throws MemoryAccessException { switch (address) { case 0: return readData(); case 1: return readStatus(); default: return 0; } } private void computePosition() { this.position = lba0 + (lba1 << 8) + (lba2 << 16); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.devices; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.exceptions.MemoryRangeException;  public class Via6522 extends Pia { public static final int VIA_SIZE = 16; enum Register { ORB, ORA, DDRB, DDRA, T1C_L, T1C_H, T1L_L, T1L_H, T2C_L, T2C_H, SR, ACR, PCR, IFR, IER, ORA_H } public Via6522(int address) throws MemoryRangeException { super(address, address + VIA_SIZE - 1, \"MOS 6522 VIA\"); } @Override public void write(int address, int data) throws MemoryAccessException { Register[] registers = Register.values(); if (address >= registers.length) { throw new MemoryAccessException(\"Unknown register: \" + address); } Register r = registers[address]; switch (r) { case ORA: case ORB: case DDRA: case DDRB: case T1C_L: case T1C_H: case T1L_L: case T1L_H: case T2C_L: case T2C_H: case SR: case ACR: case PCR: case IFR: case IER: case ORA_H: default: } } @Override public int read(int address, boolean cpuAccess) throws MemoryAccessException { Register[] registers = Register.values(); if (address >= registers.length) { throw new MemoryAccessException(\"Unknown register: \" + address); } Register r = registers[address]; switch (r) { case ORA: case ORB: case DDRA: case DDRB: case T1C_L: case T1C_H: case T1L_L: case T1L_H: case T2C_L: case T2C_H: case SR: case ACR: case PCR: case IFR: case IER: case ORA_H: default: } return 0; } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.exceptions;  public class FifoUnderrunException extends SymonException { public FifoUnderrunException(String msg) { super(msg); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.exceptions;  public class MemoryAccessException extends SymonException { public MemoryAccessException(String msg) { super(msg); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.exceptions;  public class MemoryRangeException extends SymonException { public MemoryRangeException(String msg) { super(msg); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.exceptions;  public class SymonException extends Exception { public SymonException(String msg) { super(msg); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal;  public abstract class AbstractTerminalModel implements TerminalModel { @Override public void clear() { int rows = getRows(), columns = getColumns(); for (int column = 0; column < columns; column++) { for (int row = 0; row < rows; row++) { setCell(column, row, null); } } } @Override public void moveCursorBack(int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be positive\"); } int cursorColumn = getCursorColumn() - n; if (cursorColumn < 0) { cursorColumn = 0; } setCursorColumn(cursorColumn); } @Override public void moveCursorForward(int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be positive\"); } int columns = getColumns(); int cursorColumn = getCursorColumn() + n; if (cursorColumn >= columns) { cursorColumn = columns - 1; } setCursorColumn(cursorColumn); } @Override public void moveCursorDown(int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be positive\"); } int bufferSize = getBufferSize(); int cursorRow = getCursorRow() + n; if (cursorRow >= bufferSize) { cursorRow = bufferSize - 1; } setCursorRow(cursorRow); } @Override public void moveCursorUp(int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be positive\"); } int cursorRow = getCursorRow() - n; if (cursorRow < 0) { cursorRow = 0; } setCursorRow(cursorRow); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal; import com.loomcom.symon.jterminal.vt100.Vt100TerminalModel; import java.awt.BorderLayout; import java.awt.Dimension; import java.awt.Font; import java.awt.FontMetrics; import java.awt.Graphics; import java.awt.event.AdjustmentEvent; import java.awt.event.AdjustmentListener; import javax.swing.JComponent; import javax.swing.JScrollBar;  public class JTerminal extends JComponent { private static final long serialVersionUID = 2871625194146986567L; private int borderWidth = 0; private JScrollBar scrollBar;  private TerminalModel model;  private Font font;  private int cellWidth;  private int cellHeight;  private int maxDescender; public JTerminal(Font font) { this(new Vt100TerminalModel(), font); } public JTerminal(TerminalModel model, Font font) { setModel(model); setFont(font); init(); } public void setBorderWidth(int borderWidth) { this.borderWidth = borderWidth; revalidate(); } public int getBorderWidth() { return borderWidth; } public void setFont(Font font) { this.font = font; setCellWidthAndHeight(font); revalidate(); } public Font getFont() { return font; } public void setModel(TerminalModel model) { if (model == null) { throw new NullPointerException(\"model\"); } this.model = model; } public TerminalModel getModel() { return model; } public void println(String str) { if (str == null) { throw new NullPointerException(\"str\"); } print(str.concat(\"\\r\\n\")); } public void print(String str) { model.print(str); } public Dimension getMinimumSize() { return new Dimension(model.getColumns() * cellWidth + borderWidth * 2, model.getRows() * cellHeight + borderWidth * 2); } public Dimension getMaximumSize() { return getMinimumSize(); } public Dimension getPreferredSize() { return getMinimumSize(); } public void paint(Graphics g) { g.setFont(font); int width = model.getColumns(); int height = model.getBufferSize(); g.setColor(model.getDefaultBackgroundColor()); g.fillRect(0, 0, width * cellWidth + borderWidth * 2, height * cellHeight + borderWidth * 2); int start = scrollBar == null ? 0 : scrollBar.getValue(); for (int y = start; y < height; y++) { for (int x = 0; x < width; x++) { TerminalCell cell = model.getCell(x, y); boolean cursorHere = (model.getCursorRow() == y) && (model.getCursorColumn() == x); if ((cursorHere) && (cell == null)) { cell = new TerminalCell(' ', model.getDefaultBackgroundColor(), model.getDefaultForegroundColor()); } if (cell != null) { int px = x * cellWidth + borderWidth; int py = (y - start) * cellHeight + borderWidth; g.setColor(cursorHere ? cell.getForegroundColor() : cell.getBackgroundColor()); g.fillRect(px, py, cellWidth, cellHeight); g.setColor(cursorHere ? cell.getBackgroundColor() : cell.getForegroundColor()); g.drawChars(new char[] { cell.getCharacter() }, 0, 1, px, py + cellHeight - maxDescender); } } } } private void init() { setLayout(new BorderLayout(0, 0)); int rows = model.getRows(); int bufferSize = model.getBufferSize(); if (bufferSize > rows) { scrollBar = new JScrollBar(1, 0, rows, 0, bufferSize + 1); scrollBar.addAdjustmentListener(new AdjustmentListener() { public void adjustmentValueChanged(AdjustmentEvent evt) { repaint(); } }); add(\"After\", scrollBar); } repaint(); } private void setCellWidthAndHeight(Font font) { FontMetrics metrics = getFontMetrics(font); cellWidth = metrics.charWidth('W'); cellHeight = metrics.getHeight(); maxDescender = metrics.getMaxDescent(); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal; import java.awt.Color;  public class TerminalCell {  private final char character;  private final Color backgroundColor;  private final Color foregroundColor;  public TerminalCell(char character, Color backgroundColor, Color foregroundColor) { if (backgroundColor == null) { throw new NullPointerException(\"backgroundColor\"); } if (foregroundColor == null) { throw new NullPointerException(\"foregroundColor\"); } this.character = character; this.backgroundColor = backgroundColor; this.foregroundColor = foregroundColor; }  public char getCharacter() { return character; }  public Color getBackgroundColor() { return backgroundColor; }  public Color getForegroundColor() { return foregroundColor; } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal; import java.awt.Color; import com.loomcom.symon.jterminal.bell.BellStrategy;  public interface TerminalModel {  public BellStrategy getBellStrategy();  public void setBellStrategy(BellStrategy strategy);  public void clear();  public void moveCursorBack(int n);  public void moveCursorForward(int n);  public void moveCursorDown(int n);  public void moveCursorUp(int n);  public void setCell(int column, int row, TerminalCell cell);  public TerminalCell getCell(int column, int row);  public void print(String str);  public int getColumns();  public int getRows();  public int getBufferSize();  public int getCursorRow();  public void setCursorRow(int row);  public int getCursorColumn();  public void setCursorColumn(int column);  public Color getDefaultBackgroundColor();  public Color getDefaultForegroundColor(); }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.bell; import java.awt.Toolkit;  public class BeepBellStrategy implements BellStrategy { @Override public void soundBell() { Toolkit.getDefaultToolkit().beep(); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.bell;  public interface BellStrategy {  public void soundBell(); }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.bell;  public class NopBellStrategy implements BellStrategy { @Override public void soundBell() {  } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.vt100;  public class AnsiControlSequence {  private final char command;  private final String[] parameters;  public AnsiControlSequence(char command, String[] parameters) { if (parameters == null) { throw new NullPointerException(\"parameters\"); } this.command = command; if (parameters.length == 1 && parameters[0].equals(\"\")) { this.parameters = new String[0]; } else { this.parameters = parameters.clone(); } }  public char getCommand() { return command; }  public String[] getParameters() { return parameters; } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.vt100;  public interface AnsiControlSequenceListener {  public void parsedControlSequence(AnsiControlSequence seq);  public void parsedString(String str); }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.vt100; import java.io.IOException; import java.io.Reader; import java.io.StringReader;  public class AnsiControlSequenceParser {  private static final char[] MULTI_CSI = new char[] { 27, '[' };  private static final char SINGLE_CSI = 155;  private StringBuilder buffer = new StringBuilder();  private final AnsiControlSequenceListener listener;  public AnsiControlSequenceParser(AnsiControlSequenceListener listener) { this.listener = listener; }  public void parse(String str) { if (buffer.length() > 0) { str = buffer.toString().concat(str); buffer = new StringBuilder(); } Reader reader = new StringReader(str); try { try { parse(reader); } finally { reader.close(); } } catch (IOException ex) {  } }  private void parse(Reader reader) throws IOException { StringBuilder text = new StringBuilder(); int character; while ((character = reader.read()) != -1) { boolean introducedControlSequence = false; if (character == SINGLE_CSI) { introducedControlSequence = true; } else if (character == MULTI_CSI[0]) { int nextCharacter = reader.read(); if (nextCharacter == -1) { buffer.append((char) character); break; } else if (nextCharacter == MULTI_CSI[1]) { introducedControlSequence = true; } else { text.append((char) character); text.append((char) nextCharacter); } } else { text.append((char) character); } if (introducedControlSequence) { if (text.length() > 0) { listener.parsedString(text.toString()); text = new StringBuilder(); } parseControlSequence(reader); } } if (text.length() > 0) { listener.parsedString(text.toString()); } }  private void parseControlSequence(Reader reader) throws IOException { boolean finishedSequence = false; StringBuilder parameters = new StringBuilder(); int character; while ((character = reader.read()) != -1) { if ((character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z')) { String[] array = parameters.toString().split(\";\"); AnsiControlSequence seq = new AnsiControlSequence((char) character, array); listener.parsedControlSequence(seq); finishedSequence = true; break; } else { parameters.append((char) character); } } if (!finishedSequence) { "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.vt100; import java.awt.Color;  final class SgrColor {  public static final Color[] COLOR_NORMAL = new Color[] { new Color(0, 0, 0), new Color(128, 0, 0), new Color(0, 128, 0), new Color(128, 128, 0), new Color(0, 0, 128), new Color(128, 0, 128), new Color(0, 128, 128), new Color(192, 192, 192) };  public static final Color[] COLOR_BRIGHT = new Color[] { new Color(128, 128, 128), new Color(255, 0, 0), new Color(0, 255, 0), new Color(255, 255, 0), new Color(0, 0, 255), new Color(0, 0, 255), new Color(255, 0, 255), new Color(0, 255, 255), new Color(255, 255, 255) };  private SgrColor() { } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.jterminal.vt100; import java.awt.Color; import com.loomcom.symon.jterminal.AbstractTerminalModel; import com.loomcom.symon.jterminal.TerminalCell; import com.loomcom.symon.jterminal.TerminalModel; import com.loomcom.symon.jterminal.bell.BellStrategy; import com.loomcom.symon.jterminal.bell.NopBellStrategy;  public class Vt100TerminalModel extends AbstractTerminalModel {  private class Vt100Listener implements AnsiControlSequenceListener {  private int savedCursorRow = -1;  private int savedCursorColumn = -1; @Override public void parsedControlSequence(AnsiControlSequence seq) { char command = seq.getCommand(); String[] parameters = seq.getParameters(); switch (command) { case 'A': case 'B': case 'C': case 'D': int n = 1; if (parameters.length == 1) { n = Integer.parseInt(parameters[0]); } if (command == 'A') { moveCursorUp(n); } else if (command == 'B') { moveCursorDown(n); } else if (command == 'C') { moveCursorForward(n); } else if (command == 'D') { moveCursorBack(n); } break; case 'E': case 'F': n = 1; if (parameters.length == 1) { n = Integer.parseInt(parameters[0]); } if (command == 'E') { moveCursorDown(n); } else if (command == 'F') { moveCursorUp(n); } setCursorColumn(0); break; case 'G': if (parameters.length == 1) { n = Integer.parseInt(parameters[0]); setCursorColumn(n - 1); } break; case 'H': case 'f': if (parameters.length == 2) { n = 1; int m = 1; if (parameters[0].length() > 0) { n = Integer.parseInt(parameters[0]); } if (parameters[1].length() > 0) { m = Integer.parseInt(parameters[1]); } setCursorRow(n - 1); setCursorColumn(m - 1); } break; case 'J': n = 0; if (parameters.length == 1) { n = Integer.parseInt(parameters[0]); } if (n == 0) { int row = cursorRow; int column = cursorColumn; while(row < rows) { while(column < columns) { cells[row][column] = null; column++; } column = 0; row++; } } else if (n == 1) { int row = cursorRow; int column = cursorColumn; while(row >= 0) { while(column >= 0) { cells[row][column] = null; column--; } column = columns - 1; row--; } } else if (n == 2) { clear(); } break; case 'K': n = 0; if (parameters.length == 1) { n = Integer.parseInt(parameters[0]); } if (n == 0) { for (int row = cursorRow; row < rows; row++) { cells[row][cursorColumn] = null; } } else if (n == 1) { for (int row = cursorRow; row >= 0; row--) { cells[row][cursorColumn] = null; } } else if (n == 2) { for (int column = 0; column < columns; column++) { cells[cursorRow][column] = null; } } break; case 'm': if (parameters.length == 0) { parameters = new String[] { \"0\" }; } for (String parameter : parameters) { if (parameter.equals(\"0\")) { foregroundColor = DEFAULT_FOREGROUND_COLOR; backgroundColor = DEFAULT_BACKGROUND_COLOR; backgroundBold = DEFAULT_BACKGROUND_BOLD; foregroundBold = DEFAULT_FOREGROUND_BOLD; } else if (parameter.equals(\"2\")) { backgroundBold = true; foregroundBold = true; } else if (parameter.equals(\"22\")) { backgroundBold = false; foregroundBold = false; } else if ((parameter.startsWith(\"3\") || parameter.startsWith(\"4\")) && parameter.length() == 2) { int color = Integer.parseInt(parameter.substring(1)); if (parameter.startsWith(\"3\")) { foregroundColor = color; } else if (parameter.startsWith(\"4\")) { backgroundColor = color; } } } break; case 'u': if (savedCursorColumn != -1 && savedCursorRow != -1) { cursorColumn = savedCursorColumn; cursorRow = savedCursorRow; } break; case 's': savedCursorColumn = cursorColumn; savedCursorRow = cursorRow; break; } } @Override public void parsedString(String str) { for (char ch : str.toCharArray()) { switch (ch) { case '\\0': continue; case '\\r': cursorColumn = 0; continue; case '\\n': cursorRow++; break; case '\\t': while ((++cursorColumn % TAB_WIDTH) != 0); continue; case 8: "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.machines; import com.loomcom.symon.Bus; import com.loomcom.symon.Cpu; import com.loomcom.symon.devices.*; import com.loomcom.symon.exceptions.MemoryRangeException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.File; public class BenEaterMachine implements Machine { private final static Logger logger = LoggerFactory.getLogger(BenEaterMachine.class.getName()); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.machines; import com.loomcom.symon.Bus; import com.loomcom.symon.Cpu; import com.loomcom.symon.devices.Acia; import com.loomcom.symon.devices.Crtc; import com.loomcom.symon.devices.Memory; import com.loomcom.symon.devices.Pia; import com.loomcom.symon.exceptions.MemoryRangeException; public interface Machine { Bus getBus(); Cpu getCpu(); Memory getRam(); Acia getAcia(); Pia getPia(); Crtc getCrtc(); Memory getRom(); void setRom(Memory rom) throws MemoryRangeException; int getRomBase(); int getRomSize(); int getMemorySize(); String getName(); }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.machines; import com.loomcom.symon.Bus; import com.loomcom.symon.Cpu; import com.loomcom.symon.devices.Acia; import com.loomcom.symon.devices.Acia6850; import com.loomcom.symon.devices.Crtc; import com.loomcom.symon.devices.Memory; import com.loomcom.symon.devices.Pia; import com.loomcom.symon.devices.SdController; import com.loomcom.symon.exceptions.MemoryRangeException; import java.io.File; import java.util.logging.Logger; public class MulticompMachine implements Machine { private final static Logger logger = Logger.getLogger(MulticompMachine.class.getName()); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.machines; import com.loomcom.symon.Bus; import com.loomcom.symon.Cpu; import com.loomcom.symon.devices.Acia; import com.loomcom.symon.devices.Crtc; import com.loomcom.symon.devices.Memory; import com.loomcom.symon.devices.Pia; import com.loomcom.symon.exceptions.MemoryRangeException;  public class SimpleMachine implements Machine { private static final int BUS_BOTTOM = 0x0000; private static final int BUS_TOP = 0xffff; private final Bus bus; private final Memory ram; private final Cpu cpu; public SimpleMachine(String romFile) throws MemoryRangeException { this.bus = new Bus(BUS_BOTTOM, BUS_TOP); this.ram = new Memory(BUS_BOTTOM, BUS_TOP, false); this.cpu = new Cpu(); bus.addCpu(cpu); bus.addDevice(ram); } @Override public Bus getBus() { return bus; } @Override public Cpu getCpu() { return cpu; } @Override public Memory getRam() { return ram; } @Override public Acia getAcia() { return null; } @Override public Pia getPia() { return null; } @Override public Crtc getCrtc() { return null; } @Override public Memory getRom() { return null; } @Override public void setRom(Memory rom) throws MemoryRangeException { "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.machines; import com.loomcom.symon.Bus; import com.loomcom.symon.Cpu; import com.loomcom.symon.devices.*; import com.loomcom.symon.exceptions.MemoryRangeException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.File; public class SymonMachine implements Machine { private final static Logger logger = LoggerFactory.getLogger(SymonMachine.class.getName()); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.ui; import com.loomcom.symon.Breakpoints; import com.loomcom.symon.util.Utils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.swing.*; import javax.swing.border.EmptyBorder; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener;  public class BreakpointsWindow extends JFrame { private static final Logger logger = LoggerFactory.getLogger(BreakpointsWindow.class); private static final Dimension FRAME_SIZE = new Dimension(240, 280); private static final String EMPTY_STRING = \"\"; private JFrame mainWindow; private Breakpoints breakpoints; public BreakpointsWindow(Breakpoints breakpoints, JFrame mainWindow) { this.breakpoints = breakpoints; this.mainWindow = mainWindow; createUi(); } private void createUi() { setTitle(\"Breakpoints\"); JPanel breakpointsPanel = new JPanel(); JPanel controlPanel = new JPanel(); breakpointsPanel.setLayout(new BorderLayout()); breakpointsPanel.setBorder(new EmptyBorder(10, 10, 10, 10)); final JButton addButton = new JButton(\"Add\"); final JButton removeButton = new JButton(\"Del\"); removeButton.setEnabled(false); final JTextField addTextField = new JTextField(4); final JTable breakpointsTable = new JTable(breakpoints); breakpointsTable.setShowGrid(true); breakpointsTable.setGridColor(Color.LIGHT_GRAY); breakpointsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); breakpointsTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() { @Override public void valueChanged(ListSelectionEvent e) { if (e.getFirstIndex() > -1) { removeButton.setEnabled(true); } else { removeButton.setEnabled(false); } } }); JScrollPane scrollPane = new JScrollPane(breakpointsTable); scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER); scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS); breakpointsPanel.add(scrollPane, BorderLayout.CENTER); ActionListener addBreakpointListener = new ActionListener() { @Override public void actionPerformed(ActionEvent e) { int value; String newBreakpoint = addTextField.getText(); if (newBreakpoint == null || newBreakpoint.isEmpty()) { return; } try { value = (Integer.parseInt(addTextField.getText(), 16) & 0xffff); } catch (NumberFormatException ex) { logger.warn(\"Can't parse page number {}\", newBreakpoint); return; } if (value < 0) { return; } breakpoints.addBreakpoint(value); logger.debug(\"Added breakpoint ${}\", Utils.wordToHex(value)); addTextField.setText(EMPTY_STRING); } }; addButton.addActionListener(addBreakpointListener); addTextField.addActionListener(addBreakpointListener); removeButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { breakpoints.removeBreakpointAtIndex(breakpointsTable.getSelectedRow()); } }); controlPanel.add(addTextField); controlPanel.add(addButton); controlPanel.add(removeButton); setLayout(new BorderLayout()); getContentPane().add(breakpointsPanel, BorderLayout.CENTER); getContentPane().add(controlPanel, BorderLayout.SOUTH); setMinimumSize(FRAME_SIZE); setMaximumSize(FRAME_SIZE); setPreferredSize(FRAME_SIZE); setLocationRelativeTo(mainWindow); setResizable(false); pack(); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.ui; import com.loomcom.symon.jterminal.JTerminal; import com.loomcom.symon.jterminal.vt100.Vt100TerminalModel; import com.loomcom.symon.exceptions.FifoUnderrunException; import com.loomcom.symon.util.FifoRingBuffer; import javax.swing.*; import javax.swing.border.BevelBorder; import javax.swing.border.Border; import java.awt.*; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener;  public class Console extends JTerminal implements KeyListener, MouseListener { private static final long serialVersionUID = 6633818486963338126L; private static final int DEFAULT_BORDER_WIDTH = 10; "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.ui; import com.loomcom.symon.Bus; import com.loomcom.symon.exceptions.MemoryAccessException; import com.loomcom.symon.util.Utils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.swing.*; import javax.swing.border.EmptyBorder; import javax.swing.table.AbstractTableModel; import javax.swing.table.DefaultTableCellRenderer; import javax.swing.table.TableModel; import javax.swing.text.JTextComponent; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.EventObject;  public class MemoryWindow extends JFrame implements ActionListener { private static final Logger logger = LoggerFactory.getLogger(MemoryWindow.class); private MemoryTableModel memoryTableModel; private JTable memoryTable; private JTextField pageNumberTextField; private JButton previousPageButton; private JButton nextPageButton; private static final Dimension MINIMUM_SIZE = new Dimension(320, 600); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.ui; import com.loomcom.symon.Preferences; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.Observable;  public class PreferencesDialog extends Observable implements Preferences { private final JDialog dialog; private JCheckBox haltOnBreakCheckBox; private JTextField programLoadAddressField; private int programLoadAddress = DEFAULT_PROGRAM_LOAD_ADDRESS; private boolean haltOnBreak; public PreferencesDialog(Frame parent, boolean modal, boolean haltOnBreak) { this.dialog = new JDialog(parent, modal); this.haltOnBreak = haltOnBreak; createUi(); updateUi(); } public JDialog getDialog() { return dialog; }  private void createUi() { dialog.setTitle(\"Preferences\"); Container contents = dialog.getContentPane(); JPanel settingsContainer = new JPanel(); JPanel buttonsContainer = new JPanel(); GridBagLayout layout = new GridBagLayout(); settingsContainer.setLayout(layout); final JLabel haltOnBreakLabel = new JLabel(\"Halt on BRK\"); final JLabel programLoadAddressLabel = new JLabel(\"Program Load Address\"); haltOnBreakCheckBox = new JCheckBox(); programLoadAddressField = new JTextField(8); programLoadAddressLabel.setLabelFor(programLoadAddressField); GridBagConstraints constraints = new GridBagConstraints(); constraints.insets = new Insets(5, 5, 5, 5); constraints.fill = GridBagConstraints.HORIZONTAL; constraints.gridx = 0; constraints.gridy = 0; settingsContainer.add(haltOnBreakLabel, constraints); constraints.gridx = 1; settingsContainer.add(haltOnBreakCheckBox, constraints); constraints.gridy = 1; constraints.gridx = 0; settingsContainer.add(programLoadAddressLabel, constraints); constraints.gridx = 1; settingsContainer.add(programLoadAddressField, constraints); JButton applyButton = new JButton(\"Apply\"); JButton cancelButton = new JButton(\"Cancel\"); cancelButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent actionEvent) { PreferencesDialog.this.updateUi(); dialog.setVisible(false); } }); applyButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent actionEvent) { haltOnBreak = haltOnBreakCheckBox.isSelected(); programLoadAddress = PreferencesDialog.this.hexToInt(programLoadAddressField.getText()); PreferencesDialog.this.updateUi(); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.ui; import com.loomcom.symon.Cpu; import com.loomcom.symon.CpuState; import com.loomcom.symon.machines.Machine; import javax.swing.*; import javax.swing.border.Border; import javax.swing.border.EtchedBorder; import javax.swing.plaf.metal.MetalTextFieldUI; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener;  public class StatusPanel extends JPanel { private ImageIcon carryOn; private ImageIcon carryOff; private ImageIcon zeroOn; private ImageIcon zeroOff; private ImageIcon irqOn; private ImageIcon irqOff; private ImageIcon decimalOn; private ImageIcon decimalOff; private ImageIcon breakOn; private ImageIcon breakOff; private ImageIcon overflowOn; private ImageIcon overflowOff; private ImageIcon negativeOn; private ImageIcon negativeOff; private JLabel carryFlagLabel; private JLabel zeroFlagLabel; private JLabel irqDisableFlagLabel; private JLabel decimalModeFlagLabel; private JLabel breakFlagLabel; private JLabel overflowFlagLabel; private JLabel negativeFlagLabel; private JTextField opcodeField; private JTextField pcField; private JTextField spField; private JTextField aField; private JTextField xField; private JTextField yField; private final Machine machine; private static final int EMPTY_BORDER = 10; private static final Border LABEL_BORDER = BorderFactory.createEmptyBorder(0, 5, 0, 0); private static final Font LABEL_FONT = new Font(Font.SANS_SERIF, Font.BOLD, 12); private static final Dimension LARGE_TEXT_FIELD_SIZE = new Dimension(134, 22); private static final Dimension SMALL_TEXT_FIELD_SIZE = new Dimension(65, 22); public StatusPanel(Machine machine) { super(); this.machine = machine; createUi(); } private void createUi() { Border emptyBorder = BorderFactory.createEmptyBorder(EMPTY_BORDER, EMPTY_BORDER, EMPTY_BORDER, EMPTY_BORDER); Border etchedBorder = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED); setBorder(BorderFactory.createCompoundBorder(emptyBorder, etchedBorder)); GridBagLayout layout = new GridBagLayout(); GridBagConstraints constraints = new GridBagConstraints(); setLayout(layout); JPanel statusFlagsPanel = new JPanel(); statusFlagsPanel.setAlignmentX(LEFT_ALIGNMENT); carryOn = new ImageIcon(this.getClass().getResource(\"/C_on.png\")); carryOff = new ImageIcon(this.getClass().getResource(\"/C_off.png\")); zeroOn = new ImageIcon(this.getClass().getResource(\"/Z_on.png\")); zeroOff = new ImageIcon(this.getClass().getResource(\"/Z_off.png\")); irqOn = new ImageIcon(this.getClass().getResource(\"/I_on.png\")); irqOff = new ImageIcon(this.getClass().getResource(\"/I_off.png\")); decimalOn = new ImageIcon(this.getClass().getResource(\"/D_on.png\")); decimalOff = new ImageIcon(this.getClass().getResource(\"/D_off.png\")); breakOn = new ImageIcon(this.getClass().getResource(\"/B_on.png\")); breakOff = new ImageIcon(this.getClass().getResource(\"/B_off.png\")); overflowOn = new ImageIcon(this.getClass().getResource(\"/O_on.png\")); overflowOff = new ImageIcon(this.getClass().getResource(\"/O_off.png\")); negativeOn = new ImageIcon(this.getClass().getResource(\"/N_on.png\")); negativeOff = new ImageIcon(this.getClass().getResource(\"/N_off.png\")); "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.ui; import com.loomcom.symon.CpuState; import com.loomcom.symon.util.FifoRingBuffer; import javax.swing.*; import java.awt.*;  public class TraceLog extends JFrame { private final FifoRingBuffer<CpuState> traceLog; private final JTextArea traceLogTextArea; private static final Dimension MIN_SIZE = new Dimension(320, 200); private static final Dimension PREFERRED_SIZE = new Dimension(640, 480); private static final int MAX_LOG_LENGTH = 50000; public TraceLog() { traceLog = new FifoRingBuffer<>(MAX_LOG_LENGTH); setMinimumSize(MIN_SIZE); setPreferredSize(PREFERRED_SIZE); setResizable(true); setTitle(\"Trace Log\"); setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE); traceLogTextArea = new JTextArea(); traceLogTextArea.setFont(new Font(Font.MONOSPACED, Font.BOLD, 12)); traceLogTextArea.setEditable(false); JScrollPane scrollableView = new JScrollPane(traceLogTextArea); getContentPane().add(scrollableView); pack(); }  public void refresh() { StringBuilder logString = new StringBuilder(); synchronized(traceLog) { for (CpuState state : traceLog) { logString.append(state.toTraceEvent()); } } synchronized(traceLogTextArea) { traceLogTextArea.setText(logString.toString()); } }  public void reset() { synchronized(traceLog) { traceLog.reset(); } synchronized(traceLogTextArea) { traceLogTextArea.setText(\"\"); traceLogTextArea.setEnabled(true); } }  public void append(CpuState state) { synchronized(traceLog) { traceLog.push(new CpuState(state)); } } public void simulatorDidStart() { traceLogTextArea.setEnabled(false); } public void simulatorDidStop() { traceLogTextArea.setEnabled(true); } public boolean shouldUpdate() { return isVisible() && traceLogTextArea.isEnabled(); } }"}
{"name": "sethm/symon", "content": " package com.loomcom.symon.ui; import com.loomcom.symon.devices.Crtc; import com.loomcom.symon.devices.DeviceChangeListener; import com.loomcom.symon.exceptions.MemoryAccessException; import javax.swing.*; import java.awt.*; import java.awt.image.BufferedImage; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.ScheduledFuture; import java.util.concurrent.TimeUnit; import java.util.logging.Level; import java.util.logging.Logger; import static java.lang.System.*;  public class VideoWindow extends JFrame implements DeviceChangeListener { private static final Logger logger = Logger.getLogger(VideoWindow.class.getName()); private static final long WINDOW_REPAINT_INTERVAL = 66; "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.util; import com.loomcom.symon.exceptions.*; import java.util.Iterator; import java.util.LinkedList; import java.util.Queue;  public class FifoRingBuffer<E> implements Iterable<E> { private Queue<E> fifoBuffer; private int maxLength; public FifoRingBuffer(int maxLength) { this.fifoBuffer = new LinkedList<>(); this.maxLength = maxLength; } public E pop() throws FifoUnderrunException { return fifoBuffer.remove(); } public boolean isEmpty() { return fifoBuffer.isEmpty(); } public void push(E val) { if (fifoBuffer.size() == maxLength) { "}
{"name": "sethm/symon", "content": " package com.loomcom.symon.util;  public class Utils { static final String NON_PRINTABLE = \".\"; static final String[] ASCII_CONSTANTS = {\" \", \"!\", \"\\\"\", \"#\", \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \"-\", \".\", \"/\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \":\", \";\", \"<\", \"=\", \">\", \"?\", \"@\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"[\", \"\\\\\", \"]\", \"^\", \"_\", \"`\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"{\", \"|\", \"}\", \"~\"}; static final String[] HEX_CONSTANTS = {\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0A\", \"0B\", \"0C\", \"0D\", \"0E\", \"0F\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1A\", \"1B\", \"1C\", \"1D\", \"1E\", \"1F\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2A\", \"2B\", \"2C\", \"2D\", \"2E\", \"2F\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3A\", \"3B\", \"3C\", \"3D\", \"3E\", \"3F\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4A\", \"4B\", \"4C\", \"4D\", \"4E\", \"4F\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5A\", \"5B\", \"5C\", \"5D\", \"5E\", \"5F\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6A\", \"6B\", \"6C\", \"6D\", \"6E\", \"6F\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7A\", \"7B\", \"7C\", \"7D\", \"7E\", \"7F\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8A\", \"8B\", \"8C\", \"8D\", \"8E\", \"8F\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9A\", \"9B\", \"9C\", \"9D\", \"9E\", \"9F\", \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"A7\", \"A8\", \"A9\", \"AA\", \"AB\", \"AC\", \"AD\", \"AE\", \"AF\", \"B0\", \"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B9\", \"BA\", \"BB\", \"BC\", \"BD\", \"BE\", \"BF\", \"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\", \"CA\", \"CB\", \"CC\", \"CD\", \"CE\", \"CF\", \"D0\", \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\", \"D8\", \"D9\", \"DA\", \"DB\", \"DC\", \"DD\", \"DE\", \"DF\", \"E0\", \"E1\", \"E2\", \"E3\", \"E4\", \"E5\", \"E6\", \"E7\", \"E8\", \"E9\", \"EA\", \"EB\", \"EC\", \"ED\", \"EE\", \"EF\", \"F0\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"FA\", \"FB\", \"FC\", \"FD\", \"FE\", \"FF\"};  public static String byteToAscii(int val) { if (val >= 32 && val <= 126) { return ASCII_CONSTANTS[val - 32]; } else { return NON_PRINTABLE; } }  public static String byteToHex(int val) { return HEX_CONSTANTS[val & 0xff]; }  public static String wordToHex(int val) { return HEX_CONSTANTS[(val >> 8) & 0xff] + HEX_CONSTANTS[val & 0xff]; }  public static int address(int lowByte, int hiByte) { return ((hiByte << 8) | lowByte) & 0xffff; } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.api; import java.util.List; import java.util.ArrayList; public class DataSet { private String _type; private List<DataSource> _ds; private DataSet () { this._type = null; this._ds = new ArrayList<DataSource> (); } public DataSet (String type) { this._type = type; this._ds = new ArrayList<DataSource> (); } public DataSet (String type, DataSource dsrc) { this._type = type; this._ds = new ArrayList<DataSource> (); this._ds.add (dsrc); } public DataSet (String type, List<DataSource> ds) { this._type = type; this._ds = ds; } public void setType (String type) { this._type = type; } public String getType () { return (this._type); } public void addDataSource (DataSource dsrc) { this._ds.add (dsrc); } public List<DataSource> getDataSources () { return (this._ds); } public String toString () { StringBuffer sb = new StringBuffer (); int i; sb.append (this._type); for (i = 0; i < this._ds.size (); i++) { if (i == 0) sb.append (\"\\t\"); else sb.append (\", \"); sb.append (this._ds.get (i).toString ()); } return (sb.toString ()); } static public DataSet parseDataSet (String str) { DataSet ds = new DataSet (); String[] fields; int i; str = str.trim(); if (str.length() == 0) { return (null); } if (str.charAt(0) == '#') { return (null); } fields = str.split (\"\\\\s+\"); if (fields.length < 2) return (null); ds._type = fields[0]; for (i = 1; i < fields.length; i++) { DataSource dsrc; dsrc = DataSource.parseDataSource (fields[i]); if (dsrc == null) break; ds._ds.add (dsrc); } if (i < fields.length) return (null); return (ds); }  }  "}
{"name": "collectd/jcollectd", "content": " package org.collectd.api;  public class DataSource { public static final int TYPE_COUNTER = 0; public static final int TYPE_GAUGE = 1; static final String COUNTER = \"COUNTER\"; static final String GAUGE = \"GAUGE\"; static final String NAN = \"U\"; private static final String[] TYPES = { COUNTER, GAUGE }; String _name; int _type; double _min; double _max; public DataSource (String name, int type, double min, double max) { this._name = name; this._type = TYPE_GAUGE; if (type == TYPE_COUNTER) this._type = TYPE_COUNTER; this._min = min; this._max = max; }  private DataSource () { this._type = TYPE_GAUGE; } public String getName() { return _name; } public void setName(String name) { _name = name; } public int getType() { return _type; } public void setType(int type) { _type = type; } public double getMin() { return _min; } public void setMin(double min) { _min = min; } public double getMax() { return _max; } public void setMax(double max) { _max = max; } static double toDouble(String val) { if (val.equals(NAN)) { return Double.NaN; } else { return Double.parseDouble(val); } } private String asString(double val) { if (Double.isNaN(val)) { return NAN; } else { return String.valueOf(val); } } public String toString() { StringBuffer sb = new StringBuffer(); final char DLM = ':'; sb.append(_name).append(DLM); sb.append(TYPES[_type]).append(DLM); sb.append(asString(_min)).append(DLM); sb.append(asString(_max)); return sb.toString(); } static public DataSource parseDataSource (String str) { String[] fields; int str_len = str.length (); DataSource dsrc = new DataSource ();  if (str.charAt (str_len - 1) == ',') { str = str.substring (0, str_len - 1); } fields = str.split(\":\"); if (fields.length != 4) return (null); dsrc._name = fields[0]; if (fields[1].equals (DataSource.GAUGE)) { dsrc._type = TYPE_GAUGE; } else { dsrc._type = TYPE_COUNTER; } dsrc._min = toDouble (fields[2]); dsrc._max = toDouble (fields[3]); return (dsrc); }  } "}
{"name": "collectd/jcollectd", "content": " package org.collectd.api;  public class Notification extends PluginData { public static final int FAILURE = 1; public static final int WARNING = 2; public static final int OKAY = 4; public static String[] SEVERITY = { \"FAILURE\", \"WARNING\", \"OKAY\", \"UNKNOWN\" }; private int _severity; private String _message; public Notification (PluginData pd) { super (pd); } public void setSeverity (int severity) { if ((severity == FAILURE) || (severity == WARNING) || (severity == OKAY)) this._severity = severity; } public int getSeverity() { return _severity; } public String getSeverityString() { switch (_severity) { case FAILURE: return SEVERITY[0]; case WARNING: return SEVERITY[1]; case OKAY: return SEVERITY[2]; default: return SEVERITY[3]; } } public void setMessage (String message) { this._message = message; } public String getMessage() { return _message; } public String toString() { StringBuffer sb = new StringBuffer(super.toString()); sb.append(\" [\").append(getSeverityString()).append(\"] \"); sb.append(_message); return sb.toString(); } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.api; import java.util.Date;  public class PluginData { protected long _time; protected String _host; protected String _plugin; protected String _pluginInstance = \"\"; protected String _type = \"\"; protected String _typeInstance = \"\"; public PluginData() { } public PluginData(PluginData pd) { _time = pd._time; _host = pd._host; _plugin = pd._plugin; _pluginInstance = pd._pluginInstance; _type = pd._type; _typeInstance = pd._typeInstance; } public long getTime() { return _time; } public void setTime(long time) { _time = time; } public String getHost() { return _host; } public void setHost(String host) { _host = host; } public String getPlugin() { return _plugin; } public void setPlugin(String plugin) { _plugin = plugin; } public String getPluginInstance() { return _pluginInstance; } public void setPluginInstance(String pluginInstance) { _pluginInstance = pluginInstance; } public String getType() { return _type; } public void setType(String type) { _type = type; } public String getTypeInstance() { return _typeInstance; } public void setTypeInstance(String typeInstance) { _typeInstance = typeInstance; } public boolean defined(String val) { return (val != null) && (val.length() > 0); } public String getSource() { final char DLM = '/'; StringBuffer sb = new StringBuffer(); if (defined(_host)) { sb.append(_host); } if (defined(_plugin)) { sb.append(DLM).append(_plugin); } if (defined(_pluginInstance)) { sb.append(DLM).append(_pluginInstance); } if (defined(_type)) { sb.append(DLM).append(_type); } if (defined(_typeInstance)) { sb.append(DLM).append(_typeInstance); } return sb.toString(); } public String toString() { StringBuffer sb = new StringBuffer(); sb.append('[').append(new Date(_time)).append(\"] \"); sb.append(getSource()); return sb.toString(); } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.api; import java.util.ArrayList; import java.util.List;  public class ValueList extends PluginData { List<Number> _values = new ArrayList<Number>(); List<DataSource> _ds = new ArrayList<DataSource>(); long _interval; public ValueList() { } public ValueList(PluginData pd) { super(pd); } public ValueList(ValueList vl) { this((PluginData)vl); _interval = vl._interval; _values.addAll(vl.getValues()); _ds.addAll(vl._ds); } public List<Number> getValues() { return _values; } public void setValues(List<Number> values) { _values = values; } public void addValue(Number value) { _values.add(value); }  public void clearValues () { _values.clear (); } public List<DataSource> getDataSource() { if (_ds.size() > 0) { return _ds; } else { return null; } } public void setDataSource(List<DataSource> ds) { _ds = ds; } public long getInterval() { return _interval; } public void setInterval(long interval) { _interval = interval; } public String toString() { StringBuffer sb = new StringBuffer(super.toString()); sb.append(\"=[\"); List<DataSource> ds = getDataSource(); int size = _values.size(); for (int i=0; i<size; i++) { Number val = _values.get(i); String name; if (ds == null) { name = \"unknown\" + i; } else { name = ds.get(i).getName(); } sb.append(name).append('=').append(val); if (i < size-1) { sb.append(','); } } sb.append(\"]\"); return sb.toString(); } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.util.Map; import javax.management.Attribute; import javax.management.AttributeList; import javax.management.AttributeNotFoundException; import javax.management.DynamicMBean; import javax.management.InvalidAttributeValueException; import javax.management.MBeanAttributeInfo; import javax.management.MBeanException; import javax.management.MBeanInfo; import javax.management.ReflectionException;  public class CollectdMBean implements DynamicMBean { private Map<String,Number> _metrics; public CollectdMBean(Map<String,Number> metrics) { _metrics = metrics; } public Object getAttribute(String key) throws AttributeNotFoundException, MBeanException, ReflectionException { Number val = _metrics.get(key); if (val == null){ throw new AttributeNotFoundException(key); } return val; } public AttributeList getAttributes(String[] attrs) { AttributeList result = new AttributeList(); for (int i=0; i<attrs.length; i++) { try { result.add(new Attribute(attrs[i], getAttribute(attrs[i]))); } catch (AttributeNotFoundException e) { } catch (MBeanException e) { } catch (ReflectionException e) { } } return result; } protected String getAttributeType(String name) { return _metrics.get(name).getClass().getName(); } protected String getAttributeDescription(String name) { return name + \" Attribute\"; } protected MBeanAttributeInfo[] getAttributeInfo() { MBeanAttributeInfo[] attrs = new MBeanAttributeInfo[_metrics.size()]; int i=0; for (String name : _metrics.keySet()) { attrs[i++] = new MBeanAttributeInfo(name, getAttributeType(name), getAttributeDescription(name), true, "}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.lang.management.ManagementFactory; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Pattern; import javax.management.ListenerNotFoundException; import javax.management.MBeanNotificationInfo; import javax.management.MBeanServer; import javax.management.MalformedObjectNameException; import javax.management.NotificationBroadcaster; import javax.management.NotificationBroadcasterSupport; import javax.management.NotificationFilter; import javax.management.NotificationListener; import javax.management.ObjectName; import org.collectd.api.DataSource; import org.collectd.protocol.Network; import org.collectd.protocol.TypesDB; import org.collectd.api.Notification; import org.collectd.protocol.Dispatcher; import org.collectd.api.PluginData; import org.collectd.api.ValueList;  public class CollectdMBeanRegistry implements Dispatcher, NotificationBroadcaster, CollectdMBeanRegistryMBean { public static final String DOMAIN = \"collectd\"; private Map<ObjectName,Map<String,Number>> beans = new HashMap<ObjectName,Map<String,Number>>(); private NotificationBroadcasterSupport _broadcaster = new NotificationBroadcasterSupport(); private static Pattern _hosts = hostPattern(); private long _notifSequence = 0; private boolean _doSummary = !\"false\".equals(Network.getProperty(\"mx.summary\")); MBeanServer bs = ManagementFactory.getPlatformMBeanServer(); public void init() throws Exception { ObjectName name = new ObjectName(DOMAIN + \":\" + \"type=\" + \"MBeanRegistry\"); bs.registerMBean(this, name); } private static Pattern hostPattern() { String hosts = Network.getProperty(\"mx.hosts\"); if (hosts == null) { return null; } return Pattern.compile(hosts); } private static boolean excludeHost(PluginData data) { if (_hosts == null) { return false; } return !_hosts.matcher(data.getHost()).find(); } public void dispatch(Notification notif) { if (excludeHost(notif)) { return; } _broadcaster.sendNotification(new javax.management. Notification(notif.getSeverityString(), notif.getSource(), ++_notifSequence, notif.getTime(), notif.getMessage())); } private String getRootName(String host, ValueList vl) { StringBuffer name = new StringBuffer(); name.append(DOMAIN).append(':'); if (host != null) { name.append(\"host=\").append(host).append(','); } name.append(\"plugin=\").append(vl.getPlugin()); if (host == null) { name.append(\",*\"); } return name.toString(); } Map<String,Number> getMBean(ObjectName name) { return beans.get(name); } Number getMBeanAttribute(ObjectName name, String attribute) { Map<String,Number> bean = getMBean(name); if (bean == null) { return null; } return bean.get(attribute); } private Map<String,Number> getMBean(ValueList vl) { String instance = vl.getPluginInstance(); StringBuffer bname = new StringBuffer(); bname.append(getRootName(vl.getHost(), vl)); if (!vl.defined(instance)) { List<DataSource> ds = vl.getDataSource(); if (ds == null) { ds = TypesDB.getInstance().getType(vl.getType()); } if ((ds != null) && (ds.size() > 1)) { "}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx;  public interface CollectdMBeanRegistryMBean { }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.util.Map; import java.util.Set; import javax.management.AttributeNotFoundException; import javax.management.MBeanException; import javax.management.ObjectName; import javax.management.ReflectionException;  public class CollectdSummaryMBean extends CollectdMBean { private ObjectName _query; private CollectdMBeanRegistry _registry; public CollectdSummaryMBean(ObjectName name, Map<String, Number> metrics) { super(metrics); _query = name; } void setMBeanRegistry(CollectdMBeanRegistry registry) { _registry = registry; } private Object getAverage(String key) { double sum = 0; double avg; int num = 0; Set<ObjectName> names = _registry.bs.queryNames(_query, null); for (ObjectName name : names) { Number val = _registry.getMBeanAttribute(name, key); if (val == null) { continue; } num++; sum += val.doubleValue(); } if (num == 0) { avg = 0; } else { avg = sum / num; } return new Double(avg); } public Object getAttribute(String key) throws AttributeNotFoundException, MBeanException, ReflectionException { try { return getAverage(key); } catch (Throwable e) { e.printStackTrace(); return null; } } protected String getAttributeType(String name) { return Double.class.getName(); } protected String getAttributeDescription(String name) { return super.getAttributeDescription(name) + \" (summary)\"; } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.util.List; import org.collectd.api.DataSource; import org.collectd.protocol.Network; import org.collectd.protocol.TypesDB;  public class MBeanAttribute { private static final TypesDB _types = TypesDB.getInstance(); private String _name; private String _attributeName; private String _compositeKey; private String _typeName; private int _dataType; public MBeanAttribute(String attributeName) { this(attributeName, Network.DS_TYPE_GAUGE); } public MBeanAttribute(String attributeName, int dataType) { this(attributeName, dataType, null); } private static final int getDataType(String typeName) { List<DataSource> ds = _types.getType(typeName); if ((ds == null) || (ds.size() == 0)) { return Network.DS_TYPE_GAUGE; } else { return ds.get(0).getType(); } } public MBeanAttribute(String attributeName, String typeName) { this(attributeName, getDataType(typeName), typeName); } public MBeanAttribute(String attributeName, int dataType, String typeName) { _name = attributeName; _dataType = dataType; _typeName = typeName; if (_typeName == null) { if (dataType == Network.DS_TYPE_COUNTER) { _typeName = TypesDB.NAME_COUNTER; } else { _typeName = TypesDB.NAME_GAUGE; } } int ix = attributeName.indexOf('.'); if (ix != -1) { _attributeName = attributeName.substring(0, ix); _compositeKey = attributeName.substring(ix+1); } else { _attributeName = attributeName; } } public String getName() { return _name; } public void setName(String name) { _name = name; } public String getAttributeName() { return _attributeName; } public void setAttributeName(String attributeName) { _attributeName = attributeName; } public String getCompositeKey() { return _compositeKey; } public void setCompositeKey(String compositeKey) { _compositeKey = compositeKey; } public String getTypeName() { return _typeName; } public void setTypeName(String typeName) { _typeName = typeName; } public int getDataType() { return _dataType; } public void setDataType(int dataType) { _dataType = dataType; } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.util.Set; import java.util.logging.Level; import java.util.logging.Logger; import javax.management.Descriptor; import javax.management.MBeanAttributeInfo; import javax.management.MBeanInfo; import javax.management.MBeanServerConnection; import javax.management.ObjectName; import javax.management.openmbean.CompositeData; import org.collectd.api.ValueList; import org.collectd.protocol.Network; import org.collectd.protocol.TypesDB;  public class MBeanCollector implements Runnable { private static final Logger _log = Logger.getLogger(MBeanCollector.class.getName()); private static boolean _useDescriptors = \"true\".equals(Network.getProperty(\"mx.descriptors\", \"true\")); private static Method _getDescriptor; private static final String _metricTypeField = Network.getProperty(\"mx.metricTypeField\", \"metricType\"); private MBeanSender _sender; private long _interval = 60; private Map<String,MBeanQuery> _queries = new HashMap<String,MBeanQuery>(); static { if (_useDescriptors) { try { _getDescriptor = "}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.io.File; import java.io.InputStream; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpressionException; import javax.xml.xpath.XPathFactory; import org.collectd.protocol.TypesDB; import org.w3c.dom.NamedNodeMap; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.InputSource;  public class MBeanConfig { private XPath _xpath = XPathFactory.newInstance().newXPath(); private String getAttribute(Node node, String name) { NamedNodeMap attrs = node.getAttributes(); if (attrs == null) { return null; } Node item = attrs.getNamedItem(name); if (item == null) { return null; } return item.getNodeValue(); } private NodeList eval(String name, Node node) throws XPathExpressionException { return (NodeList)_xpath.evaluate(name, node, XPathConstants.NODESET); } private NodeList eval(String name, InputSource is) throws XPathExpressionException { return (NodeList)_xpath.evaluate(name, is, XPathConstants.NODESET); } public MBeanCollector add(String source) throws Exception { String name = source + \"-jcollectd.xml\"; if (new File(source).exists()) { return add(new InputSource(source)); } else if (new File(name).exists()) { return add(new InputSource(name)); } else { String[] rs = { name, \"etc/\" + name, \"META-INF/\" + name }; for (int i=0; i<rs.length; i++) { InputStream is = getClass().getClassLoader().getResourceAsStream(rs[i]); if (is != null) { return add(is); } } return null; } } public MBeanCollector add(InputStream is) throws Exception { return add(new InputSource(is)); } public MBeanCollector add(InputSource is) throws Exception { MBeanCollector collector = new MBeanCollector(); final String path = \"/jcollectd-config/mbeans\"; NodeList plugins = eval(path, is); int len = plugins.getLength(); if (len == 0) { throw new IllegalArgumentException(\"Missing \" + path); } for (int i=0; i<len; i++) { Node plugin = plugins.item(i); String pluginName = getAttribute(plugin, \"name\"); NodeList mbeans = eval(\"mbean\", plugin); for (int j=0; j<mbeans.getLength(); j++) { Node mbean = mbeans.item(j); String objectName = getAttribute(mbean, \"name\"); String objectNameAlias = getAttribute(mbean, \"alias\"); NodeList attrs = eval(\"attribute\", mbean); MBeanQuery query = collector.addMBean(objectName); if (pluginName != null) { query.setPlugin(pluginName); } if (objectNameAlias != null) { query.setAlias(objectNameAlias); } for (int k=0; k<attrs.getLength(); k++) { Node attr = attrs.item(k); String attrName = getAttribute(attr, \"name\"); String type = getAttribute(attr, \"type\"); String units = getAttribute(attr, \"units\"); String alias = getAttribute(attr, \"alias\"); if (type == null) { type = TypesDB.NAME_GAUGE; } MBeanAttribute mattr = new MBeanAttribute(attrName, type); if (alias != null) { mattr.setName(alias); } if (units != null) { "}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.util.HashSet; import java.util.Set; import javax.management.ObjectName;  public class MBeanQuery { private String _plugin; private String _pluginInstance; private ObjectName _name; private String _alias; private Set<MBeanAttribute> _attributes = new HashSet<MBeanAttribute>(); public MBeanQuery(ObjectName name) { _name = name; } public String getPlugin() { return _plugin; } public void setPlugin(String plugin) { _plugin = plugin; } public String getPluginInstance() { return _pluginInstance; } public void setPluginInstance(String pluginInstance) { _pluginInstance = pluginInstance; } public ObjectName getName() { return _name; } public void setName(ObjectName name) { _name = name; } public String getAlias() { return _alias; } public void setAlias(String alias) { _alias = alias; } public Set<MBeanAttribute> getAttributes() { return _attributes; } public void setAttributes(Set<MBeanAttribute> attributes) { _attributes = attributes; } public void addAttribute(MBeanAttribute attribute) { _attributes.add(attribute); } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.lang.management.ManagementFactory; import java.net.DatagramSocket; import java.net.MulticastSocket; import javax.management.MBeanServerFactory; import org.collectd.protocol.Dispatcher; import org.collectd.protocol.UdpReceiver;  public class MBeanReceiver extends UdpReceiver implements Runnable { private static final String MX = \"com.sun.management.jmxremote\"; private static final String DMX = \"-D\" + MX; public MBeanReceiver() { setDispatcher(new CollectdMBeanRegistry()); } public MBeanReceiver(Dispatcher dispatcher) { super(dispatcher); } private void setup() throws Exception { DatagramSocket socket = getSocket(); if (socket instanceof MulticastSocket) { MulticastSocket mcast = (MulticastSocket)socket; System.err.println(\"Multicast interface=\" + mcast.getInterface()); } System.err.println(getListenAddress() + \":\" + getPort() + \" listening...\"); listen(); } public void run() { try { setup(); } catch (Exception e){ e.printStackTrace(); } } private static String getPid() { String name = ManagementFactory.getRuntimeMXBean().getName(); int ix = name.indexOf('@'); if (ix == -1) { return null; } return name.substring(0, ix); } private static boolean hasMBeanServer() { return MBeanServerFactory.findMBeanServer(null).size() != 0; } private static boolean checkMxAgent(String[] args) { if (hasMBeanServer()) { return true; } boolean hasMx = false; for (int i=0; i<args.length; i++) { if (args[i].startsWith(DMX)) { hasMx = true; break; } } if (hasMx) { return true; } try { System.err.print(\"Enabling \" + DMX + \"...\"); System.setProperty(MX, \"true\"); "}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.io.IOException; import java.lang.instrument.Instrumentation; import java.lang.management.ManagementFactory; import java.util.HashMap; import java.util.Map; import java.util.Properties; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; import java.util.logging.Level; import java.util.logging.Logger; import javax.management.MBeanServerConnection; import javax.management.MalformedObjectNameException; import javax.management.ObjectName; import org.collectd.protocol.Network; import org.collectd.api.Notification; import org.collectd.protocol.Dispatcher; import org.collectd.protocol.Sender; import org.collectd.protocol.UdpSender; import org.collectd.api.ValueList;  public class MBeanSender implements Dispatcher { private static final Logger _log = Logger.getLogger(MBeanSender.class.getName()); private static final String UDP = \"udp\"; private static final String PSEP = \":"}
{"name": "collectd/jcollectd", "content": " package org.collectd.mx; import java.io.IOException; import java.lang.instrument.Instrumentation; import java.util.Properties; import java.util.logging.Logger; import javax.management.remote.JMXConnector; import javax.management.remote.JMXConnectorFactory; import javax.management.remote.JMXServiceURL;  public class RemoteMBeanSender extends MBeanSender { private static final Logger _log = Logger.getLogger(RemoteMBeanSender.class.getName()); public void setMBeanServerConnection(JMXServiceURL url) throws IOException { JMXConnector connector = JMXConnectorFactory.connect(url); setMBeanServerConnection(connector.getMBeanServerConnection()); } public void setMBeanServerConnection(String url) throws IOException { if (url.indexOf('/') == -1) { url = \"service:jmx:rmi:"}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import org.collectd.api.ValueList; import org.collectd.api.Notification;  public interface Dispatcher { public void dispatch(ValueList values); public void dispatch(Notification notification); }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.util.Properties; import java.util.logging.Logger;  public class Network { public static final int DEFAULT_PORT = 25826; public static final String DEFAULT_V4_ADDR = \"239.192.74.66\"; public static final String DEFAULT_V6_ADDR = \"ff18::efc0:4a42\"; public static final int TYPE_HOST = 0x0000; public static final int TYPE_TIME = 0x0001; public static final int TYPE_PLUGIN = 0x0002; public static final int TYPE_PLUGIN_INSTANCE = 0x0003; public static final int TYPE_TYPE = 0x0004; public static final int TYPE_TYPE_INSTANCE = 0x0005; public static final int TYPE_VALUES = 0x0006; public static final int TYPE_INTERVAL = 0x0007; public static final int TYPE_MESSAGE = 0x0100; public static final int TYPE_SEVERITY = 0x0101; public static final int DS_TYPE_COUNTER = 0; public static final int DS_TYPE_GAUGE = 1; static final int UINT8_LEN = 1; static final int UINT16_LEN = UINT8_LEN * 2; static final int UINT32_LEN = UINT16_LEN * 2; static final int UINT64_LEN = UINT32_LEN * 2; static final int HEADER_LEN = UINT16_LEN * 2; static final int BUFFER_SIZE = 1024; "}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import java.io.ByteArrayOutputStream; import java.io.DataOutputStream; import java.io.IOException; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.util.List; import org.collectd.api.DataSource; import org.collectd.api.PluginData; import org.collectd.api.ValueList;  public class PacketWriter { private ByteArrayOutputStream _bos; private DataOutputStream _os; private final TypesDB _types = TypesDB.getInstance(); public PacketWriter() { this(new ByteArrayOutputStream(Network.BUFFER_SIZE)); } public PacketWriter(ByteArrayOutputStream bos) { _bos = bos; _os = new DataOutputStream(_bos); } public int getSize() { return _bos.size(); } public byte[] getBytes() { return _bos.toByteArray(); } public boolean isFull() { return getSize() >= Network.BUFFER_SIZE; } public void reset() { _bos.reset(); } public void write(PluginData data) throws IOException { String type = data.getType(); writeString(Network.TYPE_HOST, data.getHost()); writeNumber(Network.TYPE_TIME, data.getTime()/1000); writeString(Network.TYPE_PLUGIN, data.getPlugin()); writeString(Network.TYPE_PLUGIN_INSTANCE, data.getPluginInstance()); writeString(Network.TYPE_TYPE, type); writeString(Network.TYPE_TYPE_INSTANCE, data.getTypeInstance()); if (data instanceof ValueList) { ValueList vl = (ValueList)data; List<DataSource> ds = _types.getType(type); List<Number> values = vl.getValues(); if ((ds != null) && (ds.size() != values.size())) { String msg = type + \" datasource mismatch, expecting \" + ds.size() + \", given \" + values.size(); throw new IOException(msg); } writeNumber(Network.TYPE_INTERVAL, vl.getInterval()); writeValues(ds, values); } else { "}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import java.io.IOException; import java.net.InetAddress; import org.collectd.api.PluginData; import org.collectd.api.ValueList; import org.collectd.api.Notification;  public abstract class Sender implements Dispatcher { private String _host = Network.getProperty(\"host\", Network.getProperty(\"hostname\")); public Sender() { } protected abstract void write(PluginData data) throws IOException; public abstract void flush() throws IOException; public abstract void addServer(String server); public String getHost() { if (_host == null) { try { _host = InetAddress.getLocalHost().getHostName(); } catch (IOException e) { _host = \"unknown\"; } } return _host; } public void setHost(String host) { _host = host; } protected void setDefaults(PluginData data) { if (data.getHost() == null) { data.setHost(getHost()); } if (data.getTime() <= 0) { data.setTime(System.currentTimeMillis()); } } public void dispatch(ValueList values) { try { setDefaults(values); write(values); } catch (IOException e) { "}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import java.util.ArrayList; import java.util.List; import org.collectd.api.DataSource; import org.collectd.api.ValueList; import org.collectd.api.Notification;  public class StdoutDispatcher implements Dispatcher { private boolean namesOnly = \"true\".equals(Network.getProperty(\"namesOnly\")); public void dispatch(ValueList vl) { if (namesOnly) { System.out.print(\"plugin=\" + vl.getPlugin()); System.out.print(\",pluginInstance=\" + vl.getPluginInstance()); System.out.print(\",type=\" + vl.getType()); System.out.print(\",typeInstance=\" + vl.getTypeInstance()); List<DataSource> ds = vl.getDataSource(); if (ds == null) { ds = TypesDB.getInstance().getType(vl.getType()); } if (ds != null) { List<String> names = new ArrayList<String>(); for (int i=0; i<ds.size(); i++) { names.add(ds.get(i).getName()); } System.out.print(\"-->\" + names); } System.out.println(); } else { System.out.println(vl); } } public void dispatch(Notification notification) { System.out.println(notification); } }"}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.StringTokenizer; import org.collectd.api.DataSource; import org.collectd.api.DataSet;  public class TypesDB { "}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import java.io.ByteArrayInputStream; import java.io.DataInputStream; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.MulticastSocket; import java.net.NetworkInterface; import java.net.SocketException; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.util.logging.Logger; import org.collectd.api.PluginData; import org.collectd.api.ValueList; import org.collectd.api.Notification;  public class UdpReceiver { private static final Logger _log = Logger.getLogger(UdpReceiver.class.getName()); private Dispatcher _dispatcher; private DatagramSocket _socket; private int _port = Network.DEFAULT_PORT; private String _bindAddress; private String _ifAddress; private boolean _isShutdown = false; protected UdpReceiver() { String addr = Network.getProperty(\"laddr\", Network.DEFAULT_V4_ADDR); if (addr != null) { int ix = addr.indexOf(':'); "}
{"name": "collectd/jcollectd", "content": " package org.collectd.protocol; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; import java.net.MulticastSocket; import java.net.SocketException; import java.util.ArrayList; import java.util.List; import org.collectd.api.PluginData;  public class UdpSender extends Sender { private List<InetSocketAddress> _servers; private DatagramSocket _socket; private MulticastSocket _mcast; private PacketWriter _writer; public UdpSender() { _servers = new ArrayList<InetSocketAddress>(); _writer = new PacketWriter(); } public void addServer(String server) { String ip; int ix = server.indexOf(':'); int port; if (ix == -1) { ip = server; port = Network.DEFAULT_PORT; } else { ip = server.substring(0, ix); port = Integer.parseInt(server.substring(ix+1)); } addServer(new InetSocketAddress(ip, port)); } public void addServer(InetSocketAddress server) { _servers.add(server); } private DatagramSocket getSocket() throws SocketException { if (_socket == null) { _socket = new DatagramSocket(); } return _socket; } private MulticastSocket getMulticastSocket() throws IOException { if (_mcast == null) { _mcast = new MulticastSocket(); _mcast.setTimeToLive(1); } return _mcast; } protected void write(PluginData data) throws IOException { setDefaults(data); int len = _writer.getSize(); _writer.write(data); if (_writer.getSize() >= Network.BUFFER_SIZE) { send(_writer.getBytes(), len); _writer.reset(); _writer.write(data);"}
{"name": "bradfitz/android-garage-opener", "content": "package com.danga.garagedoor; import android.app.Activity; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.ServiceConnection; import android.content.SharedPreferences; import android.net.Uri; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiManager; import android.os.Bundle; import android.os.Handler; import android.os.IBinder; import android.os.Message; import android.os.RemoteException; import android.provider.Settings; import android.view.Menu; import android.view.MenuItem; import android.view.View.OnClickListener; import android.view.View; import android.widget.Button; import android.widget.TextView; import java.util.List; public class GarageDoorActivity extends Activity { private static final String TAG = \"GarageDoorActivity\"; private static final int MENU_OPEN = 2; private static final int MENU_WIFI_OFF = 3; private static final int MENU_JUST_SCAN = 4; private static final int MENU_SETTINGS = 5; private static final int MENU_HELP = 6; private TextView textView; private TextView scanResultTextView; private IntentFilter intentFilter; private Handler logHandler = new Handler() { public void handleMessage(Message m) { String logMessage = m.getData().getString(\"logmessage\"); textView.setText(logMessage + \"\\n\" + textView.getText()); } }; private IGarageScanService scanServiceStub = null; private ServiceConnection serviceConnection = new ServiceConnection() { public void onServiceConnected(ComponentName name, IBinder service) { scanServiceStub = IGarageScanService.Stub.asInterface(service); log(\"Service bound\"); checkScanningState(); try { scanServiceStub.registerCallback(garageCallback); } catch (RemoteException e) { e.printStackTrace(); } } public void onServiceDisconnected(ComponentName name) { scanServiceStub = null; }; }; private IGarageScanCallback garageCallback = new IGarageScanCallback.Stub() { public void logToClient(String message) throws RemoteException { log(message); } public void onScanResults(String scanResults) throws RemoteException { scanResultTextView.setText(scanResults); } }; private SharedPreferences getPrefs() { return getSharedPreferences(Preferences.NAME, 0); }  @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); scanResultTextView = (TextView) findViewById(R.id.scanresults); textView = (TextView) findViewById(R.id.textthing); Button startScan = (Button) findViewById(R.id.StartScan); startScan.setOnClickListener(new OnClickListener() { public void onClick(View v) { startScanningService(false); } }); Button stopScan = (Button) findViewById(R.id.StopScan); stopScan.setOnClickListener(new OnClickListener() { public void onClick(View v) { if (scanServiceStub == null) { textView.setText(\"service stub is null\"); return; } try { scanServiceStub.setScanning(false); scanResultTextView.setText(\"\"); log(\"Stopped scanning.\"); } catch (RemoteException e) { log(\"Exception changing state: \" + e); } } }); intentFilter = new IntentFilter(); intentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION); intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION); intentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION); intentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION); intentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION); } protected void startScanningService(boolean debugMode) { if (scanServiceStub == null) { log(\"Not bound to service.\"); return; } try { scanServiceStub.setDebugMode(debugMode); scanResultTextView.setText(\"\"); Intent startScanning = new Intent(this, InRangeService.class); startScanning.setAction(InRangeService.ACTION_START_SCANNING); startService(startScanning); if (debugMode) { log(\"Scan-only mode started.\"); } else { log(\"Scanning mod started.\"); } } catch (RemoteException e) { log(\"Exception changing state: \" + e); } }  protected void checkScanningState() { if (scanServiceStub == null) { textView.setText(\"service stub is null\"); } else { boolean running; try { running = scanServiceStub.isScanning(); String state = running ? \"Scanning\" : \"NOT scanning\"; textView.setText(state + \"\\nURL: \" + getPrefs().getString(Preferences.KEY_URL, \"<no_url>\")); } catch (RemoteException e) { textView.setText(\"Exception error checking scanning: \" + e); } } } @Override public void onResume() { super.onResume(); textView.setText(\"onResume\"); bindService(new Intent(this, InRangeService.class), serviceConnection, Context.BIND_AUTO_CREATE); } @Override public void onPause() { super.onPause(); if (scanServiceStub != null) { try { scanServiceStub.unregisterCallback(garageCallback); } catch (RemoteException e) { e.printStackTrace(); } } if (serviceConnection != null) { unbindService(serviceConnection); } } View.OnClickListener createWifiAPairer(final String ssid) { return new OnClickListener() { public void onClick(View v) { Settings.System.putInt(getContentResolver(), Settings.System.WIFI_USE_STATIC_IP, 0); WifiManager wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE); List<WifiConfiguration> networks = wifiManager.getConfiguredNetworks(); WifiConfiguration foundConfig = null; for (WifiConfiguration config : networks) { if (config.SSID.equals(\"\\\"\" + ssid + \"\\\"\")) { foundConfig = config; break; } textView.setText(config.SSID + \", \" + new Integer(config.SSID.length())); } if (foundConfig != null) { textView.setText(new StringBuilder().append(foundConfig.networkId)); int n = 0; try { boolean success = wifiManager.enableNetwork(foundConfig.networkId, true); textView.setText(new Boolean(success).toString()); if (success) { textView.setText(\"Connecting to: \" + ssid); } } catch (Exception e) { textView.setText(e.toString() + \", \" + n); } } else { textView.setText(ssid + \" not found\"); } } }; } @Override public boolean onCreateOptionsMenu(Menu menu) { super.onCreateOptionsMenu(menu); menu.add(Menu.NONE, MENU_WIFI_OFF, 0, \"Wifi Off\"); menu.add(Menu.NONE, MENU_OPEN, 0, \"Open Now\"); menu.add(Menu.NONE, MENU_JUST_SCAN, 0, \"Just Scan\"); menu.add(Menu.NONE, MENU_HELP, 0, \"Help\"); menu.add(Menu.NONE, MENU_SETTINGS, 0, \"Settings\"); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case MENU_OPEN: try { scanServiceStub.openGarageNow(); } catch (RemoteException e) { log(e.toString()); } break; case MENU_WIFI_OFF: wifi().disconnect(); break; case MENU_JUST_SCAN: startScanningService(true); break; case MENU_SETTINGS: SettingsActivity.show(this); break; case MENU_HELP: final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"http:"}
{"name": "bradfitz/android-garage-opener", "content": "package com.danga.garagedoor; import android.app.PendingIntent; import android.appwidget.AppWidgetManager; import android.appwidget.AppWidgetProvider; import android.content.Context; import android.content.Intent; import android.util.Log; import android.widget.RemoteViews; public class GarageOpenAppWidgetProvider extends AppWidgetProvider { private static final String TAG = \"GarageWidget\"; private static final String ACTION_OPEN_NOW = \"OPEN_GARAGE_NOW\"; @Override public void onDeleted(Context context, int[] appWidgetIds) { super.onDeleted(context, appWidgetIds); Log.d(TAG, \"onDeleted\"); } @Override public void onEnabled(Context context) { super.onEnabled(context); Log.d(TAG, \"onEnabled\"); } @Override public void onReceive(Context context, Intent intent) { super.onReceive(context, intent); Log.d(TAG, \"onReceive: \" + intent); if (ACTION_OPEN_NOW.equals(intent.getAction())) { Intent in = new Intent(context, InRangeService.class); in.putExtra(InRangeService.EXTRA_KEY_OPEN_TYPE, InRangeService.EXTRA_OPEN_TYPE_IF_IN_RANGE); context.startService(in); } } @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { super.onUpdate(context, appWidgetManager, appWidgetIds); Log.d(TAG, \"onUpdate\"); final int n = appWidgetIds.length; for (int i = 0; i < n; i++) { int appWidgetId = appWidgetIds[i]; RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget); Intent intent = new Intent(context, getClass()); intent.setAction(ACTION_OPEN_NOW); views.setOnClickPendingIntent(R.id.btn_widget_open, PendingIntent.getBroadcast(context, 0, intent, 0)); appWidgetManager.updateAppWidget(appWidgetId, views); } } }"}
{"name": "bradfitz/android-garage-opener", "content": "package com.danga.garagedoor; import android.app.Notification; import android.app.NotificationManager; import android.app.PendingIntent; import android.app.Service; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.SharedPreferences; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.net.wifi.ScanResult; import android.net.wifi.WifiManager; import android.os.Bundle; import android.os.Handler; import android.os.IBinder; import android.os.PowerManager; import android.os.RemoteCallbackList; import android.os.RemoteException; import android.os.Vibrator; import android.util.Log; import android.widget.Toast; import java.io.IOException; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.Date; import java.util.List; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicLong; import javax.crypto.Mac; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import org.apache.http.HttpResponse; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.HttpClient; import org.apache.http.client.ResponseHandler; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.impl.client.DefaultHttpClient; public class InRangeService extends Service { public static final String EXTRA_KEY_OPEN_TYPE = \"open_type\"; public static final String EXTRA_OPEN_TYPE_IF_IN_RANGE = \"if_in_range\"; public static final String ACTION_START_SCANNING = \"START_SCANNING\"; private static final String TAG = \"InRangeService\"; private static final int NOTIFY_ID_SCANNING = 1; private static final int NOTIFY_ID_EVENT = 2; private AtomicBoolean isScanning = new AtomicBoolean(false); private AtomicBoolean scanTimerOutstanding = new AtomicBoolean(false); "}
{"name": "bradfitz/android-garage-opener", "content": "/* * Copyright (C) 2010 Brad Fitzpatrick <brad@danga.com> * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "bradfitz/android-garage-opener", "content": "package com.danga.garagedoor; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.content.SharedPreferences; import android.net.Uri; import android.os.Bundle; import android.os.IBinder; import android.os.RemoteException; import android.preference.CheckBoxPreference; import android.preference.EditTextPreference; import android.preference.ListPreference; import android.preference.Preference.OnPreferenceChangeListener; import android.preference.Preference; import android.preference.PreferenceActivity; import android.util.Log; import android.view.Menu; import android.view.MenuItem; public class SettingsActivity extends PreferenceActivity { private static final String TAG = \"SettingsActivity\"; private static final int MENU_HELP = 0; private EditTextPreference ssidPref; private EditTextPreference urlPref; private EditTextPreference secretPref; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getPreferenceManager().setSharedPreferencesName(Preferences.NAME); addPreferencesFromResource(R.xml.preferences); ssidPref = (EditTextPreference) findPreference(Preferences.KEY_SSID); urlPref = (EditTextPreference) findPreference(Preferences.KEY_URL); secretPref = (EditTextPreference) findPreference(Preferences.KEY_SECRET); OnPreferenceChangeListener onChange = new OnPreferenceChangeListener() { @Override public boolean onPreferenceChange(Preference preference, Object newValue) { final String key = preference.getKey(); Log.v(TAG, \"preference change for: \" + key); return true; "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import com.googlecode.jslint4java.formatter.CheckstyleXmlFormatter; import com.googlecode.jslint4java.formatter.JSLintResultFormatter; public class CheckstyleXmlResultFormatter extends XmlResultFormatter implements ResultFormatter { @Override protected JSLintResultFormatter createFormatter() { return new CheckstyleXmlFormatter(); } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import java.io.File; import java.io.OutputStream; import org.apache.tools.ant.BuildException;  public class FormatterElement {  public static enum Type { plain() { @Override public ResultFormatter getResultFormatter() { return new PlainResultFormatter(); } }, xml() { @Override public ResultFormatter getResultFormatter() { return new XmlResultFormatter(); } }, junit() { @Override ResultFormatter getResultFormatter() { return new JUnitXmlResultFormatter(); } }, report() { @Override ResultFormatter getResultFormatter() { return new ReportResultFormatter(); } }, checkstyle() { @Override ResultFormatter getResultFormatter() { return new CheckstyleXmlResultFormatter(); } }; abstract ResultFormatter getResultFormatter(); } private Type type; private OutputStream defaultOutputStream = System.out; private File destFile;  public ResultFormatter getResultFormatter() { if (type == null) throw new BuildException(\"you must specify type\"); ResultFormatter rf = type.getResultFormatter(); rf.setStdout(defaultOutputStream); if (destFile != null) { rf.setFile(destFile); } return rf; }  void setDefaultOutputStream(OutputStream defaultOutputStream) { this.defaultOutputStream = defaultOutputStream; }  public void setDestFile(File destFile) { this.destFile = destFile; }  public void setType(Type type) { this.type = type; } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.UnsupportedEncodingException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Map.Entry; import org.apache.tools.ant.BuildException; import org.apache.tools.ant.Project; import org.apache.tools.ant.Task; import org.apache.tools.ant.taskdefs.LogOutputStream; import org.apache.tools.ant.types.Resource; import org.apache.tools.ant.types.ResourceCollection; import org.apache.tools.ant.types.resources.Union; import com.googlecode.jslint4java.JSLint; import com.googlecode.jslint4java.JSLintBuilder; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.Option; import com.googlecode.jslint4java.UnicodeBomInputStream; /** * Run {@link JSLint} over a tree of files in order to pick holes in your * JavaScript. * * <p> * Example build.xml usage: * * <pre> * &lt;project name=&quot;build-test&quot; xmlns:jsl=&quot;antlib:com.googlecode.jslint4java&quot;&gt; * &lt;target name=&quot;jslint&quot;&gt; * &lt;jsl:jslint options=&quot;es5&quot;&gt; * &lt;formatter type=&quot;plain&quot; /&gt; * &lt;fileset dir=&quot;.&quot; includes=&quot;*.js&quot; excludes=&quot;*.pack.js&quot; /&gt; * &lt;/jsl:jslint&gt; * &lt;/target&gt; * &lt;/project * </pre> * * <p> * You have to specify one or more nested <i>fileset</i> elements. You may * optionally specify a <i>formatter</i> element in order to generate output (as * opposed to just a build failed message). Usually, you will want the plain * formatter, but in case you want to generate a report, the xml formatter * mighht be useful. * * <h3>Attributes</h3> * * <dl> * <dt><code>encoding</code></dt> * <dd>Optional. The encoding of the JavaScript files. Defaults to system * encoding.</dd> * <dt><code>haltOnFailure</code></dt> * <dd>Optional. Specify if the build should fail if there are files which do * not pass JSLint. Defaults to true.</dd> * <dt><code>options</code></dt> * <dd>Optional. A comma separated list of {@link Option} names. No default.</dd> * <dt><code>timeout</code> * <dd>Optional. The maximum amount of time that JSLint can run. * </dl> * * @author dom * @see <a href=\"http:"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import java.io.BufferedWriter; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.Writer; import org.apache.tools.ant.BuildException; import org.apache.tools.ant.util.FileUtils; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.formatter.JSLintResultFormatter; import com.googlecode.jslint4java.formatter.JUnitXmlFormatter;  public class JUnitXmlResultFormatter implements ResultFormatter { private File file; private final JSLintResultFormatter form = new JUnitXmlFormatter(); public void begin() { if (file == null) { throw new BuildException(\"must set destFile attribute\"); } if (file.exists()) { if (!file.isDirectory()) { throw new BuildException(file + \" must be a directory\"); } } else { if (!file.mkdirs()) { throw new BuildException(\"failed to make directory \" + file); } } } public void end() { file = null; } public void output(JSLintResult result) { File f = new File(file, testFileName(result)); Writer w = null; try { w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\")); if (form.header() != null) { w.write(form.header()); } w.write(form.format(result)); if (form.footer() != null) { w.write(form.footer()); } } catch (IOException e) { throw new BuildException(e); } finally { FileUtils.close(w); } } public void setFile(File file) { this.file = file; } public void setStdout(OutputStream defaultOutputStream) { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import java.io.BufferedWriter; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintWriter; import org.apache.tools.ant.BuildException; import org.apache.tools.ant.util.FileUtils; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.formatter.JSLintResultFormatter; import com.googlecode.jslint4java.formatter.PlainFormatter;  public class PlainResultFormatter implements ResultFormatter { protected OutputStream out; protected PrintWriter w = null; private final JSLintResultFormatter form = new PlainFormatter(); public void begin() { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import org.apache.tools.ant.Project;  public class PredefElement { private final Project project; private final StringBuffer sb = new StringBuffer(); public PredefElement(Project project) { this.project = project; }  public void addText(String s) { sb.append(project.replaceProperties(s)); }  public String getText() { return sb.toString(); } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import java.io.BufferedWriter; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.Writer; import org.apache.tools.ant.BuildException; import org.apache.tools.ant.util.FileUtils; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.formatter.ReportFormatter;  public class ReportResultFormatter implements ResultFormatter { private final ReportFormatter formatter = new ReportFormatter(); private OutputStream out; private final StringBuilder sb = new StringBuilder(); public void begin() { if (out == null) { throw new BuildException(\"destFile not specified\"); } if (formatter.header() != null) { sb.append(formatter.header()); } } public void end() { if (formatter.footer() != null) { sb.append(formatter.footer()); } Writer w = null; try { w = new BufferedWriter(new OutputStreamWriter(out, \"UTF8\")); w.write(sb.toString()); w.flush(); } catch (IOException exc) { throw new BuildException(\"Unable to write log file\", exc); } finally { FileUtils.close(w); } out = null; sb.delete(0, sb.length() - 1); } public void output(JSLintResult result) { sb.append(formatter.format(result)); } public void setFile(File file) { try { out = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new BuildException(e); } } public void setStdout(OutputStream defaultOutputStream) { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import java.io.File; import java.io.OutputStream; import com.googlecode.jslint4java.JSLintResult;  public interface ResultFormatter {  public abstract void begin();  public abstract void end();  public abstract void output(JSLintResult result);  public abstract void setFile(File file);  public abstract void setStdout(OutputStream defaultOutputStream); }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.ant; import java.io.BufferedWriter; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.Writer; import org.apache.tools.ant.BuildException; import org.apache.tools.ant.util.FileUtils; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.formatter.JSLintResultFormatter; import com.googlecode.jslint4java.formatter.JSLintXmlFormatter;  public class XmlResultFormatter implements ResultFormatter { private final JSLintResultFormatter form; private final StringBuilder sb = new StringBuilder(); private OutputStream out; public XmlResultFormatter() { form = createFormatter(); }  protected JSLintResultFormatter createFormatter() { return new JSLintXmlFormatter(); } public void begin() { if (out == null) throw new BuildException(\"must specify destFile for xml output\"); "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.maven; import java.io.File; import java.io.IOException; import java.util.List; import org.codehaus.plexus.util.FileUtils; import org.codehaus.plexus.util.StringUtils; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists;  public class FileLister { private final List<String> includes = Lists.newArrayList(); private final List<String> excludes = Lists.newArrayList(); private final File sourceDirectory; public FileLister(File sourceDirectory, List<String> includes, List<String> excludes) { this.sourceDirectory = sourceDirectory; this.includes.addAll(includes); this.excludes.addAll(excludes); this.excludes.addAll(FileUtils.getDefaultExcludesAsList()); } public List<File> files() throws IOException { if (!sourceDirectory.exists()) { return ImmutableList.of(); } String includesStr = StringUtils.join(includes.iterator(), \",\"); String excludesStr = StringUtils.join(excludes.iterator(), \",\"); return FileUtils.getFiles(sourceDirectory, includesStr, excludesStr); } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.maven; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStreamReader; import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Map.Entry; import org.apache.maven.plugin.AbstractMojo; import org.apache.maven.plugin.MojoExecutionException; import org.apache.maven.plugin.MojoFailureException; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import com.google.common.annotations.VisibleForTesting; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.io.Closeables; import com.googlecode.jslint4java.JSLint; import com.googlecode.jslint4java.JSLintBuilder; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.Option; import com.googlecode.jslint4java.UnicodeBomInputStream; import com.googlecode.jslint4java.formatter.CheckstyleXmlFormatter; import com.googlecode.jslint4java.formatter.JSLintResultFormatter; import com.googlecode.jslint4java.formatter.JSLintXmlFormatter; import com.googlecode.jslint4java.formatter.JUnitXmlFormatter; import com.googlecode.jslint4java.formatter.PlainFormatter; import com.googlecode.jslint4java.formatter.ReportFormatter;  "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.maven; import java.util.Arrays; import java.util.List; import com.google.common.io.Closeables; import com.googlecode.jslint4java.JSLintResult;  public class MultiReportWriter implements ReportWriter { private final List<ReportWriter> reportWriters;  public MultiReportWriter(ReportWriter... reportWriters) { this.reportWriters = Arrays.asList(reportWriters); }  public void close() { for (ReportWriter reportWriter : reportWriters) { Closeables.closeQuietly(reportWriter); } }  public void open() { for (ReportWriter reportWriter : reportWriters) { reportWriter.open(); } }  public void report(JSLintResult result) { for (ReportWriter reportWriter : reportWriters) { reportWriter.report(result); } } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.maven; import java.io.Closeable; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.formatter.JSLintResultFormatter;  public interface ReportWriter extends Closeable {  void close();  void open();  void report(JSLintResult result); }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.maven; import java.io.BufferedWriter; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.nio.charset.Charset; import com.google.common.base.Throwables; import com.google.common.io.Closeables; import com.google.common.io.Files; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.formatter.JSLintResultFormatter;  public class ReportWriterImpl implements ReportWriter { private final File reportFile; private final JSLintResultFormatter formatter; private BufferedWriter writer; public ReportWriterImpl(File reportFile, JSLintResultFormatter formatter) { this.reportFile = reportFile; this.formatter = formatter; } public void close() { try { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import org.mozilla.javascript.Scriptable;  public class Issue {  public static class IssueBuilder {  public static Issue fromJavaScript(String systemId, Scriptable err) { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.util.ArrayList; import java.util.List;  public class JSFunction {  public static class Builder { private final List<String> closures = new ArrayList<String>(); private final List<String> exceptions = new ArrayList<String>(); private final List<String> globals = new ArrayList<String>(); private final List<String> labels = new ArrayList<String>(); private int last; private final int line; private final String name; private final List<String> outers = new ArrayList<String>(); private final List<String> params = new ArrayList<String>(); private final List<String> unuseds = new ArrayList<String>(); private final List<String> vars = new ArrayList<String>(); public Builder(String name, int line) { this.name = name; this.line = line; } public Builder addClosure(String closure) { closures.add(closure); return this; } public Builder addException(String exception) { exceptions.add(exception); return this; } public Builder addGlobal(String global) { globals.add(global); return this; } public Builder addLabel(String label) { labels.add(label); return this; } public Builder addOuter(String outer) { outers.add(outer); return this; } public Builder addParam(String param) { params.add(param); return this; } public Builder addUnused(String unused) { unuseds.add(unused); return this; } public Builder addVar(String var) { vars.add(var); return this; } public JSFunction build() { return new JSFunction(this); } public Builder last(int last) { this.last = last; return this; } } private final List<String> closure = new ArrayList<String>(); private final List<String> exception = new ArrayList<String>(); private final List<String> global = new ArrayList<String>(); private final List<String> label = new ArrayList<String>(); private final int last; private final int line; private final String name; private final List<String> outer = new ArrayList<String>(); private final List<String> params = new ArrayList<String>(); private final List<String> unused = new ArrayList<String>(); private final List<String> vars = new ArrayList<String>(); private JSFunction(Builder builder) { name = builder.name; line = builder.line; last = builder.last; closure.addAll(builder.closures); exception.addAll(builder.exceptions); global.addAll(builder.globals); label.addAll(builder.labels); outer.addAll(builder.outers); params.addAll(builder.params); unused.addAll(builder.unuseds); vars.addAll(builder.vars); }  public List<String> getClosure() { return closure; }  public List<String> getException() { return exception; }  public List<String> getGlobal() { return global; }  public List<String> getLabel() { return label; } public int getLast() { return last; }  public int getLine() { return line; }  public String getName() { return name; }  public List<String> getOuter() { return outer; }  public List<String> getParams() { return params; }  public List<String> getUnused() { return unused; }  public List<String> getVars() { return vars; } @Override public String toString() { return String.format(\"function %s()\", getName()); } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.io.IOException; import java.io.Reader; import java.util.ArrayList; import java.util.EnumMap; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.concurrent.TimeUnit; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextAction; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.Function; import org.mozilla.javascript.Scriptable; import org.mozilla.javascript.ScriptableObject; import org.mozilla.javascript.UniqueTag; import com.googlecode.jslint4java.Issue.IssueBuilder; import com.googlecode.jslint4java.JSFunction.Builder; import com.googlecode.jslint4java.JSLintResult.ResultBuilder;  public class JSLint { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.nio.charset.Charset; import java.util.concurrent.TimeUnit; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.Function; import org.mozilla.javascript.ScriptableObject;  public class JSLintBuilder { private static final String JSLINT_FILE = \"com/googlecode/jslint4java/jslint.js\"; private static final Charset UTF8 = Charset.forName(\"UTF-8\"); private ContextFactory contextFactory = new ContextFactory();  public JSLint fromClasspathResource(String resource) throws IOException { return fromClasspathResource(resource, UTF8); }  public JSLint fromClasspathResource(String resource, Charset encoding) throws IOException { Reader reader = new BufferedReader(new InputStreamReader(getClass().getClassLoader() .getResourceAsStream(resource), encoding)); return fromReader(reader, resource); }  public JSLint fromDefault() { try { return fromClasspathResource(JSLINT_FILE); } catch (IOException e) { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class JSLintResult {  public static class ResultBuilder { private long duration; private final List<JSFunction> functions = new ArrayList<JSFunction>(); private final List<String> globals = new ArrayList<String>(); private final List<Issue> issues = new ArrayList<Issue>(); private boolean json; private final String name; private String report; private final List<String> urls = new ArrayList<String>(); private final Set<String> properties = new HashSet<String>(); public ResultBuilder(String name) { this.name = name; } public ResultBuilder addFunction(JSFunction f) { functions.add(f); return this; } public ResultBuilder addGlobal(String global) { globals.add(global); return this; } public ResultBuilder addIssue(Issue issue) { issues.add(issue); return this; } public ResultBuilder addProperty(String prop) { properties.add(prop); return this; } public ResultBuilder addUrl(String url) { urls.add(url); return this; } public JSLintResult build() { return new JSLintResult(this); } public ResultBuilder duration(long millis) { duration = millis; return this; } public ResultBuilder json(boolean json) { this.json = json; return this; } public ResultBuilder report(String report) { this.report = report; return this; } } private final long duration; private final List<JSFunction> functions = new ArrayList<JSFunction>(); private final List<String> globals = new ArrayList<String>(); private final List<Issue> issues = new ArrayList<Issue>(); private final boolean json; private final String name; private final String report; private final List<String> urls = new ArrayList<String>(); private final Set<String> properties = new HashSet<String>(); private JSLintResult(ResultBuilder b) { name = b.name; duration = b.duration; issues.addAll(b.issues); functions.addAll(b.functions); globals.addAll(b.globals); json = b.json; report = b.report; urls.addAll(b.urls); properties.addAll(b.properties); }  public long getDuration() { return duration; }  public List<JSFunction> getFunctions() { return functions; }  public List<String> getGlobals() { return globals; }  public List<Issue> getIssues() { return issues; }  public String getName() { return name; } public Set<String> getProperties() { return properties; }  public String getReport() { return report; }  public List<String> getUrls() { return urls; }  public boolean isJson() { return json; } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory;  @Retention(RetentionPolicy.SOURCE) @Target({ ElementType.METHOD, ElementType.CONSTRUCTOR }) @Documented public @interface NeedsContext { }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.util.Locale;  public enum Option { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method;  class OptionParser {  public <T> T parse(Class<T> clazz, String value) { try { Method method = clazz.getMethod(\"valueOf\", String.class); "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java;  public final class StringArray { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.util.concurrent.TimeUnit; import org.mozilla.javascript.Callable; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.Scriptable;  public class TimeLimitedContextFactory extends ContextFactory {  private static final int OPS_QUANTUM = 10000; @SuppressWarnings(\"serial\") public static class TimeExceededException extends IllegalStateException { public TimeExceededException() { super(); } } private static class TimeLimitedContext extends Context { public TimeLimitedContext(TimeLimitedContextFactory timeLimitedContextFactory) { super(timeLimitedContextFactory); } private long startTime; } private final long maxTimeNanos;  public TimeLimitedContextFactory(long maxTime, TimeUnit timeUnit) { maxTimeNanos = timeUnit.toNanos(maxTime); }  @Override protected Context makeContext() { TimeLimitedContext cx = new TimeLimitedContext(this); cx.setInstructionObserverThreshold(OPS_QUANTUM); return cx; }  @Override protected Object doTopCall(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) { TimeLimitedContext tlcx = (TimeLimitedContext) cx; tlcx.startTime = System.nanoTime(); return super.doTopCall(callable, tlcx, scope, thisObj, args); }  @Override protected void observeInstructionCount(Context cx, int instructionCount) { TimeLimitedContext tlcx = (TimeLimitedContext) cx; long currentTime = System.nanoTime(); long durationNanos = currentTime - tlcx.startTime; if (durationNanos > maxTimeNanos) { throw new TimeExceededException(); } } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.io.IOException; import java.io.InputStream; import java.io.PushbackInputStream; /** * The <code>UnicodeBOMInputStream</code> class wraps any * <code>InputStream</code> and detects the presence of any Unicode BOM (Byte * Order Mark) at its beginning, as defined by <a * href=\"http:"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java; import java.io.IOException; import java.io.Reader; import java.util.ArrayList; import java.util.List; import org.mozilla.javascript.Context; import org.mozilla.javascript.NativeArray; import org.mozilla.javascript.NativeJavaArray; import org.mozilla.javascript.Scriptable; import org.mozilla.javascript.Undefined; import org.mozilla.javascript.UniqueTag;  final class Util { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.cli; import java.nio.charset.Charset; import java.nio.charset.IllegalCharsetNameException; import java.nio.charset.UnsupportedCharsetException; import com.beust.jcommander.IStringConverter; import com.beust.jcommander.ParameterException;  public class CharsetConverter implements IStringConverter<Charset> { public Charset convert(String value) { try { return Charset.forName(value); } catch (IllegalCharsetNameException e) { throw new ParameterException(\"unknown encoding '\" + value + \"'\"); } catch (UnsupportedCharsetException e) { throw new ParameterException(\"unknown encoding '\" + value + \"'\"); } } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.cli; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.List; import com.beust.jcommander.Parameter;  class Flags { @Parameter(names = \"--encoding\", description = \"Specify the input encoding\", converter = CharsetConverter.class) public Charset encoding; @Parameter(names = \"--jslint\", description = \"Specify an alternative version of jslint.js\") public String jslint; @Parameter(names = \"--help\", description = \"Display usage information\") public boolean help; @Parameter(names = \"--report\", description = \"Display report in different formats: plain, xml, junit, checkstyle and report\") public String report; @Parameter(names = \"--timeout\", description = \"Maximum number of seconds JSLint can run for\") public long timeout = 0; @Parameter(names = \"--version\", description = \"Show the version of JSLint in use.\") public boolean version;  @Parameter(description = \"file.js ...\") public List<String> files = new ArrayList<String>(); }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.cli; import com.beust.jcommander.Parameter;  class JSLintFlags { "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.cli; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.Charset; import java.util.Collections; import java.util.Comparator; import java.util.List; import com.beust.jcommander.JCommander; import com.beust.jcommander.ParameterDescription; import com.beust.jcommander.ParameterException; import com.beust.jcommander.Parameterized; import com.googlecode.jslint4java.Issue; import com.googlecode.jslint4java.JSLint; import com.googlecode.jslint4java.JSLintBuilder; import com.googlecode.jslint4java.JSLintResult; import com.googlecode.jslint4java.Option; import com.googlecode.jslint4java.UnicodeBomInputStream; import com.googlecode.jslint4java.formatter.CheckstyleXmlFormatter; import com.googlecode.jslint4java.formatter.JSLintResultFormatter; import com.googlecode.jslint4java.formatter.JSLintXmlFormatter; import com.googlecode.jslint4java.formatter.JUnitXmlFormatter; import com.googlecode.jslint4java.formatter.PlainFormatter; import com.googlecode.jslint4java.formatter.ReportFormatter;  class Main { private static final class ParameterDescriptionComparator implements Comparator<ParameterDescription> { public int compare(ParameterDescription a, ParameterDescription b) { return a.getLongestName().compareTo(b.getLongestName()); } }  private static final class DefaultFormatter implements JSLintResultFormatter { public String format(JSLintResult result) { if (result.getIssues().isEmpty()) { return \"\"; } String nl = System.getProperty(\"line.separator\"); StringBuilder sb = new StringBuilder(); for (Issue issue : result.getIssues()) { sb.append(PROGNAME); sb.append(':'); sb.append(issue.toString()); sb.append(nl); } "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.formatter; import com.googlecode.jslint4java.Issue; import com.googlecode.jslint4java.JSLint; import com.googlecode.jslint4java.JSLintResult; public class CheckstyleXmlFormatter extends XmlFormatter implements JSLintResultFormatter { @Override protected String root() { return \"checkstyle\"; } public String format(JSLintResult result) { StringBuilder sb = new StringBuilder(\"<file\"); sb.append(attr(\"name\", result.getName())); sb.append(\">\\n\"); for (Issue issue : result.getIssues()) { sb.append(\"<error\"); sb.append(attr(\"line\", Integer.toString(issue.getLine()))); sb.append(attr(\"column\", Integer.toString(issue.getCharacter()))); "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.formatter; import com.googlecode.jslint4java.JSLintResult;  public interface JSLintResultFormatter {  String footer();  String format(JSLintResult result);  String header(); }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.formatter; import java.util.List; import com.googlecode.jslint4java.Issue; import com.googlecode.jslint4java.JSLintResult;  public class JSLintXmlFormatter extends XmlFormatter implements JSLintResultFormatter { private static final String NEWLINE = System.getProperty(\"line.separator\"); public String format(JSLintResult result) { StringBuilder sb = new StringBuilder(\"<file\"); sb.append(attr(\"name\", result.getName())); sb.append(\">\" + NEWLINE); List<Issue> issues = result.getIssues(); for (Issue issue : issues) { sb.append(\"<issue\"); sb.append(attr(\"line\", Integer.toString(issue.getLine()))); sb.append(attr(\"char\", Integer.toString(issue.getCharacter()))); sb.append(attr(\"reason\", issue.getReason())); sb.append(attr(\"evidence\", issue.getEvidence())); sb.append(\"/>\" + NEWLINE); } sb.append(\"</file>\"); return sb.toString(); } @Override protected String root() { return \"jslint\"; } }"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.formatter; import java.util.List; import java.util.Locale; import com.googlecode.jslint4java.Issue; import com.googlecode.jslint4java.JSLintResult; /** * After a bit of experimentation, this seems to be the best way to represent * JSLint output in JUnit format: * * <pre> * <!-- All OK --> * &lt;testsuite failures=\"0\" time=\"0.131\" errors=\"0\" skipped=\"0\" tests=\"1\" name=\"good.js\"> * &lt;testcase time=\"0.022\" classname=\"com.googlecode.jslint4java\" name=\"good.js\"/> * &lt;/testsuite> * </pre> * * <pre> * &lt;testsuite failures=\"1\" time=\"0.2\" errors=\"0\" skipped=\"0\" tests=\"1\" name=\"bad.js\"> * &lt;testcase time=\"0.078\" classname=\"com.googlecode.jslint4java\" name=\"bad.js\"> * &lt;failure message=\"Found 11 problems\" type=\"java.lang.AssertionError\"> * prettify.js:54:8:['PR_SHOULD_USE_CONTINUATION'] is better written in dot notation. * prettify.js:57:8:['PR_TAB_WIDTH'] is better written in dot notation. * prettify.js:63:8:['PR_normalizedHtml'] is better written in dot notation. * prettify.js:68:3:Bad line breaking before '='. * prettify.js:68:12:['PR'] is better written in dot notation. * prettify.js:75:3:Bad line breaking before '='. * prettify.js:75:12:['prettyPrintOne'] is better written in dot notation. * prettify.js:81:3:Bad line breaking before '='. * prettify.js:81:12:['prettyPrint'] is better written in dot notation. * prettify.js:81:29:Expected an identifier and instead saw 'void'. * prettify.js:81:29:Stopping, unable to continue. (5% scanned). * &lt;/failure> * &lt;/testcase> * &lt;/testsuite> * </pre> * * After a bit of testing in <a * href=\"http:"}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.formatter; import com.googlecode.jslint4java.Issue; import com.googlecode.jslint4java.JSLintResult;  public class PlainFormatter implements JSLintResultFormatter {  public String footer() { return null; } public String format(JSLintResult result) { StringBuilder sb = new StringBuilder(); for (Issue issue : result.getIssues()) { sb.append(outputOneIssue(issue)); } return sb.toString(); }  public String header() { return null; } private String outputOneIssue(Issue issue) { String nl = System.getProperty(\"line.separator\"); StringBuilder sb = new StringBuilder(); sb.append(issue.getSystemId()); sb.append(':'); sb.append(issue.getLine()); sb.append(':'); sb.append(issue.getCharacter()); "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.formatter; import com.googlecode.jslint4java.JSLintResult;  public class ReportFormatter extends XmlFormatter implements JSLintResultFormatter { @Override public String footer() { return \"</body></html>\"; } public String format(JSLintResult result) { String name = result.getName(); StringBuilder sb = new StringBuilder(); sb.append(\"<div class='file'>\"); sb.append(\"<h1\"); sb.append(attr(\"id\", name)); sb.append(\">\"); sb.append(escape(name)); sb.append(\"</h1>\"); sb.append(result.getReport()); sb.append(\"</div>\"); "}
{"name": "happygiraffe/jslint4java", "content": "package com.googlecode.jslint4java.formatter;  public abstract class XmlFormatter { protected String attr(String key, String value) { if (key == null) throw new IllegalArgumentException(\"key cannot be null\"); if (value == null) { value = \"\"; } StringBuilder sb = new StringBuilder(' '); sb.append(' '); sb.append(escapeAttr(key)); sb.append(\"='\"); sb.append(escapeAttr(value)); sb.append(\"'\"); return sb.toString(); } protected String escape(String str) { if (str == null) return \"\"; return str.replaceAll(\"&\", \"&amp;\").replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\"); } private String escapeAttr(String str) { return escape(str).replaceAll(\"\\\"\", \"&quot;\").replaceAll(\"\\'\", \"&apos;\"); } public String footer() { return \"</\" + root() + \">\"; } public String header() { return \"<\" + root() + \">\"; }  protected abstract String root(); }"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) CustomLoggerFactory.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. Copyright (C) 2008 Karthik Kumar. Licensed under * the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ArithmeticEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) CastEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) CompareEvaluator.java * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ConditionBiOperatorEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ConditionNullEvaluator.java * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ConditionUniOperatorEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) DupEvaluator.java * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ILoadEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ILoadEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) NonStaticFieldAccessorEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) InvokeEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.ast.evaluator; import java.util.Arrays; import java.util.List; import org.jreversepro.ast.expression.Expression; import org.jreversepro.ast.expression.InstanceMethodAccessExpression; import org.jreversepro.ast.expression.MethodAccessExpression; import org.jreversepro.jvm.TypeInferrer; import org.jreversepro.reflect.instruction.Instruction; public class InvokeSpecialEvaluator extends InvokeEvaluator { public InvokeSpecialEvaluator(EvaluatorContext context) { super(context); "}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.ast.evaluator; import java.util.Arrays; import java.util.List; import org.jreversepro.ast.expression.Expression; import org.jreversepro.ast.expression.MethodAccessExpression; import org.jreversepro.ast.expression.StaticMethodAccessExpression; import org.jreversepro.ast.intermediate.CompleteLine; import org.jreversepro.jvm.TypeInferrer; import org.jreversepro.reflect.instruction.Instruction; public class InvokeStaticEvaluator extends InvokeEvaluator { public InvokeStaticEvaluator(EvaluatorContext context) { super(context); "}
{"name": "akkumar/jreversepro", "content": "/** * @(#) JSREvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) LogicalOpEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) MonitorEvaluator.java * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) NegateEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) NewArrayEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ReferenceTypeInfoEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ReturnEvaluator.java * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) RuntimeFrame.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) FieldReferenceEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) SwitchEvaluator.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ArrayInstantiationExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ArrayLengthExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) Assignment.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) BinaryOpExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ConditionExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) Expression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/* * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) FieldAccessExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.ast.expression; import org.jreversepro.jls.JLSConstants; public class InstanceFieldAccessExpression extends FieldAccessExpression { private final Expression accessTarget; public InstanceFieldAccessExpression(Expression accessTarget, String fieldName, String fieldType) { super(fieldName, fieldType); this.accessTarget = accessTarget; }  @Override public String getJLSCode() { String objName = accessTarget.getJLSCode(); String target = \"\"; if (!objName.equals(JLSConstants.THIS)) { target = objName + JLSConstants.JLS_PACKAGE_DELIMITER; } return target + fieldName; } }"}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.ast.expression; import java.util.List; import org.jreversepro.jls.JLSConstants;  public class InstanceMethodAccessExpression extends MethodAccessExpression {  private final Expression accessTarget; public InstanceMethodAccessExpression(Expression accessTarget, String methodName, String methodType, List<Expression> args) { super(methodName, methodType, args); this.accessTarget = accessTarget; }  @Override public String getJLSCode() { String objName = accessTarget.getJLSCode(); StringBuilder result = new StringBuilder(); if (methodName.equals(INIT)) { result.append(objName); "}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) MethodAccessExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ObjectInstantiationExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.ast.expression; import org.jreversepro.jls.JLSConstants; import org.jreversepro.jvm.TypeInferrer; import org.jreversepro.reflect.Import; public class StaticFieldAccessExpression extends FieldAccessExpression { private final String classType; public StaticFieldAccessExpression(String _classType, String fieldName, String fieldType) { super(fieldName, fieldType); this.classType = _classType; }  @Override public String getJLSCode() { String target = Import.getClassName(TypeInferrer.getJLSType(classType, false)); return target + JLSConstants.JLS_PACKAGE_DELIMITER + fieldName; } }"}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.ast.expression; import java.util.List; import org.jreversepro.jls.JLSConstants; import org.jreversepro.jvm.TypeInferrer; import org.jreversepro.reflect.Import;  public class StaticMethodAccessExpression extends MethodAccessExpression {  private final String classType; public StaticMethodAccessExpression(String _classType, String _methodName, String _methodType, List<Expression> _args) { super(_methodName, _methodType, _args); classType = _classType; }  @Override public String getJLSCode() { StringBuilder result = new StringBuilder(); result.append(Import.getClassName(TypeInferrer.getJLSType(classType, false)) + JLSConstants.JLS_PACKAGE_DELIMITER + methodName); result.append(serializedArgs()); return result.toString(); } }"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ThrowExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) UnaryOpExpression.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) ConditionalLine.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.ast.intermediate; import org.jreversepro.decompile.BlockInferrer; import org.jreversepro.reflect.instruction.Instruction; public class GotoLine extends AbstractLineOfCode { public GotoLine(Instruction _ins) { super(_ins); } @Override public void regenerateBlock(BlockInferrer ctx) { "}
{"name": "akkumar/jreversepro", "content": "/** * @(#) JSRLine.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) StatementList.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) JSRLine.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) SwitchLine.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)CommandMain.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/* * @(#)BranchConstants.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)BranchEntry.java * * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)BranchTable.java * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)ClassEditPanel.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)ConfirmCloseDialog.java * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)JCustomFileChooser.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)CustomListPanel.java * * JReversePro - Java Decompiler / Disassembler. * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)DlgAbout.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)DlgClose.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)JLSStringEncoder.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) EmitterTarget.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) IfEmitter.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) MethodEmitter.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) StatementEmitter.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)ConstantPoolEntry.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "package org.jreversepro.reflect; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  public class ExceptionList { private final List<ExceptionThrown> exceptions; public ExceptionList() { this.exceptions = new ArrayList<ExceptionThrown>(); }  public Map<Integer, String> getAllExceptionsAsMap() { final Map<Integer, String> newMap = new HashMap<Integer, String>(); for (final ExceptionThrown exc : exceptions) { newMap.putAll(exc.excCatchTable); } return newMap; }  public void addExceptionBlock(int startPc, int endPc, int handlerPc, String datatype) { ExceptionThrown exc = new ExceptionThrown(startPc, endPc, handlerPc, datatype); "}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)Field.java 1.00 00/12/09 * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)JImport.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)LineNumberTable.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#) LocalVariableTable.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)Member.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * @(#)Method.java * * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "akkumar/jreversepro", "content": "/** * JReversePro - Java Decompiler / Disassembler. * Copyright (C) 2008 Karthik Kumar. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "purcell/jargs", "content": " package com.sanityinc.jargs.examples; import com.sanityinc.jargs.CmdLineParser; import java.util.ArrayList; import java.util.List;  public class AutoHelpParser extends CmdLineParser { List<String> optionHelpStrings = new ArrayList<String>(); public <T> Option<T> addHelp(Option<T> option, String helpString) { optionHelpStrings.add(\" -\" + option.shortForm() + \"/--\" + option.longForm() + \": \" + helpString); return option; } public void printUsage() { System.err.println(\"usage: prog [options]\"); for (String help : optionHelpStrings) { System.err.println(help); } } public static void main( String[] args ) { AutoHelpParser parser = new AutoHelpParser(); CmdLineParser.Option<Boolean> verbose = parser.addHelp( parser.addBooleanOption('v', \"verbose\"), \"Print extra information\"); CmdLineParser.Option<Integer> size = parser.addHelp( parser.addIntegerOption('s', \"size\"), \"The extent of the thing\"); CmdLineParser.Option<String> name = parser.addHelp( parser.addStringOption('n', \"name\"), \"Name given to the widget\"); CmdLineParser.Option<Double> fraction = parser.addHelp( parser.addDoubleOption('f', \"fraction\"), \"What percentage should be discarded\"); CmdLineParser.Option<Boolean> help = parser.addHelp( parser.addBooleanOption('h', \"help\"), \"Show this help message\"); try { parser.parse(args); } catch ( CmdLineParser.OptionException e ) { System.err.println(e.getMessage()); parser.printUsage(); System.exit(2); } if ( parser.getOptionValue(help) ) { parser.printUsage(); System.exit(0); } "}
{"name": "purcell/jargs", "content": " package com.sanityinc.jargs; import java.text.NumberFormat; import java.text.ParseException; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Locale; import java.util.Map;  public class CmdLineParser {  public static abstract class OptionException extends Exception { OptionException(String msg) { super(msg); } }  public static class UnknownOptionException extends OptionException { UnknownOptionException( String optionName ) { this(optionName, \"Unknown option '\" + optionName + \"'\"); } UnknownOptionException( String optionName, String msg ) { super(msg); this.optionName = optionName; }  public String getOptionName() { return this.optionName; } private final String optionName; }  public static class UnknownSuboptionException extends UnknownOptionException { private char suboption; UnknownSuboptionException( String option, char suboption ) { super(option, \"Illegal option: '\"+suboption+\"' in '\"+option+\"'\"); this.suboption=suboption; } public char getSuboption() { return suboption; } }  public static class NotFlagException extends UnknownOptionException { private char notflag; NotFlagException( String option, char unflaggish ) { super(option, \"Illegal option: '\"+option+\"', '\"+ unflaggish+\"' requires a value\"); notflag=unflaggish; }  public char getOptionChar() { return notflag; } }  public static class IllegalOptionValueException extends OptionException { public <T> IllegalOptionValueException( Option<T> opt, String value ) { super(\"Illegal value '\" + value + \"' for option \" + (opt.shortForm() != null ? \"-\" + opt.shortForm() + \"/\" : \"\") + \"--\" + opt.longForm()); this.option = opt; this.value = value; }  public Option<?> getOption() { return this.option; }  public String getValue() { return this.value; } private final Option<?> option; private final String value; }  public static abstract class Option<T> { protected Option( String longForm, boolean wantsValue ) { this(null, longForm, wantsValue); } protected Option( char shortForm, String longForm, boolean wantsValue ) { this(new String(new char[]{shortForm}), longForm, wantsValue); } private Option( String shortForm, String longForm, boolean wantsValue ) { if ( longForm == null ) { throw new IllegalArgumentException(\"Null longForm not allowed\"); } this.shortForm = shortForm; this.longForm = longForm; this.wantsValue = wantsValue; } public String shortForm() { return this.shortForm; } public String longForm() { return this.longForm; }  public boolean wantsValue() { return this.wantsValue; } public final T getValue( String arg, Locale locale ) throws IllegalOptionValueException { if ( this.wantsValue ) { if ( arg == null ) { throw new IllegalOptionValueException(this, \"\"); } return this.parseValue(arg, locale); } else { return this.getDefaultValue(); } }  protected T parseValue(String arg, Locale locale) throws IllegalOptionValueException { return null; }  protected T getDefaultValue() { return null; } private final String shortForm; private final String longForm; private final boolean wantsValue;  public static class BooleanOption extends Option<Boolean> { public BooleanOption( char shortForm, String longForm ) { super(shortForm, longForm, false); } public BooleanOption( String longForm ) { super(longForm, false); } @Override public Boolean parseValue(String arg, Locale lcoale) { return Boolean.TRUE; } @Override public Boolean getDefaultValue() { return Boolean.TRUE; } }  public static class IntegerOption extends Option<Integer> { public IntegerOption( char shortForm, String longForm ) { super(shortForm, longForm, true); } public IntegerOption( String longForm ) { super(longForm, true); } @Override protected Integer parseValue( String arg, Locale locale ) throws IllegalOptionValueException { try { return new Integer(arg); } catch (NumberFormatException e) { throw new IllegalOptionValueException(this, arg); } } }  public static class LongOption extends Option<Long> { public LongOption( char shortForm, String longForm ) { super(shortForm, longForm, true); } public LongOption( String longForm ) { super(longForm, true); } @Override protected Long parseValue( String arg, Locale locale ) throws IllegalOptionValueException { try { return new Long(arg); } catch (NumberFormatException e) { throw new IllegalOptionValueException(this, arg); } } }  public static class DoubleOption extends Option<Double> { public DoubleOption( char shortForm, String longForm ) { super(shortForm, longForm, true); } public DoubleOption( String longForm ) { super(longForm, true); } @Override protected Double parseValue( String arg, Locale locale ) throws IllegalOptionValueException { try { NumberFormat format = NumberFormat.getNumberInstance(locale); Number num = (Number)format.parse(arg); return new Double(num.doubleValue()); } catch (ParseException e) { throw new IllegalOptionValueException(this, arg); } } }  public static class StringOption extends Option<String> { public StringOption( char shortForm, String longForm ) { super(shortForm, longForm, true); } public StringOption( String longForm ) { super(longForm, true); } @Override protected String parseValue( String arg, Locale locale ) { return arg; } } }  public final <T> Option<T> addOption( Option<T> opt ) { if ( opt.shortForm() != null ) { this.options.put(\"-\" + opt.shortForm(), opt); } this.options.put(\"--\" + opt.longForm(), opt); return opt; }  public final Option<String> addStringOption( char shortForm, String longForm ) { return addOption(new Option.StringOption(shortForm, longForm)); }  public final Option<String> addStringOption( String longForm ) { return addOption(new Option.StringOption(longForm)); }  public final Option<Integer> addIntegerOption( char shortForm, String longForm ) { return addOption(new Option.IntegerOption(shortForm, longForm)); }  public final Option<Integer> addIntegerOption( String longForm ) { return addOption(new Option.IntegerOption(longForm)); }  public final Option<Long> addLongOption( char shortForm, String longForm ) { return addOption(new Option.LongOption(shortForm, longForm)); }  public final Option<Long> addLongOption( String longForm ) { return addOption(new Option.LongOption(longForm)); }  public final Option<Double> addDoubleOption( char shortForm, String longForm ) { return addOption(new Option.DoubleOption(shortForm, longForm)); }  public final Option<Double> addDoubleOption( String longForm ) { return addOption(new Option.DoubleOption(longForm)); }  public final Option<Boolean> addBooleanOption( char shortForm, String longForm ) { return addOption(new Option.BooleanOption(shortForm, longForm)); }  public final Option<Boolean> addBooleanOption( String longForm ) { return addOption(new Option.BooleanOption(longForm)); }  public final <T> T getOptionValue( Option<T> o ) { return getOptionValue(o, null); }  public final <T> T getOptionValue( Option<T> o, T def ) { List<?> v = values.get(o.longForm()); if (v == null) { return def; } else if (v.isEmpty()) { return null; } else {  @SuppressWarnings(\"unchecked\") T result = (T)v.remove(0); return result; } }  public final <T> Collection<T> getOptionValues(Option<T> option) { Collection<T> result = new ArrayList<T>(); while (true) { T o = getOptionValue(option, null); if (o == null) { return result; } else { result.add(o); } } }  public final String[] getRemainingArgs() { return this.remainingArgs; }  public final void parse( String[] argv ) throws OptionException { parse(argv, Locale.getDefault()); }  public final void parse( String[] argv, Locale locale ) throws OptionException { ArrayList<Object> otherArgs = new ArrayList<Object>(); int position = 0; this.values = new HashMap<String, List<?>>(10); while ( position < argv.length ) { String curArg = argv[position]; if ( curArg.startsWith(\"-\") ) { if ( curArg.equals(\"--\") ) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class BindingException extends BuildException { private final static String beanBindingError = \"Unable to bind caller '%s' property to '%s.%s'. Error: %s\";  public BindingException(String source, String sourceProperty, String destinationProperty, String errorDetails) { super(String.format(beanBindingError, destinationProperty, source, sourceProperty, errorDetails)); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.text.MessageFormat; import org.javabuilders.util.BuilderUtils;  @SuppressWarnings(\"serial\") public class BuildException extends RuntimeException {  public BuildException(String messageFormat, Object...messageArguments) { super(MessageFormat.format(messageFormat, messageArguments)); }  public BuildException(Throwable cause) { super(cause); }  public BuildException(Throwable cause,String messageFormat, Object...messageArguments) { super(MessageFormat.format(messageFormat, BuilderUtils.getMessageFormatSafeArguments(messageArguments)), cause); }  @Override public String toString() { if (this.getCause() == null) { return this.getMessage(); } else { return this.getMessage() + \"\\n\" + this.getCause().getClass().getName() + \": \" + this.getCause().getMessage(); } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set;  public class BuildProcess { private BuildResult result; private Map<String,Object> instances = new HashMap<String, Object>(); private List<NamedObjectPropertyValue> propertiesAsNamedObjects = new ArrayList<NamedObjectPropertyValue>(); private BuilderConfig config = null; private Object document = null;  public BuildProcess(BuilderConfig config, Object caller, ResourceBundle...bundles) throws BuildException { if (caller == null) { throw new BuildException(\"Caller cannot be null\"); } if (config == null) { throw new BuildException(\"config cannot be null\"); } this.config = config; result = new BuildResult(config,caller); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.Enumeration; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.MissingResourceException; import java.util.ResourceBundle; import java.util.Set; import org.javabuilders.event.BackgroundEventListener; import org.javabuilders.handler.validation.BuilderValidators; import org.javabuilders.handler.validation.IValidationMessageHandler; import org.javabuilders.handler.validation.ValidationMessageList; import org.javabuilders.util.BuilderUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  @SuppressWarnings(\"serial\") public class BuildResult extends HashMap<String, Object> { private static final Logger logger = LoggerFactory.getLogger(BuildResult.class); private BuilderConfig config; private Object caller = null; private ResourceBundle defaultBundle = null; private List<Object> roots = new ArrayList<Object>(); private boolean isDirty = false; private BuilderValidators validators = new BuilderValidators(this); private PropertyChangeSupport support = new PropertyChangeSupport(this); private IValidationMessageHandler validationMessageHandler; private Set<ResourceBundle> resourceBundles = new HashSet<ResourceBundle>(); private Map<String, Field> allFields = null; private Object bindingContext = null; private Map<String,?> properties = new HashMap<String, Object>(); private Set<BackgroundEventListener> backgroundEventListeners = new LinkedHashSet<BackgroundEventListener>(); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.lang.reflect.Method; import java.net.URI; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedHashSet; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.TreeMap; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.javabuilders.annotations.BuildFile; import org.javabuilders.event.BuildEvent; import org.javabuilders.event.BuildListener; import org.javabuilders.exception.InvalidFormatException; import org.javabuilders.handler.GlobalVariablePropertyHandler; import org.javabuilders.handler.IPropertyHandler; import org.javabuilders.handler.ITypeAsValueHandler; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.handler.ITypeHandler; import org.javabuilders.handler.ITypeHandlerAfterCreationProcessor; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.util.BuilderUtils; import org.javabuilders.util.ChildrenCardinalityUtils; import org.javabuilders.util.PropertyUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.yaml.snakeyaml.Yaml;  public class Builder { private final static Logger logger = LoggerFactory.getLogger(Builder.class); private static final Pattern prefixNameSplitter = Pattern.compile(\"([a-z]+)([A-Z0-9]+[a-zA-Z0-9]*)\"); public final static Map<String,?> EMPTY_PROPERTIES = null; public final static String NAME = \"name\";  public final static String CONTENT = \"content\";  public final static String CONSTRAINTS = \"constraints\";  public final static String BIND = \"bind\";  public final static String VALIDATE = \"validate\";  public final static String VALUE = \"value\";  public final static String LAYOUT = \"layout\";  public final static String ON_ACTION = \"onAction\";  public final static String ON_FOCUS = \"onFocus\";  public final static String ON_FOCUS_LOST = \"onFocusLost\";  public final static String THIS = \"this\";  public final static String NAMED_OBJECT_REGEX = \"\\\\$\\\\{[a-zA-Z0-9]+\\\\}\"; private final static int NAMED_OBJECT_PREFIX_LENGTH = 2; private final static int NAMED_OBJECT_SUFFIX_LENGTH = 1; public static final String RESOURCE_BUNDLE = \"org/javabuilders/Resources\";  public final static String VALIDATE_CUSTOM_COMMAND = \"$validate\";  public final static String CONFIRM_CUSTOM_COMMAND = \"$confirm\";  public final static String BOOLEAN_FALSE = \"false\";  public final static String BOOLEAN_TRUE = \"true\"; public final static String INTERNAL_FIELD_PREFIX = \"__\"; public final static String PROTOTYPE_FIELD_PREFIX = \"$\";  public static BuildResult build(BuilderConfig config, Object caller, ResourceBundle...resourceBundles) { return build(config, caller, EMPTY_PROPERTIES, resourceBundles); }  public static BuildResult build(BuilderConfig config,Object caller, Map<String, ?> customProperties, ResourceBundle...resourceBundles) { Class<?> type = caller.getClass(); String fileName = null; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.beans.PropertyChangeSupport; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.TreeSet; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.javabuilders.event.BackgroundEventListener; import org.javabuilders.event.BuildListener; import org.javabuilders.event.IBackgroundProcessingHandler; import org.javabuilders.handler.DefaultPropertyHandler; import org.javabuilders.handler.DefaultTypeHandler; import org.javabuilders.handler.IPropertyHandler; import org.javabuilders.handler.ITypeHandler; import org.javabuilders.handler.IntegerAsValueHandler; import org.javabuilders.handler.binding.BuilderBindings; import org.javabuilders.handler.type.ClassAsValueHandler; import org.javabuilders.handler.type.IntArrayAsValueHandler; import org.javabuilders.handler.type.IntegerArrayAsValueHandler; import org.javabuilders.handler.validation.BuilderValidators; import org.javabuilders.handler.validation.DefaultValidatorTypeHandler; import org.javabuilders.handler.validation.IValidationMessageHandler; import org.javabuilders.util.BuilderUtils; import org.javabuilders.util.PropertyUtils;  public class BuilderConfig { private static final Pattern nameExtractor = Pattern.compile(\".+\\\\((?:\\\\s*|.*,\\\\s*)name\\\\s*=\\\\s*([a-zA-Z0-9_]+)(?:\\\\s*|,|).*\\\\).*\"); static ITypeHandler defaultTypeHandler = new DefaultTypeHandler(); static IPropertyHandler defaultPropertyHandler = DefaultPropertyHandler.getInstance(); private static String devSourceFolder = null; public static final String SOURCE = \"javabuilders.dev.src\"; public final static String CUSTOM_COMMAND_REGEX = \"\\\\$[a-zA-Z0-9]+\"; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import static org.javabuilders.util.BuilderUtils.getRealKey; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import org.javabuilders.exception.UnrecognizedAliasException; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.handler.ITypeHandler; import org.javabuilders.util.BuilderUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class BuilderPreProcessor { public static final Logger logger = LoggerFactory.getLogger(BuilderPreProcessor.class); public static final Map<Character,Character> listIndicators = new HashMap<Character, Character>(); static { listIndicators.put('(',')'); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  public class ChildrenCardinalityException extends BuildException { private static final long serialVersionUID = -3361737994936544730L;  public ChildrenCardinalityException(String messageFormat, Object... messageArguments) { super(messageFormat, messageArguments); }  public ChildrenCardinalityException(Throwable cause) { super(cause); }  public ChildrenCardinalityException(Throwable cause, String messageFormat, Object... messageArguments) { super(cause, messageFormat, messageArguments); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class ConfigurationException extends BuildException {  public ConfigurationException(String message) { super(message); }  public ConfigurationException(Throwable cause) { super(cause); }  public ConfigurationException(String message, Throwable cause) { super(cause, message); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class DuplicateAliasException extends RuntimeException {  public DuplicateAliasException(String message) { super(message); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders;  public class EventMethod {}"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  public interface IAllowedPropertyCombinations {  PropertyCombination getAllowedCombinations(); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  public interface IAllowedPropertyFormat {  String getValidSample(String propertyName);  String getRegexPattern(String propertyName); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.Collection;  public interface IAllowedValues {  Collection<? extends Object> getAllowedValues(); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders;  public interface IApplicable {  Class<?> getApplicableClass(); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders;  public interface ICustomCommand<T> {  T process(BuildResult result, Object source); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.Set;  public interface IKeyValueConsumer {  Set<String> getConsumedKeys(); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.List;  public interface IPropertyList {  boolean isList(String propertyName);  List<ValueListDefinition> getValueListDefinitions(String propertyName); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders;  public interface IResourceFallback {  String get(String key); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders;  public interface IStringLiteralControlConfig {  String getStringLiteralControlSuffix();  String getStringLiteralControlPrefix();  void setStringLiteralControlSuffix(String suffix);  void setStringLiteralControlPrefix(String prefix); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders;  public interface ITypeAsValueSupport { }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.Set;  public class InvalidParentTypeException extends BuildException {  private static final long serialVersionUID = 5527212031302490576L; private final static String message = \"Attempted to create a class of type '%s' under an invalid parent of type '%s'. Only allowed parent types are: %s.\";  public InvalidParentTypeException(Class<?> typeClass, Class<?> invalidParentClass, Set<Class<?>> allowedParentClasses) { super(String.format(message,typeClass,invalidParentClass,allowedParentClasses)); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class InvalidPropertyException extends BuildException { private static final String message = \"{0}.{1} : unable to set value \\\"{2}\\\".\\n{3}.\\n{4}\";  public InvalidPropertyException(Throwable e,String typeAlias, String propertyName, Object value, String properties) { super(e, message, typeAlias,propertyName, value, e.getMessage(), properties); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class InvalidPropertyFormatException extends BuildException { private final static String message = \"Invalid value '%s' of property '%s' for type alias '%s'. Expected value in format '%s', e.g.'%s'\";  public InvalidPropertyFormatException(String typeAlias, String property, String value, String format, String validFormatSample) { super(String.format(message, value, property, typeAlias, format, validFormatSample)); }  public InvalidPropertyFormatException(String typeAlias, String property, String value, String format, String validFormatSample, Throwable cause) { super(cause, String.format(message, value, property, typeAlias, format, validFormatSample)); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.Collection;  @SuppressWarnings(\"serial\") public class InvalidPropertyValueException extends BuildException { private final static String formatMessage = \"Invalid value '%s' of property '%s' for type alias '%s'. Expected value in format '%s', e.g.'%s'\"; private final static String valueMessage = \"Invalid value '%s' of property '%s' for type alias '%s'. Allowed values are: %s\";  public InvalidPropertyValueException(String typeAlias, String property, Object value, Collection<? extends Object> allowedValues) { super(String.format(valueMessage, value, property, typeAlias, allowedValues)); }  public InvalidPropertyValueException(String typeAlias, String property, Object value, String format, Collection<? extends Object> allowedValues, Throwable cause) { super(cause,String.format(valueMessage, value, property, typeAlias, allowedValues)); }  public InvalidPropertyValueException(String typeAlias, String property, Object value, String format, String validFormatSample) { super(String.format(formatMessage, value, property, typeAlias, format, validFormatSample)); }  public InvalidPropertyValueException(String typeAlias, String property, Object value, String format, String validFormatSample, Throwable cause) { super(cause, String.format(formatMessage, value, property, typeAlias, format, validFormatSample)); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class InvalidTypeException extends BuildException { private String key = \"\";  public InvalidTypeException(String key) { super(getKeyMessage(key,null)); this.key = key; }  public InvalidTypeException(String key, Throwable cause) { super(cause,getKeyMessage(key,cause)); this.key = key; } "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class MissingRequiredPropertyException extends BuildException { private final static String message = \"Entry for alias '%s' is missing required property '%s'.\\nCurrent document node:\\n%s\";  public MissingRequiredPropertyException(String alias, String requiredPropertyName, Object documentNode) { super(String.format(message, alias,requiredPropertyName, documentNode)); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  @SuppressWarnings(\"serial\") public class MissingRequiredTypeException extends BuildException { private final static String message = \"Entry for alias '%s' is missing required type '%s'.\\nCurrent document node:\\n%s\";  public MissingRequiredTypeException(String alias, Class<?> requiredType, Object documentNode) { super(String.format(message, alias,requiredType.getName(), documentNode)); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; @SuppressWarnings(\"serial\") public class MultipleRootsException extends BuildException {  public MultipleRootsException(int rootCount) { super(\"Expected 1 root object, but encountered \" + rootCount); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders;  public class NamedObject { }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders;  public class NamedObjectProperty { private String name; private String propertyExpression;  public NamedObjectProperty(String name, String propertyExpression) { this.name = name; this.propertyExpression = propertyExpression; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getPropertyExpression() { return propertyExpression; }  public void setPropertyExpression(String propertyExpression) { this.propertyExpression = propertyExpression; }  @Override public String toString() { return String.format(\"%s.%s\",name,propertyExpression); }  @Override public boolean equals(Object obj) { if (obj != null && obj instanceof NamedObjectProperty) { NamedObjectProperty p = (NamedObjectProperty) obj; if (p.getName().equals(getName()) && p.getPropertyExpression().equals(getPropertyExpression())) { return true; } else { return false; } } else { return false; } }  @Override public int hashCode() { return getName().hashCode(); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; import org.javabuilders.util.PropertyUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class NamedObjectPropertyValue { private static final Logger logger = LoggerFactory.getLogger(NamedObjectPropertyValue.class); private Object source = null; private String propertyName = null; private String targetObjectName = null;  public NamedObjectPropertyValue(Object source, String propertyName, String targetObjectName) { this.source = source; this.propertyName = propertyName; this.targetObjectName = targetObjectName; }  void setReference(BuildProcess result) throws BuildException { Object namedObject = result.getByName(targetObjectName); if (namedObject == null) { throw new BuildException(targetObjectName + \" is not a valid named object\"); } try { PropertyUtils.setProperty(source, propertyName, namedObject); } catch (Exception e) { throw new BuildException(e,\"Unable to set property {0}.{1} to named object \\\"{2}\\\"\", source.getClass().getSimpleName(),propertyName,targetObjectName); } if (logger.isDebugEnabled()) { logger.debug(\"Set reference on property {} to {}\", propertyName, targetObjectName); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; import java.text.MessageFormat; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Set;  public class Node { private Object mainObject = null; private Node parent = null; private String key = null; private Map<String,List<Object>> childValues = new HashMap<String,List<Object>>(); private Set<Node> childNodes = new LinkedHashSet<Node>(); private Map<String,Object> properties = new HashMap<String,Object>(); private Set<String> consumedKeys = new HashSet<String>(); private boolean usePreInstantiatedRoot = false; private Map<String,Object> customProperties = new HashMap<String, Object>();  Node(Node parent, String key) { this(parent,key,null); }  public Node(String key, Map<String,Object> properties) { this(null,key, properties); }  public Node(Node parent, String key, Map<String,Object> properties) { this(parent,key, properties, null); }  public Node(Node parent, String key, Map<String,Object> properties, Object mainObject) { if (key == null) { throw new NullPointerException(\"key cannot be null\"); } this.key = key; if (properties != null) { this.properties = properties; } "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.Map.Entry; import org.javabuilders.util.JBStringUtils;  public class PrefixControlDefinition {  public static final String SUFFIX_LABEL = \"${CONTROL_SUFFIX_LABEL}\";  public static final String SUFFIX_PASCAL_CASE = \"${CONTROL_SUFFIX_PASCAL_CASE}\"; private static Set<String> reservedPrefixes = new HashSet<String>();  public static void addReservedPrefix(String prefix) { reservedPrefixes.add(prefix); } static { reservedPrefixes.add(\"new\"); } private Class<?> clazz; private Map<String,String> defaults = new HashMap<String, String>();  public String getDefaultsAsYaml(BuildProcess process, String controlName, String suffix) { StringBuilder bld = new StringBuilder(\"{\"); if (defaults != null && defaults.size() > 0) { String suffixPascal = (suffix.length() > 0) ? suffix.substring(0,1).toLowerCase() + suffix.substring(1) : suffix; for(Entry<String,String> entry : defaults.entrySet()) { if (bld.length() > 1) { bld.append(\",\"); } String value = entry.getValue(); if (value.contains(SUFFIX_PASCAL_CASE)) { value = value.replace(SUFFIX_PASCAL_CASE, suffixPascal); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; import java.lang.reflect.Method;  public class PropertyAsMethodInvocation { private Method method; private String propertyName; private int valueArgumentIndex = 0; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; import java.util.ArrayList; import java.util.Collection; import java.util.List;  public class PropertyCombination { private List<String[]> combinations = new ArrayList<String[]>();  public void add(String...properties) { combinations.add(properties); }  public boolean isValid(Collection<String> properties) { boolean isValid = false; for(String[] allowed : combinations) { boolean found = false; boolean notFound = false; for(String property : allowed) { if (properties.contains(property)) { found = true; } else { notFound = true; } } if (found && !notFound) { isValid = true; break; } } return isValid; }  @Override public String toString() { StringBuilder builder = new StringBuilder(combinations.size() * 20); for(String[] properties : combinations) { if (builder.length() > 0) { builder.append(\" | \"); } for(String property : properties) { builder.append(property).append(\" \"); } } return builder.toString(); }  @Override public int hashCode() { return combinations.hashCode(); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Set; import org.javabuilders.handler.IPropertyHandler; import org.javabuilders.handler.ITypeAsValueHandler; import org.javabuilders.handler.ITypeHandler; import org.javabuilders.handler.ITypeHandlerAfterCreationProcessor; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.layout.DefaultResize; import org.javabuilders.util.BuilderUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class TypeDefinition implements IKeyValueConsumer, IApplicable { public static final Integer DEFAULT_DELAY_WEIGHT = 1000; public final static Logger logger = LoggerFactory.getLogger(TypeDefinition.class);   public static Integer getDelayedWeight(ITypeHandler handler, Collection<TypeDefinition> typeDefinitions) { Integer delayedWeight = 0; root: for(TypeDefinition def : typeDefinitions) { Map<Class<?>,Integer> delayedClasses = def.getDelayedTypes(); for(Class<?> delayedClass : delayedClasses.keySet()) { if (delayedClass.isAssignableFrom(handler.getApplicableClass())) { delayedWeight = delayedClasses.get(delayedClass); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.Comparator;  public class TypeDefinitionClassHierarchyComparator implements Comparator<Object> {  public int compare(Object arg0, Object arg1) { if (arg0 instanceof TypeDefinition && arg1 instanceof TypeDefinition) { TypeDefinition def0 = (TypeDefinition)arg0; TypeDefinition def1 = (TypeDefinition)arg1; if (def0.getApplicableClass().equals(def1.getApplicableClass())) { return 0; } else if (def0.getApplicableClass().isAssignableFrom(def1.getApplicableClass())) { return 1; } else { return -1; } } else { throw new BuildException(\"Unexpected type\"); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders; import java.util.HashSet; import java.util.Set; import org.javabuilders.event.ObjectMethod; import org.javabuilders.util.BuilderUtils;  public class ValueDefinition { private boolean isVariableLength = false; private Class<?> type = null; private Object defaultValue = null; private Set<Object> allowedValues = new HashSet<Object>(); private String regexPattern = \"\"; private String name; private Class<?>[] relatedTypes = new Class[0];  public ValueDefinition(String name,Class<?> type) { BuilderUtils.validateNotNullAndNotEmpty(\"name\",name); BuilderUtils.validateNotNullAndNotEmpty(\"type\",type); this.name = name; this.type = type; }  public ValueDefinition(String name, Class<?> type, Object defaultValue) { BuilderUtils.validateNotNullAndNotEmpty(\"name\",name); BuilderUtils.validateNotNullAndNotEmpty(\"type\",type); this.name = name; this.type = type; this.defaultValue = defaultValue; }  public Object getDefaultValue() { return defaultValue; }  public void setDefaultValue(Object defaultValue) { this.defaultValue = defaultValue; }  public Class<?> getType() { return type; }  public void validateValue(BuildProcess result, Node node, Object value, Values<Object,Object> valueList) throws BuildException { if (getType().equals(NamedObject.class)) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.List;  public class ValueListDefinition {  public static List<ValueListDefinition> getCommonEventDefinitions(Class<?>...relatedTypes) { List<ValueListDefinition> eventDefs = new ArrayList<ValueListDefinition>(); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map;  @SuppressWarnings(\"serial\") public class Values<K,V> extends LinkedHashMap<K,V> { private Map<Object,String> errorMessages = new HashMap<Object, String>(); private ValueListDefinition definition = null;  public Values() { this(null); }  public Values(ValueListDefinition def) { this.definition = def; }  public void put(K key, V value, String errorMessageFormat, Object... messageArgs) { put(key,value); errorMessages.put(key,String.format(errorMessageFormat,messageArgs)); }  public boolean isValid(String key) { return errorMessages.containsKey(key); }  public boolean isValid() { return errorMessages.size() == 0; }  public String getErrors() { StringBuilder builder = new StringBuilder(); for(String msg : errorMessages.values()) { builder.append(msg); builder.append(\"\\n\"); } return builder.toString(); }  public String getError(String key) { return errorMessages.get(key); }  public ValueListDefinition getDefinition() { return definition; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD, ElementType.METHOD}) public @interface Alias { String value(); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE}) public @interface BuildFile { String value(); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD}) public @interface Built { String[] value(); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface DoInBackground {  String progressMessage() default \"label.processing\";  boolean cancelable() default false;  int progressStart() default 1;  int progressEnd() default 100;  int progressValue() default 1;  boolean blocking() default true;  boolean indeterminateProgress() default true; }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.util.EventObject; import org.javabuilders.BuildResult;  @SuppressWarnings(\"serial\") public class BackgroundEvent extends EventObject { private Boolean isCancelable = false; private CancelStatus cancelStatus = CancelStatus.FORBIDDEN; private Integer progressStart = 0, progressEnd = 100, progressValue = 0; private String progressMessage = \"\"; private Object originalEvent = null; private Boolean isProgressIndeterminate = false; private Boolean isBlocking = true; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event; import java.util.EventListener; import org.javabuilders.BuildResult; public interface BackgroundEventListener extends EventListener {  public void backgroundTaskStarted(BuildResult r, BackgroundEvent evt);  public void backgroundTaskEnded(BuildResult r, BackgroundEvent evt); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.event;  public class BuildAdapter implements BuildListener {  public void buildEnded(BuildEvent evt) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.event; import java.util.EventObject; import org.javabuilders.BuildResult;  @SuppressWarnings(\"serial\") public class BuildEvent extends EventObject { private BuildResult result;  public BuildEvent(Object source, BuildResult result) { super(source); this.result = result; }  public BuildResult getResult() { return result; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event; import java.util.EventListener;  public interface BuildListener extends EventListener {  public void buildStarted(BuildEvent evt);  public void buildEnded(BuildEvent evt); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event;  public enum CancelStatus { FORBIDDEN(-1), NONE(0), REQUESTED(1), PROCESSING(2), COMPLETED(3); private int status; private CancelStatus(int status) { this.status = status; }  public int getStatus() { return this.status; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event;  public interface IBackgroundCallback {  void done(Object returnValue); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.event; import java.lang.reflect.Method; import org.javabuilders.BuildResult;  public interface IBackgroundProcessingHandler {  void doInBackground( BuildResult result, Object target, Method method, BackgroundEvent event, IBackgroundCallback callbackWhenFinished) throws Exception; }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event; import java.util.EventListener; import org.javabuilders.BuildResult;  public interface IBindingListener<B> extends EventListener {  public void bindingCreated(BuildResult result, B binding); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event; public interface IBindingListenerProvider<B> {  public void addBindingListener(IBindingListener<B> listener);  public void removeBindingListener(IBindingListener<B> listener);  public IBindingListener<B>[] getBindingListeners(); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.event; import java.lang.reflect.Method;  public class ObjectMethod { private Object instance; private Method method; private MethodType type = MethodType.Regular;  public ObjectMethod(Object instance, Method method) { this(instance,method,MethodType.Regular); }  public ObjectMethod(Object instance, Method method, MethodType type) { this.instance = instance; this.method = method; this.type = type; }  public Method getMethod() { return method; }  public void setMethod(Method method) { this.method = method; }  public Object getInstance() { return instance; }  public void setInstance(Object instance) { this.instance = instance; }  public enum MethodType { Regular, CustomCommand }  public MethodType getType() { return type; }  public void setType(MethodType type) { this.type = type; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.exception; import org.javabuilders.BuildException;  public class InvalidFormatException extends BuildException { private static final long serialVersionUID = -7414063354223404642L; public InvalidFormatException(String messageFormat, Object... messageArguments) { super(messageFormat, messageArguments); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.exception; import org.javabuilders.BuildException;  public class UnrecognizedAliasException extends BuildException { private static final long serialVersionUID = -4492413379928323054L; public UnrecognizedAliasException(String messageFormat, Object... messageArguments) { super(messageFormat, messageArguments); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.util.Arrays; import java.util.HashSet; import java.util.Set;  public abstract class AbstractPropertyHandler implements IPropertyHandler { private Set<String> consumedKeys = new HashSet<String>();  public AbstractPropertyHandler(String... consumedKeys) { this(new HashSet<String>(Arrays.asList(consumedKeys))); }  public AbstractPropertyHandler(Set<String> consumedKeys) { this.consumedKeys = consumedKeys; }  public Set<String> getConsumedKeys() { return consumedKeys; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.util.Arrays; import java.util.HashSet; import java.util.Set; import org.javabuilders.Builder;  public abstract class AbstractTypeHandler implements ITypeHandler { private Set<String> consumedKeys = new HashSet<String>();  public AbstractTypeHandler(String... consumedKeys) { this(new HashSet<String>(Arrays.asList(consumedKeys))); }  public AbstractTypeHandler(Set<String> consumedKeys) { this.consumedKeys = consumedKeys; }  public Set<String> getConsumedKeys() { return consumedKeys; }  public String getCollectionPropertyName() { return Builder.CONTENT; }  public String getSimpleValuePropertyName() { return Builder.VALUE; }  public boolean isApplicableToSubclasses() { return true; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.util.Set; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.NamedObjectPropertyValue; import org.javabuilders.Node;  public class DefaultPropertyAsNamedObjectHandler extends AbstractPropertyHandler {  public DefaultPropertyAsNamedObjectHandler(String... consumedKeys) { super(consumedKeys); }  public DefaultPropertyAsNamedObjectHandler(Set<String> consumedKeys) { super(consumedKeys); }  public void handle(BuilderConfig config, BuildProcess result, Node node, String key) throws BuildException { NamedObjectPropertyValue request = new NamedObjectPropertyValue( node.getMainObject(),key,node.getStringProperty(key)); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.util.Set; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.ITypeAsValueSupport; import org.javabuilders.InvalidPropertyException; import org.javabuilders.Node; import org.javabuilders.util.PropertyUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class DefaultPropertyHandler extends AbstractPropertyHandler implements ITypeAsValueSupport { private static final Logger logger = LoggerFactory.getLogger(DefaultPropertyHandler.class); private static final DefaultPropertyHandler singleton = new DefaultPropertyHandler();  public static DefaultPropertyHandler getInstance() {return singleton;}  private DefaultPropertyHandler(Set<String> consumedKeys) { super(consumedKeys); }  private DefaultPropertyHandler(String... consumedKeys) { super(consumedKeys); }  public void handle(BuilderConfig config, BuildProcess result, Node node, String key) throws InvalidPropertyException { if (key != Builder.CONTENT) { Object mainObject = node.getMainObject(); Object value = node.getProperties().get(key); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.InvalidTypeException; import org.javabuilders.Node; import org.javabuilders.util.BuilderUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class DefaultTypeHandler extends AbstractTypeHandler { private final static Logger logger = LoggerFactory.getLogger(DefaultTypeHandler.class);  public DefaultTypeHandler() { super(); }  public Node createNewInstance(BuilderConfig config, BuildProcess result, Node parent, String key, Map<String, Object> typeDefinition) throws InvalidTypeException { Object instance = null; try { Class<?> typeClass = BuilderUtils.getClassFromAlias(result, key, null); instance = typeClass.newInstance(); if (logger.isDebugEnabled()) { logger.debug(\"Created object instance of type: {}\", typeClass.getName()); } return useExistingInstance(config, result, parent, key, typeDefinition, instance); } catch (BuildException ex) { throw ex; } catch (Exception ex) { logger.error(\"Failed to create class {}:{}\",key, ex.getMessage()); throw new InvalidTypeException(key,ex); } }  public Node useExistingInstance(BuilderConfig config, BuildProcess result, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { if (instance == null) { throw new NullPointerException(\"instance cannot be null\"); } if (!getApplicableClass().isInstance(instance)) { throw new BuildException(\"instance is not of type: \" + getApplicableClass().getName()); } Node node = new Node(parent, key, typeDefinition, instance); return node; }  public Class<?> getApplicableClass() { return Object.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.util.PropertyUtils;  public class GlobalVariablePropertyHandler extends AbstractPropertyHandler { private static final GlobalVariablePropertyHandler instance = new GlobalVariablePropertyHandler();  public static GlobalVariablePropertyHandler getInstance() {return instance;} private GlobalVariablePropertyHandler() {}  public void handle(BuilderConfig config, BuildProcess process, Node node, String key) throws BuildException { Object main = node.getMainObject(); String name = node.getStringProperty(key); try { Class<?> type = PropertyUtils.getPropertyType(main, key); Object value = config.getGlobalVariable(name, type); PropertyUtils.setProperty(main, key, value); } catch (BuildException ex) { throw ex; } catch (Exception e) { throw new BuildException(\"Unable to access or set property \\\"{0}\\\" : {1}\", key, e); } }  public Class<Object> getApplicableClass() { return Object.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IKeyValueConsumer; import org.javabuilders.Node;  public interface IPropertyHandler extends IKeyValueConsumer {  void handle(BuilderConfig config, BuildProcess process, Node node, String key) throws BuildException; }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.IApplicable; import org.javabuilders.Node;  public interface ITypeAsValueHandler<T> extends IApplicable {  T getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException;  String getRegex();  String getInputValueSample(); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler;  public interface ITypeChildrenHandler {}"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IApplicable; import org.javabuilders.IKeyValueConsumer; import org.javabuilders.InvalidTypeException; import org.javabuilders.Node;  public interface ITypeHandler extends IKeyValueConsumer, IApplicable {  Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String,Object> properties) throws BuildException;  Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String,Object> properties, Object instance) throws BuildException;  String getCollectionPropertyName();  String getSimpleValuePropertyName();  boolean isApplicableToSubclasses(); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node;  public interface ITypeHandlerAfterCreationProcessor {  void afterCreation(BuilderConfig config, BuildProcess process, Node current, String key, Map<String,Object> typeDefinition) throws BuildException; }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node;  public interface ITypeHandlerFinishProcessor {  void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String,Object> typeDefinition) throws BuildException; }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.TypeDefinition;  public class IntegerAsValueHandler implements ITypeAsValueHandler<Integer> { private static String regex = \"\\\\d+|[a-zA-Z0-9_]+\"; private static final IntegerAsValueHandler singleton = new IntegerAsValueHandler();  public static IntegerAsValueHandler getInstance() {return singleton;}  private IntegerAsValueHandler() {}  public String getInputValueSample() { return \"3 | SOME_CONSTANT_VALUE | someConstantValue\"; }  public String getRegex() { return regex; }  public Integer getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { Integer value = null; if (inputValue instanceof Integer) { value = (Integer)inputValue; } else if (inputValue instanceof Long) { Long lValue = (Long)inputValue; value = lValue.intValue(); } else if (inputValue instanceof String) { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.binding; import java.util.ArrayList; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.Set; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.NamedObjectProperty; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.util.BuilderUtils;  public abstract class AbstractBuilderBindingsHandler extends AbstractTypeHandler implements ITypeChildrenHandler { public final static String READ = \"read\"; public final static String READ_ONCE = \"readOnce\"; public final static String READ_WRITE = \"readWrite\";  public Node createNewInstance(BuilderConfig config, BuildProcess result, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { BuilderBindings instance = new BuilderBindings(); return useExistingInstance(config, result, parent, key, typeDefinition, instance); }  @SuppressWarnings(\"unchecked\") protected Map<NamedObjectProperty,BindingSourceDefinition> getBindingDefinitions(Node node, BuildProcess process) { Map<NamedObjectProperty,BindingSourceDefinition> defs = new LinkedHashMap<NamedObjectProperty, BindingSourceDefinition>(); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.binding; import org.javabuilders.BuildException;  public class BindingSourceDefinition { public Object source; public String bindingExpression; public String updateStrategy;  public BindingSourceDefinition(Object source, String bindingExpression, String updateStrategy) { super(); this.bindingExpression = bindingExpression; this.source = source; this.updateStrategy = updateStrategy; }  public Object getSource() { return source; }  public void setSource(Object source) { this.source = source; }  public String getBindingExpression() { return bindingExpression; }  public void setBindingExpression(String bindingExpression) { this.bindingExpression = bindingExpression; }  public String getUpdateStrategy() { return updateStrategy; }  public void setUpdateStrategy(String updateStrategy) { this.updateStrategy = updateStrategy; }  public boolean isSingleProperty() { if (getBindingExpression() != null) { return !getBindingExpression().matches(\".*\\\\$\\\\{.+}.*\"); } else { throw new BuildException(\"No Binding Expression defined yet: \" + getBindingExpression()); } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.binding;  public final class BuilderBindings {}"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.type; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public final class ClassAsValueHandler implements ITypeAsValueHandler<Class<?>> {  private final static String CLASS_VALUE_REGEX = \"^(.)+$\";  private final static ClassAsValueHandler SINGLETON = new ClassAsValueHandler();  public static ClassAsValueHandler getInstance() { return SINGLETON; }  public String getInputValueSample() { return \"java.lang.String\"; }  public Class<?> getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { final String classValue = (String) inputValue; if (classValue.matches(CLASS_VALUE_REGEX)) { try { return Class.forName(classValue); } catch (ClassNotFoundException e) { throw new BuildException(\"\\\"{0}\\\" is not a valid class\", classValue); } } "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.type; import java.awt.Component; import java.awt.Font; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public class FontAsValueHandler implements ITypeAsValueHandler<Font> { public static final String REGEX = \".*\"; private static final String REGEX_ITALIC = \"italic\"; private static final String REGEX_BOLD = \"bold\"; private static final String REGEX_SIZE= \"[0-9]{1,3}pt\"; public final static FontAsValueHandler singleton = new FontAsValueHandler();  private FontAsValueHandler() {}  public static FontAsValueHandler getInstance() {return singleton;}  public String getInputValueSample() { return \"italic 12pt Arial\"; }  public String getRegex() { return REGEX; }  public Font getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { Font font = null; int size = 12; String name = \"Arial\"; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.type; import java.net.URL; import javax.swing.Icon; import javax.swing.ImageIcon; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler; import org.javabuilders.util.BuilderUtils;  public class IconAsValueHandler implements ITypeAsValueHandler<Icon> { private final static IconAsValueHandler singleton = new IconAsValueHandler(); public static IconAsValueHandler getInstance() {return singleton;} public static final String IMAGE_REGEX = \".+\"; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.type; import java.awt.Component; import java.awt.Image; import java.net.URL; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler; import org.javabuilders.util.BuilderUtils;  public class ImageAsValueHandler implements ITypeAsValueHandler<Image> { private static final ImageAsValueHandler singleton = new ImageAsValueHandler();  public static ImageAsValueHandler getInstance() {return singleton;} private ImageAsValueHandler() {}  public String getInputValueSample() {return \"images/save48x48.png\";}  public String getRegex() { return IconAsValueHandler.IMAGE_REGEX; }  public Image getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { String path = (String)inputValue; URL imgURL = BuilderUtils.getResourceURL(process, path); if (imgURL != null) { Object c = node.getMainObject(); if (c instanceof Component) { Component comp = (Component) c; return comp.getToolkit().getImage(imgURL); } else { throw new BuildException(\"Unable to obtain Toolkit required for Image: \" + path); } } else { throw new BuildException(\"Unable to find Image defined by path: \" + path); } }  public Class<?> getApplicableClass() { return Image.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.type; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public class IntArrayAsValueHandler implements ITypeAsValueHandler<int[]> { private static final IntArrayAsValueHandler singleton = new IntArrayAsValueHandler();  public static IntArrayAsValueHandler getInstance() {return singleton;} private IntArrayAsValueHandler() {}  public String getInputValueSample() { return \"weights=(30,40,30)\"; }  public String getRegex() { return IntegerArrayAsValueHandler.REGEX_MATCHER; }  @SuppressWarnings(\"unchecked\") public int[] getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { List<Long> values = (List<Long>)inputValue; int[] returnValue = new int[values.size()]; for(int i = 0; i < values.size();i++) { returnValue[i] = values.get(i).intValue(); } return returnValue; }  public Class<int[]> getApplicableClass() { return int[].class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.type; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public class IntegerArrayAsValueHandler implements ITypeAsValueHandler<Integer[]> { private static final IntegerArrayAsValueHandler singleton = new IntegerArrayAsValueHandler(); public static final String REGEX_MATCHER = \"\\\\[\\\\s*(([0-9]+\\\\s*)|([0-9]+\\\\s*,\\\\s*[0-9]+\\\\s*)+)\\\\s*\\\\]\";;  public static IntegerArrayAsValueHandler getInstance() {return singleton;} private IntegerArrayAsValueHandler() {} public String getInputValueSample() { return \"weights=(30,40,30)\"; }  public String getRegex() { return REGEX_MATCHER; }  @SuppressWarnings(\"unchecked\") public Integer[] getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { List<Long> values = (List<Long>)inputValue; Integer[] returnValue = new Integer[values.size()]; for(int i = 0; i < values.size();i++) { returnValue[i] = values.get(i).intValue(); } return returnValue; }  public Class<Integer[]> getApplicableClass() { return Integer[].class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.validation; import java.util.LinkedList; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.handler.validation.validator.DateFormatValidator; import org.javabuilders.handler.validation.validator.EmailAddressValidator; import org.javabuilders.handler.validation.validator.MandatoryValidator; import org.javabuilders.handler.validation.validator.MaxLengthValidator; import org.javabuilders.handler.validation.validator.MaxValueValidator; import org.javabuilders.handler.validation.validator.MinLengthValidator; import org.javabuilders.handler.validation.validator.MinValueValidator; import org.javabuilders.handler.validation.validator.RegexValidator; import org.javabuilders.handler.validation.validator.TypeValidator; import org.javabuilders.util.PropertyUtils;  @SuppressWarnings(\"serial\") public class BuilderValidators extends LinkedList<PropertyValidations> { private BuildResult result; private static String defaultMandatoryMessage = \"message.error.mandatory\"; private static String defaultMinLengthMessage = \"message.error.minLength\"; private static String defaultMaxLengthMessage = \"message.error.maxLength\"; private static String defaultDateFormatMessage = \"message.error.dateFormat\"; private static String defaultMinValueMessage = \"message.error.minValue\"; private static String defaultMaxValueMessage = \"message.error.maxValue\"; private static String defaultNumericMessage = \"message.error.numeric\"; private static String defaultEmailAddressMessage = \"message.error.emailAddress\"; private static String defaultRegexMessage = \"message.error.regex\"; private String mandatoryMessage = defaultMandatoryMessage; private String minLengthMessage = defaultMinLengthMessage; private String maxLengthMessage = defaultMaxLengthMessage; private String dateFormatMessage = defaultDateFormatMessage; private String minValueMessage = defaultMinValueMessage; private String maxValueMessage = defaultMaxValueMessage; private String numericMessage = defaultNumericMessage; private String emailAddressMessage = defaultEmailAddressMessage; private String regexMessage = defaultRegexMessage; private List<IValidator> validators = new LinkedList<IValidator>(); private boolean validatorsCreated = false;  public BuilderValidators(BuildResult result) { this.result = result; }  public ValidationMessageList getValidationMessages(IValidationMessageHandler validationMessageHandler) { ValidationMessageList list = new ValidationMessageList(); createValidators(validationMessageHandler); for(PropertyValidations validator : this) { Object namedObject = result.get(validator.getProperty().getName()); Object value; boolean isEmptyValue = false; try { value = PropertyUtils.getNestedProperty(namedObject, validator.getProperty().getPropertyExpression()); if (value == null || String.valueOf(value).trim().length() == 0) { isEmptyValue = true; } } catch (Exception e) { throw new BuildException(\"Error while processing validator for \\\"{0}\\\": {1}\", namedObject, e); } "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation; import java.util.List; import java.util.Map; import java.util.logging.Logger; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.NamedObjectProperty; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.util.BuilderUtils;  public class DefaultValidatorTypeHandler extends AbstractTypeHandler implements ITypeChildrenHandler { private static final DefaultValidatorTypeHandler singleton = new DefaultValidatorTypeHandler();  public static DefaultValidatorTypeHandler getInstance() {return singleton;}  private DefaultValidatorTypeHandler() { super(Builder.CONTENT); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { BuilderValidators instance = process.getBuildResult().getValidators(); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  @SuppressWarnings(\"unchecked\") public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent, key, typeDefinition); node.setMainObject(instance); List<Object> contents = (List<Object>)typeDefinition.get(Builder.CONTENT); for(Object validatorData : contents) { if (validatorData instanceof Map) { Map<String,Object> data = (Map<String,Object>)validatorData; for(String dataKey : data.keySet()) { NamedObjectProperty property = BuilderUtils.getParsedProperty(dataKey); PropertyValidations validator = new PropertyValidations(property); Map<String,Object> validatorProperties = (Map<String,Object>)data.get(dataKey); BuilderUtils.populateObjectPropertiesFromMap(validator, validatorProperties); process.getBuildResult().getValidators().add(validator); } } else { throw new BuildException(\"Unable to parse validator data: \" + validatorData); } } return node; }  public Class<?> getApplicableClass() { return BuilderValidators.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.validation;  public interface ICustomValidator extends IValidator {  void validate(ValidationMessageList list); }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation; import org.javabuilders.NamedObjectProperty;  public interface IPropertyValidator extends IValidator {  public NamedObjectProperty getProperty();  void validate(Object value, ValidationMessageList list); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.validation; import org.javabuilders.BuildResult;  public interface IValidationMessageHandler { String DEFAULT_VALIDATION_ERROR_TITLE = \"title.validationError\"; String DEFAULT_VALIDATION_ERRORS_TITLE = \"title.validationErrors\";  void handleValidationMessages(ValidationMessageList list, BuildResult result);  String getNamedObjectLabel(Object namedObject); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.validation;  public interface IValidator {}"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.validation; import java.util.List; import java.util.Locale; import org.javabuilders.NamedObjectProperty;  public class PropertyValidations { private NamedObjectProperty property; private boolean mandatory = false; private Integer minLength = null; private Integer maxLength = null; private String dateFormat = null; private String format = null; private Object minValue = null; private Object maxValue = null; private List<String> range = null; private boolean currency = false; private boolean percent = false; private String regex = null; private boolean regexCaseSensitive = true; private String regexMessage = null; private boolean luhnCheckDigit = false; private boolean ean13CheckDigit = false; private boolean isbnCheckDigit = false; private boolean isbn10CheckDigit = false; private boolean ipAddress = false; private boolean email = false; private boolean url = false; private boolean domain = false; private boolean topLevelDomain = false; private boolean genericTopLevelDomain = false; private boolean countryCodeTopLevelDomain = false; private String locale = null; private String type = null; private String label;  public PropertyValidations(NamedObjectProperty property) { this.property = property; }  public NamedObjectProperty getProperty() { return property; }  public boolean isMandatory() { return mandatory; }  public void setMandatory(boolean mandatory) { this.mandatory = mandatory; }  public Integer getMinLength() { return minLength; }  public void setMinLength(Integer minLength) { this.minLength = minLength; }  public Integer getMaxLength() { return maxLength; }  public void setMaxLength(Integer maxLength) { this.maxLength = maxLength; }  public String getDateFormat() { return dateFormat; }  public void setDateFormat(String dateFormat) { this.dateFormat = dateFormat; }  public String getFormat() { return format; }  public void setFormat(String format) { this.format = format; }  public List<String> getRange() { return range; }  public void setRange(List<String> range) { this.range = range; }  public boolean isCurrency() { return currency; }  public void setCurrency(boolean currency) { this.currency = currency; }  public boolean isPercent() { return percent; }  public void setPercent(boolean percent) { this.percent = percent; }  public String getRegex() { return regex; }  public void setRegex(String regex) { this.regex = regex; }  public boolean isRegexCaseSensitive() { return regexCaseSensitive; }  public void setRegexCaseSensitive(boolean regexCaseSensitive) { this.regexCaseSensitive = regexCaseSensitive; }  public boolean isLuhnCheckDigit() { return luhnCheckDigit; }  public void setLuhnCheckDigit(boolean luhnCheckDigit) { this.luhnCheckDigit = luhnCheckDigit; }  public boolean isEan13CheckDigit() { return ean13CheckDigit; }  public void setEan13CheckDigit(boolean ean13CheckDigit) { this.ean13CheckDigit = ean13CheckDigit; }  public boolean isIsbnCheckDigit() { return isbnCheckDigit; }  public void setIsbnCheckDigit(boolean isbnCheckDigit) { this.isbnCheckDigit = isbnCheckDigit; }  public boolean isIsbn10CheckDigit() { return isbn10CheckDigit; }  public void setIsbn10CheckDigit(boolean isbn10CheckDigit) { this.isbn10CheckDigit = isbn10CheckDigit; }  public boolean isIpAddress() { return ipAddress; }  public void setIpAddress(boolean ipAddress) { this.ipAddress = ipAddress; }  public boolean isEmailAddress() { return email; }  public void setEmailAddress(boolean emailAddress) { this.email = emailAddress; }  public boolean isUrl() { return url; }  public void setUrl(boolean url) { this.url = url; }  public boolean isDomain() { return domain; }  public void setDomain(boolean domain) { this.domain = domain; }  public boolean isTopLevelDomain() { return topLevelDomain; }  public void setTopLevelDomain(boolean topLevelDomain) { this.topLevelDomain = topLevelDomain; }  public boolean isGenericTopLevelDomain() { return genericTopLevelDomain; }  public void setGenericTopLevelDomain(boolean genericTopLevelDomain) { this.genericTopLevelDomain = genericTopLevelDomain; }  public boolean isCountryCodeTopLevelDomain() { return countryCodeTopLevelDomain; }  public void setCountryCodeTopLevelDomain(boolean countryCodeTopLevelDomain) { this.countryCodeTopLevelDomain = countryCodeTopLevelDomain; }  @Override public String toString() { return property.toString(); }  public String getLabel() { return label; }  public void setLabel(String label) { this.label = label; }  public String getLocale() { return locale; }  public void setLocale(String locale) { this.locale = locale; }  public Locale getLocaleInstance() { if (getLocale() == null) { return Locale.getDefault(); } else { String[] parts = getLocale().split(\"-\"); if (parts.length == 1) { return new Locale(parts[0]); } else { return new Locale(parts[0],parts[1]); } } }  public boolean isEmail() { return email; }  public void setEmail(boolean email) { this.email = email; }  public String getRegexMessage() { return regexMessage; }  public void setRegexMessage(String regexMessage) { this.regexMessage = regexMessage; }  public Object getMinValue() { return minValue; }  public void setMinValue(Object minValue) { this.minValue = minValue; }  public Object getMaxValue() { return maxValue; }  public void setMaxValue(Object maxValue) { this.maxValue = maxValue; }  public String getType() { return type; }  public void setType(String type) { this.type = type; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.validation; import org.javabuilders.Builder; import org.javabuilders.NamedObjectProperty;  public class ValidationMessage { private NamedObjectProperty property; private String message;  public ValidationMessage(String message) { this.message = message; }  public ValidationMessage(String propertyName, String message) { this.property = new NamedObjectProperty(Builder.THIS,propertyName); this.message = message; }  public ValidationMessage(String objectName, String propertyName, String message) { this.property = new NamedObjectProperty(objectName,propertyName); this.message = message; }  public ValidationMessage(NamedObjectProperty property, String message) { this.property = property; this.message = message; }  public NamedObjectProperty getProperty() { return property; }  public void setProperty(NamedObjectProperty property) { this.property = property; }  public String getMessage() { return message; }  public void setMessage(String message) { this.message = message; }  @Override public String toString() { return String.format(\"%s: %s\",property,message); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.handler.validation; import java.util.LinkedList;  @SuppressWarnings(\"serial\") public class ValidationMessageList extends LinkedList<ValidationMessage> {  @Override public boolean add(ValidationMessage o) { boolean duplicate = false; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import java.text.MessageFormat; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.IPropertyValidator; import org.javabuilders.handler.validation.IValidator;  public abstract class AbstractValidator implements IValidator, IPropertyValidator { private String label; private String messageFormat; private BuildResult result; private NamedObjectProperty property;  public AbstractValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result) { this.property = property; this.label = label; this.messageFormat = messageFormat; this.result = result; }  public String getLabel() { return label; }  public void setLabel(String label) { this.label = label; }  public void setMessageFormat(String message) { this.messageFormat = message; }  public String getMessageFormat() { return messageFormat; }  public String getMessage(Object...arguments) { String pattern = result.getResource(messageFormat); return MessageFormat.format(pattern, arguments); }  protected String getMessageForFormat(String pattern, Object...arguments) { pattern = result.getResource(pattern); return MessageFormat.format(pattern, arguments); }  public NamedObjectProperty getProperty() { return property; }  public void setProperty(NamedObjectProperty property) { this.property = property; }  protected String getStringValue(Object value) { return (value instanceof String) ? (String)value : String.valueOf(value); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Locale; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class DateFormatValidator extends AbstractValidator { private String dateFormat; private Locale locale;  public DateFormatValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result, String dateFormat, Locale locale) { super(property, label, messageFormat, result); this.dateFormat = dateFormat; this.locale = locale; }  public void validate(Object value, ValidationMessageList list) { String sValue = getStringValue(value); SimpleDateFormat sdf = new SimpleDateFormat(dateFormat, locale); try { Date date = sdf.parse(sValue); if (!sdf.format(date).equals(sValue)) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import java.util.regex.Pattern; import org.apache.commons.lang.StringUtils; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class EmailAddressValidator extends AbstractValidator { private static String REGEX = \"[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\";  public EmailAddressValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result) { super(property, label, messageFormat, result); }  public void validate(Object value, ValidationMessageList list) { String sValue = getStringValue(value); if (StringUtils.isNotEmpty(sValue)) { if (!Pattern.matches(REGEX, sValue)) { list.add(new ValidationMessage(getProperty(), getMessage(getLabel()))); } } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class MandatoryValidator extends AbstractValidator {  public MandatoryValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result) { super(property, label, messageFormat, result); }  public void validate(Object value, ValidationMessageList list) { if (value == null) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class MaxLengthValidator extends AbstractValidator { private Integer maxLength=0;  public MaxLengthValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result, Integer maxLength) { super(property, label, messageFormat, result); this.maxLength = maxLength; }  public void validate(Object value, ValidationMessageList list) { String sValue = getStringValue(value); if (sValue != null && sValue.length() > maxLength) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.BuilderValidators; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class MaxValueValidator extends AbstractValidator { private Object maxValue = null; private Long maxValueLong = null; private Double maxValueDouble = null;  public MaxValueValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result, Object maxValue) { super(property, label, messageFormat, result); this.maxValue = maxValue; try { maxValueDouble = Double.parseDouble(maxValue.toString()); } catch (Exception ex) {} try { if (maxValueDouble == null) { maxValueLong = Long.parseLong(maxValue.toString()); } } catch (Exception ex) {} if (maxValueDouble == null && maxValueLong == null) { throw new BuildException(\"{0} is not a valid Long or Double comparison value\",maxValue); } }  public void validate(Object value, ValidationMessageList list) { String sValue = String.valueOf(value); if (maxValueDouble != null) { try { Double dbl = Double.parseDouble(sValue); if (dbl > maxValueDouble) { list.add(new ValidationMessage(getProperty(), getMessage(getLabel(),maxValue))); } } catch (NumberFormatException ex) { list.add(new ValidationMessage(getProperty(), getMessageForFormat(BuilderValidators.getDefaultNumericMessage(),getLabel()))); } } else if (maxValueLong != null) { try { Long lng = Long.parseLong(sValue); if (lng > maxValueLong) { list.add(new ValidationMessage(getProperty(), getMessage(getLabel(),maxValue))); } } catch (NumberFormatException ex) { list.add(new ValidationMessage(getProperty(), getMessageForFormat(BuilderValidators.getDefaultNumericMessage(),getLabel()))); } } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class MinLengthValidator extends AbstractValidator { private Integer minLength;  public MinLengthValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result, Integer minLength) { super(property, label, messageFormat, result); this.minLength = minLength; }  public void validate(Object value, ValidationMessageList list) { String sValue = getStringValue(value); if (sValue == null || sValue.length() < minLength) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.BuilderValidators; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class MinValueValidator extends AbstractValidator { private Object minValue = null; private Long minValueLong = null; private Double minValueDouble = null;  public MinValueValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result, Object minValue) { super(property, label, messageFormat, result); this.minValue = minValue; try { minValueDouble = Double.parseDouble(minValue.toString()); } catch (Exception ex) {} try { if (minValueDouble == null) { minValueLong = Long.parseLong(minValue.toString()); } } catch (Exception ex) {} if (minValueDouble == null && minValueLong == null) { throw new BuildException(\"{0} is not a valid Long or Double comparison value\",minValue); } }  public void validate(Object value, ValidationMessageList list) { String sValue = String.valueOf(value); if (minValueDouble != null) { try { Double dbl = Double.parseDouble(sValue); if (dbl < minValueDouble) { list.add(new ValidationMessage(getProperty(), getMessage(getLabel(),minValue))); } } catch (NumberFormatException ex) { list.add(new ValidationMessage(getProperty(), getMessageForFormat(BuilderValidators.getDefaultNumericMessage(),getLabel()))); } } else if (minValueLong != null) { try { Long lng = Long.parseLong(sValue); if (lng < minValueLong) { list.add(new ValidationMessage(getProperty(), getMessage(getLabel(),minValue))); } } catch (NumberFormatException ex) { list.add(new ValidationMessage(getProperty(), getMessageForFormat(BuilderValidators.getDefaultNumericMessage(),getLabel()))); } } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class RegexValidator extends AbstractValidator { private String regex = \"\";  public RegexValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result, String regex) { super(property, label, messageFormat, result); this.regex = regex; }  public void validate(Object value, ValidationMessageList list) { String sValue = getStringValue(value); if (!sValue.matches(regex)) { list.add(new ValidationMessage(getProperty(), getMessage(getLabel()))); } }  public String getRegex() { return regex; }  public void setRegex(String regex) { this.regex = regex; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.handler.validation.validator; import java.util.ArrayList; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.NamedObjectProperty; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList;  public class TypeValidator extends AbstractValidator { public static final String INT = \"int\"; public static final String LONG = \"long\"; public static final String SHORT = \"short\"; public static final String BYTE = \"byte\"; public static final String DOUBLE=\"double\"; public static final String FLOAT = \"float\"; private static List<String> types = new ArrayList<String>(); private String type = LONG; static { types.add(INT); types.add(LONG); types.add(SHORT); types.add(BYTE); types.add(DOUBLE); types.add(FLOAT); }  public TypeValidator(NamedObjectProperty property, String label, String messageFormat, BuildResult result, String type) { super(property, label, messageFormat, result); if (!types.contains(type)) { throw new BuildException(\"\\\"{0}\\\" is not a valid type. Allowed values are: {1}\", type, types); } this.type = type; }  public void validate(Object value, ValidationMessageList list) { String errorFormat = null; try { if (type.equals(INT)) { errorFormat = \"message.error.int\"; Integer.parseInt(String.valueOf(value)); } else if (type.equals(LONG)) { errorFormat = \"message.error.long\"; Long.parseLong(String.valueOf(value)); } else if (type.equals(SHORT)) { errorFormat = \"message.error.short\"; Short.parseShort(String.valueOf(value)); } else if (type.equals(BYTE)) { errorFormat = \"message.error.byte\"; Byte.parseByte(String.valueOf(value)); } else if (type.equals(DOUBLE)) { errorFormat = \"message.error.double\"; Double.parseDouble(String.valueOf(value)); } else if (type.equals(FLOAT)) { errorFormat = \"message.error.float\"; Float.parseFloat(String.valueOf(value)); } else { throw new BuildException(\"Unexpected type: {0}\" + type); } } catch (NumberFormatException e) { list.add(new ValidationMessage(getProperty(),getMessageForFormat(errorFormat,getLabel()))); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout; import java.util.ArrayList; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class ControlConstraint { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout;  public enum DefaultResize { X_AXIS, Y_AXIS, BOTH, NONE }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.layout;  public enum Flow { VERTICAL, HORIZONTAL }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout;  public enum HAlign { LEFT, CENTER, RIGHT, DEFAULT; }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.layout; import java.util.ArrayList; import java.util.List;  public class LayoutCell {  public static final char SPAN_INDICATOR='+';  public static final char MAX_SPAN_VALUE = '*'; private int columnIndex = 0; private int rowIndex = 0; private Flow flow = Flow.HORIZONTAL; private List<ControlConstraint> controls = new ArrayList<ControlConstraint>();  public LayoutCell(int rowIndex, int cellIndex) { this.rowIndex = rowIndex; this.columnIndex = cellIndex; }  public List<ControlConstraint> getControls() { return controls; }  public int getColumnIndex() { return columnIndex; }  public int getRowIndex() { return rowIndex; }  public void setColumnIndex(int columnIndex) { this.columnIndex = columnIndex; }  public void setRowIndex(int rowIndex) { this.rowIndex = rowIndex; }  public int getHSpan() { if (getControls().size() == 0) { return 1; } else { return getControls().get(0).getHSpan(); } }  public int getVSpan() { if (getControls().size() == 0) { return 1; } else { return getControls().get(0).getVSpan(); } }  public Flow getFlow() { return flow; }  public void setFlow(Flow flow) { this.flow = flow; }  @Override public String toString() { return String.format(\"Row: %s / Cell: %s / Controls: %s\", rowIndex, columnIndex, controls); }  @Override public int hashCode() { return (rowIndex*1000)+columnIndex; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.TreeMap; import java.util.TreeSet; import org.javabuilders.util.BuilderUtils; import org.javabuilders.util.JBStringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.yaml.snakeyaml.Yaml;  public class LayoutConstraints { private final static Logger logger = LoggerFactory.getLogger(LayoutConstraints.class); private String layoutConstraints =\"\"; private List<String> rowConstraints= new ArrayList<String>(); private List<String> columnConstraints= new ArrayList<String>(); private Set<LayoutCell> cells = new LinkedHashSet<LayoutCell>(); private Map<Integer,Set<String>> sizeGroups = new HashMap<Integer, Set<String>>(); private Map<String,String> additionalControlConstraints = new HashMap<String, String>();  public LayoutConstraints() {}  public LayoutConstraints(String layoutConstraints) { this.layoutConstraints = layoutConstraints; }  public String getLayoutConstraints() { return layoutConstraints; }  public void setLayoutConstraints(String layoutConstraints) { this.layoutConstraints = layoutConstraints; }  public List<String> getRowConstraints() { return rowConstraints; }  @Override public String toString() { return String.format(\"General: %s\\nRow: %s\\nColumn: %s\\nCells:\\n%s\", layoutConstraints,rowConstraints,columnConstraints,cells); }  @Override public int hashCode() { return toString().hashCode(); }  public List<String> getColumnConstraints() { return columnConstraints; }  public Set<LayoutCell> getCells() { return cells; }  public LayoutCell getCellAt(int rowIndex, int columnIndex) { for(LayoutCell cell : getCells()) { if (cell.getRowIndex() == rowIndex && cell.getColumnIndex() == columnIndex) { return cell; } } return null; }  public Map<Integer, Set<String>> getSizeGroups() { return sizeGroups; }  public int getRowCount() { int maxRow = 0; for (LayoutCell cell : getCells()) { if (cell.getRowIndex() > maxRow) { maxRow = cell.getRowIndex(); } } return maxRow + 1; }  public int getColumnCount() { int maxColumn = 0; for (LayoutCell cell : getCells()) { if (cell.getColumnIndex() > maxColumn) { maxColumn = cell.getColumnIndex(); } } return maxColumn + 1; }  private void updateSpanForMaxValues() { int rows = getRowCount(); int columns = getColumnCount(); for (LayoutCell cell : getCells()) { if (cell.getControls().size() > 0) { ControlConstraint co = cell.getControls().get(0); if (co.isMaxHSpan()) { co.setHSpan(columns - cell.getColumnIndex()); } if (co.isMaxVSpan()) { co.setVSpan(rows - cell.getRowIndex()); } } } }   public static LayoutConstraints getParsedLayoutConstraints(String layout, String defaultRowContraint, String defaultColumnConstraint) throws LayoutException { LayoutConstraints constraints = new LayoutConstraints(); String columnConstraintLine = \"\"; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.layout; import org.javabuilders.BuildException;  @SuppressWarnings(\"serial\") public class LayoutException extends BuildException {  public LayoutException(String message, Object...args) { super(message, args); }  public LayoutException(Throwable cause) { super(cause); }  public LayoutException(String message, Throwable cause) { super(cause, message); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout;  public enum Size { MIN, PREF, MAX, DEFAULT; }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout;  public enum VAlign { TOP, MIDDLE, BOTTOM, DEFAULT; }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout.mig; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import org.apache.commons.lang.StringUtils; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.IStringLiteralControlConfig; import org.javabuilders.Node; import org.javabuilders.TypeDefinition; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.layout.ControlConstraint; import org.javabuilders.layout.DefaultResize; import org.javabuilders.layout.Flow; import org.javabuilders.layout.HAlign; import org.javabuilders.layout.LayoutCell; import org.javabuilders.layout.LayoutConstraints; import org.javabuilders.layout.VAlign; import org.javabuilders.util.BuilderUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public abstract class AbstractMigLayoutHandler extends AbstractTypeHandler implements ITypeChildrenHandler { private final static Map<DefaultResize,String> resizeConstraints = new HashMap<DefaultResize, String>(); protected final static Logger logger = LoggerFactory.getLogger(AbstractMigLayoutHandler.class); private Class<?> defaultTypeClass = null; private String defaultTypePropertyName = null;  static { resizeConstraints.put(DefaultResize.BOTH, \"grow\"); resizeConstraints.put(DefaultResize.X_AXIS, \"growx\"); resizeConstraints.put(DefaultResize.Y_AXIS, \"growy\"); }  protected AbstractMigLayoutHandler(Class<?> defaultTypeClass, String defaultTypePropertyName) { super(); this.defaultTypeClass = defaultTypeClass; this.defaultTypePropertyName = defaultTypePropertyName; } protected abstract void setLayout(BuildProcess result, Node node, Object migLayout) throws BuildException; protected abstract Object getComponent(BuildProcess result, Node components, String name) throws BuildException; protected abstract void setLayoutConstraints(Object layout, String constraints) throws BuildException; protected abstract void setRowConstraints(Object layout, String constraints) throws BuildException; protected abstract void setColumnConstraints(Object layout, String constraints) throws BuildException; protected abstract void applyControlConstraints(BuildProcess result, Node node, Node components, Map<String,String> layoutConstraints) throws BuildException; protected abstract void setControlName(Object control, String name);  @SuppressWarnings(\"unchecked\") public final Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition); node.setMainObject(instance); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.layout.mig; import java.util.HashMap; import java.util.Map; import org.javabuilders.layout.ControlConstraint; import org.javabuilders.layout.DefaultResize; import org.javabuilders.layout.Size;  public class MigLayoutCommon { public final static String LAYOUT_CONSTRAINTS = \"layoutConstraints\"; public final static String ROW_CONSTRAINTS = \"rowConstraints\"; public final static String COLUMN_CONSTRAINTS = \"columnConstraints\"; public final static String DEFAULT_ROW_COLUMN_CONSTRAINT = \"[] \";  private final static Map<DefaultResize,String> resizeConstraints = new HashMap<DefaultResize, String>(); static { resizeConstraints.put(DefaultResize.BOTH, \"grow\"); resizeConstraints.put(DefaultResize.X_AXIS, \"growx\"); resizeConstraints.put(DefaultResize.Y_AXIS, \"growy\"); }  public static void handleResize(StringBuilder builder, ControlConstraint c, DefaultResize defaultResize, String additionalConstraints) { String resize = resizeConstraints.get(defaultResize); if (c.getHSize() == Size.DEFAULT && c.getVSize() == Size.DEFAULT) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.util; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.net.URL; import java.text.MessageFormat; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Set; import java.util.TreeMap; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuildResult; import org.javabuilders.BuilderConfig; import org.javabuilders.BuilderPreProcessor; import org.javabuilders.ICustomCommand; import org.javabuilders.NamedObjectProperty; import org.javabuilders.Node; import org.javabuilders.Values; import org.javabuilders.annotations.Alias; import org.javabuilders.annotations.DoInBackground; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.BackgroundEventListener; import org.javabuilders.event.CancelStatus; import org.javabuilders.event.IBackgroundCallback; import org.javabuilders.event.IBindingListener; import org.javabuilders.event.IBindingListenerProvider; import org.javabuilders.event.ObjectMethod; import org.javabuilders.exception.InvalidFormatException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.yaml.snakeyaml.Yaml;  public class BuilderUtils { private final static Logger logger = LoggerFactory.getLogger(BuilderUtils.class); private static OperatingSystem os = OperatingSystem.Windows; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.util; import java.util.Map; import java.util.Set; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.ChildrenCardinalityException; import org.javabuilders.Node; import org.javabuilders.TypeDefinition;  public class ChildrenCardinalityUtils {  public static void checkChildrenCardinality(BuilderConfig config, Node current) { if (!current.getKey().equals(Builder.CONTENT)) { Object obj = current.getMainObject(); Map<Class<?>,int[]> childrenCardinalities = TypeDefinition.getChildrenCardinality(config, obj.getClass()); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.util; import java.util.LinkedList; import java.util.List; import org.javabuilders.BuildProcess; import org.javabuilders.IResourceFallback;  public class JBStringUtils { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.util; import org.javabuilders.BuildException;  public class Preconditions {  public static void checkNotNull(Object source, String messageFormat, Object...params) { if (source == null) { throw new BuildException(messageFormat,params); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.util; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.util.Set; import java.util.TreeSet; import org.javabuilders.BuildException;  public class PropertyUtils { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.util;  public class Tuple2<T0,T1> { private T0 obj0; private T1 obj1; public Tuple2(T0 obj0, T1 obj1) { this.obj0 = obj0; this.obj1 = obj1; } public T0 get0() { return obj0; } public T1 get1() { return obj1; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.util; import java.util.ResourceBundle; import org.javabuilders.BuildResult; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig;  public class YamlBuilder { private StringBuilder builder = new StringBuilder();  public YamlBuilder(String root) { _(root); }  private YamlBuilder _(String yamlLine) { builder.append(yamlLine).append(\"\\n\"); return this; }  public YamlBuilder ___(String yamlLine) { nest(); return _(yamlLine); }  public YamlBuilder _____(String yamlLine) { nest(); return ___(yamlLine); }  public YamlBuilder _______(String yamlLine) { nest(); return _____(yamlLine); }  public YamlBuilder _________(String yamlLine) { nest(); return _______(yamlLine); }  public YamlBuilder ___________(String yamlLine) { nest(); return _________(yamlLine); }  public YamlBuilder _____________(String yamlLine) { nest(); return ___________(yamlLine); }  public YamlBuilder _______________(String yamlLine) { nest(); return _____________(yamlLine); }  public YamlBuilder _________________(String yamlLine) { nest(); return _______________(yamlLine); } "}
{"name": "jacek99/javabuilders", "content": "package org.gnome.gtk;  public class GtkJavaBuilderInternalUtils {  public static Stock getStock(String stockId) { return Stock.instanceFor(stockId); }  public static void setScaleDrawValue(Scale scale, boolean drawValue) { GtkScale.setDrawValue(scale, drawValue); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk;  public class GtkConstants { public static final String ACTION = \"action\"; public static final String LABEL = \"label\"; public static final String LAYOUT = \"layout\"; public static final String HOMOGENOUS = \"homogenous\"; public static final String MNEMONIC_LABEL = \"mnemonicLabel\"; public static final String SPACING = \"spacing\"; public static final String STOCK= \"stock\"; public static final String TITLE = \"title\"; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk; import java.util.ResourceBundle; import org.javabuilders.BuildResult; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; public class GtkJavaBuilder { private static BuilderConfig config = new GtkJavaBuilderConfig(null,null,null, null);  public static BuilderConfig getConfig() { return config; }  public static BuildResult build(Object caller) { return Builder.build(getConfig(),caller); }  public static BuildResult build(Object caller, ResourceBundle...bundles) { return Builder.build(getConfig(),caller,bundles); }  public static BuildResult build(Object caller, String yaml, ResourceBundle...bundles) { return Builder.buildFromString(getConfig(),caller, yaml, bundles); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk; import static org.javabuilders.gtk.GtkConstants.*; import java.beans.PropertyChangeSupport; import java.util.Calendar; import org.freedesktop.bindings.Constant; import org.gnome.gtk.AccelLabel; import org.gnome.gtk.Action; import org.gnome.gtk.Alignment; import org.gnome.gtk.Arrow; import org.gnome.gtk.AspectFrame; import org.gnome.gtk.Assistant; import org.gnome.gtk.Box; import org.gnome.gtk.Button; import org.gnome.gtk.ButtonBox; import org.gnome.gtk.CellView; import org.gnome.gtk.CheckButton; import org.gnome.gtk.CheckMenuItem; import org.gnome.gtk.ColorButton; import org.gnome.gtk.ColorSelection; import org.gnome.gtk.ComboBox; import org.gnome.gtk.ComboBoxEntry; import org.gnome.gtk.Container; import org.gnome.gtk.Dialog; import org.gnome.gtk.DrawingArea; import org.gnome.gtk.Entry; import org.gnome.gtk.EventBox; import org.gnome.gtk.Expander; import org.gnome.gtk.FileChooserAction; import org.gnome.gtk.FileChooserButton; import org.gnome.gtk.FileChooserWidget; import org.gnome.gtk.Fixed; import org.gnome.gtk.FontButton; import org.gnome.gtk.FontSelection; import org.gnome.gtk.Frame; import org.gnome.gtk.HBox; import org.gnome.gtk.HButtonBox; import org.gnome.gtk.HPaned; import org.gnome.gtk.HRuler; import org.gnome.gtk.HScale; import org.gnome.gtk.HScrollbar; import org.gnome.gtk.HSeparator; import org.gnome.gtk.HandleBox; import org.gnome.gtk.IconView; import org.gnome.gtk.Image; import org.gnome.gtk.ImageMenuItem; import org.gnome.gtk.Label; import org.gnome.gtk.Layout; import org.gnome.gtk.LinkButton; import org.gnome.gtk.Menu; import org.gnome.gtk.MenuBar; import org.gnome.gtk.MenuItem; import org.gnome.gtk.MenuShell; import org.gnome.gtk.MenuToolButton; import org.gnome.gtk.Notebook; import org.gnome.gtk.Paned; import org.gnome.gtk.Plug; import org.gnome.gtk.ProgressBar; import org.gnome.gtk.RadioButton; import org.gnome.gtk.RadioMenuItem; import org.gnome.gtk.RecentChooserMenu; import org.gnome.gtk.RecentChooserWidget; import org.gnome.gtk.Ruler; import org.gnome.gtk.Scale; import org.gnome.gtk.ScaleButton; import org.gnome.gtk.ScrolledWindow; import org.gnome.gtk.SeparatorMenuItem; import org.gnome.gtk.SeparatorToolItem; import org.gnome.gtk.Socket; import org.gnome.gtk.SpinButton; import org.gnome.gtk.Statusbar; import org.gnome.gtk.Table; import org.gnome.gtk.TearoffMenuItem; import org.gnome.gtk.TextComboBox; import org.gnome.gtk.TextComboBoxEntry; import org.gnome.gtk.TextView; import org.gnome.gtk.ToggleButton; import org.gnome.gtk.ToggleToolButton; import org.gnome.gtk.ToolButton; import org.gnome.gtk.ToolItem; import org.gnome.gtk.Toolbar; import org.gnome.gtk.TreeView; import org.gnome.gtk.TreeViewColumn; import org.gnome.gtk.VBox; import org.gnome.gtk.VButtonBox; import org.gnome.gtk.VPaned; import org.gnome.gtk.VRuler; import org.gnome.gtk.VScale; import org.gnome.gtk.VScrollbar; import org.gnome.gtk.VSeparator; import org.gnome.gtk.Viewport; import org.gnome.gtk.Widget; import org.gnome.gtk.Window; import org.javabuilders.BuilderConfig; import org.javabuilders.ICustomCommand; import org.javabuilders.event.IBackgroundProcessingHandler; import org.javabuilders.gtk.handler.property.ScaleDrawValueHandler; import org.javabuilders.gtk.handler.type.ConstantAsValueHandler; import org.javabuilders.gtk.handler.type.ContainerFinishProcessor; import org.javabuilders.gtk.handler.type.FileChooserActionAsValue; import org.javabuilders.gtk.handler.type.FileChooserButtonTypeHandler; import org.javabuilders.gtk.handler.type.HBoxTypeHandler; import org.javabuilders.gtk.handler.type.HScaleTypeHandler; import org.javabuilders.gtk.handler.type.LabelHandler; import org.javabuilders.gtk.handler.type.MenuItemTypeHandler; import org.javabuilders.gtk.handler.type.MenuShellFinishProcessor; import org.javabuilders.gtk.handler.type.NotebookFinishProcessor; import org.javabuilders.gtk.handler.type.PanedFinishProcessor; import org.javabuilders.gtk.handler.type.ScrolledWindowFinishProcessor; import org.javabuilders.gtk.handler.type.TableTypeHandler; import org.javabuilders.gtk.handler.type.TreeViewColumnTypeHandler; import org.javabuilders.gtk.handler.type.VBoxTypeHandler; import org.javabuilders.handler.ITypeHandler; import org.javabuilders.handler.validation.IValidationMessageHandler; import org.javabuilders.layout.DefaultResize;  public class GtkJavaBuilderConfig extends BuilderConfig{ public GtkJavaBuilderConfig( IBackgroundProcessingHandler backgroundProcessingHandler, ITypeHandler bindingTypeHandler, IValidationMessageHandler validationMessageHandler, ICustomCommand<Boolean> confirmCommand) { super(null, null, null); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.property; import org.freedesktop.bindings.Pointer; import org.gnome.gtk.GtkJavaBuilderInternalUtils; import org.gnome.gtk.Scale; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler;  public class ScaleDrawValueHandler extends AbstractPropertyHandler { public ScaleDrawValueHandler() { super(\"drawValue\"); }  public void handle(BuilderConfig config, BuildProcess process, Node node, String key) throws BuildException { Scale scale = (Scale) node.getMainObject(); if (\"false\".equals(node.getStringProperty(\"drawValue\"))) { GtkJavaBuilderInternalUtils.setScaleDrawValue(scale, false); } else { GtkJavaBuilderInternalUtils.setScaleDrawValue(scale, true); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk.handler.type; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import org.freedesktop.bindings.Constant; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.TypeDefinition; import org.javabuilders.handler.ITypeAsValueHandler; import org.javabuilders.util.PropertyUtils; public class ConstantAsValueHandler implements ITypeAsValueHandler<Constant> {  public String getInputValueSample() { return \"tabPosition=left | tabPosition=LEFT\"; }  public String getRegex() { return \".+\"; }  public Constant getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { Constant c = null; try { Class<?> type = PropertyUtils.getPropertyType(node.getMainObject(), key); Field[] fields = type.getFields(); for(Field field : fields) { int mod = field.getModifiers(); if (Modifier.isPublic(mod) && Modifier.isFinal(mod) && Modifier.isStatic(mod) && Constant.class.isAssignableFrom(field.getType())) { String name = field.getName(); String camelCase = TypeDefinition.getShortEnumConstant(field.getName()); if (inputValue.equals(name) || inputValue.equals(camelCase)) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Set; import org.gnome.gtk.Container; import org.gnome.gtk.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.TypeDefinition; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class ContainerFinishProcessor implements ITypeHandlerFinishProcessor {  public Class<Container> getApplicableClass() { return Container.class; }  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.HashMap; import java.util.Map; import org.gnome.gtk.FileChooserAction; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public class FileChooserActionAsValue implements ITypeAsValueHandler<FileChooserAction> { private static final String regex = \"CREATE_FOLDER|OPEN|SAVE|SELECT_FOLDER|createFolder|open|save|selectFolder\"; private static final Map<String,FileChooserAction> values = new HashMap<String, FileChooserAction>(); static { values.put(\"CREATE_FOLDER\", FileChooserAction.CREATE_FOLDER); values.put(\"createFolder\", FileChooserAction.CREATE_FOLDER); values.put(\"OPEN\", FileChooserAction.OPEN); values.put(\"open\", FileChooserAction.OPEN); values.put(\"SAVE\", FileChooserAction.SAVE); values.put(\"save\", FileChooserAction.SAVE); values.put(\"SELECT_FOLDER\", FileChooserAction.SELECT_FOLDER); values.put(\"selectFolder\", FileChooserAction.SELECT_FOLDER); }  public String getInputValueSample() { return regex; }  public String getRegex() { return regex; }  public FileChooserAction getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { return values.get(inputValue); }  public Class<FileChooserAction> getApplicableClass() { return FileChooserAction.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk.handler.type; import java.util.Map; import org.gnome.gtk.FileChooserAction; import org.gnome.gtk.FileChooserButton; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.handler.AbstractTypeHandler;  public class FileChooserButtonTypeHandler extends AbstractTypeHandler {  public FileChooserButtonTypeHandler() { super(GtkConstants.ACTION,GtkConstants.TITLE); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { String title = (String) typeDefinition.get(GtkConstants.TITLE); String action = (String) typeDefinition.get(GtkConstants.ACTION); if (action == null) { action = \"OPEN\"; } FileChooserAction actionInstance = FileChooserAction.SELECT_FOLDER; FileChooserButton instance = new FileChooserButton(title,actionInstance); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition,instance); return node; } public Class<FileChooserButton> getApplicableClass() { return FileChooserButton.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import static org.javabuilders.gtk.GtkConstants.*; import java.util.Map; import org.gnome.gtk.HBox; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.handler.AbstractTypeHandler;  public class HBoxTypeHandler extends AbstractTypeHandler {  public HBoxTypeHandler() { super(HOMOGENOUS, SPACING); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Boolean homogenous = (Boolean) typeDefinition.get(GtkConstants.HOMOGENOUS); if (homogenous == null) { homogenous = Boolean.FALSE; } Integer spacing = (Integer) typeDefinition.get(GtkConstants.SPACING); if (spacing == null) { spacing = 4; } HBox instance = new HBox(homogenous,spacing); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent, key, typeDefinition); node.setMainObject(instance); return node; }  public Class<HBox> getApplicableClass() { return HBox.class; }  public boolean isApplicableToSubclasses() { return false; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.Map; import org.gnome.gtk.HScale; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler;  public class HScaleTypeHandler extends AbstractTypeHandler { public HScaleTypeHandler() { super(\"min\",\"max\",\"step\"); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Integer min = (Integer) typeDefinition.get(\"min\"); Integer max = (Integer) typeDefinition.get(\"max\"); Integer step = (Integer) typeDefinition.get(\"step\"); HScale instance = new HScale(min,max,step); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition,instance); return node; }  public Class<HScale> getApplicableClass() { return HScale.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.Map; import org.gnome.gtk.Label; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler;  public class LabelHandler extends AbstractTypeHandler {  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Label instance = new Label(\"\"); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { return new Node(parent,key,typeDefinition,instance); }  public Class<Label> getApplicableClass() { return Label.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.Map; import java.util.Set; import org.gnome.gtk.Menu; import org.gnome.gtk.MenuItem; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class MenuItemTypeHandler extends AbstractTypeHandler implements ITypeHandlerFinishProcessor{  public MenuItemTypeHandler() { super(GtkConstants.LABEL, GtkConstants.MNEMONIC_LABEL); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { MenuItem instance = null; String label = (String) typeDefinition.get(GtkConstants.MNEMONIC_LABEL); if (label == null) { label = (String) typeDefinition.get(GtkConstants.LABEL); } instance = new MenuItem(label); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition,instance); return node; }  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { if (1==1) return; MenuItem item = (MenuItem) current.getMainObject(); Set<Node> nodes = current.getContentNodes(Menu.class); if (nodes.size() > 1) { throw new BuildException(\"Only 1 Menu can be specified underneath a MenuItem: {0}\", typeDefinition); } for(Node node : nodes){ Menu menu = (Menu) node.getMainObject(); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk.handler.type; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Map; import java.util.Set; import org.gnome.gtk.Menu; import org.gnome.gtk.MenuBar; import org.gnome.gtk.MenuItem; import org.gnome.gtk.MenuShell; import org.gnome.gtk.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class MenuShellFinishProcessor implements ITypeHandlerFinishProcessor {  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { MenuShell bar = (MenuShell) current.getMainObject(); if (bar instanceof MenuBar) { Set<Node> nodes = current.getContentNodes(MenuItem.class); for(Node node : nodes) { processMenuItem(bar, node); } } current.getCustomProperties().put(GtkConstants.INTERNAL_LAYOUT_HANDLED, true); } private void processMenuItem(MenuShell parent, Node node) { MenuItem mi = (MenuItem) node.getMainObject(); parent.append(mi); Set<Node> items = node.getContentNodes(Menu.class); for(Node item : items) { Menu menu = (Menu) item.getMainObject(); menu = new Menu(); menu.append(new MenuItem(\"TEST\")); mi.setSubmenu(menu); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk.handler.type; import java.util.HashSet; import java.util.Map; import java.util.Set; import org.gnome.gtk.Label; import org.gnome.gtk.Notebook; import org.gnome.gtk.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IKeyValueConsumer; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class NotebookFinishProcessor implements ITypeHandlerFinishProcessor, IKeyValueConsumer {  public static final String IS_TAB_LABEL = \"isTabLabel\";  public static final String TAB_LABEL = \"tabLabel\"; private static final Set<String> consumed = new HashSet<String>(); static { consumed.add(IS_TAB_LABEL); consumed.add(TAB_LABEL); }  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Set<Node> nodes = current.getContentNodes(Widget.class); Notebook notebook = (Notebook) current.getMainObject(); Widget lastLabelWidget = null; for(Node node : nodes) { if (node.getProperties().containsKey(IS_TAB_LABEL)) { lastLabelWidget = (Widget) node.getMainObject(); } else { Widget tabLabel = null; if (lastLabelWidget != null) { tabLabel = lastLabelWidget; lastLabelWidget = null; } Widget child = (Widget) node.getMainObject(); if (node.getProperties().containsKey(TAB_LABEL)) { tabLabel = new Label(node.getStringProperty(TAB_LABEL)); } notebook.appendPage(child, tabLabel); } } }  public Set<String> getConsumedKeys() { return consumed; }  public Class<Notebook> getApplicableClass() { return Notebook.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.Map; import java.util.Set; import org.gnome.gtk.Paned; import org.gnome.gtk.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class PanedFinishProcessor implements ITypeHandlerFinishProcessor {  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.Map; import java.util.Set; import org.gnome.gtk.ScrolledWindow; import org.gnome.gtk.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class ScrolledWindowFinishProcessor implements ITypeHandlerFinishProcessor {  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk.handler.type; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Set; import org.gnome.gtk.Alignment; import org.gnome.gtk.AttachOptions; import org.gnome.gtk.Container; import org.gnome.gtk.HBox; import org.gnome.gtk.SizeGroup; import org.gnome.gtk.SizeGroupMode; import org.gnome.gtk.Table; import org.gnome.gtk.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.TypeDefinition; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.gtk.layout.RowColumnConstraint; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.layout.ControlConstraint; import org.javabuilders.layout.DefaultResize; import org.javabuilders.layout.Flow; import org.javabuilders.layout.HAlign; import org.javabuilders.layout.LayoutCell; import org.javabuilders.layout.LayoutConstraints; import org.javabuilders.layout.VAlign; import org.javabuilders.layout.mig.MigLayoutCommon;  public class TableTypeHandler extends AbstractTypeHandler implements ITypeHandlerFinishProcessor { private static final String ATTACH = \"attach\";  public TableTypeHandler() { super(ATTACH); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { LayoutConstraints c = getLayoutConstraints(typeDefinition); boolean homogenous = false; if (typeDefinition.containsKey(GtkConstants.HOMOGENOUS)) { homogenous = (Boolean) typeDefinition.get(GtkConstants.HOMOGENOUS); } Table instance = new Table(c.getRowCount(), c.getColumnCount(), homogenous); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition, instance); return node; }  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { LayoutConstraints c = getLayoutConstraints(typeDefinition); Set<Node> widgets = current.getContentNodes(Widget.class); Table table = (Table) current.getMainObject(); Map<String,Widget> widgetNames = new HashMap<String, Widget>(); for(Node node : widgets) { Widget w = (Widget) node.getMainObject(); String name = node.getStringProperty(Builder.NAME); if (name != null) { widgetNames.put(name, w); } } "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import java.util.Map; import org.gnome.gtk.TreeView; import org.gnome.gtk.TreeViewColumn; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.handler.AbstractTypeHandler;  public class TreeViewColumnTypeHandler extends AbstractTypeHandler {  public TreeViewColumnTypeHandler() { super(GtkConstants.TITLE); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Node tvNode = parent.getParent(); if (tvNode != null && tvNode.getMainObject() instanceof TreeView) { TreeView tv = (TreeView) tvNode.getMainObject(); TreeViewColumn instance = tv.appendColumn(); return useExistingInstance(config, process, parent, key, typeDefinition, instance); } else { throw new BuildException(\"TreeViewColumn must be created under a TreeView object: {0}. Parent node: {1}\", typeDefinition, tvNode); } }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition,instance); return node; }  public Class<TreeViewColumn> getApplicableClass() { return TreeViewColumn.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.gtk.handler.type; import static org.javabuilders.gtk.GtkConstants.*; import java.util.Map; import org.gnome.gtk.VBox; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.gtk.GtkConstants; import org.javabuilders.handler.AbstractTypeHandler;  public class VBoxTypeHandler extends AbstractTypeHandler {  public VBoxTypeHandler() { super(HOMOGENOUS, SPACING); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Boolean homogenous = (Boolean) typeDefinition.get(GtkConstants.HOMOGENOUS); if (homogenous == null) { homogenous = Boolean.FALSE; } Integer spacing = (Integer) typeDefinition.get(GtkConstants.SPACING); if (spacing == null) { spacing = 4; } VBox instance = new VBox(homogenous,spacing); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent, key, typeDefinition); node.setMainObject(instance); return node; }  public Class<VBox> getApplicableClass() { return VBox.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.gtk.layout; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.javabuilders.layout.HAlign; import org.javabuilders.layout.VAlign;  public class RowColumnConstraint { private static final String REGEX = \"\\\\[(.+)\\\\]\\\\s*([0-9]*)\"; private static final Pattern pattern = Pattern.compile(REGEX); private static final String PREF = \"pref\"; private static final String EXPAND = \"expand\"; private static final String RIGHT = \"right\"; private static final String LEFT = \"left\"; private static final String CENTER = \"center\"; private static final String TOP = \"top\"; private static final String BOTTOM = \"botton\"; private static final String MIDDLE = \"middle\"; private HAlign hAlign = HAlign.DEFAULT; private VAlign vAlign = VAlign.DEFAULT; private Integer value = Integer.MIN_VALUE; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.List; import org.eclipse.swt.SWT; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Shell; import org.javabuilders.BuildException; import org.javabuilders.Node; import org.javabuilders.TypeDefinition;  public class SwtBuilderUtils {  @SuppressWarnings(\"unchecked\") public static int getSWTStyle(Object data) throws BuildException { int value = SWT.NONE; List<String> styles; if (data instanceof List) { styles = (List<String>) data; } else { styles = new ArrayList<String>(); styles.add(String.valueOf(data)); } for(String style : styles) { int styleValue = SWT.NONE; boolean found = false; Field[] fields = SWT.class.getFields(); for(Field field : fields) { int mod = field.getModifiers(); if (Modifier.isPublic(mod) && Modifier.isFinal(mod) && Modifier.isStatic(mod) && field.getType().equals(int.class)) { String name = field.getName(); String camelCase = TypeDefinition.getShortEnumConstant(field.getName()); if (style.equals(name) || style.equals(camelCase)) { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt; import java.io.IOException; import java.util.HashMap; import java.util.Map; import java.util.ResourceBundle; import org.eclipse.swt.widgets.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.annotations.BuildFile; public class SwtJavaBuilder { public static final String MARGIN_BOTTOM = \"marginBottom\"; public static final String MARGIN_HEIGHT = \"marginHeight\"; public static final String MARGIN_WIDTH = \"marginWidth\"; public static final String MARGIN_TOP = \"marginTop\"; public static final String MARGIN_LEFT = \"marginLeft\"; public static final String MARGIN_RIGHT = \"marginRight\"; public static final String SPACING = \"spacing\"; public static final String STYLE = \"style\"; public static final String TEXT = \"text\"; public static final String ON_SELECTION = \"onSelection\"; public static final String PARENT = \"parent\"; private static final SwtJavaBuilderConfig config = new SwtJavaBuilderConfig();  public static SwtJavaBuilderConfig getConfig() {return config;}  public static BuildResult build(Object caller, ResourceBundle...bundles) throws BuildException { return Builder.build(getConfig(),caller, bundles); }  public static BuildResult build(Object caller, String yaml, ResourceBundle...bundles) { return Builder.buildFromString(getConfig(),caller, yaml, bundles); }  public static BuildResult build(Widget parent, Object caller, ResourceBundle...bundles) throws BuildException { Map<String,Widget> map = new HashMap<String, Widget>(); map.put(SwtJavaBuilder.PARENT, parent); return Builder.build(getConfig(),caller, map, bundles); }  public static BuildResult build(Widget parent, Object caller, String yaml, ResourceBundle...bundles) { Map<String,Widget> map = new HashMap<String, Widget>(); map.put(SwtJavaBuilder.PARENT, parent); return Builder.buildFromString(getConfig(),caller, yaml, map, bundles); }  public static BuildResult buildFromFile(Widget parent, Object caller, String fileName, ResourceBundle...resourceBundles) { Map<String,Widget> map = new HashMap<String, Widget>(); map.put(SwtJavaBuilder.PARENT, parent); return Builder.build(getConfig(),caller, fileName, map, resourceBundles); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt; import java.beans.PropertyChangeSupport; import java.lang.reflect.Method; import net.miginfocom.swt.MigLayout; import org.eclipse.jface.dialogs.Dialog; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.jface.dialogs.ProgressIndicator; import org.eclipse.swt.browser.Browser; import org.eclipse.swt.custom.CBanner; import org.eclipse.swt.custom.CCombo; import org.eclipse.swt.custom.CLabel; import org.eclipse.swt.custom.CTabFolder; import org.eclipse.swt.custom.CTabItem; import org.eclipse.swt.custom.SashForm; import org.eclipse.swt.custom.ScrolledComposite; import org.eclipse.swt.custom.StackLayout; import org.eclipse.swt.custom.StyledText; import org.eclipse.swt.custom.TableCursor; import org.eclipse.swt.custom.ViewForm; import org.eclipse.swt.graphics.Font; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.layout.FormLayout; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.layout.RowLayout; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Canvas; import org.eclipse.swt.widgets.Combo; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.CoolBar; import org.eclipse.swt.widgets.CoolItem; import org.eclipse.swt.widgets.DateTime; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.ExpandBar; import org.eclipse.swt.widgets.Group; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.Layout; import org.eclipse.swt.widgets.Link; import org.eclipse.swt.widgets.List; import org.eclipse.swt.widgets.Menu; import org.eclipse.swt.widgets.MenuItem; import org.eclipse.swt.widgets.ProgressBar; import org.eclipse.swt.widgets.Sash; import org.eclipse.swt.widgets.Scale; import org.eclipse.swt.widgets.ScrollBar; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Slider; import org.eclipse.swt.widgets.Spinner; import org.eclipse.swt.widgets.TabFolder; import org.eclipse.swt.widgets.TabItem; import org.eclipse.swt.widgets.Table; import org.eclipse.swt.widgets.TableColumn; import org.eclipse.swt.widgets.TableItem; import org.eclipse.swt.widgets.Text; import org.eclipse.swt.widgets.ToolBar; import org.eclipse.swt.widgets.ToolItem; import org.eclipse.swt.widgets.Tracker; import org.eclipse.swt.widgets.Tray; import org.eclipse.swt.widgets.TrayItem; import org.eclipse.swt.widgets.Tree; import org.eclipse.swt.widgets.TreeItem; import org.eclipse.swt.widgets.Widget; import org.javabuilders.BuildResult; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.ICustomCommand; import org.javabuilders.handler.binding.BuilderBindings; import org.javabuilders.layout.DefaultResize; import org.javabuilders.swt.handler.DefaultValidationMessageHandler; import org.javabuilders.swt.handler.binding.JFaceDatabindingHandler; import org.javabuilders.swt.handler.event.ButtonSelectionListenerHandler; import org.javabuilders.swt.handler.event.MenuItemSelectionListenerHandler; import org.javabuilders.swt.handler.event.background.SWTBackgroundProcessingHandler; import org.javabuilders.swt.handler.property.SashBoundsHandler; import org.javabuilders.swt.handler.type.CTabFolderFinishProcessor; import org.javabuilders.swt.handler.type.DialogHandler; import org.javabuilders.swt.handler.type.FontAsValueHandler; import org.javabuilders.swt.handler.type.ImageAsValueHandler; import org.javabuilders.swt.handler.type.MenuItemTypeHandler; import org.javabuilders.swt.handler.type.ScrolledCompositeFinishProcessor; import org.javabuilders.swt.handler.type.ShellHandler; import org.javabuilders.swt.handler.type.WidgetTypeHandler; import org.javabuilders.swt.handler.type.layout.FillLayoutHandler; import org.javabuilders.swt.handler.type.layout.MigSWTLayoutHandler; import org.javabuilders.swt.handler.type.layout.StackLayoutHandler; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class SwtJavaBuilderConfig extends BuilderConfig { private static final Logger LOGGER = LoggerFactory.getLogger(SwtJavaBuilderConfig.class);  public SwtJavaBuilderConfig() { super(SWTBackgroundProcessingHandler.getInstance(), DefaultValidationMessageHandler.getInstance(), new ConfirmCommand()); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.cache; import java.text.MessageFormat; import java.util.HashMap; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Device; import org.eclipse.swt.graphics.Font; import org.eclipse.swt.graphics.FontData;  public class FontCache { private static Map<String,Font> fonts = new HashMap<String, Font>(); public static final String REGEX = \"\\\\s*([a-zA-Z]*)\\\\s*([0-9]*)\\\\s*([bold|normal|italic]*)\\\\s*\"; private static Pattern pattern = Pattern.compile(REGEX); private static final String BOLD = \"bold\"; private static final String NORMAL = \"normal\"; private static final String ITALIC = \"italic\";  public static Font getFont(Device device, String input) { String fontName = null; Integer size = null; int normal = SWT.NORMAL; int italic = SWT.NONE; int bold = SWT.NONE; Matcher m = pattern.matcher(input); while (m.find()) { for(int i = 1; i < m.groupCount(); i++) { String group = m.group(i); if (group.length() > 0) { if (group.matches(\"[0-9]+\")) { size = Integer.parseInt(group); } else if (BOLD.equals(group)) { bold = SWT.BOLD; normal = SWT.NONE; } else if (NORMAL.equals(group)) { normal = SWT.NORMAL; } else if (ITALIC.equals(group)) { italic = SWT.ITALIC; normal = SWT.NONE; } else { fontName = group; } } } } String key = MessageFormat.format(\"{0}_{1}_{2}_{3}_[4}\", fontName,size,normal,italic,bold); if (!fonts.containsKey(key)) { FontData fd = new FontData(); if (size != null) { fd.setHeight(size); } if (fontName != null) { fd.setName(fontName); } fd.setStyle(normal|italic|bold); Font font = new Font(device,fd); fonts.put(key, font); } return fonts.get(key); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler; import java.lang.reflect.Method; import org.javabuilders.BuildResult; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.IBackgroundCallback; import org.javabuilders.event.IBackgroundProcessingHandler; import sun.reflect.generics.reflectiveObjects.NotImplementedException;  public class DefaultBackgroundProcessingHandler implements IBackgroundProcessingHandler { private final static DefaultBackgroundProcessingHandler singleton = new DefaultBackgroundProcessingHandler();  public static DefaultBackgroundProcessingHandler getInstance() {return singleton;}  private DefaultBackgroundProcessingHandler() {}  public void doInBackground(BuildResult result, Object target, Method method, BackgroundEvent event, IBackgroundCallback callbackWhenFinished) throws Exception { throw new NotImplementedException(); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler; import org.javabuilders.BuildResult; import org.javabuilders.handler.validation.IValidationMessageHandler; import org.javabuilders.handler.validation.ValidationMessageList; import sun.reflect.generics.reflectiveObjects.NotImplementedException;  public class DefaultValidationMessageHandler implements IValidationMessageHandler { private final static DefaultValidationMessageHandler singleton = new DefaultValidationMessageHandler();  public static DefaultValidationMessageHandler getInstance() {return singleton;}  private DefaultValidationMessageHandler() {}  public String getNamedObjectLabel(Object namedObject) { throw new NotImplementedException(); }  public void handleValidationMessages(ValidationMessageList list, BuildResult result) { throw new NotImplementedException(); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.binding; import java.util.HashMap; import java.util.List; import java.util.Map; import org.eclipse.core.databinding.DataBindingContext; import org.eclipse.core.databinding.beans.BeansObservables; import org.eclipse.core.databinding.observable.*; import org.eclipse.core.databinding.observable.list.IObservableList; import org.eclipse.core.databinding.observable.value.IObservableValue; import org.eclipse.jface.databinding.swt.SWTObservables; import org.eclipse.swt.SWT; import org.eclipse.swt.widgets.Control; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.NamedObjectProperty; import org.javabuilders.Node; import org.javabuilders.handler.binding.AbstractBuilderBindingsHandler; import org.javabuilders.handler.binding.BindingSourceDefinition; import org.javabuilders.swt.SwtBuilderUtils; import org.javabuilders.util.PropertyUtils;  public class JFaceDatabindingHandler extends AbstractBuilderBindingsHandler { public static final String BACKGROUND = \"background\"; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.handler.binding; import org.eclipse.core.databinding.observable.value.ComputedValue; import org.javabuilders.BuildException; import org.javabuilders.util.PropertyUtils;  public class NestedPropertyComputedValue extends ComputedValue { private static final String NESTED_MATCHER = \".+\\\\..+\";  public static boolean isNestedProperty(String expression) { return expression.matches(NESTED_MATCHER); } private Object source; private String expression;  public NestedPropertyComputedValue(Object source, String expression) { this.source=source; this.expression = expression; }  @Override protected Object calculate() { try { return PropertyUtils.getNestedProperty(source, expression); } catch (Exception e) { throw new BuildException(e, \"Unable to get a value for expression {0}\", expression); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.handler.event; import static org.javabuilders.swt.SwtJavaBuilder.ON_SELECTION; import java.util.List; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.MenuItem; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class ButtonSelectionListenerHandler extends AbstractPropertyHandler implements IPropertyList { private final static ButtonSelectionListenerHandler singleton = new ButtonSelectionListenerHandler(); private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(SelectionEvent.class);  public static ButtonSelectionListenerHandler getInstance() {return singleton;}  private ButtonSelectionListenerHandler() { super(ON_SELECTION); }  @SuppressWarnings(\"unchecked\") public void handle(BuilderConfig config, final BuildProcess process, Node node, String key) throws BuildException { final Button target = (Button)node.getMainObject(); final Values<String,ObjectMethod> values = (Values<String, ObjectMethod>) node.getProperty(key); if (values.size() > 0) { target.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), target, values.values(), e); } }); } }  public boolean isList(String propertyName) { return true; }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; }  public Class<Button> getApplicableClass() { return Button.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.handler.event; import static org.javabuilders.swt.SwtJavaBuilder.ON_SELECTION; import java.util.List; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.widgets.MenuItem; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class MenuItemSelectionListenerHandler extends AbstractPropertyHandler implements IPropertyList { private final static MenuItemSelectionListenerHandler singleton = new MenuItemSelectionListenerHandler(); private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(SelectionEvent.class);  public static MenuItemSelectionListenerHandler getInstance() {return singleton;}  private MenuItemSelectionListenerHandler() { super(ON_SELECTION); }  @SuppressWarnings(\"unchecked\") public void handle(BuilderConfig config, final BuildProcess process, Node node, String key) throws BuildException { final MenuItem target = (MenuItem)node.getMainObject(); final Values<String,ObjectMethod> values = (Values<String, ObjectMethod>) node.getProperty(key); if (values.size() > 0) { target.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), target, values.values(), e); } }); } }  public boolean isList(String propertyName) { return true; }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; }  public Class<MenuItem> getApplicableClass() { return MenuItem.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.event.background; import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.io.IOException; import java.util.logging.Logger; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.ProgressBar; import org.eclipse.swt.widgets.Shell; import org.javabuilders.BuildException; import org.javabuilders.Builder; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.CancelStatus; import org.javabuilders.swt.SwtJavaBuilder; import org.javabuilders.util.BuilderUtils;  public class BackgroundDialog { private Shell shell; @SuppressWarnings(\"unused\") private Label progressLabel; @SuppressWarnings(\"unused\") private ProgressBar progressBar; private BackgroundEvent event = null;  public BackgroundDialog(BackgroundEvent event) throws IOException, BuildException { BuilderUtils.validateNotNullAndNotEmpty(\"event\", event); this.event = event; this.event.addPropertyChangeListener(new PropertyChangeListener() { public void propertyChange(PropertyChangeEvent evt) { if (evt.getPropertyName().equals(\"progressMessage\")) { progressLabel.setText((String) evt.getNewValue()); } } }); SwtJavaBuilder.build(this, Builder.getResourceBundle()); }  public BackgroundEvent getEvent() { return event; }  @SuppressWarnings(\"unused\") private void requestCancel() { boolean answer = MessageDialog.openQuestion(null, Builder.getResourceBundle().getString(\"message.cancelConfirm\"), Builder.getResourceBundle().getString(\"title.cancelTask\")); if (answer) { getEvent().setCancelStatus(CancelStatus.REQUESTED); } }  public Shell getShell() { return shell; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.event.background; import java.awt.Component; import java.io.IOException; import java.lang.reflect.Method; import org.eclipse.swt.widgets.Display; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.IBackgroundCallback; import org.javabuilders.event.IBackgroundProcessingHandler; import org.javabuilders.swt.worker.SWTWorker;  public class SWTBackgroundProcessingHandler implements IBackgroundProcessingHandler { private static final SWTBackgroundProcessingHandler singleton = new SWTBackgroundProcessingHandler();  public static SWTBackgroundProcessingHandler getInstance() {return singleton;} private SWTBackgroundProcessingHandler() {}  public void doInBackground(final BuildResult result, final Object target, final Method method, final BackgroundEvent event, final IBackgroundCallback callbackWhenFinished) throws IOException, BuildException { Component component = null; if (event.getSource() != null && event.getSource() instanceof Component) { component = (Component)event.getSource(); } final Component componentForEvent = component; final boolean enabled = (componentForEvent == null) ? true : componentForEvent.isEnabled(); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.property; import org.eclipse.swt.widgets.Sash; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler;  public class SashBoundsHandler extends AbstractPropertyHandler { public static final String X = \"x\"; public static final String Y = \"y\"; public static final String WIDTH = \"width\"; public static final String HEIGHT = \"height\"; private static final SashBoundsHandler singleton = new SashBoundsHandler();  public static SashBoundsHandler getInstance() {return singleton;}  private SashBoundsHandler() { super(X,Y,WIDTH,HEIGHT); }  public void handle(BuilderConfig config, BuildProcess process, Node node, String key) throws BuildException { Long x = node.getLongProperty(X); if (x == null) { x = 100L; } Long y = node.getLongProperty(Y); if (y == null) { y = 100L; } Long width = node.getLongProperty(WIDTH); if (width == null) { width = 400L; } Long height = node.getLongProperty(HEIGHT); if (height == null) { height = 800L; } Sash sash = (Sash) node.getMainObject(); sash.setBounds(x.intValue(), y.intValue(), width.intValue(), height.intValue()); }  public Class<?> getApplicableClass() { return Sash.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.handler.type; import java.util.Map; import java.util.Set; import org.eclipse.swt.custom.CTabFolder; import org.eclipse.swt.custom.CTabItem; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class CTabFolderFinishProcessor implements ITypeHandlerFinishProcessor {  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { CTabFolder tab = (CTabFolder) current.getMainObject(); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type; import java.util.Map; import org.eclipse.jface.dialogs.Dialog; import org.eclipse.swt.widgets.Display; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler;  public class DialogHandler extends AbstractTypeHandler { private static final DialogHandler singleton = new DialogHandler();  public static DialogHandler getInstance() { return singleton; }  private DialogHandler() {}  public Class<Dialog> getApplicableClass() { return Dialog.class; }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Display display = Display.getDefault(); Dialog instance = new Dialog(display.getActiveShell()) {}; return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition); node.setMainObject(instance); return node; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type; import org.eclipse.swt.graphics.Font; import org.eclipse.swt.widgets.Display; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler; import org.javabuilders.swt.cache.FontCache;  public class FontAsValueHandler implements ITypeAsValueHandler<Font> {  public String getInputValueSample() { return \"Monospaced 12 bold\"; } public String getRegex() { return FontCache.REGEX; }  public Font getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { Font font = FontCache.getFont(Display.getCurrent(), String.valueOf(inputValue)); return font; }  public Class<Font> getApplicableClass() { return Font.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type; import java.io.File; import java.io.InputStream; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.widgets.Shell; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler; import org.javabuilders.swt.SwtBuilderUtils; import org.javabuilders.util.BuilderUtils;  public class ImageAsValueHandler implements ITypeAsValueHandler<Image> { private static final ImageAsValueHandler singleton = new ImageAsValueHandler();  public static ImageAsValueHandler getInstance() {return singleton;}  private ImageAsValueHandler() {}  public String getInputValueSample() { return \"images/swt.png\"; }  public String getRegex() { return \".+\"; }  public Image getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { Shell shell = SwtBuilderUtils.getShell(node); String name = String.valueOf(inputValue); InputStream stream = BuilderUtils.getResourceInputStream(process, name); Image image = null; if (stream != null) { image = new Image(shell.getDisplay(),stream); } else { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type; import java.util.Map; import org.eclipse.swt.SWT; import org.eclipse.swt.widgets.Menu; import org.eclipse.swt.widgets.MenuItem; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.swt.SwtJavaBuilder; import org.javabuilders.swt.SwtBuilderUtils;  public class MenuItemTypeHandler extends AbstractTypeHandler { private static final MenuItemTypeHandler singleton = new MenuItemTypeHandler();  public static MenuItemTypeHandler getInstance() {return singleton;}  private MenuItemTypeHandler() { super(SwtJavaBuilder.STYLE); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Object parentMenu = parent.getMainObject(); MenuItem instance =null; int style = SwtBuilderUtils.getSWTStyle((String) typeDefinition.get(SwtJavaBuilder.STYLE)); if (parentMenu instanceof Menu) { Menu menu = (Menu) parentMenu; instance = new MenuItem(menu,style); } else if (parentMenu instanceof MenuItem) { MenuItem item = (MenuItem) parentMenu; Menu menu = item.getMenu(); if (menu == null) { menu = new Menu(SwtBuilderUtils.getShell(parent),SWT.DROP_DOWN); item.setMenu(menu); } instance = new MenuItem(menu,style); } else { throw new BuildException(\"MenuItem \\\"{0}\\\" can only be under a Menu or MenuItem\",key); } return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition); node.setMainObject(instance); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.handler.type; import java.util.Map; import java.util.Set; import org.eclipse.swt.custom.ScrolledComposite; import org.eclipse.swt.widgets.Control; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class ScrolledCompositeFinishProcessor implements ITypeHandlerFinishProcessor {  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Set<Node> controls = current.getChildNodes(Control.class); if (controls.size() > 1) { throw new BuildException(\"You can only specify one Control under ScrolledComposite: {0}\",typeDefinition); } else { for(Node control : controls) { final ScrolledComposite sc = (ScrolledComposite) current.getMainObject(); final Control cn = (Control) control.getMainObject(); sc.setContent(cn); sc.setMinHeight(1); sc.setMinWidth(1); sc.setExpandVertical(true); sc.setExpandHorizontal(true); break; } } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type; import java.util.Map; import java.util.Set; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Menu; import org.eclipse.swt.widgets.Shell; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.IAllowedPropertyFormat; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class ShellHandler extends AbstractTypeHandler implements ITypeHandlerFinishProcessor, IAllowedPropertyFormat { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Map; import java.util.logging.Logger; import org.eclipse.swt.custom.ScrolledComposite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Widget; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.swt.SwtJavaBuilder; import org.javabuilders.swt.SwtBuilderUtils; import org.javabuilders.util.BuilderUtils;  public class WidgetTypeHandler extends AbstractTypeHandler implements ITypeHandlerFinishProcessor { private static final WidgetTypeHandler singleton = new WidgetTypeHandler();  public static WidgetTypeHandler getInstance() { return singleton; }  protected WidgetTypeHandler() {}  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { Object instance = null; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type.layout; import java.util.HashMap; import java.util.Map; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.widgets.Composite; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.InvalidPropertyFormatException; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.swt.SwtJavaBuilder;  public class FillLayoutHandler extends AbstractTypeHandler implements ITypeChildrenHandler{ private static final FillLayoutHandler singleton = new FillLayoutHandler(); private Map<String,Integer> styleMap = new HashMap<String,Integer>();  public static FillLayoutHandler getInstance() { return singleton; }  public FillLayoutHandler() { super(SwtJavaBuilder.MARGIN_HEIGHT,SwtJavaBuilder.MARGIN_WIDTH,SwtJavaBuilder.SPACING,SwtJavaBuilder.STYLE); styleMap.put(\"horizontal\", SWT.HORIZONTAL); styleMap.put(\"vertical\", SWT.VERTICAL); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { FillLayout instance = new FillLayout(); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition); node.setMainObject(instance); FillLayout layout = (FillLayout)instance; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type.layout; import static org.javabuilders.swt.SwtJavaBuilder.MARGIN_BOTTOM; import static org.javabuilders.swt.SwtJavaBuilder.MARGIN_HEIGHT; import static org.javabuilders.swt.SwtJavaBuilder.MARGIN_LEFT; import static org.javabuilders.swt.SwtJavaBuilder.MARGIN_RIGHT; import static org.javabuilders.swt.SwtJavaBuilder.MARGIN_TOP; import static org.javabuilders.swt.SwtJavaBuilder.MARGIN_WIDTH; import static org.javabuilders.swt.SwtJavaBuilder.SPACING; import java.util.Map; import org.eclipse.swt.layout.FormLayout; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.InvalidPropertyFormatException; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler;  public class FormLayoutHandler extends AbstractTypeHandler {  public FormLayoutHandler() { super(MARGIN_BOTTOM,MARGIN_HEIGHT,MARGIN_LEFT,MARGIN_RIGHT, MARGIN_TOP, MARGIN_WIDTH, SPACING); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { FormLayout instance = new FormLayout(); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition); node.setMainObject(instance); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type.layout; import java.util.Map; import java.util.logging.Level; import net.miginfocom.swt.MigLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Label; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.layout.mig.AbstractMigLayoutHandler;  public class MigSWTLayoutHandler extends AbstractMigLayoutHandler { private final static MigSWTLayoutHandler singleton = new MigSWTLayoutHandler();  public static MigSWTLayoutHandler getInstance() { return singleton; }  private MigSWTLayoutHandler() { super(Label.class,\"text\"); }  public Node createNewInstance(BuilderConfig config, BuildProcess result, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { MigLayout instance = new MigLayout(); return useExistingInstance(config, result, parent, key, typeDefinition, instance); }  public Class<MigLayout> getApplicableClass() { return MigLayout.class; }  @Override protected void setLayoutConstraints(Object layout, String constraints) { ((MigLayout)layout).setLayoutConstraints(constraints); }  @Override protected void setRowConstraints(Object layout, String constraints) { ((MigLayout)layout).setRowConstraints(constraints); }  @Override protected void setColumnConstraints(Object layout, String constraints) { ((MigLayout)layout).setColumnConstraints(constraints); } @Override protected void applyControlConstraints(BuildProcess result, Node node, Node components, Map<String, String> layoutConstraints) throws BuildException { for(String componentName : layoutConstraints.keySet()) { String componentConstraint = layoutConstraints.get(componentName); Control component = (Control)result.getByName(componentName); component.setLayoutData(componentConstraint); if (logger.isLoggable(Level.FINE)) { logger.fine(\"MigLayout constraints for \" + componentName + \" : \" + componentConstraint); } } }  @Override protected Object getComponent(BuildProcess result, Node components, String name) throws BuildException { return result.getByName(name); }  @Override protected void setLayout(BuildProcess result, Node node, Object migLayout) throws BuildException { Node parent = node.getParent(); if (parent.getMainObject() instanceof Composite) { Composite parentContainer = (Composite)parent.getMainObject(); MigLayout layout = (MigLayout)node.getMainObject(); parentContainer.setLayout(layout); } else { throw new BuildException(\"MigLayout can only be present under a parent Composite: {0}\", node); } }  @Override protected void setControlName(Object control, String name) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.handler.type.layout; import java.util.Map; import org.eclipse.swt.custom.StackLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Layout; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler;  public class StackLayoutHandler extends AbstractTypeHandler { private static final StackLayoutHandler singleton = new StackLayoutHandler();  public static StackLayoutHandler getInstance() {return singleton;} private StackLayoutHandler() {}  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { StackLayout instance = new StackLayout(); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition); node.setMainObject(instance); Composite composite = (Composite)parent.getMainObject(); composite.setLayout((Layout) instance); return node; }  public Class<StackLayout> getApplicableClass() { return StackLayout.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.worker; import java.util.*; import org.eclipse.swt.widgets.Display; /** * A port of the JDK SwingWorker classes to SWT. Original JDK docs follow: * * An abstract class to be used in the cases where we need {@code Runnable} * to perform some actions on an appendable set of data. * The set of data might be appended after the {@code Runnable} is * sent for the execution. Usually such {@code Runnables} are sent to * the EDT. * * <p> * Usage example: * * <p> * Say we want to implement JLabel.setText(String text) which sends * {@code text} string to the JLabel.setTextImpl(String text) on the EDT. * In the event JLabel.setText is called rapidly many times off the EDT * we will get many updates on the EDT but only the last one is important. * (Every next updates overrides the previous one.) * We might want to implement this {@code setText} in a way that only * the last update is delivered. * <p> * Here is how one can do this using {@code AccumulativeRunnable}: * <pre> * AccumulativeRunnable<String> doSetTextImpl = * new AccumulativeRunnable<String>() { * @Override * protected void run(List&lt;String&gt; args) { * "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swt.worker; import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeSupport; import org.eclipse.swt.widgets.Display;  public class SWTPropertyChangeSupport extends PropertyChangeSupport {  private static final long serialVersionUID = -1913653933006243847L; private Display display;  public SWTPropertyChangeSupport(Object sourceBean, Display display) { super(sourceBean); this.display = display; }  @Override public void firePropertyChange(final PropertyChangeEvent evt) { if (Thread.currentThread().equals(this.display.getThread())) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swt.worker; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; import java.util.concurrent.FutureTask; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.ThreadFactory; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; import org.eclipse.swt.widgets.Display; /** * An abstract class to perform lengthy GUI-interacting tasks in a * dedicated thread. * * <p> * When writing a multi-threaded application using SWT, there are * two constraints to keep in mind: * (refer to * <a href=\"http:"}
{"name": "jacek99/javabuilders", "content": "/* * Copyright 2009 IT Mill Ltd. * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.vaadin; import org.javabuilders.BuilderConfig; import org.javabuilders.ICustomCommand; import org.javabuilders.IStringLiteralControlConfig; import org.javabuilders.event.IBackgroundProcessingHandler; import org.javabuilders.handler.validation.IValidationMessageHandler; import com.vaadin.data.Container; import com.vaadin.data.util.HierarchicalContainer; import com.vaadin.data.util.IndexedContainer; import com.vaadin.event.ShortcutAction; import com.vaadin.terminal.gwt.client.ui.Action; import com.vaadin.terminal.gwt.client.ui.Icon; import com.vaadin.terminal.gwt.client.ui.SimpleFocusablePanel; import com.vaadin.terminal.gwt.client.ui.TreeAction; import com.vaadin.ui.AbstractField; import com.vaadin.ui.Accordion; import com.vaadin.ui.Button; import com.vaadin.ui.CheckBox; import com.vaadin.ui.ComboBox; import com.vaadin.ui.Component; import com.vaadin.ui.ComponentContainer; import com.vaadin.ui.CustomComponent; import com.vaadin.ui.DateField; import com.vaadin.ui.Form; import com.vaadin.ui.FormLayout; import com.vaadin.ui.GridLayout; import com.vaadin.ui.HorizontalLayout; import com.vaadin.ui.InlineDateField; import com.vaadin.ui.Label; import com.vaadin.ui.Link; import com.vaadin.ui.ListSelect; import com.vaadin.ui.LoginForm; import com.vaadin.ui.MenuBar; import com.vaadin.ui.NativeButton; import com.vaadin.ui.NativeSelect; import com.vaadin.ui.Panel; import com.vaadin.ui.PopupDateField; import com.vaadin.ui.PopupView; import com.vaadin.ui.ProgressIndicator; import com.vaadin.ui.RichTextArea; import com.vaadin.ui.Select; import com.vaadin.ui.Slider; import com.vaadin.ui.SplitPanel; import com.vaadin.ui.TabSheet; import com.vaadin.ui.Table; import com.vaadin.ui.TextField; import com.vaadin.ui.Tree; import com.vaadin.ui.TwinColSelect; import com.vaadin.ui.Upload; import com.vaadin.ui.Window;  public class VaadinBuilderConfig extends BuilderConfig implements IStringLiteralControlConfig { public VaadinBuilderConfig(IBackgroundProcessingHandler backgroundProcessingHandler, IValidationMessageHandler validationMessageHandler, ICustomCommand<Boolean> confirmCommand) { super(backgroundProcessingHandler, validationMessageHandler, confirmCommand); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.vaadin; import java.util.ResourceBundle; import org.javabuilders.BuildResult; import org.javabuilders.Builder; public class VaadinJB { private static VaadinBuilderConfig config = new VaadinBuilderConfig(null,null,null);  public static VaadinBuilderConfig getConfig() { return config; }  public static BuildResult build(Object caller) { return Builder.build(getConfig(),caller); }  public static BuildResult build(Object caller, ResourceBundle...bundles) { return Builder.build(getConfig(),caller,bundles); }  public static BuildResult build(Object caller, String yaml, ResourceBundle...bundles) { return Builder.buildFromString(getConfig(),caller, yaml, bundles); } }"}
{"name": "jacek99/javabuilders", "content": "package javabuilders;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing; import javax.swing.Icon; import javax.swing.ImageIcon; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node;  public class IconUtils {  public static Icon getIcon(BuildProcess result, Node node, String key) throws BuildException { String path = String.valueOf(node.getProperties().get(key)); return getIcon(result,path); }  public static Icon getIcon(BuildProcess result, String path) throws BuildException { java.net.URL imgURL = result.getCaller().getClass().getResource(path); if (imgURL != null) { return new ImageIcon(imgURL); } else { throw new BuildException(\"Unable to find Icon defined by path: \" + path); } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing; import java.awt.event.ActionEvent; import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.Icon; import javax.swing.KeyStroke; import org.javabuilders.BuildException;  public class SwingAction extends AbstractAction {  private static final long serialVersionUID = 914022683711186677L; private IActionHandler actionHandler = null;  public SwingAction() { }  public SwingAction(String text) { super(text); }  public SwingAction(String name, Icon icon) { super(name, icon); }  public void setText(String text) { putValue(Action.NAME, text); }  public String getText() { return (String) getValue(Action.NAME); }  public void setIcon(Icon icon) { putValue(SMALL_ICON, icon); }  public Icon getIcon() { return (Icon) getValue(SMALL_ICON); }  public void setToolTipText(String text) { putValue(SHORT_DESCRIPTION, text); }  public String getToolTipText() { return (String) getValue(SMALL_ICON); }  public void setLongDescription(String text) { putValue(LONG_DESCRIPTION, text); }  public String getLongDescription() { return (String) getValue(LONG_DESCRIPTION); }  public void setMnemonic(Integer mnemonic) { putValue(MNEMONIC_KEY, mnemonic); }  public Integer getMnemonic() { return (Integer) getValue(MNEMONIC_KEY); }  public void setAccelerator(KeyStroke accelerator) { putValue(ACCELERATOR_KEY, accelerator); }  public KeyStroke getAccelerator() { return (KeyStroke) getValue(ACCELERATOR_KEY); }  public void setActionCommand(String action) { putValue(ACTION_COMMAND_KEY, action); }  public String getActionCommand() { return (String) getValue(ACTION_COMMAND_KEY); }  public void actionPerformed(ActionEvent e) { if (actionHandler != null) { actionHandler.onAction(e); } else { throw new BuildException(\"No action handler defined for action: \" + getText()); } }  public IActionHandler getActionHandler() { return actionHandler; }  public void setActionHandler(IActionHandler actionHandler) { this.actionHandler = actionHandler; }  public interface IActionHandler { void onAction(ActionEvent e); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing;  public class SwingBuilder extends SwingJavaBuilder {}"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing; import java.util.ResourceBundle; import javax.swing.UIManager; import org.javabuilders.BuildResult; import org.javabuilders.Builder; import org.javabuilders.util.BuilderUtils; import org.javabuilders.util.BuilderUtils.OperatingSystem; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class SwingJavaBuilder { private static SwingJavaBuilderConfig config = new SwingJavaBuilderConfig(); private static final Logger LOG = LoggerFactory.getLogger(SwingJavaBuilder.class); public final static String VGAP = \"vgap\"; public final static String HGAP = \"hgap\"; public final static String DEFAULT_LAYOUT_MANAGER = \"__DefaultSwingLayoutManager__\"; public final static String TITLE = \"title\"; public final static String TEXT = \"text\"; public final static String TOOL_TIP_TEXT = \"toolTipText\"; public final static String ACCELERATOR = \"accelerator\"; public final static String ICON = \"icon\"; public final static String ACTION = \"action\"; public final static String LAYOUT_DATA = \"layoutData\"; public final static String POPUP_MENU = \"popupMenu\";  public final static String ON_KEY_PRESSED = \"onKeyPressed\"; public final static String ON_KEY_RELEASED = \"onKeyReleased\"; public final static String ON_KEY_TYPED = \"onKeyTyped\"; public final static String ON_MOUSE_CLICKED = \"onMouseClicked\"; public final static String ON_MOUSE_DOUBLE_CLICKED = \"onMouseDoubleClicked\"; public final static String ON_MOUSE_RIGHT_CLICKED = \"onMouseRightClicked\"; public final static String ON_MOUSE_ENTERED = \"onMouseEntered\"; public final static String ON_MOUSE_EXITED =\"onMouseExited\"; public final static String ON_MOUSE_PRESSED =\"onMousePressed\"; public final static String ON_MOUSE_RELEASED = \"onMouseReleased\"; public final static String ON_STATE_CHANGED = \"onStateChanged\"; public final static String ON_WINDOW_FOCUS = \"onWindowFocus\"; public final static String ON_WINDOW_FOCUS_LOST = \"onWindowFocusLost\"; public final static String ON_WINDOW_ACTIVATED = \"onWindowActivated\"; public final static String ON_WINDOW_CLOSED = \"onWindowClosed\"; public final static String ON_WINDOW_CLOSING = \"onWindowClosing\"; public final static String ON_WINDOW_DEACTIVATED = \"onWindowDeactivated\"; public final static String ON_WINDOW_DEICONIFIED = \"onWindowDeiconified\"; public final static String ON_WINDOW_ICONIFIED = \"onWindowIconified\"; public final static String ON_WINDOW_OPENED = \"onWindowOpened\";  public final static String PROPERTY_IGNORE_LAYOUT_MANAGER = \"ignoreLayoutManager\";  public static SwingJavaBuilderConfig getConfig() { return config; }  public static BuildResult build(Object caller) { return Builder.build(getConfig(),caller); }  public static BuildResult build(Object caller, ResourceBundle...bundles) { return Builder.build(getConfig(),caller,bundles); }  public static BuildResult build(Object caller, String yaml, ResourceBundle...bundles) { return Builder.buildFromString(getConfig(),caller, yaml, bundles); }  public static void initSystemLookAndFeel() { try { String lf = UIManager.getSystemLookAndFeelClassName(); if (BuilderUtils.getOS() == OperatingSystem.LinuxUnix) { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing; import static org.javabuilders.swing.SwingJavaBuilder.*; import java.applet.Applet; import java.awt.Button; import java.awt.Canvas; import java.awt.CardLayout; import java.awt.Checkbox; import java.awt.Choice; import java.awt.Color; import java.awt.Component; import java.awt.Container; import java.awt.Dialog; import java.awt.Dimension; import java.awt.FlowLayout; import java.awt.Font; import java.awt.Frame; import java.awt.Image; import java.awt.Label; import java.awt.LayoutManager; import java.awt.Panel; import java.awt.ScrollPane; import java.awt.Scrollbar; import java.awt.TextArea; import java.awt.TextComponent; import java.awt.TextField; import java.awt.Window; import java.beans.PropertyChangeSupport; import java.util.HashMap; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set; import javax.swing.AbstractButton; import javax.swing.Action; import javax.swing.Box; import javax.swing.ButtonGroup; import javax.swing.ComboBoxModel; import javax.swing.DefaultComboBoxModel; import javax.swing.Icon; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JCheckBoxMenuItem; import javax.swing.JColorChooser; import javax.swing.JComboBox; import javax.swing.JComponent; import javax.swing.JDesktopPane; import javax.swing.JDialog; import javax.swing.JEditorPane; import javax.swing.JFileChooser; import javax.swing.JFormattedTextField; import javax.swing.JFrame; import javax.swing.JInternalFrame; import javax.swing.JLabel; import javax.swing.JLayeredPane; import javax.swing.JList; import javax.swing.JMenu; import javax.swing.JMenuBar; import javax.swing.JMenuItem; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JPasswordField; import javax.swing.JPopupMenu; import javax.swing.JProgressBar; import javax.swing.JRadioButton; import javax.swing.JRadioButtonMenuItem; import javax.swing.JScrollBar; import javax.swing.JScrollPane; import javax.swing.JSeparator; import javax.swing.JSlider; import javax.swing.JSpinner; import javax.swing.JSplitPane; import javax.swing.JTabbedPane; import javax.swing.JTable; import javax.swing.JTextArea; import javax.swing.JTextField; import javax.swing.JTextPane; import javax.swing.JToggleButton; import javax.swing.JToolBar; import javax.swing.JTree; import javax.swing.JViewport; import javax.swing.JWindow; import javax.swing.ListModel; import javax.swing.ListSelectionModel; import javax.swing.border.Border; import javax.swing.event.SwingPropertyChangeSupport; import javax.swing.table.TableCellEditor; import javax.swing.table.TableCellRenderer; import javax.swing.table.TableColumn; import javax.swing.table.TableModel; import javax.swing.text.JTextComponent; import net.miginfocom.swing.MigLayout; import org.javabuilders.BuildResult; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.ICustomCommand; import org.javabuilders.IStringLiteralControlConfig; import org.javabuilders.PrefixControlDefinition; import org.javabuilders.TypeDefinition; import org.javabuilders.event.IBindingListener; import org.javabuilders.event.IBindingListenerProvider; import org.javabuilders.handler.type.FontAsValueHandler; import org.javabuilders.handler.type.IconAsValueHandler; import org.javabuilders.handler.type.ImageAsValueHandler; import org.javabuilders.layout.DefaultResize; import org.javabuilders.swing.controls.JBSeparator; import org.javabuilders.swing.handler.SwingValidationMessageHandler; import org.javabuilders.swing.handler.binding.BeansBindingTypeHandler; import org.javabuilders.swing.handler.event.CommonActionListenerHandler; import org.javabuilders.swing.handler.event.ComponentFocusListenerHandler; import org.javabuilders.swing.handler.event.ComponentKeyListenerHandler; import org.javabuilders.swing.handler.event.ComponentMouseListenerHandler; import org.javabuilders.swing.handler.event.ComponentMouseMotionListenerHandler; import org.javabuilders.swing.handler.event.ComponentMouseWheelListenerHandler; import org.javabuilders.swing.handler.event.JFrameWindowListenerHandler; import org.javabuilders.swing.handler.event.JListSelectionListenerHandler; import org.javabuilders.swing.handler.event.JTabbedPaneChangeListenerHandler; import org.javabuilders.swing.handler.event.JTableSelectionListenerHandler; import org.javabuilders.swing.handler.event.JTreeSelectionListenerHandler; import org.javabuilders.swing.handler.event.WindowListenerHandler; import org.javabuilders.swing.handler.event.background.SwingBackgroundProcessingHandler; import org.javabuilders.swing.handler.property.AbstractButtonActionCommandHandler; import org.javabuilders.swing.handler.property.AbstractButtonTextHandler; import org.javabuilders.swing.handler.property.ComponentSizeHandler; import org.javabuilders.swing.handler.property.FrameExtendedStateHandler; import org.javabuilders.swing.handler.property.JComponentGroupTitleHandler; import org.javabuilders.swing.handler.property.JMenuItemAcceleratorHandler; import org.javabuilders.swing.handler.property.JTextFieldActionCommandHandler; import org.javabuilders.swing.handler.property.SwingActionTextHandler; import org.javabuilders.swing.handler.type.ActionAsValueHandler; import org.javabuilders.swing.handler.type.BorderAsValueHandler; import org.javabuilders.swing.handler.type.ButtonGroupTypeHandler; import org.javabuilders.swing.handler.type.ColorAsValueHandler; import org.javabuilders.swing.handler.type.ContainerTypeHandler; import org.javabuilders.swing.handler.type.DimensionAsValueHandler; import org.javabuilders.swing.handler.type.Focus; import org.javabuilders.swing.handler.type.FocusFinishProcessor; import org.javabuilders.swing.handler.type.JComboBoxFinishProcessor; import org.javabuilders.swing.handler.type.JDialogTypeHandler; import org.javabuilders.swing.handler.type.JFormattedTextFieldTypeHandler; import org.javabuilders.swing.handler.type.JFrameTypeHandler; import org.javabuilders.swing.handler.type.JInternalFrameFinishProcessor; import org.javabuilders.swing.handler.type.JListFinishProcessor; import org.javabuilders.swing.handler.type.JSpiltPaneTypeHandler; import org.javabuilders.swing.handler.type.JTabbedPaneTypeHandler; import org.javabuilders.swing.handler.type.JTableFinishProcessor; import org.javabuilders.swing.handler.type.SwingActionHandler; import org.javabuilders.swing.handler.type.TableColumnTypeHandler; import org.javabuilders.swing.handler.type.layout.CardLayoutTypeHandler; import org.javabuilders.swing.handler.type.layout.FlowLayoutTypeHandler; import org.javabuilders.swing.handler.type.layout.MigLayoutHandler; import org.javabuilders.swing.handler.type.model.DefaultComboBoxModelHandler; import org.jdesktop.beansbinding.Binding; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class SwingJavaBuilderConfig extends BuilderConfig implements IStringLiteralControlConfig, IBindingListenerProvider<Binding<? extends Object,? extends Object,? extends Object,? extends Object>> { private static final Logger LOGGER = LoggerFactory.getLogger(SwingJavaBuilderConfig.class); private Map<String,Integer> hScrollbars = new HashMap<String, Integer>(); private Map<String,Integer> vScrollbars = new HashMap<String, Integer>(); private Set<IBindingListener<Binding<? extends Object,? extends Object,? extends Object,? extends Object>>> bindingListeners = new LinkedHashSet<IBindingListener<Binding<? extends Object,? extends Object,? extends Object,? extends Object>>>(); { hScrollbars.put(\"always\", JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS); hScrollbars.put(\"asNeeded\", JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); hScrollbars.put(\"never\", JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); vScrollbars.put(\"always\", JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); vScrollbars.put(\"asNeeded\", JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED); vScrollbars.put(\"never\", JScrollPane.VERTICAL_SCROLLBAR_NEVER); }  public SwingJavaBuilderConfig() { super(SwingBackgroundProcessingHandler.getInstance(), SwingValidationMessageHandler.getInstance(), new ConfirmCommand()); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing; import java.awt.Component; import java.awt.Container; import java.awt.event.ActionEvent; import java.awt.event.KeyEvent; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.swing.JDialog; import javax.swing.JFrame; import javax.swing.JWindow; import javax.swing.KeyStroke; import org.javabuilders.BuildException; import org.javabuilders.Builder; import org.javabuilders.Node;  public class SwingJavaBuilderUtils { public static final String MNEMONIC = \"&\"; public final static String SEPARATOR = \"+\"; private final static String SEPARATOR_ESCAPED = \"__\"; private static Map<String,Integer> mnemonics = new HashMap<String, Integer>(); private static Map<String,Integer> actionEvents = new HashMap<String, Integer>(); private static List<String> functionKeys = new ArrayList<String>(); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.controls; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JSeparator; import javax.swing.SwingConstants; import net.miginfocom.swing.MigLayout;  public class JBSeparator extends JPanel {  private static final long serialVersionUID = -5286756879004703880L; private JLabel label = new JLabel();  public JBSeparator() { super(new MigLayout(\"insets 0\",\"[8px][shrink][grow]\")); add(new JSeparator(SwingConstants.HORIZONTAL),\"growx, aligny center\"); add(label); add(new JSeparator(SwingConstants.HORIZONTAL),\"growx, aligny center\"); }  public void setText(String text) { label.setText(text); }  public String getText() { return label.getText(); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler; import java.awt.Component; import javax.accessibility.AccessibleContext; import javax.swing.JOptionPane; import org.javabuilders.BuildResult; import org.javabuilders.Builder; import org.javabuilders.handler.validation.IValidationMessageHandler; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList; import org.javabuilders.swing.SwingJavaBuilderUtils;  public class SwingValidationMessageHandler implements IValidationMessageHandler { private static final SwingValidationMessageHandler singleton = new SwingValidationMessageHandler();  public static SwingValidationMessageHandler getInstance() {return singleton;} private SwingValidationMessageHandler() {}  public void handleValidationMessages(ValidationMessageList list, BuildResult result) { if (list.size() > 0) { Component firstObject = null; StringBuilder builder = new StringBuilder(); for(ValidationMessage msg : list) { if (builder.length() > 0) { builder.append(\"\\n\"); } builder.append(msg.getMessage()); if (firstObject == null && msg.getProperty() != null) { Object focusable = result.get(msg.getProperty().getName()); if (focusable instanceof Component) { firstObject = (Component)focusable; } } } Component parent = null; if (result.getRoot() instanceof Component) { parent = SwingJavaBuilderUtils.getTopLevelParent(result.getRoot()); } String title = (list.size() == 1) ? DEFAULT_VALIDATION_ERROR_TITLE : DEFAULT_VALIDATION_ERRORS_TITLE; JOptionPane.showMessageDialog(parent,builder.toString(), result.getResource(title), JOptionPane.ERROR_MESSAGE); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.binding; import java.util.HashMap; import java.util.Map; import javax.swing.JComboBox; import javax.swing.JList; import javax.swing.JTable; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.NamedObjectProperty; import org.javabuilders.Node; import org.javabuilders.handler.binding.AbstractBuilderBindingsHandler; import org.javabuilders.handler.binding.BindingSourceDefinition; import org.javabuilders.util.BuilderUtils; import org.jdesktop.beansbinding.Binding; import org.jdesktop.beansbinding.BindingGroup; import org.jdesktop.beansbinding.Bindings; import org.jdesktop.beansbinding.ELProperty; import org.jdesktop.beansbinding.AutoBinding.UpdateStrategy; import org.jdesktop.swingbinding.SwingBindings; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class BeansBindingTypeHandler extends AbstractBuilderBindingsHandler {  public static final String MODEL = \"model\"; private final static Logger logger = LoggerFactory.getLogger(BeansBindingTypeHandler.class); private static final BeansBindingTypeHandler singleton = new BeansBindingTypeHandler(); private Map<String, UpdateStrategy> updateStrategies = new HashMap<String, UpdateStrategy>();  public static BeansBindingTypeHandler getInstance() { return singleton; }  private BeansBindingTypeHandler() { super(); updateStrategies.put(READ, UpdateStrategy.READ); updateStrategies.put(READ_ONCE, UpdateStrategy.READ_ONCE); updateStrategies.put(READ_WRITE, UpdateStrategy.READ_WRITE); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent, key, typeDefinition); node.setMainObject(instance); BindingGroup bindingGroup = new BindingGroup(); process.getBuildResult().setBindingContext(bindingGroup); Map<NamedObjectProperty, BindingSourceDefinition> defs = getBindingDefinitions(node, process); for (NamedObjectProperty targetProperty : defs.keySet()) { BindingSourceDefinition sourceDef = defs.get(targetProperty); UpdateStrategy strategy = updateStrategies.get(sourceDef.getUpdateStrategy()); Object source = sourceDef.getSource(); String sourceExpression = sourceDef.getBindingExpression(); Object target = process.getByName(targetProperty.getName()); String targetExpression = targetProperty.getPropertyExpression(); Binding<Object, Object, Object, Object> binding = null; if (MODEL.equals(targetExpression)) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.List; import javax.swing.AbstractButton; import javax.swing.JComboBox; import javax.swing.JTextField; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.swing.SwingAction; import org.javabuilders.swing.SwingAction.IActionHandler; import org.javabuilders.util.BuilderUtils;  public class CommonActionListenerHandler extends AbstractPropertyHandler implements IPropertyList { private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(ActionEvent.class); private final static CommonActionListenerHandler singleton = new CommonActionListenerHandler();  public static CommonActionListenerHandler getInstance() { return singleton; }  private CommonActionListenerHandler() { super(Builder.ON_ACTION); }  @SuppressWarnings(\"unchecked\") public void handle(final BuilderConfig config, final BuildProcess process, final Node node, String key) throws BuildException { final Values<String,ObjectMethod> values = (Values<String, ObjectMethod>) node.getProperty(key); if (values.size() > 0) { if (node.getMainObject() instanceof SwingAction) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.awt.Component; import java.awt.event.FocusEvent; import java.awt.event.FocusListener; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class ComponentFocusListenerHandler extends AbstractPropertyHandler implements IPropertyList { private final static ComponentFocusListenerHandler singleton = new ComponentFocusListenerHandler(); private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(FocusEvent.class);  public final static ComponentFocusListenerHandler getInstance() { return singleton; }  private ComponentFocusListenerHandler(String... consumedKeys) { super(Builder.ON_FOCUS, Builder.ON_FOCUS_LOST); }  @SuppressWarnings(\"unchecked\") public void handle(final BuilderConfig config, final BuildProcess process, final Node node, String key) throws BuildException { Component component = (Component)node.getMainObject(); final Values<String,ObjectMethod> onFocusList = (Values<String, ObjectMethod>) node.getProperties().get(Builder.ON_FOCUS); final Values<String,ObjectMethod> onFocusLostList = (Values<String, ObjectMethod>) node.getProperties().get(Builder.ON_FOCUS_LOST); component.addFocusListener(new FocusListener() { public void focusGained(FocusEvent e) { if (onFocusList != null) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), node, onFocusList.values(), e); } } public void focusLost(FocusEvent e) { if (onFocusLostList != null) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), node, onFocusLostList.values(), e); } } }); }  public Class<?> getApplicableClass() { return Component.class; }  public boolean isList(String propertyName) { return true; }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.awt.Component; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.util.BuilderUtils;  public class ComponentKeyListenerHandler extends AbstractPropertyHandler implements IPropertyList{ private final static ComponentKeyListenerHandler singleton = new ComponentKeyListenerHandler(); private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(KeyEvent.class);  public static ComponentKeyListenerHandler getInstance() { return singleton; }  private ComponentKeyListenerHandler() { super(SwingJavaBuilder.ON_KEY_PRESSED,SwingJavaBuilder.ON_KEY_RELEASED, SwingJavaBuilder.ON_KEY_TYPED); }  @SuppressWarnings(\"unchecked\") public void handle(final BuilderConfig config,final BuildProcess process, final Node node, String key) throws BuildException { Component component = (Component)node.getMainObject(); final Values<String,ObjectMethod> onKeyTypedList = (Values<String,ObjectMethod>)node.getProperty(SwingJavaBuilder.ON_KEY_TYPED); final Values<String,ObjectMethod> onKeyReleasedList = (Values<String,ObjectMethod>)node.getProperty(SwingJavaBuilder.ON_KEY_RELEASED); final Values<String,ObjectMethod> onKeyPressedList = (Values<String,ObjectMethod>)node.getProperty(SwingJavaBuilder.ON_KEY_PRESSED); component.addKeyListener(new KeyListener() { public void keyPressed(KeyEvent e) { if (onKeyPressedList != null && onKeyPressedList.size() > 0) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), node, onKeyPressedList.values(), e); } } public void keyReleased(KeyEvent e) { if (onKeyReleasedList != null && onKeyReleasedList.size() > 0) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), node, onKeyReleasedList.values(), e); } } public void keyTyped(KeyEvent e) { if (onKeyTypedList != null && onKeyTypedList.size() > 0) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), node, onKeyTypedList.values(), e); } } }); }  public Class<?> getApplicableClass() { return Component.class; }  public boolean isList(String propertyName) { return true; }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import static org.javabuilders.swing.SwingBuilder.ON_MOUSE_CLICKED; import static org.javabuilders.swing.SwingBuilder.ON_MOUSE_DOUBLE_CLICKED; import static org.javabuilders.swing.SwingBuilder.ON_MOUSE_ENTERED; import static org.javabuilders.swing.SwingBuilder.ON_MOUSE_EXITED; import static org.javabuilders.swing.SwingBuilder.ON_MOUSE_PRESSED; import static org.javabuilders.swing.SwingBuilder.ON_MOUSE_RELEASED; import static org.javabuilders.swing.SwingBuilder.ON_MOUSE_RIGHT_CLICKED; import static org.javabuilders.swing.SwingBuilder.POPUP_MENU; import java.awt.Component; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.util.List; import javax.swing.JPopupMenu; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuildResult; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class ComponentMouseListenerHandler extends AbstractPropertyHandler implements IPropertyList{ private static final ComponentMouseListenerHandler singleton = new ComponentMouseListenerHandler(); private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(MouseEvent.class);  public static ComponentMouseListenerHandler getInstance() { return singleton; }  public ComponentMouseListenerHandler() { super(ON_MOUSE_CLICKED, ON_MOUSE_DOUBLE_CLICKED, ON_MOUSE_RIGHT_CLICKED, ON_MOUSE_ENTERED, ON_MOUSE_EXITED, ON_MOUSE_PRESSED, ON_MOUSE_RELEASED, POPUP_MENU); }  @SuppressWarnings(\"unchecked\") public void handle(final BuilderConfig config, final BuildProcess process, final Node node, String key) throws BuildException { final Values<String,ObjectMethod> onMouseClicked = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_CLICKED); final Values<String,ObjectMethod> onMouseDoubleClicked = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_DOUBLE_CLICKED); final Values<String,ObjectMethod> onMouseEntered = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_ENTERED); final Values<String,ObjectMethod> onMouseExited = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_EXITED); final Values<String,ObjectMethod> onMousePressed = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_PRESSED); final Values<String,ObjectMethod> onMouseReleased = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_RELEASED); final Values<String,ObjectMethod> onMouseRightClicked = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_RIGHT_CLICKED); final String popupMenu = node.getStringProperty(POPUP_MENU); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.awt.Component; import java.awt.event.MouseEvent; import java.awt.event.MouseMotionListener; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class ComponentMouseMotionListenerHandler extends AbstractPropertyHandler implements IPropertyList { public final static String ON_MOUSE_DRAGGED = \"onMouseDragged\"; public final static String ON_MOUSE_MOVED = \"onMouseMoved\"; private final static ComponentMouseMotionListenerHandler singleton = new ComponentMouseMotionListenerHandler(); private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(MouseEvent.class);  public static ComponentMouseMotionListenerHandler getInstance() {return singleton;} "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.awt.Component; import java.awt.event.MouseWheelEvent; import java.awt.event.MouseWheelListener; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class ComponentMouseWheelListenerHandler extends AbstractPropertyHandler implements IPropertyList { public final static String ON_MOUSE_WHEEL_MOVED = \"onMouseWheelMoved\"; private final static ComponentMouseWheelListenerHandler singleton = new ComponentMouseWheelListenerHandler(); private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(MouseWheelEvent.class);  public static ComponentMouseWheelListenerHandler getInstance() {return singleton;}  private ComponentMouseWheelListenerHandler() { super(ON_MOUSE_WHEEL_MOVED); }  @SuppressWarnings(\"unchecked\") public void handle(final BuilderConfig config, final BuildProcess process, final Node node, String key) throws BuildException { Component component = (Component)node.getMainObject(); final Values<String,ObjectMethod> methods = (Values<String,ObjectMethod>)node.getProperty(ON_MOUSE_WHEEL_MOVED); component.addMouseWheelListener(new MouseWheelListener() { public void mouseWheelMoved(MouseWheelEvent e) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), node, methods.values(), e); } }); }  public Class<?> getApplicableClass() { return Component.class; }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; }  public boolean isList(String propertyName) { return true; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.awt.event.WindowEvent; import java.awt.event.WindowFocusListener; import java.awt.event.WindowListener; import java.awt.event.WindowStateListener; import javax.swing.JFrame; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.util.BuilderUtils;  public class JFrameWindowListenerHandler extends WindowListenerHandler { private static final JFrameWindowListenerHandler singleton = new JFrameWindowListenerHandler();  public static JFrameWindowListenerHandler getInstance() {return singleton;}  private JFrameWindowListenerHandler() { super(); }  @SuppressWarnings(\"unchecked\") @Override protected void createListeners(final Node node, final BuildProcess process, final Values<String, ObjectMethod> stateValues, final Values<String, ObjectMethod> windowFocusValues, final Values<String, ObjectMethod> windowFocusLostValues, final Values<String, ObjectMethod> windowActivatedValues, final Values<String, ObjectMethod> windowClosedValues, final Values<String, ObjectMethod> windowClosingValues, final Values<String, ObjectMethod> windowDeactivatedValues, final Values<String, ObjectMethod> windowDeiconifiedValues, final Values<String, ObjectMethod> windowIconifiedValues, final Values<String, ObjectMethod> windowOpenedValues) { final JFrame control = (JFrame)node.getMainObject(); if (stateValues != null) { control.addWindowStateListener(new WindowStateListener() { public void windowStateChanged(WindowEvent e) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), control, stateValues.values(), e); } }); } "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.event; import java.util.List; import javax.swing.JList; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import org.javabuilders.*; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class JListSelectionListenerHandler extends AbstractPropertyHandler implements IPropertyList { private static final String ON_SELECTION = \"onSelection\"; private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(ListSelectionEvent.class); private static final JListSelectionListenerHandler singleton = new JListSelectionListenerHandler();  public static JListSelectionListenerHandler getInstance() { return singleton; }  public JListSelectionListenerHandler() { super(ON_SELECTION); }  @SuppressWarnings(\"unchecked\") public void handle(BuilderConfig config, final BuildProcess process, Node node, String key) throws BuildException { final JList target = (JList) node.getMainObject(); final Values<String, ObjectMethod> values = (Values<String, ObjectMethod>) node.getProperty(key); if (values.size() > 0) { target.addListSelectionListener(new ListSelectionListener() { public void valueChanged(ListSelectionEvent e) { if (e.getValueIsAdjusting() == false) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), target, values.values(), e); } } }); } }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; }  public boolean isList(String propertyName) { return true; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.util.List; import javax.swing.JTabbedPane; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class JTabbedPaneChangeListenerHandler extends AbstractPropertyHandler implements IPropertyList { public static final String ON_CHANGE = \"onChange\"; private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(ChangeEvent.class); private static final JTabbedPaneChangeListenerHandler singleton = new JTabbedPaneChangeListenerHandler();  public static JTabbedPaneChangeListenerHandler getInstance() {return singleton;}  private JTabbedPaneChangeListenerHandler() { super(ON_CHANGE); }  @SuppressWarnings(\"unchecked\") public void handle(BuilderConfig config, final BuildProcess process, final Node node, String key) throws BuildException { final Values<String,ObjectMethod> onChange = (Values<String,ObjectMethod>)node.getProperty(ON_CHANGE); JTabbedPane pane = (JTabbedPane) node.getMainObject(); pane.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), node, onChange.values(), e); } }); }  public Class<?> getApplicableClass() { return JTabbedPane.class; }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; }  public boolean isList(String propertyName) { return true; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.util.Set; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler;  public class JTableColumnModelListenerHandler extends AbstractPropertyHandler {  public JTableColumnModelListenerHandler(String... consumedKeys) { super(consumedKeys); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.util.List; import javax.swing.JTable; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class JTableSelectionListenerHandler extends AbstractPropertyHandler implements IPropertyList { public static final String ON_SELECTION = \"onSelection\"; private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(ListSelectionEvent.class); private static final JTableSelectionListenerHandler singleton = new JTableSelectionListenerHandler();  public static JTableSelectionListenerHandler getInstance() {return singleton;}  public JTableSelectionListenerHandler() { super(ON_SELECTION); }  @SuppressWarnings(\"unchecked\") public void handle(BuilderConfig config, final BuildProcess process, Node node, String key) throws BuildException { final JTable target = (JTable)node.getMainObject(); final Values<String,ObjectMethod> values = (Values<String, ObjectMethod>) node.getProperty(key); if (values.size() > 0) { target.getSelectionModel().addListSelectionListener(new ListSelectionListener() { public void valueChanged(ListSelectionEvent e) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), target, values.values(), e); } }); } }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; }  public boolean isList(String propertyName) { return true; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import java.util.List; import javax.swing.JTree; import javax.swing.event.TreeSelectionEvent; import javax.swing.event.TreeSelectionListener; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class JTreeSelectionListenerHandler extends AbstractPropertyHandler implements IPropertyList{ public static final String ON_SELECTION = \"onSelection\"; private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(TreeSelectionEvent.class); private static final JTreeSelectionListenerHandler singleton = new JTreeSelectionListenerHandler();  public static JTreeSelectionListenerHandler getInstance() {return singleton;}  private JTreeSelectionListenerHandler(String... consumedKeys) { super(ON_SELECTION); }  @SuppressWarnings(\"unchecked\") public void handle(BuilderConfig config, final BuildProcess process, Node node, String key) throws BuildException { final JTree target = (JTree)node.getMainObject(); final Values<String,ObjectMethod> values = (Values<String, ObjectMethod>) node.getProperty(key); if (values.size() > 0) { target.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() { public void valueChanged(TreeSelectionEvent e) { BuilderUtils.invokeCallerEventMethods(process.getBuildResult(), target, values.values(), e); } }); } }  public Class<?> getApplicableClass() { return JTree.class; }  public List<ValueListDefinition> getValueListDefinitions(String propertyName) { return defs; }  public boolean isList(String propertyName) { return true; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event; import static org.javabuilders.swing.SwingJavaBuilder.*; import java.awt.Window; import java.awt.event.WindowEvent; import java.awt.event.WindowFocusListener; import java.awt.event.WindowListener; import java.awt.event.WindowStateListener; import java.util.List; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IPropertyList; import org.javabuilders.Node; import org.javabuilders.ValueListDefinition; import org.javabuilders.Values; import org.javabuilders.event.ObjectMethod; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils;  public class WindowListenerHandler extends AbstractPropertyHandler implements IPropertyList { private final static List<ValueListDefinition> defs = ValueListDefinition.getCommonEventDefinitions(WindowEvent.class); private static final WindowListenerHandler singleton = new WindowListenerHandler();  public static WindowListenerHandler getInstance() {return singleton;}  protected WindowListenerHandler() { super(ON_STATE_CHANGED, ON_WINDOW_FOCUS, ON_WINDOW_FOCUS_LOST,ON_WINDOW_ACTIVATED, ON_WINDOW_CLOSED, ON_WINDOW_CLOSING, ON_WINDOW_DEACTIVATED, ON_WINDOW_DEICONIFIED, ON_WINDOW_ICONIFIED,ON_WINDOW_OPENED); }  @SuppressWarnings(\"unchecked\") public void handle(BuilderConfig config, final BuildProcess process, Node node, String key) throws BuildException { Values<String,ObjectMethod> stateValues = (Values<String, ObjectMethod>) node.getProperty(ON_STATE_CHANGED); Values<String,ObjectMethod> windowFocusValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_FOCUS); Values<String,ObjectMethod> windowFocusLostValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_FOCUS_LOST); Values<String,ObjectMethod> windowActivatedValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_ACTIVATED); Values<String,ObjectMethod> windowClosedValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_CLOSED); Values<String,ObjectMethod> windowClosingValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_CLOSING); Values<String,ObjectMethod> windowDeactivatedValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_DEACTIVATED); Values<String,ObjectMethod> windowDeiconifiedValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_DEICONIFIED); Values<String,ObjectMethod> windowIconifiedValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_ICONIFIED); Values<String,ObjectMethod> windowOpenedValues = (Values<String, ObjectMethod>) node.getProperty(ON_WINDOW_OPENED); createListeners(node, process, stateValues, windowFocusValues, windowFocusLostValues, windowActivatedValues, windowClosedValues, windowClosingValues, windowDeactivatedValues, windowDeiconifiedValues, windowIconifiedValues, windowOpenedValues); } "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event.background; import java.awt.Color; import java.awt.Component; import java.io.IOException; import javax.swing.BorderFactory; import javax.swing.JDialog; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JProgressBar; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.annotations.BuildFile; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.CancelStatus; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.SwingJavaBuilderUtils; import org.javabuilders.util.BuilderUtils;  @SuppressWarnings(\"serial\") @BuildFile(\"BackgroundDialog.yml\") public class BackgroundDialog extends JDialog { @SuppressWarnings(\"unused\") private JProgressBar progressBar = null; private BackgroundEvent event = null; private BuildResult result = null; private JPanel mainPanel;  public BackgroundDialog(BackgroundEvent event, BuildResult result) throws IOException, BuildException { BuilderUtils.validateNotNullAndNotEmpty(\"event\", event); this.event = event; this.result = result; SwingJavaBuilder.build(this); mainPanel.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY)); setLocationRelativeTo((Component) SwingJavaBuilderUtils.getTopLevelParent(event.getSource())); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.event.background; import java.awt.Component; import java.io.IOException; import java.lang.reflect.Method; import javax.swing.JDialog; import javax.swing.SwingWorker; import org.javabuilders.BuildException; import org.javabuilders.BuildResult; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.IBackgroundCallback; import org.javabuilders.event.IBackgroundProcessingHandler;  public class SwingBackgroundProcessingHandler implements IBackgroundProcessingHandler { private static final SwingBackgroundProcessingHandler singleton = new SwingBackgroundProcessingHandler();  public static SwingBackgroundProcessingHandler getInstance() { return singleton; } private SwingBackgroundProcessingHandler() { }  public void doInBackground(final BuildResult result, final Object target, final Method method, final BackgroundEvent event, final IBackgroundCallback callbackWhenFinished) throws IOException, BuildException { Component component = null; if (event.getSource() != null && event.getSource() instanceof Component) { component = (Component) event.getSource(); } final Component componentForEvent = component; final boolean enabled = (componentForEvent == null) ? true : componentForEvent.isEnabled(); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.property; import java.awt.event.ActionListener; import javax.swing.AbstractButton; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class AbstractButtonActionCommandHandler extends AbstractPropertyHandler { public final static String ACTION_COMMAND = \"actionCommand\"; private final static Logger logger = LoggerFactory.getLogger(AbstractButtonActionCommandHandler.class); private final static AbstractButtonActionCommandHandler singleton = new AbstractButtonActionCommandHandler();  public static AbstractButtonActionCommandHandler getInstance() { return singleton; }  private AbstractButtonActionCommandHandler() { super(ACTION_COMMAND); }  public void handle(BuilderConfig config, BuildProcess result, Node node, String key) throws BuildException { AbstractButton button = (AbstractButton)node.getMainObject(); String actionCommand = String.valueOf(node.getProperties().get(key)); button.setActionCommand(actionCommand); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.property; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.AbstractAction; import javax.swing.AbstractButton; import javax.swing.ActionMap; import javax.swing.ComponentInputMap; import javax.swing.InputMap; import javax.swing.JButton; import javax.swing.JComponent; import javax.swing.JMenu; import javax.swing.JMenuItem; import javax.swing.SwingUtilities; import javax.swing.plaf.ActionMapUIResource; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.swing.SwingJavaBuilderUtils; import org.javabuilders.swing.SwingJavaBuilderUtils.ActionDefinition; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class AbstractButtonTextHandler extends AbstractPropertyHandler { private static final Logger LOG = LoggerFactory.getLogger(AbstractButtonTextHandler.class); public static final String TEXT = \"text\"; public AbstractButtonTextHandler() { super(TEXT); }  @SuppressWarnings(\"serial\") public void handle(BuilderConfig config, BuildProcess process, Node node, String key) throws BuildException { String text = String.valueOf(node.getProperties().get(key)); final AbstractButton button = (AbstractButton)node.getMainObject(); ActionDefinition def = SwingJavaBuilderUtils.getActionDefintion(text); button.setText(def.getText()); if (def.getMnemonic() != null) { button.setMnemonic(def.getMnemonic()); } "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.property; import java.awt.Component; import java.awt.Frame; import java.awt.Window; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IAllowedPropertyCombinations; import org.javabuilders.IAllowedPropertyFormat; import org.javabuilders.Node; import org.javabuilders.PropertyCombination; import org.javabuilders.handler.AbstractPropertyHandler;  public class ComponentSizeHandler extends AbstractPropertyHandler implements IAllowedPropertyFormat, IAllowedPropertyCombinations { public final static String SIZE = \"size\"; public final static String WIDTH = \"width\"; public final static String HEIGHT = \"height\"; public final static String PACKED = \"packed\"; private final static ComponentSizeHandler singleton = new ComponentSizeHandler(); private PropertyCombination combination = new PropertyCombination();  public static ComponentSizeHandler getInstance() { return singleton; }  public ComponentSizeHandler() { super(SIZE, WIDTH, HEIGHT); combination.add(SIZE); combination.add(WIDTH,HEIGHT); }  public void handle(BuilderConfig config, BuildProcess result, Node node, String key) throws BuildException { Component component = (Component) node.getMainObject(); if (node.getProperties().containsKey(SIZE)) { String size = (String) node.getProperties().get(SIZE); if (PACKED.equals(size)) { if (component instanceof Window) { Window window = (Window)component; window.pack(); } else if (component instanceof Frame) { Frame frame = (Frame)component; frame.pack(); } else { throw new BuildException(\"'size : packed' is only valid for Window/Frame and subclasses\"); } } else { String[] parts = size.split(\"x\"); Integer width = Integer.parseInt(parts[0]); Integer height = Integer.parseInt(parts[1]); component.setSize(width, height); } } else { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.property; import java.awt.Frame; import java.awt.GraphicsEnvironment; import java.awt.Rectangle; import java.util.Collection; import java.util.HashMap; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.IAllowedValues; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.util.BuilderUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class FrameExtendedStateHandler extends AbstractPropertyHandler implements IAllowedValues { public final static String STATE = \"state\"; public final static String ICON = \"icon\"; public final static String MAXH = \"maxh\"; public final static String MAXV = \"maxv\"; public final static String MAX = \"max\"; private final static Logger logger = LoggerFactory.getLogger(FrameExtendedStateHandler.class); private final static FrameExtendedStateHandler singleton = new FrameExtendedStateHandler(); private Map<String,Integer> values = new HashMap<String,Integer>();  public static FrameExtendedStateHandler getInstance() { return singleton; }  private FrameExtendedStateHandler() { super(STATE); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.property; import javax.swing.BorderFactory; import javax.swing.JComponent; import javax.swing.border.TitledBorder; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler;  public class JComponentGroupTitleHandler extends AbstractPropertyHandler { public final static String GROUP_TITLE = \"groupTitle\"; private final static JComponentGroupTitleHandler singleton = new JComponentGroupTitleHandler();  public static JComponentGroupTitleHandler getInstance() { return singleton; }  public JComponentGroupTitleHandler() { super(GROUP_TITLE); }  public void handle(BuilderConfig config, BuildProcess result, Node node, String key) throws BuildException { TitledBorder border = BorderFactory.createTitledBorder(String.valueOf(node.getProperties().get(key))); JComponent component = (JComponent)node.getMainObject(); component.setBorder(border); }  public Class<?> getApplicableClass() { return JComponent.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.property; import javax.swing.JMenuItem; import javax.swing.KeyStroke; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.InvalidPropertyValueException; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.SwingJavaBuilderUtils;  public class JMenuItemAcceleratorHandler extends AbstractPropertyHandler { private static final JMenuItemAcceleratorHandler singleton = new JMenuItemAcceleratorHandler();  public static JMenuItemAcceleratorHandler getInstance() { return singleton; }  public JMenuItemAcceleratorHandler() { super(SwingJavaBuilder.ACCELERATOR); }  void setAccelerator(Node node, String key, JMenuItem item, String accelerator) throws InvalidPropertyValueException { KeyStroke acc = SwingJavaBuilderUtils.getAccelerator(accelerator); if (acc != null) { item.setAccelerator(acc); } }  public void handle(BuilderConfig config, BuildProcess result, Node node, String key) throws BuildException { String accelerator = node.getStringProperty(key); JMenuItem item = (JMenuItem)node.getMainObject(); setAccelerator(node, key, item, accelerator); }  public Class<?> getApplicableClass() { return JMenuItem.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.property; import java.awt.event.ActionListener; import javax.swing.JTextField; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class JTextFieldActionCommandHandler extends AbstractPropertyHandler { private final static Logger logger = LoggerFactory.getLogger(JTextFieldActionCommandHandler.class); private final static JTextFieldActionCommandHandler singleton = new JTextFieldActionCommandHandler();  public static JTextFieldActionCommandHandler getInstance() { return singleton; }  private JTextFieldActionCommandHandler() { super(AbstractButtonActionCommandHandler.ACTION_COMMAND); }  public void handle(BuilderConfig config, BuildProcess result, Node node, String key) throws BuildException { JTextField field = (JTextField)node.getMainObject(); String actionCommand = String.valueOf(node.getProperties().get(key)); field.setActionCommand(actionCommand); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.property; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractPropertyHandler; import org.javabuilders.swing.SwingAction; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.SwingJavaBuilderUtils; import org.javabuilders.swing.SwingJavaBuilderUtils.ActionDefinition;  public class SwingActionTextHandler extends AbstractPropertyHandler { private static final SwingActionTextHandler singleton = new SwingActionTextHandler();  public static SwingActionTextHandler getInstance() {return singleton;} private SwingActionTextHandler() { super(SwingJavaBuilder.TEXT); }  public void handle(BuilderConfig config, BuildProcess process, Node node, String key) throws BuildException { String text = node.getStringProperty(SwingJavaBuilder.TEXT); SwingAction action = (SwingAction) node.getMainObject(); ActionDefinition def = SwingJavaBuilderUtils.getActionDefintion(text); action.setText(def.getText()); if (def.getAccelerator() != null) { action.setAccelerator(def.getAccelerator()); } if (def.getMnemonic() != null) { action.setMnemonic(def.getMnemonic()); } }  public Class<SwingAction> getApplicableClass() { return SwingAction.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import javax.swing.Action; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public class ActionAsValueHandler implements ITypeAsValueHandler<Action> { private static final ActionAsValueHandler singleton = new ActionAsValueHandler();  public static ActionAsValueHandler getInstance() {return singleton;} private ActionAsValueHandler() {}  public String getInputValueSample() { return \"saveAction\"; }  public String getRegex() { return \".+\"; } public Action getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { Action action = null; String name = node.getStringProperty(key); Object value = process.getByName(name); if (value == null) { throw new BuildException(\"No Action found for name {0}. Values named objects are: {1}\",name, process.getBuildResult().toString()); } else if (value instanceof Action) { action = (Action) value; } else { throw new BuildException(\"Object identified by {0} is not an Action, but a {1}.\",name, value.getClass()); } return action; }  public Class<Action> getApplicableClass() { return Action.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import static org.javabuilders.swing.handler.type.ColorAsValueHandler.COLOR_REGEX; import java.awt.Color; import java.awt.SystemColor; import java.text.MessageFormat; import javax.swing.BorderFactory; import javax.swing.border.Border; import javax.swing.border.EtchedBorder; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public class BorderAsValueHandler implements ITypeAsValueHandler<Border> { public final static String LOWERED_BEVEL = \"loweredBevel\"; public final static String RAISED_BEVEL = \"raisedBevel\"; public final static String LOWERED_ETCHED = \"loweredEtched\"; public final static String RAISED_ETCHED = \"raisedEtched\"; public final static String LINE_BORDER_REGEX = \"\\\\d+\"; public final static String COLOR_LINE_BORDER_REGEX = \"^([a-zA-Z0-9]+)\\\\s+\\\\d+$\"; private final static String regex = MessageFormat.format(\"{0}|{1}|{2}|{3}|{4}|({5})|{6}\", LOWERED_BEVEL, RAISED_BEVEL, LOWERED_ETCHED, RAISED_ETCHED, LINE_BORDER_REGEX, COLOR_REGEX, COLOR_LINE_BORDER_REGEX); private final static BorderAsValueHandler singleton = new BorderAsValueHandler();  public static BorderAsValueHandler getInstance() {return singleton;} "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.util.List; import java.util.Map; import javax.swing.AbstractButton; import javax.swing.ButtonGroup; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class ButtonGroupTypeHandler implements ITypeHandlerFinishProcessor { private final static ButtonGroupTypeHandler singleton = new ButtonGroupTypeHandler(); private final static Logger logger = LoggerFactory.getLogger(ButtonGroupTypeHandler.class);  public static ButtonGroupTypeHandler getInstance() {return singleton;}  private ButtonGroupTypeHandler() {}  @SuppressWarnings(\"unchecked\") public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { try { ButtonGroup group = (ButtonGroup)current.getMainObject(); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.awt.Color; import java.util.HashMap; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public class ColorAsValueHandler implements ITypeAsValueHandler<Color> { private final static String COLOR_NAME_REGEX = \"^[a-zA-Z]*$\"; private final static String COLOR_VALUE_REGEX = \"^([a-fA-F0-9]){6}$\"; private final static String COLOR_VALUE_SHORT_REGEX = \"^([a-fA-F0-9]){3}$\"; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.awt.Component; import java.awt.Container; import java.awt.LayoutManager; import java.lang.reflect.Method; import java.util.HashSet; import java.util.Map; import java.util.Set; import javax.swing.JDesktopPane; import javax.swing.JFrame; import javax.swing.JMenuBar; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.handler.property.ComponentSizeHandler;  public class ContainerTypeHandler implements ITypeHandlerFinishProcessor { private static final ContainerTypeHandler singleton = new ContainerTypeHandler();  public static ContainerTypeHandler getInstance() {return singleton;} private Set<Class<?>> ignored = new HashSet<Class<?>>();  private ContainerTypeHandler() { ignored.add(JMenuBar.class); }  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Container c = (Container) current.getMainObject(); Node content = current.getChildNode(Builder.CONTENT) ; if (content != null && !content.containsType(LayoutManager.class) && !current.isCustomPropertyEqualTo(SwingJavaBuilder.PROPERTY_IGNORE_LAYOUT_MANAGER, Boolean.TRUE)) { for(Node child : content.getChildNodes(Component.class)) { if (!isIgnored(child.getMainObject())) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.awt.Dimension; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Node; import org.javabuilders.handler.ITypeAsValueHandler;  public final class DimensionAsValueHandler implements ITypeAsValueHandler<Dimension> {  private final static String DIMENSION_VALUE_REGEX = \"^[0-9]+x{1}[0-9]+$\";  private final static DimensionAsValueHandler SINGLETON = new DimensionAsValueHandler();  public static DimensionAsValueHandler getInstance() { return SINGLETON; } public String getInputValueSample() { return \"800x600\"; }  @SuppressWarnings(\"boxing\") public Dimension getValue(BuildProcess process, Node node, String key, Object inputValue) throws BuildException { final String dimensionValue = (String) inputValue; if (dimensionValue.matches(DIMENSION_VALUE_REGEX)) { final String[] widthHeight = dimensionValue.split(\"x\"); return new Dimension(Integer.valueOf(widthHeight[0]), Integer.valueOf(widthHeight[1])); } "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.awt.Component; import java.awt.Container; import java.util.ArrayList; import java.util.List; import javax.swing.LayoutFocusTraversalPolicy;  @SuppressWarnings(\"serial\") public class Focus extends LayoutFocusTraversalPolicy { private List<Component> components = new ArrayList<Component>(); @Override public Component getComponentAfter(Container aContainer, Component aComponent) { int i = components.indexOf(aComponent) + 1; if (i >= components.size()) { i = 0; } return components.get(i); } @Override public Component getComponentBefore(Container aContainer, Component aComponent) { int i = components.indexOf(aComponent) + 1; if (i < 0) { i = components.size() - 1; } return components.get(i); } @Override public Component getDefaultComponent(Container aContainer) { return components.get(0); } @Override public Component getFirstComponent(Container aContainer) { return components.get(0); } @Override public Component getLastComponent(Container aContainer) { return components.get(components.size() - 1); }  public List<Component> getComponents() { return components; }  public void setComponents(List<Component> components) { this.components = components; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.awt.Container; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.swing.SwingJavaBuilderUtils;  public class FocusFinishProcessor implements ITypeHandlerFinishProcessor { @Override public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Focus focus = (Focus) current.getMainObject(); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.awt.Component; import java.awt.Container; import java.util.List; import javax.swing.LayoutFocusTraversalPolicy;  @SuppressWarnings(\"serial\") public class FocusPolicy extends LayoutFocusTraversalPolicy { private final List<Component> components; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.awt.Component; import java.awt.Container; import java.awt.FocusTraversalPolicy; import java.util.LinkedList; import java.util.List; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; @SuppressWarnings(\"unchecked\") public class FocusPolicyTypeHandler extends AbstractTypeHandler {  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> properties) throws BuildException { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.util.Map; import java.util.Set; import javax.swing.ComboBoxModel; import javax.swing.JComboBox; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor; public class JComboBoxFinishProcessor implements ITypeHandlerFinishProcessor {  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Set<ComboBoxModel> models = current.getChildObjects(ComboBoxModel.class); JComboBox list = (JComboBox) current.getMainObject(); for(ComboBoxModel model : models) { list.setModel(model); } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.util.Map; import java.util.Set; import javax.swing.JDialog; import javax.swing.JMenuBar; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class JDialogTypeHandler implements ITypeHandlerFinishProcessor { private static final JDialogTypeHandler singleton = new JDialogTypeHandler();  public static JDialogTypeHandler getInstance() {return singleton;}  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { JDialog dialog = (JDialog) current.getMainObject(); Set<Node> menus = current.getChildNodes(JMenuBar.class); for(Node node : menus) { JMenuBar bar = (JMenuBar) node.getMainObject(); dialog.setJMenuBar(bar); break; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.text.DateFormat; import java.text.Format; import java.text.NumberFormat; import java.util.HashMap; import java.util.Map; import javax.swing.JFormattedTextField; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler;  public class JFormattedTextFieldHandler extends AbstractTypeHandler{ public static final String FORMAT = \"format\"; public static final String FORMAT_LOCALE = \"locale\"; public static final String FORMAT_STYLE = \"formatStyle\"; private static final Map<String,Integer> formatStyles = new HashMap<String, Integer>(); public static final String FORMAT_VALUE_DATE = \"date\"; public static final String FORMAT_VALUE_TIME = \"time\"; public static final String FORMAT_VALUE_NUMBER = \"number\"; public static final String FORMAT_VALUE_CURRENCY = \"currency\"; public static final String FORMAT_VALUE_INTEGER = \"integer\"; public static final String FORMAT_VALUE_PERCENT = \"percent\"; public static final String FORMAT_STYLE_VALUE_SHORT = \"short\"; public static final String FORMAT_STYLE_VALUE_MEDIUM = \"medium\"; public static final String FORMAT_STYLE_VALUE_LONG = \"long\"; public static final String FORMAT_STYLE_VALUE_FULL = \"full\"; private static final JFormattedTextFieldHandler singleton = new JFormattedTextFieldHandler(); static { formatStyles.put(FORMAT_STYLE_VALUE_SHORT, DateFormat.SHORT); formatStyles.put(FORMAT_STYLE_VALUE_MEDIUM, DateFormat.MEDIUM); formatStyles.put(FORMAT_STYLE_VALUE_LONG, DateFormat.LONG); formatStyles.put(FORMAT_STYLE_VALUE_FULL, DateFormat.FULL); }  public static JFormattedTextFieldHandler getInstance() {return singleton;}  private JFormattedTextFieldHandler() { super(FORMAT,FORMAT_LOCALE); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { JFormattedTextField instance = null; String formatValue = (String) typeDefinition.get(FORMAT); @SuppressWarnings(\"unused\") String localeValue = (String)typeDefinition.get(FORMAT_LOCALE); if (formatValue == null) { instance = new JFormattedTextField(); } else { @SuppressWarnings(\"unused\") Format format = null; if (FORMAT_VALUE_DATE.equals(formatValue)) { Integer style = (Integer) typeDefinition.get(FORMAT_STYLE); if (style == null) { format = DateFormat.getDateInstance(); } else { format = DateFormat.getDateInstance(style); } } else if (FORMAT_VALUE_TIME.equals(formatValue)) { Integer style = (Integer) typeDefinition.get(FORMAT_STYLE); if (style == null) { format = DateFormat.getTimeInstance(); } else { format = DateFormat.getTimeInstance(style); } } else if (FORMAT_VALUE_NUMBER.equals(formatValue)) { format = NumberFormat.getNumberInstance(); } else if (FORMAT_VALUE_CURRENCY.equals(formatValue)) { format = NumberFormat.getCurrencyInstance(); } else if (FORMAT_VALUE_INTEGER.equals(formatValue)) { format = NumberFormat.getIntegerInstance(); } else if (FORMAT_VALUE_PERCENT.equals(formatValue)) { format = NumberFormat.getPercentInstance(); } else { throw new BuildException(\"Unrecognized JFormattedTextField format: {0}\",formatValue); } } return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent, key, typeDefinition); node.setMainObject(instance); return node; }  public Class<JFormattedTextField> getApplicableClass() { return JFormattedTextField.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.text.Format; import java.util.Map; import javax.swing.JFormattedTextField; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler;  public class JFormattedTextFieldTypeHandler extends AbstractTypeHandler { public static final String FORMAT = \"format\"; private static final JFormattedTextFieldTypeHandler singleton = new JFormattedTextFieldTypeHandler();  public static JFormattedTextFieldTypeHandler getInstance() {return singleton;}  private JFormattedTextFieldTypeHandler() { super(FORMAT); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { JFormattedTextField instance = null; String formatName = (String)typeDefinition.get(FORMAT); if (formatName != null) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.util.Map; import java.util.Set; import javax.swing.JFrame; import javax.swing.JMenuBar; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class JFrameTypeHandler implements ITypeHandlerFinishProcessor { private static final JFrameTypeHandler singleton = new JFrameTypeHandler();  public static JFrameTypeHandler getInstance() {return singleton;}  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { JFrame frame = (JFrame) current.getMainObject(); Set<Node> menus = current.getChildNodes(JMenuBar.class); for(Node node : menus) { JMenuBar bar = (JMenuBar) node.getMainObject(); frame.setJMenuBar(bar); break; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.util.Map; import javax.swing.JInternalFrame; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class JInternalFrameFinishProcessor implements ITypeHandlerFinishProcessor { public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { JInternalFrame f = (JInternalFrame) current.getMainObject(); f.pack(); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.util.Map; import java.util.Set; import javax.swing.JList; import javax.swing.ListModel; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class JListFinishProcessor implements ITypeHandlerFinishProcessor {  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Set<ListModel> models = current.getChildObjects(ListModel.class); JList list = (JList) current.getMainObject(); for(ListModel model : models) { list.setModel(model); } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.awt.Component; import java.text.MessageFormat; import java.util.Map; import javax.swing.JSplitPane; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerAfterCreationProcessor; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.swing.SwingJavaBuilder; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class JSpiltPaneTypeHandler implements ITypeHandlerAfterCreationProcessor, ITypeHandlerFinishProcessor { private static final JSpiltPaneTypeHandler singleton = new JSpiltPaneTypeHandler(); private static final Logger logger = LoggerFactory.getLogger(JSpiltPaneTypeHandler.class);  public static JSpiltPaneTypeHandler getInstance() {return singleton;}  private JSpiltPaneTypeHandler() {}  public void afterCreation(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.awt.Component; import java.util.Map; import javax.swing.Icon; import javax.swing.JTabbedPane; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.swing.IconUtils; import org.javabuilders.swing.SwingJavaBuilder;  public class JTabbedPaneTypeHandler implements ITypeHandlerFinishProcessor { private static final JTabbedPaneTypeHandler singleton = new JTabbedPaneTypeHandler(); public final static String TAB_TITLE = \"tabTitle\"; public final static String TAB_ICON = \"tabIcon\"; public final static String TAB_TOOLTIP =\"tabToolTip\"; public final static String TAB_ENABLED =\"tabEnabled\";  public static JTabbedPaneTypeHandler getInstance() {return singleton;}  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { JTabbedPane tabs = (JTabbedPane) current.getMainObject(); Node content = current.getChildNode(Builder.CONTENT); if (content != null) { current.getCustomProperties().put(SwingJavaBuilder.PROPERTY_IGNORE_LAYOUT_MANAGER, Boolean.TRUE); int tabCounter = 0; for(Node child : content.getChildNodes()) { tabCounter++; Component c = (Component) child.getMainObject(); String tabTitle = child.getStringProperty(TAB_TITLE); if (tabTitle == null) { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.util.Map; import java.util.Set; import javax.swing.JTable; import javax.swing.table.TableColumn; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor;  public class JTableFinishProcessor implements ITypeHandlerFinishProcessor { private static final JTableFinishProcessor singleton = new JTableFinishProcessor();  public static JTableFinishProcessor getInstance() { return singleton; } private JTableFinishProcessor() { }  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Node content = current.getChildNode(Builder.CONTENT); if (content != null) { JTable table = (JTable) current.getMainObject(); Set<TableColumn> columns = current.getContentObjects(TableColumn.class); "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.swing.SwingAction;  public class SwingActionHandler extends AbstractTypeHandler { private static final SwingActionHandler singleton = new SwingActionHandler(); public static final String SHORT_DESCRIPTION =\"shortDescription\"; public static final String SHORT_DESC =\"shortDesc\"; public static final String LONG_DESCRIPTION =\"longDescription\"; public static final String LONG_DESC =\"longDesc\";  public static SwingActionHandler getInstance() {return singleton;} private SwingActionHandler() { super(Builder.NAME); }  public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { return useExistingInstance(config, process, parent, key, typeDefinition, new SwingAction()); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent, key, typeDefinition); node.setMainObject(instance); String name = node.getStringProperty(Builder.NAME); if (name == null) { throw new BuildException(\"An Action requires a 'name' attribute: {0}\",typeDefinition); } return node; }  public Class<SwingAction> getApplicableClass() { return SwingAction.class; } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type; import java.util.Map; import java.util.Set; import javax.swing.DefaultCellEditor; import javax.swing.JCheckBox; import javax.swing.JComboBox; import javax.swing.JTable; import javax.swing.JTextField; import javax.swing.table.TableCellEditor; import javax.swing.table.TableCellRenderer; import javax.swing.table.TableColumn; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.util.JBStringUtils;  public class TableColumnTypeHandler extends AbstractTypeHandler implements ITypeHandlerFinishProcessor {  public static final String FOR_HEADER = \"forHeader\"; public static final String IDENTIFIER = \"identifier\"; public static final String HEADER_VALUE = \"headerValue\"; public static final String FILTER = \"filter\"; "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type.layout; import java.awt.CardLayout; import java.awt.Component; import java.awt.Container; import java.util.Map; import javax.swing.JComponent; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.swing.SwingJavaBuilderUtils;  public class CardLayoutTypeHandler implements ITypeHandlerFinishProcessor { private static final CardLayoutTypeHandler singleton = new CardLayoutTypeHandler();  public static CardLayoutTypeHandler getInstance() {return singleton;}  private CardLayoutTypeHandler() {}  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Container container = SwingJavaBuilderUtils.getParentContainer(current); if (container != null) { CardLayout layout = (CardLayout) current.getMainObject(); container.setLayout(layout); Node content = current.getParent(); if (content != null) { for(Node child : content.getChildNodes(JComponent.class)) { Component c = (Component) child.getMainObject(); container.add(c,c.getName()); } } } else { throw new BuildException(\"Unable to process CardLayout since no parent JComponent was found: {0}\", typeDefinition); } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type.layout; import java.awt.Component; import java.awt.Container; import java.awt.FlowLayout; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeHandlerFinishProcessor; import org.javabuilders.swing.SwingJavaBuilderUtils;  public class FlowLayoutTypeHandler implements ITypeHandlerFinishProcessor { private final static FlowLayoutTypeHandler singleton = new FlowLayoutTypeHandler();  public static FlowLayoutTypeHandler getInstance() {return singleton;}  public void finish(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { Container container = SwingJavaBuilderUtils.getParentContainer(current); if (container != null) { FlowLayout layout = (FlowLayout)current.getMainObject(); container.setLayout(layout); for(Node child : current.getParent().getChildNodes(Component.class)) { Component c = (Component) child.getMainObject(); container.add(c); } } } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.handler.type.layout; import java.awt.Component; import java.awt.Container; import java.util.Map; import javax.swing.JLabel; import net.miginfocom.swing.MigLayout; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.layout.mig.AbstractMigLayoutHandler; import org.javabuilders.swing.SwingJavaBuilderUtils;  public class MigLayoutHandler extends AbstractMigLayoutHandler { private final static MigLayoutHandler singleton = new MigLayoutHandler();  public static MigLayoutHandler getInstance() { return singleton; }  private MigLayoutHandler() { super(JLabel.class,\"text\"); }  public Node createNewInstance(BuilderConfig config, BuildProcess result, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { MigLayout instance = new MigLayout(); return useExistingInstance(config, result, parent, key, typeDefinition, instance); }  public Class<?> getApplicableClass() { return MigLayout.class; }  @Override protected void applyControlConstraints(BuildProcess process, Node node, Node components, Map<String, String> layoutConstraints) throws BuildException { Container parentContainer = (Container)node.getParent().getParent().getMainObject(); for(String componentName : layoutConstraints.keySet()) { String componentConstraint = layoutConstraints.get(componentName); Component component = SwingJavaBuilderUtils.getComponent(components,String.valueOf(componentName)); if (component == null) { throw new BuildException(\"Unable to find component for name: {0}\",componentName); } if (logger.isDebugEnabled()) { logger.debug(\"MigLayout constraints for \" + componentName + \" : \" + componentConstraint); } parentContainer.add(component,componentConstraint); } }  @Override protected Object getComponent(BuildProcess result, Node components, String name) throws BuildException { Component component = SwingJavaBuilderUtils.getComponent(components,String.valueOf(name)); return component; }  @Override protected void setLayout(BuildProcess result, Node node, Object migLayout) { Node parent = node.getParent().getParent(); Container parentContainer = (Container)parent.getMainObject(); MigLayout layout = (MigLayout)node.getMainObject(); parentContainer.setLayout(layout); }  @Override protected void setLayoutConstraints(Object layout, String constraints) { ((MigLayout)layout).setLayoutConstraints(constraints); }  @Override protected void setRowConstraints(Object layout, String constraints) { ((MigLayout)layout).setRowConstraints(constraints); }  @Override protected void setColumnConstraints(Object layout, String constraints) { ((MigLayout)layout).setColumnConstraints(constraints); }  @Override protected void setControlName(Object control, String name) { ((Component)control).setName(name); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.handler.type.model; import java.util.Map; import javax.swing.DefaultComboBoxModel; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.handler.ITypeHandlerAfterCreationProcessor;  public class DefaultComboBoxModelHandler implements ITypeHandlerAfterCreationProcessor, ITypeChildrenHandler {  public void afterCreation(BuilderConfig config, BuildProcess process, Node current, String key, Map<String, Object> typeDefinition) throws BuildException { @SuppressWarnings(\"unused\") DefaultComboBoxModel model = (DefaultComboBoxModel) current.getMainObject(); if (current.getContentNode() != null) { for(@SuppressWarnings(\"unused\") String value : current.getContentNode().getChildValues().keySet()) { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.util; import java.util.ResourceBundle; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.util.YamlBuilder; public class SwingYamlBuilder extends YamlBuilder {  public SwingYamlBuilder(String root) { super(root); }  public BuildResult build(Object caller, ResourceBundle...bundles) { return build(SwingJavaBuilder.getConfig(),caller,bundles); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists; import org.javabuilders.BuilderConfig; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.plugin.glazedlists.handler.EventComboBoxModelTypeHandler; import org.javabuilders.swing.plugin.glazedlists.handler.EventListModelTypeHandler; import org.javabuilders.swing.plugin.glazedlists.handler.EventTableModelTypeHandler; import ca.odell.glazedlists.TextFilterator; import ca.odell.glazedlists.swing.EventComboBoxModel; import ca.odell.glazedlists.swing.EventListModel; import ca.odell.glazedlists.swing.EventTableModel;  public class SwingGlazedListsConfig { private static boolean initDone = false;  public static void init() { if (!initDone) { init(SwingJavaBuilder.getConfig()); initDone = true; } }  public static void init(BuilderConfig config) { config.addType(EventListModel.class, EventComboBoxModel.class,EventTableModel.class, TextFilterator.class); config.forType(EventListModel.class).typeHandler(new EventListModelTypeHandler()); config.forType(EventComboBoxModel.class).typeHandler(new EventComboBoxModelTypeHandler()); config.forType(EventTableModel.class).asList(EventTableModelTypeHandler.COLUMNS, EventTableModelTypeHandler.SORT_BY) .typeHandler(new EventTableModelTypeHandler()); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.compiler; import java.net.URI; import javax.tools.SimpleJavaFileObject; /** * Taken from: * http:"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.compiler; import java.io.IOException; import java.security.SecureClassLoader; import javax.tools.FileObject; import javax.tools.ForwardingJavaFileManager; import javax.tools.JavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.JavaFileObject.Kind; /** * Taken from : http:"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.compiler; import java.lang.StringBuilder;  public class ClassStringBuilder { private StringBuilder bld = new StringBuilder();  public ClassStringBuilder _(String template, Object...params) { return add(0,template,params); } public ClassStringBuilder ___(String template, Object...params) { return add(1,template,params); } public ClassStringBuilder _____(String template, Object...params) { return add(2,template,params); } public ClassStringBuilder _______(String template, Object...params) { return add(3,template,params); } public ClassStringBuilder _________(String template, Object...params) { return add(4,template,params); } public ClassStringBuilder ___________(String template, Object...params) { return add(5,template,params); } private ClassStringBuilder add(int level, String template, Object...params) { for(int i = 0; i < level;i++) { bld.append(\"\\t\"); } bld.append(String.format(template, params)).append(\"\\n\"); return this; } @Override public String toString() { return bld.toString(); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.compiler; import java.util.Calendar; import java.util.Comparator; import java.util.List; import java.util.Random; import org.codehaus.janino.ClassBodyEvaluator; import org.codehaus.janino.CompileException; import org.codehaus.janino.Parser.ParseException; import org.codehaus.janino.Scanner.ScanException; import org.javabuilders.BuildException; import org.javabuilders.util.PropertyUtils; public class CompilerUtils { private static final Random RANDOM = new Random();  public static Class<?> compile(String className, String classBody, Class<?> type, Class<?>...interfaces) throws Exception { ClassBodyEvaluator eval = new ClassBodyEvaluator(); eval.setParentClassLoader(Thread.currentThread().getContextClassLoader()); eval.setClassName(className); eval.setExtendedType(type); eval.setImplementedTypes(interfaces); eval.cook(classBody); return eval.getClazz(); }  public static String generateClassName(Class<?> baseClass) { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.compiler; import java.util.ArrayList; import java.util.Calendar; import java.util.Comparator; import java.util.List; import java.util.Random; import javax.tools.JavaCompiler; import javax.tools.JavaFileManager; import javax.tools.JavaFileObject; import javax.tools.ToolProvider; import org.javabuilders.BuildException; import org.javabuilders.util.PropertyUtils;  @Deprecated public class JavaCCUtils { private static final Random RANDOM = new Random(); private static JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); private static JavaFileManager fileManager = new ClassFileManager(compiler.getStandardFileManager(null, null, null));  public static Class<?> compile(String fullName, String src) throws ClassNotFoundException { List<JavaFileObject> jfiles = new ArrayList<JavaFileObject>(); jfiles.add(new CharSequenceJavaFileObject(fullName, src)); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.compiler; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.OutputStream; import java.net.URI; import javax.tools.SimpleJavaFileObject; /** * Taken from: http:"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.handler; import java.util.LinkedHashMap; import java.util.Map; import ca.odell.glazedlists.gui.TableFormat; public class BaseTableFormat implements TableFormat<Object> { private Map<String,String> columns; private String[] names;  public void setColumns(LinkedHashMap<String,String> columns) { this.columns = columns; names = columns.values().toArray(new String[columns.keySet().size()]); }  public int getColumnCount() { return columns.size(); }  public String getColumnName(int i) { return names[i]; }  public Object getColumnValue(Object arg, int index) { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.handler; import java.util.ArrayList; import java.util.List; import ca.odell.glazedlists.gui.WritableTableFormat; public class BaseWritableTableFormat extends BaseTableFormat implements WritableTableFormat<Object> { private List<Integer> editableColumns = new ArrayList<Integer>();  public void setEditableColumnIndexes(List<Integer> columnIndexes) { editableColumns = columnIndexes; }  public boolean isEditable(Object baseObject, int column) { return editableColumns.contains(column); }  public Object setColumnValue(Object baseObject, Object newValue, int column) { "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.handler; import static org.javabuilders.util.Preconditions.*; import java.lang.reflect.Field; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.util.BuilderUtils; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.swing.EventComboBoxModel;  public class EventComboBoxModelTypeHandler extends AbstractTypeHandler { public static final String SOURCE=\"source\"; public EventComboBoxModelTypeHandler() { super(SOURCE); }  @SuppressWarnings(\"unchecked\") public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, final Map<String, Object> typeDefinition) throws BuildException { String source = (String) typeDefinition.get(SOURCE); checkNotNull(source,\"EventComboBoxModel.source property must be specified: {0}\",typeDefinition); Field field = BuilderUtils.getField(process.getCaller(),source, EventList.class); checkNotNull(field, \"EventComboBoxModel.source property does not point to a valid instance of GlazedLists EventList: {0}\",typeDefinition); try { EventList list = GlazedListsUtils.getSource(process.getCaller(), typeDefinition).get0(); EventComboBoxModel instance = new EventComboBoxModel<Object>(list); return useExistingInstance(config, process, parent, key, typeDefinition, instance); } catch (Exception e) { throw new BuildException(e,\"Unable to get instance of EventComboBoxModel.source: {0}\",typeDefinition); } }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition,instance); return node; }  @SuppressWarnings(\"unchecked\") public Class<EventComboBoxModel> getApplicableClass() { return EventComboBoxModel.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.plugin.glazedlists.handler; import java.util.Map; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.swing.EventListModel;  public class EventListModelTypeHandler extends AbstractTypeHandler { public static final String SOURCE=\"source\"; public EventListModelTypeHandler() { super(SOURCE); }  @SuppressWarnings(\"unchecked\") public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition) throws BuildException { EventList list = GlazedListsUtils.getSource(process.getCaller(), typeDefinition).get0(); EventListModel instance = new EventListModel<Object>(list); return useExistingInstance(config, process, parent, key, typeDefinition, instance); }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent,key,typeDefinition,instance); return node; }  @SuppressWarnings(\"unchecked\") public Class<EventListModel> getApplicableClass() { return EventListModel.class; } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.plugin.glazedlists.handler; import static org.javabuilders.swing.handler.type.TableColumnTypeHandler.EDITABLE; import static org.javabuilders.util.Preconditions.checkNotNull; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.regex.Matcher; import java.util.regex.Pattern; import javax.swing.JComponent; import javax.swing.JTable; import javax.swing.table.TableColumn; import javax.swing.text.JTextComponent; import org.javabuilders.BuildException; import org.javabuilders.BuildProcess; import org.javabuilders.Builder; import org.javabuilders.BuilderConfig; import org.javabuilders.Node; import org.javabuilders.handler.AbstractTypeHandler; import org.javabuilders.handler.ITypeChildrenHandler; import org.javabuilders.swing.handler.type.TableColumnTypeHandler; import org.javabuilders.swing.plugin.glazedlists.compiler.CompilerUtils; import org.javabuilders.util.BuilderUtils; import org.javabuilders.util.JBStringUtils; import org.javabuilders.util.PropertyUtils; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.FilterList; import ca.odell.glazedlists.SortedList; import ca.odell.glazedlists.TextFilterator; import ca.odell.glazedlists.gui.TableFormat; import ca.odell.glazedlists.impl.beans.BeanTableFormat; import ca.odell.glazedlists.matchers.MatcherEditor; import ca.odell.glazedlists.swing.EventTableModel; import ca.odell.glazedlists.swing.TableComparatorChooser; import ca.odell.glazedlists.swing.TextComponentMatcherEditor;  public class EventTableModelTypeHandler extends AbstractTypeHandler implements ITypeChildrenHandler { public static final String SOURCE = \"source\"; public static final String HEADER_VALUE = TableColumnTypeHandler.HEADER_VALUE; public static final String SORT = \"sort\"; public static final String SORT_SINGLE = \"single\"; public static final String SORT_MULTI = \"multi\"; public static final String SORT_BY = \"sortBy\"; public static final String COLUMNS = \"columns\"; private static final String TEXT_FILTERATOR = \"TextFilterator\"; private static final Pattern TEXT_FILTERATOR_REGEX = Pattern.compile(\"(?:[a-zA-Z]+\\\\()([a-zA-Z0-9]+)=\\\\[(.*)\\\\]\"); public EventTableModelTypeHandler() { super(SOURCE, SORT,EDITABLE, COLUMNS, SORT_BY); }  @SuppressWarnings(\"unchecked\") public Node createNewInstance(BuilderConfig config, BuildProcess process, Node parent, String key, final Map<String, Object> typeDefinition) throws BuildException { String source = (String) typeDefinition.get(SOURCE); checkNotNull(source, \"EventTableModel.source property must be specified: {0}\", typeDefinition); List<Map<String, Object>> cols = parent.getParent().getContentData(TableColumn.class); JTable table = (JTable) parent.getParentObject(JTable.class); Field field = BuilderUtils.getField(process.getCaller(), source, EventList.class); checkNotNull(field,\"EventTableModel.source property does not point to a valid instance of GlazedLists EventList: {0}\", typeDefinition); try { EventList list = GlazedListsUtils.getSource(process.getCaller(), typeDefinition).get0(); Class<?> type = BuilderUtils.getGenericsTypeFromCollectionField(field); if (type == null) { throw new BuildException(\"Unable to use generics to find type of object stored in source: {0}\", source); } LinkedHashMap<String, String> columnNames = getColumnNamesAndHeaders(process, typeDefinition, cols, type); TableFormat tableFormat = createTableFormat(parent, type, typeDefinition, cols, columnNames); EventTableModel instance = setupModel(process, typeDefinition, table, list, cols, type,tableFormat, source); return useExistingInstance(config, process, parent, key, typeDefinition, instance); } catch (BuildException ex) { throw ex; } catch (Exception e) { throw new BuildException(e, \"Unable to create instance of EventTableModel: {0}.\\n{1}\", typeDefinition,e.getMessage()); } }  public Node useExistingInstance(BuilderConfig config, BuildProcess process, Node parent, String key, Map<String, Object> typeDefinition, Object instance) throws BuildException { Node node = new Node(parent, key, typeDefinition, instance); return node; }  @SuppressWarnings(\"unchecked\") public Class<EventTableModel> getApplicableClass() { return EventTableModel.class; } "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.handler; import static org.javabuilders.util.Preconditions.*; import java.lang.reflect.Field; import java.util.Comparator; import java.util.List; import java.util.Map; import org.apache.commons.lang.StringUtils; import org.javabuilders.BuildException; import org.javabuilders.swing.plugin.glazedlists.compiler.ClassStringBuilder; import org.javabuilders.swing.plugin.glazedlists.compiler.CompilerUtils; import org.javabuilders.util.BuilderUtils; import org.javabuilders.util.PropertyUtils; import org.javabuilders.util.Tuple2; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.TransformedList; import ca.odell.glazedlists.UniqueList;  public class GlazedListsUtils { public static final String SOURCE = \"source\";  @SuppressWarnings(\"unchecked\") public static Tuple2<EventList,Class<?>> getSource(Object caller, Map<String, Object> typeDefinition) throws BuildException { try { String source = (String) typeDefinition.get(SOURCE); if (source == null) { throw new BuildException(\"EventTableModel.source property must be specified: {0}\", typeDefinition); } "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.plugin.glazedlists.handler; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.TransformedList; import ca.odell.glazedlists.event.ListEvent;  public abstract class ReadOnlyTransformedList<S,E> extends TransformedList<S, E> { protected ReadOnlyTransformedList(EventList<S> source) { super(source); source.addListEventListener(this); } @Override protected boolean isWritable() { return false; } @Override public void listChanged(ListEvent<S> listChanges) { updates.forwardEvent(listChanges); } }"}
{"name": "jacek99/javabuilders", "content": "package person.app; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.text.MessageFormat; public class Person { private String firstName; private String lastName; private String emailAddress; "}
{"name": "jacek99/javabuilders", "content": "package person.app; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import javax.swing.JFrame; import javax.swing.JOptionPane; import javax.swing.SwingUtilities; import javax.swing.UIManager; import org.javabuilders.BuildResult; import org.javabuilders.annotations.DoInBackground; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.CancelStatus; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings({\"serial\",\"unused\"}) public class PersonApp extends JFrame { private Person person; private BuildResult result; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import org.javabuilders.swing.SwingJavaBuilder; public class AlignmentAndSizesPanel extends SamplePanel { public AlignmentAndSizesPanel() throws Exception { super(); SwingJavaBuilder.build(this); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.samples; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder;  @SuppressWarnings(\"serial\") public class BorderPanel extends SamplePanel { @SuppressWarnings(\"unused\") private BuildResult result = SwingJavaBuilder.build(this);  public BorderPanel() throws Exception { } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import java.awt.CardLayout; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings({ \"unused\", \"serial\" }) public class CardLayoutPanel extends SamplePanel { private BuildResult result = SwingJavaBuilder.build(this); private CardLayout cards; public CardLayoutPanel() throws Exception { super(); } private void switch1() { cards.show(this,\"panel1\"); } private void switch2() { cards.show(this,\"panel2\"); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings(\"serial\") public class ComponentsPanel extends SamplePanel { @SuppressWarnings(\"unused\") private BuildResult result = SwingJavaBuilder.build(this); public ComponentsPanel() throws Exception { super(); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import java.text.DateFormat; import java.util.Calendar; import javax.swing.JLabel; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings({\"serial\",\"unused\"}) public class EventsPanel extends SamplePanel { private JLabel lbl1; private JLabel focusLabel; private JLabel focusLostLabel; private JLabel keyPressedLabel; private JLabel keyReleasedLabel; private JLabel keyTypedLabel; private JLabel mouseEnteredLabel; private JLabel mouseExitedLabel; private JLabel mouseClickedLabel; private JLabel mouseDoubleClickedLabel; private JLabel mouseRightClickedLabel; private JLabel wheelLabel; "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import javax.swing.JButton; import javax.swing.JOptionPane; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings(\"serial\") public class FlowLayoutPanel extends SamplePanel { @SuppressWarnings(\"unused\") private BuildResult result = SwingJavaBuilder.build(this); public FlowLayoutPanel() throws Exception { super(); } @SuppressWarnings(\"unused\") private void showButton(JButton button) { JOptionPane.showMessageDialog(this,\"Button '\" + button.getText() + \"' was clicked\"); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import javax.swing.JPanel; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder;  public class FormattedInputPanel extends SamplePanel { private BuildResult result = SwingJavaBuilder.build(this); public FormattedInputPanel() throws Exception { super(); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import java.awt.Cursor; import java.util.List; import java.util.Random; import javax.swing.JList; import javax.swing.JOptionPane; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.samples.resources.Defect; import ca.odell.glazedlists.BasicEventList; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.GlazedLists; import ca.odell.glazedlists.TextFilterator; import ca.odell.glazedlists.swing.EventListModel; import ca.odell.glazedlists.swing.EventSelectionModel; public class GlazedListsEditablePanel extends SamplePanel implements ListSelectionListener { private final EventList<Defect> defects = GlazedLists.threadSafeList(new BasicEventList<Defect>()); private String[] states = {\"Fixed\",\"New\",\"In Progress\",\"Rejected\",\"Works for me\"}; private String[] types = {\"Bug\",\"Enhancement\",\"Documentation\",\"Task\",\"Question\"}; private String[] reporters = {\"John Doe\",\"Jane Doe\",\"Jimmy Doenowski\",\"Arnold Doenator\",\"Sylvester Doellone\"}; private Random random = new Random(); public GlazedListsEditablePanel() throws Exception { super(); SwingJavaBuilder.build(this); createData(100); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import java.awt.Cursor; import java.util.List; import java.util.Random; import javax.swing.JList; import javax.swing.JOptionPane; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.samples.resources.Defect; import ca.odell.glazedlists.BasicEventList; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.GlazedLists; import ca.odell.glazedlists.TextFilterator; import ca.odell.glazedlists.swing.EventListModel; import ca.odell.glazedlists.swing.EventSelectionModel; public class GlazedListsSamplePanel extends SamplePanel implements ListSelectionListener { private final EventList<Defect> defects = GlazedLists.threadSafeList(new BasicEventList<Defect>()); private String[] states = {\"Fixed\",\"New\",\"In Progress\",\"Rejected\",\"Works for me\"}; private String[] types = {\"Bug\",\"Enhancement\",\"Documentation\",\"Task\",\"Question\"}; private String[] reporter = {\"John Doe\",\"Jane Doe\",\"Jimmy Doenowski\",\"Arnold Doenator\",\"Sylvester Doellone\"}; private Random random = new Random(); public GlazedListsSamplePanel() throws Exception { super(); SwingJavaBuilder.build(this); createData(100); "}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import javax.swing.JDesktopPane; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; public class JDesktopPanePanel extends SamplePanel { JDesktopPane desktop; public JDesktopPanePanel() throws Exception { super(); BuildResult r = SwingJavaBuilder.build(this); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import javax.swing.JOptionPane; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings({\"serial\",\"unused\"}) public class LayoutManagerShowdownChallenge extends SamplePanel { private BuildResult result = SwingJavaBuilder.build(this); public LayoutManagerShowdownChallenge() throws Exception {} private void doNew() { JOptionPane.showMessageDialog(this,\"private void doNew() was called!\"); } private void delete() { JOptionPane.showMessageDialog(this,\"private void delete() was called!\"); } private void edit() { JOptionPane.showMessageDialog(this,\"private void edit() was called!\"); } private void save() { JOptionPane.showMessageDialog(this,\"private void save() was called!\"); } private void cancel() { JOptionPane.showMessageDialog(this,\"private void cancel() was called!\"); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.util.Calendar; import java.util.LinkedList; import java.util.List; import javax.swing.JList; import javax.swing.JPanel; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.samples.resources.Person; import org.javabuilders.swing.samples.resources.PersonDialog; import org.jdesktop.observablecollections.ObservableCollections; public class ListBindingPanel extends SamplePanel { private PropertyChangeSupport support = new PropertyChangeSupport(this); private List<Person> people = ObservableCollections.observableList(new LinkedList<Person>()); private JList list; private String listStatus = \"\"; public ListBindingPanel() throws Exception { super(); Calendar date = Calendar.getInstance(); date.set(Calendar.YEAR, 1970); people.add(new Person(\"John\",\"Doe\", date)); people.add(new Person(\"Jan\",\"Doenowvsky\", date)); people.add(new Person(\"Jazz\",\"Doezilla\", date)); SwingJavaBuilder.build(this); } public void addPropertyChangeListener(PropertyChangeListener listener) { if (support != null) { support.addPropertyChangeListener(listener); } } public void removePropertyChangeListener(PropertyChangeListener listener) { if (support != null) { support.removePropertyChangeListener(listener); } }  public List<Person> getPeople() { return people; } @SuppressWarnings(\"unused\") private void addPerson() { PersonDialog dialog = new PersonDialog(); dialog.setVisible(true); if (dialog.getPerson().getFirstName() != null) { people.add(dialog.getPerson()); } } @SuppressWarnings(\"unused\") private void deleteFromList() { Person person = (Person) list.getSelectedValue(); people.remove(person); }  public String getListStatus() { return listStatus; }  public void setListStatus(String status) { String old = this.listStatus; this.listStatus = status; support.firePropertyChange(\"listStatus\", old, this.listStatus); } private void listSelectedNotification() { setListStatus(\"List selected on : \" + Calendar.getInstance().getTime()); } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.samples; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder;  @SuppressWarnings(\"serial\") public class MigLayoutPanel1 extends SamplePanel { @SuppressWarnings(\"unused\") private BuildResult result = SwingJavaBuilder.build(this);  public MigLayoutPanel1() throws Exception { } }"}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.samples; import java.awt.event.ActionEvent; import javax.swing.JButton; import javax.swing.JComponent; import javax.swing.JOptionPane; import org.javabuilders.BuildResult; import org.javabuilders.annotations.DoInBackground; import org.javabuilders.event.BackgroundEvent; import org.javabuilders.event.CancelStatus; import org.javabuilders.swing.SwingJavaBuilder;  @SuppressWarnings(\"serial\") public class MigLayoutPanel2 extends SamplePanel { @SuppressWarnings(\"unused\") private BuildResult result = SwingJavaBuilder.build(this);  public MigLayoutPanel2() throws Exception { } @SuppressWarnings(\"unused\") private void doAdd(JComponent c, ActionEvent evt) { JOptionPane.showMessageDialog(this,\"btnAdd => private void doAdd(JComponent c, ActionEvent evt)\"); } @SuppressWarnings(\"unused\") private void delete(ActionEvent evt) { JOptionPane.showMessageDialog(this,\"btnDelete => private void delete(ActionEvent evt) \"); } @SuppressWarnings(\"unused\") private void edit(JButton button) { JOptionPane.showMessageDialog(this,\"btnEdit => private void edit(JButton button)\"); } @SuppressWarnings(\"unused\") private void advanced() { JOptionPane.showMessageDialog(this,\"btnAdanced => private void advanced()\"); } @SuppressWarnings(\"unused\") private void cancel() { JOptionPane.showMessageDialog(this,\"btnCancel => private void cancel()\"); } @SuppressWarnings(\"unused\") @DoInBackground(indeterminateProgress=false,cancelable=true,progressStart=1,progressEnd=100) private void save(BackgroundEvent evt) { for(int i = 1; i <= 100; i++) { evt.setProgressValue(i); if (evt.getCancelStatus() != CancelStatus.REQUESTED) { try { evt.setProgressMessage(\"Processing \" + i + \" of \" + \" 100\"); Thread.sleep(200); } catch (InterruptedException e) {} } else { evt.setCancelStatus(CancelStatus.PROCESSING); try { evt.setProgressMessage(\"Cancelling process....please wait.\"); Thread.sleep(1000); } catch (InterruptedException e) {} evt.setCancelStatus(CancelStatus.COMPLETED); break; } } } @SuppressWarnings(\"unused\") private void finishSave() { JOptionPane.showMessageDialog(this,\"Save was successfully completed!\"); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import javax.swing.JOptionPane; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings({\"serial\",\"unused\"}) public class MigLayoutPanel3 extends SamplePanel { private BuildResult result = SwingJavaBuilder.build(this); public MigLayoutPanel3() throws Exception { super(); } private void addNew() { JOptionPane.showMessageDialog(this,\"addNew() from prototype button $btnAdd\"); } private void edit() { JOptionPane.showMessageDialog(this,\"edit() from prototype button $btnEdit\"); } private void delete() { JOptionPane.showMessageDialog(this,\"delete() from prototype button $btnDelete\"); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import javax.swing.JPanel; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.util.BuilderUtils;  @SuppressWarnings(\"serial\") public class SamplePanel extends JPanel { private PropertyChangeSupport support = new PropertyChangeSupport(this); private String yaml = BuilderUtils.getYamlContent(SwingJavaBuilder.getConfig(), this.getClass()); public SamplePanel() throws Exception {} public void addPropertyChangeListener(PropertyChangeListener listener) { if (support != null) { support.addPropertyChangeListener(listener); } } public void removePropertyChangeListener(PropertyChangeListener listener) { if (support != null) { support.removePropertyChangeListener(listener); } }  public String getYaml() {return yaml;} }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import java.awt.event.ActionEvent; import java.awt.event.WindowEvent; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.text.DateFormat; import javax.swing.JFrame; import javax.swing.JOptionPane; import javax.swing.JTextArea; import javax.swing.UIManager; import javax.swing.event.ChangeEvent; import org.javabuilders.BuildResult; import org.javabuilders.event.BuildAdapter; import org.javabuilders.event.BuildEvent; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.plugin.glazedlists.SwingGlazedListsConfig; import org.javabuilders.util.BuilderUtils; @SuppressWarnings({ \"unused\", \"serial\" }) public class SwingSamplesFrame extends JFrame { "}
{"name": "jacek99/javabuilders", "content": " package org.javabuilders.swing.samples; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JTextArea; import org.javabuilders.swing.SwingJavaBuilder; import org.javabuilders.swing.samples.external.CardLayoutFrame; import org.javabuilders.swing.samples.external.CenteredJFrame; import org.javabuilders.util.BuilderUtils;  @SuppressWarnings({\"serial\",\"unused\"}) public class UserSubmissionsPanel extends SamplePanel implements ActionListener { private JTextArea source; public UserSubmissionsPanel() throws Exception { super(); SwingJavaBuilder.build(this); } public void actionPerformed(ActionEvent e) { try { if (e.getActionCommand().equals(\"cardLayoutInFrame\")) { CardLayoutFrame cardLayoutInFrame = new CardLayoutFrame(); cardLayoutInFrame.setVisible(true); source.setText(BuilderUtils.getYamlContent(SwingJavaBuilder.getConfig(), CardLayoutFrame.class)); } else if (e.getActionCommand().equals(\"centeredJFrame\")) { CenteredJFrame frame = new CenteredJFrame(); source.setText(BuilderUtils.getYamlContent(SwingJavaBuilder.getConfig(), CenteredJFrame.class)); } } catch (Exception ex) { ex.printStackTrace(); } } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples; import org.javabuilders.BuildResult; import org.javabuilders.handler.validation.ICustomValidator; import org.javabuilders.handler.validation.ValidationMessage; import org.javabuilders.handler.validation.ValidationMessageList; import org.javabuilders.swing.SwingJavaBuilder;  @SuppressWarnings(\"serial\") public class ValidatorsPanel extends SamplePanel { @SuppressWarnings(\"unused\") private BuildResult result = SwingJavaBuilder.build(this); public ValidatorsPanel() throws Exception { super(); result.getValidators().add(new ICustomValidator() { public void validate(ValidationMessageList list) { if (list.size() > 0) { list.add(new ValidationMessage(\"If other errors exist, a new custom validator message is added as well!\")); } } }); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples.external; import java.awt.CardLayout; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JTabbedPane; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings({\"serial\",\"unused\"}) public class CardLayoutFrame extends JFrame { BuildResult result; private CardLayout cards; private JPanel progressPanel; private JTabbedPane tabs; public CardLayoutFrame() { result = SwingJavaBuilder.build(this); } private void urlSubmit() {} private void outputFolderSubmit() {} private void exitApplication() {} private void randomStructureClicked() {} private void randomDataClicked() {} private void networkDownloadsClicked() {} private void noPVRClicked(){} private void noUPAClicked() {} private void loadSubmit() {} private void saveSubmit() {} private void newSubmit() {} private void editSubmit() {} private void deleteSubmit() {} private void showProgress() { cards.show(this.getContentPane(), progressPanel.getName()); } private void showTabs() { cards.show(this.getContentPane(), tabs.getName()); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples.external; import javax.swing.JFrame; import org.javabuilders.BuildResult; import org.javabuilders.swing.SwingJavaBuilder; @SuppressWarnings(\"serial\") public class CenteredJFrame extends JFrame { @SuppressWarnings(\"unused\") private BuildResult result = SwingJavaBuilder.build(this); }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples.resources; import org.apache.commons.lang.builder.CompareToBuilder; public class Defect implements Comparable { private int id; private String type; private int priority = 0; private String state; private String summary; private String reporter = \"\";  public int getId() { return id; }  public void setId(int id) { this.id = id; }  public String getType() { return type; }  public void setType(String type) { this.type = type; }  public int getPriority() { return priority; }  public void setPriority(int priority) { this.priority = priority; }  public String getState() { return state; }  public void setState(String state) { this.state = state; }  public String getSummary() { return summary; }  public void setSummary(String summary) { this.summary = summary; }  public String getReporter() { return reporter; }  public void setReporter(String reporter) { this.reporter = reporter; } public int compareTo(Object o) { return CompareToBuilder.reflectionCompare(this, o); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples.resources; import java.util.Calendar; public class Person { private String firstName; private String lastName; private Calendar birthDate; public Person() {} public Person(String firstName, String lastName, Calendar birthDate) { super(); this.firstName = firstName; this.lastName = lastName; this.birthDate = birthDate; }  public String getFirstName() { return firstName; }  public void setFirstName(String firstName) { this.firstName = firstName; }  public String getLastName() { return lastName; }  public void setLastName(String lastName) { this.lastName = lastName; }  public Calendar getBirthDate() { return birthDate; }  public void setBirthDate(Calendar birthDate) { this.birthDate = birthDate; } @Override public String toString() { return String.format(\"%s %s\", firstName, lastName); } }"}
{"name": "jacek99/javabuilders", "content": "package org.javabuilders.swing.samples.resources; import javax.swing.JDialog; import org.javabuilders.swing.SwingJavaBuilder;  public class PersonDialog extends JDialog { private Person person; public PersonDialog() { this(new Person()); } public PersonDialog(Person person) { this.person = person; SwingJavaBuilder.build(this); } public Person getPerson() { return person; } private void save() { setVisible(false); } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.samples.delimited; import java.util.Date; import org.coury.jfilehelpers.annotations.DelimitedRecord; import org.coury.jfilehelpers.annotations.FieldConverter; import org.coury.jfilehelpers.enums.ConverterKind; import org.coury.jfilehelpers.helpers.StringHelper; @DelimitedRecord(\",\") public class Customer { private Integer custId; private String name; private Integer rating; @FieldConverter(converter = ConverterKind.Date, format = \"dd-MM-yyyy\") private Date addedDate; @Override public String toString() { String l = System.getProperty(\"line.separator\"); StringBuffer b = new StringBuffer(); b.append(\"Customer: \").append(l); b.append(\" custId = \" + custId).append(l); b.append(\" name = \" + name).append(l); b.append(\" rating = \" + rating).append(l); b.append(\" addedDate = \" + addedDate).append(l); return StringHelper.toStringBuilder(this, b.toString()); } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.samples.delimited.open; import java.util.Date; import org.coury.jfilehelpers.annotations.DelimitedRecord; import org.coury.jfilehelpers.annotations.FieldConverter; import org.coury.jfilehelpers.enums.ConverterKind; import org.coury.jfilehelpers.helpers.StringHelper; @DelimitedRecord(\",\") public class Customer { private Integer custId; private String name; private Integer rating; @FieldConverter(converter = ConverterKind.Date, format = \"dd-MM-yyyy\") private Date addedDate; public String getName() { return name; } @Override public String toString() { String l = System.getProperty(\"line.separator\"); StringBuffer b = new StringBuffer(); b.append(\"Customer: \").append(l); b.append(\" custId = \" + custId).append(l); b.append(\" name = \" + name).append(l); b.append(\" rating = \" + rating).append(l); b.append(\" addedDate = \" + addedDate).append(l); return StringHelper.toStringBuilder(this, b.toString()); } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.samples.fixed; import java.util.Date; import org.coury.jfilehelpers.annotations.FieldAlign; import org.coury.jfilehelpers.annotations.FieldConverter; import org.coury.jfilehelpers.annotations.FieldFixedLength; import org.coury.jfilehelpers.annotations.FieldOptional; import org.coury.jfilehelpers.annotations.FieldTrim; import org.coury.jfilehelpers.annotations.FixedLengthRecord; import org.coury.jfilehelpers.enums.AlignMode; import org.coury.jfilehelpers.enums.ConverterKind; import org.coury.jfilehelpers.enums.TrimMode; import org.coury.jfilehelpers.helpers.StringHelper; @FixedLengthRecord() public class Customer { @FieldFixedLength(4) private Integer custId; @FieldAlign(alignMode=AlignMode.Right) @FieldFixedLength(20) private String name; @FieldFixedLength(3) private Integer rating; @FieldTrim(trimMode=TrimMode.Right) @FieldFixedLength(10) @FieldConverter(converter = ConverterKind.Date, format = \"dd-MM-yyyy\") private Date addedDate; @FieldFixedLength(3) @FieldOptional private String stockSimbol; @Override public String toString() { String l = System.getProperty(\"line.separator\"); StringBuffer b = new StringBuffer(); b.append(\"Customer: \").append(l); b.append(\" custId = \" + custId).append(l); b.append(\" name = \" + name).append(l); b.append(\" rating = \" + rating).append(l); b.append(\" addedDate = \" + addedDate).append(l); b.append(\" stockSimbol = \" + stockSimbol).append(l); return StringHelper.toStringBuilder(this, b.toString()); } public Integer getCustId() { return custId; } public void setCustId(Integer custId) { this.custId = custId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getRating() { return rating; } public void setRating(Integer rating) { this.rating = rating; } public Date getAddedDate() { return addedDate; } public void setAddedDate(Date addedDate) { this.addedDate = addedDate; } public String getStockSimbol() { return stockSimbol; } public void setStockSimbol(String stockSimbol) { this.stockSimbol = stockSimbol; } }"}
{"name": "fcoury/jfilehelpers", "content": "package org.coury.jfilehelpers.samples.fixed.lesschars; import org.coury.jfilehelpers.annotations.FieldFixedLength; import org.coury.jfilehelpers.annotations.FixedLengthRecord; import org.coury.jfilehelpers.enums.FixedMode; import org.coury.jfilehelpers.helpers.StringHelper; @FixedLengthRecord(fixedMode=FixedMode.AllowLessChars) public class Track { @FieldFixedLength(2) public int number; @FieldFixedLength(15) public String performer; @FieldFixedLength(15) public String album; @FieldFixedLength(20) public String music; @FieldFixedLength(10) public String genre; @FieldFixedLength(15) public String label; @FieldFixedLength(4) public int year; @Override public String toString() { String l = System.getProperty(\"line.separator\"); StringBuffer b = new StringBuffer(); b.append(\"Track #\").append(number).append(\"): \").append(l); b.append(\" performer = \").append(performer).append(l); b.append(\" album = \").append(album).append(l); b.append(\" music = \").append(music).append(l); b.append(\" genre = \").append(genre).append(l); b.append(\" label = \").append(label).append(l); b.append(\" year = \").append(year).append(l); return StringHelper.toStringBuilder(this, b.toString()); } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.samples.masterdetail; import java.io.IOException; import java.util.ArrayList; import java.util.List; import org.coury.jfilehelpers.annotations.DelimitedRecord; import org.coury.jfilehelpers.masterdetail.MasterDetailEngine; import org.coury.jfilehelpers.masterdetail.MasterDetailSelector; import org.coury.jfilehelpers.masterdetail.MasterDetails; import org.coury.jfilehelpers.masterdetail.RecordAction; public class MasterDetailsSample { public static void main(String[] args) throws IOException { MasterDetailEngine<Order, Item> engine = new MasterDetailEngine<Order, Item>(Order.class, Item.class, new MasterDetailSelector() { @Override public RecordAction getRecordAction(String recordString) { if (recordString.startsWith(\"-\")) { return RecordAction.Detail; } else { return RecordAction.Master; } } }); String teste = \"1,4039BF,1130.45\" + \"\\n\" + \"-1,teste,12,120.01\" + \"\\n\" + \"2,302512,1320.11\" + \"\\n\" + \"-2,awesome,14,130.01\"; List<MasterDetails<Order, Item>> orders = engine.fromString(teste); for (MasterDetails<Order, Item> md : orders) { Order order = md.getMaster(); System.out.println(\"Order: \" + order.id + \" - \" + order.orderNo); for (Item item : md.getDetails()) { System.out.println(\" - \" + (item.id*-1) + \" - \" + item.description); } } engine.writeFile(\"c:/temp/out.txt\", orders); MasterDetails<Order, Item> masterDetail = new MasterDetails<Order, Item>(); Order sampleOrder = new Order(1, \"1234ORD\", 1032.11); List<Item> items = new ArrayList<Item>(); items.add(new Item(-2, \"Teste 123\", 2, 100.00)); items.add(new Item(-3, \"Teste 456\", 2, 200.00)); masterDetail.setMaster(sampleOrder); masterDetail.addDetails(items); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface DelimitedRecord { String value() default \",\"; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.coury.jfilehelpers.enums.AlignMode; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldAlign { AlignMode alignMode(); char alignChar() default ' '; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.coury.jfilehelpers.enums.ConverterKind; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldConverter { ConverterKind converter(); String format(); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldDelimiter { String value() default \",\"; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldFixedLength { int value(); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldIgnored { }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldNullValue { String value(); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldOptional { }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.coury.jfilehelpers.enums.TrimMode; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface FieldTrim { TrimMode trimMode() default TrimMode.None; char[] trimChars() default ' '; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.coury.jfilehelpers.enums.FixedMode; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface FixedLengthRecord { FixedMode fixedMode() default FixedMode.ExactLength; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface IgnoreCommentedLines { String commentMarker(); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface IgnoreEmptyLines { }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface IgnoreFirst { int lines() default 1; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface IgnoreLast { int lines() default 1; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.converters; import java.lang.reflect.Field; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import org.coury.jfilehelpers.enums.ConverterKind; public class ConvertHelpers { public static ConverterBase getConverter(ConverterKind converterKind, String format) { switch (converterKind) { case Date: return new ConvertHelpers().new DateTimeConverter(format); case Boolean: return new ConvertHelpers().new BooleanConverter(); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.converters;  public abstract class ConverterBase { private static String defaultDateTimeFormat = \"ddMMyyyy\"; public abstract Object stringToField(String from); public String fieldToString(Object from) { if (from == null) { return \"\"; } else { return from.toString(); } } public boolean isCustomNullHandling() { return false; } public static String getDefaultDateTimeFormat() { return defaultDateTimeFormat; } public static void setDefaultDateTimeFormat(String defaultDateTimeFormat) { ConverterBase.defaultDateTimeFormat = defaultDateTimeFormat; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.core; import java.util.Arrays; import org.coury.jfilehelpers.engines.LineInfo; import org.coury.jfilehelpers.helpers.StringHelper; public final class ExtractedInfo { public static final ExtractedInfo Empty = new ExtractedInfo(\"\"); private LineInfo line; private int extractedFrom; private int extractedTo; private String customExtractedString = null; public ExtractedInfo(LineInfo line) { this.line = line; this.extractedFrom = line.getCurrentPos(); this.extractedTo = line.getLine().length - 1; } public ExtractedInfo(LineInfo line, int extractTo) { this.line = line; this.extractedFrom = line.getCurrentPos(); this.extractedTo = extractTo - 1; } public ExtractedInfo(String customExtract) { customExtractedString = customExtract; } public void trimStart(char[] sortedToTrim) { if (customExtractedString != null) "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.core; import java.io.BufferedReader; import java.io.IOException; import org.coury.jfilehelpers.helpers.StringHelper; public class ForwardReader { private BufferedReader reader; private int forwardIndex = 0; private int forwardLines = 0; "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.core; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.security.AccessController; import java.security.PrivilegedAction; import java.util.ArrayList; import java.util.List; import java.util.regex.Pattern; import org.coury.jfilehelpers.annotations.FixedLengthRecord; import org.coury.jfilehelpers.annotations.IgnoreCommentedLines; import org.coury.jfilehelpers.annotations.IgnoreEmptyLines; import org.coury.jfilehelpers.annotations.IgnoreFirst; import org.coury.jfilehelpers.annotations.IgnoreLast; import org.coury.jfilehelpers.engines.LineInfo; import org.coury.jfilehelpers.enums.RecordCondition; import org.coury.jfilehelpers.fields.FieldBase; import org.coury.jfilehelpers.fields.FieldFactory; import org.coury.jfilehelpers.fields.FixedLengthField; import org.coury.jfilehelpers.helpers.ConditionHelper; import org.coury.jfilehelpers.helpers.StringHelper; import org.coury.jfilehelpers.interfaces.NotifyRead; import org.coury.jfilehelpers.interfaces.NotifyWrite;  public final class RecordInfo<T> { private FieldBase[] fields; private final Class<T> recordClass; private Constructor<T> recordConstructor; private int ignoreFirst = 0; private int ignoreLast = 0; private boolean ignoreEmptyLines = false; private boolean ignoreEmptySpaces = false; private String commentMarker = null; private boolean commentAnyPlace = true; private RecordCondition recordCondition = RecordCondition.None; private String recordConditionSelector = \"\"; private boolean notifyRead = false; private boolean notifyWrite = false; private String conditionRegEx = null; private int sizeHint = 32; "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.engines; public class Encoding { "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.engines; import org.coury.jfilehelpers.core.RecordInfo; import org.coury.jfilehelpers.enums.ProgressMode; import org.coury.jfilehelpers.progress.ProgressChangeHandler; public abstract class EngineBase<T> { protected RecordInfo<T> recordInfo; protected Class<T> recordClass; protected Encoding encoding; protected String footerText; protected String headerText; protected int lineNumber; protected int totalRecords; public EngineBase(Class<T> recordClass) { this.recordClass = recordClass; this.recordInfo = new RecordInfo<T>(recordClass); } protected ProgressMode progressMode = ProgressMode.DontNotify; "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.engines; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringWriter; import java.io.Writer; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; import org.coury.jfilehelpers.core.ForwardReader; import org.coury.jfilehelpers.events.AfterReadRecordEventArgs; import org.coury.jfilehelpers.events.AfterReadRecordHandler; import org.coury.jfilehelpers.events.AfterWriteRecordEventArgs; import org.coury.jfilehelpers.events.AfterWriteRecordHandler; import org.coury.jfilehelpers.events.BeforeReadRecordEventArgs; import org.coury.jfilehelpers.events.BeforeReadRecordHandler; import org.coury.jfilehelpers.events.BeforeWriteRecordEventArgs; import org.coury.jfilehelpers.events.BeforeWriteRecordHandler; import org.coury.jfilehelpers.helpers.ProgressHelper; import org.coury.jfilehelpers.helpers.StringHelper; import org.coury.jfilehelpers.interfaces.NotifyRead; import org.coury.jfilehelpers.interfaces.NotifyWrite; public class FileHelperEngine<T> extends EngineBase<T> implements Iterable<T> { private int maxRecords = 0; private int currentRecord = 0; private LineInfo line; private String currentLine; private String completeLine; private FileReader fr = null; private ForwardReader freader = null; private BeforeReadRecordHandler<T> beforeReadRecordHandler; private AfterReadRecordHandler<T> afterReadRecordHandler; private BeforeWriteRecordHandler<T> beforeWriteRecordHandler; private AfterWriteRecordHandler<T> afterWriteRecordHandler; public FileHelperEngine(Class<T> recordClass) { super(recordClass); } public List<T> readFile(String fileName) throws IOException { return readFile(fileName, Integer.MAX_VALUE); } public void writeFile(String fileName, List<T> records) throws IOException { writeFile(fileName, records, -1); } public void writeFile(String fileName, List<T> records, int maxRecords) throws IOException { FileWriter fw = null; try { fw = new FileWriter(new File(fileName)); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.engines; public final class FileTransformEngine<Source, Destination> { private Encoding destinationEncoding; private Destination destination; private Encoding sourceEncoding; private Source source; public FileTransformEngine(Source source, Destination destination) { this.source = source; this.destination = destination; } public Destination[] transformFile(String sourceFile, String destinationFile) { "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.engines; import java.io.IOException; import java.util.Arrays; import org.coury.jfilehelpers.core.ForwardReader; import org.coury.jfilehelpers.helpers.StringHelper; public final class LineInfo { private static char[] emptyChars = new char[] {}; private String lineStr; private char[] line; private int currentPos = 0; private int lineNumber; private ForwardReader reader; public String toString() { StringBuffer sb = new StringBuffer(); sb.append(\"currentLine = [\").append(this.getLineStr()).append(\"]\").append(StringHelper.NEW_LINE); sb.append(\" -> currentString = [\").append(this.getCurrentString()).append(\"]\").append(StringHelper.NEW_LINE); sb.append(\" -> currentLength = \").append(this.getCurrentLength()).append(StringHelper.NEW_LINE); sb.append(\" -> isEol = \").append(this.isEol()).append(StringHelper.NEW_LINE); sb.append(\" -> isEmptyFromPos = \").append(this.isEmptyFromPos()).append(StringHelper.NEW_LINE); return sb.toString(); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum AlignMode { Left, Center, Right }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum ConverterKind { None, Date, Boolean, Byte, Int, Float, Double; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum FixedMode { ExactLength, AllowMoreChars, AllowLessChars, AllowVariableLength }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum MultilineMode { AllowForBoth, AllowForRead, AllowForWrite, NotAllow; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum ProgressMode { NotifyPercent, NotifyRecords, NotifyBytes, DontNotify; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum QuoteMode { AlwaysQuoted, OptionalForRead, OptionalForWrite, OptionalForBoth }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum RecordCondition { None, IncludeIfContains, IncludeIfBegins, IncludeIfEnds, IncludeIfEnclosed, IncludeIfMatchRegex, ExcludeIfContains, ExcludeIfBegins, ExcludeIfEnds, ExcludeIfEnclosed, ExcludeIfMatchRegex; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.enums; public enum TrimMode { None, Both, Left, Right; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events;  public class AfterReadRecordEventArgs<T> extends ReadRecordEventArgs { private T record; private boolean skipThisRecord = false; public AfterReadRecordEventArgs(String recordLine, T newRecord, int lineNumber) { super(recordLine, lineNumber); record = newRecord; } public AfterReadRecordEventArgs(String recordLine, T newRecord) { super(recordLine, -1); record = newRecord; } public T getRecord() { return record; } public void setRecord(T record) { this.record = record; } public boolean getSkipThisRecord() { return skipThisRecord; } public void setSkipThisRecord(boolean skipThisRecord) { this.skipThisRecord = skipThisRecord; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events; import org.coury.jfilehelpers.engines.EngineBase;  public interface AfterReadRecordHandler<T> { public void handleAfterReadRecord(EngineBase<T> engine, AfterReadRecordEventArgs<T> e); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events;  public class AfterWriteRecordEventArgs<T> extends WriteRecordEventArgs<T> { private String recordLine; public AfterWriteRecordEventArgs(T record, int lineNumber, String recordLine) { super(record, lineNumber); this.recordLine = recordLine; } public String getRecordLine() { return recordLine; } public void setRecordLine(String recordLine) { this.recordLine = recordLine; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events; import org.coury.jfilehelpers.engines.EngineBase;  public interface AfterWriteRecordHandler<T> {  public void handleAfterWriteRecord(EngineBase<T> engine, AfterWriteRecordEventArgs<T> e); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events;  public class BeforeReadRecordEventArgs<T> extends ReadRecordEventArgs { private boolean skipThisRecord = false; public BeforeReadRecordEventArgs(String recordLine, int lineNumber) { super(recordLine, lineNumber); } public BeforeReadRecordEventArgs(String recordLine) { super(recordLine, -1); } public boolean getSkipThisRecord() { return skipThisRecord; } public void setSkipThisRecord(boolean skipThisRecord) { this.skipThisRecord = skipThisRecord; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events; import org.coury.jfilehelpers.engines.EngineBase;  public interface BeforeReadRecordHandler<T> { public void handleBeforeReadRecord(EngineBase<T> engine, BeforeReadRecordEventArgs<T> e); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events;  public class BeforeWriteRecordEventArgs<T> extends WriteRecordEventArgs<T> { private boolean skipThisRecord = false; public BeforeWriteRecordEventArgs(T record, int lineNumber) { super(record, lineNumber); } public boolean getSkipThisRecord() { return skipThisRecord; } public void setSkipThisRecord(boolean skipThisRecord) { this.skipThisRecord = skipThisRecord; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events; import org.coury.jfilehelpers.engines.EngineBase;  public interface BeforeWriteRecordHandler<T> { public void handleBeforeWriteRecord(EngineBase<T> engine, BeforeWriteRecordEventArgs<T> e); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events;  public abstract class ReadRecordEventArgs { private int lineNumber; private String recordLine; boolean recordLineChanged = false; public ReadRecordEventArgs(String recordLine, int lineNumber) { this.recordLine = recordLine; this.lineNumber = lineNumber; } public int getLineNumber() { return lineNumber; } public void setLineNumber(int lineNumber) { this.lineNumber = lineNumber; } public String getRecordLine() { return recordLine; } public void setRecordLine(String recordLine) { this.recordLine = recordLine; recordLineChanged = true; } public boolean getRecordLineChanged() { return recordLineChanged; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.events; public abstract class WriteRecordEventArgs<T> { private int lineNumber; private T record; public WriteRecordEventArgs(T record, int lineNumber) { this.lineNumber = lineNumber; this.record = record; } public int getLineNumber() { return lineNumber; } public void setLineNumber(int lineNumber) { this.lineNumber = lineNumber; } public T getRecord() { return record; } public void setRecord(T record) { this.record = record; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.fields; import java.io.IOException; import java.lang.reflect.Field; import org.coury.jfilehelpers.core.ExtractedInfo; import org.coury.jfilehelpers.engines.LineInfo; import org.coury.jfilehelpers.enums.MultilineMode; import org.coury.jfilehelpers.enums.QuoteMode; import org.coury.jfilehelpers.enums.TrimMode; import org.coury.jfilehelpers.helpers.StringHelper; public class DelimitedField extends FieldBase { private String separator; private char quoteChar = '\\0'; private QuoteMode quoteMode; private MultilineMode quoteMultiline = MultilineMode.AllowForBoth; public DelimitedField(Field fi, String sep) { super(fi); this.separator = sep; } @Override protected ExtractedInfo extractFieldString(LineInfo line) { if (isOptional() && line.isEol()) { return ExtractedInfo.Empty; } if (isLast()) { charsToDiscard = 0; } else { charsToDiscard = separator.length(); } if (quoteChar == '\\0') { return basicExtractString(line); } else { "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.fields; import java.lang.reflect.Field; import org.coury.jfilehelpers.annotations.FieldAlign; import org.coury.jfilehelpers.enums.AlignMode; public class FieldAlignBean { private AlignMode mode = AlignMode.Left; private char alignChar = ' '; private FieldAlignBean() { } public static FieldAlignBean createFromAnnotation(FieldAlign ann, Field fi) { FieldAlignBean fab = new FieldAlignBean(); if (ann != null) { fab.mode = ann.alignMode(); fab.alignChar = ann.alignChar(); } else { if (fi.getType() == Integer.class || fi.getType() == Float.class || fi.getType() == Double.class) { fab.mode = AlignMode.Right; } } return fab; } public AlignMode getAlign() { return mode; } public char getChar() { return alignChar; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.fields; import java.io.IOException; import java.lang.reflect.Field; import org.coury.jfilehelpers.annotations.FieldConverter; import org.coury.jfilehelpers.annotations.FieldNullValue; import org.coury.jfilehelpers.converters.ConvertHelpers; import org.coury.jfilehelpers.converters.ConverterBase; import org.coury.jfilehelpers.core.ExtractedInfo; import org.coury.jfilehelpers.engines.LineInfo; import org.coury.jfilehelpers.enums.TrimMode; import org.coury.jfilehelpers.helpers.StringHelper; public abstract class FieldBase { private boolean stringField; private Field fieldInfo; private TrimMode trimMode = TrimMode.None; private char[] trimChars = null; private boolean isOptional = false; private boolean nextOptional = false; private boolean inNewLine = false; private boolean first = false; private boolean last = false; private boolean trailingArray = false; private Object nullValue = null; private boolean nullableType = false; protected int charsToDiscard = 0; private ConverterBase convertProvider; public FieldBase(Field field) { fieldInfo = field; stringField = (field.getType().equals(String.class)); FieldConverter fc = field.getAnnotation(FieldConverter.class); if (fc == null) { convertProvider = ConvertHelpers.getDefaultConverter(field); } else { convertProvider = ConvertHelpers.getConverter(fc.converter(), fc.format()); } FieldNullValue fn = field.getAnnotation(FieldNullValue.class); if (fn != null) { nullValue = fn.value(); } } public Object extractValue(LineInfo line) throws IOException { if (this.inNewLine) { if (!line.isEmptyFromPos()) { "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.fields; import java.lang.reflect.Field; import org.coury.jfilehelpers.annotations.DelimitedRecord; import org.coury.jfilehelpers.annotations.FieldAlign; import org.coury.jfilehelpers.annotations.FieldDelimiter; import org.coury.jfilehelpers.annotations.FieldFixedLength; import org.coury.jfilehelpers.annotations.FieldIgnored; import org.coury.jfilehelpers.annotations.FieldOptional; import org.coury.jfilehelpers.annotations.FieldTrim; import org.coury.jfilehelpers.annotations.FixedLengthRecord; public class FieldFactory {  @SuppressWarnings(\"unchecked\") public static FieldBase createField(Field fi, Class recordClass, boolean someOptional) { if (fi.isAnnotationPresent(FieldIgnored.class)) { return null; } FieldBase res = null; /* "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.fields; import java.lang.reflect.Field; import org.coury.jfilehelpers.core.ExtractedInfo; import org.coury.jfilehelpers.engines.LineInfo; import org.coury.jfilehelpers.enums.AlignMode; import org.coury.jfilehelpers.enums.FixedMode; import org.coury.jfilehelpers.helpers.StringHelper; public class FixedLengthField extends FieldBase { private final int fieldLength; private final FieldAlignBean align; private final FixedMode fixedMode; public FixedLengthField(Field fi, int length, FieldAlignBean align, FixedMode fixedMode) { super(fi); this.fieldLength = length; this.align = align; this.fixedMode = fixedMode; } @Override protected ExtractedInfo extractFieldString(LineInfo line) { if (line.getCurrentLength() == 0) { if (isOptional()) return ExtractedInfo.Empty; else throw new IllegalArgumentException( \"End Of Line found processing the field: \" + getFieldInfo().getName() + \" at line \" + line.getLineNumber() + \". \" + \"(You need to mark it as @FieldOptional if you want to avoid this exception)\"); } ExtractedInfo res; if (line.getCurrentLength() < this.fieldLength) { if (fixedMode == FixedMode.AllowLessChars || fixedMode == FixedMode.AllowVariableLength) { res = new ExtractedInfo(line); } else { throw new IllegalArgumentException( \"The string '\" + line.getCurrentString() + \"' (length \" + line.getCurrentLength() + \") at line \" + line.getLineNumber() + \" has less chars than the defined for \" + getFieldInfo().getName() + \" (\" + fieldLength + \"). \" + \"You can use the @FixedLengthRecord(fixedMode=FixedMode.AllowLessChars) to avoid this problem.\"); } } else if (isLast() && line.getCurrentLength() > fieldLength && fixedMode != FixedMode.AllowMoreChars && fixedMode != FixedMode.AllowVariableLength) { throw new IllegalArgumentException( \"The string '\" + line.getCurrentString() + \"' (length \" + line.getCurrentLength() + \") at line \" + line.getLineNumber() + \" has more chars than the defined for the last field \" + getFieldInfo().getName() + \" (\" + fieldLength + \"). \" + \"You can use the @FixedLengthRecord(fixedMode=FixedMode.AllowMoreChars) to avoid this problem.\"); } else { res = new ExtractedInfo(line, line.getCurrentPos() + fieldLength); } return res; } @Override protected void createFieldString(StringBuffer sb, Object fieldValue) { String field = super.baseFieldString(fieldValue); field = StringHelper.trimBoth(field, StringHelper.WHITESPACE_CHARS); if (field.length() > fieldLength) { field = field.substring(0, fieldLength); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.helpers; public class ConditionHelper { public static boolean beginsWith(String line, String s) { return line.startsWith(s); } public static boolean endsWith(String line, String s) { return line.endsWith(s); } public static boolean contains(String line, String s) { return line.indexOf(s) >= 0; } public static boolean enclosed(String line, String s) { return line.startsWith(s) && line.endsWith(s); } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.helpers; import org.coury.jfilehelpers.enums.ProgressMode; import org.coury.jfilehelpers.progress.ProgressChangeHandler; import org.coury.jfilehelpers.progress.ProgressEventArgs;  public class ProgressHelper { public static void notify(ProgressChangeHandler handler, ProgressMode mode, int current, int total) { if (handler == null) return; if (mode == ProgressMode.DontNotify) return; switch (mode) { case NotifyBytes: handler.handleProgressChange(new ProgressEventArgs(mode, current, total)); break; case NotifyRecords: handler.handleProgressChange(new ProgressEventArgs(mode, current, total)); break; case NotifyPercent: if (total == -1) return; handler.handleProgressChange(new ProgressEventArgs(mode, (int) (current * 100 / total), 100)); break; } } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.helpers; import java.io.IOException; import org.apache.commons.lang.builder.ToStringStyle; import org.coury.jfilehelpers.core.ExtractedInfo; import org.coury.jfilehelpers.engines.LineInfo; public class StringHelper { public static void main(String[] args) { String test1 = \"abcdeCAmanducaia\"; System.out.println(StringHelper.trimStart(test1, \"abcdefghijklmnopqrstuvwxyz\".toCharArray())); System.out.println(StringHelper.trimEnd(test1, \"abcdefghijklmnopqrstuvwxyz\".toCharArray())); System.out.println(StringHelper.trimBoth(test1, \"abcdefghijklmnopqrstuvwxyz\".toCharArray())); } public static String toStringBuilder(Object o) { return toStringBuilder(o, o.toString()); } public static String toStringBuilder(Object o, String defaultString) { try { return getToString(o); } catch (ClassNotFoundException e) { return defaultString; } } private static String getToString(Object o) throws ClassNotFoundException { Class.forName(\"org.apache.commons.lang.builder.ToStringBuilder\"); return org.apache.commons.lang.builder.ToStringBuilder.reflectionToString(o, ToStringStyle.MULTI_LINE_STYLE); } public static void createQuotedString(StringBuffer sb, String source, char quoteChar) { if (source == null) source = \"\"; String quotedCharStr = Character.toString(quoteChar); String escapedString = source.replace(quotedCharStr, quotedCharStr + quotedCharStr); sb.append(quoteChar); sb.append(escapedString); sb.append(quoteChar); } public static ExtractedInfo extractQuotedString(LineInfo line, char quoteChar, boolean allowMultiline) throws IOException { if (line.isEol()) { throw new IllegalArgumentException( \"An empty String found and can be parsed like \" + \"a QuotedString try to use SafeExtractQuotedString\"); } if (line.getLine()[line.getCurrentPos()] != quoteChar) { throw new IllegalArgumentException( \"The source string not begins with the quote char: \" + quoteChar); } StringBuilder res = new StringBuilder(32); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.interfaces; public interface ComparableRecord<T> { boolean equalsRecord(T record); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.interfaces; import org.coury.jfilehelpers.engines.EngineBase;  public interface NotifyRead<T> { public void afterRead(EngineBase<T> engine, String line); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.interfaces; import org.coury.jfilehelpers.engines.EngineBase;  public interface NotifyWrite<T> { public void beforeWrite(EngineBase<T> engine); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.masterdetail; public enum CommonSelector { MasterIfContains, MasterIfBegins, MasterIfEnds, MasterIfEnclosed, DetailIfContains, DetailIfBegins, DetailIfEnds, DetailIfEnclosed }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.masterdetail; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.ArrayList; import java.util.List; import org.coury.jfilehelpers.core.ForwardReader; import org.coury.jfilehelpers.core.RecordInfo; import org.coury.jfilehelpers.engines.EngineBase; import org.coury.jfilehelpers.engines.LineInfo; import org.coury.jfilehelpers.helpers.ProgressHelper; import org.coury.jfilehelpers.helpers.StringHelper;  public class MasterDetailEngine<MT, DT> extends EngineBase<DT> { @SuppressWarnings(\"unused\") private Class<MT> masterRecordClass; private final RecordInfo<MT> masterInfo; private final MasterDetailSelector recordSelector; public MasterDetailEngine(Class<MT> masterRecordClass, Class<DT> detailRecordClass, MasterDetailSelector recordSelector) { super(detailRecordClass); this.masterRecordClass = masterRecordClass; this.masterInfo = new RecordInfo<MT>(masterRecordClass); this.recordSelector = recordSelector; } public MasterDetailEngine(Class<MT> masterRecordClass, Class<DT> detailRecordClass, CommonSelector action, String selector) { super(detailRecordClass); this.masterInfo = new RecordInfo<MT>(masterRecordClass); final CommonInternalSelector sel = new CommonInternalSelector(action, selector, masterInfo.isIgnoreEmptyLines() || recordInfo.isIgnoreEmptyLines()); this.recordSelector = new MasterDetailSelector() { @Override public RecordAction getRecordAction(String recordString) { return sel.getCommonSelectorMethod(recordString); } }; } public List<MasterDetails<MT, DT>> readResource(String fileName) throws IOException { List<MasterDetails<MT, DT>> tempRes = null; InputStreamReader fr = null; try { fr = new InputStreamReader(getClass().getResourceAsStream(fileName)); tempRes = readStream(fr); } finally { if (fr != null) { fr.close(); } } return tempRes; } public List<MasterDetails<MT, DT>> fromString(String s) throws IOException { return readStream(new InputStreamReader(new ByteArrayInputStream(s.getBytes()))); } public List<MasterDetails<MT, DT>> readFile(String fileName) throws IOException { List<MasterDetails<MT, DT>> tempRes = null; FileReader fr = null; try { fr = new FileReader(new File(fileName)); tempRes = readStream(fr); } finally { if (fr != null) { fr.close(); } } return tempRes; } public void writeFile(String fileName, MasterDetails<MT, DT> record) throws IOException { List<MasterDetails<MT, DT>> list = new ArrayList<MasterDetails<MT, DT>>(); list.add(record); writeFile(fileName, list); } public void writeFile(String fileName, List<MasterDetails<MT, DT>> records) throws IOException { writeFile(fileName, records, -1); } public void writeFile(String fileName, List<MasterDetails<MT, DT>> records, int maxRecords) throws IOException { FileWriter fw = null; try { fw = new FileWriter(new File(fileName)); "}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.masterdetail; public interface MasterDetailSelector { public RecordAction getRecordAction(String recordString); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.masterdetail; import java.util.ArrayList; import java.util.List; public class MasterDetails<MT, DT> { private List<DT> details; private MT master; public MasterDetails() { details = new ArrayList<DT>(); } public MasterDetails(MT master, List<DT> details) { this.master = master; this.details = details; } public List<DT> getDetails() { return details; } public void addDetails(List<DT> details) { if (this.details == null) { this.details = new ArrayList<DT>(); } this.details.addAll(details); } public void setDetails(List<DT> details) { this.details = details; } public MT getMaster() { return master; } public void setMaster(MT master) { this.master = master; } }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.masterdetail; public enum RecordAction { Skip, Master, Detail; }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.progress;  public interface ProgressChangeHandler { public void handleProgressChange(ProgressEventArgs e); }"}
{"name": "fcoury/jfilehelpers", "content": " package org.coury.jfilehelpers.progress; import org.coury.jfilehelpers.enums.ProgressMode;  public class ProgressEventArgs { private int progressCurrent; private int progressTotal; private ProgressMode progressMode = ProgressMode.DontNotify; public ProgressEventArgs(ProgressMode mode, int current, int total) { progressMode = mode; progressCurrent = current; progressTotal = total; } public ProgressEventArgs() { progressMode = ProgressMode.DontNotify; } public int getProgressCurrent() { return progressCurrent; } public int getProgressTotal() { return progressTotal; } public ProgressMode getProgressMode() { return progressMode; } }"}
{"name": "dtrott/fuse4j", "content": " package java2c; import fuse.FuseContext; import fuse.FuseFS; import fuse.FuseFSDirEnt; import fuse.FuseFSDirFiller; import fuse.FuseFSFactory; import fuse.FuseGetattr; import fuse.FuseOpen; import fuse.FuseSize; import fuse.FuseStatfs; import fuse.PasswordEntry; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Map; @SuppressWarnings(\"unchecked\") public class CAPIGenerator { private Class clazz; public CAPIGenerator(Class clazz) { this.clazz = clazz; } public void generateClassAPI(Map<String, String> overload, PrintWriter hOut, PrintWriter cOut, boolean extraArgForInterfaces, boolean includeStaticFields) { String className = clazz.getName(); String jniClassName = className.replace('.', '/'); String structTypeName = \"jclass_\" + className.replace('.', '_'); String structVarName = className.replace('.', '_'); "}
{"name": "dtrott/fuse4j", "content": "package java2c; import java.util.Comparator; import java.lang.reflect.Constructor; public class ConstructorComparator implements Comparator<Constructor> { private final CAPIGenerator capiGenerator; ConstructorComparator(CAPIGenerator capiGenerator) { this.capiGenerator = capiGenerator; } public int compare(Constructor constructor1, Constructor constructor2) { if (constructor1 == null && constructor2 == null) { return 0; } if (constructor1 == null) { return -1; } if (constructor2 == null) { return 1; } String sig1 = capiGenerator.getMethodName(\"new\", constructor1.getParameterTypes()); String sig2 = capiGenerator.getMethodName(\"new\", constructor2.getParameterTypes()); return sig1.compareTo(sig2); } }"}
{"name": "dtrott/fuse4j", "content": "package java2c; import java.io.PrintStream; import java.io.FileOutputStream; import java.io.FileNotFoundException; import java.io.IOException;  public class DumpJVMLdPath { public static void main(String[] args) throws IOException { String[] libDirs = System.getProperty(\"java.library.path\", \"\").split(\":\"); StringBuffer sb = new StringBuffer(\"LDPATH :=\"); for (int i = 0; i < libDirs.length; i++) sb.append(\" -L\").append(libDirs[i]); if (args.length == 0) System.out.println(sb.toString()); else { PrintStream out = new PrintStream(new FileOutputStream(args[0])); out.println(sb.toString()); out.close(); } } }"}
{"name": "dtrott/fuse4j", "content": "package java2c; import java.util.Comparator; import java.lang.reflect.Field; public class FieldComparator implements Comparator<Field> { public int compare(Field field1, Field field2) { if (field1 == null && field2 == null) { return 0; } if (field1 == null) { return -1; } if (field2 == null) { return 1; } return field1.getName().compareTo(field2.getName()); } }"}
{"name": "dtrott/fuse4j", "content": "package java2c; import java.util.Comparator; import java.lang.reflect.Method; public class MethodComparator implements Comparator<Method> { private final CAPIGenerator capiGenerator; MethodComparator(CAPIGenerator capiGenerator) { this.capiGenerator = capiGenerator; } public int compare(Method method1, Method method2) { if (method1 == null && method2 == null) { return 0; } if (method1 == null) { return -1; } if (method2 == null) { return 1; } String sig1 = capiGenerator.getMethodName(method1.getName(), method1.getParameterTypes()); String sig2 = capiGenerator.getMethodName(method2.getName(), method2.getParameterTypes()); return sig1.compareTo(sig2); } }"}
{"name": "dtrott/fuse4j", "content": " package fuse;  public interface Errno { "}
{"name": "dtrott/fuse4j", "content": " package fuse; import java.nio.ByteBuffer; import java.nio.CharBuffer;  public interface Filesystem3 extends FilesystemConstants { public int getattr(String path, FuseGetattrSetter getattrSetter) throws FuseException; public int readlink(String path, CharBuffer link) throws FuseException; public int getdir(String path, FuseDirFiller dirFiller) throws FuseException; public int mknod(String path, int mode, int rdev) throws FuseException; public int mkdir(String path, int mode) throws FuseException; public int unlink(String path) throws FuseException; public int rmdir(String path) throws FuseException; public int symlink(String from, String to) throws FuseException; public int rename(String from, String to) throws FuseException; public int link(String from, String to) throws FuseException; public int chmod(String path, int mode) throws FuseException; public int chown(String path, int uid, int gid) throws FuseException; public int truncate(String path, long size) throws FuseException; public int utime(String path, int atime, int mtime) throws FuseException; public int statfs(FuseStatfsSetter statfsSetter) throws FuseException; "}
{"name": "dtrott/fuse4j", "content": " package fuse; import org.apache.commons.logging.Log; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.BufferOverflowException; import java.nio.charset.*; import java.util.Date;  public class Filesystem3ToFuseFSAdapter implements FuseFS { private Filesystem3 fs3; private XattrSupport xattrSupport; private LifecycleSupport lifecycleSupport; private Charset cs; private Log log; public Filesystem3ToFuseFSAdapter(Filesystem3 fs3, Log log) { this(fs3, System.getProperty(\"file.encoding\", \"UTF-8\"), log); } public Filesystem3ToFuseFSAdapter(Filesystem3 fs3, String encoding, Log log) { this(fs3, Charset.forName(encoding), log); } public Filesystem3ToFuseFSAdapter(Filesystem3 fs3, Charset cs, Log log) { this.fs3 = fs3; "}
{"name": "dtrott/fuse4j", "content": " package fuse;  public interface FilesystemConstants { public static final int O_RDONLY = 00; public static final int O_WRONLY = 01; public static final int O_RDWR = 02; }"}
{"name": "dtrott/fuse4j", "content": "package fuse; import fuse.util.Struct;  public class FuseContext extends Struct { public int uid; public int gid; public int pid; private FuseContext() { } public static FuseContext get() { FuseContext fuseContext = new FuseContext(); fuseContext.fillInFuseContext(); return fuseContext; } protected boolean appendAttributes(StringBuilder buff, boolean isPrefixed) { buff.append(super.appendAttributes(buff, isPrefixed)? \", \" : \" \"); buff.append(\"uid=\").append(uid) .append(\", gid=\").append(gid) .append(\", pid=\").append(pid); return true; } private native void fillInFuseContext(); }"}
{"name": "dtrott/fuse4j", "content": "package fuse;  public interface FuseDirFiller { public void add(String name, long inode, int mode); }"}
{"name": "dtrott/fuse4j", "content": " package fuse; public class FuseException extends Exception implements Errno { private static final long serialVersionUID = 0; private int errno; public FuseException() { } public FuseException(Throwable cause) { super(cause); } public FuseException(String message) { super(message); } public FuseException(String message, Throwable cause) { super(message, cause); } public FuseException initErrno(int errno) { this.errno = errno; return this; } public int getErrno() { return errno; } }"}
{"name": "dtrott/fuse4j", "content": " package fuse; import java.nio.ByteBuffer;  public interface FuseFS extends FilesystemConstants { public int getattr(ByteBuffer path, FuseGetattrSetter getattrSetter); public int readlink(ByteBuffer path, ByteBuffer link); public int getdir(ByteBuffer path, FuseFSDirFiller dirFiller); public int mknod(ByteBuffer path, int mode, int rdev); public int mkdir(ByteBuffer path, int mode); public int unlink(ByteBuffer path); public int rmdir(ByteBuffer path); public int symlink(ByteBuffer from, ByteBuffer to); public int rename(ByteBuffer from, ByteBuffer to); public int link(ByteBuffer from, ByteBuffer to); public int chmod(ByteBuffer path, int mode); public int chown(ByteBuffer path, int uid, int gid); public int truncate(ByteBuffer path, long size); public int utime(ByteBuffer path, int atime, int mtime); public int statfs(FuseStatfsSetter statfsSetter); public int open(ByteBuffer path, int flags, FuseOpenSetter openSetter); public int read(ByteBuffer path, Object fh, ByteBuffer buf, long offset); public int write(ByteBuffer path, Object fh, boolean isWritepage, ByteBuffer buf, long offset); public int flush(ByteBuffer path, Object fh); public int release(ByteBuffer path, Object fh, int flags); public int fsync(ByteBuffer path, Object fh, boolean isDatasync); "}
{"name": "dtrott/fuse4j", "content": " package fuse;  public class FuseFSDirEnt extends FuseFtype { public byte[] name; public long inode; protected boolean appendAttributes(StringBuilder buff, boolean isPrefixed) { buff.append(isPrefixed? \", \" : \" \").append(\"name='\").append(name).append(\"'\").append(\"inode='\").append(inode).append(\"'\"); return super.appendAttributes(buff, true); } }"}
{"name": "dtrott/fuse4j", "content": "package fuse; import java.util.List; import java.util.ArrayList; import java.nio.charset.Charset; import java.nio.CharBuffer; import java.nio.ByteBuffer;  public class FuseFSDirFiller extends ArrayList<FuseFSDirEnt> implements FuseDirFiller { private Charset cs; public void setCharset(Charset cs) { this.cs = cs; } "}
{"name": "dtrott/fuse4j", "content": "package fuse; import fuse.compat.Filesystem1; import fuse.compat.Filesystem1ToFilesystem2Adapter; import fuse.compat.Filesystem2; import fuse.compat.Filesystem2ToFilesystem3Adapter; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory;  public class FuseFSFactory {  public static FuseFS adapt(Filesystem1 filesystem1, Log log) { return adapt(new Filesystem1ToFilesystem2Adapter(filesystem1), log); }  public static FuseFS adapt(Filesystem2 filesystem2, Log log) { return adapt(new Filesystem2ToFilesystem3Adapter(filesystem2), log); }  public static FuseFS adapt(Filesystem3 filesystem3, Log log) { return new Filesystem3ToFuseFSAdapter(filesystem3, log); }  public static FuseFS adapt(Object filesystem) { Log log = LogFactory.getLog(filesystem.getClass()); return adapt(filesystem, log); }  public static FuseFS adapt(Object filesystem, Log log) { if (filesystem instanceof Filesystem3) { return adapt((Filesystem3) filesystem, log); } if (filesystem instanceof Filesystem2) { return adapt((Filesystem2) filesystem, log); } if (filesystem instanceof Filesystem1) { return adapt((Filesystem1) filesystem, log); } return null; } }"}
{"name": "dtrott/fuse4j", "content": "package fuse; import fuse.util.Struct; import java.nio.ByteBuffer; import java.nio.charset.Charset;  public class FuseFSFillDir extends Struct implements FuseFillDir { private Charset cs; "}
{"name": "dtrott/fuse4j", "content": "package fuse;  public interface FuseFillDir {  public boolean fill(String name, long inode, int mode, long nextOffset); }"}
{"name": "dtrott/fuse4j", "content": " package fuse; import fuse.util.Struct; public class FuseFtype extends Struct implements FuseFtypeConstants { public int mode; protected boolean appendAttributes(StringBuilder buff, boolean isPrefixed) { buff.append(super.appendAttributes(buff, isPrefixed)? \", \" : \" \").append(\"mode=\").append(Integer.toOctalString(mode)).append(\"(OCT)\"); return true; } }"}
{"name": "dtrott/fuse4j", "content": "package fuse;  @SuppressWarnings({\"OctalInteger\"}) public interface FuseFtypeConstants { "}
{"name": "dtrott/fuse4j", "content": " package fuse; import fuse.FuseFtype; import fuse.FuseGetattrSetter; public class FuseGetattr extends FuseFtype implements FuseGetattrSetter, FuseStatConstants { public long inode; "}
{"name": "dtrott/fuse4j", "content": "package fuse;  public interface FuseGetattrSetter { public void set(long inode, int mode, int nlink, int uid, int gid, int rdev, long size, long blocks, int atime, int mtime, int ctime); }"}
{"name": "dtrott/fuse4j", "content": " package fuse; import fuse.compat.Filesystem1; import fuse.compat.Filesystem1ToFilesystem2Adapter; import fuse.compat.Filesystem2; import fuse.compat.Filesystem2ToFilesystem3Adapter; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class FuseMount { private static final Log log = LogFactory.getLog(FuseMount.class); static { System.loadLibrary(\"javafs\"); } private FuseMount() { "}
{"name": "dtrott/fuse4j", "content": " package fuse; import fuse.util.Struct;  public class FuseOpen extends Struct implements FuseOpenSetter { public Object fh; public boolean directIO; public boolean keepCache;  public void setFh(Object fh) { this.fh = fh; }  public boolean isDirectIO() { return directIO; } public void setDirectIO(boolean directIO) { this.directIO = directIO; }  public boolean isKeepCache() { return keepCache; } public void setKeepCache(boolean keepCache) { this.keepCache = keepCache; } protected boolean appendAttributes(StringBuilder buff, boolean isPrefixed) { buff.append(super.appendAttributes(buff, isPrefixed)? \", \" : \" \"); buff.append(\"fh=\").append(fh) .append(\", directIO=\").append(directIO) .append(\", keepCache=\").append(keepCache); return true; } }"}
{"name": "dtrott/fuse4j", "content": " package fuse;  public interface FuseOpenSetter {  public void setFh(Object fh);  public boolean isDirectIO(); public void setDirectIO(boolean directIO);  public boolean isKeepCache(); public void setKeepCache(boolean keepCache); }"}
{"name": "dtrott/fuse4j", "content": " package fuse; import fuse.util.Struct;  public class FuseOpendir extends Struct implements FuseOpendirSetter { public Object fh;  public void setFh(Object fh) { this.fh = fh; } protected boolean appendAttributes(StringBuilder buff, boolean isPrefixed) { buff.append(super.appendAttributes(buff, isPrefixed)? \", \" : \" \"); buff.append(\"fh=\").append(fh); return true; } }"}
{"name": "dtrott/fuse4j", "content": " package fuse;  public interface FuseOpendirSetter {  public void setFh(Object fh); }"}
{"name": "dtrott/fuse4j", "content": "package fuse; import fuse.util.Struct;  public class FuseSize extends Struct implements FuseSizeSetter { public int size; "}
{"name": "dtrott/fuse4j", "content": "package fuse;  public interface FuseSizeSetter { public void setSize(int size); }"}
{"name": "dtrott/fuse4j", "content": "package fuse;  @SuppressWarnings({\"OctalInteger\"}) public interface FuseStatConstants extends FuseFtypeConstants { "}
{"name": "dtrott/fuse4j", "content": " package fuse; import fuse.util.Struct; public class FuseStatfs extends Struct implements FuseStatfsSetter { public int blockSize; public int blocks; public int blocksFree; public int blocksAvail = -1; "}
{"name": "dtrott/fuse4j", "content": "package fuse;  public interface FuseStatfsSetter { public void set(int blockSize, int blocks, int blocksFree, int blocksAvail, int files, int filesFree, int namelen); }"}
{"name": "dtrott/fuse4j", "content": "package fuse; public interface LifecycleSupport { public int init(); public int destroy(); }"}
{"name": "dtrott/fuse4j", "content": "package fuse; import fuse.util.Struct; import java.nio.ByteBuffer; import java.nio.charset.Charset;  public class PasswordEntry extends Struct {  public String username;  public int uid;  public int gid;  public String homeDirectory;  public String shell; public PasswordEntry(Charset cs, ByteBuffer username, int uid, int gid, ByteBuffer homeDirectory, ByteBuffer shell) { this.username = cs.decode(username).toString(); this.uid = uid; this.gid = gid; this.homeDirectory = cs.decode(homeDirectory).toString(); this.shell = cs.decode(shell).toString(); }  public static native PasswordEntry lookupByUsername(Charset cs, String username);  public static native PasswordEntry lookupByUid(Charset cs, int uid);  protected boolean appendAttributes(StringBuilder buff, boolean isPrefixed) { buff.append(super.appendAttributes(buff, isPrefixed) ? \", \" : \" \"); buff.append(\"username=\").append(username) .append(\", uid=\").append(uid) .append(\", gid=\").append(gid) .append(\", homeDirectory=\").append(homeDirectory) .append(\", shell=\").append(shell); return true; } }"}
{"name": "dtrott/fuse4j", "content": "package fuse;  public interface XattrLister { public void add(String xattrName); }"}
{"name": "dtrott/fuse4j", "content": "package fuse; import java.nio.ByteBuffer; import java.nio.BufferOverflowException;  public interface XattrSupport { "}
{"name": "dtrott/fuse4j", "content": " package fuse.compat; import fuse.*; import java.nio.ByteBuffer;  public interface Filesystem1 extends FilesystemConstants { public FuseStat getattr(String path) throws FuseException; public String readlink(String path) throws FuseException; public FuseDirEnt[] getdir(String path) throws FuseException; public void mknod(String path, int mode, int rdev) throws FuseException; public void mkdir(String path, int mode) throws FuseException; public void unlink(String path) throws FuseException; public void rmdir(String path) throws FuseException; public void symlink(String from, String to) throws FuseException; public void rename(String from, String to) throws FuseException; public void link(String from, String to) throws FuseException; public void chmod(String path, int mode) throws FuseException; public void chown(String path, int uid, int gid) throws FuseException; public void truncate(String path, long size) throws FuseException; public void utime(String path, int atime, int mtime) throws FuseException; public FuseStatfs statfs() throws FuseException; public void open(String path, int flags) throws FuseException; public void read(String path, ByteBuffer buf, long offset) throws FuseException; public void write(String path, ByteBuffer buf, long offset) throws FuseException; public void release(String path, int flags) throws FuseException; }"}
{"name": "dtrott/fuse4j", "content": " package fuse.compat; import fuse.compat.Filesystem1; import fuse.FuseException; import fuse.FuseStatfs; import java.nio.ByteBuffer;  public class Filesystem1ToFilesystem2Adapter implements Filesystem2 { Filesystem1 fs1; public Filesystem1ToFilesystem2Adapter(Filesystem1 fs1) { this.fs1 = fs1; } "}
{"name": "dtrott/fuse4j", "content": " package fuse.compat; import fuse.*; import java.nio.ByteBuffer;  public interface Filesystem2 extends FilesystemConstants { public FuseStat getattr(String path) throws FuseException; public String readlink(String path) throws FuseException; "}
{"name": "dtrott/fuse4j", "content": " package fuse.compat; import fuse.*; import java.nio.ByteBuffer; import java.nio.CharBuffer;  @SuppressWarnings({\"UnnecessaryUnboxing\", \"UnnecessaryBoxing\"}) public class Filesystem2ToFilesystem3Adapter implements Filesystem3 { private Filesystem2 fs2; public Filesystem2ToFilesystem3Adapter(Filesystem2 fs2) { this.fs2 = fs2; } public int getattr(String path, FuseGetattrSetter getattrSetter) throws FuseException { FuseStat stat = fs2.getattr(path); getattrSetter.set( stat.inode, stat.mode, stat.nlink, stat.uid, stat.gid, 0, stat.size, stat.blocks, stat.atime, stat.mtime, stat.ctime ); return 0; } public int chmod(String path, int mode) throws FuseException { fs2.chmod(path, mode); return 0; } public int chown(String path, int uid, int gid) throws FuseException { fs2.chown(path, uid, gid); return 0; } "}
{"name": "dtrott/fuse4j", "content": " package fuse.compat; import fuse.FuseFtype;  public class FuseDirEnt extends FuseFtype { public String name; "}
{"name": "dtrott/fuse4j", "content": " package fuse.compat; import fuse.FuseFtype; import fuse.FuseFtypeConstants; public class FuseStat extends FuseFtype implements FuseFtypeConstants { public int nlink; public int uid; public int gid; public long size; public int atime; public int mtime; public int ctime; public int blocks; "}
{"name": "dtrott/fuse4j", "content": "package fuse.logging; import org.apache.commons.logging.Log; import java.io.PrintStream; import java.util.*;  public class FuseLog implements Log { public static PrintStream trace = System.err; public static PrintStream debug = System.err; public static PrintStream info = System.err; public static PrintStream warn = System.err; public static PrintStream error = System.err; public static PrintStream fatal = System.err; public static void setOut(PrintStream out) { trace = debug = info = warn = error = fatal = out; } public static final String LEVEL_PREFIX = \"fuse.logging.level\"; private static final int LEVEL_TRACE = 0; private static final int LEVEL_DEBUG = 1; private static final int LEVEL_INFO = 2; private static final int LEVEL_WARN = 3; private static final int LEVEL_ERROR = 4; private static final int LEVEL_FATAL = 5; private static final String[] levelNames = new String[] { \"TRACE\", \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"FATAL\" }; private static final String formatPattern = \"%1$tH:%1$tM:%1$tS.%1$tL %2$8s %3$5s [%4$s]: %5$s%n\"; private static final Levels levels = new Levels(); private String name; public FuseLog(String name) { this.name = name; } "}
{"name": "dtrott/fuse4j", "content": "package fuse.util; import java.util.ArrayList; import java.util.List;  public class FuseArgumentParser { private String mountPoint; private String source; private boolean foreground; private List<String> remaining = new ArrayList<String>(); public FuseArgumentParser(String[] args) { boolean seenOption = false; for (String arg : args) { if (seenOption == true) { remaining.add(arg); seenOption = false; } else if (\"-o\".equals(arg)) { remaining.add(arg); seenOption = true; } else if (\"-f\".equals(arg)) { foreground = true; } else if (mountPoint == null) { mountPoint = arg; } else if (source == null) { source = arg; } else { remaining.add(arg); } } }  public String[] getFuseArgs() { if (foreground) { return new String[]{mountPoint, \"-f\"}; } return new String[]{mountPoint}; } public String getMountPoint() { return mountPoint; }  public String getSource() { return source; }  public boolean isForeground() { return foreground; }  public List<String> getRemaining() { return remaining; } }"}
{"name": "dtrott/fuse4j", "content": " package fuse.util; public abstract class Struct implements Cloneable { public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException e) { "}
{"name": "dtrott/fuse4j", "content": " package fuse; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.nio.BufferOverflowException; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; @SuppressWarnings({\"OctalInteger\"}) public class FakeFilesystem implements Filesystem3, XattrSupport, LifecycleSupport { private static final Log log = LogFactory.getLog(FakeFilesystem.class); private static final int BLOCK_SIZE = 512; private static final int NAME_LENGTH = 1024; private static class Node { static int nfiles = 0; String name; int mode; Map<String, byte[]> xattrs = new HashMap<String, byte[]>(); Node(String name, int mode, String... xattrs) { this.name = name; this.mode = mode; for (int i = 0; i < xattrs.length - 1; i += 2) { this.xattrs.put(xattrs[i], xattrs[i + 1].getBytes()); } nfiles++; } public String toString() { String cn = getClass().getName(); return cn.substring(cn.indexOf(\"$\")) + \"[ name=\" + name + \", mode=\" + Integer.toOctalString(mode) + \"(OCT) ]\"; } } private static class Directory extends Node { Map<String, Node> files = new LinkedHashMap<String, Node>(); Directory(String name, int mode, String... xattrs) { super(name, mode, xattrs); } void add(Node node) { files.put(node.name, node); } public String toString() { return super.toString() + \" with \" + files.size() + \" files\"; } } private static class File extends Node { byte[] content; File(String name, int mode, String content, String... xattrs) { super(name, mode, xattrs); this.content = content.getBytes(); } } private static class Link extends Node { String link; Link(String name, int mode, String link, String... xattrs) { super(name, mode, xattrs); this.link = link; } } private static class FileHandle { Node node; FileHandle(Node node) { this.node = node; log.debug(\" \" + this + \" created\"); } void release() { log.debug(\" \" + this + \" released\"); } protected void finalize() { log.debug(\" \" + this + \" finalized\"); } public String toString() { return \"FileHandle[\" + node + \", hashCode=\" + hashCode() + \"]\"; } } "}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; import fuse.FuseFtype; import fuse.compat.FuseStat; import java.util.Collection; import java.util.HashMap; import java.util.Map; public class DirectoryNode extends Node { private final static int FILE_PERMS = 493; "}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; import fuse.FuseException; import java.nio.ByteBuffer; public abstract class FileNode extends Node { public FileNode(String name) { super(name); } public abstract void open(int flags) throws FuseException; public abstract void release(int flags) throws FuseException; public abstract void read(ByteBuffer buff, long offset) throws FuseException; public abstract void write(ByteBuffer buff, long offset) throws FuseException; public abstract void truncate(long size) throws FuseException; public abstract void utime(int atime, int mtime) throws FuseException; }"}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; import fuse.compat.Filesystem1; import fuse.compat.FuseStat; public class MountpointNode extends Node { private Filesystem1 filesystem; public MountpointNode(String name, Filesystem1 filesystem) { super(name); this.filesystem = filesystem; } protected FuseStat createStat() { return null; } public Filesystem1 getFilesystem() { return filesystem; } }"}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; import fuse.compat.FuseStat; public abstract class Node { private String name; private FuseStat stat; private DirectoryNode parent; public Node(String name) { this.name = name; stat = createStat(); } "}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; import fuse.FuseFS; import fuse.FuseException; import fuse.FuseFtype; import fuse.compat.FuseStat; import java.nio.ByteBuffer; public class ReadOnlyFileNode extends FileNode { private byte[] content; public ReadOnlyFileNode(String name) { this(name, new byte[0]); } public ReadOnlyFileNode(String name, byte[] content) { super(name); setContent(content); } "}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; public class ReadOnlySymlinkNode extends SymlinkNode { private String target; public ReadOnlySymlinkNode(String name, String target) { super(name); this.target = target; } public synchronized String getTarget() { return target; } public synchronized void setTarget(String target) { this.target = target; } }"}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; import fuse.*; import fuse.compat.Filesystem1; import fuse.compat.FuseDirEnt; import fuse.compat.FuseStat; import java.nio.ByteBuffer; public class StaticFilesystem implements Filesystem1 { DirectoryNode rootNode; FuseStatfs statfs; public StaticFilesystem(DirectoryNode rootNode) { this.rootNode = rootNode; statfs = new FuseStatfs(); statfs.blocks = 0; statfs.blocksFree = 0; statfs.blockSize = 8192; statfs.files = 0; statfs.filesFree = 0; statfs.namelen = 2048; } public DirectoryNode getRootNode() { return rootNode; } "}
{"name": "dtrott/fuse4j", "content": " package fuse.staticfs; import fuse.FuseFtype; import fuse.compat.FuseStat; public abstract class SymlinkNode extends Node { public SymlinkNode(String name) { super(name); } "}
{"name": "dtrott/fuse4j", "content": " package fuse.zipfs; import fuse.FuseMount; import fuse.staticfs.DirectoryNode; import fuse.staticfs.MountpointNode; import fuse.staticfs.StaticFilesystem; import java.io.File; import java.io.IOException; public class MultiZipFilesystem extends StaticFilesystem { public MultiZipFilesystem(String args[], int offset) throws IOException { super(new DirectoryNode(\"$ROOT\")); DirectoryNode rootNode = getRootNode(); for (int i = offset; i < args.length; i++) { File zipFile = new File(args[i]); rootNode.addChild(new MountpointNode(zipFile.getName(), new ZipFilesystem(zipFile))); } } public static void main(String[] args) { if (args.length < 2) { System.out.println(\"Usage: MultiZipFilesystem mountpoint zipfile1 [zipfile2 ...]\"); System.exit(-1); } String fuseArgs[] = new String[] { args[0] }; try { FuseMount.mount(fuseArgs, new MultiZipFilesystem(args, 1)); } catch (Exception e) { e.printStackTrace(); } } }"}
{"name": "dtrott/fuse4j", "content": " package fuse.zipfs; import fuse.FuseException; import java.io.BufferedInputStream; import java.io.IOException; import java.nio.ByteBuffer; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import org.apache.commons.logging.LogFactory; import org.apache.commons.logging.Log; public class ZipEntryDataReader { private static final Log log = LogFactory.getLog(ZipEntryDataReader.class); private static final int bufferSize = 8192; private ZipFile zipFile; private ZipEntry zipEntry; private BufferedInputStream zipStream; private long zipPos; private long zipMarkPos; public ZipEntryDataReader(ZipFile zipFile, ZipEntry zipEntry) { this.zipFile = zipFile; this.zipEntry = zipEntry; } public synchronized void read(ByteBuffer bb, long offset) throws FuseException { BufferedInputStream in = getZipStream(offset, bb.capacity()); "}
{"name": "dtrott/fuse4j", "content": " package fuse.zipfs; import java.util.HashMap; import java.util.Map; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; public class ZipFileDataReader { private ZipFile zipFile; private Map zipEntry2dataReader; public ZipFileDataReader(ZipFile zipFile) { this.zipFile = zipFile; zipEntry2dataReader = new HashMap(); } public synchronized ZipEntryDataReader getZipEntryDataReader(ZipEntry zipEntry, long offset, int size) { ZipEntryDataReader entryReader = (ZipEntryDataReader)zipEntry2dataReader.get(zipEntry.getName()); if (entryReader == null) { entryReader = new ZipEntryDataReader(zipFile, zipEntry); zipEntry2dataReader.put(zipEntry.getName(), entryReader); } return entryReader; } public synchronized void releaseZipEntryDataReader(ZipEntry zipEntry) { zipEntry2dataReader.remove(zipEntry.getName()); } }"}
{"name": "dtrott/fuse4j", "content": " package fuse.zipfs; import fuse.*; import fuse.compat.Filesystem1; import fuse.compat.FuseDirEnt; import fuse.compat.FuseStat; import fuse.zipfs.util.Node; import fuse.zipfs.util.Tree; import java.io.File; import java.io.IOException; import java.nio.ByteBuffer; import java.util.Collection; import java.util.Enumeration; import java.util.Iterator; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import org.apache.commons.logging.LogFactory; import org.apache.commons.logging.Log; public class ZipFilesystem implements Filesystem1 { private static final Log log = LogFactory.getLog(ZipFilesystem.class); private static final int blockSize = 512; private ZipFile zipFile; private long zipFileTime; private ZipEntry rootEntry; private Tree tree; private FuseStatfs statfs; private ZipFileDataReader zipFileDataReader; public ZipFilesystem(File file) throws IOException { log.info(\"extracting zip file structure...\"); zipFile = new ZipFile(file, ZipFile.OPEN_READ); zipFileTime = file.lastModified(); rootEntry = new ZipEntry(\"\") { public boolean isDirectory() { return true; } }; rootEntry.setTime(zipFileTime); rootEntry.setSize(0); zipFileDataReader = new ZipFileDataReader(zipFile); tree = new Tree(); tree.addNode(rootEntry.getName(), rootEntry); int files = 0; int dirs = 0; int blocks = 0; for (Enumeration e = zipFile.entries(); e.hasMoreElements();) { ZipEntry entry = (ZipEntry) e.nextElement(); tree.addNode(entry.getName(), entry); if (entry.isDirectory()) dirs++; else files++; blocks += (entry.getSize() + blockSize - 1) / blockSize; } statfs = new FuseStatfs(); statfs.blocks = blocks; statfs.blockSize = blockSize; statfs.blocksFree = 0; statfs.files = files + dirs; statfs.filesFree = 0; statfs.namelen = 2048; log.info(\"zip file structure extracted: \" + files + \" files, \" + dirs + \" directories, \" + blocks + \" blocks (\" + blockSize + \" byte/block).\"); } public void chmod(String path, int mode) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void chown(String path, int uid, int gid) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public FuseStat getattr(String path) throws FuseException { Node node = tree.lookupNode(path); ZipEntry entry = null; if (node == null || (entry = (ZipEntry)node.getValue()) == null) throw new FuseException(\"No Such Entry\").initErrno(FuseException.ENOENT); FuseStat stat = new FuseStat(); stat.mode = entry.isDirectory() ? FuseFtype.TYPE_DIR | 0755 : FuseFtype.TYPE_FILE | 0644; stat.nlink = 1; stat.uid = 0; stat.gid = 0; stat.size = entry.getSize(); stat.atime = stat.mtime = stat.ctime = (int) (entry.getTime() / 1000L); stat.blocks = (int) ((stat.size + 511L) / 512L); return stat; } public FuseDirEnt[] getdir(String path) throws FuseException { Node node = tree.lookupNode(path); ZipEntry entry = null; if (node == null || (entry = (ZipEntry)node.getValue()) == null) throw new FuseException(\"No Such Entry\").initErrno(FuseException.ENOENT); if (!entry.isDirectory()) throw new FuseException(\"Not A Directory\").initErrno(FuseException.ENOTDIR); Collection children = node.getChildren(); FuseDirEnt[] dirEntries = new FuseDirEnt[children.size()]; int i = 0; for (Iterator iter = children.iterator(); iter.hasNext(); i++) { Node childNode = (Node)iter.next(); ZipEntry zipEntry = (ZipEntry)childNode.getValue(); FuseDirEnt dirEntry = new FuseDirEnt(); dirEntries[i] = dirEntry; dirEntry.name = childNode.getName(); dirEntry.mode = zipEntry.isDirectory()? FuseFtype.TYPE_DIR : FuseFtype.TYPE_FILE; } return dirEntries; } public void link(String from, String to) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void mkdir(String path, int mode) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void mknod(String path, int mode, int rdev) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void open(String path, int flags) throws FuseException { ZipEntry entry = getFileZipEntry(path); if (flags == O_WRONLY || flags == O_RDWR) throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void rename(String from, String to) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void rmdir(String path) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public FuseStatfs statfs() throws FuseException { return statfs; } public void symlink(String from, String to) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void truncate(String path, long size) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void unlink(String path) throws FuseException { throw new FuseException(\"Read Only\").initErrno(FuseException.EACCES); } public void utime(String path, int atime, int mtime) throws FuseException { "}
{"name": "dtrott/fuse4j", "content": " package fuse.zipfs.util; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.Map; public class Node { private String name; private Node parent; private Object value; private Map children; public String getName() { return name; } public void setName(String name) { this.name = name; } public Node getParent() { return parent; } public void setParent(Node parent) { this.parent = parent; } public Object getValue() { return value; } public void setValue(Object value) { this.value = value; } public boolean isLeafNode() { return children == null || children.size() == 0; } public void addChild(Node node) { if (children == null) children = new HashMap(); children.put(node.getName(), node); } public Node getChild(String name) { return (children == null)? null : (Node)children.get(name); } public Collection getChildren() { return (children == null)? Collections.EMPTY_LIST : children.values(); } }"}
{"name": "dtrott/fuse4j", "content": " package fuse.zipfs.util; public class Tree { Node rootNode; public Tree() { rootNode = new Node(); rootNode.setName(\"$ROOT\"); rootNode.setParent(rootNode); } public void addNode(String path, Object value) { Node node = rootNode; String[] pathParts = path.split(\"/\"); for (int i = 0; i < pathParts.length; i++) { String pathPart = pathParts[i]; if (pathPart.equals(\"\") || pathPart.equals(\".\")) { "}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": ""}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App1 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App2 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "public class Utilities { public static boolean stillAlive() { return true; } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App1 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App2 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App1 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World from Main!\" ); int mysum = sum(5, 4); System.out.println(\"We can set a breakpoint and output a var: \" + mysum); } public static int sum(int opr1, int opr2) { throw new java.lang.IllegalStateException(\"A big scary exception\"); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World from Main!\" ); int mysum = sum(5, 4); System.out.println(\"We can set a breakpoint and output a var: \" + mysum); } public static int sum(int opr1, int opr2) { return opr1 + opr2; } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas; import org.apache.wicket.PageParameters; import org.apache.wicket.markup.html.basic.Label; import org.apache.wicket.markup.html.WebPage;  public class HomePage extends WebPage { private static final long serialVersionUID = 1L; "}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas; import org.apache.wicket.protocol.http.WebApplication;  public class WicketApplication extends WebApplication {  public WicketApplication() { }  public Class getHomePage() { return HomePage.class; } @Deprecated public void throwawayMethod() { "}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas; import org.apache.wicket.PageParameters; import org.apache.wicket.markup.html.basic.Label; import org.apache.wicket.markup.html.WebPage;  public class HomePage extends WebPage { private static final long serialVersionUID = 1L; private static final Utility util = new Utility(); "}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class Utility { private static final long serialVersionUID = 1L; public void worthlessMethod() { System.out.println(\"This is boilerplate output\"); System.out.println(\"This is more boilerplate output\"); System.out.println(\"This is even more boilerplate output\"); System.out.println(\"This is boilerplate output\"); System.out.println(\"This is more boilerplate output\"); System.out.println(\"This is even more boilerplate output\"); System.out.println(\"This is boilerplate output\"); System.out.println(\"This is more boilerplate output\"); System.out.println(\"This is even more boilerplate output\"); System.out.println(\"This is boilerplate output\"); System.out.println(\"This is more boilerplate output\"); System.out.println(\"This is even more boilerplate output\"); "}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas; import org.apache.wicket.protocol.http.WebApplication;  public class WicketApplication extends WebApplication {  public WicketApplication() { }  public Class getHomePage() { "}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App1 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App2 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": ""}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package org.module1;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package org.module2;  public class App { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App1 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "matthewmccullough/maven-training", "content": "package com.ambientideas;  public class App2 { public static void main( String[] args ) { System.out.println( \"Hello World!\" ); } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets; public class RcpSnippetsConstants { public static final String SNIPPETS_PERSPECTIVE_ID = \"de.ralfebert.rcpsnippets\"; public static final String SNIPPET_01_TABLE_PROPERTIES_VIEW_ID = \"de.ralfebert.rcpsnippets.Snippet01TableProperties\"; public static final String SNIPPET_02_STOCKS_VIEW_ID = \"de.ralfebert.rcpsnippets.snippet02stocks\"; }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets; import org.eclipse.ui.IFolderLayout; import org.eclipse.ui.IPageLayout; import org.eclipse.ui.IPerspectiveFactory; public class SnippetsPerspectiveFactory implements IPerspectiveFactory { public void createInitialLayout(IPageLayout layout) { IFolderLayout snippetsFolder = layout.createFolder(\"snippets\", IPageLayout.TOP, 0.35f, layout.getEditorArea()); snippetsFolder.addView(RcpSnippetsConstants.SNIPPET_01_TABLE_PROPERTIES_VIEW_ID); snippetsFolder.addView(RcpSnippetsConstants.SNIPPET_02_STOCKS_VIEW_ID); layout.setEditorAreaVisible(false); } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.application; import org.eclipse.jface.action.IMenuManager; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.application.ActionBarAdvisor; import org.eclipse.ui.application.IActionBarConfigurer; public class ApplicationActionBarAdvisor extends ActionBarAdvisor { public ApplicationActionBarAdvisor(IActionBarConfigurer configurer) { super(configurer); } protected void makeActions(IWorkbenchWindow window) { } protected void fillMenuBar(IMenuManager menuBar) { } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.application; import org.eclipse.ui.application.IWorkbenchWindowConfigurer; import org.eclipse.ui.application.WorkbenchAdvisor; import org.eclipse.ui.application.WorkbenchWindowAdvisor; import de.ralfebert.rcpsnippets.RcpSnippetsConstants; public class ApplicationWorkbenchAdvisor extends WorkbenchAdvisor { @Override public WorkbenchWindowAdvisor createWorkbenchWindowAdvisor(IWorkbenchWindowConfigurer configurer) { return new ApplicationWorkbenchWindowAdvisor(configurer); } @Override public String getInitialWindowPerspectiveId() { return RcpSnippetsConstants.SNIPPETS_PERSPECTIVE_ID; } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.application; import org.eclipse.swt.graphics.Point; import org.eclipse.ui.application.ActionBarAdvisor; import org.eclipse.ui.application.IActionBarConfigurer; import org.eclipse.ui.application.IWorkbenchWindowConfigurer; import org.eclipse.ui.application.WorkbenchWindowAdvisor; public class ApplicationWorkbenchWindowAdvisor extends WorkbenchWindowAdvisor { public ApplicationWorkbenchWindowAdvisor(IWorkbenchWindowConfigurer configurer) { super(configurer); } public ActionBarAdvisor createActionBarAdvisor(IActionBarConfigurer configurer) { return new ApplicationActionBarAdvisor(configurer); } public void preWindowOpen() { IWorkbenchWindowConfigurer configurer = getWindowConfigurer(); configurer.setInitialSize(new Point(400, 300)); configurer.setShowCoolBar(false); configurer.setShowStatusLine(false); configurer.setTitle(\"Hello RCP\"); } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.application; import org.eclipse.equinox.app.IApplication; import org.eclipse.equinox.app.IApplicationContext; import org.eclipse.swt.widgets.Display; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.PlatformUI;  public class SnippetsApplication implements IApplication {  public Object start(IApplicationContext context) throws Exception { Display display = PlatformUI.createDisplay(); try { int returnCode = PlatformUI.createAndRunWorkbench(display, new ApplicationWorkbenchAdvisor()); if (returnCode == PlatformUI.RETURN_RESTART) return IApplication.EXIT_RESTART; else return IApplication.EXIT_OK; } finally { display.dispose(); } }  public void stop() { final IWorkbench workbench = PlatformUI.getWorkbench(); if (workbench == null) return; final Display display = workbench.getDisplay(); display.syncExec(new Runnable() { public void run() { if (!display.isDisposed()) workbench.close(); } }); } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.snippet01tableproperties; import java.util.Date; public class City { private String name; private Date foundingDate; private final CityStats stats; private String neighborCity; public City(String name, Date foundingYear, CityStats stats, String neighborCity) { super(); this.name = name; this.foundingDate = foundingYear; this.stats = stats; this.neighborCity = neighborCity; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getFoundingDate() { return foundingDate; } public void setFoundingDate(Date foundingYear) { this.foundingDate = foundingYear; } public CityStats getStats() { return stats; } public String getNeighborCity() { return neighborCity; } public void setNeighborCity(String neighborCity) { this.neighborCity = neighborCity; } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.snippet01tableproperties; public class CityStats { private int population; private double areaKm2; public CityStats(int population, double areaKm2) { super(); this.population = population; this.areaKm2 = areaKm2; } public int getPopulation() { return population; } public void setPopulation(int population) { this.population = population; } public double getAreaKm2() { return areaKm2; } public void setAreaKm2(double areaKm2) { this.areaKm2 = areaKm2; } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.snippet01tableproperties; import java.text.DecimalFormat; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.List; import org.eclipse.jface.viewers.ArrayContentProvider; import org.eclipse.jface.viewers.ComboBoxViewerCellEditor; import org.eclipse.jface.viewers.LabelProvider; import org.eclipse.jface.viewers.TableViewer; import org.eclipse.jface.viewers.ViewerCell; import org.eclipse.swt.SWT; import org.eclipse.swt.widgets.Composite; import org.eclipse.ui.part.ViewPart; import de.ralfebert.rcputils.properties.BaseValue; import de.ralfebert.rcputils.random.RandomData; import de.ralfebert.rcputils.tables.ColumnBuilder; import de.ralfebert.rcputils.tables.ICellFormatter; import de.ralfebert.rcputils.tables.TableViewerBuilder; import de.ralfebert.rcputils.tables.format.Formatter; import de.ralfebert.rcputils.tables.format.StringValueFormatter; public class Snippet01TableViewerBuilder extends ViewPart { private TableViewer tableViewer; @Override public void createPartControl(Composite parent) { TableViewerBuilder t = new TableViewerBuilder(parent); ColumnBuilder city = t.createColumn(\"City\"); city.bindToProperty(\"name\"); city.setPercentWidth(60); city.useAsDefaultSortColumn(); city.makeEditable(); city.build(); ColumnBuilder population = t.createColumn(\"Population\"); population.bindToProperty(\"stats.population\"); population.format(Formatter.forInt(new DecimalFormat(\"#,##0\"))); population.format(new ICellFormatter() { public void formatCell(ViewerCell cell, Object value) { int population = (Integer) value; int color = (population > 5000000) ? SWT.COLOR_RED : SWT.COLOR_BLACK; cell.setForeground(cell.getControl().getDisplay().getSystemColor(color)); } }); population.alignRight(); population.makeEditable(Formatter.forInt()); population.build(); ColumnBuilder area = t.createColumn(\"Area\"); area.bindToProperty(\"stats.areaKm2\"); area.alignRight(); area.format(Formatter.forDouble(new DecimalFormat(\"0.00 km\u00b2\"))); area.makeEditable(Formatter.forDouble(new DecimalFormat(\"0.00\"))); area.build(); ColumnBuilder density = t.createColumn(\"People/km\u00b2\"); density.bindToValue(new BaseValue<City>() { @Override public Object get(City city) { return city.getStats().getPopulation() / city.getStats().getAreaKm2(); } }); density.format(Formatter.forDouble(new DecimalFormat(\"0\"))); density.alignRight(); density.build(); ColumnBuilder foundingDate = t.createColumn(\"Founding date\"); foundingDate.bindToProperty(\"foundingDate\"); StringValueFormatter dateFormat = Formatter.forDate(SimpleDateFormat.getDateInstance(SimpleDateFormat.MEDIUM)); foundingDate.format(dateFormat); foundingDate.alignCenter(); foundingDate.setPixelWidth(100); foundingDate.makeEditable(dateFormat); foundingDate.build(); ColumnBuilder neighborCity = t.createColumn(\"Neighbor city\"); neighborCity.bindToProperty(\"neighborCity\"); neighborCity.setPixelWidth(100); ComboBoxViewerCellEditor cityComboEditor = new ComboBoxViewerCellEditor(t.getTable(), SWT.READ_ONLY); cityComboEditor.setContenProvider(new ArrayContentProvider()); cityComboEditor.setLabelProvider(new LabelProvider()); cityComboEditor.setInput(RandomData.CITIES); neighborCity.makeEditable(cityComboEditor); neighborCity.build(); t.setInput(createSomeData()); tableViewer = t.getTableViewer(); } private List<City> createSomeData() { List<City> data = new ArrayList<City>(); RandomData randomData = new RandomData(); for (int i = 0; i < 50; i++) { CityStats stats = new CityStats(randomData.someNumber(10000, 10000000), randomData.someNumber(100d, 800d)); data.add(new City(randomData.someCity(), randomData.someDate(1200, 1600), stats, randomData.someCity())); randomData.newData(); } return data; } @Override public void setFocus() { tableViewer.getTable().setFocus(); } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.snippet02stocks; import java.math.BigDecimal; import java.util.Collection; import org.eclipse.core.databinding.beans.BeanProperties; import org.eclipse.core.databinding.observable.list.IObservableList; import org.eclipse.core.databinding.observable.list.WritableList; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.Status; import org.eclipse.core.runtime.jobs.Job; import org.eclipse.jface.databinding.viewers.ViewerSupport; import org.eclipse.swt.widgets.Composite; import org.eclipse.ui.part.ViewPart; import de.ralfebert.rcputils.databinding.Realms; import de.ralfebert.rcputils.random.RandomData; import de.ralfebert.rcputils.tables.TableViewerBuilder; public class Snippet02Stocks extends ViewPart { @Override public void createPartControl(Composite parent) { TableViewerBuilder t = new TableViewerBuilder(parent); t.createColumn(\"Stock\").build(); t.createColumn(\"Rate\").alignRight().build(); ViewerSupport.bind(t.getTableViewer(), createStocks(), BeanProperties.values(new String[] { \"name\", \"rate\" })); } private IObservableList createStocks() { final WritableList stocks = new WritableList(Realms.WHATEVER); final RandomData rand = new RandomData(); for (int i = 0; i < 50; i++) { stocks.add(new Stock(rand.someCharacters(4, RandomData.UPPERCASE_CHARS), new BigDecimal(rand.someNumber(1d, 200d)))); rand.newData(); } Job job = new Job(\"stock exchange\") { @Override @SuppressWarnings(\"unchecked\") protected IStatus run(IProgressMonitor monitor) { for (Stock stock : (Collection<Stock>) stocks) { rand.newData(); stock.setRate(stock.getRate().add( new BigDecimal(rand.someNumber(-20, 20)).divide(new BigDecimal(100)))); } this.schedule(200); return Status.OK_STATUS; } }; job.schedule(); return stocks; } @Override public void setFocus() { "}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcpsnippets.snippet02stocks; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.math.BigDecimal; public class Stock { private final PropertyChangeSupport changes = new PropertyChangeSupport(this); private String name; private BigDecimal rate; public Stock(String name, BigDecimal rate) { super(); this.name = name; this.rate = rate; } public String getName() { return name; } public void setName(String name) { changes.firePropertyChange(\"name\", this.name, this.name = name); } public BigDecimal getRate() { return rate; } public void setRate(BigDecimal rate) { changes.firePropertyChange(\"rate\", this.rate, this.rate = rate); } public void addPropertyChangeListener(PropertyChangeListener listener) { changes.addPropertyChangeListener(listener); } public void removePropertyChangeListener(PropertyChangeListener listener) { changes.removePropertyChangeListener(listener); } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.wired; import org.eclipse.riena.core.wire.Wire; import org.eclipse.riena.core.wire.WirePuller; import org.eclipse.ui.IEditorInput; import org.eclipse.ui.IEditorSite; import org.eclipse.ui.PartInitException; import org.osgi.framework.Bundle; import org.osgi.framework.FrameworkUtil; import de.ralfebert.rcputils.parts.AbstractEditorPart; public abstract class WiredEditorPart<INPUT extends IEditorInput> extends AbstractEditorPart<INPUT> { private WirePuller wire; @Override public void init(IEditorSite site, IEditorInput input) throws PartInitException { setSite(site); setInput(input); Bundle bundle = FrameworkUtil.getBundle(this.getClass()); if (bundle != null) { wire = Wire.instance(this).andStart(bundle.getBundleContext()); } } @Override public void dispose() { super.dispose(); if (wire != null) { wire.stop(); wire = null; } } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.wired; import org.eclipse.core.commands.AbstractHandler; import org.eclipse.riena.core.wire.Wire; import org.eclipse.riena.core.wire.WirePuller; import org.osgi.framework.Bundle; import org.osgi.framework.FrameworkUtil; public abstract class WiredHandler extends AbstractHandler { private WirePuller wire; public WiredHandler() { Bundle bundle = FrameworkUtil.getBundle(this.getClass()); if (bundle != null) { wire = Wire.instance(this).andStart(bundle.getBundleContext()); } } @Override public void dispose() { super.dispose(); if (wire != null) { wire.stop(); wire = null; } } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.wired; import org.eclipse.riena.core.wire.Wire; import org.eclipse.riena.core.wire.WirePuller; import org.eclipse.ui.IEditorInput; import org.eclipse.ui.IEditorSite; import org.eclipse.ui.PartInitException; import org.osgi.framework.Bundle; import org.osgi.framework.FrameworkUtil; import de.ralfebert.rcputils.databinding.ModelDataBindingEditorPart; public abstract class WiredModelDataBindingEditorPart<INPUT extends IEditorInput, MODEL> extends ModelDataBindingEditorPart<INPUT, MODEL> { private WirePuller wire; @Override public void init(IEditorSite site, IEditorInput input) throws PartInitException { super.init(site, input); Bundle bundle = FrameworkUtil.getBundle(this.getClass()); if (bundle != null) { wire = Wire.instance(this).andStart(bundle.getBundleContext()); } } @Override public void dispose() { super.dispose(); if (wire != null) { wire.stop(); wire = null; } } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.wired; import org.eclipse.riena.core.wire.Wire; import org.eclipse.riena.core.wire.WirePuller; import org.eclipse.ui.IViewSite; import org.eclipse.ui.PartInitException; import org.eclipse.ui.part.ViewPart; import org.osgi.framework.Bundle; import org.osgi.framework.FrameworkUtil; public abstract class WiredViewPart extends ViewPart { private WirePuller wire; @Override public void init(IViewSite site) throws PartInitException { super.init(site); Bundle bundle = FrameworkUtil.getBundle(this.getClass()); if (bundle != null) { wire = Wire.instance(this).andStart(bundle.getBundleContext()); } } @Override public void dispose() { super.dispose(); if (wire != null) { wire.stop(); wire = null; } } }"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.lang; import java.io.IOException; import java.io.InputStream; import java.net.URL; import org.apache.commons.io.IOUtils; public class Colocated { public static String toString(Object ownerObject, String filename) { try { return IOUtils.toString(toStream(ownerObject, filename)); } catch (IOException e) { throw new RuntimeException(e); } } public static InputStream toStream(Object ownerObject, String filename) { Class<?> ownerClass = ownerObject.getClass(); InputStream stream = ownerObject.getClass().getResourceAsStream(filename); if (stream == null) { throw new RuntimeException(filename + \" not found in package \" + ownerClass.getPackage()); } return stream; } public static URL toURL(Object ownerObject, String filename) { Class<?> ownerClass = ownerObject.getClass(); URL url = ownerObject.getClass().getResource(filename); if (url == null) { throw new RuntimeException(filename + \" not found in package \" + ownerClass.getPackage()); } return url; } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.menus; import org.eclipse.core.commands.common.CommandException; import org.eclipse.jface.action.MenuManager; import org.eclipse.jface.action.Separator; import org.eclipse.jface.viewers.DoubleClickEvent; import org.eclipse.jface.viewers.IDoubleClickListener; import org.eclipse.jface.viewers.StructuredViewer; import org.eclipse.swt.SWT; import org.eclipse.swt.events.MenuAdapter; import org.eclipse.swt.events.MenuEvent; import org.eclipse.swt.events.MenuListener; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Menu; import org.eclipse.swt.widgets.MenuItem; import org.eclipse.ui.IWorkbenchActionConstants; import org.eclipse.ui.IWorkbenchPartSite; import org.eclipse.ui.handlers.IHandlerService; import org.eclipse.ui.menus.CommandContributionItem; import de.ralfebert.rcputils.internal.RcpUtilsPlugin; /** * ContextMenu creates a context menu for a structured viewer and registers it * with the workbench. It can assist with handling the default menu item. * * @author Ralf Ebert * @see http:"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.parts; import org.eclipse.jface.resource.JFaceResources; import org.eclipse.jface.resource.LocalResourceManager; import org.eclipse.jface.resource.ResourceManager; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Display; import org.eclipse.ui.IEditorInput; import org.eclipse.ui.IEditorSite; import org.eclipse.ui.PartInitException; import org.eclipse.ui.part.EditorPart; public abstract class AbstractEditorPart<INPUT extends IEditorInput> extends EditorPart { private ResourceManager resources; @Override public void init(IEditorSite site, IEditorInput input) throws PartInitException { setSite(site); setInput(input); } @Override public final void createPartControl(Composite parent) { this.resources = new LocalResourceManager(JFaceResources.getResources(), parent); onBeforeUi(parent); onCreateUi(parent); onAfterUi(parent); } protected void onBeforeUi(Composite parent) { } protected void onAfterUi(Composite parent) { }  protected abstract void onCreateUi(Composite parent); @Override public boolean isSaveAsAllowed() { return false; } @Override public void doSaveAs() { throw new UnsupportedOperationException(); } @Override @SuppressWarnings(\"unchecked\") public INPUT getEditorInput() { return (INPUT) super.getEditorInput(); } protected Display getDisplay() { return getSite().getShell().getDisplay(); } protected ResourceManager getResources() { return resources; } }"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.porting; import org.eclipse.swt.SWT; public class CrossPlatformSupport {  public static boolean isStyleSupported(int style) { if ((style & (SWT.SEARCH | SWT.ICON_SEARCH | SWT.ICON_CANCEL)) > 0) { return isCocoa(); } return true; } private static boolean isCocoa() { return SWT.getPlatform().equals(\"cocoa\"); } }"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "package de.ralfebert.rcputils.selection; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; import org.eclipse.jface.viewers.ISelection; import org.eclipse.jface.viewers.IStructuredSelection;  public class SelectionUtils {  public static final <A> Iterable<A> getIterable(ISelection selection, Class<A> selectedObjectClass) { if (selection.isEmpty()) return Collections.emptyList(); List<A> selectedObjects = new ArrayList<A>(); if (selection instanceof IStructuredSelection) { Iterator<?> iterator = ((IStructuredSelection) selection) .iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); if (selectedObjectClass.isAssignableFrom(obj.getClass())) { @SuppressWarnings(\"unchecked\") A selectedObject = (A) obj; selectedObjects.add(selectedObject); } } } return selectedObjects; } }"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "ralfebert/rcputils", "content": "/******************************************************************************* * Copyright (c) 2008 Ralf Ebert * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "package com.apress.progwt.server.gwt; /* * Copyright 2007 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "package com.apress.progwt.server.gwt; /* * Copyright 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "package com.apress.progwt.server.gwt; /* * Copyright 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "package com.apress.progwt.server.web.controllers.facebook; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.security.MessageDigest; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.SortedSet; import java.util.TreeSet; import java.util.Map.Entry; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.facebook.api.FacebookParam; import com.facebook.api.FacebookRestClient;  public class Facebook { private HttpServletRequest request; private HttpServletResponse response; protected FacebookRestClient apiClient; protected String apiKey; protected String secret; protected Map<String, String> fbParams; protected Long user; private static String FACEBOOK_URL_PATTERN = \"^https?:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "/* * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "jdwyah/tocollege.net", "content": "package com.apress.progwt.server.web.servlet; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.OutputStream; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; import javax.activation.FileTypeMap; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.log4j.Logger; /** * * * Copyright 2008 Jeff Dwyer * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2009 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2009 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "package com.salas.bb.core.actions.feed; import com.salas.bb.domain.IFeed; import java.awt.event.ActionEvent;  public class FeedLinkMarkFeedAsUnreadAction extends MarkFeedAsUnreadAction { private static IFeed feed;  public FeedLinkMarkFeedAsUnreadAction() { super(); setEnabled(true); }  public static void setFeed(IFeed feed) { FeedLinkMarkFeedAsUnreadAction.feed = feed; }  protected IFeed[] getFeeds() { return new IFeed[] { feed }; }  protected void doAction(ActionEvent event) { try { super.doAction(event); } catch (Exception e) { "}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2009 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": " package com.salas.bb.domain; import com.salas.bb.utils.i18n.Strings;  public class FeedType {  public static final int TYPE_TEXT = 0;  public static final int TYPE_IMAGE = 1;  public static final int TYPE_LINK = 2;  public static final int TYPE_TWITTER = 3;  public static final FeedType TEXT = new FeedType(TYPE_TEXT, Strings.message(\"feed.type.text\"));  public static final FeedType IMAGE = new FeedType(TYPE_IMAGE, Strings.message(\"feed.type.images\"));  public static final FeedType LINK = new FeedType(TYPE_LINK, Strings.message(\"feed.type.links\"));  public static final FeedType TWITTER = new FeedType(TYPE_TWITTER, Strings.message(\"feed.type.twitter\")); private final int type; private final String typeName;  private FeedType(int aType, String aTypeName) { type = aType; typeName = aTypeName; }  public int getType() { return type; }  public static FeedType toObject(int type) { FeedType obj; switch (type) { case TYPE_TEXT: obj = TEXT; break; case TYPE_IMAGE: obj = IMAGE; break; case TYPE_LINK: obj = LINK; break; case TYPE_TWITTER: obj = TWITTER; break; default: throw new IllegalArgumentException(Strings.error(\"unsupported.feed.type\")); } return obj; }  public String toString() { return typeName; }  public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final FeedType feedType = (FeedType)o; return type == feedType.type; }  public int hashCode() { return type; }  public static FeedType[] getAllTypes() { return new FeedType[] { TEXT, IMAGE, TWITTER }; } }"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "package com.salas.bb.domain.query.articles; import com.salas.bb.domain.query.AbstractProperty; import com.salas.bb.domain.query.PropertyType; import com.salas.bb.domain.query.IComparisonOperation; import com.salas.bb.domain.query.general.StringContainsCO; import com.salas.bb.domain.query.general.StringNotContainsCO; import com.salas.bb.domain.IArticle; import com.salas.bb.utils.i18n.Strings;  public class ArticleCategoryProperty extends AbstractProperty {  public static final ArticleCategoryProperty INSTANCE = new ArticleCategoryProperty();  protected ArticleCategoryProperty() { super(Strings.message(\"query.property.article.category\"), \"article-category\", PropertyType.STRING, \"\", new IComparisonOperation[] { StringContainsCO.INSTANCE, StringNotContainsCO.INSTANCE }); }  public boolean match(Object target, IComparisonOperation operation, String value) { IArticle article = (IArticle)target; String categories = article == null ? null : article.getSubject(); return operation.match(categories, value.toUpperCase()); } }"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "package com.salas.bb.imageblocker; import com.salas.bb.core.GlobalController; import com.salas.bb.core.GlobalModel; import com.salas.bb.utils.ThreadedAction; import com.salas.bb.views.mainframe.MainFrame; import java.awt.event.ActionEvent; import java.util.List;  public class ImageBlockerConfigAction extends ThreadedAction {  protected void doAction(ActionEvent event) { List<String> oldExpr = ImageBlocker.getExpressions(); MainFrame frame = GlobalController.SINGLETON.getMainFrame(); ImageBlockerDialog dialog = new ImageBlockerDialog(frame, null); dialog.open(); if (!oldExpr.equals(ImageBlocker.getExpressions())) { GlobalModel.touchPreferences(); } } }"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "package com.salas.bb.networking.manager; import com.jgoodies.forms.layout.CellConstraints; import com.salas.bb.utils.Constants; import com.salas.bb.utils.StringUtils; import com.salas.bb.utils.i18n.Strings; import com.salas.bb.utils.uif.BBFormBuilder; import com.salas.bb.utils.uif.treetable.JTreeTable; import com.salas.bb.utils.uif.treetable.TreeTableModel; import javax.swing.*; import javax.swing.tree.DefaultTreeCellRenderer; import javax.swing.table.TableColumn; import java.awt.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.text.MessageFormat;  public final class ActivityWindow extends JDialog { private static final int DEFAULT_WIDTH = 300; private static final int DEFAULT_HEIGHT = 200; "}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "package com.salas.bb.networking.manager; import com.salas.bb.utils.uif.UifUtilities; import com.salas.bb.utils.uif.treetable.AbstractTreeTableModel; import com.salas.bb.utils.uif.treetable.TreeTableModel; import com.salas.bb.utils.i18n.Strings; import javax.swing.*; import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.util.ArrayList; import java.util.List;  public class NetTasksModel extends AbstractTreeTableModel {  public static final int COL_TASK_NAME = 0;  public static final int COL_PROGRESS = 1;  public static final int COL_COMMANDS = 2; private final static String[] COLUMN_NAME = { Strings.message(\"activity.taskstable.name\"), Strings.message(\"activity.taskstable.progress\"), \"_\" }; private final static Class[] COLUMN_CLASS = { TreeTableModel.class, Double.class, Integer.class }; private ModelChangeListener rootListener;  public NetTasksModel(NetTaskGroup aRoot) { super(aRoot); rootListener = new ModelChangeListener(); aRoot.addPropertyChangeListener(rootListener); aRoot.addListener(rootListener); }  public int getColumnCount() { return COLUMN_NAME.length; }  public String getColumnName(int column) { return COLUMN_NAME[column]; }  public Class getColumnClass(int column) { return COLUMN_CLASS[column]; }  public Object getValueAt(Object node, int column) { NetTask task = (NetTask)node; Object value; switch (column) { case COL_TASK_NAME: value = task.getTitle(); break; case COL_PROGRESS: float progress = task.getProgress(); value = new Double(progress); break; case COL_COMMANDS: value = new Integer(task.getStatus()); break; case -1: "}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2009 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2009 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": " package com.salas.bb.search; import com.jgoodies.uif.util.ResourceUtils; import com.salas.bb.utils.i18n.Strings; import javax.swing.*;  public class ResultItemType {  public static final ResultItemType GUIDE = new ResultItemType(0, Strings.message(\"search.itemtype.guides\"), \"search.guide.icon\");  public static final ResultItemType FEED = new ResultItemType(1, Strings.message(\"search.itemtype.feeds\"), \"search.feed.icon\");  public static final ResultItemType ARTICLE = new ResultItemType(2, Strings.message(\"search.itemtype.article\"), \"search.article.icon\");  public static final ResultItemType PICTURE = new ResultItemType(3, Strings.message(\"search.itemtype.picture\"), \"search.picture.icon\");  public static final int COUNT = 4; private final int order; private final String name; private final Icon icon;  private ResultItemType(int anOrder, String aName, String aIconName) { order = anOrder; name = aName; icon = ResourceUtils.getIcon(aIconName); }  public String getName() { return name; }  public int getOrder() { return order; }  public Icon getIcon() { return icon; }  public String toString() { return name; } }"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2011 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2011 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2011 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2011 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": "/* * BlogBridge -- RSS feed reader, manager, and web based service * Copyright (C) 2002-2009 by R. Pito Salas * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software Foundation; * either version 2 of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with this program; * if not, write to the Free Software Foundation, Inc., 59 Temple Place, * Suite 330, Boston, MA 02111-1307 USA * * Contact: R. Pito Salas * mailto:pitosalas@users.sourceforge.net * More information: about BlogBridge * http:"}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "pitosalas/blogbridge", "content": ""}
{"name": "maimuzo/android_utils", "content": " package net.it4myself.util; public final class R { public static final class attr { } public static final class drawable { public static final int icon=0x7f020000; } public static final class layout { public static final int main=0x7f030000; } public static final class string { public static final int app_name=0x7f040001; public static final int hello=0x7f040000; } }"}
{"name": "maimuzo/android_utils", "content": "package net.it4myself.util; import java.io.BufferedInputStream; import java.io.IOException; import java.io.InputStream; import java.io.UnsupportedEncodingException; import java.net.URI; import java.net.URLEncoder; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.ParserConfigurationException; import javax.xml.parsers.SAXParser; import javax.xml.parsers.SAXParserFactory; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.NameValuePair; import org.apache.http.auth.AuthScope; import org.apache.http.auth.UsernamePasswordCredentials; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.HttpResponseException; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpDelete; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.methods.HttpPut; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.message.BasicNameValuePair; import org.apache.http.protocol.HTTP; import org.apache.http.util.EntityUtils; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.SAXException; import org.xml.sax.helpers.DefaultHandler; import org.xmlpull.v1.XmlPullParser; import org.xmlpull.v1.XmlPullParserException; import org.xmlpull.v1.XmlPullParserFactory; import android.util.Log; public class RestfulClient { private static final String TAG = \"Restful\"; public static String basicAuthUsername = \"\"; public static String basicAuthPassword = \"\"; public static String get(String uri, HashMap<String,String> map) throws ClientProtocolException, IOException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpGet method = new HttpGet(fulluri); return EntityUtils.toString(doRequest(method)); } public static Document get(String uri, HashMap<String,String> map, DocumentBuilder builder) throws ClientProtocolException, IOException, SAXException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpGet method = new HttpGet(fulluri); return getDOM(doRequest(method), builder); } public static void get(String uri, HashMap<String,String> map, DefaultHandler handler) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpGet method = new HttpGet(fulluri); parseBySAX(doRequest(method), handler); } public static void get(String uri, HashMap<String,String> map, CustomPullParser pullParser) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpGet method = new HttpGet(fulluri); parseByPullParser(doRequest(method), pullParser); } public static void get(String uri, HashMap<String,String> map, OnAccessListener onAccessListener) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpGet method = new HttpGet(fulluri); BufferedInputStream is = new BufferedInputStream(doRequest(method).getContent()); try { onAccessListener.onAccess(is, uri); } finally{ is.close(); } } public static String post(String uri, HashMap<String,String> map) throws ClientProtocolException, IOException { HttpPost method = new HttpPost(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } return EntityUtils.toString(doRequest(method)); } public static Document post(String uri, HashMap<String,String> map, DocumentBuilder builder) throws ClientProtocolException, IOException, SAXException { HttpPost method = new HttpPost(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } return getDOM(doRequest(method), builder); } public static void post(String uri, HashMap<String,String> map, DefaultHandler handler) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { HttpPost method = new HttpPost(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } parseBySAX(doRequest(method), handler); } public static void post(String uri, HashMap<String,String> map, CustomPullParser pullParser) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { HttpPost method = new HttpPost(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } parseByPullParser(doRequest(method), pullParser); } public static String put(String uri, HashMap<String,String> map) throws ClientProtocolException, IOException { HttpPut method = new HttpPut(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } return EntityUtils.toString(doRequest(method)); } public static Document put(String uri, HashMap<String,String> map, DocumentBuilder builder) throws ClientProtocolException, IOException, SAXException { HttpPut method = new HttpPut(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } return getDOM(doRequest(method), builder); } public static void put(String uri, HashMap<String,String> map, DefaultHandler handler) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { HttpPut method = new HttpPut(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } parseBySAX(doRequest(method), handler); } public static void put(String uri, HashMap<String,String> map, CustomPullParser pullParser) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { HttpPut method = new HttpPut(uri); if(null != map){ List<NameValuePair> paramList = packEntryParams(map); method.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8)); } parseByPullParser(doRequest(method), pullParser); } public static String delete(String uri, HashMap<String,String> map) throws ClientProtocolException, IOException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpDelete method = new HttpDelete(fulluri); return EntityUtils.toString(doRequest(method)); } public static Document delete(String uri, HashMap<String,String> map, DocumentBuilder builder) throws ClientProtocolException, IOException, SAXException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpDelete method = new HttpDelete(fulluri); return getDOM(doRequest(method), builder); } public static void delete(String uri, HashMap<String,String> map, DefaultHandler handler) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpDelete method = new HttpDelete(fulluri); parseBySAX(doRequest(method), handler); } public static void delete(String uri, HashMap<String,String> map, CustomPullParser pullParser) throws ClientProtocolException, IOException, SAXException, IllegalStateException, ParserConfigurationException { String fulluri; if(null == map){ fulluri = uri; } else { fulluri = uri + packQueryString(map); } HttpDelete method = new HttpDelete(fulluri); parseByPullParser(doRequest(method), pullParser); }  public static Node removeEmptyNodes(Node currentNode) { NodeList list = currentNode.getChildNodes(); int n = list.getLength(); if(0 < n){ for (int i = 0; i < n; i++) { Node childNode = list.item(i); String value = childNode.getNodeValue(); "}
{"name": "maimuzo/android_utils", "content": "package net.it4myself.util; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import android.content.ContentValues; import android.content.Context; import android.database.Cursor; import android.database.SQLException; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.database.sqlite.SQLiteQueryBuilder; import android.util.Log; public class Settings { private static final String TAG = \"Settings\"; private static final int DB_VERSION = 1; private static final String DEFAULT_DB_NAME = \"settings.db\"; private static String db_name = DEFAULT_DB_NAME; private static final String TABLE_NAME = \"settings\"; private HashMap<String,String> map = new HashMap<String,String>(); private static class DatabaseHelper extends SQLiteOpenHelper { DatabaseHelper(Context context) { super(context, db_name, null, DB_VERSION); } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(\"create table \" + TABLE_NAME + \" (\" + \"key TEXT primary key, \" + \"value TEXT\" + \");\"); db.execSQL(\"insert into \" + TABLE_NAME + \"(key, value) values('seed', '\" + MakeKey() + \"')\"); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { Log.w(TAG, \"Upgrading database.\" + TABLE_NAME + \" from version \" + oldVersion + \" to \" + newVersion + \", which will destroy all old data\"); db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_NAME); onCreate(db); } private static String MakeKey(){ MessageDigest digest; try { digest = MessageDigest.getInstance(\"MD5\"); return digest.digest(Long.toBinaryString(System.currentTimeMillis()).getBytes()).toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return \"\"; } } public static final int COLUMN_INDEX_KEY = 0; public static final int COLUMN_INDEX_VALUE = 1; private static final String[] PROJECTION = new String[] { \"key\", \"value\" }; private DatabaseHelper mOpenHelper; public Settings(Context context, String special_db_name){ if(null != special_db_name) { db_name = special_db_name; } mOpenHelper = new DatabaseHelper(context); restore(); } public void set(String key, String value){ map.put(key, value); if(hasKeyInDB(key)){ updateDB(key, value); } else { insertToDB(key, value); } } public String get(String key){ return map.get(key); } public int delete(String key){ map.remove(key); SQLiteDatabase db = mOpenHelper.getWritableDatabase(); return db.delete(TABLE_NAME, \"key = ?\", new String[] {key}); } public List<String> keysInDB(){ List<String> result = new ArrayList<String>(); SQLiteDatabase db = mOpenHelper.getReadableDatabase(); Cursor cursor = db.rawQuery(\"SELECT key FROM \" + TABLE_NAME, null); while(cursor.moveToNext()){ result.add(cursor.getString(COLUMN_INDEX_KEY)); } return result; } private void restore(){ SQLiteDatabase db = mOpenHelper.getReadableDatabase(); Cursor cursor = db.rawQuery(\"SELECT key, value FROM \" + TABLE_NAME, null); while(cursor.moveToNext()){ map.put(cursor.getString(COLUMN_INDEX_KEY), cursor.getString(COLUMN_INDEX_VALUE)); } } private long insertToDB(String key, String value){ ContentValues values = new ContentValues(); values.put(\"key\", key); values.put(\"value\", value); SQLiteDatabase db = mOpenHelper.getWritableDatabase(); long rowId = db.insert(TABLE_NAME, \"DEFAULT\",values); if (rowId > 0) { return rowId; } throw new SQLException(\"Failed to insert location\"); } private boolean updateDB(String key, String value){ ContentValues values = new ContentValues(); values.put(\"value\", value); SQLiteDatabase db = mOpenHelper.getWritableDatabase(); int num = db.update(TABLE_NAME, values, \"key = ?\", new String[] {key}); if(0 < num){ return true; } else { return false; } } public boolean hasKeyInDB(String key){ SQLiteQueryBuilder qb = new SQLiteQueryBuilder(); String[] selectionArgs = new String[] {key}; qb.setTables(TABLE_NAME); SQLiteDatabase db = mOpenHelper.getReadableDatabase(); Cursor cursor = qb.query(db, PROJECTION, \"key = ?\", selectionArgs, null, null, null, null); if(1 == cursor.getCount()){ return true; }else{ return false; } } public boolean hasKeyInMap(String key){ return map.containsKey(key); } }"}
{"name": "maimuzo/android_utils", "content": "package net.it4myself.util; import android.app.Activity; import android.os.Bundle; public class androidUtils extends Activity {  @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm;  import java.awt.BorderLayout; import java.awt.Dimension; import java.awt.Font; import java.awt.event.ActionEvent; import java.util.ArrayList; import java.util.List; import javax.swing.AbstractAction; import javax.swing.JButton; import javax.swing.JComponent; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTabbedPane; import javax.swing.JTextArea; import javax.swing.SwingUtilities; import ajm.maxsupport.AbstractMaxObject; import ajm.util.TextBlock; import ajm.util.Utils; import com.cycling74.max.Atom;  public class code extends AbstractMaxObject { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm;  import java.util.List; import ajm.maxsupport.AbstractMaxRubyObject; import ajm.seqsupport.Item; import ajm.seqsupport.Parser; import ajm.util.Utils; import com.cycling74.max.Atom; import com.cycling74.max.Executable;  public class eval extends AbstractMaxRubyObject { Parser parser = new Parser(); public eval(Atom[] args) { declareIO(1, 1); setInletAssist(new String[] { \"message\" }); setOutletAssist(new String[] { \"evaluated message\" }); "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.maxsupport;  import java.io.PrintStream; import ajm.util.Logger; import com.cycling74.max.Executable; import com.cycling74.max.MaxObject; import com.cycling74.max.MaxQelem;  public abstract class AbstractMaxObject extends MaxObject implements Logger { protected boolean verbose = false; protected boolean initialized = false; protected MaxQelem initializer = getInitializerQelem(); "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.maxsupport;  import org.jruby.CompatVersion; import com.cycling74.max.*; import ajm.rubysupport.*; import ajm.util.Utils;  public abstract class AbstractMaxRubyObject extends AbstractMaxObject { protected String context = null; protected String id = defaultId(); private boolean autoinit = false; protected Atom[] rubyVersionValue; protected CompatVersion rubyVersion; protected MaxRubyAdapter ruby; protected AbstractMaxRubyObject self = this; public AbstractMaxRubyObject() { super(); declareAttribute(\"context\", \"getcontext\", \"context\"); declareAttribute(\"id\", \"getid\", \"id\"); declareAttribute(\"autoinit\"); declareAttribute(\"ruby_version\", \"getruby_version\", \"ruby_version\"); } @Override protected Executable getInitializer() { return new DefaultRubyInitializer(); } protected class DefaultRubyInitializer extends DefaultInitializer { @Override public void execute() { super.execute(); try { ruby = new MaxRubyAdapter(self, context, id, rubyVersion); } catch (IdInUseException e) { String availableId = e.getMessage(); error(\"id \" + id + \" not available. Using: \" + availableId); id = availableId; ruby = new MaxRubyAdapter(self, context, id, rubyVersion); } if (autoinit) { ruby.init();  } } } public Atom[] getcontext() { return Atom.newAtom(new String[]{context}); } public String context() { return context; } public void context(Atom[] params) { String context = Utils.toString(params); this.context = context; if (ruby != null) { ruby.setContext(context); } "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.maxsupport; import com.cycling74.max.Atom;  public interface Atomizer { Atom toAtom(); }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm;  import java.util.ArrayList; import java.util.List; import ajm.seqsupport.Item; import ajm.util.Utils; import com.cycling74.max.Atom;  public class preemptrseq extends rseq { List<Item> actualSeq = new ArrayList<Item>(); public preemptrseq(Atom[] args) { super(args); } @Override public void set(Atom[] list) { try { List<Item> newSeq = parser.parse(list); actualSeq.clear(); actualSeq.addAll(newSeq); setPreemptiveSeq(); onSeqChange(); } catch (IllegalStateException e) { err(\"Could not evaluate: \" + Utils.detokenize(list) + \"\\n\" + e.getMessage()); } } "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm; import com.cycling74.max.Atom; import ajm.maxsupport.AbstractMaxObject; import ajm.util.Utils; public class print extends AbstractMaxObject { private boolean onlyanything = false; private boolean detokenize = false; public print() { declareAttribute(\"onlyanything\"); declareAttribute(\"detokenize\"); declareIO(1, 0); createInfoOutlet(false); } public void inlet(float value) { if (onlyanything) { super.inlet(value); } else { System.out.println(\"Recieved a float: \" + value); } } public void inlet(int value) { if (onlyanything) { super.inlet(value); } else { System.out.println(\"Recieved an int: \" + value); } } public void list(Atom[] list) { if (onlyanything) { super.list(list); } else { System.out.println(\"Received a list of length \" + list.length + (list.length > 0 ? \":\" : \".\")); dumpList(list); } } public void anything(String msg, Atom[] args) { System.out.println(\"Received message '\" + (detokenize ? Utils.detokenize(msg) : msg) + \"' with \" + args.length + \" arguments\" + (args.length > 0 ? \":\" : \".\")); dumpList(args); } private void dumpList(Atom[] list) { for (Atom atom : list) { if (atom == null) { System.out.println(\" null (might have been a semicolon?)\"); } else if (atom.isInt()) { System.out.println(\" int: \" + atom.getInt()); } else if (atom.isFloat()) { System.out.println(\" float: \" + atom.getFloat()); } else { System.out.println(\" string: '\" + (detokenize ? Utils.detokenize(atom.getString()) : atom.getString()) + \"'\"); } } } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm;  import java.util.Arrays; import ajm.seqsupport.Item; import com.cycling74.max.Atom; import com.cycling74.max.Executable;  public class rseq extends seq { public rseq(Atom[] args) { super(args); "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm;  import java.io.File; import java.io.IOException; import java.util.Date; import ajm.maxsupport.AbstractMaxRubyObject; import ajm.rubysupport.SymbolConversionOption; import ajm.util.FileWatcher; import ajm.util.TextBlock; import ajm.util.Utils; import com.cycling74.max.Atom; import com.cycling74.max.Executable; import com.cycling74.max.MaxPatcher; import com.cycling74.max.MaxSystem;  public class ruby extends AbstractMaxRubyObject { private String scriptFilePath; private File scriptFile; private Atom[] scriptFileArgs; private int evalOutlet = -1; private boolean autowatch = false; private FileWatcher fileWatcher; private String[] symbolsTo; private SymbolConversionOption[] symbolConversionOptions;  public ruby(Atom[] args) { super(); declareAttribute(\"evalout\", \"getevalout\", \"evalout\"); declareAttribute(\"evaloutlet\", \"getevalout\", \"evalout\"); "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;  import java.util.HashMap; import java.util.Map;  public abstract class AbstractScriptEvaluator implements ScriptEvaluator { private boolean initialized = false; private Map<String, Object> persitentGlobals = new HashMap<String, Object>(); protected abstract void resetEngineContext(); protected abstract void declareGlobalInternal(String variableName, Object obj) throws Exception; protected abstract void undeclareGlobalInternal(String variableName) throws Exception; public void resetContext() { resetEngineContext(); try { for (Map.Entry<String, Object> global : persitentGlobals.entrySet()) { String name = global.getKey(); undeclareGlobalInternal(name); declareGlobalInternal(name, global.getValue()); } } catch (Exception e) { throw new RubyException(e); } } public boolean isInitialized() { return initialized; } public void setInitialized(boolean initialized) { this.initialized = initialized; } public void declareGlobal(String variableName, Object obj) { try { declareGlobalInternal(variableName, obj); } catch (Exception e) { throw new RubyException(e); } persitentGlobals.put(variableName, obj); } public void undeclareGlobal(String variableName) { try { undeclareGlobalInternal(variableName); } catch (Exception e) { throw new RubyException(e); } persitentGlobals.remove(variableName); } public void setScriptFilename(String scriptFilename) { } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;  import org.apache.bsf.BSFException; import org.apache.bsf.BSFManager; import org.jruby.CompatVersion;  public class BSFRubyEvaluator extends AbstractScriptEvaluator { private BSFManager manager; public BSFRubyEvaluator(CompatVersion version) { BSFManager.registerScriptingEngine(\"ruby\", \"org.jruby.javasupport.bsf.JRubyEngine\", new String[] { \"rb\" }); resetEngineContext(); } protected void resetEngineContext() { manager = new BSFManager(); } protected void declareGlobalInternal(String variableName, Object obj) throws BSFException { manager.declareBean(variableName, obj, obj.getClass()); } protected void undeclareGlobalInternal(String variableName) throws BSFException { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;   @SuppressWarnings(\"serial\") public class IdInUseException extends RuntimeException { public IdInUseException(String availableId) { super(availableId); } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport; import org.jruby.CompatVersion; import org.jruby.embed.ScriptingContainer; import org.jruby.embed.LocalContextScope; import org.jruby.embed.LocalVariableBehavior; public class JRubyEmbedEvaluator extends AbstractScriptEvaluator { private ScriptingContainer container; private CompatVersion compatVersion; public JRubyEmbedEvaluator(CompatVersion rubyVersion) { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;  import java.io.File; import java.io.IOException; import java.math.BigInteger; import org.jruby.*; import ajm.maxsupport.Atomizer; import ajm.util.GlobalVariableStore; import ajm.util.LineBuilder; import ajm.util.Logger; import ajm.util.Utils; import com.cycling74.max.Atom; import com.cycling74.max.MaxObject;  public class MaxRubyAdapter { public static final String NIL = \"nil\"; private ScriptEvaluator ruby; private LineBuilder code = new LineBuilder(); private LineBuilder scriptFileInit = new LineBuilder(); private final MaxObject maxObject; private Logger logger; private String maxContext; private String id; private CompatVersion rubyVersion; public MaxRubyAdapter(MaxObject maxObject, String context, String id, CompatVersion rubyVersion) { this.maxObject = maxObject; if (maxObject instanceof Logger) { this.logger = (Logger) maxObject; } this.maxContext = context; this.id = id; this.rubyVersion = rubyVersion; getEvaluator(); } private void getEvaluator() { ruby = ScriptEvaluatorManager.getRubyEvaluator(maxContext, id, maxObject, rubyVersion); ruby.declareGlobal(\"max_ruby_adapter\", this); ruby.declareGlobal(\"global_variable_store\", GlobalVariableStore.getInstance()); } public Logger getLogger() { return logger; } public void setLogger(Logger logger) { this.logger = logger; } public String getContext() { return maxContext; } public void setContext(String context) { if (!Utils.equals(this.maxContext, context)) { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;   @SuppressWarnings(\"serial\") public class RubyException extends RuntimeException { public RubyException() { super(); } public RubyException(String message, Throwable cause) { super(message, cause); } public RubyException(String message) { super(message); } public RubyException(Throwable cause) { super(cause); } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;  import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.util.Properties; import org.jruby.CompatVersion; import com.cycling74.max.MaxSystem;  public class RubyProperties { public static Properties properties; public static final String DEFAULT_RUBY_ENGINE = \"ajm.rubysupport.JRubyEmbedEvaluator\"; public static final String DEFAULT_INITIALIZER_FILES = \"ajm_ruby_initialize.rb\"; private static String rubyEngine; private static String[] initializers; private static String[] loadpaths; public static String getRubyEngine() { if (rubyEngine == null) { rubyEngine = properties.getProperty(\"ruby.engine\", DEFAULT_RUBY_ENGINE).trim(); } return rubyEngine; } public static String[] getInitializerFiles() { if (initializers == null) { initializers = properties.getProperty(\"ruby.initializers\", DEFAULT_INITIALIZER_FILES).split(\";\"); for (int i = 0; i < initializers.length; i++) { initializers[i] = initializers[i].trim(); } } return initializers; } public static String[] getLoadPaths() { if (loadpaths == null) { String loadpathsProp = properties.getProperty(\"ruby.loadpaths\"); if (loadpathsProp == null || loadpathsProp.trim().equals(\"\")) { loadpaths = new String[] {}; } else { loadpaths = loadpathsProp.split(\";\"); for (int i = 0; i < loadpaths.length; i++) { loadpaths[i] = loadpaths[i].trim(); } } } return loadpaths; } static { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;   public interface ScriptEvaluator { void resetContext(); boolean isInitialized(); void setInitialized(boolean initialized); void declareGlobal(String variableName, Object obj); void undeclareGlobal(String variableName); void setScriptFilename(String scriptFilename); Object eval(CharSequence rubyCode); void exit(); }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;  import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Set; import org.jruby.CompatVersion; import ajm.util.MappedSet;  public class ScriptEvaluatorManager { private static Map<String, ScriptEvaluator> evaluatorContexts = new HashMap<String, ScriptEvaluator>(); private static Map<String, Integer> evaluatorContextCounter = new HashMap<String, Integer>(); "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.rubysupport;  public enum SymbolConversionOption {  STRING (\"string\"),  SYMBOL (\"symbol\"),  LITERAL (\"literal\"),  REMAINING_INLETS (\"*\"); public static SymbolConversionOption DEFAULT = LITERAL; SymbolConversionOption(String stringValue) { this.stringValue = stringValue; }  public String toString() { return stringValue; } private final String stringValue; public static SymbolConversionOption fromString(String stringValue) { if(STRING.stringValue.equals(stringValue)) { return STRING; } else if(SYMBOL.stringValue.equals(stringValue)) { return SYMBOL; } else if(LITERAL.stringValue.equals(stringValue)) { return LITERAL; } else if(REMAINING_INLETS.stringValue.equals(stringValue)) { return REMAINING_INLETS; } else { return null; } } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm;  import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.TreeSet; import ajm.maxsupport.AbstractMaxRubyObject; import ajm.rubysupport.MaxRubyAdapter; import ajm.seqsupport.Item; import ajm.seqsupport.Parser; import ajm.seqsupport.Token; import ajm.util.Utils; import com.cycling74.max.Atom; import com.cycling74.max.Executable;  public class seq extends AbstractMaxRubyObject { public seq(Atom[] args) { declareAttribute(\"seq\", \"getseq\", \"seq\"); declareAttribute(\"index\", \"getindex\", \"index\"); declareAttribute(\"cmode\", \"getchordmode\", \"chordmode\"); declareAttribute(\"iter\", \"getiter\", \"iter\"); declareAttribute(\"step\", \"getstep\", \"step\"); declareAttribute(\"autooutputseq\"); declareIO(1, 4); setInletAssist(new String[] { \"list / bang / commands\" }); setOutletAssist(new String[] { \"value\", \"index\", \"iteration\", \"sequence\" }); } @Override protected Executable getInitializer() { return new SeqInitializer(); } protected class SeqInitializer extends DefaultRubyInitializer { @Override public void execute() { super.execute(); parser.setRubyEvaluator(ruby); "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.seqsupport;  import ajm.maxsupport.Atomizer; import ajm.rubysupport.MaxRubyAdapter; import com.cycling74.max.Atom;  public class Item implements Comparable<Item>, Atomizer { public static final String INFINITY = \"INF\"; public static final String NEG_INFINITY = \"-INF\"; private Atom atom; private Atom[] atoms; private String rubyCode; private MaxRubyAdapter ruby; private boolean infinite = false; private boolean reeval = true; private Item() { } public Item(Atom atom) { this.atom = atom; } public Item(int i) { this.atom = Atom.newAtom(i); } public Item(float f) { this.atom = Atom.newAtom(f); } public Item(String s) { infinite = INFINITY.equalsIgnoreCase(s) || NEG_INFINITY.equalsIgnoreCase(s); if (infinite) { s = s.toUpperCase(); } this.atom = Atom.newAtom(s); } public Item(String rubyCode, MaxRubyAdapter ruby) { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.seqsupport;  import static ajm.seqsupport.Parser.STATE.*; import static ajm.seqsupport.Token.TYPE.*; import java.io.PrintStream; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Stack; import ajm.rubysupport.MaxRubyAdapter; import com.cycling74.max.Atom;  public class Parser { public Parser() { evalNotes = true; } private MaxRubyAdapter ruby; public void setRubyEvaluator(MaxRubyAdapter ruby) { this.ruby = ruby; } enum STATE { CHORD, REPETITION, RUBY, DEFAULT; } private boolean evalNotes = true; private CharSequence input; private int index; private boolean lookedAhead; private Token token; Stack<STATE> states = new Stack<STATE>(); private Stack<List<Item>> scopes = new Stack<List<Item>>(); private List<Item> topScope = new ArrayList<Item>(); private List<Item> currentScope; public List<Item> parse(Atom[] list) { return parse(null, list); } public List<Item> parse(String msg, Atom[] args) { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.seqsupport;  import com.cycling74.max.Atom;  public class Token { public enum TYPE { REPEAT_BEGIN, REPEAT_END, REPEAT_STAR, CHORD_BEGIN, CHORD_END, NEXT, PREV, RUBY_BEGIN, RUBY_END, TEXT; } private TYPE type; private String text; public Token(TYPE type) { this(type, null); } public Token(TYPE type, String text) { this.type = type; this.text = text; } public TYPE getType() { return type; } public int getInt() { return Integer.parseInt(text); } public String getText() { return text; } public Item getItem() { try { if (text.contains(\".\")) { return new Item(Float.parseFloat(text)); } else { return new Item(Integer.parseInt(text)); } } catch (NumberFormatException e) { return new Item(text); } } public Atom getAtom() { try { if (text.contains(\".\")) { return Atom.newAtom(Float.parseFloat(text)); } else { return Atom.newAtom(Integer.parseInt(text)); } } catch (NumberFormatException e) { return Atom.newAtom(text); } } public Atom getValue() { int val; switch (Character.toUpperCase(text.charAt(0))) { case 'C': val = 0; break; case 'D': val = 2; break; case 'E': val = 4; break; case 'F': val = 5; break; case 'G': val = 7; break; case 'A': val = 9; break; case 'B': val = 11; break; default: return getAtom(); } int i = 1; int quarterSteps = 0; loop: for (; i < text.length(); i++) { switch (text.charAt(i)) { case '#': val++; break; case 'b': val--; break; case '+': quarterSteps++; break; case '_': quarterSteps--; break; default: break loop; } } try { int octave = Integer.parseInt(text.substring(i)); val += (octave + 1) * 12; "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util; import com.cycling74.max.MaxObject;  public class DummyMaxObject extends MaxObject { }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util;  import java.io.File; import com.cycling74.max.Executable;  public class FileWatcher extends Thread { public final static long DEFAULT_WATCH_PERIOD = 2500; "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util;  import java.util.HashMap; import java.util.Map; import java.util.Set;  public class GlobalVariableStore { private static GlobalVariableStore instance; private GlobalVariableStore() { } public synchronized static GlobalVariableStore getInstance() { if (instance == null) { instance = new GlobalVariableStore(); } return instance; } private Map<String, Object> variableStore = new HashMap<String, Object>(); public synchronized Object get(String name) { return variableStore.get(name); } public synchronized Object set(String name, Object value) { return variableStore.put(name, value); } public synchronized boolean delete(String name) { Object value = variableStore.remove(name); return value != null; } public synchronized boolean defined(String name) { return variableStore.containsKey(name); } public synchronized Set<String> names() { return variableStore.keySet(); } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util;   public class LineBuilder implements CharSequence { private StringBuilder lines = new StringBuilder(); public void line(String s) { lines.append(s).append(\"\\n\"); } public void append(String s) { lines.append(s); } public String toString() { return lines.toString(); } public boolean isEmpty() { return lines.length() == 0; } public int length() { return lines.length(); } public void clear() { lines.setLength(0); } public char charAt(int index) { return lines.charAt(index); } public CharSequence subSequence(int start, int end) { return lines.subSequence(start, end); } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util;   public interface Logger { void debug(String message); void info(String message); void err(String message); }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util;  import java.util.LinkedHashSet; import java.util.Set; import java.util.TreeMap;  @SuppressWarnings(\"serial\") public class MappedSet<K, T> extends TreeMap<K, Set<T>> { public Set<T> addValue(K key, T value) { Set<T> values = get(key); if (values == null) { "}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util;  import java.util.HashMap; import java.util.Map;  public class TextBlock { private static Map<String, String> textMap = new HashMap<String, String>(); private TextBlock() { } public synchronized static void set(String name, String text) { textMap.put(name, text); } public synchronized static String get(String name) { return textMap.get(name); } public synchronized static void remove(String name) { textMap.remove(name); } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util;  import java.awt.BorderLayout; import java.awt.Dimension; import java.awt.Font; import java.awt.Toolkit; import javax.swing.JFrame; import javax.swing.JScrollPane; import javax.swing.JTextArea; import javax.swing.SwingUtilities;  public class TextViewer { private JFrame frame; private JTextArea textArea; private boolean packed = false; private int width; private int height; Dimension dim; public TextViewer(String name) { frame = new JFrame(name); frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE); width = 600; height = 450; textArea = new JTextArea(); textArea.setEditable(false); textArea.setFont(new Font(\"Monospaced\", Font.PLAIN, 11)); JScrollPane scroller = new JScrollPane(textArea); scroller.setPreferredSize(new Dimension(width, height)); frame.add(scroller, BorderLayout.CENTER); } public void show() { SwingUtilities.invokeLater(new Runnable() { public void run() { if(!packed) { frame.pack(); packed = true; } frame.setVisible(true); } }); } public void hide() { frame.setVisible(false); } public void setText(String text) { textArea.setText(text); } private int WINDOW_PADDING = 10; public void setCenter(int x, int y) { x -= width/2; y -= height/2; if(x < WINDOW_PADDING) x = WINDOW_PADDING; if(y < WINDOW_PADDING) y = WINDOW_PADDING; Toolkit toolkit = Toolkit.getDefaultToolkit(); Dimension resolution = toolkit.getScreenSize(); int maxX = resolution.width - width - WINDOW_PADDING; int maxY = resolution.height - height - WINDOW_PADDING; if(x > maxX) x = maxX; if(y > maxY) y = maxY; frame.setLocation(x,y); } }"}
{"name": "adamjmurray/ajm_objects", "content": "package ajm.util; import java.io.*; import java.util.Collection; import ajm.maxsupport.Atomizer; import com.cycling74.max.Atom; import com.cycling74.max.MaxPatcher; import com.cycling74.max.MaxSystem;   public class Utils { private Utils() { } public static boolean equals(Object o1, Object o2) { if (o1 == null) { return o2 == null; } else { return o1.equals(o2); } }  public static String toString(Object obj) { return (obj == null ? null : obj.toString()); }  public static String toString(Atom[] atoms) { String s = \"\"; if(atoms != null) { for(int i=0; i< atoms.length; i++) { if(i > 0) { s += \" \"; } s += atoms[i].toString(); } } return s; } public static Atom[] toAtoms(Collection<? extends Atomizer> objs) { Atom[] atoms = new Atom[objs.size()]; int i = 0; for (Atomizer obj : objs) { atoms[i] = obj.toAtom(); i++; } return atoms; } public static boolean isNumber(Atom atom) { return atom.isInt() || atom.isFloat(); } public static String detokenize(Atom[] args) { return detokenize(null, args); } public static String detokenize(String msg, Atom[] args) { StringBuilder input = new StringBuilder(); if (msg != null) { input.append(detokenize(msg)).append(\" \"); } for (int i = 0; i < args.length; i++) { if (i > 0) { input.append(\" \"); } input.append(detokenize(args[i])); } return input.toString(); } public static String detokenize(Atom atom) { if (atom == null) { return \"\"; } return detokenize(atom.toString()); } public static String detokenize(String str) { if (str.contains(\" \")) { return '\"' + str + '\"'; } else { return str; } }  public static File getFile(String path) { return getFile(path, null); }  public static File getFile(String path, MaxPatcher patcher) { return getFile(path, patcher, false); } public static File getFile(String path, MaxPatcher patcher, boolean suppressError) { if (path == null || path.length() == 0) { path = MaxSystem.openDialog(); if(path == null) { return null; "}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2009 Myriad Group AG. * Copyright (C) 2009 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/** * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not * use this file except in compliance with the License. You may obtain a copy of * the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2009 Myriad Group AG * Copyright (C) 2009 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 Esmertec AG. * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "aosp-mirror/platform_packages_apps_im", "content": "/* * Copyright (C) 2007-2008 Esmertec AG. * Copyright (C) 2007-2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.regex.Matcher; import java.util.regex.Pattern; public class Commit { private static final Integer MAXIMUM_AUTHOR_LENGTH = 32; Collection<NameAndStatus> changes = new ArrayList<NameAndStatus>(); String hash, author, message; Date date; public Commit() { this.message = \"\"; } public Commit(String hash, String author, Date date) { this.hash = hash; this.author = author; this.date = date; this.message = \"\"; } public Collection<NameAndStatus> getChanges() { return changes; } public String getHash() { return hash; } public String getAuthor() { return author; } public Date getDate() { return date; } public String getMessage() { return message; } public void setHash(String hash) { this.hash = hash; } public void setAuthor(String author) { this.author = author; } public void setMessage(String message) { this.message = message; } public void setDate(Date date) { this.date = date; } public VersionNumber getVersion() { return new VersionNumber(getHash(), getDate()); } @Override public String toString() { return \"Commit<\" + getHash() + \", \" + getAuthor() + \", \" + getDate() + \", NumberChanges=\" + getChanges().size() + \", Version=\" + getVersion() + \">\"; } public boolean isValid() { return this.author != null && this.date != null && this.hash != null; } public String getShortAuthor() { Pattern pattern = Pattern.compile(\"([^\\\\s><]+)@\\\\S+\"); Matcher m = pattern.matcher(this.author); if (m.find()) { return m.group(1); } if (author.length() > MAXIMUM_AUTHOR_LENGTH) { return author.substring(0, MAXIMUM_AUTHOR_LENGTH); } return author; } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import java.text.SimpleDateFormat; import java.util.Locale; public class Constants { private static final String GIT_DATE_FORMAT = \"EEE MMM dd HH:mm:ss yyyy Z\"; private static final String VERSION_DATE_FORMAT = \"MM/dd/yyyy HH:mm:ss\"; public static final SimpleDateFormat GIT_DATE = new SimpleDateFormat(Constants.GIT_DATE_FORMAT, Locale.US); public static final SimpleDateFormat VERSION_DATE = new SimpleDateFormat(Constants.VERSION_DATE_FORMAT, Locale.US); }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import java.util.Comparator; public class GitComparator implements Comparator<String> { public int compare(String o1, String o2) { if (o1.equals(o2)) { return 0; } else { VersionNumber v1 = new VersionNumber(o1); VersionNumber v2 = new VersionNumber(o2); return v1.getDate().compareTo(v2.getDate()); } } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import java.io.File; import jetbrains.buildServer.vcs.VcsRoot; public class GitConfiguration { public static final String CLONE_URL = \"clone_url\"; public static final String BRANCH = \"branch\"; public static final String SERVER_PROJECT_DIRECTORY = \"server_project_directory\"; File workingDirectory; File projectDirectory; File command; String url; String branch; public File getWorkingDirectory() { return workingDirectory; } public File getProjectDirectory() { return projectDirectory; } public File getCommand() { return command; } public String getUrl() { return url; } public String getBranch() { return branch; } public String getRemoteBranch() { return \"origin/\" + getBranch(); } public boolean isProjectDirectoryARepository() { return new File(getProjectDirectory(), \".git\").exists(); } public GitConfiguration(File command, File workingDirectory, File projectDirectory, String url, String ref) { super(); this.command = command; this.workingDirectory = workingDirectory; this.projectDirectory = projectDirectory; this.url = url; this.branch = ref; } public static GitConfiguration createAgentConfiguration(VcsRoot root, File project) { File working = project.getParentFile(); String url = root.getProperty(CLONE_URL); String branch = root.getProperty(BRANCH); return new GitConfiguration(inferGitCommand(), working, project, url, branch); } public static GitConfiguration createServerConfiguration(VcsRoot root) { File project = new File(root.getProperty(SERVER_PROJECT_DIRECTORY)); File working = project.getParentFile(); if (!working.exists()) { working.mkdirs(); } String url = root.getProperty(CLONE_URL); String branch = root.getProperty(BRANCH); return new GitConfiguration(inferGitCommand(), working, project, url, branch); } private static File inferGitCommand() { String[] defaults = new String[] { \"C:\\\\Program Files\\\\Git\\\\Cmd\\\\git-debug.cmd\", \"C:\\\\Program Files\\\\Git\\\\Cmd\\\\git.cmd\", \"C:\\\\Program Files (x86)\\\\Cmd\\\\git-debug.cmd\", \"C:\\\\Program Files (x86)\\\\Cmd\\\\git.cmd\", \"/usr/bin/git\", }; for (String path: defaults) { File file = new File(path); if (file.exists()) { return file; } } throw new RuntimeException(\"Unable to infer path to Git executable!\"); } public String toString() { return String.format(\"%s:%s\", this.url, this.branch); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import jetbrains.buildServer.vcs.*; import jetbrains.buildServer.vcs.patches.PatchBuilder; import jetbrains.buildServer.Used; import jetbrains.buildServer.AgentSideCheckoutAbility; import jetbrains.buildServer.CollectChangesByIncludeRule; import jetbrains.buildServer.serverSide.PropertiesProcessor; import jetbrains.buildServer.serverSide.InvalidProperty; import java.util.*; import java.io.IOException; import org.hivedb.teamcity.plugin.commands.CloneCommand; import org.hivedb.teamcity.plugin.commands.FetchCommand; import org.hivedb.teamcity.plugin.commands.LogCommand; import org.hivedb.teamcity.plugin.commands.ShowCommand; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import org.apache.log4j.Logger; import jetbrains.buildServer.web.openapi.WebResourcesManager; public class GitVcs extends VcsSupport implements AgentSideCheckoutAbility, VcsPersonalSupport, CollectChangesByIncludeRule { Logger log = Logger.getLogger(GitVcs.class); public GitVcs(VcsManager vcsmanager, WebResourcesManager resourcesManager) { vcsmanager.registerVcsSupport(this); resourcesManager.addPluginResources(\"git\", \"git-vcs.jar\"); } public String getCurrentVersion(VcsRoot root) throws VcsException { log.warn(\"Getting current version\"); GitConfiguration configuration = GitConfiguration.createServerConfiguration(root); if (!configuration.isProjectDirectoryARepository()) { new CloneCommand(configuration).run(false); } else { new FetchCommand(configuration).run(); } LogCommand getLog = new LogCommand(configuration); Commit head = getLog.head(); if (head == null) { log.warn(\"No current version!\"); return null; } log.warn(\"Version: \" + head); return head.getVersion().toString(); } public String getVersionDisplayName(String version, VcsRoot root) throws VcsException { log.warn(\"Getting version display name: \" + version); return version; } public List<ModificationData> collectBuildChanges(VcsRoot root, String fromVersion, String toVersion, IncludeRule includeRule) throws VcsException { log.warn(String.format(\"Getting build changes from %s to %s\", fromVersion, toVersion)); List<ModificationData> modifications = new ArrayList<ModificationData>(); VersionNumber from = new VersionNumber(fromVersion); VersionNumber to = new VersionNumber(toVersion); if (from.equals(to)) { return modifications; } GitConfiguration configuration = GitConfiguration.createServerConfiguration(root); LogCommand logCommand = new LogCommand(configuration); for (Commit commit : logCommand.between(from, to)) { log.info(commit); List<VcsChange> vcsChanged = new ArrayList<VcsChange>(); for (NameAndStatus change : commit.getChanges()) { log.info(change); vcsChanged.add(createChange(change, fromVersion, toVersion)); } modifications.add(new ModificationData(to.getDate(), vcsChanged, commit.getMessage(), commit.getShortAuthor(), root, to.toString(), to.toString())); } return modifications; } private VcsChange createChange(@NotNull NameAndStatus change, @NotNull String from, @NotNull String to) { switch (change.getStatus()) { case ADDED: "}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import com.intellij.openapi.vcs.AbstractVcs; import com.intellij.openapi.options.Configurable; import com.intellij.openapi.project.Project; import org.jetbrains.annotations.NonNls; public class GitVcsManager extends AbstractVcs { public GitVcsManager(Project project) { super(project); } @NonNls public String getName() { return \"Git\"; } @NonNls public String getDisplayName() { return \"Git\"; } public Configurable getConfigurable() { return null; } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import java.io.File; import jetbrains.buildServer.vcs.*; import jetbrains.buildServer.agent.vcs.CheckoutOnAgentVcsSupport; import jetbrains.buildServer.agent.BuildAgentConfiguration; import jetbrains.buildServer.agent.BuildProgressLogger; import org.apache.log4j.Logger; import org.hivedb.teamcity.plugin.commands.CheckoutCommand; import org.hivedb.teamcity.plugin.commands.CloneCommand; import org.hivedb.teamcity.plugin.commands.FetchCommand; public class GitVcsOnAgent implements CheckoutOnAgentVcsSupport { Logger log = Logger.getLogger(GitVcsOnAgent.class); public GitVcsOnAgent(BuildAgentConfiguration agentConf) { } public void updateSources(BuildProgressLogger logger, File workingDirectory, VcsRoot root, String version, IncludeRule includeRule) throws VcsException { GitConfiguration configuration = GitConfiguration.createAgentConfiguration(root, workingDirectory); if (!configuration.isProjectDirectoryARepository()) { workingDirectory.delete(); CloneCommand cmd = new CloneCommand(configuration); cmd.run(false); } else { FetchCommand cmd = new FetchCommand(configuration); cmd.run(); } new CheckoutCommand(configuration).forceCheckout(configuration.getRemoteBranch()); } public String getName() { return \"git\"; } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import org.jetbrains.annotations.NotNull; public class NameAndStatus { public static enum Status { ADDED(\"A\"), COPIED(\"C\"), DELETED(\"D\"), MODIFIED(\"M\"), RENAMED(\"R\"), UNMERGED(\"U\"), UNKNOWN(\"X\"), BROKEN(\"B\"); private final String myName; Status(@NotNull String name) { myName = name; } @NotNull public String getName() { return myName; } } private final String name; private final Status status; public String getName() { return name; } public Status getStatus() { return status; } public NameAndStatus(String name, String status) { super(); this.name = name; switch (status.charAt(0)) { case 'A': { this.status = Status.ADDED; break; } case 'C': { this.status = Status.COPIED; break; } case 'D': { this.status = Status.DELETED; break; } case 'M': { this.status = Status.MODIFIED; break; } case 'R': { this.status = Status.RENAMED; break; } case 'U': { this.status = Status.UNMERGED; break; } case 'X': { this.status = Status.UNKNOWN; break; } case 'B': { this.status = Status.BROKEN; break; } default: { assert false : \"unknown status: \" + status; this.status = Status.UNKNOWN; } } } public String toString() { return String.format(\"%s: %s\", status, name); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin; import java.text.ParseException; import java.util.Date; public class VersionNumber { private short MAXIMUM_LENGTH = 32; private String hash; private Date date; public VersionNumber(String version) { String[] fields = version.split(\"-\"); try { if (fields.length != 2) { throw new RuntimeException(\"Malformed Git Version: \" + version); } date = Constants.VERSION_DATE.parse(fields[1].trim()); hash = fields[0].trim(); } catch (ParseException e) { throw new RuntimeException(e); } } public VersionNumber(String hash, Date date) { this.hash = hash; this.date = date; } public String getHash() { return this.hash; } public Date getDate() { return this.date; } @Override public int hashCode() { return hash.hashCode(); } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; VersionNumber other = (VersionNumber) obj; return getHash().equals(other.getHash()); } @Override public String toString() { String datePart = \"-\" + Constants.VERSION_DATE.format(date); String hashPart = hash.substring(0, MAXIMUM_LENGTH - datePart.length()); return String.format(\"%s%s\", hashPart, datePart); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import java.io.BufferedReader; import java.io.IOException; import java.io.StringReader; import java.util.ArrayList; import java.util.List; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import com.intellij.execution.configurations.GeneralCommandLine; public class BranchCommand extends GitCommand { public BranchCommand(GitConfiguration configuration) { super(configuration); } public String[] local() throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"branch\"); cli.addParameter(\"--no-color\"); return parse(exec(cli).getStdout()); } public String[] remote() throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"branch\"); cli.addParameter(\"--no-color\"); cli.addParameter(\"-r\"); return parse(exec(cli).getStdout()); } public String[] remote(String remote) throws VcsException { List<String> branches = new ArrayList<String>(); for (String branch : remote()) { if (branch.startsWith(remote + \"/\")) { branches.add(branch.replaceAll(remote + \"/\", \"\")); } } return branches.toArray(new String[0]); } public void delete(String branch) throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"branch\"); cli.addParameter(\"--no-color\"); cli.addParameter(\"-D\"); cli.addParameter(branch); exec(cli); } public void track(String branch, String remote) throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"branch\"); cli.addParameter(branch); cli.addParameter(\"--no-color\"); cli.addParameter(\"--track\"); cli.addParameter(remote); exec(cli); } private String[] parse(String data) { List<String> branches = new ArrayList<String>(); BufferedReader r = new BufferedReader(new StringReader(data)); try { String line; while ((line = r.readLine()) != null) { line = line.trim(); if (line == null || line.equals(\"\")) { continue; } else { branches.add(line.substring(2)); } } } catch (IOException e) { throw new RuntimeException(e); } return branches.toArray(new String[0]); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import com.intellij.execution.configurations.GeneralCommandLine; public class CheckoutCommand extends GitCommand { public CheckoutCommand(GitConfiguration configuration) { super(configuration); } public void forceCheckout(String ref) throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"checkout\"); cli.addParameter(\"-f\"); cli.addParameter(ref); exec(cli); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import com.intellij.execution.configurations.GeneralCommandLine; public class CleanCommand extends GitCommand { public CleanCommand(GitConfiguration configuration) { super(configuration); } public void everything() throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"clean\"); cli.addParameter(\"-f\"); cli.addParameter(\"-d\"); exec(cli); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import com.intellij.execution.configurations.GeneralCommandLine; public class CloneCommand extends GitCommand { public CloneCommand(GitConfiguration configuration) { super(configuration); } protected boolean useProjectDirectory() { return false; } protected Integer getTimeout() { return 0; } public void run(boolean getWc) throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"clone\"); if (!getWc) { cli.addParameter(\"-n\"); } cli.addParameter(getConfiguration().getUrl()); cli.addParameter(getConfiguration().getProjectDirectory().getAbsolutePath()); exec(cli); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import com.intellij.execution.configurations.GeneralCommandLine; import jetbrains.buildServer.ExecResult; import jetbrains.buildServer.SimpleCommandLineProcessRunner; import jetbrains.buildServer.SimpleCommandLineProcessRunner.RunCommandEvents; import jetbrains.buildServer.log.Loggers; import jetbrains.buildServer.util.StringUtil; import jetbrains.buildServer.vcs.VcsException; import org.jetbrains.annotations.NotNull; public class CommandUtil { public static void checkCommandFailed(@NotNull String cmdName, @NotNull ExecResult res) throws VcsException { if (res.getExitCode() > 0 || res.getException() != null) { commandFailed(cmdName, res); } if (res.getStderr().length() > 0) { Loggers.VCS.warn(\"Error output produced by: \" + cmdName); Loggers.VCS.warn(res.getStderr()); } } public static void commandFailed(final String cmdName, final ExecResult res) throws VcsException { Throwable exception = res.getException(); String stderr = res.getStderr(); String stdout = res.getStdout(); final String message = \"'\" + cmdName + \"' command failed.\\n\" + (!StringUtil.isEmpty(stderr) ? \"stderr: \" + stderr + \"\\n\" : \"\") + (!StringUtil.isEmpty(stdout) ? \"stdout: \" + stdout + \"\\n\" : \"\") + (exception != null ? \"exception: \" + exception.getLocalizedMessage() : \"\"); Loggers.VCS.warn(message); throw new VcsException(message); } public static ExecResult runCommand(@NotNull GeneralCommandLine cli, Integer timeout) throws VcsException { String cmdStr = cli.getCommandLineString(); Loggers.VCS.info(\"Run Command: \" + cmdStr); ExecResult res = SimpleCommandLineProcessRunner.runCommand(cli, null, new OurRunCommandEvents(timeout)); CommandUtil.checkCommandFailed(cmdStr, res); Loggers.VCS.info(res.getStdout()); return res; } public static class OurRunCommandEvents implements RunCommandEvents { Integer timeout; public OurRunCommandEvents(Integer timeout) { super(); this.timeout = timeout; } public Integer getOutputIdleSecondsTimeout() { return Integer.valueOf(this.timeout); } public void onProcessFinished(Process arg0) { } public void onProcessStarted(Process arg0) { } } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; public class CreateTrackingBranchesCommand extends GitCommand { public CreateTrackingBranchesCommand(GitConfiguration configuration) { super(configuration); } public void run() throws VcsException { BranchCommand branch = new BranchCommand(getConfiguration()); String[] locals = branch.local(); for (String name : branch.remote(\"origin\")) { boolean found = false; for (String existing : locals) { if (existing.equals(name)) { found = true; break; } } if (!found) { branch.track(name, \"origin/\" + name); } } } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import java.io.BufferedReader; import java.io.IOException; import java.io.StringReader; import java.util.ArrayList; import java.util.Collection; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import org.hivedb.teamcity.plugin.NameAndStatus; import org.hivedb.teamcity.plugin.VersionNumber; import com.intellij.execution.configurations.GeneralCommandLine; public class DiffCommand extends GitCommand { public DiffCommand(GitConfiguration configuration) { super(configuration); } public Collection<NameAndStatus> run(VersionNumber from, VersionNumber to)throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"diff\"); cli.addParameter(\"--no-color\"); cli.addParameter(\"--name-status\"); cli.addParameter(from.getHash()); cli.addParameter(to.getHash()); return parseNamesAndStatuses(exec(cli).getStdout()); } private Collection<NameAndStatus> parseNamesAndStatuses(String data) { Collection<NameAndStatus> changes = new ArrayList<NameAndStatus>(); BufferedReader r = new BufferedReader(new StringReader(data)); try { String line; while ((line = r.readLine()) != null) { String s = line.trim(); if (s == null || \"\".equals(s)) continue; else { String[] fields = line.split(\" \"); String status = fields[0].trim(); String name = fields[1].trim(); changes.add(new NameAndStatus(name, status)); } } } catch (IOException e) { throw new RuntimeException(e); } return changes; } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import com.intellij.execution.configurations.GeneralCommandLine; public class FetchCommand extends GitCommand { public FetchCommand(GitConfiguration configuration) { super(configuration); } public void run() throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"fetch\"); cli.addParameter(\"-v\"); exec(cli); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import jetbrains.buildServer.ExecResult; import com.intellij.execution.configurations.GeneralCommandLine; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; public class GitCommand { static final Integer FIVE_MINUTES = 60 * 5; GitConfiguration configuration; public GitConfiguration getConfiguration() { return configuration; } public GitCommand(GitConfiguration configuration) { super(); this.configuration = configuration; } protected boolean useProjectDirectory() { return true; } protected GeneralCommandLine createCommandLine() { GeneralCommandLine cli = new GeneralCommandLine(); cli.setExePath(this.configuration.getCommand().getAbsolutePath()); cli.setWorkingDirectory(useProjectDirectory() ? this.configuration.getProjectDirectory() : this.configuration.getWorkingDirectory()); return cli; } protected ExecResult exec(GeneralCommandLine cli) throws VcsException { return CommandUtil.runCommand(cli, getTimeout()); } protected Integer getTimeout() { return FIVE_MINUTES; } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import java.util.Collection; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.Commit; import org.hivedb.teamcity.plugin.GitConfiguration; import org.hivedb.teamcity.plugin.VersionNumber; import com.intellij.execution.configurations.GeneralCommandLine; public class LogCommand extends GitCommand { public LogCommand(GitConfiguration configuration) { super(configuration); } public Collection<Commit> between(VersionNumber from, VersionNumber to) throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"log\"); cli.addParameter(\"--no-color\"); cli.addParameter(\"--name-status\"); if (from.equals(to)) { cli.addParameter(\"-1\"); cli.addParameter(from.getHash()); } else { cli.addParameter(from.getHash() + \"..\" + to.getHash()); } return LogOutput.parse(exec(cli).getStdout()); } public Commit run(VersionNumber version) throws VcsException { return getSingle(version.getHash()); } public Commit head() throws VcsException { return getSingle(getConfiguration().getRemoteBranch()); } private Commit getSingle(String ref) throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"log\"); cli.addParameter(\"--no-color\"); cli.addParameter(\"--name-status\"); cli.addParameter(\"-1\"); cli.addParameter(ref); Collection<Commit> commits = LogOutput.parse(exec(cli).getStdout()); if (commits.size() != 1) { throw new RuntimeException(\"Unable to log commit: \" + ref); } return commits.iterator().next(); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import java.io.BufferedReader; import java.io.IOException; import java.io.StringReader; import java.text.ParseException; import java.util.ArrayList; import java.util.Collection; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.hivedb.teamcity.plugin.Commit; import org.hivedb.teamcity.plugin.Constants; import org.hivedb.teamcity.plugin.NameAndStatus; public class LogOutput { public static Collection<Commit> parse(String log) { Pattern nameAndStatus = Pattern.compile(\"^(\\\\w)\\\\s+(.+)$\"); Collection<Commit> commits = new ArrayList<Commit>(); BufferedReader r = new BufferedReader(new StringReader(log)); try { String line; Commit current = new Commit(); while ((line = r.readLine()) != null) { if (line == null || line.trim().equals(\"\")) continue; else { if (line.startsWith(\"commit\")) { if (current.isValid()) { commits.add(current); current = new Commit(); } current.setHash(line.replaceAll(\"commit\", \"\").trim()); } else if (line.startsWith(\"Author\")) current.setAuthor(line.replaceAll(\"Author:\", \"\").trim()); else if (line.startsWith(\"Date\")) { String dateString = line.replaceAll(\"Date:\", \"\").trim(); current.setDate(Constants.GIT_DATE.parse(dateString)); } else if (line.startsWith(\" \")) { current.setMessage(current.getMessage() + \"\\n\" + line); } else { Matcher m = nameAndStatus.matcher(line); while (m.find()) { NameAndStatus change = new NameAndStatus(m.group(2), m.group(1)); current.getChanges().add(change); } } } } if (current.isValid()) { commits.add(current); } } catch (IOException e) { throw new RuntimeException(e); } catch (ParseException e) { throw new RuntimeException(e); } return commits; } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import com.intellij.execution.configurations.GeneralCommandLine; public class PullCommand extends GitCommand { public PullCommand(GitConfiguration configuration) { super(configuration); } public void run() throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"pull\"); exec(cli); } }"}
{"name": "jlewallen/git-teamcity", "content": "package org.hivedb.teamcity.plugin.commands; import com.intellij.execution.configurations.GeneralCommandLine; import jetbrains.buildServer.vcs.VcsException; import org.hivedb.teamcity.plugin.GitConfiguration; import org.hivedb.teamcity.plugin.VersionNumber; public class ShowCommand extends GitCommand { public ShowCommand(GitConfiguration configuration) { super(configuration); } public byte[] run(VersionNumber version, String path) throws VcsException { GeneralCommandLine cli = createCommandLine(); cli.addParameter(\"show\"); cli.addParameter(version.getHash() + \":\" + path); return exec(cli).getByteOut(); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; public class Version { public String getClientProduct () { return \"OpenAMQ/JMS\"; } public String getClientVersion () { return \"@@version@@\"; } public String getClientCopyright () { return \"Copyright 2007 iMatix Corporation\"; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq;  public class AMQChannelClosedException extends AMQException { public AMQChannelClosedException(int errorCode, String msg) { super(errorCode, msg); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq; import org.openamq.framing.ChannelCloseBody; import org.openamq.framing.AMQFrame; public class AMQChannelException extends AMQException { private final int _classId; private final int _methodId; public AMQChannelException(int errorCode, String msg, int classId, int methodId, Throwable t) { super(errorCode, msg, t); _classId = classId; _methodId = methodId; } public AMQChannelException(int errorCode, String msg, int classId, int methodId) { super(errorCode, msg); _classId = classId; _methodId = methodId; } public AMQFrame getCloseFrame(int channel) { return ChannelCloseBody.createAMQFrame(channel, getErrorCode(), getMessage(), _classId, _methodId); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq;  public class AMQConnectionClosedException extends AMQException { public AMQConnectionClosedException(int errorCode, String msg) { super(errorCode, msg); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq;  public class AMQDisconnectedException extends AMQException { public AMQDisconnectedException(String msg) { super(msg); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class AMQException extends Exception { private int _errorCode; public AMQException(String message) { super(message); } public AMQException(String msg, Throwable t) { super(msg, t); } public AMQException(int errorCode, String msg, Throwable t) { super(msg + \" [error code \" + errorCode + ']', t); _errorCode = errorCode; } public AMQException(int errorCode, String msg) { super(msg + \" [error code \" + errorCode + ']'); _errorCode = errorCode; } public AMQException(Logger logger, String msg, Throwable t) { this(msg, t); logger.error(getMessage(), this); } public AMQException(Logger logger, String msg) { this(msg); logger.error(getMessage(), this); } public AMQException(Logger logger, int errorCode, String msg) { this(errorCode, msg); logger.error(getMessage(), this); } public int getErrorCode() { return _errorCode; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq;  public class AMQUndeliveredException extends AMQException { private Object _bounced; public AMQUndeliveredException(int errorCode, String msg, Object bounced) { super(errorCode, msg); _bounced = bounced; } public Object getUndeliveredMessage() { return _bounced; } }"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketSessionImpl.java 398039 2006-04-28 23:36:27Z proyal $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketSessionImpl.java 398039 2006-04-28 23:36:27Z proyal $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketSessionImpl.java 398039 2006-04-28 23:36:27Z proyal $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketAcceptor.java 389042 2006-03-27 07:49:41Z trustin $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketConnector.java 389042 2006-03-27 07:49:41Z trustin $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketFilterChain.java 398039 2006-04-28 23:36:27Z proyal $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketSessionImpl.java 398039 2006-04-28 23:36:27Z proyal $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.AMQUndeliveredException; import org.openamq.client.protocol.AMQProtocolHandler; import org.openamq.client.protocol.FailoverSupport; import org.openamq.client.state.AMQState; import org.openamq.client.state.listener.SpecificMethodFrameListener; import org.openamq.client.transport.TransportConnection; import org.openamq.framing.AMQFrame; import org.openamq.framing.BasicQosBody; import org.openamq.framing.BasicQosOkBody; import org.openamq.framing.ChannelOpenBody; import org.openamq.framing.ChannelOpenOkBody; import org.openamq.framing.TxSelectBody; import org.openamq.framing.TxSelectOkBody; import org.openamq.jms.ChannelLimitReachedException; import org.openamq.jms.Connection; import org.openamq.jms.ConnectionListener; import javax.jms.ConnectionConsumer; import javax.jms.ConnectionMetaData; import javax.jms.Destination; import javax.jms.ExceptionListener; import javax.jms.JMSException; import javax.jms.Queue; import javax.jms.QueueConnection; import javax.jms.QueueSession; import javax.jms.ServerSessionPool; import javax.jms.Session; import javax.jms.Topic; import javax.jms.TopicConnection; import javax.jms.TopicSession; import java.io.IOException; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.LinkedList; import java.util.Map; import java.util.StringTokenizer; public class AMQConnection extends Closeable implements Connection, QueueConnection, TopicConnection { private static final Logger _logger = LoggerFactory.getLogger(AMQConnection.class); private final IdFactory _idFactory = new IdFactory();  private final Object _failoverMutex = new Object();  public static class BrokerDetail { public String host; public int port; public BrokerDetail(String host, int port) { this.host = host; this.port = port; } public String toString() { return (host + \":\" + port); } public boolean equals(Object o) { if (!(o instanceof BrokerDetail)) { return false; } BrokerDetail bd = (BrokerDetail) o; return host.equals(bd.host) && (port == bd.port); } }  private long _maximumChannelCount;  private long _maximumFrameSize;  private AMQProtocolHandler _protocolHandler;  private final Map _sessions = new LinkedHashMap(); private String _clientName; private BrokerDetail[] _brokerDetails;  private int _activeBrokerIndex = -1;  private String _username;  private String _password;  private String _virtualPath; private ExceptionListener _exceptionListener; private ConnectionListener _connectionListener;  private boolean _started; public AMQConnection(String host, int port, String username, String password, String clientName, String virtualPath) throws AMQException { this(new BrokerDetail(host, port), username, password, clientName, virtualPath); } public AMQConnection(String brokerDetails, String username, String password, String clientName, String virtualPath) throws AMQException { this(parseBrokerDetails(brokerDetails), username, password, clientName, virtualPath); } public AMQConnection(BrokerDetail brokerDetail, String username, String password, String clientName, String virtualPath) throws AMQException { this(new BrokerDetail[]{brokerDetail}, username, password, clientName, virtualPath); } public AMQConnection(BrokerDetail[] brokerDetails, String username, String password, String clientName, String virtualPath) throws AMQException { if (brokerDetails == null || brokerDetails.length == 0) { throw new IllegalArgumentException(\"Broker details must specify at least one broker\"); } _brokerDetails = brokerDetails; _clientName = clientName; _username = username; _password = password; _virtualPath = virtualPath; _protocolHandler = new AMQProtocolHandler(this); for (int i = 0; i < brokerDetails.length; i++) { try { makeBrokerConnection(brokerDetails[i]); _activeBrokerIndex = i; "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import org.openamq.AMQException; import javax.jms.*; import java.net.InetAddress; import java.net.UnknownHostException; public class AMQConnectionFactory implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory { private String _host = null; private int _port; private String _brokerDetails = null; private String _defaultUsername; private String _defaultPassword; private String _virtualPath; public AMQConnectionFactory() { } public AMQConnectionFactory(String host, int port, String virtualPath) { this(host, port, \"guest\", \"guest\", virtualPath); } public AMQConnectionFactory(String brokerDetails, String virtualPath) { this(brokerDetails, \"guest\", \"guest\", virtualPath); } public AMQConnectionFactory(String host, int port, String defaultUsername, String defaultPassword, String virtualPath) { _host = host; _port = port; _defaultUsername = defaultUsername; _defaultPassword = defaultPassword; _virtualPath = virtualPath; } public AMQConnectionFactory(String brokerDetails, String defaultUsername, String defaultPassword, String virtualPath) { _brokerDetails = brokerDetails; _defaultUsername = defaultUsername; _defaultPassword = defaultPassword; _virtualPath = virtualPath; }  public final void setDefaultPassword(String password) { _defaultPassword = password; }  public final void setDefaultUsername(String username) { _defaultUsername = username; }  public final void setBrokerDetails(String _brokerDetails) { this._brokerDetails = _brokerDetails; }  public final void setHost(String _host) { this._host = _host; }  public final void setPort(int _port) { this._port = _port; }  public final void setVirtualPath(String path) { _virtualPath = path; } private static String getUniqueClientID() { try { InetAddress addr = InetAddress.getLocalHost(); return addr.getHostName() + System.currentTimeMillis(); } catch (UnknownHostException e) { return null; } } private Connection createConnection(String username, String password, String clientId, String virtualPath) throws AMQException { if(_host == null){ return new AMQConnection(_brokerDetails, username, password, clientId, virtualPath); } else { return new AMQConnection(_host, _port, username, password, clientId, virtualPath); } } public Connection createConnection() throws JMSException { try { return createConnection(_defaultUsername, _defaultPassword, getUniqueClientID(), _virtualPath); } catch (AMQException e) { throw new JMSException(\"Error creating connection: \" + e); } } public Connection createConnection(String userName, String password) throws JMSException { if((userName == null || userName.length() == 0) && (password == null || password.length() == 0)){ return createConnection(); } try { return createConnection(userName, password, getUniqueClientID(), _virtualPath); } catch (AMQException e) { throw new JMSException(\"Error creating connection: \" + e); } } public QueueConnection createQueueConnection() throws JMSException { return (QueueConnection) createConnection(); } public QueueConnection createQueueConnection(String username, String password) throws JMSException { return (QueueConnection) createConnection(username, password); } public TopicConnection createTopicConnection() throws JMSException { return (TopicConnection) createConnection(); } public TopicConnection createTopicConnection(String username, String password) throws JMSException { return (TopicConnection) createConnection(username, password); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import javax.jms.Destination; public abstract class AMQDestination implements Destination { public final static String TOPIC_EXCHANGE_NAME = \"amq.topic\"; public final static String TOPIC_EXCHANGE_CLASS = \"topic\"; public final static String QUEUE_EXCHANGE_NAME = \"amq.direct\"; public final static String QUEUE_EXCHANGE_CLASS = \"direct\"; public final static String HEADERS_EXCHANGE_NAME = \"amq.headers\"; public final static String HEADERS_EXCHANGE_CLASS = \"headers\"; protected final String _destinationName; protected boolean _isDurable; protected final boolean _isExclusive; protected final boolean _isAutoDelete; protected String _queueName; protected String _exchangeName; protected String _exchangeClass; protected final boolean _isExchangeDurable; protected final boolean _isExchangeAutoDelete; protected AMQDestination(String exchangeName, String exchangeClass, String destinationName, String queueName) { this(exchangeName, exchangeClass, false, false, destinationName, false, false, false, queueName); } protected AMQDestination(String exchangeName, String exchangeClass, String destinationName) { this(exchangeName, exchangeClass, false, false, destinationName, false, false, true, destinationName); } protected AMQDestination(String exchangeName, String exchangeClass, String destinationName, boolean isExclusive, boolean isAutoDelete, String queueName) { this(exchangeName, exchangeClass, false, false, destinationName, false, isExclusive, isAutoDelete, queueName); } protected AMQDestination(String exchangeName, String exchangeClass, String destinationName, boolean isDurable, boolean isExclusive, boolean isAutoDelete, String queueName) { this(exchangeName, exchangeClass, false, false, destinationName, isDurable, isExclusive, isAutoDelete, queueName); } protected AMQDestination(String exchangeName, String exchangeClass, boolean isExchangeDurable, boolean isExchangeAutoDelete, String destinationName, boolean isDurable, boolean isExclusive, boolean isAutoDelete, String queueName) { if (destinationName == null) { throw new IllegalArgumentException(\"Destination name must not be null\"); } if (exchangeName == null) { throw new IllegalArgumentException(\"Exchange name must not be null\"); } if (exchangeClass == null) { throw new IllegalArgumentException(\"Exchange class must not be null\"); } _exchangeName = exchangeName; _exchangeClass = exchangeClass; _destinationName = destinationName; _isExclusive = isExclusive; _isAutoDelete = isAutoDelete; _queueName = queueName; _isDurable = isDurable; _isExchangeDurable = isExchangeDurable; _isExchangeAutoDelete = isExchangeAutoDelete; } public abstract String getEncodedName(); public boolean isDurable() { return _isDurable; } public String getExchangeName() { return _exchangeName; } public String getExchangeClass() { return _exchangeClass; } public boolean getExchangeDurable() { return _isExchangeDurable; } public boolean getExchangeAutoDelete() { return _isExchangeAutoDelete; } public void setExchangeName(String exchangeName) { _exchangeName = exchangeName; } public void setExchangeClass(String exchangeClass) { _exchangeClass = exchangeClass; } public boolean isTopic() { return TOPIC_EXCHANGE_CLASS.equals(_exchangeClass); } public boolean isQueue() { return QUEUE_EXCHANGE_CLASS.equals(_exchangeClass); } public String getDestinationName() { return _destinationName; } public String getQueueName() { return _queueName; } public void setQueueName(String queueName) { _queueName = queueName; } public abstract String getRoutingKey(); public boolean isExclusive() { return _isExclusive; } public boolean isAutoDelete() { return _isAutoDelete; } public boolean isExchangeDurable() { return _isExchangeDurable; } public boolean isExchangeAutoDelete() { return _isExchangeAutoDelete; } public abstract boolean isNameRequired(); public String toString() { return \"Destination: \" + _destinationName + \", \" + \"Queue Name: \" + _queueName + \", Exchange: \" + _exchangeName + \", Exchange class: \" + _exchangeClass + \", Exclusive: \" + _isExclusive + \", AutoDelete: \" + _isAutoDelete + \", Routing Key: \" + getRoutingKey(); } public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } final AMQDestination that = (AMQDestination) o; if (!_destinationName.equals(that._destinationName)) { return false; } if (!_exchangeClass.equals(that._exchangeClass)) { return false; } if (!_exchangeName.equals(that._exchangeName)) { return false; } if ((_queueName == null && that._queueName != null) || (_queueName != null && !_queueName.equals(that._queueName))) { return false; } if (_isExclusive != that._isExclusive) { return false; } if (_isAutoDelete != that._isAutoDelete) { return false; } return true; } public int hashCode() { int result; result = _exchangeName.hashCode(); result = 29 * result + _exchangeClass.hashCode(); result = 29 * result + _destinationName.hashCode(); if (_queueName != null) { result = 29 * result + _queueName.hashCode(); } result = result * (_isExclusive?13:7); result = result * (_isAutoDelete?13:7); return result; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client;  public class AMQHeadersExchange extends AMQDestination { public AMQHeadersExchange(String queueName) { super(queueName, HEADERS_EXCHANGE_CLASS, queueName, true, true, null); } public String getEncodedName() { return getDestinationName(); } public String getRoutingKey() { return getDestinationName(); } public boolean isNameRequired() { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import javax.jms.Queue; public class AMQQueue extends AMQDestination implements Queue { private String _routingKey;  public AMQQueue(String name) { this(name, false); }  public AMQQueue(String name, boolean temporary) { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap; import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQDisconnectedException; import org.openamq.AMQException; import org.openamq.AMQUndeliveredException; import org.openamq.client.message.AbstractJMSMessage; import org.openamq.client.message.MessageFactoryRegistry; import org.openamq.client.message.UnprocessedMessage; import org.openamq.client.protocol.AMQProtocolHandler; import org.openamq.client.protocol.FailoverSupport; import org.openamq.client.util.FlowControllingBlockingQueue; import org.openamq.client.state.listener.SpecificMethodFrameListener; import org.openamq.framing.*; import org.openamq.jms.Session; import javax.jms.*; import javax.jms.IllegalStateException; import java.io.Serializable; import java.io.StringReader; import java.io.StreamTokenizer; import java.io.IOException; import java.util.ArrayList; import java.util.Iterator; import java.util.Map; public class AMQSession extends Closeable implements Session, QueueSession, TopicSession { private static final Logger _logger = LoggerFactory.getLogger(AMQSession.class); public static final int DEFAULT_PREFETCH = 5000; private AMQConnection _connection; private boolean _transacted; private int _acknowledgeMode; private int _channelId; private int _defaultPrefetch = DEFAULT_PREFETCH;  private int _nextTag = 1;  private final FlowControllingBlockingQueue _queue; private Dispatcher _dispatcher; private MessageFactoryRegistry _messageFactoryRegistry;  private Map _producers = new ConcurrentHashMap();  private Map _consumers = new ConcurrentHashMap();  protected static final boolean DEFAULT_IMMEDIATE = false;  protected static final boolean DEFAULT_MANDATORY = true;  private long _nextProducerId;  private volatile AtomicBoolean _stopped = new AtomicBoolean(true);  private class Dispatcher extends Thread { public Dispatcher() { super(\"Dispatcher-Channel-\" + _channelId); } public void run() { UnprocessedMessage message; _stopped.set(false); try { while (!_stopped.get() && (message = (UnprocessedMessage)_queue.take()) != null) { dispatchMessage(message); } } catch(InterruptedException e) { ; } _logger.info(\"Dispatcher thread terminating for channel \" + _channelId); } private void dispatchMessage(UnprocessedMessage message) { if (message.deliverBody != null) { final BasicMessageConsumer consumer = (BasicMessageConsumer) _consumers.get(message.deliverBody.consumerTag); if (consumer == null) { _logger.warn(\"Received a message from queue \" + message.deliverBody.consumerTag + \" without a handler - ignoring...\"); } else { consumer.notifyMessage(message, _channelId); } } else { try { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import javax.jms.JMSException; import javax.jms.TemporaryQueue;  final class AMQTemporaryQueue extends AMQQueue implements TemporaryQueue {  public AMQTemporaryQueue() { super(\"TempQueue\" + Long.toString(System.currentTimeMillis()), null, true, true); }  public void delete() throws JMSException { throw new UnsupportedOperationException(\"Delete not supported, \" + \"will auto-delete when connection closed\"); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import javax.jms.JMSException; import javax.jms.TemporaryTopic;  class AMQTemporaryTopic extends AMQTopic implements TemporaryTopic {  public AMQTemporaryTopic() { super(\"TempQueue\" + Long.toString(System.currentTimeMillis()), true); }  public void delete() throws JMSException { throw new UnsupportedOperationException(\"Delete not supported, \" + \"will auto-delete when connection closed\"); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import javax.jms.JMSException; import javax.jms.Topic; public class AMQTopic extends AMQDestination implements Topic { public AMQTopic(String name) { this(name, false); } public AMQTopic(String name, boolean temporary) { super(AMQDestination.HEADERS_EXCHANGE_NAME, AMQDestination.HEADERS_EXCHANGE_CLASS, name, temporary, temporary, null); _isDurable = !temporary; }  public AMQTopic(AMQTopic topic, String clientId, String subscriptionName) { super(AMQDestination.HEADERS_EXCHANGE_NAME, AMQDestination.HEADERS_EXCHANGE_CLASS, topic.getDestinationName(), false, false, clientId + \":\" + subscriptionName); } public String getTopicName() throws JMSException { return super.getDestinationName(); } public String getEncodedName() { return 'T' + getDestinationName(); } public String getRoutingKey() { return getDestinationName(); } public boolean isNameRequired() { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import edu.emory.mathcs.backport.java.util.concurrent.SynchronousQueue; import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit; import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean; import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicReference; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.client.message.MessageFactoryRegistry; import org.openamq.client.message.UnprocessedMessage; import org.openamq.client.message.AbstractJMSMessage; import org.openamq.client.message.AMQMessage; import org.openamq.client.protocol.AMQProtocolHandler; import org.openamq.client.state.listener.SpecificMethodFrameListener; import org.openamq.framing.*; import org.openamq.jms.MessageConsumer; import org.openamq.jms.Session; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageListener; public class BasicMessageConsumer extends Closeable implements MessageConsumer { private static final Logger _logger = LoggerFactory.getLogger(BasicMessageConsumer.class);  private AMQConnection _connection; private String _messageSelector; private boolean _noLocal; private AMQDestination _destination;  private final AtomicBoolean _receiving = new AtomicBoolean(false);  private final AtomicReference _messageListener = new AtomicReference();  private String _consumerTag;  private int _channelId;  private final SynchronousQueue _synchronousQueue = new SynchronousQueue(true); private MessageFactoryRegistry _messageFactory; private AMQSession _session; private AMQProtocolHandler _protocolHandler;  private FieldTable _rawSelectorFieldTable;  private int _prefetch;  private boolean _exclusive;  private int _acknowledgeMode;  private int _outstanding;  private long _lastDeliveryTag; BasicMessageConsumer(int channelId, AMQConnection connection, AMQDestination destination, String messageSelector, boolean noLocal, MessageFactoryRegistry messageFactory, AMQSession session, AMQProtocolHandler protocolHandler, FieldTable rawSelectorFieldTable, int prefetch, boolean exclusive, int acknowledgeMode) { _channelId = channelId; _connection = connection; _messageSelector = messageSelector; _noLocal = noLocal; _destination = destination; _messageFactory = messageFactory; _session = session; _protocolHandler = protocolHandler; _rawSelectorFieldTable =rawSelectorFieldTable; _prefetch = prefetch; _exclusive = exclusive; _acknowledgeMode = acknowledgeMode; } public AMQDestination getDestination() { return _destination; } public String getMessageSelector() throws JMSException { return _messageSelector; } public MessageListener getMessageListener() throws JMSException { return (MessageListener) _messageListener.get(); } public int getAcknowledgeMode() { return _acknowledgeMode; } private boolean isMessageListenerSet() { return _messageListener.get() != null; } public void setMessageListener(MessageListener messageListener) throws JMSException { checkNotClosed(); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; import org.openamq.client.protocol.AMQProtocolHandler; import org.openamq.client.state.listener.SpecificMethodFrameListener; import org.openamq.client.message.AbstractJMSMessage; import org.openamq.client.message.JMSBytesMessage; import org.openamq.AMQException; import org.openamq.framing.*; import javax.jms.*; import java.io.UnsupportedEncodingException; public class BasicMessageProducer extends Closeable implements org.openamq.jms.MessageProducer { protected final Logger _logger = LoggerFactory.getLogger(getClass()); private AMQConnection _connection;  private boolean _disableTimestamps;  private int _messagePriority;  private long _timeToLive;  private int _deliveryMode = DeliveryMode.PERSISTENT;  protected AMQDestination _destination;  private String _encoding;  private String _mimeType; private AMQProtocolHandler _protocolHandler;  private boolean _transacted; private int _channelId;  private long _producerId;  private AMQSession _session; private final boolean _immediate; private final boolean _mandatory; private final boolean _waitUntilSent; protected BasicMessageProducer(AMQConnection connection, AMQDestination destination, boolean transacted, int channelId, AMQSession session, AMQProtocolHandler protocolHandler, long producerId, boolean immediate, boolean mandatory, boolean waitUntilSent) throws AMQException { _connection = connection; _destination = destination; _transacted = transacted; _protocolHandler = protocolHandler; _channelId = channelId; _session = session; _producerId = producerId; if (destination != null) { declareDestination(destination); } _immediate = immediate; _mandatory = mandatory; _waitUntilSent = waitUntilSent; } void resubscribe() throws AMQException { if (_destination != null) { declareDestination(_destination); } } private void declareDestination(AMQDestination destination) throws AMQException { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean; import javax.jms.JMSException;  public abstract class Closeable {  protected AtomicBoolean _closed = new AtomicBoolean(false); protected void checkNotClosed() { if (_closed.get()) { throw new IllegalStateException(\"Object \" + toString() + \" has been closed\"); } } public boolean isClosed() { return _closed.get(); } public abstract void close() throws JMSException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; public class ConnectionTuneParameters { private long _frameMax; private int _channelMax; private int _heartbeat; private long _txnLimit; public long getFrameMax() { return _frameMax; } public void setFrameMax(long frameMax) { _frameMax = frameMax; } public int getChannelMax() { return _channelMax; } public void setChannelMax(int channelMax) { _channelMax = channelMax; } public int getHeartbeat() { return _heartbeat; } public void setHeartbeat(int hearbeat) { _heartbeat = hearbeat; } public long getTxnLimit() { return _txnLimit; } public void setTxnLimit(long txnLimit) { _txnLimit = txnLimit; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; public class IdFactory { private Object[] _locks = new Object[1]; private short[] _counters = new short[1]; private static final int CHANNEL_ID = 0; public IdFactory() { for (int i = 0; i < _locks.length; i++) { _locks[i] = new Object(); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageConsumer; import javax.jms.MessageListener; import javax.jms.Topic; import javax.jms.TopicSubscriber;  class TopicSubscriberAdaptor implements TopicSubscriber { private final Topic _topic; private final MessageConsumer _consumer; private final boolean _noLocal; TopicSubscriberAdaptor(Topic topic, MessageConsumer consumer, boolean noLocal) { _topic = topic; _consumer = consumer; _noLocal = noLocal; } TopicSubscriberAdaptor(Topic topic, BasicMessageConsumer consumer) { this(topic, consumer, consumer.isNoLocal()); } public Topic getTopic() throws JMSException { return _topic; } public boolean getNoLocal() throws JMSException { return _noLocal; } public String getMessageSelector() throws JMSException { return _consumer.getMessageSelector(); } public MessageListener getMessageListener() throws JMSException { return _consumer.getMessageListener(); } public void setMessageListener(MessageListener messageListener) throws JMSException { _consumer.setMessageListener(messageListener); } public Message receive() throws JMSException { return _consumer.receive(); } public Message receive(long l) throws JMSException { return _consumer.receive(l); } public Message receiveNoWait() throws JMSException { return _consumer.receiveNoWait(); } public void close() throws JMSException { _consumer.close(); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.framing.BasicDeliverBody; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.message.UnprocessedMessage; public class BasicDeliverMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(BasicDeliverMethodHandler.class); private static final BasicDeliverMethodHandler _instance = new BasicDeliverMethodHandler(); public static BasicDeliverMethodHandler getInstance() { return _instance; } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { final UnprocessedMessage msg = new UnprocessedMessage(); msg.deliverBody = (BasicDeliverBody) evt.getMethod(); msg.channelId = evt.getChannelId(); _logger.debug(\"New JmsDeliver method received\"); evt.getProtocolSession().unprocessedMessageReceived(msg); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.client.message.UnprocessedMessage; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.BasicReturnBody; public class BasicReturnMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(BasicReturnMethodHandler.class); private static final BasicReturnMethodHandler _instance = new BasicReturnMethodHandler(); public static BasicReturnMethodHandler getInstance() { return _instance; } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { _logger.debug(\"New JmsBounce method received\"); final UnprocessedMessage msg = new UnprocessedMessage(); msg.deliverBody = null; msg.bounceBody = (BasicReturnBody) evt.getMethod(); msg.channelId = evt.getChannelId(); evt.getProtocolSession().unprocessedMessageReceived(msg); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQChannelClosedException; import org.openamq.AMQException; import org.openamq.client.protocol.AMQConstant; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.AMQFrame; import org.openamq.framing.ChannelCloseBody; import org.openamq.framing.ChannelCloseOkBody; public class ChannelCloseMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(ChannelCloseMethodHandler.class); private static ChannelCloseMethodHandler _handler = new ChannelCloseMethodHandler(); public static ChannelCloseMethodHandler getInstance() { return _handler; } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { _logger.debug(\"ChannelClose method received\"); ChannelCloseBody method = (ChannelCloseBody) evt.getMethod(); int errorCode = method.replyCode; String reason = method.replyText; if (_logger.isDebugEnabled()) { _logger.debug(\"Channel close reply code: \" + errorCode + \", reason: \" + reason); } AMQFrame frame = ChannelCloseOkBody.createAMQFrame(evt.getChannelId()); evt.getProtocolSession().writeFrame(frame); if (errorCode != AMQConstant.REPLY_SUCCESS.getCode()) { _logger.debug(\"Channel close received with errorCode \" + errorCode + \", throwing exception\"); throw new AMQChannelClosedException(errorCode, \"Error: \" + reason); } evt.getProtocolSession().channelClosed(evt.getChannelId(), errorCode, reason); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.ChannelFlowOkBody; public class ChannelFlowOkMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(ChannelFlowOkMethodHandler.class); private static final ChannelFlowOkMethodHandler _instance = new ChannelFlowOkMethodHandler(); public static ChannelFlowOkMethodHandler getInstance() { return _instance; } private ChannelFlowOkMethodHandler() { } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { ChannelFlowOkBody method = (ChannelFlowOkBody) evt.getMethod(); _logger.debug(\"Received Channel.Flow-Ok message, active = \" + method.active); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.AMQConnectionClosedException; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.state.AMQState; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.ConnectionCloseBody; import org.openamq.framing.ConnectionCloseOkBody; public class ConnectionCloseMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(ConnectionCloseMethodHandler.class); private static ConnectionCloseMethodHandler _handler = new ConnectionCloseMethodHandler(); public static ConnectionCloseMethodHandler getInstance() { return _handler; } private ConnectionCloseMethodHandler() { } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { _logger.debug(\"ConnectionClose frame received\"); ConnectionCloseBody method = (ConnectionCloseBody) evt.getMethod(); int errorCode = method.replyCode; String reason = method.replyText; "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.protocol.AMQProtocolSession; import org.openamq.client.state.AMQState; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.ConnectionOpenOkBody; public class ConnectionOpenOkMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(ConnectionOpenOkMethodHandler.class); private static final ConnectionOpenOkMethodHandler _instance = new ConnectionOpenOkMethodHandler(); public static ConnectionOpenOkMethodHandler getInstance() { return _instance; } private ConnectionOpenOkMethodHandler() { } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { AMQProtocolSession session = evt.getProtocolSession(); ConnectionOpenOkBody method = (ConnectionOpenOkBody) evt.getMethod(); stateManager.changeState(AMQState.CONNECTION_OPEN); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.ConnectionRedirectBody; public class ConnectionRedirectMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(ConnectionRedirectMethodHandler.class); private static final int DEFAULT_REDIRECT_PORT = 5672; private static ConnectionRedirectMethodHandler _handler = new ConnectionRedirectMethodHandler(); public static ConnectionRedirectMethodHandler getInstance() { return _handler; } private ConnectionRedirectMethodHandler() { } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { _logger.info(\"ConnectionRedirect frame received\"); ConnectionRedirectBody method = (ConnectionRedirectBody) evt.getMethod(); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.openamq.AMQException; import org.openamq.framing.AMQFrame; import org.openamq.framing.ConnectionSecureOkBody; import org.openamq.framing.ConnectionSecureBody; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.client.protocol.AMQMethodEvent; import javax.security.sasl.SaslClient; import javax.security.sasl.SaslException; public class ConnectionSecureMethodHandler implements StateAwareMethodListener { private static final ConnectionSecureMethodHandler _instance = new ConnectionSecureMethodHandler(); public static ConnectionSecureMethodHandler getInstance() { return _instance; } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { SaslClient client = evt.getProtocolSession().getSaslClient(); if (client == null) { throw new AMQException(\"No SASL client set up - cannot proceed with authentication\"); } ConnectionSecureBody body = (ConnectionSecureBody) evt.getMethod(); try { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.client.Version; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.protocol.AMQProtocolSession; import org.openamq.client.security.AMQCallbackHandler; import org.openamq.client.security.CallbackHandlerRegistry; import org.openamq.client.state.AMQState; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.ConnectionStartBody; import org.openamq.framing.ConnectionStartOkBody; import org.openamq.framing.FieldTable; import javax.security.sasl.Sasl; import javax.security.sasl.SaslClient; import javax.security.sasl.SaslException; import java.io.UnsupportedEncodingException; import java.util.HashSet; import java.util.StringTokenizer; public class ConnectionStartMethodHandler implements StateAwareMethodListener { private static final Logger _log = LoggerFactory.getLogger(ConnectionStartMethodHandler.class); private static final ConnectionStartMethodHandler _instance = new ConnectionStartMethodHandler(); private static final Version _clientVersion = new Version(); public static ConnectionStartMethodHandler getInstance() { return _instance; } private ConnectionStartMethodHandler() { } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { ConnectionStartBody body = (ConnectionStartBody) evt.getMethod(); try { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.handler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.client.ConnectionTuneParameters; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.client.protocol.AMQProtocolSession; import org.openamq.client.state.AMQState; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.StateAwareMethodListener; import org.openamq.framing.ConnectionOpenBody; import org.openamq.framing.ConnectionTuneBody; import org.openamq.framing.ConnectionTuneOkBody; import org.openamq.framing.AMQFrame; public class ConnectionTuneMethodHandler implements StateAwareMethodListener { private static final Logger _logger = LoggerFactory.getLogger(ConnectionTuneMethodHandler.class); private static final ConnectionTuneMethodHandler _instance = new ConnectionTuneMethodHandler(); public static ConnectionTuneMethodHandler getInstance() { return _instance; } protected ConnectionTuneMethodHandler() { } public void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException { _logger.debug(\"ConnectionTune frame received\"); ConnectionTuneBody frame = (ConnectionTuneBody) evt.getMethod(); AMQProtocolSession session = evt.getProtocolSession(); ConnectionTuneParameters params = session.getConnectionTuneParameters(); if (params == null) { params = new ConnectionTuneParameters(); } params.setFrameMax(frame.frameMax); params.setChannelMax(frame.channelMax); params.setHeartbeat(Integer.getInteger(\"amqj.heartbeat.delay\", frame.heartbeat)); session.setConnectionTuneParameters(params); stateManager.changeState(AMQState.CONNECTION_NOT_OPENED); session.writeFrame(createTuneOkFrame(evt.getChannelId(), params)); session.writeFrame(createConnectionOpenFrame(evt.getChannelId(), session.getAMQConnection().getVirtualPath(), null, true)); } protected AMQFrame createConnectionOpenFrame(int channel, String path, String capabilities, boolean insist) { return ConnectionOpenBody.createAMQFrame(channel, path, capabilities, insist); } protected AMQFrame createTuneOkFrame(int channel, ConnectionTuneParameters params) { return ConnectionTuneOkBody.createAMQFrame(channel, params.getChannelMax(), params.getFrameMax(), params.getHeartbeat()); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.framing.ContentHeaderProperties; import org.openamq.client.AMQSession; public class AMQMessage { protected ContentHeaderProperties _contentHeaderProperties;  protected AMQSession _session; protected final long _deliveryTag; public AMQMessage(ContentHeaderProperties properties, long deliveryTag) { _contentHeaderProperties = properties; _deliveryTag = deliveryTag; } public AMQMessage(ContentHeaderProperties properties) { this(properties, -1); }  public void setAMQSession(AMQSession s) { _session = s; } public AMQSession getAMQSession() { return _session; }  public long getDeliveryTag() { return _deliveryTag; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.apache.commons.collections.map.ReferenceMap; import org.apache.mina.common.ByteBuffer; import org.openamq.AMQException; import org.openamq.client.AMQDestination; import org.openamq.client.AMQQueue; import org.openamq.client.AMQTopic; import org.openamq.framing.FieldTable; import org.openamq.framing.BasicContentHeaderProperties; import javax.jms.Destination; import javax.jms.JMSException; import java.util.Collections; import java.util.Enumeration; import java.util.Iterator; import java.util.Map; public abstract class AbstractJMSMessage extends AMQMessage implements javax.jms.Message { private static final Map _destinationCache = Collections.synchronizedMap(new ReferenceMap()); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.AMQException; import org.openamq.framing.ContentHeaderBody; import org.openamq.framing.ContentBody; import org.openamq.framing.BasicContentHeaderProperties; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; import javax.jms.JMSException; import java.util.List; import java.util.Iterator; public abstract class AbstractJMSMessageFactory implements MessageFactory { private static final Logger _logger = LoggerFactory.getLogger(AbstractJMSMessageFactory.class); protected abstract AbstractJMSMessage createMessage(long messageNbr, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException; protected AbstractJMSMessage createMessageWithBody(long messageNbr, ContentHeaderBody contentHeader, List bodies) throws AMQException { ByteBuffer data; "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.framing.BasicContentHeaderProperties; import org.openamq.framing.ContentHeaderBody; import org.openamq.AMQException; import org.apache.mina.common.ByteBuffer; import javax.jms.JMSException; import javax.jms.MessageNotReadableException; import javax.jms.MessageNotWriteableException; import java.io.*; import java.nio.charset.Charset; import java.nio.charset.CharacterCodingException; public class JMSBytesMessage extends AbstractJMSMessage implements javax.jms.BytesMessage { private static final String MIME_TYPE = \"application/octet-stream\"; private boolean _readable = false;  private static final int DEFAULT_BUFFER_INITIAL_SIZE = 1024; JMSBytesMessage() { this(null); }  JMSBytesMessage(ByteBuffer data) { super(data); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.apache.mina.common.ByteBuffer; import org.openamq.AMQException; import org.openamq.framing.ContentHeaderBody; import javax.jms.JMSException; public class JMSBytesMessageFactory extends AbstractJMSMessageFactory { protected AbstractJMSMessage createMessage(long deliveryTag, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException { return new JMSBytesMessage(deliveryTag, data, contentHeader); } public AbstractJMSMessage createMessage() throws JMSException { return new JMSBytesMessage(); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.framing.ContentHeaderBody; import org.openamq.framing.BasicContentHeaderProperties; import org.openamq.AMQException; import org.apache.mina.common.ByteBuffer; import javax.jms.ObjectMessage; import javax.jms.JMSException; import javax.jms.MessageFormatException; import javax.jms.MessageNotWriteableException; import java.io.*; import java.nio.charset.Charset; import java.nio.charset.CharacterCodingException; public class JMSObjectMessage extends AbstractJMSMessage implements ObjectMessage { static final String MIME_TYPE = \"application/java-object-stream\"; private final boolean _readonly; private static final int DEFAULT_BUFFER_SIZE = 1024;  JMSObjectMessage() { this(null); } private JMSObjectMessage(ByteBuffer data) { super(data); if (data == null) { _data = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE); _data.setAutoExpand(true); } _readonly = (data != null); getJmsContentHeaderProperties().setContentType(MIME_TYPE); }  JMSObjectMessage(long messageNbr, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException { super(messageNbr, (BasicContentHeaderProperties) contentHeader.properties, data); _readonly = data != null; } public void clearBody() throws JMSException { if (_data != null) { _data.release(); } _data = null; } public String toBodyString() throws JMSException { return toString(_data); } public String getMimeType() { return MIME_TYPE; } public void setObject(Serializable serializable) throws JMSException { if (_readonly) { throw new MessageNotWriteableException(\"Message is not writable.\"); } if (_data == null) { _data = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE); _data.setAutoExpand(true); } try { ObjectOutputStream out = new ObjectOutputStream(_data.asOutputStream()); out.writeObject(serializable); out.flush(); out.close(); _data.rewind(); } catch (IOException e) { throw new MessageFormatException(\"Message not serializable: \" + e); } } public Serializable getObject() throws JMSException { ObjectInputStream in = null; if (_data == null) { return null; } try { in = new ObjectInputStream(_data.asInputStream()); return (Serializable) in.readObject(); } catch (IOException e) { throw new MessageFormatException(\"Could not deserialize message: \" + e); } catch (ClassNotFoundException e) { throw new MessageFormatException(\"Could not deserialize message: \" + e); } finally { _data.rewind(); close(in); } } private static void close(InputStream in) { try { if (in != null) { in.close(); } } catch (IOException ignore) { } } private static String toString(ByteBuffer data) { if (data == null) { return null; } int pos = data.position(); try { return data.getString(Charset.forName(\"UTF8\").newDecoder()); } catch (CharacterCodingException e) { return null; } finally { data.position(pos); } } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.apache.mina.common.ByteBuffer; import org.openamq.AMQException; import org.openamq.framing.ContentHeaderBody; import javax.jms.JMSException; public class JMSObjectMessageFactory extends AbstractJMSMessageFactory { protected AbstractJMSMessage createMessage(long deliveryTag, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException { return new JMSObjectMessage(deliveryTag, data, contentHeader); } public AbstractJMSMessage createMessage() throws JMSException { return new JMSObjectMessage(); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.framing.BasicContentHeaderProperties; import org.openamq.AMQException; import org.apache.mina.common.ByteBuffer; import javax.jms.JMSException; import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; import java.nio.charset.CharacterCodingException; public class JMSTextMessage extends AbstractJMSMessage implements javax.jms.TextMessage { private static final String MIME_TYPE = \"text/plain\"; private String _decodedValue; JMSTextMessage() throws JMSException { this(null, null); } JMSTextMessage(ByteBuffer data, String encoding) throws JMSException { super(data); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.apache.mina.common.ByteBuffer; import org.openamq.AMQException; import org.openamq.framing.BasicContentHeaderProperties; import org.openamq.framing.ContentHeaderBody; import javax.jms.JMSException; public class JMSTextMessageFactory extends AbstractJMSMessageFactory { public AbstractJMSMessage createMessage() throws JMSException { return new JMSTextMessage(); } protected AbstractJMSMessage createMessage(long deliveryTag, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException { return new JMSTextMessage(deliveryTag, data, (BasicContentHeaderProperties)contentHeader.properties); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.AMQException; import org.openamq.framing.ContentHeaderBody; import javax.jms.JMSException; import java.util.List; public interface MessageFactory { AbstractJMSMessage createMessage(long deliveryTag, boolean redelivered, ContentHeaderBody contentHeader, List bodies) throws JMSException, AMQException; AbstractJMSMessage createMessage() throws JMSException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.AMQException; import org.openamq.framing.BasicContentHeaderProperties; import org.openamq.framing.ContentHeaderBody; import javax.jms.JMSException; import java.util.HashMap; import java.util.Map; import java.util.List; public class MessageFactoryRegistry { private final Map _mimeToFactoryMap = new HashMap(); public void registerFactory(String mimeType, MessageFactory mf) { if (mf == null) { throw new IllegalArgumentException(\"Message factory must not be null\"); } _mimeToFactoryMap.put(mimeType, mf); } public MessageFactory deregisterFactory(String mimeType) { return (MessageFactory) _mimeToFactoryMap.remove(mimeType); }  public AbstractJMSMessage createMessage(long deliveryTag, boolean redelivered, ContentHeaderBody contentHeader, List bodies) throws AMQException, JMSException { BasicContentHeaderProperties properties = (BasicContentHeaderProperties) contentHeader.properties; MessageFactory mf = (MessageFactory) _mimeToFactoryMap.get(properties.getContentType()); if (mf == null) { throw new AMQException(\"Unsupport MIME type of \" + properties.getContentType()); } else { return mf.createMessage(deliveryTag, redelivered, contentHeader, bodies); } } public AbstractJMSMessage createMessage(String mimeType) throws AMQException, JMSException { if (mimeType == null) { throw new IllegalArgumentException(\"Mime type must not be null\"); } MessageFactory mf = (MessageFactory) _mimeToFactoryMap.get(mimeType); if (mf == null) { throw new AMQException(\"Unsupport MIME type of \" + mimeType); } else { return mf.createMessage(); } }  public static MessageFactoryRegistry newDefaultRegistry() { MessageFactoryRegistry mf = new MessageFactoryRegistry(); mf.registerFactory(\"text/plain\", new JMSTextMessageFactory()); mf.registerFactory(\"text/xml\", new JMSTextMessageFactory()); mf.registerFactory(\"application/octet-stream\", new JMSBytesMessageFactory()); mf.registerFactory(JMSObjectMessage.MIME_TYPE, new JMSObjectMessageFactory()); mf.registerFactory(null, new JMSBytesMessageFactory()); return mf; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.AMQException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class UnexpectedBodyReceivedException extends AMQException { public UnexpectedBodyReceivedException(Logger logger, String msg, Throwable t) { super(logger, msg, t); } public UnexpectedBodyReceivedException(Logger logger, String msg) { super(logger, msg); } public UnexpectedBodyReceivedException(Logger logger, int errorCode, String msg) { super(logger, errorCode, msg); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.message; import org.openamq.framing.*; import java.util.List; import java.util.LinkedList;  public class UnprocessedMessage { private long _bytesReceived = 0; public BasicDeliverBody deliverBody; public BasicReturnBody bounceBody; "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import java.util.Map; import java.util.HashMap; public final class AMQConstant { private int _code; private String _name; private static Map _codeMap = new HashMap(); private AMQConstant(int code, String name, boolean map) { _code = code; _name = name; if (map) { _codeMap.put(new Integer(code), this); } } public String toString() { return _code + \": \" + _name; } public int getCode() { return _code; } public String getName() { return _name; } public static final AMQConstant FRAME_MIN_SIZE = new AMQConstant(4096, \"frame min size\", true); public static final AMQConstant FRAME_END = new AMQConstant(206, \"frame end\", true); public static final AMQConstant REPLY_SUCCESS = new AMQConstant(200, \"reply success\", true); public static final AMQConstant NOT_DELIVERED = new AMQConstant(310, \"not delivered\", true); public static final AMQConstant MESSAGE_TOO_LARGE = new AMQConstant(311, \"message too large\", true); public static final AMQConstant CONTEXT_IN_USE = new AMQConstant(320, \"context in use\", true); public static final AMQConstant CONTEXT_UNKNOWN = new AMQConstant(321, \"context unknown\", true); public static final AMQConstant INVALID_PATH = new AMQConstant(402, \"invalid path\", true); public static final AMQConstant ACCESS_REFUSED = new AMQConstant(403, \"access refused\", true); public static final AMQConstant NOT_FOUND = new AMQConstant(404, \"not found\", true); public static final AMQConstant FRAME_ERROR = new AMQConstant(501, \"frame error\", true); public static final AMQConstant SYNTAX_ERROR = new AMQConstant(502, \"syntax error\", true); public static final AMQConstant COMMAND_INVALID = new AMQConstant(503, \"command invalid\", true); public static final AMQConstant CHANNEL_ERROR = new AMQConstant(504, \"channel error\", true); public static final AMQConstant RESOURCE_ERROR = new AMQConstant(506, \"resource error\", true); public static final AMQConstant NOT_ALLOWED = new AMQConstant(507, \"not allowed\", true); public static final AMQConstant NOT_IMPLEMENTED = new AMQConstant(540, \"not implemented\", true); public static final AMQConstant INTERNAL_ERROR = new AMQConstant(541, \"internal error\", true); public static AMQConstant getConstant(int code) { AMQConstant c = (AMQConstant) _codeMap.get(new Integer(code)); if (c == null) { c = new AMQConstant(code, \"unknown code\", false); } return c; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import org.openamq.framing.AMQMethodBody; public class AMQMethodEvent { private AMQMethodBody _method; private int _channelId; private AMQProtocolSession _protocolSession; public AMQMethodEvent(int channelId, AMQMethodBody method, AMQProtocolSession protocolSession) { _channelId = channelId; _method = method; _protocolSession = protocolSession; } public AMQMethodBody getMethod() { return _method; } public int getChannelId() { return _channelId; } public AMQProtocolSession getProtocolSession() { return _protocolSession; } public String toString() { StringBuffer buf = new StringBuffer(\"Method event: \"); buf.append(\"\\nChannel id: \").append(_channelId); buf.append(\"\\nMethod: \").append(_method); return buf.toString(); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import org.openamq.AMQException; public interface AMQMethodListener {  boolean methodReceived(AMQMethodEvent evt) throws AMQException;  void error(Exception e); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import java.util.concurrent.CopyOnWriteArraySet; import java.util.concurrent.CountDownLatch; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.IdleStatus; import org.apache.mina.common.IoHandlerAdapter; import org.apache.mina.common.IoSession; import org.apache.mina.filter.codec.ProtocolCodecFilter; import org.openamq.AMQDisconnectedException; import org.openamq.AMQException; import org.openamq.client.AMQConnection; import org.openamq.client.AMQSession; import org.openamq.client.state.AMQState; import org.openamq.client.state.AMQStateManager; import org.openamq.client.state.listener.ConnectionCloseOkListener; import org.openamq.client.state.listener.SpecificMethodFrameListener; import org.openamq.codec.AMQCodecFactory; import org.openamq.framing.*; import java.util.Iterator; public class AMQProtocolHandler extends IoHandlerAdapter { private static final Logger _logger = LoggerFactory.getLogger(AMQProtocolHandler.class);  private AMQConnection _connection;  private volatile AMQProtocolSession _protocolSession; private AMQStateManager _stateManager = new AMQStateManager(); private final CopyOnWriteArraySet _frameListeners = new CopyOnWriteArraySet();  private FailoverHandler _failoverHandler;  private FailoverState _failoverState = FailoverState.NOT_STARTED; private CountDownLatch _failoverLatch;  private class FailoverHandler implements Runnable { private final IoSession _session;  private String _host;  private int _port; public FailoverHandler(IoSession session) { _session = session; } public void run() { _failoverLatch = new CountDownLatch(1); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap; import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentMap; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.IoSession; import org.apache.mina.common.WriteFuture; import org.apache.mina.common.IdleStatus; import org.apache.mina.common.CloseFuture; import org.openamq.AMQException; import org.openamq.client.AMQConnection; import org.openamq.client.AMQSession; import org.openamq.client.ConnectionTuneParameters; import org.openamq.client.message.UnprocessedMessage; import org.openamq.client.message.UnexpectedBodyReceivedException; import org.openamq.framing.*; import javax.jms.JMSException; import javax.security.sasl.SaslClient;  public class AMQProtocolSession { private static final Logger _logger = LoggerFactory.getLogger(AMQProtocolSession.class); public static final String PROTOCOL_INITIATION_RECEIVED = \"ProtocolInitiatiionReceived\"; protected static final String CONNECTION_TUNE_PARAMETERS = \"ConnectionTuneParameters\"; private static final String AMQ_CONNECTION = \"AMQConnection\"; private static final String SASL_CLIENT = \"SASLClient\"; private final IoSession _minaProtocolSession;  private final AMQProtocolHandler _protocolHandler;  private ConcurrentMap _channelId2SessionMap = new ConcurrentHashMap(); private ConcurrentMap _closingChannels = new ConcurrentHashMap();  private ConcurrentMap _channelId2UnprocessedMsgMap = new ConcurrentHashMap();  private int _queueId = 1; private final Object _queueIdLock = new Object(); public AMQProtocolSession(AMQProtocolHandler protocolHandler, IoSession protocolSession, AMQConnection connection) { _protocolHandler = protocolHandler; _minaProtocolSession = protocolSession; "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import org.openamq.AMQException; import org.openamq.framing.AMQMethodBody; public abstract class BlockingMethodFrameListener implements AMQMethodListener { private volatile boolean _ready = false; public abstract boolean processMethod(int channelId, AMQMethodBody frame) throws AMQException; private final Object _lock = new Object();  private volatile Exception _error; protected int _channelId; protected AMQMethodEvent _doneEvt = null; public BlockingMethodFrameListener(int channelId) { _channelId = channelId; }  public boolean methodReceived(AMQMethodEvent evt) throws AMQException { AMQMethodBody method = evt.getMethod(); try { boolean ready = (evt.getChannelId() == _channelId) && processMethod(evt.getChannelId(), method); if (ready) { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol;  public class FailoverException extends RuntimeException { public FailoverException(String message) { super(message); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol;  final class FailoverState { private final String _state;  static final FailoverState NOT_STARTED = new FailoverState(\"NOT STARTED\");  static final FailoverState IN_PROGRESS = new FailoverState(\"IN PROGRESS\");  static final FailoverState FAILED = new FailoverState(\"FAILED\"); private FailoverState(String state) { _state = state; } public String toString() { return \"FailoverState: \" + _state; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.client.AMQConnection; import javax.jms.JMSException; public abstract class FailoverSupport { private static final Logger _log = LoggerFactory.getLogger(FailoverSupport.class); public Object execute(AMQConnection con) throws JMSException { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import org.slf4j.Logger; import org.slf4j.LoggerFactory; class HeartbeatConfig { private static final Logger _logger = LoggerFactory.getLogger(HeartbeatConfig.class); static final HeartbeatConfig CONFIG = new HeartbeatConfig();  private float timeoutFactor = 2; HeartbeatConfig() { String property = System.getProperty(\"amqj.heartbeat.timeoutFactor\"); if(property != null) { try { timeoutFactor = Float.parseFloat(property); } catch(NumberFormatException e) { _logger.warn(\"Invalid timeout factor (amqj.heartbeat.timeoutFactor): \" + property); } } } float getTimeoutFactor() { return timeoutFactor; } int getTimeout(int writeDelay) { return (int) (timeoutFactor * writeDelay); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; class HeartbeatDiagnostics { private static final Diagnostics _impl = init(); private static Diagnostics init() { return Boolean.getBoolean(\"amqj.heartbeat.diagnostics\") ? new On() : new Off(); } static void sent() { _impl.sent(); } static void timeout() { _impl.timeout(); } static void received(boolean heartbeat) { _impl.received(heartbeat); } static void init(int delay, int timeout) { _impl.init(delay, timeout); } private static interface Diagnostics { void sent(); void timeout(); void received(boolean heartbeat); void init(int delay, int timeout); } private static class On implements Diagnostics { private final String[] messages = new String[50]; private int i; private void save(String msg) { messages[i++] = msg; if(i >= messages.length){ i = 0;"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.protocol; import org.apache.mina.common.IoFilterAdapter; import org.apache.mina.common.IoSession; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class ProtocolBufferMonitorFilter extends IoFilterAdapter { private static final Logger _logger = LoggerFactory.getLogger(ProtocolBufferMonitorFilter.class); public static long DEFAULT_FREQUENCY = 5000; public static int DEFAULT_THRESHOLD = 3000; private int _bufferedMessages = 0; private int _threshold; private long _lastMessageOutputTime; private long _outputFrequencyInMillis; public ProtocolBufferMonitorFilter() { _threshold = DEFAULT_THRESHOLD; _outputFrequencyInMillis = DEFAULT_FREQUENCY; } public ProtocolBufferMonitorFilter(int threshold, long frequency) { _threshold = threshold; _outputFrequencyInMillis = frequency; } public void messageReceived( NextFilter nextFilter, IoSession session, Object message ) throws Exception { _bufferedMessages++; if (_bufferedMessages > _threshold) { long now = System.currentTimeMillis(); if ((now - _lastMessageOutputTime) > _outputFrequencyInMillis) { _logger.warn(\"Protocol message buffer exceeded threshold of \" + _threshold + \". Current backlog: \" + _bufferedMessages); _lastMessageOutputTime = now; } } nextFilter.messageReceived(session, message); } public void messageSent( NextFilter nextFilter, IoSession session, Object message ) throws Exception { _bufferedMessages--; nextFilter.messageSent(session, message); } public int getBufferedMessages() { return _bufferedMessages; } public int getThreshold() { return _threshold; } public void setThreshold(int threshold) { _threshold = threshold; } public long getOutputFrequencyInMillis() { return _outputFrequencyInMillis; } public void setOutputFrequencyInMillis(long outputFrequencyInMillis) { _outputFrequencyInMillis = outputFrequencyInMillis; } public long getLastMessageOutputTime() { return _lastMessageOutputTime; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.security; import org.openamq.client.protocol.AMQProtocolSession; import javax.security.auth.callback.CallbackHandler; public interface AMQCallbackHandler extends CallbackHandler { void initialise(AMQProtocolSession protocolSession); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.security; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.*; import java.util.*; public class CallbackHandlerRegistry { private static final String FILE_PROPERTY = \"amq.callbackhandler.properties\"; private static final Logger _logger = LoggerFactory.getLogger(CallbackHandlerRegistry.class); private static CallbackHandlerRegistry _instance = new CallbackHandlerRegistry(); private Map _mechanismToHandlerClassMap = new HashMap(); private String _mechanisms; public static CallbackHandlerRegistry getInstance() { return _instance; } public Class getCallbackHandlerClass(String mechanism) { return (Class) _mechanismToHandlerClassMap.get(mechanism); } public String getMechanisms() { return _mechanisms; } private CallbackHandlerRegistry() { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.security; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.security.sasl.SaslClientFactory; import java.io.*; import java.util.Properties; import java.util.Enumeration; import java.util.Map; import java.util.TreeMap; import java.security.Security; public class DynamicSaslRegistrar { private static final String FILE_PROPERTY = \"amq.dynamicsaslregistrar.properties\"; private static final Logger _logger = LoggerFactory.getLogger(DynamicSaslRegistrar.class); public static void registerSaslProviders() { InputStream is = openPropertiesInputStream(); try { Properties props = new Properties(); props.load(is); Map<String, Class<? extends SaslClientFactory>> factories = parseProperties(props); if (factories.size() > 0) { Security.addProvider(new JCAProvider(factories)); _logger.debug(\"Dynamic SASL provider added as a security provider\"); } } catch (IOException e) { _logger.error(\"Error reading properties: \" + e, e); } finally { if (is != null) { try { is.close(); } catch (IOException e) { _logger.error(\"Unable to close properties stream: \" + e, e); } } } } private static InputStream openPropertiesInputStream() { String filename = System.getProperty(FILE_PROPERTY); boolean useDefault = true; InputStream is = null; if (filename != null) { try { is = new BufferedInputStream(new FileInputStream(new File(filename))); useDefault = false; } catch (FileNotFoundException e) { _logger.error(\"Unable to read from file \" + filename + \": \" + e, e); } } if (useDefault) { is = CallbackHandlerRegistry.class.getResourceAsStream(\"DynamicSaslRegistrar.properties\"); } return is; } private static Map<String, Class<? extends SaslClientFactory>> parseProperties(Properties props) { Enumeration e = props.propertyNames(); TreeMap<String, Class<? extends SaslClientFactory>> factoriesToRegister = new TreeMap<String, Class<? extends SaslClientFactory>>(); while (e.hasMoreElements()) { String mechanism = (String) e.nextElement(); String className = props.getProperty(mechanism); try { Class<?> clazz = Class.forName(className); if (!(SaslClientFactory.class.isAssignableFrom(clazz))) { _logger.error(\"Class \" + clazz + \" does not implement \" + SaslClientFactory.class + \" - skipping\"); continue; } factoriesToRegister.put(mechanism, (Class<? extends SaslClientFactory>) clazz); } catch (Exception ex) { _logger.error(\"Error instantiating SaslClientFactory calss \" + className + \" - skipping\"); } } return factoriesToRegister; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.security; import javax.security.sasl.SaslClientFactory; import java.security.Provider; import java.security.Security; import java.util.Map; public class JCAProvider extends Provider { public JCAProvider(Map<String, Class<? extends SaslClientFactory>> providerMap) { super(\"AMQSASLProvider\", 1.0, \"A JCA provider that registers all \" + \"AMQ SASL providers that want to be registered\"); register(providerMap); Security.addProvider(this); } private void register(Map<String, Class<? extends SaslClientFactory>> providerMap) { for (Map.Entry<String, Class<? extends SaslClientFactory>> me : providerMap.entrySet()) { put(\"SaslClientFactory.\" + me.getKey(), me.getValue().getName()); } } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.security; import org.openamq.client.protocol.AMQProtocolSession; import javax.security.auth.callback.*; import java.io.IOException; public class UsernamePasswordCallbackHandler implements AMQCallbackHandler { private AMQProtocolSession _protocolSession; public void initialise(AMQProtocolSession protocolSession) { _protocolSession = protocolSession; } public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException { for (int i = 0; i < callbacks.length; i++) { Callback cb = callbacks[i]; if (cb instanceof NameCallback) { ((NameCallback)cb).setName(_protocolSession.getUsername()); } else if (cb instanceof PasswordCallback) { ((PasswordCallback)cb).setPassword(_protocolSession.getPassword().toCharArray()); } else { throw new UnsupportedCallbackException(cb); } } } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.security.amqplain; import org.openamq.framing.FieldTable; import javax.security.sasl.SaslClient; import javax.security.sasl.SaslException; import javax.security.auth.callback.CallbackHandler; import javax.security.auth.callback.NameCallback; import javax.security.auth.callback.PasswordCallback; import javax.security.auth.callback.Callback;  public class AmqPlainSaslClient implements SaslClient {  public static final String MECHANISM = \"AMQPLAIN\"; private CallbackHandler _cbh; public AmqPlainSaslClient(CallbackHandler cbh) { _cbh = cbh; } public String getMechanismName() { return \"AMQPLAIN\"; } public boolean hasInitialResponse() { return true; } public byte[] evaluateChallenge(byte[] challenge) throws SaslException { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.security.amqplain; import javax.security.sasl.SaslClientFactory; import javax.security.sasl.SaslClient; import javax.security.sasl.SaslException; import javax.security.sasl.Sasl; import javax.security.auth.callback.CallbackHandler; import java.util.Map; public class AmqPlainSaslClientFactory implements SaslClientFactory { public SaslClient createSaslClient(String[] mechanisms, String authorizationId, String protocol, String serverName, Map props, CallbackHandler cbh) throws SaslException { for (int i = 0; i < mechanisms.length; i++) { if (mechanisms[i].equals(AmqPlainSaslClient.MECHANISM)) { if (cbh == null) { throw new SaslException(\"CallbackHandler must not be null\"); } return new AmqPlainSaslClient(cbh); } } return null; } public String[] getMechanismNames(Map props) { if (props.containsKey(Sasl.POLICY_NOPLAINTEXT) || props.containsKey(Sasl.POLICY_NODICTIONARY) || props.containsKey(Sasl.POLICY_NOACTIVE)) { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state;  public class AMQState { private final int _id; private final String _name; private AMQState(int id, String name) { _id = id; _name = name; } public String toString() { return \"AMQState: id = \" + _id + \" name: \" + _name; } public static final AMQState CONNECTION_NOT_STARTED = new AMQState(1, \"CONNECTION_NOT_STARTED\"); public static final AMQState CONNECTION_NOT_TUNED = new AMQState(2, \"CONNECTION_NOT_TUNED\"); public static final AMQState CONNECTION_NOT_OPENED = new AMQState(3, \"CONNECTION_NOT_OPENED\"); public static final AMQState CONNECTION_OPEN = new AMQState(4, \"CONNECTION_OPEN\"); public static final AMQState CONNECTION_CLOSING = new AMQState(5, \"CONNECTION_CLOSING\"); public static final AMQState CONNECTION_CLOSED = new AMQState(6, \"CONNECTION_CLOSED\"); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state;  public class AMQStateChangedEvent { private final AMQState _oldState; private final AMQState _newState; public AMQStateChangedEvent(AMQState oldState, AMQState newState) { _oldState = oldState; _newState = newState; } public AMQState getOldState() { return _oldState; } public AMQState getNewState() { return _newState; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state; public interface AMQStateListener { void stateChanged(AMQStateChangedEvent evt); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state; import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArraySet; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; import org.openamq.framing.AMQMethodBody; import org.openamq.client.protocol.*; import org.openamq.client.handler.*; import org.openamq.framing.*; import java.util.HashMap; import java.util.Iterator; import java.util.Map;  public class AMQStateManager implements AMQMethodListener { private static final Logger _logger = LoggerFactory.getLogger(AMQStateManager.class);  private AMQState _currentState;  private final Map _state2HandlersMap = new HashMap(); private final CopyOnWriteArraySet _stateListeners = new CopyOnWriteArraySet(); public AMQStateManager() { this(AMQState.CONNECTION_NOT_STARTED, true); } protected AMQStateManager(AMQState state, boolean register) { _currentState = state; if(register) { registerListeners(); } } protected void registerListeners() { Map frame2handlerMap = new HashMap(); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state; import org.openamq.AMQException; public class IllegalStateTransitionException extends AMQException { private AMQState _originalState; private Class _frame; public IllegalStateTransitionException(AMQState originalState, Class frame) { super(\"No valid state transition defined for receiving frame \" + frame + \" from state \" + originalState); _originalState = originalState; _frame = frame; } public AMQState getOriginalState() { return _originalState; } public Class getFrameClass() { return _frame; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state; import org.openamq.client.protocol.AMQMethodEvent; import org.openamq.AMQException;  public interface StateAwareMethodListener { void methodReceived(AMQStateManager stateManager, AMQMethodEvent evt) throws AMQException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state; import org.openamq.AMQException; public interface StateListener { void stateChanged(AMQState oldState, AMQState newState) throws AMQException; void error(Throwable t); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException;  public class StateWaiter implements StateListener { private static final Logger _logger = LoggerFactory.getLogger(StateWaiter.class); private final AMQState _state; private volatile boolean _newStateAchieved; private volatile Throwable _throwable; private final Object _monitor = new Object(); public StateWaiter(AMQState state) { _state = state; } public void waituntilStateHasChanged() throws AMQException { synchronized (_monitor) { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state.listener; import org.openamq.AMQException; import org.openamq.client.protocol.BlockingMethodFrameListener; import org.openamq.framing.AMQMethodBody; import org.openamq.framing.ConnectionCloseOkBody; public class ConnectionCloseOkListener extends BlockingMethodFrameListener { public ConnectionCloseOkListener() { super(0); } public boolean processMethod(int channelId, AMQMethodBody frame) throws AMQException { return (frame instanceof ConnectionCloseOkBody); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.state.listener; import org.openamq.client.protocol.BlockingMethodFrameListener; import org.openamq.framing.AMQMethodBody; import org.openamq.AMQException; public class SpecificMethodFrameListener extends BlockingMethodFrameListener { private final Class _expectedClass; public SpecificMethodFrameListener(int channelId, Class expectedClass) { super(channelId); _expectedClass = expectedClass; } public boolean processMethod(int channelId, AMQMethodBody frame) throws AMQException { return _expectedClass.isInstance(frame); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.transport; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ConnectFuture; import org.apache.mina.common.ByteBuffer; import org.apache.mina.common.SimpleByteBufferAllocator; import org.apache.mina.transport.socket.nio.SocketSessionConfig; import org.apache.mina.transport.socket.nio.SocketConnectorConfig; import org.openamq.client.AMQConnection; import org.openamq.client.protocol.AMQProtocolHandler; import org.openamq.pool.ReadWriteThreadModel; import org.openamq.bio.SocketConnector; import java.io.IOException; import java.net.InetSocketAddress; public class BlockingSocketTransportConnection implements ITransportConnection { private static final Logger _logger = LoggerFactory.getLogger(BlockingSocketTransportConnection.class); public void connect(AMQProtocolHandler protocolHandler, AMQConnection.BrokerDetail brokerDetail) throws IOException { ByteBuffer.setUseDirectBuffers(Boolean.getBoolean(\"amqj.enableDirectBuffers\")); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.transport; import org.openamq.client.protocol.AMQProtocolHandler; import org.openamq.client.AMQConnection; import java.io.IOException; public interface ITransportConnection { void connect(AMQProtocolHandler protocolHandler, AMQConnection.BrokerDetail brokerDetail) throws IOException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.transport; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ConnectFuture; import org.apache.mina.common.ByteBuffer; import org.apache.mina.common.SimpleByteBufferAllocator; import org.apache.mina.transport.socket.nio.SocketConnector; import org.apache.mina.transport.socket.nio.SocketConnectorConfig; import org.apache.mina.transport.socket.nio.SocketSessionConfig; import org.openamq.client.AMQConnection; import org.openamq.client.protocol.AMQProtocolHandler; import org.openamq.pool.ReadWriteThreadModel; import java.io.IOException; import java.net.InetSocketAddress; public class SocketTransportConnection implements ITransportConnection { private static final Logger _logger = LoggerFactory.getLogger(SocketTransportConnection.class); public void connect(AMQProtocolHandler protocolHandler, AMQConnection.BrokerDetail brokerDetail) throws IOException { ByteBuffer.setUseDirectBuffers(Boolean.getBoolean(\"amqj.enableDirectBuffers\")); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.transport;  public class TransportConnection { private static ITransportConnection _instance; static { if(Boolean.getBoolean(\"amqj.useBlockingIo\")) { _instance = new BlockingSocketTransportConnection(); } else { _instance = new SocketTransportConnection(); } } public static void setInstance(ITransportConnection transport) { _instance = transport; } public static ITransportConnection getInstance() { return _instance; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.client.util; import edu.emory.mathcs.backport.java.util.concurrent.BlockingQueue; import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;  public class FlowControllingBlockingQueue {  private final BlockingQueue _queue = new LinkedBlockingQueue(); private final int _flowControlThreshold; private final ThresholdListener _listener;  private int _count; public interface ThresholdListener { void aboveThreshold(int currentValue); void underThreshold(int currentValue); } public FlowControllingBlockingQueue(int threshold, ThresholdListener listener) { _flowControlThreshold = threshold; _listener = listener; } public Object take() throws InterruptedException { Object o = _queue.take(); synchronized (_listener) { if (--_count == (_flowControlThreshold - 1)) { _listener.underThreshold(_count); } } return o; } public void add(Object o) { _queue.add(o); synchronized (_listener) { if (++_count == _flowControlThreshold) { _listener.aboveThreshold(_count); } } } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.codec; import org.apache.mina.filter.codec.ProtocolCodecFactory; import org.apache.mina.filter.codec.ProtocolDecoder; import org.apache.mina.filter.codec.ProtocolEncoder; public class AMQCodecFactory implements ProtocolCodecFactory { private AMQEncoder _encoder = new AMQEncoder(); private AMQDecoder _frameDecoder;  public AMQCodecFactory(boolean expectProtocolInitiation) { _frameDecoder = new AMQDecoder(expectProtocolInitiation); } public ProtocolEncoder getEncoder() { return _encoder; } public ProtocolDecoder getDecoder() { return _frameDecoder; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.codec; import org.apache.mina.common.ByteBuffer; import org.apache.mina.common.IoSession; import org.apache.mina.filter.codec.CumulativeProtocolDecoder; import org.apache.mina.filter.codec.ProtocolDecoderOutput; import org.openamq.framing.AMQDataBlockDecoder; import org.openamq.framing.ProtocolInitiation;  public class AMQDecoder extends CumulativeProtocolDecoder { private AMQDataBlockDecoder _dataBlockDecoder = new AMQDataBlockDecoder(); private ProtocolInitiation.Decoder _piDecoder = new ProtocolInitiation.Decoder(); private boolean _expectProtocolInitiation; public AMQDecoder(boolean expectProtocolInitiation) { _expectProtocolInitiation = expectProtocolInitiation; } protected boolean doDecode(IoSession session, ByteBuffer in, ProtocolDecoderOutput out) throws Exception { if (_expectProtocolInitiation) { return doDecodePI(session, in, out); } else { return doDecodeDataBlock(session, in, out); } } protected boolean doDecodeDataBlock(IoSession session, ByteBuffer in, ProtocolDecoderOutput out) throws Exception { int pos = in.position(); boolean enoughData = _dataBlockDecoder.decodable(session, in); in.position(pos); if (!enoughData) { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.codec; import org.apache.mina.filter.codec.ProtocolEncoder; import org.apache.mina.filter.codec.ProtocolEncoderOutput; import org.apache.mina.common.IoSession; import org.openamq.framing.AMQDataBlockEncoder; public class AMQEncoder implements ProtocolEncoder { private AMQDataBlockEncoder _dataBlockEncoder = new AMQDataBlockEncoder(); public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception { _dataBlockEncoder.encode(session, message, out); } public void dispose(IoSession session) throws Exception { } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.configuration; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.ElementType; import java.lang.annotation.Target; public @interface Configured {  String path();  String defaultValue(); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public abstract class AMQBody { protected abstract byte getType();  protected abstract int getSize(); protected abstract void writePayload(ByteBuffer buffer); protected abstract void populateFromBuffer(ByteBuffer buffer, long size) throws AMQFrameDecodingException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer;  public abstract class AMQDataBlock implements EncodableAMQDataBlock {  public abstract long getSize();  public abstract void writePayload(ByteBuffer buffer); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; import org.apache.mina.common.IoSession; import org.apache.mina.filter.codec.ProtocolDecoderOutput; import java.util.HashMap; import java.util.Map; public class AMQDataBlockDecoder { Logger _logger = LoggerFactory.getLogger(AMQDataBlockDecoder.class); private final Map _supportedBodies = new HashMap(); public AMQDataBlockDecoder() { _supportedBodies.put(new Byte(AMQMethodBody.TYPE), AMQMethodBodyFactory.getInstance()); _supportedBodies.put(new Byte(ContentHeaderBody.TYPE), ContentHeaderBodyFactory.getInstance()); _supportedBodies.put(new Byte(ContentBody.TYPE), ContentBodyFactory.getInstance()); _supportedBodies.put(new Byte(HeartbeatBody.TYPE), new HeartbeatBodyFactory()); } public boolean decodable(IoSession session, ByteBuffer in) throws AMQFrameDecodingException { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; import org.apache.mina.common.IoSession; import org.apache.mina.filter.codec.demux.MessageEncoder; import org.apache.mina.filter.codec.ProtocolEncoderOutput; import java.util.HashSet; import java.util.Set; public class AMQDataBlockEncoder implements MessageEncoder { Logger _logger = LoggerFactory.getLogger(AMQDataBlockEncoder.class); private Set _messageTypes; public AMQDataBlockEncoder() { _messageTypes = new HashSet(); _messageTypes.add(EncodableAMQDataBlock.class); } public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception { final AMQDataBlock frame = (AMQDataBlock) message; int frameSize = (int)frame.getSize(); final ByteBuffer buffer = ByteBuffer.allocate(frameSize); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public class AMQFrame extends AMQDataBlock implements EncodableAMQDataBlock { public int channel; public AMQBody bodyFrame; public AMQFrame() { } public AMQFrame(int channel, AMQBody bodyFrame) { this.channel = channel; this.bodyFrame = bodyFrame; } public long getSize() { return 1 + 2 + 4 + bodyFrame.getSize() + 1; } public void writePayload(ByteBuffer buffer) { buffer.put(bodyFrame.getType()); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.openamq.AMQException; public class AMQFrameDecodingException extends AMQException { public AMQFrameDecodingException(String message) { super(message); } public AMQFrameDecodingException(String message, Throwable t) { super(message, t); } public AMQFrameDecodingException(Logger log, String message) { super(log, message); } public AMQFrameDecodingException(Logger log, String message, Throwable t) { super(log, message, t); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; import org.openamq.AMQChannelException; public abstract class AMQMethodBody extends AMQBody { public static final byte TYPE = 1;  protected abstract int getBodySize();  protected abstract int getClazz();  protected abstract int getMethod(); protected abstract void writeMethodPayload(ByteBuffer buffer); protected byte getType() { return TYPE; } protected int getSize() { return 2 + 2 + getBodySize(); } protected void writePayload(ByteBuffer buffer) { EncodingUtils.writeUnsignedShort(buffer, getClazz()); EncodingUtils.writeUnsignedShort(buffer, getMethod()); writeMethodPayload(buffer); } protected abstract void populateMethodBodyFromBuffer(ByteBuffer buffer) throws AMQFrameDecodingException; protected void populateFromBuffer(ByteBuffer buffer, long size) throws AMQFrameDecodingException { populateMethodBodyFromBuffer(buffer); } public String toString() { StringBuffer buf = new StringBuffer(getClass().toString()); buf.append(\" Class: \").append(getClazz()); buf.append(\" Method: \").append(getMethod()); return buf.toString(); }  public AMQChannelException getChannelException(int code, String message) { return new AMQChannelException(code, message, getClazz(), getMethod()); } public AMQChannelException getChannelException(int code, String message, Throwable cause) { return new AMQChannelException(code, message, getClazz(), getMethod(), cause); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; public class AMQMethodBodyFactory implements BodyFactory { private static final Logger _log = LoggerFactory.getLogger(AMQMethodBodyFactory.class); private static final AMQMethodBodyFactory _instance = new AMQMethodBodyFactory(); public static AMQMethodBodyFactory getInstance() { return _instance; } private AMQMethodBodyFactory() { _log.debug(\"Creating method body factory\"); } public AMQBody createBody(ByteBuffer in) throws AMQFrameDecodingException { return MethodBodyDecoderRegistry.get(in.getUnsignedShort(), in.getUnsignedShort()); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; public class AMQProtocolClassException extends AMQProtocolHeaderException { public AMQProtocolClassException(String message) { super(message); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.openamq.AMQException; public class AMQProtocolHeaderException extends AMQException { public AMQProtocolHeaderException(String message) { super(message); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; public class AMQProtocolInstanceException extends AMQProtocolHeaderException { public AMQProtocolInstanceException(String message) { super(message); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing;  public class AMQProtocolVersionException extends AMQProtocolHeaderException { public AMQProtocolVersionException(String message) { super(message); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class BasicContentHeaderProperties implements ContentHeaderProperties { private static final Logger _logger = LoggerFactory.getLogger(BasicContentHeaderProperties.class);  private byte[] _encodedForm;  private boolean _decoded = true;  private boolean _decodedHeaders = true;  private boolean _decodedContentType = true; private String _contentType; private String _encoding; private FieldTable _headers; private byte _deliveryMode; private byte _priority; private String _correlationId; private String _replyTo; private long _expiration; private String _messageId; private long _timestamp; private String _type; private String _userId; private String _appId; private String _clusterId; private int _propertyFlags = 0; public BasicContentHeaderProperties() { } public int getPropertyListSize() { if (_encodedForm != null) { return _encodedForm.length; } else { int size = 0; if ((_propertyFlags & (1 << 15)) > 0) { size += EncodingUtils.encodedShortStringLength(_contentType); } if ((_propertyFlags & (1 << 14)) > 0) { size += EncodingUtils.encodedShortStringLength(_encoding); } if ((_propertyFlags & (1 << 13)) > 0) { size += EncodingUtils.encodedFieldTableLength(_headers); } if ((_propertyFlags & (1 << 12)) > 0) { size += 1; } if ((_propertyFlags & (1 << 11)) > 0) { size += 1; } if ((_propertyFlags & (1 << 10)) > 0) { size += EncodingUtils.encodedShortStringLength(_correlationId); } if ((_propertyFlags & (1 << 9)) > 0) { size += EncodingUtils.encodedShortStringLength(_replyTo); } if ((_propertyFlags & (1 << 8)) > 0) { size += EncodingUtils.encodedShortStringLength(String.valueOf(_expiration)); } if ((_propertyFlags & (1 << 7)) > 0) { size += EncodingUtils.encodedShortStringLength(_messageId); } if ((_propertyFlags & (1 << 6)) > 0) { size += 8; } if ((_propertyFlags & (1 << 5)) > 0) { size += EncodingUtils.encodedShortStringLength(_type); } if ((_propertyFlags & (1 << 4)) > 0) { size += EncodingUtils.encodedShortStringLength(_userId); } if ((_propertyFlags & (1 << 3)) > 0) { size += EncodingUtils.encodedShortStringLength(_appId); } if ((_propertyFlags & (1 << 2)) > 0) { size += EncodingUtils.encodedShortStringLength(_clusterId); } return size; } } private void clearEncodedForm() { if (!_decoded && _encodedForm != null) { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer;  public interface BodyFactory { AMQBody createBody(ByteBuffer in) throws AMQFrameDecodingException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public class CompositeAMQDataBlock extends AMQDataBlock implements EncodableAMQDataBlock { private ByteBuffer _encodedBlock; private AMQDataBlock[] _blocks; public CompositeAMQDataBlock(AMQDataBlock[] blocks) { _blocks = blocks; }  public CompositeAMQDataBlock(ByteBuffer encodedBlock, AMQDataBlock[] blocks) { this(blocks); _encodedBlock = encodedBlock; } public AMQDataBlock[] getBlocks() { return _blocks; } public ByteBuffer getEncodedBlock() { return _encodedBlock; } public long getSize() { long frameSize = 0; for (int i = 0; i < _blocks.length; i++) { frameSize += _blocks[i].getSize(); } if (_encodedBlock != null) { _encodedBlock.rewind(); frameSize += _encodedBlock.remaining(); } return frameSize; } public void writePayload(ByteBuffer buffer) { if (_encodedBlock != null) { buffer.put(_encodedBlock); } for (int i = 0; i < _blocks.length; i++) { _blocks[i].writePayload(buffer); } } public String toString() { if (_blocks == null) { return \"No blocks contained in composite frame\"; } else { StringBuilder buf = new StringBuilder(); for (int i = 0 ; i< _blocks.length; i++) { buf.append(\"Block \").append(i).append('\\n').append(_blocks[i].toString()); } return buf.toString(); } } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public class ContentBody extends AMQBody { public static final byte TYPE = 3; public ByteBuffer payload; protected byte getType() { return TYPE; } public int getSize() { return (payload == null?0:payload.limit()); } public void writePayload(ByteBuffer buffer) { if (payload != null) { ByteBuffer copy = payload.duplicate(); buffer.put(copy.rewind()); } } protected void populateFromBuffer(ByteBuffer buffer, long size) throws AMQFrameDecodingException { if (size > 0) { payload = buffer.slice(); payload.limit((int)size); buffer.skip((int)size); } } public static AMQFrame createAMQFrame(int channelId, ContentBody body) { final AMQFrame frame = new AMQFrame(); frame.channel = channelId; frame.bodyFrame = body; return frame; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; public class ContentBodyFactory implements BodyFactory { private static final Logger _log = LoggerFactory.getLogger(AMQMethodBodyFactory.class); private static final ContentBodyFactory _instance = new ContentBodyFactory(); public static ContentBodyFactory getInstance() { return _instance; } private ContentBodyFactory() { _log.debug(\"Creating content body factory\"); } public AMQBody createBody(ByteBuffer in) throws AMQFrameDecodingException { return new ContentBody(); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public class ContentHeaderBody extends AMQBody { public static final byte TYPE = 2; public int classId; public int weight;  public long bodySize;  public ContentHeaderProperties properties; public ContentHeaderBody() { } public ContentHeaderBody(ContentHeaderProperties props, int classId) { properties = props; this.classId = classId; } public ContentHeaderBody(int classId, int weight, ContentHeaderProperties props, long bodySize) { this(props, classId); this.weight = weight; this.bodySize = bodySize; } protected byte getType() { return TYPE; } protected void populateFromBuffer(ByteBuffer buffer, long size) throws AMQFrameDecodingException { classId = buffer.getUnsignedShort(); weight = buffer.getUnsignedShort(); bodySize = buffer.getLong(); int propertyFlags = buffer.getUnsignedShort(); ContentHeaderPropertiesFactory factory = ContentHeaderPropertiesFactory.getInstance(); properties = factory.createContentHeaderProperties(classId, propertyFlags, buffer, (int)size - 14); }  public static ContentHeaderBody createFromBuffer(ByteBuffer buffer, long size) throws AMQFrameDecodingException { ContentHeaderBody body = new ContentHeaderBody(); body.populateFromBuffer(buffer, size); return body; } public int getSize() { return 2 + 2 + 8 + 2 + properties.getPropertyListSize(); } public void writePayload(ByteBuffer buffer) { EncodingUtils.writeUnsignedShort(buffer, classId); EncodingUtils.writeUnsignedShort(buffer, weight); buffer.putLong(bodySize); EncodingUtils.writeUnsignedShort(buffer, properties.getPropertyFlags()); properties.writePropertyListPayload(buffer); } public static AMQFrame createAMQFrame(int channelId, int classId, int weight, BasicContentHeaderProperties properties, long bodySize) { final AMQFrame frame = new AMQFrame(); frame.channel = channelId; frame.bodyFrame = new ContentHeaderBody(classId, weight, properties, bodySize); return frame; } public static AMQFrame createAMQFrame(int channelId, ContentHeaderBody body) { final AMQFrame frame = new AMQFrame(); frame.channel = channelId; frame.bodyFrame = body; return frame; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; public class ContentHeaderBodyFactory implements BodyFactory { private static final Logger _log = LoggerFactory.getLogger(AMQMethodBodyFactory.class); private static final ContentHeaderBodyFactory _instance = new ContentHeaderBodyFactory(); public static ContentHeaderBodyFactory getInstance() { return _instance; } private ContentHeaderBodyFactory() { _log.debug(\"Creating content header body factory\"); } public AMQBody createBody(ByteBuffer in) throws AMQFrameDecodingException { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer;  public interface ContentHeaderProperties {  void writePropertyListPayload(ByteBuffer buffer);  void populatePropertiesFromBuffer(ByteBuffer buffer, int propertyFlags, int size) throws AMQFrameDecodingException;  int getPropertyListSize();  int getPropertyFlags(); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public class ContentHeaderPropertiesFactory { private static final ContentHeaderPropertiesFactory _instance = new ContentHeaderPropertiesFactory(); public static ContentHeaderPropertiesFactory getInstance() { return _instance; } private ContentHeaderPropertiesFactory() { } public ContentHeaderProperties createContentHeaderProperties(int classId, int propertyFlags, ByteBuffer buffer, int size) throws AMQFrameDecodingException { ContentHeaderProperties properties; switch (classId) { case BasicConsumeBody.CLASS_ID: properties = new BasicContentHeaderProperties(); break; default: throw new AMQFrameDecodingException(\"Unsupport content header class id: \" + classId); } properties.populatePropertiesFromBuffer(buffer, propertyFlags, size); return properties; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing;  public interface EncodableAMQDataBlock { }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.ByteBuffer; import java.nio.charset.Charset; public class EncodingUtils { private static final Logger _logger = LoggerFactory.getLogger(EncodingUtils.class); private static final String STRING_ENCODING = \"iso8859-15\"; private static final Charset _charset = Charset.forName(\"iso8859-15\"); public static final int SIZEOF_UNSIGNED_SHORT = 2; public static final int SIZEOF_UNSIGNED_INT = 4; public static int encodedShortStringLength(String s) { if (s == null) { return 1; } else { return (short) (1 + s.length()); } } public static int encodedLongStringLength(String s) { if (s == null) { return 4; } else { return 4 + s.length(); } } public static int encodedLongStringLength(char[] s) { if (s == null) { return 4; } else { return 4 + s.length; } } public static int encodedLongstrLength(byte[] bytes) { if (bytes == null) { return 4; } else { return 4 + bytes.length; } } public static int encodedFieldTableLength(FieldTable table) { if (table == null) { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map;  public class FieldTable extends LinkedHashMap { private long _encodedSize = 0; public FieldTable() { super(); }  public FieldTable(ByteBuffer buffer, long length) throws AMQFrameDecodingException { super(); assert length > 0; _encodedSize = length; int sizeRead = 0; while (sizeRead < _encodedSize) { int sizeRemaining = buffer.remaining(); final String key = EncodingUtils.readShortString(buffer); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public class HeartbeatBody extends AMQBody { public static final byte TYPE = 8; public static AMQFrame FRAME = new HeartbeatBody().toFrame(); protected byte getType() { return TYPE; } protected int getSize() { return 0;"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; public class HeartbeatBodyFactory implements BodyFactory { public AMQBody createBody(ByteBuffer in) throws AMQFrameDecodingException { return new HeartbeatBody(); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.framing; import org.apache.mina.common.ByteBuffer; import org.apache.mina.common.IoSession; import org.apache.mina.filter.codec.ProtocolDecoderOutput; import org.openamq.AMQException; public class ProtocolInitiation extends AMQDataBlock implements EncodableAMQDataBlock { public char[] header = new char[]{'A','M','Q','P'}; "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.jms; import javax.jms.ResourceAllocationException;  public class ChannelLimitReachedException extends ResourceAllocationException { private static final String ERROR_CODE = \"1\"; private long _limit; public ChannelLimitReachedException(long limit) { super(\"Unable to create session since maximum number of sessions per connection is \" + limit + \". Either close one or more sessions or increase the \" + \"maximum number of sessions per connection (or contact your OpenAMQ administrator.\", ERROR_CODE); _limit = limit; } public long getLimit() { return _limit; } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.jms; import javax.jms.*; public interface Connection extends javax.jms.Connection {  long getMaximumChannelCount(); void setConnectionListener(ConnectionListener listener);  ConnectionListener getConnectionListener();  org.openamq.jms.Session createSession(boolean transacted, int acknowledgeMode, int prefetch) throws JMSException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.jms; public interface ConnectionListener {  void bytesSent(long count);  void bytesReceived(long count);  boolean preFailover(boolean redirect);  boolean preResubscribe();  void failoverComplete(); }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.jms;  public interface MessageConsumer extends javax.jms.MessageConsumer { }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.jms; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.Message; import java.io.UnsupportedEncodingException;  public interface MessageProducer extends javax.jms.MessageProducer {  void setMimeType(String mimeType);  void setEncoding(String encoding) throws UnsupportedEncodingException; void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive, boolean immediate) throws JMSException; void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive, boolean mandatory, boolean immediate) throws JMSException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.jms; import javax.jms.*; import javax.jms.MessageConsumer; import javax.jms.MessageProducer; public interface Session extends javax.jms.Session {  static final int NO_ACKNOWLEDGE = 257;  static final int PRE_ACKNOWLEDGE = 258; MessageConsumer createConsumer(Destination destination, int prefetch, boolean noLocal, boolean exclusive, String selector) throws JMSException;  int getDefaultPrefetch();  MessageProducer createProducer(Destination destination, boolean mandatory, boolean immediate) throws JMSException;  MessageProducer createProducer(Destination destination, boolean immediate) throws JMSException; }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.nio; import org.apache.mina.common.support.DelegatedIoAcceptor; public class SocketAcceptor extends DelegatedIoAcceptor {  public SocketAcceptor() { init(new SocketAcceptorDelegate(this)); } }"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketAcceptorDelegate.java 379346 2006-02-21 05:10:30Z trustin $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.nio; import org.apache.mina.common.support.DelegatedIoConnector; import org.apache.mina.transport.socket.nio.support.*; public class SocketConnector extends DelegatedIoConnector {  public SocketConnector() { init(new SocketConnectorDelegate(this)); } }"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketConnectorDelegate.java 379044 2006-02-20 07:40:37Z trustin $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.nio; import java.io.IOException; import org.apache.mina.common.ByteBuffer; import org.apache.mina.common.IoFilterChain; import org.apache.mina.common.IoSession; import org.apache.mina.common.IoFilter.WriteRequest; import org.apache.mina.common.support.AbstractIoFilterChain; import org.apache.mina.util.Queue;  class SocketFilterChain extends AbstractIoFilterChain { public SocketFilterChain( IoSession parent ) { super( parent ); } protected void doWrite( IoSession session, WriteRequest writeRequest ) { SocketSessionImpl s = ( SocketSessionImpl ) session; Queue writeRequestQueue = s.getWriteRequestQueue(); "}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketIoProcessor.java 372449 2006-01-26 05:24:58Z trustin $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "/* * @(#) $Id: SocketSessionImpl.java 385247 2006-03-12 05:06:11Z trustin $ * * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.pool; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.IoFilter; import org.apache.mina.common.IoSession; import org.apache.mina.common.IdleStatus;  enum EventType { OPENED, CLOSED, READ, WRITE, WRITTEN, RECEIVED, SENT, IDLE, EXCEPTION } class Event { private static final Logger _log = LoggerFactory.getLogger(Event.class); private final EventType type; private final IoFilter.NextFilter nextFilter; private final Object data; public Event(IoFilter.NextFilter nextFilter, EventType type, Object data) { this.type = type; this.nextFilter = nextFilter; this.data = data; if (type == EventType.EXCEPTION) { _log.error(\"Exception event constructed: \" + data, (Exception) data); } } public Object getData() { return data; } public IoFilter.NextFilter getNextFilter() { return nextFilter; } public EventType getType() { return type; } void process(IoSession session) { if (_log.isDebugEnabled()) { _log.debug(\"Processing \" + this); } if (type == EventType.RECEIVED) { nextFilter.messageReceived(session, data); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.pool; import org.apache.mina.common.IoSession; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger;  class Job implements Runnable { private final int _maxEvents; private final IoSession _session; private final java.util.Queue<Event> _eventQueue = new ConcurrentLinkedQueue<Event>(); private final AtomicBoolean _active = new AtomicBoolean(); private final AtomicInteger _refCount = new AtomicInteger(); private final JobCompletionHandler _completionHandler; Job(IoSession session, JobCompletionHandler completionHandler, int maxEvents) { _session = session; _completionHandler = completionHandler; _maxEvents = maxEvents; } void acquire() { _refCount.incrementAndGet(); } void release() { _refCount.decrementAndGet(); } boolean isReferenced() { return _refCount.get() > 0; } void add(Event evt) { _eventQueue.add(evt); } void processAll() { "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.pool; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.mina.common.IdleStatus; import org.apache.mina.common.IoFilterAdapter; import org.apache.mina.common.IoSession; import java.util.Arrays; import java.util.HashSet; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; public class PoolingFilter extends IoFilterAdapter implements Job.JobCompletionHandler { private static final Logger _logger = LoggerFactory.getLogger(PoolingFilter.class); public static final Set<EventType> READ_EVENTS = new HashSet<EventType>(Arrays.asList(EventType.RECEIVED)); public static final Set<EventType> WRITE_EVENTS = new HashSet<EventType>(Arrays.asList(EventType.WRITE)); private final ConcurrentMap<IoSession, Job> _jobs = new ConcurrentHashMap<IoSession, Job>(); private final ReferenceCountingExecutorService _poolReference; private final Set<EventType> _asyncTypes; private final String _name; private final int _maxEvents = Integer.getInteger(\"amqj.server.read_write_pool.max_events\", 10); public PoolingFilter(ReferenceCountingExecutorService refCountingPool, Set<EventType> asyncTypes, String name) { _poolReference = refCountingPool; _asyncTypes = asyncTypes; _name = name; } private void fireEvent(IoSession session, Event event) { if (_asyncTypes.contains(event.getType())) { Job job = getJobForSession(session); job.acquire(); "}
{"name": "imatix/openamq-jms", "content": "package org.openamq.pool; import org.apache.mina.common.ThreadModel; import org.apache.mina.common.IoFilterChain; import org.apache.mina.common.ReferenceCountingIoFilterWrapper; public class ReadWriteThreadModel implements ThreadModel { public void buildFilterChain(IoFilterChain chain) throws Exception { ReferenceCountingExecutorService executor = ReferenceCountingExecutorService.getInstance(); PoolingFilter asyncRead = new PoolingFilter(executor, PoolingFilter.READ_EVENTS, \"AsynchronousReadFilter\"); PoolingFilter asyncWrite = new PoolingFilter(executor, PoolingFilter.WRITE_EVENTS, \"AsynchronousWriteFilter\"); chain.addFirst(\"AsynchronousReadFilter\", new ReferenceCountingIoFilterWrapper(asyncRead)); chain.addLast(\"AsynchronousWriteFilter\", new ReferenceCountingIoFilterWrapper(asyncWrite)); } }"}
{"name": "imatix/openamq-jms", "content": "package org.openamq.pool; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;  public class ReferenceCountingExecutorService { private ExecutorService _pool; private int _refCount = 0;  private final Object _lock = new Object(); private int _poolSize = Integer.getInteger(\"amqj.read_write_pool_size\", 4); private static final ReferenceCountingExecutorService _instance = new ReferenceCountingExecutorService(); public static ReferenceCountingExecutorService getInstance() { return _instance; } private ReferenceCountingExecutorService() { } ExecutorService acquireExecutorService() { synchronized (_lock) { if (_refCount++ == 0) { _pool = Executors.newFixedThreadPool(_poolSize); } return _pool; } } void releaseExecutorService() { synchronized (_lock) { if (--_refCount == 0) { _pool.shutdownNow(); } } }  public ExecutorService getPool() { return _pool; } }"}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc; import java.io.IOException; import java.util.Arrays; import cascading.jdbc.db.DBInputFormat; import cascading.jdbc.db.DBOutputFormat; import cascading.scheme.Scheme; import cascading.tap.Tap; import cascading.tap.TapException; import cascading.tuple.Fields; import cascading.tuple.Tuple; import cascading.tuple.TupleEntry; import cascading.util.Util; import org.apache.hadoop.mapred.JobConf; import org.apache.hadoop.mapred.OutputCollector;  public class JDBCScheme extends Scheme { private Class<? extends DBInputFormat> inputFormatClass; private Class<? extends DBOutputFormat> outputFormatClass; private String[] columns; private String[] orderBy; private String conditions; private String[] updateBy; private Fields updateValueFields; private Fields updateByFields; private Fields columnFields; private Tuple updateIfTuple; private String selectQuery; private String countQuery; private long limit = -1;  public JDBCScheme( Class<? extends DBInputFormat> inputFormatClass, Class<? extends DBOutputFormat> outputFormatClass, String[] columns, String[] orderBy, String conditions, long limit, String[] updateBy ) { this( inputFormatClass, outputFormatClass, new Fields( columns ), columns, orderBy, conditions, limit, updateBy != null ? new Fields( updateBy ) : null, updateBy ); }  public JDBCScheme( Class<? extends DBInputFormat> inputFormatClass, Class<? extends DBOutputFormat> outputFormatClass, Fields columnFields, String[] columns, String[] orderBy, String conditions, long limit, Fields updateByFields, String[] updateBy ) { this.columnFields = columnFields; verifyColumns( columnFields, columns ); setSinkFields( columnFields ); setSourceFields( columnFields ); if( updateBy != null && updateBy.length != 0 ) { this.updateBy = updateBy; this.updateByFields = updateByFields; if( updateByFields.size() != updateBy.length ) throw new IllegalArgumentException( \"updateByFields and updateBy must be the same size\" ); if( !this.columnFields.contains( this.updateByFields ) ) throw new IllegalArgumentException( \"columnFields must contain updateByFields column names\" ); this.updateValueFields = columnFields.subtract( updateByFields ).append( updateByFields ); this.updateIfTuple = Tuple.size( updateByFields.size() ); "}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc; import java.io.IOException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.Collections; import java.util.List; import cascading.jdbc.db.DBConfiguration; import cascading.tap.SinkMode; import cascading.tap.Tap; import cascading.tap.TapException; import cascading.tap.hadoop.TapCollector; import cascading.tap.hadoop.TapIterator; import cascading.tuple.TupleEntryCollector; import cascading.tuple.TupleEntryIterator; import org.apache.hadoop.fs.Path; import org.apache.hadoop.mapred.FileInputFormat; import org.apache.hadoop.mapred.JobConf; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class JDBCTap extends Tap {  private static final Logger LOG = LoggerFactory.getLogger( JDBCTap.class );  String connectionUrl;  String username;  String password;  String driverClassName;  TableDesc tableDesc;  int batchSize = 1000;  int concurrentReads = 0;  public JDBCTap( String connectionUrl, String username, String password, String driverClassName, String tableName, JDBCScheme scheme ) { this( connectionUrl, username, password, driverClassName, new TableDesc( tableName ), scheme, SinkMode.APPEND ); }  public JDBCTap( String connectionUrl, String driverClassName, TableDesc tableDesc, JDBCScheme scheme, SinkMode sinkMode ) { this( connectionUrl, null, null, driverClassName, tableDesc, scheme, sinkMode ); }  public JDBCTap( String connectionUrl, String username, String password, String driverClassName, TableDesc tableDesc, JDBCScheme scheme ) { this( connectionUrl, username, password, driverClassName, tableDesc, scheme, SinkMode.APPEND ); }  public JDBCTap( String connectionUrl, String username, String password, String driverClassName, TableDesc tableDesc, JDBCScheme scheme, SinkMode sinkMode ) { super( scheme, sinkMode ); this.connectionUrl = connectionUrl; this.username = username; this.password = password; this.driverClassName = driverClassName; this.tableDesc = tableDesc; if( tableDesc.getColumnDefs() == null && sinkMode != SinkMode.APPEND ) throw new IllegalArgumentException( \"cannot have sink mode REPLACE or KEEP without TableDesc column defs, use APPEND mode\" ); if( sinkMode != SinkMode.APPEND ) LOG.warn( \"using sink mode: {}, consider APPEND to prevent DROP TABLE from being called during Flow or Cascade setup\", sinkMode ); }  public JDBCTap( String connectionUrl, String driverClassName, TableDesc tableDesc, JDBCScheme scheme ) { this( connectionUrl, driverClassName, tableDesc, scheme, SinkMode.APPEND ); }  public JDBCTap( String connectionUrl, String username, String password, String driverClassName, JDBCScheme scheme ) { super( scheme ); this.connectionUrl = connectionUrl; this.username = username; this.password = password; this.driverClassName = driverClassName; }  public JDBCTap( String connectionUrl, String driverClassName, JDBCScheme scheme ) { this( connectionUrl, null, null, driverClassName, scheme ); }  public String getTableName() { return tableDesc.tableName; }  public void setBatchSize( int batchSize ) { this.batchSize = batchSize; }  public int getBatchSize() { return batchSize; }  public int getConcurrentReads() { return concurrentReads; }  public void setConcurrentReads( int concurrentReads ) { this.concurrentReads = concurrentReads; }  public Path getPath() { return new Path( \"jdbc:/\" + connectionUrl.replaceAll( \":\", \"_\" ) ); } @Override public boolean isWriteDirect() { return true; } public TupleEntryIterator openForRead( JobConf conf ) throws IOException { return new TupleEntryIterator( getSourceFields(), new TapIterator( this, conf ) ); } public TupleEntryCollector openForWrite( JobConf conf ) throws IOException { if( !isSink() ) throw new TapException( \"this tap may not be used as a sink, no TableDesc defined\" ); return new TapCollector( this, conf ); } @Override public boolean isSink() { return tableDesc != null; } @Override public void sourceInit( JobConf conf ) throws IOException { "}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import cascading.util.Util;  public class TableDesc implements Serializable {  String tableName;  String[] columnNames;  String[] columnDefs;  String[] primaryKeys;  public TableDesc( String tableName ) { this.tableName = tableName; }  public TableDesc( String tableName, String[] columnNames, String[] columnDefs, String[] primaryKeys ) { this.tableName = tableName; this.columnNames = columnNames; this.columnDefs = columnDefs; this.primaryKeys = primaryKeys; } public String getTableName() { return tableName; } public String[] getColumnNames() { return columnNames; } public String[] getColumnDefs() { return columnDefs; } public String[] getPrimaryKeys() { return primaryKeys; }  public String getCreateTableStatement() { List<String> createTableStatement = new ArrayList<String>(); createTableStatement = addCreateTableBodyTo( createTableStatement ); return String.format( getCreateTableFormat(), tableName, Util.join( createTableStatement, \", \" ) ); } protected List<String> addCreateTableBodyTo( List<String> createTableStatement ) { createTableStatement = addDefinitionsTo( createTableStatement ); createTableStatement = addPrimaryKeyTo( createTableStatement ); return createTableStatement; } protected String getCreateTableFormat() { return \"CREATE TABLE %s ( %s )\"; } protected List<String> addDefinitionsTo( List<String> createTableStatement ) { for( int i = 0; i < columnNames.length; i++ ) { String columnName = columnNames[ i ]; String columnDef = columnDefs[ i ]; createTableStatement.add( columnName + \" \" + columnDef ); } return createTableStatement; } protected List<String> addPrimaryKeyTo( List<String> createTableStatement ) { if( hasPrimaryKey() ) createTableStatement.add( String.format( \"PRIMARY KEY( %s )\", Util.join( primaryKeys, \", \" ) ) ); return createTableStatement; }  public String getTableDropStatement() { return String.format( getDropTableFormat(), tableName ); } protected String getDropTableFormat() { return \"DROP TABLE %s\"; }  public String getTableExistsQuery() { return String.format( \"select 1 from %s where 1 = 0\", tableName ); } private boolean hasPrimaryKey() { return primaryKeys != null && primaryKeys.length != 0; } @Override public String toString() { return \"TableDesc{\" + \"tableName='\" + tableName + '\\'' + \", columnNames=\" + ( columnNames == null ? null : Arrays.asList( columnNames ) ) + \", columnDefs=\" + ( columnDefs == null ? null : Arrays.asList( columnDefs ) ) + \", primaryKeys=\" + ( primaryKeys == null ? null : Arrays.asList( primaryKeys ) ) + '}'; } @Override public boolean equals( Object object ) { if( this == object ) return true; if( !( object instanceof TableDesc ) ) return false; TableDesc tableDesc = (TableDesc) object; if( !Arrays.equals( columnDefs, tableDesc.columnDefs ) ) return false; if( !Arrays.equals( columnNames, tableDesc.columnNames ) ) return false; if( !Arrays.equals( primaryKeys, tableDesc.primaryKeys ) ) return false; if( tableName != null ? !tableName.equals( tableDesc.tableName ) : tableDesc.tableName != null ) return false; return true; } @Override public int hashCode() { int result = tableName != null ? tableName.hashCode() : 0; result = 31 * result + ( columnNames != null ? Arrays.hashCode( columnNames ) : 0 ); result = 31 * result + ( columnDefs != null ? Arrays.hashCode( columnDefs ) : 0 ); result = 31 * result + ( primaryKeys != null ? Arrays.hashCode( primaryKeys ) : 0 ); return result; } }"}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import cascading.jdbc.db.DBWritable; import cascading.tuple.Tuple;  public class TupleRecord implements DBWritable { private Tuple tuple; public TupleRecord() { } public TupleRecord( Tuple tuple ) { this.tuple = tuple; } public void setTuple( Tuple tuple ) { this.tuple = tuple; } public Tuple getTuple() { return tuple; } public void write( PreparedStatement statement ) throws SQLException { for( int i = 0; i < tuple.size(); i++ ) statement.setObject( i + 1, tuple.get( i ) ); } public void readFields( ResultSet resultSet ) throws SQLException { tuple = new Tuple(); for( int i = 0; i < resultSet.getMetaData().getColumnCount(); i++ ) tuple.add( (Comparable) resultSet.getObject( i + 1 ) ); } }"}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc.asterdata;  public class ADDimensionTableDesc extends AsterDataTableDesc { public ADDimensionTableDesc( String tableName, String[] columnNames, String[] columnDefs, String[] primaryKeys, String partitionKey ) { super( tableName, columnNames, columnDefs, primaryKeys, partitionKey ); } @Override protected String getCreateTableFormat() { return \"CREATE DIMENSION TABLE %s ( %s )\"; } @Override protected String getDropTableFormat() { return \"DROP TABLE %s CASCADE\"; } }"}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc.asterdata;  public class ADFactTableDesc extends AsterDataTableDesc { public ADFactTableDesc( String tableName, String[] columnNames, String[] columnDefs, String[] primaryKeys, String partitionKey ) { super( tableName, columnNames, columnDefs, primaryKeys, partitionKey ); } @Override protected String getCreateTableFormat() { return \"CREATE FACT TABLE %s ( %s )\"; } @Override protected String getDropTableFormat() { return \"DROP TABLE %s CASCADE\"; } }"}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc.asterdata; import java.sql.Connection; import cascading.jdbc.db.DBInputFormat;  public class ADInputFormat extends DBInputFormat { public ADInputFormat() { } @Override protected void setTransactionIsolationLevel( Connection connection ) { "}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc.asterdata; import cascading.jdbc.JDBCScheme; import cascading.tuple.Fields; import cascading.tuple.Tuple;  public class AsterDataScheme extends JDBCScheme { public AsterDataScheme( String[] columns, String[] orderBy, String conditions, String[] updateBy ) { super( ADInputFormat.class, null, columns, orderBy, conditions, updateBy ); } public AsterDataScheme( Fields columnFields, String[] columns, String[] orderBy, String conditions, Fields updateByFields, String[] updateBy ) { super( ADInputFormat.class, null, columnFields, columns, orderBy, conditions, updateByFields, updateBy ); } public AsterDataScheme( String[] columns, String[] orderBy, String conditions, long limit ) { super( ADInputFormat.class, null, columns, orderBy, conditions, limit, null ); } public AsterDataScheme( Fields columnFields, String[] columns, String[] orderBy, String conditions, long limit ) { super( ADInputFormat.class, null, columnFields, columns, orderBy, conditions, limit, null, null ); } public AsterDataScheme( String[] columns, String[] orderBy, String conditions ) { super( ADInputFormat.class, null, columns, orderBy, conditions, null ); } public AsterDataScheme( Fields columnFields, String[] columns, String[] orderBy, String conditions ) { super( ADInputFormat.class, null, columnFields, columns, orderBy, conditions, null, null ); } public AsterDataScheme( String[] columns, String[] orderBy, String[] updateBy ) { super( ADInputFormat.class, null, columns, orderBy, updateBy ); } public AsterDataScheme( Fields columnFields, String[] columns, String[] orderBy, Fields updateByFields, String[] updateBy ) { super( ADInputFormat.class, null, columnFields, columns, orderBy, updateByFields, updateBy ); } public AsterDataScheme( String[] columns, String[] orderBy ) { this( columns, orderBy, null, null ); } public AsterDataScheme( Fields columnFields, String[] columns, String[] orderBy ) { this( columnFields, columns, orderBy, null, null ); } public AsterDataScheme( String[] columns, long limit ) { this( columns, (String[]) null, null, limit ); } public AsterDataScheme( Fields columnFields, String[] columns, long limit ) { this( columnFields, columns, (String[]) null, null, limit ); } public AsterDataScheme( String[] columns ) { this( columns, null, null, null ); } public AsterDataScheme( Fields columnFields, String[] columns ) { this( columnFields, columns, null, null, null ); } public AsterDataScheme( String[] columns, String selectQuery, String countQuery ) { super( ADInputFormat.class, columns, selectQuery, countQuery, -1 ); } public AsterDataScheme( Fields columnFields, String[] columns, String selectQuery, String countQuery ) { super( ADInputFormat.class, columnFields, columns, selectQuery, countQuery, -1 ); } public AsterDataScheme( String[] columns, String selectQuery, String countQuery, long limit ) { super( ADInputFormat.class, columns, selectQuery, countQuery, limit ); } public AsterDataScheme( Fields columnFields, String[] columns, String selectQuery, String countQuery, long limit ) { super( ADInputFormat.class, columnFields, columns, selectQuery, countQuery, limit ); } @Override protected Tuple cleanTuple( Tuple result ) { for( int i = 0; i < result.size(); i++ ) { Comparable value = result.get( i ); if( value instanceof String ) { value = ( (String) value ).replaceAll( \"'\", \"''\" ); value = ( (String) value ).replaceAll( \"\\t\", \"\\\\t\" ); value = ( (String) value ).replaceAll( \"\\n\", \"\\\\n\" ); result.set( i, value ); } } return result; } }"}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc.asterdata; import java.util.List; import cascading.jdbc.TableDesc;  public class AsterDataTableDesc extends TableDesc {  protected String partitionKey; public AsterDataTableDesc( String tableName ) { super( tableName ); } public AsterDataTableDesc( String tableName, String[] columnNames, String[] columnDefs, String[] primaryKeys ) { super( tableName, columnNames, columnDefs, primaryKeys ); } public AsterDataTableDesc( String tableName, String[] columnNames, String[] columnDefs, String[] primaryKeys, String partitionKey ) { super( tableName, columnNames, columnDefs, primaryKeys ); this.partitionKey = partitionKey; } @Override protected List<String> addCreateTableBodyTo( List<String> createTableStatement ) { createTableStatement = super.addCreateTableBodyTo( createTableStatement ); if( hasPartitionKey() ) createTableStatement.add( String.format( \"PARTITION KEY( %s )\", partitionKey ) ); return createTableStatement; } private boolean hasPartitionKey() { return partitionKey != null && partitionKey.length() != 0; } }"}
{"name": "cwensel/cascading.jdbc", "content": " /** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http:"}
{"name": "cwensel/cascading.jdbc", "content": " /** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http:"}
{"name": "cwensel/cascading.jdbc", "content": " /** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http:"}
{"name": "cwensel/cascading.jdbc", "content": " package cascading.jdbc.db; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import org.apache.hadoop.io.Writable; /** * Objects that are read from/written to a database should implement * <code>DBWritable</code>. DBWritable, is similar to {@link Writable} * except that the {@link #write(PreparedStatement)} method takes a * {@link PreparedStatement}, and {@link #readFields(ResultSet)} * takes a {@link ResultSet}. * <p> * Implementations are responsible for writing the fields of the object * to PreparedStatement, and reading the fields of the object from the * ResultSet. * <p/> * <p>Example:</p> * If we have the following table in the database : * <pre> * CREATE TABLE MyTable ( * counter INTEGER NOT NULL, * timestamp BIGINT NOT NULL, * ); * </pre> * then we can read/write the tuples from/to the table with : * <p><pre> * public class MyWritable implements Writable, DBWritable { * "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; class Attribute implements Comparable<Attribute> { private final String name; private final CharSequence value; Attribute(String name) { this.name = name; this.value = \"\"; } Attribute(String name, CharSequence value) { this.name = name; this.value = value; } Attribute(String name, CharSequence[] values) { this.name = name; StringBuilder sb = new StringBuilder(); String separator = \"\"; for (CharSequence value : values) { sb.append(separator); sb.append(value); separator = \" \"; } this.value = sb; } String getName() { return name; } CharSequence getValue() { return value; } @Override public String toString() { return name + \"=\\\"\" + value + \"\\\"\"; } @Override public int compareTo(Attribute o) { return name.compareTo(o.name); } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Attribute other = (Attribute) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXParseException; public class DebugErrorHandler implements ErrorHandler { private static final Logger log = LoggerFactory.getLogger(DebugErrorHandler.class); @Override public void warning(SAXParseException exception) { log.warn(exception.getLineNumber() + \":\" + exception.getColumnNumber() + \" \" + exception.getMessage()); } @Override public void fatalError(SAXParseException exception) { log.warn(exception.getLineNumber() + \":\" + exception.getColumnNumber() + \" \" + exception.getMessage()); } @Override public void error(SAXParseException exception) { log.warn(exception.getLineNumber() + \":\" + exception.getColumnNumber() + \" \" + exception.getMessage()); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import java.io.IOException; import javax.xml.parsers.ParserConfigurationException; import javax.xml.parsers.SAXParser; import javax.xml.parsers.SAXParserFactory; import nu.validator.htmlparser.common.DoctypeExpectation; import nu.validator.htmlparser.common.Heuristics; import nu.validator.htmlparser.common.XmlViolationPolicy; import nu.validator.htmlparser.sax.HtmlParser; import org.wicketstuff.htmlvalidator.xml.dataattributes.DataAttributeDroppingSchemaWrapper; import org.wicketstuff.htmlvalidator.xml.langattributes.XmlLangAttributeDroppingSchemaWrapper; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.CombineSchema; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.auto.AutoSchemaReader; import com.thaiopensource.validate.rng.CompactSchemaReader; public enum DocType { HTML5(\"\") { @Override public XMLReader createParser() { return createHtmlParser(DoctypeExpectation.HTML); } @Override public Schema createSchema() throws IOException, SAXException, IncorrectSchemaException { InputSource html5In = new InputSource(HtmlValidationResponseFilter.class .getResourceAsStream(\"/relaxng/html5.rnc\")); InputSource assertionsIn = new InputSource(HtmlValidationResponseFilter.class .getResourceAsStream(\"/relaxng/assertions.sch\")); PropertyMapBuilder properties = new PropertyMapBuilder(); properties.put(ValidateProperty.ENTITY_RESOLVER, new Html5EntityResolver()); properties.put(ValidateProperty.ERROR_HANDLER, new DebugErrorHandler()); Schema base = CompactSchemaReader.getInstance().createSchema(html5In, properties.toPropertyMap()); Schema assertions = new AutoSchemaReader().createSchema(assertionsIn, properties.toPropertyMap()); return new XmlLangAttributeDroppingSchemaWrapper(new DataAttributeDroppingSchemaWrapper(new CombineSchema(base, assertions, properties.toPropertyMap()))); } }, XHTML10_STRICT(\"-"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; public class Html5EntityResolver implements EntityResolver { @Override public InputSource resolveEntity(String publicId, String systemId) { int indexOfValidator = systemId.lastIndexOf(\"htmlvalidator\"); if (indexOfValidator != -1) systemId = systemId.substring(indexOfValidator + 14); return new InputSource(HtmlValidationResponseFilter.class.getResourceAsStream(\"/relaxng/\" + systemId)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import java.util.ArrayList; import java.util.List; import java.util.regex.Pattern; import org.xml.sax.SAXParseException;  public class HtmlValidationConfiguration { private List<Pattern> ignoreErrorsForWindow = new ArrayList<Pattern>();  public HtmlValidationConfiguration dontPopupWindowFor(String regexp) { ignoreErrorsForWindow.add(Pattern.compile(regexp)); return this; }  public boolean mustShowWindowForError(SAXParseException error) { for (Pattern curIgnorePattern : ignoreErrorsForWindow) { if (curIgnorePattern.matcher(error.getMessage()).find()) return false; } return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import java.io.StringReader; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.apache.wicket.Page; import org.apache.wicket.ajax.AjaxRequestTarget; import org.apache.wicket.core.request.handler.IPageRequestHandler; import org.apache.wicket.request.IRequestHandler; import org.apache.wicket.request.component.IRequestablePage; import org.apache.wicket.request.cycle.RequestCycle; import org.apache.wicket.response.filter.IResponseFilter; import org.apache.wicket.util.string.AppendingStringBuffer; import org.apache.wicket.util.string.Strings; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.xml.sax.InputSource; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator;  public class HtmlValidationResponseFilter implements IResponseFilter { private static final Pattern DOCTYPE_PATTERN = Pattern .compile(\"<!DOCTYPE[^>]*>\"); private static final Logger log = LoggerFactory .getLogger(HtmlValidationResponseFilter.class); private final HtmlValidationConfiguration configuration;  public HtmlValidationResponseFilter() { this(new HtmlValidationConfiguration()); }  public HtmlValidationResponseFilter( HtmlValidationConfiguration configuration) { this.configuration = configuration; }  public HtmlValidationConfiguration getConfiguration() { return configuration; }  protected void onValidMarkup(AppendingStringBuffer responseBuffer, ValidationReport report) { IRequestablePage responsePage = getResponsePage(); DocType doctype = getDocType(responseBuffer); log.info(\"Markup for {} is valid {}\", responsePage != null ? responsePage.getClass().getName() : \"<unable to determine page class>\", doctype.name()); String head = report.getHeadMarkup(); String body = report.getBodyMarkup(); int indexOfHeadClose = responseBuffer.lastIndexOf(\"</head>\"); responseBuffer.insert(indexOfHeadClose, head); int indexOfBodyClose = responseBuffer.lastIndexOf(\"</body>\"); responseBuffer.insert(indexOfBodyClose, body); }  protected void onInvalidMarkup(AppendingStringBuffer responseBuffer, ValidationReport report) { String head = report.getHeadMarkup(); String body = report.getBodyMarkup(); int indexOfHeadClose = responseBuffer.lastIndexOf(\"</head>\"); responseBuffer.insert(indexOfHeadClose, head); int indexOfBodyClose = responseBuffer.lastIndexOf(\"</body>\"); responseBuffer.insert(indexOfBodyClose, body); }  protected void onUnknownDocType(AppendingStringBuffer response) { IRequestablePage responsePage = getResponsePage(); String detectionString = getFirstCharacters(response, 128); if (responsePage != null) { log.info(\"No or unknown DOCTYPE detected for page {}: {}\", responsePage.getClass().getName(), detectionString); } else { log.info(\"No or unknown DOCTYPE detected: {}\", detectionString); } } public AppendingStringBuffer filter(AppendingStringBuffer responseBuffer) { IRequestablePage responsePage = getResponsePage(); if (responsePage != null && !(responsePage instanceof Page) || RequestCycle.get().find(AjaxRequestTarget.class) != null) { return responseBuffer; } DocType docType = getDocType(responseBuffer); if (docType == null) { setMetaData(\"Unknown doctype\"); onUnknownDocType(responseBuffer); return responseBuffer; } try { ValidationReport report = validateMarkup(responseBuffer.toString(), docType); if (report.isValid()) { setMetaData(\"Markup is valid \" + docType); onValidMarkup(responseBuffer, report); } else { setMetaData(\"Markup is invalid \" + docType); onInvalidMarkup(responseBuffer, report); } } catch (Exception e) { log.error(e.toString(), e); } return responseBuffer; } private ValidationReport validateMarkup(String response, DocType docType) throws Exception { IRequestablePage responsePage = getResponsePage(); ValidationReport report = new ValidationReport(configuration, responsePage, response, docType); PropertyMapBuilder properties = new PropertyMapBuilder(); properties.put(ValidateProperty.ERROR_HANDLER, report); Schema schema = docType.createSchema(); Validator validator = schema .createValidator(properties.toPropertyMap()); XMLReader reader = docType.createParser(); reader.setContentHandler(validator.getContentHandler()); try { reader.parse(new InputSource(new StringReader(response))); } catch (SAXParseException parseError) { report.fatalError(parseError); } return report; } private IRequestablePage getResponsePage() { IRequestHandler requestHandler = RequestCycle.get() .getActiveRequestHandler(); IRequestablePage responsePage = null; if (requestHandler instanceof IPageRequestHandler) { responsePage = ((IPageRequestHandler) requestHandler).getPage(); } return responsePage; } private void setMetaData(String msg) { IRequestablePage responsePage = getResponsePage(); if (responsePage instanceof Page) { ((Page) responsePage).setMetaData(HtmlValidationResultKey.KEY, msg); } }  protected DocType getDocType(AppendingStringBuffer response) { String contentSoFar = getFirstCharacters(response, 128); Matcher matcher = DOCTYPE_PATTERN.matcher(contentSoFar); if (!matcher.find()) return null; String docTypeStr = matcher.group(); if (Strings.isEmpty(docTypeStr)) return null; DocType docType = DocType.getDocType(docTypeStr); return docType; } private String getFirstCharacters(AppendingStringBuffer response, int max) { int maxLength = Math.min(response.length(), max); String contentSoFar = response.substring(0, maxLength); return contentSoFar; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import org.apache.wicket.MetaDataKey; public final class HtmlValidationResultKey extends MetaDataKey<String> { private static final long serialVersionUID = 1L; public static final HtmlValidationResultKey KEY = new HtmlValidationResultKey(); private HtmlValidationResultKey() { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import java.util.Collection; import java.util.TreeSet; import org.apache.wicket.util.string.Strings; class Tag { private Collection<Attribute> attributes; private final String name; private CharSequence body; Tag(String name) { this.name = name; this.attributes = new TreeSet<Attribute>(); } public Tag setBody(CharSequence body) { this.body = body; return this; } @Override public String toString() { if (\"img|link\".contains(name)) return getOpenCloseTag(); if (Strings.isEmpty(body)) return getOpenTag() + getCloseTag(); return getOpenTag() + body + getCloseTag(); } public String getName() { return name; } public Tag attr(String name, CharSequence... values) { this.attributes.add(new Attribute(name, values)); return this; } public String getOpenCloseTag() { StringBuilder sb = new StringBuilder(); sb.append(\"<\"); sb.append(name); if (!attributes.isEmpty()) { for (Attribute attribute : attributes) { sb.append(\" \"); sb.append(attribute); } } sb.append(\" />\"); return sb.toString(); } public String getOpenTag() { StringBuilder sb = new StringBuilder(); sb.append(\"<\"); sb.append(name); if (!attributes.isEmpty()) { for (Attribute attribute : attributes) { sb.append(\" \"); sb.append(attribute); } } sb.append(\">\"); return sb.toString(); } public String getCloseTag() { StringBuilder sb = new StringBuilder(); sb.append(\"</\"); sb.append(name); sb.append(\">\"); return sb.toString(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import static org.wicketstuff.htmlvalidator.ValidatorUtils.cssFor; import static org.wicketstuff.htmlvalidator.ValidatorUtils.imgFor; import static org.wicketstuff.htmlvalidator.ValidatorUtils.jsFor; import java.util.ArrayList; import java.util.List; import org.apache.wicket.request.component.IRequestablePage; import org.apache.wicket.util.lang.Bytes; import org.apache.wicket.util.string.Strings; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXParseException; public class ValidationReport implements ErrorHandler { private static final Logger log = LoggerFactory .getLogger(ValidationReport.class); private List<SAXParseException> parseErrors = new ArrayList<SAXParseException>(); private final HtmlValidationConfiguration configuration; private final String doctype; private final String markup; private final String[] lines; private final String page; public ValidationReport(HtmlValidationConfiguration configuration, IRequestablePage page, String markup, DocType doctype) { this.configuration = configuration; if (page != null) this.page = page.getClass().getName(); else this.page = \"<unable to determine page>\"; this.markup = markup; this.lines = Strings.split(markup, '\\n'); this.doctype = doctype.name(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import org.apache.wicket.request.cycle.RequestCycle; import org.apache.wicket.request.resource.PackageResourceReference; class ValidatorUtils { static Tag cssFor(String filename) { Tag link = new Tag(\"link\"); link.attr(\"rel\", \"stylesheet\"); link.attr(\"type\", \"text/css\"); link.attr(\"href\", urlFor(filename)); return link; } static Tag jsFor(String filename) { Tag script = new Tag(\"script\"); script.attr(\"type\", \"text/javascript\"); script.attr(\"src\", urlFor(filename)); return script; } static Tag imgFor(String filename) { Tag img = new Tag(\"img\"); img.attr(\"src\", urlFor(filename)); return img; } private static String urlFor(String filename) { RequestCycle requestCycle = RequestCycle.get(); PackageResourceReference reference = new PackageResourceReference( ValidationReport.class, filename); CharSequence url = requestCycle.urlFor(reference, null); return url.toString(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.wicketstuff.htmlvalidator; import java.io.File; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; public class XHtmlEntityResolver implements EntityResolver { @Override public InputSource resolveEntity(String publicId, String systemId) { String path = \"file:\" + new File(\"\").getAbsolutePath() + \"/\"; if (systemId.startsWith(path)) { systemId = systemId.substring(path.length()); } int indexOfValidator = systemId.lastIndexOf(\"htmlvalidator\"); if (indexOfValidator != -1) systemId = systemId.substring(indexOfValidator + 14); return new InputSource(HtmlValidationResponseFilter.class .getResourceAsStream(\"/schemas/xhtml10/\" + systemId)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.wicketstuff.htmlvalidator.xml.dataattributes; import nu.validator.htmlparser.impl.NCName; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.AttributesImpl;  public class DataAttributeDroppingContentHandlerWrapper implements ContentHandler { private final ContentHandler delegate; private final ErrorHandler errorHandler; private Locator locator = null;  public DataAttributeDroppingContentHandlerWrapper(ContentHandler delegate, ErrorHandler errorHandler) { this.delegate = delegate; this.errorHandler = errorHandler; }  public void characters(char[] arg0, int arg1, int arg2) throws SAXException { delegate.characters(arg0, arg1, arg2); }  public void endDocument() throws SAXException { delegate.endDocument(); }  public void endElement(String arg0, String arg1, String arg2) throws SAXException { delegate.endElement(arg0, arg1, arg2); }  public void endPrefixMapping(String arg0) throws SAXException { delegate.endPrefixMapping(arg0); }  public void ignorableWhitespace(char[] arg0, int arg1, int arg2) throws SAXException { delegate.ignorableWhitespace(arg0, arg1, arg2); }  public void processingInstruction(String arg0, String arg1) throws SAXException { delegate.processingInstruction(arg0, arg1); }  public void setDocumentLocator(Locator arg0) { locator = arg0; delegate.setDocumentLocator(arg0); }  public void skippedEntity(String arg0) throws SAXException { delegate.skippedEntity(arg0); }  public void startDocument() throws SAXException { delegate.startDocument(); }  public void startElement(String ns, String arg1, String arg2, Attributes attributes) throws SAXException { if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.wicketstuff.htmlvalidator.xml.dataattributes; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.Validator; public class DataAttributeDroppingSchemaWrapper implements Schema { private final Schema delegate;  public DataAttributeDroppingSchemaWrapper(Schema delegate) { this.delegate = delegate; }  public Validator createValidator(PropertyMap properties) { return new DataAttributeDroppingValidatorWrapper(delegate.createValidator(properties), properties); }  public PropertyMap getProperties() { return delegate.getProperties(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.wicketstuff.htmlvalidator.xml.dataattributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; public class DataAttributeDroppingValidatorWrapper implements Validator { private final Validator delegate; private final PropertyMap properties;  public DataAttributeDroppingValidatorWrapper(Validator delegate, PropertyMap properties) { this.delegate = delegate; this.properties = properties; }  public ContentHandler getContentHandler() { return new DataAttributeDroppingContentHandlerWrapper(delegate.getContentHandler(), (ErrorHandler) properties.get(ValidateProperty.ERROR_HANDLER)); }  public DTDHandler getDTDHandler() { return delegate.getDTDHandler(); }  public void reset() { delegate.reset(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.wicketstuff.htmlvalidator.xml.langattributes; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.AttributesImpl; public class XmlLangAttributeDroppingContentHandlerWrapper implements ContentHandler { private final ContentHandler delegate; private final ErrorHandler errorHandler; private Locator locator = null;  public XmlLangAttributeDroppingContentHandlerWrapper(ContentHandler delegate, ErrorHandler errorHandler) { this.delegate = delegate; this.errorHandler = errorHandler; }  public void characters(char[] arg0, int arg1, int arg2) throws SAXException { delegate.characters(arg0, arg1, arg2); }  public void endDocument() throws SAXException { delegate.endDocument(); }  public void endElement(String arg0, String arg1, String arg2) throws SAXException { delegate.endElement(arg0, arg1, arg2); }  public void endPrefixMapping(String arg0) throws SAXException { delegate.endPrefixMapping(arg0); }  public void ignorableWhitespace(char[] arg0, int arg1, int arg2) throws SAXException { delegate.ignorableWhitespace(arg0, arg1, arg2); }  public void processingInstruction(String arg0, String arg1) throws SAXException { delegate.processingInstruction(arg0, arg1); }  public void setDocumentLocator(Locator arg0) { locator = arg0; delegate.setDocumentLocator(arg0); }  public void skippedEntity(String arg0) throws SAXException { delegate.skippedEntity(arg0); }  public void startDocument() throws SAXException { delegate.startDocument(); }  public void startElement(String ns, String arg1, String arg2, Attributes attributes) throws SAXException { if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.wicketstuff.htmlvalidator.xml.langattributes; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.Validator; public class XmlLangAttributeDroppingSchemaWrapper implements Schema { private final Schema delegate;  public XmlLangAttributeDroppingSchemaWrapper(Schema delegate) { this.delegate = delegate; }  public Validator createValidator(PropertyMap properties) { return new XmlLangAttributeDroppingValidatorWrapper(delegate.createValidator(properties), properties); }  public PropertyMap getProperties() { return delegate.getProperties(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.wicketstuff.htmlvalidator.xml.langattributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; public class XmlLangAttributeDroppingValidatorWrapper implements Validator { private final Validator delegate; private final PropertyMap properties;  public XmlLangAttributeDroppingValidatorWrapper(Validator delegate, PropertyMap properties) { this.delegate = delegate; this.properties = properties; }  public ContentHandler getContentHandler() { return new XmlLangAttributeDroppingContentHandlerWrapper(delegate.getContentHandler(), (ErrorHandler) properties.get(ValidateProperty.ERROR_HANDLER)); }  public DTDHandler getDTDHandler() { return delegate.getDTDHandler(); }  public void reset() { delegate.reset(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.dom; import java.io.PrintStream; import java.io.PrintWriter;  public class DOMVisitorException extends RuntimeException { private Exception cause_ = null; public DOMVisitorException(String message) { super(message); } public DOMVisitorException(Exception e) { super(e.getMessage()); cause_ = e; } public DOMVisitorException(String message, Exception e) { super(message); cause_ = e; } public Exception getException() { if (cause_ != null) { return (cause_); } else { return (this); } } public Exception getCauseException() { return (cause_); } public void printStackTrace() { printStackTrace(new PrintWriter(System.err, true)); } public void printStackTrace(PrintStream out) { printStackTrace(new PrintWriter(out)); } public void printStackTrace(PrintWriter writer) { if (writer == null) { writer = new PrintWriter(System.err, true); } super.printStackTrace(writer); if (cause_ != null) { writer.println(); writer.println(\"StackTrace of Original Exception:\"); cause_.printStackTrace(writer); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.dom; import org.w3c.dom.Attr; import org.w3c.dom.CDATASection; import org.w3c.dom.Comment; import org.w3c.dom.Document; import org.w3c.dom.DocumentFragment; import org.w3c.dom.DocumentType; import org.w3c.dom.Element; import org.w3c.dom.Entity; import org.w3c.dom.EntityReference; import org.w3c.dom.Node; import org.w3c.dom.Notation; import org.w3c.dom.ProcessingInstruction; import org.w3c.dom.Text;  public interface IDOMVisitor { boolean enter(Element element) throws DOMVisitorException; boolean enter(Attr attr) throws DOMVisitorException; boolean enter(Text text) throws DOMVisitorException; boolean enter(CDATASection cdata) throws DOMVisitorException; boolean enter(EntityReference entityRef) throws DOMVisitorException; boolean enter(Entity entity) throws DOMVisitorException; boolean enter(ProcessingInstruction pi) throws DOMVisitorException; boolean enter(Comment comment) throws DOMVisitorException; boolean enter(Document doc) throws DOMVisitorException; boolean enter(DocumentType doctype) throws DOMVisitorException; boolean enter(DocumentFragment docfrag) throws DOMVisitorException; boolean enter(Notation notation) throws DOMVisitorException; boolean enter(Node node) throws DOMVisitorException; void leave(Element element) throws DOMVisitorException; void leave(Attr attr) throws DOMVisitorException; void leave(Text text) throws DOMVisitorException; void leave(CDATASection cdata) throws DOMVisitorException; void leave(EntityReference entityRef) throws DOMVisitorException; void leave(Entity entity) throws DOMVisitorException; void leave(ProcessingInstruction pi) throws DOMVisitorException; void leave(Comment comment) throws DOMVisitorException; void leave(Document doc) throws DOMVisitorException; void leave(DocumentType doctype) throws DOMVisitorException; void leave(DocumentFragment docfrag) throws DOMVisitorException; void leave(Notation notation) throws DOMVisitorException; void leave(Node node) throws DOMVisitorException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.dom; import org.w3c.dom.Document; import org.w3c.dom.Node;  public final class UDOM { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.dom; import org.w3c.dom.Attr; import org.w3c.dom.CDATASection; import org.w3c.dom.Comment; import org.w3c.dom.Document; import org.w3c.dom.DocumentFragment; import org.w3c.dom.DocumentType; import org.w3c.dom.Element; import org.w3c.dom.Entity; import org.w3c.dom.EntityReference; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.w3c.dom.Notation; import org.w3c.dom.ProcessingInstruction; import org.w3c.dom.Text;  public final class UDOMVisitor { public static void traverse( Node node, IDOMVisitor visitor ) throws DOMVisitorException { boolean doContinue; switch (node.getNodeType()) { case Node.ELEMENT_NODE: doContinue = visitor.enter((Element)node); break; case Node.ATTRIBUTE_NODE: doContinue = visitor.enter((Attr)node); break; case Node.TEXT_NODE: doContinue = visitor.enter((Text)node); break; case Node.CDATA_SECTION_NODE: doContinue = visitor.enter((CDATASection)node); break; case Node.ENTITY_REFERENCE_NODE: doContinue = visitor.enter((EntityReference)node); break; case Node.ENTITY_NODE: doContinue = visitor.enter((Entity)node); break; case Node.PROCESSING_INSTRUCTION_NODE: doContinue = visitor.enter((ProcessingInstruction)node); break; case Node.COMMENT_NODE: doContinue = visitor.enter((Comment)node); break; case Node.DOCUMENT_NODE: doContinue = visitor.enter((Document)node); break; case Node.DOCUMENT_TYPE_NODE: doContinue = visitor.enter((DocumentType)node); break; case Node.DOCUMENT_FRAGMENT_NODE: doContinue = visitor.enter((DocumentFragment)node); break; case Node.NOTATION_NODE: doContinue = visitor.enter((Notation)node); break; default: doContinue = visitor.enter(node); break; } if (doContinue) { traverseChildren(node, visitor); switch (node.getNodeType()) { case Node.ELEMENT_NODE: visitor.leave((Element)node); break; case Node.ATTRIBUTE_NODE: visitor.leave((Attr)node); break; case Node.TEXT_NODE: visitor.leave((Text)node); break; case Node.CDATA_SECTION_NODE: visitor.leave((CDATASection)node); break; case Node.ENTITY_REFERENCE_NODE: visitor.leave((EntityReference)node); break; case Node.ENTITY_NODE: visitor.leave((Entity)node); break; case Node.PROCESSING_INSTRUCTION_NODE: visitor.leave((ProcessingInstruction)node); break; case Node.COMMENT_NODE: visitor.leave((Comment)node); break; case Node.DOCUMENT_NODE: visitor.leave((Document)node); break; case Node.DOCUMENT_TYPE_NODE: visitor.leave((DocumentType)node); break; case Node.DOCUMENT_FRAGMENT_NODE: visitor.leave((DocumentFragment)node); break; case Node.NOTATION_NODE: visitor.leave((Notation)node); break; default: visitor.leave(node); break; } } } public static void traverseChildren(Node node, IDOMVisitor visitor) { NodeList children = node.getChildNodes(); int size = children.getLength(); for (int i = 0;i < size;i++) { traverse(children.item(i), visitor); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.dom; import jp.gr.xml.relax.xml.UXML; import org.w3c.dom.Attr; import org.w3c.dom.CDATASection; import org.w3c.dom.Comment; import org.w3c.dom.Document; import org.w3c.dom.DocumentFragment; import org.w3c.dom.DocumentType; import org.w3c.dom.Element; import org.w3c.dom.Entity; import org.w3c.dom.EntityReference; import org.w3c.dom.NamedNodeMap; import org.w3c.dom.Node; import org.w3c.dom.Notation; import org.w3c.dom.ProcessingInstruction; import org.w3c.dom.Text;  public class XMLMaker implements IDOMVisitor { protected StringBuffer buffer_; protected String encoding_ = \"UTF-8\"; protected boolean dom2_ = false; protected boolean expandEntityReference_ = false; protected boolean emptyElementTag_ = false; public XMLMaker() { buffer_ = new StringBuffer(); } public void setEncoding(String encoding) { encoding_ = encoding; } public void setDOM2(boolean dom2) { dom2_ = dom2; } public void setExpandEntityReference(boolean expand) { expandEntityReference_ = expand; } public void setEmptyElementTag(boolean empty) { emptyElementTag_ = empty; } public String getText() { return (new String(buffer_)); } public boolean enter(Element element) { String tag = element.getTagName(); buffer_.append(\"<\"); buffer_.append(tag); NamedNodeMap attrs = element.getAttributes(); int nAttrs = attrs.getLength(); for (int i = 0;i < nAttrs;i++) { Attr attr = (Attr)attrs.item(i); if (attr.getSpecified()) { buffer_.append(' '); enter(attr); leave(attr); } } buffer_.append(\">\"); return (true); } public void leave(Element element) { String tag = element.getTagName(); buffer_.append(\"</\" + tag + \">\"); } public boolean enter(Attr attr) { buffer_.append(attr.getName()); buffer_.append(\"=\\\"\"); buffer_.append(UXML.escapeAttrQuot(attr.getValue())); buffer_.append('\\\"'); return (true); } public void leave(Attr attr) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.sax; import jp.gr.xml.relax.dom.DOMVisitorException; import jp.gr.xml.relax.dom.UDOMVisitor; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.ext.DeclHandler; import org.xml.sax.ext.LexicalHandler;  public class DOMSAXProducer { private boolean needDocumentEmulation_ = true; private Node root_; private String systemID_; private String publicID_; private DTDHandler dtd_; private ContentHandler content_; private DeclHandler decl_; private LexicalHandler lexical_; private ErrorHandler error_; public DOMSAXProducer(Node node) { root_ = node; } public void setDocumentEmulation(boolean emulate) { needDocumentEmulation_ = emulate; } public void setDTDHandler(DTDHandler dtd) { dtd_ = dtd; } public void setContentHandler(ContentHandler content) { content_ = content; } public void setLexicalHandler(LexicalHandler lexical) { lexical_ = lexical; } public void setDeclHandler(DeclHandler decl) { decl_ = decl; } public void setErrorHandler(ErrorHandler error) { error_ = error; } public void makeEvent() throws SAXException { try { DOMSAXProducerVisitor visitor = new DOMSAXProducerVisitor(); visitor.setSystemID(systemID_); visitor.setPublicID(publicID_); visitor.setDTDHandler(dtd_); visitor.setContentHandler(content_); visitor.setLexicalHandler(lexical_); visitor.setDeclHandler(decl_); visitor.setErrorHandler(error_); if (!(root_ instanceof Document) && needDocumentEmulation_) { visitor.emulateStartDocument(); UDOMVisitor.traverse(root_, visitor); visitor.emulateEndDocument(); } else { UDOMVisitor.traverse(root_, visitor); } } catch (DOMVisitorException e) { Exception cause = e.getCauseException(); if (cause == null) { throw (new SAXException(e.getMessage())); } else if (cause instanceof SAXException) { throw ((SAXException) cause); } else { throw (new SAXException(e.getMessage())); } } } public void makeEvent(ContentHandler handler) throws SAXException { setContentHandler(handler); makeEvent(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.sax; import jp.gr.xml.relax.dom.DOMVisitorException; import jp.gr.xml.relax.dom.IDOMVisitor; import jp.gr.xml.relax.dom.UDOM; import org.w3c.dom.Attr; import org.w3c.dom.CDATASection; import org.w3c.dom.Comment; import org.w3c.dom.Document; import org.w3c.dom.DocumentFragment; import org.w3c.dom.DocumentType; import org.w3c.dom.Element; import org.w3c.dom.Entity; import org.w3c.dom.EntityReference; import org.w3c.dom.NamedNodeMap; import org.w3c.dom.Node; import org.w3c.dom.Notation; import org.w3c.dom.ProcessingInstruction; import org.w3c.dom.Text; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.ext.DeclHandler; import org.xml.sax.ext.LexicalHandler; import org.xml.sax.helpers.AttributesImpl; import org.xml.sax.helpers.DefaultHandler; import org.xml.sax.helpers.LocatorImpl; import org.xml.sax.helpers.NamespaceSupport;  public class DOMSAXProducerVisitor implements IDOMVisitor { private String systemID_; private String publicID_; private DTDHandler dtd_; private ContentHandler content_; private DeclHandler decl_; private LexicalHandler lexical_; private ErrorHandler error_; private NamespaceSupport namespace_; private boolean throwException_; public DOMSAXProducerVisitor() { DefaultHandler handler = new DefaultHandler(); dtd_ = handler; content_ = handler; error_ = handler; lexical_ = new LexicalHandlerBase(); decl_ = new DeclHandlerBase(); namespace_ = new NamespaceSupport(); throwException_ = false; } public void setSystemID(String id) { systemID_ = id; } public void setPublicID(String id) { publicID_ = id; } public void setDTDHandler(DTDHandler dtd) { dtd_ = dtd; } public void setContentHandler(ContentHandler content) { content_ = content; } public void setLexicalHandler(LexicalHandler lexical) { lexical_ = lexical; } public void setDeclHandler(DeclHandler decl) { decl_ = decl; } public void setErrorHandler(ErrorHandler error) { error_ = error; } public void emulateStartDocument() { try { _handleLocator(); content_.startDocument(); } catch (SAXException e) { _errorReport(e); } } public void emulateEndDocument() { try { content_.endDocument(); } catch (SAXException e) { _errorReport(e); } } public void throwException(boolean useException) { throwException_ = useException; } public boolean enter(Element element) { try { namespace_.pushContext(); String namespaceURI = element.getNamespaceURI(); if (namespaceURI == null) { namespaceURI = \"\"; } String localName = element.getLocalName(); String qName = element.getTagName(); NamedNodeMap attrMap = element.getAttributes(); AttributesImpl attrs = new AttributesImpl(); int size = attrMap.getLength(); for (int i = 0; i < size; i++) { Attr attr = (Attr) attrMap.item(i); String attrNamespaceURI = attr.getNamespaceURI(); if (attrNamespaceURI == null) { attrNamespaceURI = \"\"; } String attrLocalName = attr.getLocalName(); String attrQName = attr.getName(); String attrValue = attr.getValue(); if (attrQName.startsWith(\"xmlns\")) { String prefix; int index = attrQName.indexOf(':'); if (index == -1) { prefix = \"\"; } else { prefix = attrQName.substring(index + 1); } if (!namespace_.declarePrefix(prefix, attrValue)) { _errorReport(\"bad prefix = \" + prefix); } else { content_.startPrefixMapping(prefix, attrValue); } } else { attrs.addAttribute( attrNamespaceURI, attrLocalName, attrQName, \"CDATA\", attrValue); } } content_.startElement(namespaceURI, localName, qName, attrs); } catch (SAXException e) { _errorReport(e); } return (true); } public boolean enter(Attr attr) { return (false); } public boolean enter(Text text) { try { String data = text.getData(); content_.characters(data.toCharArray(), 0, data.length()); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(CDATASection cdata) { try { lexical_.startCDATA(); String data = cdata.getData(); content_.characters(data.toCharArray(), 0, data.length()); lexical_.endCDATA(); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(EntityReference entityRef) { try { lexical_.startEntity(entityRef.getNodeName()); } catch (SAXException e) { _errorReport(e); } return (true); } public boolean enter(Entity entity) { return (false); } public boolean enter(ProcessingInstruction pi) { try { content_.processingInstruction(pi.getTarget(), pi.getData()); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(Comment comment) { try { String data = comment.getData(); lexical_.comment(data.toCharArray(), 0, data.length()); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(Document doc) { try { _handleLocator(); content_.startDocument(); _handleDoctype(doc.getDoctype()); } catch (SAXException e) { _errorReport(e); } return (true); } private void _handleLocator() { if (systemID_ == null && publicID_ == null) { return; } _locatorEvent(systemID_, publicID_); } private void _locatorEvent(String systemID, String publicID) { LocatorImpl locator = new LocatorImpl(); locator.setSystemId(systemID_); locator.setPublicId(publicID_); locator.setLineNumber(-1); locator.setColumnNumber(-1); content_.setDocumentLocator(locator); } private void _handleDoctype(DocumentType doctype) { try { if (doctype == null) { return; } String systemID = doctype.getSystemId(); String publicID = doctype.getPublicId(); String internalSubset = doctype.getInternalSubset(); if (systemID != null) { lexical_.startDTD(doctype.getName(), publicID, systemID); if (internalSubset == null) { lexical_.endDTD(); _handleEntities(doctype); } else { _handleEntities(doctype); lexical_.endDTD(); } } else { _handleEntities(doctype); } } catch (SAXException e) { _errorReport(e); } } private void _handleEntities(DocumentType doctype) { try { NamedNodeMap entities = doctype.getEntities(); int nEntities = entities.getLength(); for (int i = 0; i < nEntities; i++) { Entity entity = (Entity) entities.item(i); String publicID = entity.getPublicId(); String systemID = entity.getSystemId(); String notationName = entity.getNotationName(); if (publicID != null || systemID != null) { _handleExternalEntity( entity.getNodeName(), publicID, systemID, notationName); } else { _handleInternalEntity(entity); } } NamedNodeMap notations = doctype.getNotations(); int nNotations = notations.getLength(); for (int i = 0; i < nNotations; i++) { Notation notation = (Notation) notations.item(i); String publicID = notation.getPublicId(); String systemID = notation.getSystemId(); dtd_.notationDecl(notation.getNodeName(), publicID, systemID); } } catch (SAXException e) { _errorReport(e); } } private void _handleExternalEntity( String name, String publicID, String systemID, String notationName) { try { if (notationName == null) { decl_.externalEntityDecl(name, publicID, systemID); } else { dtd_.unparsedEntityDecl(name, publicID, systemID, notationName); } } catch (SAXException e) { _errorReport(e); } } private void _handleInternalEntity(Entity entity) { try { decl_.internalEntityDecl( entity.getNodeName(), UDOM.getXMLText(entity)); } catch (SAXException e) { _errorReport(e); } } public boolean enter(DocumentType doctype) { return (false); } public boolean enter(DocumentFragment docfrag) { return (true); } public boolean enter(Notation notation) { return (false); } public boolean enter(Node node) { return (false); } public void leave(Element element) { try { String namespaceURI = element.getNamespaceURI(); if (namespaceURI == null) { namespaceURI = \"\"; } String localName = element.getLocalName(); String qName = element.getTagName(); content_.endElement(namespaceURI, localName, qName); namespace_.popContext(); } catch (SAXException e) { _errorReport(e); } } public void leave(Attr attr) { } public void leave(Text text) { } public void leave(CDATASection cdata) { } public void leave(EntityReference entityRef) { try { lexical_.endEntity(entityRef.getNodeName()); } catch (SAXException e) { _errorReport(e); } } public void leave(Entity entity) { } public void leave(ProcessingInstruction pi) { } public void leave(Comment comment) { } public void leave(Document doc) { try { content_.endDocument(); } catch (SAXException e) { _errorReport(e); } } public void leave(DocumentType doctype) { } public void leave(DocumentFragment docfrag) { } public void leave(Notation notation) { } public void leave(Node node) { } private void _errorReport(String message) throws DOMVisitorException { _errorReport( new SAXParseException(message, publicID_, systemID_, -1, -1)); } private void _errorReport(SAXException e) throws DOMVisitorException { try { SAXParseException parseException; if (e instanceof SAXParseException) { parseException = (SAXParseException) e; } else { parseException = new SAXParseException( e.getMessage(), publicID_, systemID_, -1, -1, e); } error_.fatalError(parseException); if (throwException_) { throw (new DOMVisitorException(e)); } } catch (SAXException ee) { } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.sax; import java.io.StringReader; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource;  public class DTDSkipper implements EntityResolver { public InputSource resolveEntity(String publicId, String systemId) { if (!systemId.endsWith(\".dtd\")) { return (null); } StringReader reader = new StringReader(\"\"); InputSource is = new InputSource(reader); return (is); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.sax; import org.xml.sax.SAXException; import org.xml.sax.ext.DeclHandler;  public class DeclHandlerBase implements DeclHandler { public void elementDecl(String name, String model) throws SAXException { } public void attributeDecl( String eName, String aName, String type, String valueDefault, String value) throws SAXException { } public void internalEntityDecl(String name, String value) throws SAXException { } public void externalEntityDecl( String name, String publicId, String systemId) throws SAXException { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.sax; import org.xml.sax.SAXException; import org.xml.sax.ext.LexicalHandler;  public class LexicalHandlerBase implements LexicalHandler { public void startDTD(String name, String publidId, String systemID) throws SAXException { } public void endDTD() throws SAXException { } public void startEntity(String name) throws SAXException { } public void endEntity(String name) throws SAXException { } public void startCDATA() throws SAXException { } public void endCDATA() throws SAXException { } public void comment(char ch[], int start, int length) { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.sax;  public class RELAXEntityResolver extends SimpleEntityResolver { public RELAXEntityResolver() { String coreUri = getClass() .getResource(\"/jp/gr/xml/relax/lib/relaxCore.dtd\") .toExternalForm(); String nsUri = getClass() .getResource(\"/jp/gr/xml/relax/lib/relaxNamespace.dtd\") .toExternalForm(); String grammarUri = getClass() .getResource(\"/jp/gr/xml/relax/lib/relax.dtd\") .toExternalForm(); addSystemId(\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.sax; import java.io.IOException; import java.io.InputStream; import java.net.URL; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource;  public class SimpleEntityResolver implements EntityResolver { private Map publicIds_ = new HashMap(); private Map systemIds_ = new HashMap(); private List relativeSystemIds_ = new ArrayList(); public SimpleEntityResolver() { } public SimpleEntityResolver(String name, String uri) { _init(new String[][] { { name, uri } }, null); } public SimpleEntityResolver(String[][] systemIds) { _init(systemIds, null); } public SimpleEntityResolver(String[][] systemIds, String[][] publicIds) { _init(systemIds, publicIds); } private void _init(String[][] systemIds, String[][] publicIds) { if (systemIds != null) { for (int i = 0; i < systemIds.length; i++) { String systemId = systemIds[i][0]; addSystemId(systemId, systemIds[i][1]); } } if (publicIds != null) { for (int i = 0; i < publicIds.length; i++) { addPublicId(publicIds[i][0], publicIds[i][1]); } } } public void addSystemId(String systemId, String uri) { systemIds_.put(systemId, uri); relativeSystemIds_.add(systemId); } public void addPublicId(String publicId, String uri) { publicIds_.put(publicId, uri); } public InputSource resolveEntity(String publicId, String systemId) { if (systemId != null) { if (_isExist(systemId)) { return (new InputSource(systemId)); } } if (publicId != null) { String uri = (String) publicIds_.get(publicId); if (uri != null) { return (new InputSource(uri)); } else { return (null); } } if (systemId != null) { String uri = _getURIBySystemId(systemId); if (uri != null) { return (new InputSource(uri)); } else { return (new InputSource(systemId)); } } else { return (null); } } private boolean _isExist(String uri) { try { URL url = new URL(uri); if (\"file\".equals(url.getProtocol())) { InputStream in = url.openStream(); in.close(); return (true); } else { return (false); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package jp.gr.xml.relax.xml;  public final class UXML { public static String escape(String string) { if (string.indexOf('<') == -1 && string.indexOf('>') == -1 && string.indexOf('&') == -1 && string.indexOf('\"') == -1 && string.indexOf('\\'') == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '<') { buffer.append(\"&lt;\"); } else if (c == '>') { buffer.append(\"&gt;\"); } else if (c == '&') { buffer.append(\"&amp;\"); } else if (c == '\"') { buffer.append(\"&quot;\"); } else if (c == '\\'') { buffer.append(\"&apos;\"); } else { buffer.append(c); } } return (new String(buffer)); } public static String escapeEntityQuot(String string) { if (string.indexOf('%') == -1 && string.indexOf('&') == -1 && string.indexOf('\"') == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '%') { buffer.append(\"&---;\"); } else if (c == '&') { buffer.append(\"&amp;\"); } else if (c == '\"') { buffer.append(\"&quot;\"); } else { buffer.append(c); } } return (new String(buffer)); } public static String escapeEntityApos(String string) { if (string.indexOf('%') == -1 && string.indexOf('&') == -1 && string.indexOf('\\'') == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '%') { buffer.append(\"&#x25;\"); } else if (c == '&') { buffer.append(\"&amp;\"); } else if (c == '\\'') { buffer.append(\"&apos;\"); } else { buffer.append(c); } } return (new String(buffer)); } public static String escapeAttrQuot(String string) { if (string.indexOf('<') == -1 && string.indexOf('&') == -1 && string.indexOf('\"') == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '<') { buffer.append(\"&lt;\"); } else if (c == '&') { buffer.append(\"&amp;\"); } else if (c == '\"') { buffer.append(\"&quot;\"); } else { buffer.append(c); } } return (new String(buffer)); } public static String escapeAttrApos(String string) { if (string.indexOf('<') == -1 && string.indexOf('&') == -1 && string.indexOf('\\'') == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '<') { buffer.append(\"&lt;\"); } else if (c == '&') { buffer.append(\"&amp;\"); } else if (c == '\\'') { buffer.append(\"&apos;\"); } else { buffer.append(c); } } return (new String(buffer)); } public static String escapeSystemQuot(String string) { if (string.indexOf('\"') == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '\"') { buffer.append(\"&quot;\"); } else { buffer.append(c); } } return (new String(buffer)); } public static String escapeSystemApos(String string) { if (string.indexOf('\\'') == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '\\'') { buffer.append(\"&apos;\"); } else { buffer.append(c); } } return (new String(buffer)); } public static String escapeCharData(String string) { if (string.indexOf('<') == -1 && string.indexOf('&') == -1 && string.indexOf(\"]]>\") == -1) { return (string); } StringBuffer buffer = new StringBuffer(); int nBrackets = 0; int size = string.length(); for (int i = 0;i < size;i++) { char c = string.charAt(i); if (c == '<') { buffer.append(\"&lt;\"); } else if (c == '&') { buffer.append(\"&amp;\"); } else if (c == '>' && nBrackets >= 2) { buffer.append(\"&gt;\"); } else { buffer.append(c); } if (c == ']') { nBrackets++; } else { nBrackets = 0; } } return (new String(buffer)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.ant; import java.io.PrintWriter; import java.io.StringWriter; import org.apache.tools.ant.Project; import org.apache.tools.ant.Task; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException;  public class ErrorHandlerImpl implements ErrorHandler { private final Task task; boolean hadError = false; public ErrorHandlerImpl( Task t ) { this.task = t; } public void warning(SAXParseException e) throws SAXException { print( e, Project.MSG_WARN ); } public void error(SAXParseException e) throws SAXException { print( e, Project.MSG_ERR ); hadError = true; } public void fatalError(SAXParseException e) throws SAXException { print( e, Project.MSG_ERR ); hadError = true; } private void print( SAXParseException e, int msgLevel ) { task.log( e.getMessage(), msgLevel ); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); pw.close(); task.log( sw.toString(), Project.MSG_VERBOSE ); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.ant; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; import org.apache.tools.ant.BuildException; import org.apache.tools.ant.DirectoryScanner; import org.apache.tools.ant.Project; import org.apache.tools.ant.Task; import org.apache.tools.ant.types.FileSet; import org.iso_relax.verifier.Verifier; import org.iso_relax.verifier.VerifierConfigurationException; import org.iso_relax.verifier.VerifierFactory; import org.xml.sax.SAXException;  public class JARVTask extends Task {  private File schemaFile;  private String schemaLanguage;  private File xmlFile;  private List xmlFiles = new ArrayList();  public void setSchema(String schemaFilename) { schemaFile = project.resolveFile(schemaFilename); }  public void setSchemaLanguage(String schemaLanguage) { this.schemaLanguage = schemaLanguage; }  public void setFile(File file) { this.xmlFile = file; }  public void addFileset( FileSet fs ) { xmlFiles.add(fs); } public void execute() throws BuildException { try { if( schemaLanguage==null ) throw new BuildException( \"schema language needs to be specified through the schemaLanguage attribute\", location ); if( schemaFile==null ) throw new BuildException( \"schema file needs to be specified through the schema attribute\", location ); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.catalog; import java.io.IOException; import java.util.HashMap; import java.util.Map; import javax.xml.parsers.ParserConfigurationException; import javax.xml.parsers.SAXParser; import javax.xml.parsers.SAXParserFactory; import org.xml.sax.Attributes; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.helpers.DefaultHandler;  public class RELAXCatalog { private Map grammars_ = new HashMap(); public RELAXCatalog() throws ParserConfigurationException, SAXException, IOException { this (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException;  public interface AttributesDecl {  String getName();  boolean getFeature( String featureName ) throws SAXNotRecognizedException,SAXNotSupportedException;  Object getProperty( String propertyName ) throws SAXNotRecognizedException,SAXNotSupportedException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.dispatcher; public interface AttributesVerifier { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.XMLReader;  public interface Dispatcher {  void attachXMLReader( XMLReader reader );  void switchVerifier( IslandVerifier newVerifier ) throws SAXException;  void setErrorHandler( ErrorHandler handler );  ErrorHandler getErrorHandler();  SchemaProvider getSchemaProvider(); public static class NotationDecl { public final String name; public final String publicId; public final String systemId; public NotationDecl( String name, String publicId, String systemId ) { this.name=name; this.publicId=publicId; this.systemId=systemId; } }  int countNotationDecls();  NotationDecl getNotationDecl( int index ); public static class UnparsedEntityDecl { public final String name; public final String publicId; public final String systemId; public final String notation; public UnparsedEntityDecl( String name, String publicId, String systemId, String notation ) { this.name=name; this.publicId=publicId; this.systemId=systemId; this.notation=notation; } }  int countUnparsedEntityDecls();  UnparsedEntityDecl getUnparsedEntityDecl( int index ); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException;  public interface ElementDecl {  String getName();  boolean getFeature( String featureName ) throws SAXNotRecognizedException,SAXNotSupportedException;  Object getProperty( String propertyName ) throws SAXNotRecognizedException,SAXNotSupportedException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher; import java.util.Iterator; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException;  public interface IslandSchema {  IslandVerifier createNewVerifier( String namespaceURI, ElementDecl[] elementDecls );  ElementDecl getElementDeclByName( String name );  Iterator iterateElementDecls();  ElementDecl[] getElementDecls();  AttributesDecl getAttributesDeclByName( String name );  Iterator iterateAttributesDecls();  AttributesDecl[] getAttributesDecls();  AttributesVerifier createNewAttributesVerifier( String namespaceURI, AttributesDecl[] decls );  void bind( SchemaProvider provider, ErrorHandler errorHandler ) throws SAXException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher;  public interface IslandSchemaReader extends org.xml.sax.ContentHandler {  IslandSchema getSchema(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher; import org.xml.sax.ContentHandler; import org.xml.sax.SAXException;  public interface IslandVerifier extends ContentHandler {  void setDispatcher( Dispatcher disp );  public ElementDecl[] endIsland() throws SAXException;  public void endChildIsland( String uri, ElementDecl assignedDecls[] ) throws SAXException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher; import java.util.Iterator;  public interface SchemaProvider {  IslandVerifier createTopLevelVerifier();  IslandSchema getSchemaByNamespace( String uri );  Iterator iterateNamespace();  IslandSchema[] getSchemata(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher.impl; import java.util.Iterator; import java.util.Map; import org.iso_relax.dispatcher.IslandSchema; import org.iso_relax.dispatcher.SchemaProvider;  public abstract class AbstractSchemaProviderImpl implements SchemaProvider {  protected final Map schemata = new java.util.HashMap();  public void addSchema( String uri, IslandSchema s ) { if( schemata.containsKey(uri) ) throw new IllegalArgumentException(); schemata.put( uri, s ); } public IslandSchema getSchemaByNamespace( String uri ) { return (IslandSchema)schemata.get(uri); } public Iterator iterateNamespace() { return schemata.keySet().iterator(); } public IslandSchema[] getSchemata() { IslandSchema[] r = new IslandSchema[schemata.size()]; schemata.values().toArray(r); return r; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher.impl; import java.util.Enumeration; import java.util.Vector; import org.iso_relax.dispatcher.ElementDecl; import org.iso_relax.dispatcher.IslandVerifier; import org.iso_relax.dispatcher.SchemaProvider; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.NamespaceSupport;  public class DispatcherImpl implements org.iso_relax.dispatcher.Dispatcher {  private int depth =1; protected Locator documentLocator =null; protected final NamespaceSupport nsMap = new NamespaceSupport(); protected ErrorHandler errorHandler;  private IslandVerifier currentHandler =null;  protected final SchemaProvider schema; public SchemaProvider getSchemaProvider() { return schema; }  protected Transponder transponder; public DispatcherImpl( SchemaProvider schema ) { this.schema = schema; this.transponder = new Transponder(); this.currentHandler = schema.createTopLevelVerifier(); this.currentHandler.setDispatcher(this); } protected static final class Context { public final IslandVerifier handler; public final int depth; public final Context previous; public Context( IslandVerifier handler, int depth, Context previous ) { this.handler = handler; this.depth = depth; this.previous = previous; } } protected Context contextStack = null; public void attachXMLReader( XMLReader reader ) { reader.setContentHandler(transponder); } public void switchVerifier( IslandVerifier newVerifier ) throws SAXException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher.impl; import org.iso_relax.dispatcher.Dispatcher; import org.iso_relax.dispatcher.ElementDecl; import org.iso_relax.dispatcher.IslandSchema; import org.iso_relax.dispatcher.IslandVerifier; import org.xml.sax.Attributes; import org.xml.sax.SAXException; import org.xml.sax.helpers.DefaultHandler;  public final class IgnoreVerifier extends DefaultHandler implements IslandVerifier { private final ElementDecl[] rules;  public IgnoreVerifier( String namespaceToIgnore, ElementDecl[] assignedRules ) { this.namespaceToIgnore = namespaceToIgnore; this.rules = assignedRules; }  private final String namespaceToIgnore; public ElementDecl[] endIsland() { return rules; } public void endChildIsland( String uri, ElementDecl[] assignedLabels ){} private Dispatcher dispatcher; public void setDispatcher( Dispatcher disp ) { this.dispatcher=disp; } public void startElement( String namespaceURI, String localName, String qName, Attributes attributes ) throws SAXException { if( namespaceToIgnore.equals(namespaceURI) ) return; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.iso_relax.dispatcher.impl; import java.util.Iterator; import java.util.Vector; import org.iso_relax.dispatcher.AttributesDecl; import org.iso_relax.dispatcher.AttributesVerifier; import org.iso_relax.dispatcher.ElementDecl; import org.iso_relax.dispatcher.IslandSchema; import org.iso_relax.dispatcher.IslandVerifier; import org.iso_relax.dispatcher.SchemaProvider; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXNotRecognizedException;  public class IgnoredSchema implements IslandSchema { private static final ElementDecl[] theElemDecl = new ElementDecl[]{ new ElementDecl(){ public String getName() { return \"$$any$$\"; } public Object getProperty(String propertyName) throws SAXNotRecognizedException { throw new SAXNotRecognizedException(propertyName); } public boolean getFeature(String featureName) throws SAXNotRecognizedException { throw new SAXNotRecognizedException(featureName); } } }; private static final AttributesDecl[] theAttDecl = new AttributesDecl[]{ new AttributesDecl(){ public String getName() { return \"$$any$$\"; } public Object getProperty(String propertyName) throws SAXNotRecognizedException { throw new SAXNotRecognizedException(propertyName); } public boolean getFeature(String featureName) throws SAXNotRecognizedException { throw new SAXNotRecognizedException(featureName); } } }; public ElementDecl getElementDeclByName( String name ) { return theElemDecl[0]; } public ElementDecl[] getElementDecls() { return theElemDecl; } public Iterator iterateElementDecls() { Vector vec = new Vector(); vec.add(theElemDecl[0]); return vec.iterator(); } public IslandVerifier createNewVerifier( String namespaceURI, ElementDecl[] rules ) { return new IgnoreVerifier(namespaceURI,rules); } public AttributesDecl getAttributesDeclByName( String name ) { return theAttDecl[0]; } public AttributesDecl[] getAttributesDecls() { return theAttDecl; } public Iterator iterateAttributesDecls() { Vector vec = new Vector(); vec.add(theAttDecl[0]); return vec.iterator(); } public AttributesVerifier createNewAttributesVerifier( String namespaceURI, AttributesDecl[] decls ) { throw new Error(\"not implemented yet\"); } public void bind( SchemaProvider provider, ErrorHandler handler ) {} }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.jaxp; import java.io.File; import java.io.IOException; import java.io.InputStream; import javax.xml.parsers.DocumentBuilder; import org.iso_relax.verifier.Verifier; import org.w3c.dom.DOMImplementation; import org.w3c.dom.Document; import org.xml.sax.EntityResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException;  class ValidatingDocumentBuilder extends DocumentBuilder { protected DocumentBuilder _WrappedBuilder; protected Verifier _Verifier;  public ValidatingDocumentBuilder(DocumentBuilder wrapped, Verifier verifier) { _WrappedBuilder = wrapped; _Verifier = verifier; }  public Document parse(InputSource inputsource) throws SAXException, IOException { return verify(_WrappedBuilder.parse(inputsource)); }  public Document parse(File file) throws SAXException, IOException { return verify(_WrappedBuilder.parse(file)); }  public Document parse(InputStream strm) throws SAXException, IOException { return verify(_WrappedBuilder.parse(strm)); }  public Document parse(InputStream strm, String systemId) throws SAXException, IOException { return verify(_WrappedBuilder.parse(strm, systemId)); }  public Document parse(String url) throws SAXException, IOException { return verify(_WrappedBuilder.parse(url)); }  public boolean isNamespaceAware() { return _WrappedBuilder.isNamespaceAware(); }  public boolean isValidating() { return true; }  public void setEntityResolver(EntityResolver entityresolver) { _WrappedBuilder.setEntityResolver(entityresolver); _Verifier.setEntityResolver(entityresolver); }  public void setErrorHandler(ErrorHandler errorhandler) { _WrappedBuilder.setErrorHandler(errorhandler); _Verifier.setErrorHandler(errorhandler); }  public Document newDocument() { return _WrappedBuilder.newDocument(); }  public DOMImplementation getDOMImplementation() { return _WrappedBuilder.getDOMImplementation(); } private Document verify(Document dom) throws SAXException, IOException { if(_Verifier.verify(dom)) return dom; else throw new SAXException(\"the document is invalid, but the ErrorHandler does not throw any Exception.\"); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.jaxp; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import org.iso_relax.verifier.Schema; import org.iso_relax.verifier.VerifierConfigurationException;  public class ValidatingDocumentBuilderFactory extends DocumentBuilderFactory { protected Schema _Schema; protected DocumentBuilderFactory _WrappedFactory; private boolean validation = true;  public ValidatingDocumentBuilderFactory(Schema schema) { this(DocumentBuilderFactory.newInstance(), schema); }  public ValidatingDocumentBuilderFactory(DocumentBuilderFactory wrapped, Schema schema) { _WrappedFactory = wrapped; _Schema = schema; }  public DocumentBuilder newDocumentBuilder() throws ParserConfigurationException { if(isValidating()) { try { return new ValidatingDocumentBuilder( _WrappedFactory.newDocumentBuilder(), _Schema.newVerifier()); } catch(VerifierConfigurationException ex) { throw new ParserConfigurationException(ex.getMessage()); } } else "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.jaxp; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import javax.xml.parsers.SAXParser; import org.iso_relax.verifier.Verifier; import org.xml.sax.HandlerBase; import org.xml.sax.InputSource; import org.xml.sax.Parser; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.XMLFilter; import org.xml.sax.XMLReader; import org.xml.sax.helpers.DefaultHandler;  class ValidatingSAXParser extends SAXParser { protected SAXParser _WrappedParser; protected Verifier _Verifier;  public ValidatingSAXParser(SAXParser wrapped, Verifier verifier) { _WrappedParser = wrapped; _Verifier = verifier; }  public Parser getParser() { throw new UnsupportedOperationException(\"getParser() method is not supported. Use getXMLReader().\"); }  public XMLReader getXMLReader() throws SAXException { XMLFilter filter = _Verifier.getVerifierFilter(); filter.setParent(_WrappedParser.getXMLReader()); return filter; }  public boolean isNamespaceAware() { return _WrappedParser.isNamespaceAware(); }  public boolean isValidating() { return true; }  public void setProperty(String name, Object value) throws SAXNotRecognizedException, SAXNotSupportedException { _WrappedParser.setProperty(name, value); }  public Object getProperty(String name) throws SAXNotRecognizedException, SAXNotSupportedException { return _WrappedParser.getProperty(name); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.jaxp; import javax.xml.parsers.ParserConfigurationException; import javax.xml.parsers.SAXParser; import javax.xml.parsers.SAXParserFactory; import org.iso_relax.verifier.Schema; import org.iso_relax.verifier.VerifierConfigurationException; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException;  public class ValidatingSAXParserFactory extends SAXParserFactory { protected SAXParserFactory _WrappedFactory; protected Schema _Schema; private boolean validation = true;  public ValidatingSAXParserFactory(Schema schema) { this(SAXParserFactory.newInstance(), schema); }  public ValidatingSAXParserFactory(SAXParserFactory wrapped, Schema schema) { _WrappedFactory = wrapped; _Schema = schema; }  public SAXParser newSAXParser() throws ParserConfigurationException, SAXException { if(isValidating()) { try { return new ValidatingSAXParser( _WrappedFactory.newSAXParser(), _Schema.newVerifier()); } catch(VerifierConfigurationException ex) { throw new ParserConfigurationException(ex.getMessage()); } } else return _WrappedFactory.newSAXParser(); }  public void setFeature(String name, boolean value) throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException { _WrappedFactory.setFeature(name, value); }  public boolean getFeature(String name) throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException { return _WrappedFactory.getFeature(name); } public boolean isNamespaceAware() { return _WrappedFactory.isNamespaceAware(); } public void setNamespaceAware(boolean awareness) { _WrappedFactory.setNamespaceAware(awareness); } public boolean isValidating() { return validation; } public void setValidating(boolean validating) { validation = validating; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier;  public interface Schema {  Verifier newVerifier() throws VerifierConfigurationException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier; import java.io.File; import java.io.IOException; import org.w3c.dom.Node; import org.xml.sax.EntityResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException;  public interface Verifier {  String FEATURE_HANDLER = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier; import java.io.PrintStream; import java.io.PrintWriter;  public class VerifierConfigurationException extends Exception { private Exception cause_ = null; public VerifierConfigurationException(String message) { super(message); } public VerifierConfigurationException(Exception e) { super(e.getMessage()); cause_ = e; } public VerifierConfigurationException(String message, Exception e) { super(message); cause_ = e; } public Exception getException() { if (cause_ != null) { return (cause_); } else { return (this); } } public Exception getCauseException() { return (cause_); } public void printStackTrace() { printStackTrace(new PrintWriter(System.err, true)); } public void printStackTrace(PrintStream out) { printStackTrace(new PrintWriter(out)); } public void printStackTrace(PrintWriter writer) { if (writer == null) { writer = new PrintWriter(System.err, true); } super.printStackTrace(writer); if (cause_ != null) { writer.println(); writer.println(\"StackTrace of Original Exception:\"); cause_.printStackTrace(writer); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier; import java.io.PrintStream; import java.io.PrintWriter; import org.xml.sax.SAXException;  public class VerifierException extends SAXException { public VerifierException(String message) { super(message); } public VerifierException(Exception e) { super(e); } public VerifierException(String message, Exception e) { super(message,e); } public void printStackTrace() { printStackTrace(new PrintWriter(System.err, true)); } public void printStackTrace(PrintStream out) { printStackTrace(new PrintWriter(out)); } public void printStackTrace(PrintWriter writer) { if (writer == null) { writer = new PrintWriter(System.err, true); } super.printStackTrace(writer); Exception cause = super.getException(); if (cause != null) { writer.println(); writer.println(\"StackTrace of Original Exception:\"); cause.printStackTrace(writer); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.net.URL; import java.util.Enumeration; import java.util.HashMap; import java.util.Iterator; import java.util.Vector; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException;  public abstract class VerifierFactory {  public Verifier newVerifier(String uri) throws VerifierConfigurationException, SAXException, IOException { return compileSchema(uri).newVerifier(); }  public Verifier newVerifier(File file) throws VerifierConfigurationException, SAXException, IOException { return compileSchema(file).newVerifier(); }  public Verifier newVerifier(InputStream stream) throws VerifierConfigurationException, SAXException, IOException { return compileSchema( stream, null ).newVerifier(); }  public Verifier newVerifier(InputStream stream, String systemId ) throws VerifierConfigurationException, SAXException, IOException { return compileSchema(stream,systemId).newVerifier(); }  public Verifier newVerifier(InputSource source) throws VerifierConfigurationException, SAXException, IOException { return compileSchema(source).newVerifier(); }  public abstract Schema compileSchema( InputSource is ) throws VerifierConfigurationException, SAXException, IOException;  public Schema compileSchema( String url ) throws VerifierConfigurationException, SAXException, IOException { return compileSchema( new InputSource(url) ); }  public Schema compileSchema( InputStream stream ) throws VerifierConfigurationException, SAXException, IOException { return compileSchema(stream,null); }  public Schema compileSchema( InputStream stream, String systemId ) throws VerifierConfigurationException, SAXException, IOException { InputSource is = new InputSource(stream); is.setSystemId(systemId); return compileSchema(is); }  public Schema compileSchema( File f ) throws VerifierConfigurationException, SAXException, IOException { String uri = \"file:\" + f.getAbsolutePath(); if (File.separatorChar == '\\\\') { uri = uri.replace('\\\\', '/'); } return compileSchema(new InputSource(uri)); }  public boolean isFeature(String feature) throws SAXNotRecognizedException, SAXNotSupportedException { if (Verifier.FEATURE_HANDLER.equals(feature) || Verifier.FEATURE_FILTER.equals(feature)) return true; throw new SAXNotRecognizedException(feature); }  public void setFeature(String feature, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException { throw new SAXNotRecognizedException(feature); }  public Object getProperty(String property) throws SAXNotRecognizedException, SAXNotSupportedException { throw new SAXNotRecognizedException(property); }  public void setProperty(String property, Object value) throws SAXNotRecognizedException, SAXNotSupportedException { throw new SAXNotRecognizedException(property); } private EntityResolver resolver = null;  public void setEntityResolver( EntityResolver _resolver ) { this.resolver = _resolver; }  public EntityResolver getEntityResolver() { return resolver; }  public static VerifierFactory newInstance() throws VerifierConfigurationException { return newInstance(\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier;  public interface VerifierFactoryLoader {  VerifierFactory createFactory( String schemaLanguage ); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier; import org.xml.sax.XMLFilter;  public interface VerifierFilter extends XMLFilter {  boolean isValid() throws IllegalStateException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier; import org.xml.sax.ContentHandler;  public interface VerifierHandler extends ContentHandler {  boolean isValid() throws IllegalStateException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier.impl; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException;  public class ForkContentHandler implements ContentHandler {  public ForkContentHandler( ContentHandler first, ContentHandler second ) { lhs = first; rhs = second; }  public static ContentHandler create( ContentHandler[] handlers ) { if(handlers.length==0) throw new IllegalArgumentException(); ContentHandler result = handlers[0]; for( int i=1; i<handlers.length; i++ ) result = new ForkContentHandler( result, handlers[i] ); return result; } private final ContentHandler lhs,rhs; public void setDocumentLocator (Locator locator) { lhs.setDocumentLocator(locator); rhs.setDocumentLocator(locator); } public void startDocument() throws SAXException { lhs.startDocument(); rhs.startDocument(); } public void endDocument () throws SAXException { lhs.endDocument(); rhs.endDocument(); } public void startPrefixMapping (String prefix, String uri) throws SAXException { lhs.startPrefixMapping(prefix,uri); rhs.startPrefixMapping(prefix,uri); } public void endPrefixMapping (String prefix) throws SAXException { lhs.endPrefixMapping(prefix); rhs.endPrefixMapping(prefix); } public void startElement (String uri, String localName, String qName, Attributes attributes) throws SAXException { lhs.startElement(uri,localName,qName,attributes); rhs.startElement(uri,localName,qName,attributes); } public void endElement (String uri, String localName, String qName) throws SAXException { lhs.endElement(uri,localName,qName); rhs.endElement(uri,localName,qName); } public void characters (char ch[], int start, int length) throws SAXException { lhs.characters(ch,start,length); rhs.characters(ch,start,length); } public void ignorableWhitespace (char ch[], int start, int length) throws SAXException { lhs.ignorableWhitespace(ch,start,length); rhs.ignorableWhitespace(ch,start,length); } public void processingInstruction (String target, String data) throws SAXException { lhs.processingInstruction(target,data); rhs.processingInstruction(target,data); } public void skippedEntity (String name) throws SAXException { lhs.skippedEntity(name); rhs.skippedEntity(name); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier.impl; import java.util.Enumeration; import jp.gr.xml.relax.dom.DOMVisitorException; import jp.gr.xml.relax.dom.IDOMVisitor; import jp.gr.xml.relax.dom.UDOM; import jp.gr.xml.relax.dom.UDOMVisitor; import jp.gr.xml.relax.sax.DeclHandlerBase; import jp.gr.xml.relax.sax.LexicalHandlerBase; import org.w3c.dom.Attr; import org.w3c.dom.CDATASection; import org.w3c.dom.Comment; import org.w3c.dom.Document; import org.w3c.dom.DocumentFragment; import org.w3c.dom.DocumentType; import org.w3c.dom.Element; import org.w3c.dom.Entity; import org.w3c.dom.EntityReference; import org.w3c.dom.NamedNodeMap; import org.w3c.dom.Node; import org.w3c.dom.Notation; import org.w3c.dom.ProcessingInstruction; import org.w3c.dom.Text; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.ext.DeclHandler; import org.xml.sax.ext.LexicalHandler; import org.xml.sax.helpers.AttributesImpl; import org.xml.sax.helpers.DefaultHandler; import org.xml.sax.helpers.LocatorImpl; import org.xml.sax.helpers.NamespaceSupport;  public class SAXEventGenerator implements IDOMVisitor { private Node root_; private boolean needDocumentEmulation_ = true; private String systemID_; private String publicID_; private DTDHandler dtd_; private ContentHandler content_; private DeclHandler decl_; private LexicalHandler lexical_; private ErrorHandler error_; private final NamespaceSupport namespace_ = new NamespaceSupport(); public SAXEventGenerator(Node node) { root_ = node; DefaultHandler handler = new DefaultHandler(); dtd_ = handler; content_ = handler; error_ = handler; lexical_ = new LexicalHandlerBase(); decl_ = new DeclHandlerBase(); } public void setDocumentEmulation(boolean emulate) { needDocumentEmulation_ = emulate; } public void setDTDHandler(DTDHandler dtd) { dtd_ = dtd; } public void setContentHandler(ContentHandler content) { content_ = content; } public void setLexicalHandler(LexicalHandler lexical) { lexical_ = lexical; } public void setDeclHandler(DeclHandler decl) { decl_ = decl; } public void setErrorHandler(ErrorHandler error) { error_ = error; } public void makeEvent() throws SAXException { try { if (!(root_ instanceof Document) && needDocumentEmulation_) { emulateStartDocument(); UDOMVisitor.traverse(root_, this); emulateEndDocument(); } else { UDOMVisitor.traverse(root_, this); } } catch (DOMVisitorException e) { Exception cause = e.getCauseException(); if (cause == null) { throw (new SAXException(e.getMessage())); } else if (cause instanceof SAXException) { throw ((SAXException)cause); } else { throw (new SAXException(e.getMessage())); } } } public void makeEvent(ContentHandler handler) throws SAXException { setContentHandler(handler); makeEvent(); } public void emulateStartDocument() { try { _handleLocator(); content_.startDocument(); } catch (SAXException e) { _errorReport(e); } } public void emulateEndDocument() { try { content_.endDocument(); } catch (SAXException e) { _errorReport(e); } } public boolean enter(Element element) { try { namespace_.pushContext(); String namespaceURI = element.getNamespaceURI(); if (namespaceURI == null) { namespaceURI = \"\"; } String localName = element.getLocalName(); String qName = element.getTagName(); if(localName==null) localName = qName; NamedNodeMap attrMap = element.getAttributes(); AttributesImpl attrs = new AttributesImpl(); int size = attrMap.getLength(); for (int i = 0;i < size;i++) { Attr attr = (Attr)attrMap.item(i); String attrNamespaceURI = attr.getNamespaceURI(); if (attrNamespaceURI == null) { attrNamespaceURI = \"\"; } String attrLocalName = attr.getLocalName(); String attrQName = attr.getName(); if(attrLocalName==null) attrLocalName = attrQName; String attrValue = attr.getValue(); if (attrQName.startsWith(\"xmlns\")) { String prefix; int index = attrQName.indexOf(':'); if (index == -1) { prefix = \"\"; } else { prefix = attrQName.substring(index + 1); } if (!namespace_.declarePrefix(prefix, attrValue)) { _errorReport(\"bad prefix = \" + prefix); } else { content_.startPrefixMapping(prefix, attrValue); } } else { attrs.addAttribute( attrNamespaceURI, attrLocalName, attrQName, \"CDATA\", attrValue ); } } content_.startElement(namespaceURI, localName, qName, attrs); } catch (SAXException e) { _errorReport(e); } return (true); } public boolean enter(Attr attr) { return (false); } public boolean enter(Text text) { try { String data = text.getData(); content_.characters(data.toCharArray(), 0, data.length()); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(CDATASection cdata) { try { lexical_.startCDATA(); String data = cdata.getData(); content_.characters(data.toCharArray(), 0, data.length()); lexical_.endCDATA(); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(EntityReference entityRef) { try { lexical_.startEntity(entityRef.getNodeName()); } catch (SAXException e) { _errorReport(e); } return (true); } public boolean enter(Entity entity) { return (false); } public boolean enter(ProcessingInstruction pi) { try { content_.processingInstruction(pi.getTarget(), pi.getData()); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(Comment comment) { try { String data = comment.getData(); lexical_.comment(data.toCharArray(), 0, data.length()); } catch (SAXException e) { _errorReport(e); } return (false); } public boolean enter(Document doc) { try { _handleLocator(); content_.startDocument(); _handleDoctype(doc.getDoctype()); } catch (SAXException e) { _errorReport(e); } return (true); } private void _handleLocator() { if (systemID_ == null && publicID_ == null) { return; } _locatorEvent(systemID_, publicID_); } private void _locatorEvent(String systemID, String publicID) { LocatorImpl locator = new LocatorImpl(); locator.setSystemId(systemID_); locator.setPublicId(publicID_); locator.setLineNumber(-1); locator.setColumnNumber(-1); content_.setDocumentLocator(locator); } private void _handleDoctype(DocumentType doctype) { try { if (doctype == null) { return; } String systemID = doctype.getSystemId(); String publicID = doctype.getPublicId(); String internalSubset = doctype.getInternalSubset(); if (systemID != null) { lexical_.startDTD(doctype.getName(), publicID, systemID); if (internalSubset == null) { lexical_.endDTD(); _handleEntities(doctype); } else { _handleEntities(doctype); lexical_.endDTD(); } } else { _handleEntities(doctype); } } catch (SAXException e) { _errorReport(e); } } private void _handleEntities(DocumentType doctype) { try { NamedNodeMap entities = doctype.getEntities(); int nEntities = entities.getLength(); for (int i = 0;i < nEntities;i++) { Entity entity = (Entity)entities.item(i); String publicID = entity.getPublicId(); String systemID = entity.getSystemId(); String notationName = entity.getNotationName(); if (publicID != null || systemID != null) { _handleExternalEntity( entity.getNodeName(), publicID, systemID, notationName ); } else { _handleInternalEntity(entity); } } NamedNodeMap notations = doctype.getNotations(); int nNotations = notations.getLength(); for (int i = 0;i < nNotations;i++) { Notation notation = (Notation)notations.item(i); String publicID = notation.getPublicId(); String systemID = notation.getSystemId(); dtd_.notationDecl(notation.getNodeName(), publicID, systemID); } } catch (SAXException e) { _errorReport(e); } } private void _handleExternalEntity( String name, String publicID, String systemID, String notationName ) { try { if (notationName == null) { decl_.externalEntityDecl(name, publicID, systemID); } else { dtd_.unparsedEntityDecl( name, publicID, systemID, notationName ); } } catch (SAXException e) { _errorReport(e); } } private void _handleInternalEntity(Entity entity) { try { decl_.internalEntityDecl( entity.getNodeName(), UDOM.getXMLText(entity) ); } catch (SAXException e) { _errorReport(e); } } public boolean enter(DocumentType doctype) { return (false); } public boolean enter(DocumentFragment docfrag) { return (true); } public boolean enter(Notation notation) { return (false); } public boolean enter(Node node) { return (false); } public void leave(Element element) { try { String namespaceURI = element.getNamespaceURI(); if (namespaceURI == null) { namespaceURI = \"\"; } String localName = element.getLocalName(); String qName = element.getTagName(); if(localName==null) localName=qName; content_.endElement(namespaceURI, localName, qName); for (Enumeration e=namespace_.getDeclaredPrefixes(); e.hasMoreElements(); ) content_.endPrefixMapping( (String)e.nextElement() ); namespace_.popContext(); } catch (SAXException e) { _errorReport(e); } } public void leave(Attr attr) { } public void leave(Text text) { } public void leave(CDATASection cdata) { } public void leave(EntityReference entityRef) { try { lexical_.endEntity(entityRef.getNodeName()); } catch (SAXException e) { _errorReport(e); } } public void leave(Entity entity) { } public void leave(ProcessingInstruction pi) { } public void leave(Comment comment) { } public void leave(Document doc) { try { content_.endDocument(); } catch (SAXException e) { _errorReport(e); } } public void leave(DocumentType doctype) { } public void leave(DocumentFragment docfrag) { } public void leave(Notation notation) { } public void leave(Node node) { } private void _errorReport(String message) throws DOMVisitorException { _errorReport( new SAXParseException( message, publicID_, systemID_, -1, -1 ) ); } private void _errorReport(SAXException e) throws DOMVisitorException { try { SAXParseException parseException; if (e instanceof SAXParseException) { parseException = (SAXParseException)e; } else { parseException = new SAXParseException( e.getMessage(), publicID_, systemID_, -1, -1, e ); } error_.fatalError(parseException); throw new DOMVisitorException(e); } catch (SAXException ee) { throw new DOMVisitorException(ee); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier.impl; import org.iso_relax.verifier.Verifier; import org.iso_relax.verifier.VerifierFilter; import org.iso_relax.verifier.VerifierHandler; import org.xml.sax.Attributes; import org.xml.sax.EntityResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.helpers.XMLFilterImpl;  public class VerifierFilterImpl extends XMLFilterImpl implements VerifierFilter { public VerifierFilterImpl( Verifier _verifier ) throws SAXException { this.verifier = _verifier; this.core = verifier.getVerifierHandler(); } private final Verifier verifier; private final VerifierHandler core; public boolean isValid() { return core.isValid(); } public void setErrorHandler( ErrorHandler handler ) { super.setErrorHandler(handler); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.iso_relax.verifier.impl; import java.io.File; import java.io.IOException; import javax.xml.parsers.ParserConfigurationException; import javax.xml.parsers.SAXParserFactory; import org.iso_relax.verifier.Verifier; import org.iso_relax.verifier.VerifierConfigurationException; import org.iso_relax.verifier.VerifierFilter; import org.iso_relax.verifier.VerifierHandler; import org.w3c.dom.Node; import org.xml.sax.EntityResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader;  public abstract class VerifierImpl implements Verifier { protected XMLReader reader; protected VerifierImpl() throws VerifierConfigurationException { prepareXMLReader(); }  protected void prepareXMLReader() throws VerifierConfigurationException { try { SAXParserFactory factory = SAXParserFactory.newInstance(); factory.setNamespaceAware(true); reader = factory.newSAXParser().getXMLReader(); } catch( SAXException e ) { throw new VerifierConfigurationException(e); } catch( ParserConfigurationException pce ) { throw new VerifierConfigurationException(pce); } } public boolean isFeature(String feature) throws SAXNotRecognizedException, SAXNotSupportedException { if (FEATURE_HANDLER.equals(feature) || FEATURE_FILTER.equals(feature)) return true; throw new SAXNotRecognizedException(feature); } public void setFeature(String feature, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException { throw new SAXNotRecognizedException(feature); } public Object getProperty(String property) throws SAXNotRecognizedException, SAXNotSupportedException { throw new SAXNotRecognizedException(property); } public void setProperty(String property, Object value) throws SAXNotRecognizedException, SAXNotSupportedException { throw new SAXNotRecognizedException(property); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype; import org.relaxng.datatype.Datatype; public interface Datatype2 extends Datatype { boolean alwaysValid(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype; import com.thaiopensource.util.Service; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory; import java.util.Iterator; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.util.Uri; class AnyUriDatatype extends TokenDatatype { public boolean lexicallyAllows(String str) { return Uri.isValid(str); } String getLexicalSpaceKey() { return \"uri\"; } public boolean alwaysValid() { return false; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.ValidationContext; class Base64BinaryDatatype extends BinaryDatatype { static private final byte[] weightTable = makeWeightTable(); static private final byte INVALID = (byte)-1; static private final byte WHITESPACE = (byte)-2; static private final byte PADDING = (byte)-3; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; abstract class BinaryDatatype extends DatatypeBase implements Measure { BinaryDatatype() { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.ValidationContext; class BooleanDatatype extends DatatypeBase { boolean lexicallyAllows(String str) { return str.equals(\"true\") || str.equals(\"false\") || str.equals(\"1\") || str.equals(\"0\"); } Object getValue(String str, ValidationContext vc) { switch (str.charAt(0)) { case 't': case '1': return Boolean.TRUE; } return Boolean.FALSE; } String getLexicalSpaceKey() { return \"boolean\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; class CdataDatatype extends TokenDatatype { CdataDatatype() { super(WHITE_SPACE_REPLACE); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.datatype.Datatype2; import com.thaiopensource.util.Localizer; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext; import org.relaxng.datatype.helpers.StreamingValidatorImpl; abstract class DatatypeBase implements Datatype2 { abstract boolean lexicallyAllows(String str); private final int whiteSpace; static final int WHITE_SPACE_PRESERVE = 0; static final int WHITE_SPACE_REPLACE = 1; static final int WHITE_SPACE_COLLAPSE = 2; DatatypeBase() { whiteSpace = WHITE_SPACE_COLLAPSE; } DatatypeBase(int whiteSpace) { this.whiteSpace = whiteSpace; } int getWhiteSpace() { return whiteSpace; } public boolean isValid(String str, ValidationContext vc) { str = normalizeWhiteSpace(str); return lexicallyAllows(str) && allowsValue(str, vc); } public void checkValid(String str, ValidationContext vc) throws DatatypeException { str = normalizeWhiteSpace(str); checkLexicallyAllows(str); getValue(str, vc); } public Object createValue(String str, ValidationContext vc) { str = normalizeWhiteSpace(str); if (!lexicallyAllows(str)) return null; try { return getValue(str, vc); } catch (DatatypeException e) { return null; } } final String normalizeWhiteSpace(String str) { switch (whiteSpace) { case WHITE_SPACE_COLLAPSE: return collapseWhiteSpace(str); case WHITE_SPACE_REPLACE: return replaceWhiteSpace(str); } return str; } void checkLexicallyAllows(String str) throws DatatypeException { if (!lexicallyAllows(str)) throw createLexicallyInvalidException(); } String getDescriptionForRestriction() { return getLexicalSpaceDescription(getLexicalSpaceKey()); } final String getLexicalSpaceDescription(String key) { return localizer().message(\"lexical_space_\" + key); } abstract String getLexicalSpaceKey(); DatatypeException createLexicallyInvalidException() { return new DatatypeException(localizer().message(\"lexical_violation\", getLexicalSpaceDescription(getLexicalSpaceKey()))); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.datatype.xsd.regex.RegexSyntaxException; import com.thaiopensource.util.Localizer; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; class DatatypeBuilderImpl implements DatatypeBuilder { static final Localizer localizer = new Localizer(DatatypeBuilderImpl.class); private DatatypeBase base; private final DatatypeLibraryImpl library; DatatypeBuilderImpl(DatatypeLibraryImpl library, DatatypeBase base) throws DatatypeException { this.library = library; this.base = base; } public void addParameter(String name, String value, ValidationContext context) throws DatatypeException { if (name.equals(\"pattern\")) addPatternParam(value); else if (name.equals(\"minInclusive\")) addMinInclusiveParam(value, context); else if (name.equals(\"maxInclusive\")) addMaxInclusiveParam(value, context); else if (name.equals(\"minExclusive\")) addMinExclusiveParam(value, context); else if (name.equals(\"maxExclusive\")) addMaxExclusiveParam(value, context); else if (name.equals(\"length\")) addLengthParam(value); else if (name.equals(\"minLength\")) addMinLengthParam(value); else if (name.equals(\"maxLength\")) addMaxLengthParam(value); else if (name.equals(\"fractionDigits\")) addScaleParam(value); else if (name.equals(\"totalDigits\")) addPrecisionParam(value); else if (name.equals(\"enumeration\")) error(\"enumeration_param\"); else if (name.equals(\"whiteSpace\")) error(\"whiteSpace_param\"); else error(\"unrecognized_param\", name); } private void addPatternParam(String value) throws DatatypeException { try { base = new PatternRestrictDatatype(base, library.getRegexEngine().compile(value), value); } catch (RegexSyntaxException e) { int pos = e.getPosition(); if (pos == RegexSyntaxException.UNKNOWN_POSITION) pos = DatatypeException.UNKNOWN; error(\"invalid_regex\", e.getMessage(), pos); } } private void addMinInclusiveParam(String value, ValidationContext context) throws DatatypeException { base = new MinInclusiveRestrictDatatype(base, getLimit(value, context), value); } private void addMaxInclusiveParam(String value, ValidationContext context) throws DatatypeException { base = new MaxInclusiveRestrictDatatype(base, getLimit(value, context), value); } private void addMinExclusiveParam(String value, ValidationContext context) throws DatatypeException { base = new MinExclusiveRestrictDatatype(base, getLimit(value, context), value); } private void addMaxExclusiveParam(String value, ValidationContext context) throws DatatypeException { base = new MaxExclusiveRestrictDatatype(base, getLimit(value, context), value); } private Object getLimit(String str, ValidationContext context) throws DatatypeException { if (base.getOrderRelation() == null) error(\"not_ordered\"); str = base.normalizeWhiteSpace(str); try { base.checkLexicallyAllows(str); return base.getValue(str, context); } catch (DatatypeException e) { throw new DatatypeException(localizer.message(\"invalid_limit\", str, e.getMessage())); } } private void addLengthParam(String value) throws DatatypeException { base = new LengthRestrictDatatype(base, getLength(value)); } private void addMinLengthParam(String value) throws DatatypeException { base = new MinLengthRestrictDatatype(base, getLength(value)); } private void addMaxLengthParam(String value) throws DatatypeException { base = new MaxLengthRestrictDatatype(base, getLength(value)); } private int getLength(String str) throws DatatypeException { if (base.getMeasure() == null) error(\"no_length\"); int len = convertNonNegativeInteger(str); if (len < 0) error(\"length_not_non_negative_integer\"); return len; } private void addScaleParam(String str) throws DatatypeException { if (!(base.getPrimitive() instanceof DecimalDatatype)) error(\"scale_not_derived_from_decimal\"); int scale = convertNonNegativeInteger(str); if (scale < 0) error(\"scale_not_non_negative_integer\"); base = new ScaleRestrictDatatype(base, scale); } private void addPrecisionParam(String str) throws DatatypeException { if (!(base.getPrimitive() instanceof DecimalDatatype)) error(\"precision_not_derived_from_decimal\"); int scale = convertNonNegativeInteger(str); if (scale <= 0) error(\"precision_not_positive_integer\"); base = new PrecisionRestrictDatatype(base, scale); } public Datatype createDatatype() { return base; } private static void error(String key) throws DatatypeException { throw new DatatypeException(localizer.message(key)); } private static void error(String key, String arg) throws DatatypeException { throw new DatatypeException(localizer.message(key, arg)); } private static void error(String key, String arg, int pos) throws DatatypeException { throw new DatatypeException(pos, localizer.message(key, arg)); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.datatype.xsd.regex.RegexEngine; import com.thaiopensource.util.Service; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory; import java.util.Iterator; public class DatatypeLibraryFactoryImpl implements DatatypeLibraryFactory { private DatatypeLibrary datatypeLibrary = null; private final RegexEngine regexEngine; private final boolean autoRegexEngine; public DatatypeLibraryFactoryImpl() { this.regexEngine = null; this.autoRegexEngine = true; } public DatatypeLibraryFactoryImpl(RegexEngine regexEngine) { this.regexEngine = regexEngine; this.autoRegexEngine = false; } public DatatypeLibrary createDatatypeLibrary(String uri) { if (!WellKnownNamespaces.XML_SCHEMA_DATATYPES.equals(uri)) return null; synchronized (this) { if (datatypeLibrary == null) datatypeLibrary = new DatatypeLibraryImpl(autoRegexEngine ? findRegexEngine() : regexEngine); return datatypeLibrary; } } private static RegexEngine findRegexEngine() { Iterator<RegexEngine> iter = Service.newInstance(RegexEngine.class).getProviders(); if (!iter.hasNext()) return null; return iter.next(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.datatype.xsd.regex.RegexEngine; import com.thaiopensource.datatype.xsd.regex.RegexSyntaxException; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeLibrary; import java.util.HashMap; import java.util.Map; public class DatatypeLibraryImpl implements DatatypeLibrary { private final Map<String, DatatypeBase> typeMap = new HashMap<String, DatatypeBase>(); private final RegexEngine regexEngine; static private final String LONG_MAX = \"9223372036854775807\"; static private final String LONG_MIN = \"-9223372036854775808\"; static private final String INT_MAX = \"2147483647\"; static private final String INT_MIN = \"-2147483648\"; static private final String SHORT_MAX = \"32767\"; static private final String SHORT_MIN = \"-32768\"; static private final String BYTE_MAX = \"127\"; static private final String BYTE_MIN = \"-128\"; static private final String UNSIGNED_LONG_MAX = \"18446744073709551615\"; static private final String UNSIGNED_INT_MAX = \"4294967295\"; static private final String UNSIGNED_SHORT_MAX = \"65535\"; static private final String UNSIGNED_BYTE_MAX = \"255\"; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; class DateTimeDatatype extends RegexDatatype implements OrderRelation { static private final String YEAR_PATTERN = \"-?([1-9][0-9]*)?[0-9]{4}\"; static private final String MONTH_PATTERN = \"[0-9]{2}\"; static private final String DAY_OF_MONTH_PATTERN = \"[0-9]{2}\"; static private final String TIME_PATTERN = \"[0-9]{2}:[0-9]{2}:[0-9]{2}(\\\\.[0-9]*)?\"; static private final String TZ_PATTERN = \"(Z|[+\\\\-][0-9][0-9]:[0-5][0-9])?\"; private final String template; private final String lexicalSpaceKey;  DateTimeDatatype(String template) { super(makePattern(template)); this.template = template; this.lexicalSpaceKey = makeLexicalSpaceKey(template); } String getLexicalSpaceKey() { return lexicalSpaceKey; } static private String makeLexicalSpaceKey(String template) { String key = \"\"; if (template.indexOf('Y') >= 0) key += \"_y\"; if (template.indexOf('M') >= 0) key += \"_m\"; if (template.indexOf('D') >= 0) key += \"_d\"; if (key.length() > 0) key = \"date\" + key; if (template.indexOf('t') >= 0) key = key.length() > 0 ? key + \"_time\" : \"time\"; return key; } static private String makePattern(String template) { StringBuffer pattern = new StringBuffer(); for (int i = 0, len = template.length(); i < len; i++) { char c = template.charAt(i); switch (c) { case 'Y': pattern.append(YEAR_PATTERN); break; case 'M': pattern.append(MONTH_PATTERN); break; case 'D': pattern.append(DAY_OF_MONTH_PATTERN); break; case 't': pattern.append(TIME_PATTERN); break; default: pattern.append(c); break; } } pattern.append(TZ_PATTERN); return pattern.toString(); } static private class DateTime { private final Date date; private final int leapMilliseconds; private final boolean hasTimeZone; DateTime(Date date, int leapMilliseconds, boolean hasTimeZone) { this.date = date; this.leapMilliseconds = leapMilliseconds; this.hasTimeZone = hasTimeZone; } public boolean equals(Object obj) { if (!(obj instanceof DateTime)) return false; DateTime other = (DateTime)obj; return (this.date.equals(other.date) && this.leapMilliseconds == other.leapMilliseconds && this.hasTimeZone == other.hasTimeZone); } public int hashCode() { return date.hashCode(); } Date getDate() { return date; } int getLeapMilliseconds() { return leapMilliseconds; } boolean getHasTimeZone() { return hasTimeZone; } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.ValidationContext; import java.math.BigDecimal; class DecimalDatatype extends DatatypeBase implements OrderRelation { boolean lexicallyAllows(String str) { int len = str.length(); if (len == 0) return false; int i = 0; switch (str.charAt(i)) { case '+': case '-': if (++i == len) return false; } boolean hadDecimalPoint = false; if (str.charAt(i) == '.') { hadDecimalPoint = true; if (++i == len) return false; } do { switch (str.charAt(i)) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': break; case '.': if (hadDecimalPoint) return false; hadDecimalPoint = true; break; default: return false; } } while (++i < len); return true; } String getLexicalSpaceKey() { return \"decimal\"; } Object getValue(String str, ValidationContext vc) { if (str.charAt(0) == '+') str = str.substring(1); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.ValidationContext; class DoubleDatatype extends DatatypeBase implements OrderRelation { boolean lexicallyAllows(String str) { if (str.equals(\"INF\") || str.equals(\"-INF\") || str.equals(\"NaN\")) return true; int len = str.length(); boolean hadSign = false; boolean hadDecimalPoint = false; boolean hadDigit = false; boolean hadE = false; for (int i = 0; i < len; i++) { switch (str.charAt(i)) { case '+': case '-': if (hadDigit || hadDecimalPoint || hadSign) return false; hadSign = true; break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': hadDigit = true; break; case 'e': case 'E': if (hadE || !hadDigit) return false; hadDigit = false; hadE = true; hadSign = false; hadDecimalPoint = false; break; case '.': if (hadDecimalPoint || hadE) return false; hadDecimalPoint = true; break; default: return false; } } return hadDigit; } String getLexicalSpaceKey() { return \"float\"; } Object getValue(String str, ValidationContext vc) { if (str.equals(\"INF\")) return Double.POSITIVE_INFINITY; if (str.equals(\"-INF\")) return Double.NEGATIVE_INFINITY; if (str.equals(\"NaN\")) return Double.NaN; return new Double(str); } OrderRelation getOrderRelation() { return this; } public boolean isLessThan(Object obj1, Object obj2) { return (Double)obj1 < (Double)obj2; } public boolean sameValue(Object value1, Object value2) { double d1 = (Double)value1; double d2 = (Double)value2; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.ValidationContext; import java.math.BigDecimal; import java.math.BigInteger; import java.util.Calendar; class DurationDatatype extends RegexDatatype implements OrderRelation { static private final String PATTERN = \"-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?(([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)S)?)?\"; DurationDatatype() { super(PATTERN); } public boolean lexicallyAllows(String str) { if (!super.lexicallyAllows(str)) return false; char last = str.charAt(str.length()-1); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; class EntityDatatype extends NCNameDatatype { boolean allowsValue(String str, ValidationContext vc) { return vc.isUnparsedEntity(str); } Object getValue(String str, ValidationContext vc) throws DatatypeException { if (!allowsValue(str, vc)) throw new DatatypeException(localizer().message(\"entity_violation\")); return str; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.ValidationContext; class FloatDatatype extends DoubleDatatype { Object getValue(String str, ValidationContext vc) { if (str.equals(\"INF\")) return Float.POSITIVE_INFINITY; if (str.equals(\"-INF\")) return Float.NEGATIVE_INFINITY; if (str.equals(\"NaN\")) return Float.NaN; return new Float(str); } public boolean isLessThan(Object obj1, Object obj2) { return (Float)obj1 < (Float)obj2; } public boolean sameValue(Object value1, Object value2) { float f1 = (Float)value1; float f2 = (Float)value2; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.ValidationContext; class HexBinaryDatatype extends BinaryDatatype { static private final int INVALID = -1; static private final int WHITESPACE = -2; boolean lexicallyAllows(String str) { int len = str.length(); int i = 0; while (i < len && weight(str.charAt(i)) == WHITESPACE) i++; while (i + 1 < len && weight(str.charAt(i)) >= 0 && weight(str.charAt(i + 1)) >= 0) i += 2; while (i < len && weight(str.charAt(i)) == WHITESPACE) i++; return i == len; } String getLexicalSpaceKey() { return \"hex\"; } Object getValue(String str, ValidationContext vc) { int len = str.length(); int start = 0; while (start < len && weight(str.charAt(start)) == WHITESPACE) start++; int end = len; while (end > start && weight(str.charAt(end - 1)) == WHITESPACE) end--; byte[] value = new byte[(end - start) >> 1]; int j = 0; for (int i = start; i < end; i += 2, j++) value[j] = (byte)((weight(str.charAt(i)) << 4) | weight(str.charAt(i + 1))); return value; } static private int weight(char c) { switch (c) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return c - '0'; case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': return c + (10 - 'A'); case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': return c + (10 - 'a'); case ' ': case '\\n': case '\\r': case '\\t': return WHITESPACE; } return INVALID; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; class IdDatatype extends NCNameDatatype { public int getIdType() { return ID_TYPE_ID; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; class IdrefDatatype extends NCNameDatatype { public int getIdType() { return ID_TYPE_IDREF; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class IntegerRestrictDatatype extends ScaleRestrictDatatype { IntegerRestrictDatatype(DatatypeBase base) { super(base, 0); } boolean lexicallyAllows(String str) { return super.lexicallyAllows(str) && str.charAt(str.length() - 1) != '.'; } void checkLexicallyAllows(String str) throws DatatypeException { if (!lexicallyAllows(str)) throw createLexicallyInvalidException(); } String getLexicalSpaceKey() { return \"integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class LengthRestrictDatatype extends ValueRestrictDatatype { private final int length; private final Measure measure; LengthRestrictDatatype(DatatypeBase base, int length) { super(base); this.measure = base.getMeasure(); this.length = length; } void checkRestriction(Object obj) throws DatatypeException { int actualLength = measure.getLength(obj); if (actualLength != length) throw new DatatypeException(localizer().message(\"length_violation\", new Object[] { getDescriptionForRestriction(), length, actualLength })); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.xml.util.StringSplitter; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; class ListDatatype extends DatatypeBase implements Measure { private final DatatypeBase itemType; ListDatatype(DatatypeBase itemType) { this.itemType = itemType; } String getLexicalSpaceKey() { return \"list_\" + itemType.getLexicalSpaceKey(); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class MaxExclusiveRestrictDatatype extends ValueRestrictDatatype { private final OrderRelation order; private final Object limit; private final String limitString; MaxExclusiveRestrictDatatype(DatatypeBase base, Object limit, String limitString) { super(base); this.order = base.getOrderRelation(); this.limit = limit; this.limitString = limitString; } void checkRestriction(Object value) throws DatatypeException { if (!order.isLessThan(value, limit)) throw new DatatypeException(localizer().message(\"max_exclusive_violation\", getDescriptionForRestriction(), limitString)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class MaxInclusiveRestrictDatatype extends ValueRestrictDatatype { private final OrderRelation order; private final Object limit; private final String limitString; MaxInclusiveRestrictDatatype(DatatypeBase base, Object limit, String limitString) { super(base); this.order = base.getOrderRelation(); this.limit = limit; this.limitString = limitString; } void checkRestriction(Object value) throws DatatypeException { if (!order.isLessThan(value, limit) && !super.sameValue(value, limit)) throw new DatatypeException(localizer().message(\"max_inclusive_violation\", getDescriptionForRestriction(), limitString)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class MaxLengthRestrictDatatype extends ValueRestrictDatatype { private final int length; private final Measure measure; MaxLengthRestrictDatatype(DatatypeBase base, int length) { super(base); this.measure = base.getMeasure(); this.length = length; } void checkRestriction(Object obj) throws DatatypeException { int actualLength = measure.getLength(obj); if (actualLength > length) throw new DatatypeException(localizer().message(\"max_length_violation\", new Object[] { getDescriptionForRestriction(), length, actualLength })); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; interface Measure { int getLength(Object obj); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class MinExclusiveRestrictDatatype extends ValueRestrictDatatype { private final OrderRelation order; private final Object limit; private final String limitString; MinExclusiveRestrictDatatype(DatatypeBase base, Object limit, String limitString) { super(base); this.order = base.getOrderRelation(); this.limit = limit; this.limitString = limitString; } void checkRestriction(Object value) throws DatatypeException { if (!order.isLessThan(limit, value)) throw new DatatypeException(localizer().message(\"min_exclusive_violation\", getDescriptionForRestriction(), limitString)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class MinInclusiveRestrictDatatype extends ValueRestrictDatatype { private final OrderRelation order; private final Object limit; private final String limitString; MinInclusiveRestrictDatatype(DatatypeBase base, Object limit, String limitString) { super(base); this.order = base.getOrderRelation(); this.limit = limit; this.limitString = limitString; } void checkRestriction(Object value) throws DatatypeException { if (!order.isLessThan(limit, value) && !super.sameValue(value, limit)) throw new DatatypeException(localizer().message(\"min_inclusive_violation\", getDescriptionForRestriction(), limitString)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; class MinLengthRestrictDatatype extends ValueRestrictDatatype { private final int length; private final Measure measure; MinLengthRestrictDatatype(DatatypeBase base, int length) { super(base); this.measure = base.getMeasure(); this.length = length; } void checkRestriction(Object obj) throws DatatypeException { int actualLength = measure.getLength(obj); if (actualLength < length) throw new DatatypeException(localizer().message(\"min_length_violation\", new Object[] { getDescriptionForRestriction(), length, actualLength })); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.xml.util.Naming; class NCNameDatatype extends NameDatatype { public boolean lexicallyAllows(String str) { return Naming.isNcname(str); } String getLexicalSpaceKey() { return \"ncname\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.xml.util.Naming; class NameDatatype extends TokenDatatype { public boolean lexicallyAllows(String str) { return Naming.isName(str); } public int getLength(Object obj) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.xml.util.Naming; class NmtokenDatatype extends TokenDatatype { public boolean lexicallyAllows(String str) { return Naming.isNmtoken(str); } public int getLength(Object obj) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; interface OrderRelation { boolean isLessThan(Object obj1, Object obj2); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.datatype.xsd.regex.Regex; import org.relaxng.datatype.DatatypeException; class PatternRestrictDatatype extends RestrictDatatype { private final Regex pattern; private final String patternString; PatternRestrictDatatype(DatatypeBase base, Regex pattern, String patternString) { super(base); this.pattern = pattern; this.patternString = patternString; } boolean lexicallyAllows(String str) { return pattern.matches(str) && super.lexicallyAllows(str); } void checkLexicallyAllows(String str) throws DatatypeException { super.checkLexicallyAllows(str); if (!pattern.matches(str)) throw new DatatypeException(localizer().message(\"pattern_violation\", getDescriptionForRestriction(), patternString)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; import java.math.BigDecimal; class PrecisionRestrictDatatype extends ValueRestrictDatatype { private final int precision; PrecisionRestrictDatatype(DatatypeBase base, int precision) { super(base); this.precision = precision; } void checkRestriction(Object obj) throws DatatypeException { final int actualPrecision = getPrecision((BigDecimal)obj); if (actualPrecision > precision) { String message; if (precision == 1) message = localizer().message(\"precision_1_violation\", getDescriptionForRestriction(), actualPrecision); else message = localizer().message(\"precision_violation\", new Object[] { getDescriptionForRestriction(), precision, actualPrecision }); throw new DatatypeException(message); } } static int getPrecision(BigDecimal n) { return n.movePointRight(n.scale()).abs().toString().length(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.xml.util.Name; import com.thaiopensource.xml.util.Naming; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; class QNameDatatype extends DatatypeBase { public boolean lexicallyAllows(String str) { return Naming.isQname(str); } String getLexicalSpaceKey() { return \"qname\"; } Object getValue(String str, ValidationContext vc) throws DatatypeException { int i = str.indexOf(':'); if (i < 0) { String ns = vc.resolveNamespacePrefix(\"\"); if (ns == null) ns = \"\"; return new Name(ns, str); } else { String prefix = str.substring(0, i); String ns = vc.resolveNamespacePrefix(prefix); if (ns == null) throw new DatatypeException(localizer().message(\"undeclared_prefix\", prefix)); return new Name(ns, str.substring(i + 1)); } } boolean allowsValue(String str, ValidationContext vc) { int i = str.indexOf(':'); return i < 0 || vc.resolveNamespacePrefix(str.substring(0, i)) != null; } public boolean isContextDependent() { return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.datatype.xsd.regex.Regex; import com.thaiopensource.datatype.xsd.regex.RegexEngine; import com.thaiopensource.datatype.xsd.regex.RegexSyntaxException; class RegexDatatype extends TokenDatatype { private final String pattern; private Regex regex; RegexDatatype(String pattern) { this.pattern = pattern; } synchronized void compile(RegexEngine engine) throws RegexSyntaxException { if (regex == null) regex = engine.compile(pattern); } public boolean lexicallyAllows(String str) { return regex.matches(str); } public boolean alwaysValid() { return false; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; abstract class RestrictDatatype extends DatatypeBase { protected final DatatypeBase base; RestrictDatatype(DatatypeBase base) { this(base, base.getWhiteSpace()); } RestrictDatatype(DatatypeBase base, int whiteSpace) { super(whiteSpace); this.base = base; } boolean lexicallyAllows(String str) { return base.lexicallyAllows(str); } void checkLexicallyAllows(String str) throws DatatypeException { base.checkLexicallyAllows(str); } String getLexicalSpaceKey() { return base.getLexicalSpaceKey(); } OrderRelation getOrderRelation() { return base.getOrderRelation(); } Measure getMeasure() { return base.getMeasure(); } DatatypeBase getPrimitive() { return base.getPrimitive(); } public int getIdType() { return base.getIdType(); } public boolean sameValue(Object value1, Object value2) { return base.sameValue(value1, value2); } public int valueHashCode(Object value) { return base.valueHashCode(value); } Object getValue(String str, ValidationContext vc) throws DatatypeException { return base.getValue(str, vc); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; import java.math.BigDecimal; class ScaleRestrictDatatype extends ValueRestrictDatatype { private final int scale; ScaleRestrictDatatype(DatatypeBase base, int scale) { super(base); this.scale = scale; } void checkRestriction(Object obj) throws DatatypeException { int actualScale = ((BigDecimal)obj).scale(); if (actualScale > scale) { String message; switch (scale) { case 0: message = localizer().message(\"scale_0_violation\"); break; case 1: message = localizer().message(\"scale_1_violation\", actualScale); break; default: message = localizer().message(\"scale_violation\", scale, actualScale); break; } throw new DatatypeException(message); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; class StringDatatype extends TokenDatatype { StringDatatype() { super(WHITE_SPACE_PRESERVE); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import com.thaiopensource.util.Utf16; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; class TokenDatatype extends DatatypeBase implements Measure { TokenDatatype() { } TokenDatatype(int whiteSpace) { super(whiteSpace); } public boolean lexicallyAllows(String str) { return true; } String getLexicalSpaceKey() { return \"string\"; } public boolean alwaysValid() { return true; } Object getValue(String str, ValidationContext vc) throws DatatypeException { return str; } Measure getMeasure() { return this; } public int getLength(Object obj) { String str = (String)obj; int len = str.length(); int nSurrogatePairs = 0; for (int i = 0; i < len; i++) if (Utf16.isSurrogate1(str.charAt(i))) nSurrogatePairs++; return len - nSurrogatePairs; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; abstract class ValueRestrictDatatype extends RestrictDatatype { ValueRestrictDatatype(DatatypeBase base) { super(base); } Object getValue(String str, ValidationContext vc) throws DatatypeException { Object obj = super.getValue(str, vc); checkRestriction(obj); return obj; } abstract void checkRestriction(Object obj) throws DatatypeException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd.regex;  public interface Regex {  boolean matches(String str); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd.regex;  public interface RegexEngine {  Regex compile(String str) throws RegexSyntaxException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd.regex;  public class RegexSyntaxException extends Exception { private final int position;  static public final int UNKNOWN_POSITION = -1; public RegexSyntaxException(String detail) { this(detail, UNKNOWN_POSITION); } public RegexSyntaxException(String detail, int position) { super(detail); this.position = position; }  public int getPosition() { return position; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": ""}
{"name": "dashorst/wicket-stuff-markup-validator", "content": ""}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd.regex.java; import com.thaiopensource.datatype.xsd.regex.Regex; import com.thaiopensource.datatype.xsd.regex.RegexEngine; import com.thaiopensource.datatype.xsd.regex.RegexSyntaxException; import java.util.regex.Pattern;  public class RegexEngineImpl implements RegexEngine { public RegexEngineImpl() { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd.regex.java; import com.thaiopensource.util.Utf16; import java.util.regex.Pattern; class RegexFeatures { static private final int EXAMPLE_NON_BMP_CHAR = 0x10000; static private final String EXAMPLE_SURROGATE_PAIR = new String(new char[] { Utf16.surrogate1(EXAMPLE_NON_BMP_CHAR), Utf16.surrogate2(EXAMPLE_NON_BMP_CHAR) }); static final boolean SURROGATES_DIRECT = Pattern.compile(\"[^x]\").matcher(EXAMPLE_SURROGATE_PAIR).matches(); private RegexFeatures() { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd.regex.java; import com.thaiopensource.datatype.xsd.regex.RegexSyntaxException; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.Utf16; import java.math.BigDecimal; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Vector; /** * Translates XML Schema regexes into <code>java.util.regex</code> regexes. * * @see java.util.regex.Pattern * @see <a href=\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.datatype.xsd.regex.xerces2; import com.thaiopensource.datatype.xsd.regex.RegexEngine; import com.thaiopensource.datatype.xsd.regex.Regex; import com.thaiopensource.datatype.xsd.regex.RegexSyntaxException; import org.apache.xerces.impl.xpath.regex.RegularExpression; import org.apache.xerces.impl.xpath.regex.ParseException;  public class RegexEngineImpl implements RegexEngine { public RegexEngineImpl() { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng; import com.thaiopensource.validate.auto.AutoSchemaReader; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.Flag; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.xml.sax.XMLReaderCreator; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import org.relaxng.datatype.DatatypeLibraryFactory; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import java.io.IOException;  public class SchemaFactory { private PropertyMapBuilder properties = new PropertyMapBuilder(); private boolean compactSyntax = false; private SchemaReader autoSchemaLanguage = new AutoSchemaReader();  public SchemaFactory() { }  public Schema createSchema(InputSource in) throws IOException, SAXException, IncorrectSchemaException { SchemaReader r = compactSyntax ? CompactSchemaReader.getInstance() : autoSchemaLanguage; return r.createSchema(in, properties.toPropertyMap()); }  public void setXMLReaderCreator(XMLReaderCreator xrc) { properties.put(ValidateProperty.XML_READER_CREATOR, xrc); }  public XMLReaderCreator getXMLReaderCreator() { return (XMLReaderCreator)properties.get(ValidateProperty.XML_READER_CREATOR); }  public void setErrorHandler(ErrorHandler eh) { properties.put(ValidateProperty.ERROR_HANDLER, eh); }  public ErrorHandler getErrorHandler() { return (ErrorHandler)properties.get(ValidateProperty.ERROR_HANDLER); }  public void setDatatypeLibraryFactory(DatatypeLibraryFactory dlf) { properties.put(RngProperty.DATATYPE_LIBRARY_FACTORY, dlf); }  public DatatypeLibraryFactory getDatatypeLibraryFactory() { return (DatatypeLibraryFactory)properties.get(RngProperty.DATATYPE_LIBRARY_FACTORY); } /** * Specifies whether to perform checking of ID/IDREF/IDREFS attributes in accordance with * RELAX NG DTD Compatibility. * * @param checkIdIdref <code>true</code> if ID/IDREF/IDREFS checking should be performed; * <code>false</code> otherwise * * @see #getCheckIdIdref * @see <a href=\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.jaxp; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.parse.compact.CompactParseable; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.NameClass; import com.thaiopensource.relaxng.pattern.CommentListImpl; import com.thaiopensource.relaxng.pattern.AnnotationsImpl; import com.thaiopensource.resolver.xml.sax.SAX; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.validation.Constants; import com.thaiopensource.util.VoidValue; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import javax.xml.transform.sax.SAXSource;  public class CompactSyntaxSchemaFactory extends SchemaFactoryImpl {  static final public String SCHEMA_LANGUAGE = Constants.RELAXNG_COMPACT_URI; public boolean isSchemaLanguageSupported(String schemaLanguage) { return schemaLanguage.equals(SCHEMA_LANGUAGE); } protected Parseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> createParseable(SAXSource source, SAXResolver saxResolver, ErrorHandler eh) { return new CompactParseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl>(SAX.createInput(source.getInputSource()), saxResolver.getResolver(), eh); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.jaxp; import com.thaiopensource.datatype.xsd.DatatypeLibraryFactoryImpl; import com.thaiopensource.datatype.xsd.regex.java.RegexEngineImpl; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.pattern.SchemaBuilderImpl; import com.thaiopensource.relaxng.pattern.SchemaPatternBuilder; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.NameClass; import com.thaiopensource.relaxng.pattern.CommentListImpl; import com.thaiopensource.relaxng.pattern.AnnotationsImpl; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.xml.ls.LS; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.validation.Schema2; import com.thaiopensource.validation.SchemaFactory2; import com.thaiopensource.xml.sax.DraconianErrorHandler; import com.thaiopensource.util.VoidValue; import org.relaxng.datatype.DatatypeLibraryFactory; import org.w3c.dom.ls.LSResourceResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.SAXParseException; import org.xml.sax.Locator; import javax.xml.transform.sax.SAXSource; import java.io.IOException;  public abstract class SchemaFactoryImpl extends SchemaFactory2 { private DatatypeLibraryFactory datatypeLibraryFactory = null;  private boolean defaultDatatypeLibraryFactory = true;  static final public String PROPERTY_DATATYPE_LIBRARY_FACTORY = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.jaxp; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.SchemaPatternBuilder; import com.thaiopensource.relaxng.pattern.ValidatorPatternBuilder; import com.thaiopensource.validation.Schema2; import com.thaiopensource.validation.ValidatorHandler2; class SchemaImpl extends Schema2 { private final SchemaFactoryImpl factory; private final SchemaPatternBuilder spb; private final Pattern start; SchemaImpl(SchemaFactoryImpl factory, SchemaPatternBuilder spb, Pattern start) { this.factory = factory; this.spb = spb; this.start = start; } public ValidatorHandler2 newValidatorHandler() { return new ValidatorHandlerImpl(factory, start, new ValidatorPatternBuilder(spb)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.jaxp; import com.thaiopensource.relaxng.match.Matcher; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.PatternMatcher; import com.thaiopensource.relaxng.pattern.ValidatorPatternBuilder; import com.thaiopensource.relaxng.sax.Context; import com.thaiopensource.validation.ValidatorHandler2; import com.thaiopensource.xml.sax.DraconianErrorHandler; import com.thaiopensource.xml.util.Name; import org.w3c.dom.ls.LSResourceResolver; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.SAXParseException; import javax.xml.XMLConstants; import javax.xml.validation.TypeInfoProvider; class ValidatorHandlerImpl extends ValidatorHandler2 { private Matcher matcher; static private final ErrorHandler defaultErrorHandler = new DraconianErrorHandler(); private ErrorHandler specifiedErrorHandler = null; private ErrorHandler actualErrorHandler = defaultErrorHandler; private boolean bufferingCharacters = false; private final StringBuffer charBuf = new StringBuffer(); private Locator locator = null; private final Context context; private ContentHandler contentHandler = null; private DTDHandler dtdHandler; private LSResourceResolver resourceResolver = null; private boolean secureProcessing; ValidatorHandlerImpl(SchemaFactoryImpl factory, Pattern pattern, ValidatorPatternBuilder builder) { matcher = new PatternMatcher(pattern, builder); context = new Context(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.jaxp; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.parse.sax.SAXParseable; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.NameClass; import com.thaiopensource.relaxng.pattern.CommentListImpl; import com.thaiopensource.relaxng.pattern.AnnotationsImpl; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.validation.Constants; import com.thaiopensource.util.VoidValue; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.Locator; import javax.xml.transform.sax.SAXSource;  public class XMLSyntaxSchemaFactory extends SchemaFactoryImpl {  static final public String SCHEMA_LANGUAGE = Constants.RELAXNG_XML_URI; protected Parseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> createParseable(SAXSource source, SAXResolver resolver, ErrorHandler eh) throws SAXException { if (source.getXMLReader() == null) source = new SAXSource(resolver.createXMLReader(), source.getInputSource()); return new SAXParseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl>(source, resolver, eh); } public boolean isSchemaLanguageSupported(String schemaLanguage) { return schemaLanguage.equals(SCHEMA_LANGUAGE); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.match; public class IncorrectSchemaException extends Exception { }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.match; import org.relaxng.datatype.ValidationContext;  public interface MatchContext extends ValidationContext {  String getPrefix(String namespaceURI); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.match;  public interface MatchablePattern {  Matcher createMatcher(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.match; import com.thaiopensource.datatype.DatatypeLibraryLoader; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.parse.compact.CompactParseable; import com.thaiopensource.relaxng.parse.sax.SAXParseable; import com.thaiopensource.relaxng.pattern.AnnotationsImpl; import com.thaiopensource.relaxng.pattern.CommentListImpl; import com.thaiopensource.relaxng.pattern.FeasibleTransform; import com.thaiopensource.relaxng.pattern.MatchablePatternImpl; import com.thaiopensource.relaxng.pattern.NameClass; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.SchemaBuilderImpl; import com.thaiopensource.relaxng.pattern.SchemaPatternBuilder; import com.thaiopensource.resolver.Input; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.VoidValue; import org.relaxng.datatype.DatatypeLibraryFactory; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import java.io.IOException;  public class MatchablePatternLoader { public static final int COMPACT_SYNTAX_FLAG = 0x1; public static final int FEASIBLE_FLAG = 0x2; public MatchablePattern load(Input input, SAXResolver saxResolver, ErrorHandler eh, DatatypeLibraryFactory dlf, int flags) throws IOException, SAXException, IncorrectSchemaException { SchemaPatternBuilder spb = new SchemaPatternBuilder(); Parseable<Pattern, com.thaiopensource.relaxng.pattern.NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> parseable; if ((flags & COMPACT_SYNTAX_FLAG) != 0) parseable = new CompactParseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl>(input, saxResolver.getResolver(), eh); else parseable = new SAXParseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl>(saxResolver.createSAXSource(input), saxResolver, eh); if (dlf == null) dlf = new DatatypeLibraryLoader(); try { Pattern start = SchemaBuilderImpl.parse(parseable, eh, dlf, spb, false); if ((flags & FEASIBLE_FLAG) != 0) start = FeasibleTransform.transform(spb, start); return new MatchablePatternImpl(spb, start); } catch (IllegalSchemaException e) { throw new IncorrectSchemaException(); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.match; import com.thaiopensource.xml.util.Name; import java.util.Set;  public interface Matcher {  Matcher copy();  Matcher start();  boolean equals(Object obj);  int hashCode();  boolean matchStartDocument();  boolean matchEndDocument();  boolean matchStartTagOpen(Name name, String qName, MatchContext context);  boolean matchAttributeName(Name name, String qName, MatchContext context);  boolean matchAttributeValue(String value, Name name, String qName, MatchContext context);  boolean matchStartTagClose(Name name, String qName, MatchContext context);  boolean matchTextBeforeEndTag(String string, Name name, String qName, MatchContext context);  boolean matchTextBeforeStartTag(String string, MatchContext context);  boolean matchUntypedText(MatchContext context);  boolean isTextTyped();  boolean matchEndTag(Name name, String qName, MatchContext context);  String getErrorMessage();  boolean isValidSoFar();  NameClass possibleStartTagNames();  NameClass possibleAttributeNames();  Set<Name> requiredAttributeNames(); Set<Name> requiredElementNames(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.match; import com.thaiopensource.xml.util.Name; import java.util.Set;  public interface NameClass {  boolean isEmpty();  boolean contains(Name name);  boolean isAnyNameIncluded();  Set<String> getExcludedNamespaces();  Set<Name> getExcludedNames();  Set<Name> getIncludedNames();  Set<String> getIncludedNamespaces();  Set<String> getExcludedLocalNames(String ns); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse;  public interface Annotations<L, EA, CL extends CommentList<L>> { void addAttribute(String ns, String localName, String prefix, String value, L loc) throws BuildException; void addElement(EA ea) throws BuildException;  void addComment(CL comments) throws BuildException; void addLeadingComment(CL comments) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; import com.thaiopensource.resolver.ResolverException; import org.xml.sax.SAXException; public class BuildException extends RuntimeException { private final Throwable cause; public BuildException(Throwable cause) { if (cause == null) throw new NullPointerException(\"null cause\"); this.cause = cause; } public Throwable getCause() { return cause; } public static BuildException fromSAXException(SAXException e) { Exception inner = e.getException(); if (inner instanceof BuildException) return (BuildException)inner; return new BuildException(e); } public static BuildException fromResolverException(ResolverException e) { if (e.getMessage() == null) { Throwable t = e.unwrap(); if (t != null) { if (t instanceof BuildException) throw (BuildException)t; throw new BuildException(t); } } throw new BuildException(e); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface CommentList<L> { void addComment(String value, L loc) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; import org.relaxng.datatype.ValidationContext; import java.util.Set; public interface Context extends ValidationContext { Set<String> prefixes(); Context copy(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface DataPatternBuilder<P, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> { void addParam(String name, String value, Context context, String ns, L loc, A anno) throws BuildException; void annotation(EA ea); P makePattern(L loc, A anno) throws BuildException; P makePattern(P except, L loc, A anno) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface Div<P, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends GrammarSection<P, L, EA, CL, A> { void endDiv(L loc, A anno) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface ElementAnnotationBuilder<L, EA, CL extends CommentList<L>> extends Annotations<L, EA, CL> { void addText(String value, L loc, CL comments) throws BuildException; EA makeElementAnnotation() throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface Grammar<P, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends GrammarSection<P, L, EA, CL, A>, Scope<P, L, EA, CL, A> { P endGrammar(L loc, A anno) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface GrammarSection<P, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> { static final class Combine { private final String name; private Combine(String name) { this.name = name; } final public String toString() { return name; } } static final Combine COMBINE_CHOICE = new Combine(\"choice\"); static final Combine COMBINE_INTERLEAVE = new Combine(\"interleave\"); static final String START = \"#start\"; void define(String name, Combine combine, P pattern, L loc, A anno) throws BuildException; void topLevelAnnotation(EA ea) throws BuildException; void topLevelComment(CL comments) throws BuildException; Div<P, L, EA, CL, A> makeDiv();  Include<P, L, EA, CL, A> makeInclude(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public class IllegalSchemaException extends Exception { }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface Include<P, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends GrammarSection<P, L, EA, CL, A> { void endInclude(String href, String base, String ns, L loc, A anno) throws BuildException, IllegalSchemaException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface IncludedGrammar<P, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends GrammarSection<P, L, EA, CL, A>, Scope<P, L, EA, CL, A> { P endIncludedGrammar(L loc, A anno) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; import org.xml.sax.XMLReader; import org.xml.sax.SAXException; public interface ParseReceiver<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends SubParser<P, NC, L, EA, CL, A> { ParsedPatternFuture<P> installHandlers(XMLReader xr, SchemaBuilder<P, NC, L, EA, CL, A> schemaBuilder, Scope<P, L, EA, CL, A> scope) throws SAXException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface Parseable<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends SubParser<P, NC, L, EA, CL, A> { P parse(SchemaBuilder<P, NC, L, EA, CL, A> f, Scope<P, L, EA, CL, A> scope) throws BuildException, IllegalSchemaException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface ParsedPatternFuture<P> { P getParsedPattern() throws IllegalSchemaException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; import java.util.List; public interface SchemaBuilder<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> { P makeChoice(List<P> patterns, L loc, A anno) throws BuildException; P makeInterleave(List<P> patterns, L loc, A anno) throws BuildException; P makeGroup(List<P> patterns, L loc, A anno) throws BuildException; P makeOneOrMore(P p, L loc, A anno) throws BuildException; P makeZeroOrMore(P p, L loc, A anno) throws BuildException; P makeOptional(P p, L loc, A anno) throws BuildException; P makeList(P p, L loc, A anno) throws BuildException; P makeMixed(P p, L loc, A anno) throws BuildException; P makeEmpty(L loc, A anno); P makeNotAllowed(L loc, A anno); P makeText(L loc, A anno); P makeAttribute(NC nc, P p, L loc, A anno) throws BuildException; P makeElement(NC nc, P p, L loc, A anno) throws BuildException; DataPatternBuilder<P, L, EA, CL, A> makeDataPatternBuilder(String datatypeLibrary, String type, L loc) throws BuildException; P makeValue(String datatypeLibrary, String type, String value, Context c, String ns, L loc, A anno) throws BuildException; Grammar<P, L, EA, CL, A> makeGrammar(Scope<P, L, EA, CL, A> parent); P annotatePattern(P p, A anno) throws BuildException; NC annotateNameClass(NC nc, A anno) throws BuildException; P annotateAfterPattern(P p, EA e) throws BuildException; NC annotateAfterNameClass(NC nc, EA e) throws BuildException; P commentAfterPattern(P p, CL comments) throws BuildException; NC commentAfterNameClass(NC nc, CL comments) throws BuildException; P makeExternalRef(String href, String base, String ns, Scope<P, L, EA, CL, A> scope, L loc, A anno) throws BuildException, IllegalSchemaException; NC makeNameClassChoice(List<NC> nameClasses, L loc, A anno); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface Scope<P, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> { P makeParentRef(String name, L loc, A anno) throws BuildException; P makeRef(String name, L loc, A anno) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface SubParseable<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends Parseable<P, NC, L, EA, CL, A> { P parseAsInclude(SchemaBuilder<P, NC, L, EA, CL, A> f, IncludedGrammar<P, L, EA, CL, A> g) throws BuildException, IllegalSchemaException;  String getUri(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse; public interface SubParser<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> { SubParseable<P, NC, L, EA, CL, A> createSubParseable(String href, String base) throws BuildException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.compact; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.CommentList; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.IncludedGrammar; import com.thaiopensource.relaxng.parse.SchemaBuilder; import com.thaiopensource.relaxng.parse.Scope; import com.thaiopensource.relaxng.parse.SubParseable; import com.thaiopensource.resolver.Identifier; import com.thaiopensource.resolver.Input; import com.thaiopensource.resolver.MediaTypedIdentifier; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.ResolverException; import com.thaiopensource.util.Uri; import com.thaiopensource.xml.util.EncodingMap; import org.xml.sax.ErrorHandler; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.PushbackInputStream; import java.io.Reader; public class CompactParseable<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> implements SubParseable<P, NC, L, EA, CL, A> { private final Input in; private final Resolver resolver; private final ErrorHandler eh; private static final String MEDIA_TYPE = \"application/relax-ng-compact-syntax\"; public CompactParseable(Input in, Resolver resolver, ErrorHandler eh) { this.in = in; this.resolver = resolver; this.eh = eh; } public P parse(SchemaBuilder<P, NC, L, EA, CL, A> sb, Scope<P, L, EA, CL, A> scope) throws BuildException, IllegalSchemaException { return new CompactSyntax<P, NC, L, EA, CL, A>(makeReader(in), in.getUri(), sb, eh).parse(scope); } public SubParseable<P, NC, L, EA, CL, A> createSubParseable(String href, String base) throws BuildException { Identifier id = new MediaTypedIdentifier(href, base, MEDIA_TYPE); Input input = new Input(); try { resolver.resolve(id, input); } catch (ResolverException e) { throw BuildException.fromResolverException(e); } catch (IOException e) { throw new BuildException(e); } return new CompactParseable<P, NC, L, EA, CL, A>(input, resolver, eh); } public P parseAsInclude(SchemaBuilder<P, NC, L, EA, CL, A> sb, IncludedGrammar<P, L, EA, CL, A> g) throws BuildException, IllegalSchemaException { return new CompactSyntax<P, NC, L, EA, CL, A>(makeReader(in), in.getUri(), sb, eh).parseInclude(g); } public String getUri() { String uri = in.getUri(); if (uri == null) return null; return Uri.escapeDisallowedChars(uri); } private static final String UTF8 = EncodingMap.getJavaName(\"UTF-8\"); private static final String UTF16 = EncodingMap.getJavaName(\"UTF-16\"); private Reader makeReader(Input in) throws BuildException { try { resolver.open(in); Reader reader = in.getCharacterStream(); if (reader == null) { InputStream byteStream = in.getByteStream(); if (byteStream == null) throw new IllegalArgumentException(\"invalid input for CompactParseable\"); String encoding = in.getEncoding(); if (encoding == null) { PushbackInputStream pb = new PushbackInputStream(byteStream, 2); encoding = detectEncoding(pb); byteStream = pb; } reader = new InputStreamReader(byteStream, encoding); } return reader; } catch (ResolverException e) { throw BuildException.fromResolverException(e); } catch (IOException e) { throw new BuildException(e); } } static private String detectEncoding(PushbackInputStream in) throws IOException { String encoding = UTF8; int b1 = in.read(); if (b1 != -1) { int b2 = in.read(); if (b2 != -1) { in.unread(b2); if ((b1 == 0xFF && b2 == 0xFE) || (b1 == 0xFE && b2 == 0xFF)) encoding = UTF16; } in.unread(b1); } return encoding; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package com.thaiopensource.relaxng.parse.compact; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.CommentList; import com.thaiopensource.relaxng.parse.Context; import com.thaiopensource.relaxng.parse.DataPatternBuilder; import com.thaiopensource.relaxng.parse.Div; import com.thaiopensource.relaxng.parse.ElementAnnotationBuilder; import com.thaiopensource.relaxng.parse.Grammar; import com.thaiopensource.relaxng.parse.GrammarSection; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.Include; import com.thaiopensource.relaxng.parse.IncludedGrammar; import com.thaiopensource.relaxng.parse.SchemaBuilder; import com.thaiopensource.relaxng.parse.Scope; import com.thaiopensource.util.Ref; import com.thaiopensource.xml.util.WellKnownNamespaces; import com.thaiopensource.util.Localizer; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.LocatorImpl; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.io.Reader; public class CompactSyntax<Pattern, NameClass, Location, ElementAnnotation, CommentListImpl extends CommentList<Location>, AnnotationsImpl extends Annotations<Location, ElementAnnotation, CommentListImpl>> implements Context, CompactSyntaxConstants { private static final int IN_ELEMENT = 0; private static final int IN_ATTRIBUTE = 1; private static final int IN_ANY_NAME = 2; private static final int IN_NS_NAME = 4; private String defaultNamespace = SchemaBuilder.INHERIT_NS; private String compatibilityPrefix = null; private SchemaBuilder<Pattern, NameClass, Location, ElementAnnotation, CommentListImpl, AnnotationsImpl> sb; private String sourceUri; private ErrorHandler eh; private final Map<String, String> namespaceMap = new HashMap<String, String>(); private final Map<String, String> datatypesMap = new HashMap<String, String>(); private boolean hadError = false; private static final Localizer localizer = new Localizer(CompactSyntax.class); private final Set<String> attributeNames = new HashSet<String>(); private boolean annotationsIncludeElements = false; final class LocatedString { private final String str; private final Token tok; LocatedString(String str, Token tok) { this.str = str; this.tok = tok; } String getString() { return str; } Location getLocation() { return makeLocation(tok); } Token getToken() { return tok; } } public CompactSyntax(Reader r, String sourceUri, SchemaBuilder<Pattern, NameClass, Location, ElementAnnotation, CommentListImpl, AnnotationsImpl> sb, ErrorHandler eh) { this(r); this.sourceUri = sourceUri; this.sb = sb; this.eh = eh; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package com.thaiopensource.relaxng.parse.compact;  public interface CompactSyntaxConstants {  int EOF = 0;  int NEWLINE = 37;  int NOT_NEWLINE = 38;  int WS = 39;  int DOCUMENTATION = 40;  int DOCUMENTATION_CONTINUE = 41;  int SINGLE_LINE_COMMENT = 42;  int DOCUMENTATION_AFTER_SINGLE_LINE_COMMENT = 43;  int SINGLE_LINE_COMMENT_CONTINUE = 44;  int BASE_CHAR = 45;  int IDEOGRAPHIC = 46;  int LETTER = 47;  int COMBINING_CHAR = 48;  int DIGIT = 49;  int EXTENDER = 50;  int NMSTART = 51;  int NMCHAR = 52;  int NCNAME = 53;  int IDENTIFIER = 54;  int ESCAPED_IDENTIFIER = 55;  int PREFIX_STAR = 56;  int PREFIXED_NAME = 57;  int LITERAL = 58;  int FANNOTATE = 59;  int ILLEGAL_CHAR = 60;  int DEFAULT = 0;  int AFTER_SINGLE_LINE_COMMENT = 1;  int AFTER_DOCUMENTATION = 2;  String[] tokenImage = { \"<EOF>\", \"\\\"[\\\"\", \"\\\"=\\\"\", \"\\\"&=\\\"\", \"\\\"|=\\\"\", \"\\\"start\\\"\", \"\\\"div\\\"\", \"\\\"include\\\"\", \"\\\"~\\\"\", \"\\\"]\\\"\", \"\\\"grammar\\\"\", \"\\\"{\\\"\", \"\\\"}\\\"\", \"\\\"namespace\\\"\", \"\\\"default\\\"\", \"\\\"inherit\\\"\", \"\\\"datatypes\\\"\", \"\\\"empty\\\"\", \"\\\"text\\\"\", \"\\\"notAllowed\\\"\", \"\\\"|\\\"\", \"\\\"&\\\"\", \"\\\",\\\"\", \"\\\"+\\\"\", \"\\\"?\\\"\", \"\\\"*\\\"\", \"\\\"element\\\"\", \"\\\"attribute\\\"\", \"\\\"(\\\"\", \"\\\")\\\"\", \"\\\"-\\\"\", \"\\\"list\\\"\", \"\\\"mixed\\\"\", \"\\\"external\\\"\", \"\\\"parent\\\"\", \"\\\"string\\\"\", \"\\\"token\\\"\", \"<NEWLINE>\", \"<NOT_NEWLINE>\", \"<WS>\", \"<DOCUMENTATION>\", \"<DOCUMENTATION_CONTINUE>\", \"<SINGLE_LINE_COMMENT>\", \"<DOCUMENTATION_AFTER_SINGLE_LINE_COMMENT>\", \"<SINGLE_LINE_COMMENT_CONTINUE>\", \"<BASE_CHAR>\", \"<IDEOGRAPHIC>\", \"<LETTER>\", \"<COMBINING_CHAR>\", \"<DIGIT>\", \"<EXTENDER>\", \"<NMSTART>\", \"<NMCHAR>\", \"<NCNAME>\", \"<IDENTIFIER>\", \"<ESCAPED_IDENTIFIER>\", \"<PREFIX_STAR>\", \"<PREFIXED_NAME>\", \"<LITERAL>\", \"\\\">>\\\"\", \"<ILLEGAL_CHAR>\", }; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package com.thaiopensource.relaxng.parse.compact; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.CommentList; import com.thaiopensource.relaxng.parse.Context; import com.thaiopensource.relaxng.parse.DataPatternBuilder; import com.thaiopensource.relaxng.parse.Div; import com.thaiopensource.relaxng.parse.ElementAnnotationBuilder; import com.thaiopensource.relaxng.parse.Grammar; import com.thaiopensource.relaxng.parse.GrammarSection; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.Include; import com.thaiopensource.relaxng.parse.IncludedGrammar; import com.thaiopensource.relaxng.parse.SchemaBuilder; import com.thaiopensource.relaxng.parse.Scope; import com.thaiopensource.util.Ref; import com.thaiopensource.xml.util.WellKnownNamespaces; import com.thaiopensource.util.Localizer; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.LocatorImpl; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.io.Reader;  public class CompactSyntaxTokenManager implements CompactSyntaxConstants {  public java.io.PrintStream debugStream = System.out;  public void setDebugStream(java.io.PrintStream ds) { debugStream = ds; } private final int jjStopStringLiteralDfa_0(int pos, long active0) { switch (pos) { case 0: if ((active0 & 0x1f8c0fe4e0L) != 0L) { jjmatchedKind = 54; return 43; } if ((active0 & 0x800000000000000L) != 0L) { jjmatchedKind = 60; return -1; } return -1; case 1: if ((active0 & 0x1f8c0fe4e0L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 1; return 43; } if ((active0 & 0x800000000000000L) != 0L) { if (jjmatchedPos == 0) { jjmatchedKind = 60; jjmatchedPos = 0; } return -1; } return -1; case 2: if ((active0 & 0x1f8c0fe4a0L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 2; return 43; } if ((active0 & 0x40L) != 0L) return 43; return -1; case 3: if ((active0 & 0x1f0c0be4a0L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 3; return 43; } if ((active0 & 0x80040000L) != 0L) return 43; return -1; case 4: if ((active0 & 0xe0c09e480L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 4; return 43; } if ((active0 & 0x1100020020L) != 0L) return 43; return -1; case 5: if ((active0 & 0x20c09e480L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 5; return 43; } if ((active0 & 0xc00000000L) != 0L) return 43; return -1; case 6: if ((active0 & 0x208092000L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 6; return 43; } if ((active0 & 0x400c480L) != 0L) return 43; return -1; case 7: if ((active0 & 0x8092000L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 7; return 43; } if ((active0 & 0x200000000L) != 0L) return 43; return -1; case 8: if ((active0 & 0x80000L) != 0L) { jjmatchedKind = 54; jjmatchedPos = 8; return 43; } if ((active0 & 0x8012000L) != 0L) return 43; return -1; default : return -1; } } private final int jjStartNfa_0(int pos, long active0) { return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1); } private int jjStopAtPos(int pos, int kind) { jjmatchedKind = kind; jjmatchedPos = pos; return pos + 1; } private int jjMoveStringLiteralDfa0_0() { switch(curChar) { case 38: jjmatchedKind = 21; return jjMoveStringLiteralDfa1_0(0x8L); case 40: return jjStopAtPos(0, 28); case 41: return jjStopAtPos(0, 29); case 42: return jjStopAtPos(0, 25); case 43: return jjStopAtPos(0, 23); case 44: return jjStopAtPos(0, 22); case 45: return jjStopAtPos(0, 30); case 61: return jjStopAtPos(0, 2); case 62: return jjMoveStringLiteralDfa1_0(0x800000000000000L); case 63: return jjStopAtPos(0, 24); case 91: return jjStopAtPos(0, 1); case 93: return jjStopAtPos(0, 9); case 97: return jjMoveStringLiteralDfa1_0(0x8000000L); case 100: return jjMoveStringLiteralDfa1_0(0x14040L); case 101: return jjMoveStringLiteralDfa1_0(0x204020000L); case 103: return jjMoveStringLiteralDfa1_0(0x400L); case 105: return jjMoveStringLiteralDfa1_0(0x8080L); case 108: return jjMoveStringLiteralDfa1_0(0x80000000L); case 109: return jjMoveStringLiteralDfa1_0(0x100000000L); case 110: return jjMoveStringLiteralDfa1_0(0x82000L); case 112: return jjMoveStringLiteralDfa1_0(0x400000000L); case 115: return jjMoveStringLiteralDfa1_0(0x800000020L); case 116: return jjMoveStringLiteralDfa1_0(0x1000040000L); case 123: return jjStopAtPos(0, 11); case 124: jjmatchedKind = 20; return jjMoveStringLiteralDfa1_0(0x10L); case 125: return jjStopAtPos(0, 12); case 126: return jjStopAtPos(0, 8); default : return jjMoveNfa_0(3, 0); } } private int jjMoveStringLiteralDfa1_0(long active0) { try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(0, active0); return 1; } switch(curChar) { case 61: if ((active0 & 0x8L) != 0L) return jjStopAtPos(1, 3); else if ((active0 & 0x10L) != 0L) return jjStopAtPos(1, 4); break; case 62: if ((active0 & 0x800000000000000L) != 0L) return jjStopAtPos(1, 59); break; case 97: return jjMoveStringLiteralDfa2_0(active0, 0x400012000L); case 101: return jjMoveStringLiteralDfa2_0(active0, 0x44000L); case 105: return jjMoveStringLiteralDfa2_0(active0, 0x180000040L); case 108: return jjMoveStringLiteralDfa2_0(active0, 0x4000000L); case 109: return jjMoveStringLiteralDfa2_0(active0, 0x20000L); case 110: return jjMoveStringLiteralDfa2_0(active0, 0x8080L); case 111: return jjMoveStringLiteralDfa2_0(active0, 0x1000080000L); case 114: return jjMoveStringLiteralDfa2_0(active0, 0x400L); case 116: return jjMoveStringLiteralDfa2_0(active0, 0x808000020L); case 120: return jjMoveStringLiteralDfa2_0(active0, 0x200000000L); default : break; } return jjStartNfa_0(0, active0); } private int jjMoveStringLiteralDfa2_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(0, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(1, active0); return 2; } switch(curChar) { case 97: return jjMoveStringLiteralDfa3_0(active0, 0x420L); case 99: return jjMoveStringLiteralDfa3_0(active0, 0x80L); case 101: return jjMoveStringLiteralDfa3_0(active0, 0x4000000L); case 102: return jjMoveStringLiteralDfa3_0(active0, 0x4000L); case 104: return jjMoveStringLiteralDfa3_0(active0, 0x8000L); case 107: return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L); case 109: return jjMoveStringLiteralDfa3_0(active0, 0x2000L); case 112: return jjMoveStringLiteralDfa3_0(active0, 0x20000L); case 114: return jjMoveStringLiteralDfa3_0(active0, 0xc00000000L); case 115: return jjMoveStringLiteralDfa3_0(active0, 0x80000000L); case 116: return jjMoveStringLiteralDfa3_0(active0, 0x208090000L); case 118: if ((active0 & 0x40L) != 0L) return jjStartNfaWithStates_0(2, 6, 43); break; case 120: return jjMoveStringLiteralDfa3_0(active0, 0x100040000L); default : break; } return jjStartNfa_0(1, active0); } private int jjMoveStringLiteralDfa3_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(1, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(2, active0); return 3; } switch(curChar) { case 65: return jjMoveStringLiteralDfa4_0(active0, 0x80000L); case 97: return jjMoveStringLiteralDfa4_0(active0, 0x14000L); case 101: return jjMoveStringLiteralDfa4_0(active0, 0x170000a000L); case 105: return jjMoveStringLiteralDfa4_0(active0, 0x800000000L); case 108: return jjMoveStringLiteralDfa4_0(active0, 0x80L); case 109: return jjMoveStringLiteralDfa4_0(active0, 0x4000400L); case 114: return jjMoveStringLiteralDfa4_0(active0, 0x8000020L); case 116: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(3, 18, 43); else if ((active0 & 0x80000000L) != 0L) return jjStartNfaWithStates_0(3, 31, 43); return jjMoveStringLiteralDfa4_0(active0, 0x20000L); default : break; } return jjStartNfa_0(2, active0); } private int jjMoveStringLiteralDfa4_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(2, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(3, active0); return 4; } switch(curChar) { case 100: if ((active0 & 0x100000000L) != 0L) return jjStartNfaWithStates_0(4, 32, 43); break; case 101: return jjMoveStringLiteralDfa5_0(active0, 0x4000000L); case 105: return jjMoveStringLiteralDfa5_0(active0, 0x8000000L); case 108: return jjMoveStringLiteralDfa5_0(active0, 0x80000L); case 109: return jjMoveStringLiteralDfa5_0(active0, 0x400L); case 110: if ((active0 & 0x1000000000L) != 0L) return jjStartNfaWithStates_0(4, 36, 43); return jjMoveStringLiteralDfa5_0(active0, 0xc00000000L); case 114: return jjMoveStringLiteralDfa5_0(active0, 0x200008000L); case 115: return jjMoveStringLiteralDfa5_0(active0, 0x2000L); case 116: if ((active0 & 0x20L) != 0L) return jjStartNfaWithStates_0(4, 5, 43); return jjMoveStringLiteralDfa5_0(active0, 0x10000L); case 117: return jjMoveStringLiteralDfa5_0(active0, 0x4080L); case 121: if ((active0 & 0x20000L) != 0L) return jjStartNfaWithStates_0(4, 17, 43); break; default : break; } return jjStartNfa_0(3, active0); } private int jjMoveStringLiteralDfa5_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(3, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(4, active0); return 5; } switch(curChar) { case 97: return jjMoveStringLiteralDfa6_0(active0, 0x400L); case 98: return jjMoveStringLiteralDfa6_0(active0, 0x8000000L); case 100: return jjMoveStringLiteralDfa6_0(active0, 0x80L); case 103: if ((active0 & 0x800000000L) != 0L) return jjStartNfaWithStates_0(5, 35, 43); break; case 105: return jjMoveStringLiteralDfa6_0(active0, 0x8000L); case 108: return jjMoveStringLiteralDfa6_0(active0, 0x84000L); case 110: return jjMoveStringLiteralDfa6_0(active0, 0x204000000L); case 112: return jjMoveStringLiteralDfa6_0(active0, 0x2000L); case 116: if ((active0 & 0x400000000L) != 0L) return jjStartNfaWithStates_0(5, 34, 43); break; case 121: return jjMoveStringLiteralDfa6_0(active0, 0x10000L); default : break; } return jjStartNfa_0(4, active0); } private int jjMoveStringLiteralDfa6_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(4, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(5, active0); return 6; } switch(curChar) { case 97: return jjMoveStringLiteralDfa7_0(active0, 0x200002000L); case 101: if ((active0 & 0x80L) != 0L) return jjStartNfaWithStates_0(6, 7, 43); break; case 111: return jjMoveStringLiteralDfa7_0(active0, 0x80000L); case 112: return jjMoveStringLiteralDfa7_0(active0, 0x10000L); case 114: if ((active0 & 0x400L) != 0L) return jjStartNfaWithStates_0(6, 10, 43); break; case 116: if ((active0 & 0x4000L) != 0L) return jjStartNfaWithStates_0(6, 14, 43); else if ((active0 & 0x8000L) != 0L) return jjStartNfaWithStates_0(6, 15, 43); else if ((active0 & 0x4000000L) != 0L) return jjStartNfaWithStates_0(6, 26, 43); break; case 117: return jjMoveStringLiteralDfa7_0(active0, 0x8000000L); default : break; } return jjStartNfa_0(5, active0); } private int jjMoveStringLiteralDfa7_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(5, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(6, active0); return 7; } switch(curChar) { case 99: return jjMoveStringLiteralDfa8_0(active0, 0x2000L); case 101: return jjMoveStringLiteralDfa8_0(active0, 0x10000L); case 108: if ((active0 & 0x200000000L) != 0L) return jjStartNfaWithStates_0(7, 33, 43); break; case 116: return jjMoveStringLiteralDfa8_0(active0, 0x8000000L); case 119: return jjMoveStringLiteralDfa8_0(active0, 0x80000L); default : break; } return jjStartNfa_0(6, active0); } private int jjMoveStringLiteralDfa8_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(6, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(7, active0); return 8; } switch(curChar) { case 101: if ((active0 & 0x2000L) != 0L) return jjStartNfaWithStates_0(8, 13, 43); else if ((active0 & 0x8000000L) != 0L) return jjStartNfaWithStates_0(8, 27, 43); return jjMoveStringLiteralDfa9_0(active0, 0x80000L); case 115: if ((active0 & 0x10000L) != 0L) return jjStartNfaWithStates_0(8, 16, 43); break; default : break; } return jjStartNfa_0(7, active0); } private int jjMoveStringLiteralDfa9_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(7, old0); try { curChar = input_stream.readChar(); } catch(EOFException e) { jjStopStringLiteralDfa_0(8, active0); return 9; } switch(curChar) { case 100: if ((active0 & 0x80000L) != 0L) return jjStartNfaWithStates_0(9, 19, 43); break; default : break; } return jjStartNfa_0(8, active0); } private int jjStartNfaWithStates_0(int pos, int kind, int state) { jjmatchedKind = kind; jjmatchedPos = pos; try { curChar = input_stream.readChar(); } catch(EOFException e) { return pos + 1; } return jjMoveNfa_0(state, pos + 1); } static final long[] jjbitVec0 = { 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; static final long[] jjbitVec2 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; static final long[] jjbitVec3 = { 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; static final long[] jjbitVec4 = { 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; static final long[] jjbitVec5 = { 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; static final long[] jjbitVec6 = { 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; static final long[] jjbitVec7 = { 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; static final long[] jjbitVec8 = { 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; static final long[] jjbitVec9 = { 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; static final long[] jjbitVec10 = { 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; static final long[] jjbitVec11 = { 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; static final long[] jjbitVec12 = { 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; static final long[] jjbitVec13 = { 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; static final long[] jjbitVec14 = { 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; static final long[] jjbitVec15 = { 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; static final long[] jjbitVec16 = { 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; static final long[] jjbitVec17 = { 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; static final long[] jjbitVec18 = { 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; static final long[] jjbitVec19 = { 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; static final long[] jjbitVec20 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; static final long[] jjbitVec21 = { 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; static final long[] jjbitVec22 = { 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; static final long[] jjbitVec23 = { 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; static final long[] jjbitVec24 = { 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; static final long[] jjbitVec25 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; static final long[] jjbitVec26 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; static final long[] jjbitVec27 = { 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; static final long[] jjbitVec28 = { 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; static final long[] jjbitVec29 = { 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; static final long[] jjbitVec30 = { 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; static final long[] jjbitVec31 = { 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; static final long[] jjbitVec32 = { 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; static final long[] jjbitVec33 = { 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; static final long[] jjbitVec34 = { 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; static final long[] jjbitVec35 = { 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; static final long[] jjbitVec36 = { 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; static final long[] jjbitVec37 = { 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; static final long[] jjbitVec38 = { 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; static final long[] jjbitVec39 = { 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; static final long[] jjbitVec40 = { 0x0L, 0x0L, 0x0L, 0x21fff0000L }; static final long[] jjbitVec41 = { 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; private int jjMoveNfa_0(int startState, int curPos) { int startsAt = 0; jjnewStateCnt = 43; int i = 1; jjstateSet[0] = startState; int kind = 0x7fffffff; for (;;) { if (++jjround == 0x7fffffff) ReInitRounds(); if (curChar < 64) { long l = 1L << curChar; do { switch(jjstateSet[--i]) { case 3: if ((0xfffffffffffff9ffL & l) != 0L) { if (kind > 60) kind = 60; } if ((0x100000601L & l) != 0L) { if (kind > 39) kind = 39; jjCheckNAdd(0); } else if (curChar == 39) jjstateSet[jjnewStateCnt++] = 31; else if (curChar == 34) jjstateSet[jjnewStateCnt++] = 22; else if (curChar == 35) { if (kind > 42) kind = 42; jjCheckNAdd(5); } if (curChar == 39) jjCheckNAddTwoStates(13, 14); else if (curChar == 34) jjCheckNAddTwoStates(10, 11); else if (curChar == 35) jjstateSet[jjnewStateCnt++] = 1; break; case 43: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(39, 40); else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 41; if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(36, 38); else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 37; if ((0x3ff600000000000L & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAdd(35); } break; case 0: if ((0x100000601L & l) == 0L) break; if (kind > 39) kind = 39; jjCheckNAdd(0); break; case 1: if (curChar != 35) break; if (kind > 40) kind = 40; jjCheckNAdd(2); break; case 2: if ((0xfffffffffffffbfeL & l) == 0L) break; if (kind > 40) kind = 40; jjCheckNAdd(2); break; case 4: if (curChar != 35) break; if (kind > 42) kind = 42; jjCheckNAdd(5); break; case 5: if ((0xfffffffffffffbfeL & l) == 0L) break; if (kind > 42) kind = 42; jjCheckNAdd(5); break; case 8: if ((0x3ff600000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjstateSet[jjnewStateCnt++] = 8; break; case 9: if (curChar == 34) jjCheckNAddTwoStates(10, 11); break; case 10: if ((0xfffffffbfffffffeL & l) != 0L) jjCheckNAddTwoStates(10, 11); break; case 11: case 20: if (curChar == 34 && kind > 58) kind = 58; break; case 12: if (curChar == 39) jjCheckNAddTwoStates(13, 14); break; case 13: if ((0xffffff7ffffffffeL & l) != 0L) jjCheckNAddTwoStates(13, 14); break; case 14: case 29: if (curChar == 39 && kind > 58) kind = 58; break; case 15: if (curChar == 34) jjCheckNAddStates(0, 2); break; case 16: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(0, 2); break; case 17: case 19: if (curChar == 34) jjCheckNAdd(16); break; case 18: if (curChar == 34) jjAddStates(3, 4); break; case 21: if (curChar == 34) jjstateSet[jjnewStateCnt++] = 20; break; case 22: if (curChar == 34) jjstateSet[jjnewStateCnt++] = 15; break; case 23: if (curChar == 34) jjstateSet[jjnewStateCnt++] = 22; break; case 24: if (curChar == 39) jjCheckNAddStates(5, 7); break; case 25: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(5, 7); break; case 26: case 28: if (curChar == 39) jjCheckNAdd(25); break; case 27: if (curChar == 39) jjAddStates(8, 9); break; case 30: if (curChar == 39) jjstateSet[jjnewStateCnt++] = 29; break; case 31: if (curChar == 39) jjstateSet[jjnewStateCnt++] = 24; break; case 32: if (curChar == 39) jjstateSet[jjnewStateCnt++] = 31; break; case 33: if ((0xfffffffffffff9ffL & l) != 0L && kind > 60) kind = 60; break; case 35: if ((0x3ff600000000000L & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAdd(35); break; case 36: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(36, 38); break; case 37: if (curChar == 42 && kind > 56) kind = 56; break; case 38: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 37; break; case 39: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(39, 40); break; case 40: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 41; break; case 42: if ((0x3ff600000000000L & l) == 0L) break; if (kind > 57) kind = 57; jjstateSet[jjnewStateCnt++] = 42; break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 3: if (kind > 60) kind = 60; if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAddStates(10, 14); } else if (curChar == 92) jjstateSet[jjnewStateCnt++] = 7; break; case 43: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(39, 40); if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(36, 38); if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAdd(35); } break; case 2: if (kind > 40) kind = 40; jjstateSet[jjnewStateCnt++] = 2; break; case 5: if (kind > 42) kind = 42; jjstateSet[jjnewStateCnt++] = 5; break; case 6: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 7; break; case 7: case 8: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(8); break; case 10: jjAddStates(15, 16); break; case 13: jjAddStates(17, 18); break; case 16: jjAddStates(0, 2); break; case 25: jjAddStates(5, 7); break; case 33: if (kind > 60) kind = 60; break; case 34: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAddStates(10, 14); break; case 35: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAdd(35); break; case 36: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(36, 38); break; case 39: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(39, 40); break; case 41: case 42: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 57) kind = 57; jjCheckNAdd(42); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 3: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) { if (kind > 60) kind = 60; } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 54) kind = 54; jjCheckNAddStates(10, 14); } break; case 43: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) { if (kind > 54) kind = 54; jjCheckNAdd(35); } if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(36, 38); if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(39, 40); break; case 2: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break; if (kind > 40) kind = 40; jjstateSet[jjnewStateCnt++] = 2; break; case 5: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break; if (kind > 42) kind = 42; jjstateSet[jjnewStateCnt++] = 5; break; case 7: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAdd(8); break; case 8: if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAdd(8); break; case 10: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(15, 16); break; case 13: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(17, 18); break; case 16: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(0, 2); break; case 25: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(5, 7); break; case 33: if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 60) kind = 60; break; case 34: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 54) kind = 54; jjCheckNAddStates(10, 14); break; case 35: if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) break; if (kind > 54) kind = 54; jjCheckNAdd(35); break; case 36: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(36, 38); break; case 39: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(39, 40); break; case 41: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 57) kind = 57; jjCheckNAdd(42); break; case 42: if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) break; if (kind > 57) kind = 57; jjCheckNAdd(42); break; default : break; } } while(i != startsAt); } if (kind != 0x7fffffff) { jjmatchedKind = kind; jjmatchedPos = curPos; kind = 0x7fffffff; } ++curPos; if ((i = jjnewStateCnt) == (startsAt = 43 - (jjnewStateCnt = startsAt))) return curPos; try { curChar = input_stream.readChar(); } catch(EOFException e) { return curPos; } } } private int jjMoveStringLiteralDfa0_1() { return jjMoveNfa_1(1, 0); } private int jjMoveNfa_1(int startState, int curPos) { int startsAt = 0; jjnewStateCnt = 10; int i = 1; jjstateSet[0] = startState; int kind = 0x7fffffff; for (;;) { if (++jjround == 0x7fffffff) ReInitRounds(); if (curChar < 64) { long l = 1L << curChar; do { switch(jjstateSet[--i]) { case 1: if ((0xfffffffffffff9ffL & l) != 0L) { if (kind > 60) kind = 60; } if ((0x100000601L & l) != 0L) { if (kind > 39) kind = 39; jjCheckNAdd(0); } if ((0x401L & l) != 0L) jjCheckNAddStates(19, 22); break; case 0: if ((0x100000601L & l) == 0L) break; if (kind > 39) kind = 39; jjCheckNAdd(0); break; case 2: if ((0x401L & l) != 0L) jjCheckNAddStates(19, 22); break; case 3: if ((0x100000200L & l) != 0L) jjCheckNAddTwoStates(3, 6); break; case 4: if (curChar != 35) break; if (kind > 43) kind = 43; jjCheckNAdd(5); break; case 5: if ((0xfffffffffffffbfeL & l) == 0L) break; if (kind > 43) kind = 43; jjCheckNAdd(5); break; case 6: if (curChar == 35) jjstateSet[jjnewStateCnt++] = 4; break; case 7: if ((0x100000200L & l) != 0L) jjCheckNAddTwoStates(7, 8); break; case 8: if (curChar != 35) break; if (kind > 44) kind = 44; jjCheckNAdd(9); break; case 9: if ((0xfffffffffffffbfeL & l) == 0L) break; if (kind > 44) kind = 44; jjCheckNAdd(9); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 1: if (kind > 60) kind = 60; break; case 5: if (kind > 43) kind = 43; jjstateSet[jjnewStateCnt++] = 5; break; case 9: if (kind > 44) kind = 44; jjstateSet[jjnewStateCnt++] = 9; break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 1: if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 60) kind = 60; break; case 5: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break; if (kind > 43) kind = 43; jjstateSet[jjnewStateCnt++] = 5; break; case 9: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break; if (kind > 44) kind = 44; jjstateSet[jjnewStateCnt++] = 9; break; default : break; } } while(i != startsAt); } if (kind != 0x7fffffff) { jjmatchedKind = kind; jjmatchedPos = curPos; kind = 0x7fffffff; } ++curPos; if ((i = jjnewStateCnt) == (startsAt = 10 - (jjnewStateCnt = startsAt))) return curPos; try { curChar = input_stream.readChar(); } catch(EOFException e) { return curPos; } } } private int jjMoveStringLiteralDfa0_2() { return jjMoveNfa_2(1, 0); } private int jjMoveNfa_2(int startState, int curPos) { int startsAt = 0; jjnewStateCnt = 7; int i = 1; jjstateSet[0] = startState; int kind = 0x7fffffff; for (;;) { if (++jjround == 0x7fffffff) ReInitRounds(); if (curChar < 64) { long l = 1L << curChar; do { switch(jjstateSet[--i]) { case 1: if ((0xfffffffffffff9ffL & l) != 0L) { if (kind > 60) kind = 60; } if ((0x100000601L & l) != 0L) { if (kind > 39) kind = 39; jjCheckNAdd(0); } if ((0x401L & l) != 0L) jjCheckNAddTwoStates(2, 5); break; case 0: if ((0x100000601L & l) == 0L) break; if (kind > 39) kind = 39; jjCheckNAdd(0); break; case 2: if ((0x100000200L & l) != 0L) jjCheckNAddTwoStates(2, 5); break; case 3: if (curChar != 35) break; if (kind > 41) kind = 41; jjCheckNAdd(4); break; case 4: if ((0xfffffffffffffbfeL & l) == 0L) break; if (kind > 41) kind = 41; jjCheckNAdd(4); break; case 5: if (curChar == 35) jjstateSet[jjnewStateCnt++] = 3; break; case 6: if ((0xfffffffffffff9ffL & l) != 0L && kind > 60) kind = 60; break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 1: if (kind > 60) kind = 60; break; case 4: if (kind > 41) kind = 41; jjstateSet[jjnewStateCnt++] = 4; break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 1: if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 60) kind = 60; break; case 4: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break; if (kind > 41) kind = 41; jjstateSet[jjnewStateCnt++] = 4; break; default : break; } } while(i != startsAt); } if (kind != 0x7fffffff) { jjmatchedKind = kind; jjmatchedPos = curPos; kind = 0x7fffffff; } ++curPos; if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt))) return curPos; try { curChar = input_stream.readChar(); } catch(EOFException e) { return curPos; } } } static final int[] jjnextStates = { 16, 17, 18, 19, 21, 25, 26, 27, 28, 30, 35, 36, 38, 39, 40, 10, 11, 13, 14, 3, 6, 7, 8, }; private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) { switch(hiByte) { case 0: return ((jjbitVec2[i2] & l2) != 0L); default : if ((jjbitVec0[i1] & l1) != 0L) return true; return false; } } private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2) { switch(hiByte) { case 0: return ((jjbitVec4[i2] & l2) != 0L); case 1: return ((jjbitVec5[i2] & l2) != 0L); case 2: return ((jjbitVec6[i2] & l2) != 0L); case 3: return ((jjbitVec7[i2] & l2) != 0L); case 4: return ((jjbitVec8[i2] & l2) != 0L); case 5: return ((jjbitVec9[i2] & l2) != 0L); case 6: return ((jjbitVec10[i2] & l2) != 0L); case 9: return ((jjbitVec11[i2] & l2) != 0L); case 10: return ((jjbitVec12[i2] & l2) != 0L); case 11: return ((jjbitVec13[i2] & l2) != 0L); case 12: return ((jjbitVec14[i2] & l2) != 0L); case 13: return ((jjbitVec15[i2] & l2) != 0L); case 14: return ((jjbitVec16[i2] & l2) != 0L); case 15: return ((jjbitVec17[i2] & l2) != 0L); case 16: return ((jjbitVec18[i2] & l2) != 0L); case 17: return ((jjbitVec19[i2] & l2) != 0L); case 30: return ((jjbitVec20[i2] & l2) != 0L); case 31: return ((jjbitVec21[i2] & l2) != 0L); case 33: return ((jjbitVec22[i2] & l2) != 0L); case 48: return ((jjbitVec23[i2] & l2) != 0L); case 49: return ((jjbitVec24[i2] & l2) != 0L); case 159: return ((jjbitVec25[i2] & l2) != 0L); case 215: return ((jjbitVec26[i2] & l2) != 0L); default : if ((jjbitVec3[i1] & l1) != 0L) return true; return false; } } private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2) { switch(hiByte) { case 0: return ((jjbitVec27[i2] & l2) != 0L); case 1: return ((jjbitVec5[i2] & l2) != 0L); case 2: return ((jjbitVec28[i2] & l2) != 0L); case 3: return ((jjbitVec29[i2] & l2) != 0L); case 4: return ((jjbitVec30[i2] & l2) != 0L); case 5: return ((jjbitVec31[i2] & l2) != 0L); case 6: return ((jjbitVec32[i2] & l2) != 0L); case 9: return ((jjbitVec33[i2] & l2) != 0L); case 10: return ((jjbitVec34[i2] & l2) != 0L); case 11: return ((jjbitVec35[i2] & l2) != 0L); case 12: return ((jjbitVec36[i2] & l2) != 0L); case 13: return ((jjbitVec37[i2] & l2) != 0L); case 14: return ((jjbitVec38[i2] & l2) != 0L); case 15: return ((jjbitVec39[i2] & l2) != 0L); case 16: return ((jjbitVec18[i2] & l2) != 0L); case 17: return ((jjbitVec19[i2] & l2) != 0L); case 30: return ((jjbitVec20[i2] & l2) != 0L); case 31: return ((jjbitVec21[i2] & l2) != 0L); case 32: return ((jjbitVec40[i2] & l2) != 0L); case 33: return ((jjbitVec22[i2] & l2) != 0L); case 48: return ((jjbitVec41[i2] & l2) != 0L); case 49: return ((jjbitVec24[i2] & l2) != 0L); case 159: return ((jjbitVec25[i2] & l2) != 0L); case 215: return ((jjbitVec26[i2] & l2) != 0L); default : if ((jjbitVec3[i1] & l1) != 0L) return true; return false; } }  public static final String[] jjstrLiteralImages = { \"\", \"\\133\", \"\\75\", \"\\46\\75\", \"\\174\\75\", \"\\163\\164\\141\\162\\164\", \"\\144\\151\\166\", \"\\151\\156\\143\\154\\165\\144\\145\", \"\\176\", \"\\135\", \"\\147\\162\\141\\155\\155\\141\\162\", \"\\173\", \"\\175\", \"\\156\\141\\155\\145\\163\\160\\141\\143\\145\", \"\\144\\145\\146\\141\\165\\154\\164\", \"\\151\\156\\150\\145\\162\\151\\164\", \"\\144\\141\\164\\141\\164\\171\\160\\145\\163\", \"\\145\\155\\160\\164\\171\", \"\\164\\145\\170\\164\", \"\\156\\157\\164\\101\\154\\154\\157\\167\\145\\144\", \"\\174\", \"\\46\", \"\\54\", \"\\53\", \"\\77\", \"\\52\", \"\\145\\154\\145\\155\\145\\156\\164\", \"\\141\\164\\164\\162\\151\\142\\165\\164\\145\", \"\\50\", \"\\51\", \"\\55\", \"\\154\\151\\163\\164\", \"\\155\\151\\170\\145\\144\", \"\\145\\170\\164\\145\\162\\156\\141\\154\", \"\\160\\141\\162\\145\\156\\164\", \"\\163\\164\\162\\151\\156\\147\", \"\\164\\157\\153\\145\\156\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"\\76\\76\", null, };  public static final String[] lexStateNames = { \"DEFAULT\", \"AFTER_SINGLE_LINE_COMMENT\", \"AFTER_DOCUMENTATION\", };  public static final int[] jjnewLexState = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, }; static final long[] jjtoToken = { 0x1fc00b1fffffffffL, }; static final long[] jjtoSkip = { 0x148000000000L, }; static final long[] jjtoSpecial = { 0x140000000000L, }; protected JavaCharStream input_stream; private final int[] jjrounds = new int[43]; private final int[] jjstateSet = new int[86]; private final StringBuffer jjimage = new StringBuffer(); private StringBuffer image = jjimage; private int jjimageLen; private int lengthOfMatch; protected char curChar;  public CompactSyntaxTokenManager(JavaCharStream stream){ if (JavaCharStream.staticFlag) throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\"); input_stream = stream; }  public CompactSyntaxTokenManager(JavaCharStream stream, int lexState){ this(stream); SwitchTo(lexState); }  public void ReInit(JavaCharStream stream) { jjmatchedPos = jjnewStateCnt = 0; curLexState = defaultLexState; input_stream = stream; ReInitRounds(); } private void ReInitRounds() { int i; jjround = 0x80000001; for (i = 43; i-- > 0;) jjrounds[i] = 0x80000000; }  public void ReInit(JavaCharStream stream, int lexState) { ReInit(stream); SwitchTo(lexState); }  public void SwitchTo(int lexState) { if (lexState >= 3 || lexState < 0) throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE); else curLexState = lexState; } protected Token jjFillToken() { final Token t; final String curTokenImage; final int beginLine; final int endLine; final int beginColumn; final int endColumn; String im = jjstrLiteralImages[jjmatchedKind]; curTokenImage = (im == null) ? input_stream.GetImage() : im; beginLine = input_stream.getBeginLine(); beginColumn = input_stream.getBeginColumn(); endLine = input_stream.getEndLine(); endColumn = input_stream.getEndColumn(); t = Token.newToken(jjmatchedKind, curTokenImage); t.beginLine = beginLine; t.endLine = endLine; t.beginColumn = beginColumn; t.endColumn = endColumn; return t; } int curLexState = 0; int defaultLexState = 0; int jjnewStateCnt; int jjround; int jjmatchedPos; int jjmatchedKind;  public Token getNextToken() { Token specialToken = null; Token matchedToken; int curPos = 0; EOFLoop : for (;;) { try { curChar = input_stream.BeginToken(); } catch(EOFException e) { jjmatchedKind = 0; matchedToken = jjFillToken(); matchedToken.specialToken = specialToken; return matchedToken; } image = jjimage; image.setLength(0); jjimageLen = 0; switch(curLexState) { case 0: jjmatchedKind = 0x7fffffff; jjmatchedPos = 0; curPos = jjMoveStringLiteralDfa0_0(); break; case 1: jjmatchedKind = 0x7fffffff; jjmatchedPos = 0; curPos = jjMoveStringLiteralDfa0_1(); break; case 2: jjmatchedKind = 0x7fffffff; jjmatchedPos = 0; curPos = jjMoveStringLiteralDfa0_2(); break; } if (jjmatchedKind != 0x7fffffff) { if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1); if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) { matchedToken = jjFillToken(); matchedToken.specialToken = specialToken; if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind]; return matchedToken; } else { if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) { matchedToken = jjFillToken(); if (specialToken == null) specialToken = matchedToken; else { matchedToken.specialToken = specialToken; specialToken = (specialToken.next = matchedToken); } SkipLexicalActions(matchedToken); } else SkipLexicalActions(null); if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind]; continue EOFLoop; } } int error_line = input_stream.getEndLine(); int error_column = input_stream.getEndColumn(); String error_after = null; boolean EOFSeen = false; try { input_stream.readChar(); input_stream.backup(1); } catch (EOFException e1) { EOFSeen = true; error_after = curPos <= 1 ? \"\" : input_stream.GetImage(); if (curChar == '\\n' || curChar == '\\r') { error_line++; error_column = 0; } else error_column++; } if (!EOFSeen) { input_stream.backup(1); error_after = curPos <= 1 ? \"\" : input_stream.GetImage(); } throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR); } } void SkipLexicalActions(Token matchedToken) { switch(jjmatchedKind) { default : break; } } private void jjCheckNAdd(int state) { if (jjrounds[state] != jjround) { jjstateSet[jjnewStateCnt++] = state; jjrounds[state] = jjround; } } private void jjAddStates(int start, int end) { do { jjstateSet[jjnewStateCnt++] = jjnextStates[start]; } while (start++ != end); } private void jjCheckNAddTwoStates(int state1, int state2) { jjCheckNAdd(state1); jjCheckNAdd(state2); } private void jjCheckNAddStates(int start, int end) { do { jjCheckNAdd(jjnextStates[start]); } while (start++ != end); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.compact; class EOFException extends Exception { }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.compact; class EscapeSyntaxException extends RuntimeException { private final String key; private final int lineNumber; private final int columnNumber; EscapeSyntaxException(String key, int lineNumber, int columnNumber) { this.key = key; this.lineNumber = lineNumber; this.columnNumber = columnNumber; } String getKey() { return key; } int getLineNumber() { return lineNumber; } int getColumnNumber() { return columnNumber; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "  package com.thaiopensource.relaxng.parse.compact; import com.thaiopensource.util.Utf16; import com.thaiopensource.relaxng.parse.BuildException; import java.io.IOException;  public final class JavaCharStream { public static final boolean staticFlag = false; static final int hexval(char c) { switch (c) { case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case 'a': case 'A': return 10; case 'b': case 'B': return 11; case 'c': case 'C': return 12; case 'd': case 'D': return 13; case 'e': case 'E': return 14; case 'f': case 'F': return 15; } return -1; } public int bufpos = -1; int bufsize; int available; int tokenBegin; private int bufline[]; private int bufcolumn[]; private int column = 0; private int line = 1; private java.io.Reader inputStream; private boolean closed = false; private boolean prevCharIsLF = false; private char[] nextCharBuf; private char[] buffer; private int maxNextCharInd = 0; private int nextCharInd = -1; private int inBuf = 0; private int tabSize = 8; protected void setTabSize(int i) { tabSize = i; } protected int getTabSize(int i) { return tabSize; } private final void ExpandBuff(boolean wrapAround) { char[] newbuffer = new char[bufsize + 2048]; int newbufline[] = new int[bufsize + 2048]; int newbufcolumn[] = new int[bufsize + 2048]; if (wrapAround) { System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin); System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos); buffer = newbuffer; System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin); System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos); bufline = newbufline; System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin); System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos); bufcolumn = newbufcolumn; bufpos += (bufsize - tokenBegin); } else { System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin); buffer = newbuffer; System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin); bufline = newbufline; System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin); bufcolumn = newbufcolumn; bufpos -= tokenBegin; } available = (bufsize += 2048); tokenBegin = 0; } private final void FillBuff() throws EOFException { int i; if (maxNextCharInd == 4096) maxNextCharInd = nextCharInd = 0; if (closed) throw new EOFException(); try { if ((i = inputStream.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd)) == -1) { closed = true; inputStream.close(); throw new EOFException(); } else maxNextCharInd += i; } catch (IOException e) { throw new BuildException(e); } } private final char ReadChar() throws EOFException { if (++nextCharInd >= maxNextCharInd) FillBuff(); return nextCharBuf[nextCharInd]; } private final char PeekChar() throws EOFException { char c = ReadChar(); --nextCharInd; return c; } public final char BeginToken() throws EOFException { if (inBuf > 0) { --inBuf; if (++bufpos == bufsize) bufpos = 0; tokenBegin = bufpos; return buffer[bufpos]; } tokenBegin = 0; bufpos = -1; return readChar(); } private final void AdjustBuffSize() { if (available == bufsize) { if (tokenBegin > 2048) { bufpos = 0; available = tokenBegin; } else ExpandBuff(false); } else if (available > tokenBegin) available = bufsize; else if ((tokenBegin - available) < 2048) ExpandBuff(true); else available = tokenBegin; } private final void UpdateLineColumn(char c) { column++; if (prevCharIsLF) { prevCharIsLF = false; line += (column = 1); } switch (c) { case NEWLINE_MARKER: prevCharIsLF = true; break; case '\\t': column--; column += (tabSize - (column % tabSize)); break; default : break; } bufline[bufpos] = line; bufcolumn[bufpos] = column; } private final char NEWLINE_MARKER = '\\u0000'; public final char readChar() throws EOFException { if (inBuf > 0) { --inBuf; if (++bufpos == bufsize) bufpos = 0; return buffer[bufpos]; } char c; try { c = ReadChar(); switch (c) { case '\\r': c = NEWLINE_MARKER; try { if (PeekChar() == '\\n') ReadChar(); } catch (EOFException e) { } break; case '\\n': c = NEWLINE_MARKER; break; case '\\t': break; default: if (c >= 0x20) { if (Utf16.isSurrogate(c)) { if (Utf16.isSurrogate2(c)) throw new EscapeSyntaxException(\"illegal_surrogate_pair\", line, column + 1); if (++bufpos == available) AdjustBuffSize(); buffer[bufpos] = c; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "  package com.thaiopensource.relaxng.parse.compact;  public class ParseException extends Exception {  public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal, String[] tokenImageVal ) { super(\"\"); specialConstructor = true; currentToken = currentTokenVal; expectedTokenSequences = expectedTokenSequencesVal; tokenImage = tokenImageVal; }  public ParseException() { super(); specialConstructor = false; }  public ParseException(String message) { super(message); specialConstructor = false; }  protected boolean specialConstructor;  public Token currentToken;  public int[][] expectedTokenSequences;  public String[] tokenImage;  public String getMessage() { if (!specialConstructor) { return super.getMessage(); } StringBuffer expected = new StringBuffer(); int maxSize = 0; for (int i = 0; i < expectedTokenSequences.length; i++) { if (maxSize < expectedTokenSequences[i].length) { maxSize = expectedTokenSequences[i].length; } for (int j = 0; j < expectedTokenSequences[i].length; j++) { expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' '); } if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) { expected.append(\"...\"); } expected.append(eol).append(\" \"); } String retval = \"Encountered \\\"\"; Token tok = currentToken.next; for (int i = 0; i < maxSize; i++) { if (i != 0) retval += \" \"; if (tok.kind == 0) { retval += tokenImage[0]; break; } retval += \" \" + tokenImage[tok.kind]; retval += \" \\\"\"; retval += add_escapes(tok.image); retval += \" \\\"\"; tok = tok.next; } retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn; retval += \".\" + eol; if (expectedTokenSequences.length == 1) { retval += \"Was expecting:\" + eol + \" \"; } else { retval += \"Was expecting one of:\" + eol + \" \"; } retval += expected.toString(); return retval; }  protected String eol = System.getProperty(\"line.separator\", \"\\n\");  protected String add_escapes(String str) { StringBuffer retval = new StringBuffer(); char ch; for (int i = 0; i < str.length(); i++) { switch (str.charAt(i)) { case 0 : continue; case '\\b': retval.append(\"\\\\b\"); continue; case '\\t': retval.append(\"\\\\t\"); continue; case '\\n': retval.append(\"\\\\n\"); continue; case '\\f': retval.append(\"\\\\f\"); continue; case '\\r': retval.append(\"\\\\r\"); continue; case '\\\"': retval.append(\"\\\\\\\"\"); continue; case '\\'': retval.append(\"\\\\\\'\"); continue; case '\\\\': retval.append(\"\\\\\\\\\"); continue; default: if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) { String s = \"0000\" + Integer.toString(ch, 16); retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length())); } else { retval.append(ch); } continue; } } return retval.toString(); } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "  package com.thaiopensource.relaxng.parse.compact;  public class Token {  public int kind;  public int beginLine;  public int beginColumn;  public int endLine;  public int endColumn;  public String image;  public Token next;  public Token specialToken;  public Object getValue() { return null; }  public Token() {}  public Token(int kind) { this(kind, null); }  public Token(int kind, String image) { this.kind = kind; this.image = image; }  public String toString() { return image; }  public static Token newToken(int ofKind, String image) { switch(ofKind) { default : return new Token(ofKind, image); } } public static Token newToken(int ofKind) { return newToken(ofKind, null); } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "  package com.thaiopensource.relaxng.parse.compact;  public class TokenMgrError extends Error {   static final int LEXICAL_ERROR = 0;  static final int STATIC_LEXER_ERROR = 1;  static final int INVALID_LEXICAL_STATE = 2;  static final int LOOP_DETECTED = 3;  int errorCode;  protected static final String addEscapes(String str) { StringBuffer retval = new StringBuffer(); char ch; for (int i = 0; i < str.length(); i++) { switch (str.charAt(i)) { case 0 : continue; case '\\b': retval.append(\"\\\\b\"); continue; case '\\t': retval.append(\"\\\\t\"); continue; case '\\n': retval.append(\"\\\\n\"); continue; case '\\f': retval.append(\"\\\\f\"); continue; case '\\r': retval.append(\"\\\\r\"); continue; case '\\\"': retval.append(\"\\\\\\\"\"); continue; case '\\'': retval.append(\"\\\\\\'\"); continue; case '\\\\': retval.append(\"\\\\\\\\\"); continue; default: if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) { String s = \"0000\" + Integer.toString(ch, 16); retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length())); } else { retval.append(ch); } continue; } } return retval.toString(); }  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) { return(\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \". Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int)curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\"); }  public String getMessage() { return super.getMessage(); }   public TokenMgrError() { }  public TokenMgrError(String message, int reason) { super(message); errorCode = reason; }  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) { this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason); } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.sax; import org.relaxng.datatype.ValidationContext; import org.xml.sax.DTDHandler; import org.xml.sax.SAXException; import java.util.HashSet; import java.util.Set; public abstract class DtdContext implements DTDHandler, ValidationContext { private final Set<String> notations; private final Set<String> unparsedEntities; public DtdContext() { notations = new HashSet<String>(); unparsedEntities = new HashSet<String>(); } public DtdContext(DtdContext dc) { notations = dc.notations; unparsedEntities = dc.unparsedEntities; } public void notationDecl(String name, String publicId, String systemId) throws SAXException { notations.add(name); } public void unparsedEntityDecl(String name, String publicId, String systemId, String notationName) throws SAXException { unparsedEntities.add(name); } public boolean isNotation(String notationName) { return notations.contains(notationName); } public boolean isUnparsedEntity(String entityName) { return unparsedEntities.contains(entityName); } public void clearDtdContext() { notations.clear(); unparsedEntities.clear(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.sax; import com.thaiopensource.relaxng.parse.ParseReceiver; import com.thaiopensource.relaxng.parse.ParsedPatternFuture; import com.thaiopensource.relaxng.parse.SchemaBuilder; import com.thaiopensource.relaxng.parse.Scope; import com.thaiopensource.relaxng.parse.CommentList; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.resolver.xml.sax.SAXResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; public class SAXParseReceiver<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends SAXSubParser<P, NC, L, EA, CL, A> implements ParseReceiver<P, NC, L, EA, CL, A> { public SAXParseReceiver(SAXResolver resolver, ErrorHandler eh) { super(resolver, eh); } public ParsedPatternFuture<P> installHandlers(XMLReader xr, SchemaBuilder<P, NC, L, EA, CL, A> schemaBuilder, Scope<P, L, EA, CL, A> scope) throws SAXException { return new SchemaParser<P, NC, L, EA, CL, A>(xr, eh, schemaBuilder, null, scope); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.sax; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.CommentList; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.IncludedGrammar; import com.thaiopensource.relaxng.parse.SchemaBuilder; import com.thaiopensource.relaxng.parse.Scope; import com.thaiopensource.relaxng.parse.SubParseable; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.Uri; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.sax.SAXSource; import java.io.IOException; public class SAXParseable<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> extends SAXSubParser<P, NC, L, EA, CL, A> implements SubParseable<P, NC, L, EA, CL, A> { private final SAXSource source;  public SAXParseable(SAXSource source, SAXResolver resolver, ErrorHandler eh) { super(resolver, eh); this.source = source; } public P parse(SchemaBuilder<P, NC, L, EA, CL, A> schemaBuilder, Scope<P, L, EA, CL, A> scope) throws BuildException, IllegalSchemaException { try { XMLReader xr = source.getXMLReader(); SchemaParser<P, NC, L, EA, CL, A> sp = new SchemaParser<P, NC, L, EA, CL, A>(xr, eh, schemaBuilder, null, scope); xr.parse(source.getInputSource()); return sp.getParsedPattern(); } catch (SAXException e) { throw BuildException.fromSAXException(e); } catch (IOException e) { throw new BuildException(e); } } public P parseAsInclude(SchemaBuilder<P, NC, L, EA, CL, A> schemaBuilder, IncludedGrammar<P, L, EA, CL, A> g) throws BuildException, IllegalSchemaException { try { XMLReader xr = source.getXMLReader(); SchemaParser<P, NC, L, EA, CL, A> sp = new SchemaParser<P, NC, L, EA, CL, A>(xr, eh, schemaBuilder, g, g); xr.parse(source.getInputSource()); return sp.getParsedPattern(); } catch (SAXException e) { throw BuildException.fromSAXException(e); } catch (IOException e) { throw new BuildException(e); } } public String getUri() { final String uri = source.getInputSource().getSystemId(); if (uri == null) return null; return Uri.escapeDisallowedChars(uri); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.sax; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.CommentList; import com.thaiopensource.relaxng.parse.SubParseable; import com.thaiopensource.relaxng.parse.SubParser; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import java.io.IOException; public class SAXSubParser<P, NC, L, EA, CL extends CommentList<L>, A extends Annotations<L, EA, CL>> implements SubParser<P, NC, L, EA, CL, A> { final SAXResolver resolver; final ErrorHandler eh; SAXSubParser(SAXResolver resolver, ErrorHandler eh) { this.resolver = resolver; this.eh = eh; } public SubParseable<P, NC, L, EA, CL, A> createSubParseable(String href, String base) throws BuildException { try { return new SAXParseable<P, NC, L, EA, CL, A>(resolver.resolve(href, base, WellKnownNamespaces.RELAX_NG), resolver, eh); } catch (SAXException e) { throw BuildException.fromSAXException(e); } catch (IOException e) { throw new BuildException(e); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.parse.sax; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.relaxng.parse.CommentList; import com.thaiopensource.relaxng.parse.Context; import com.thaiopensource.relaxng.parse.DataPatternBuilder; import com.thaiopensource.relaxng.parse.Div; import com.thaiopensource.relaxng.parse.ElementAnnotationBuilder; import com.thaiopensource.relaxng.parse.Grammar; import com.thaiopensource.relaxng.parse.GrammarSection; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.Include; import com.thaiopensource.relaxng.parse.IncludedGrammar; import com.thaiopensource.relaxng.parse.ParsedPatternFuture; import com.thaiopensource.relaxng.parse.SchemaBuilder; import com.thaiopensource.relaxng.parse.Scope; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.Uri; import com.thaiopensource.xml.sax.AbstractLexicalHandler; import com.thaiopensource.xml.sax.XmlBaseHandler; import com.thaiopensource.xml.util.Naming; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.DefaultHandler; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class SchemaParser<Pattern, NameClass, Location, ElementAnnotation, CommentListImpl extends CommentList<Location>, AnnotationsImpl extends Annotations<Location, ElementAnnotation, CommentListImpl>> implements ParsedPatternFuture<Pattern> { private static final String relaxngURIPrefix = WellKnownNamespaces.RELAX_NG.substring(0, WellKnownNamespaces.RELAX_NG.lastIndexOf('/') + 1); static final String relaxng10URI = WellKnownNamespaces.RELAX_NG; private static final Localizer localizer = new Localizer(SchemaParser.class); private String relaxngURI; private final XMLReader xr; private final ErrorHandler eh; private final SchemaBuilder<Pattern, NameClass, Location, ElementAnnotation, CommentListImpl, AnnotationsImpl> schemaBuilder; private Pattern startPattern; private Locator locator; private final XmlBaseHandler xmlBaseHandler = new XmlBaseHandler(); private final ContextImpl context = new ContextImpl(); private boolean hadError = false; private Map<String, State> patternMap; private Map<String, State> nameClassMap; static class PrefixMapping { final String prefix; final String uri; final PrefixMapping next; PrefixMapping(String prefix, String uri, PrefixMapping next) { this.prefix = prefix; this.uri = uri; this.next = next; } } static abstract class AbstractContext extends DtdContext implements Context { PrefixMapping prefixMapping; AbstractContext() { prefixMapping = new PrefixMapping(\"xml\", WellKnownNamespaces.XML, null); } AbstractContext(AbstractContext context) { super(context); prefixMapping = context.prefixMapping; } public String resolveNamespacePrefix(String prefix) { for (PrefixMapping p = prefixMapping; p != null; p = p.next) if (p.prefix.equals(prefix)) return p.uri; return null; } public Set<String> prefixes() { Set<String> set = new HashSet<String>(); for (PrefixMapping p = prefixMapping; p != null; p = p.next) set.add(p.prefix); return set; } public Context copy() { return new SavedContext(this); } } static class SavedContext extends AbstractContext { private final String baseUri; SavedContext(AbstractContext context) { super(context); this.baseUri = context.getBaseUri(); } public String getBaseUri() { return baseUri; } } class ContextImpl extends AbstractContext { public String getBaseUri() { return xmlBaseHandler.getBaseUri(); } } static interface CommentHandler { void comment(String value); } abstract class Handler implements ContentHandler, CommentHandler { CommentListImpl comments; CommentListImpl getComments() { CommentListImpl tem = comments; comments = null; return tem; } public void comment(String value) { if (comments == null) comments = schemaBuilder.makeCommentList(); comments.addComment(value, makeLocation()); } public void processingInstruction(String target, String date) { } public void skippedEntity(String name) { } public void ignorableWhitespace(char[] ch, int start, int len) { } public void startDocument() { } public void endDocument() { } public void startPrefixMapping(String prefix, String uri) { context.prefixMapping = new PrefixMapping(prefix, uri, context.prefixMapping); } public void endPrefixMapping(String prefix) { context.prefixMapping = context.prefixMapping.next; } public void setDocumentLocator(Locator loc) { locator = loc; xmlBaseHandler.setLocator(loc); } } abstract class State extends Handler { State parent; String nsInherit; String ns; String datatypeLibrary; Scope<Pattern, Location, ElementAnnotation, CommentListImpl, AnnotationsImpl> scope; Location startLocation; AnnotationsImpl annotations; void set() { xr.setContentHandler(this); } abstract State create(); abstract State createChildState(String localName) throws SAXException; RootState toRootState() { return null; } NameClassChoiceState toNameClassChoiceState() { return null; } void setParent(State parent) { this.parent = parent; this.nsInherit = parent.getNs(); this.datatypeLibrary = parent.datatypeLibrary; this.scope = parent.scope; this.startLocation = makeLocation(); if (parent.comments != null) { annotations = schemaBuilder.makeAnnotations(parent.comments, getContext()); parent.comments = null; } else if (parent.toRootState() != null) annotations = schemaBuilder.makeAnnotations(null, getContext()); } String getNs() { return ns == null ? nsInherit : ns; } boolean isRelaxNGElement(String uri) throws SAXException { return uri.equals(relaxngURI); } public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException { xmlBaseHandler.startElement(); if (isRelaxNGElement(namespaceURI)) { State state = createChildState(localName); if (state == null) { xr.setContentHandler(new Skipper(this)); return; } state.setParent(this); state.set(); state.attributes(atts); } else { checkForeignElement(); ForeignElementHandler feh = new ForeignElementHandler(this, getComments()); feh.startElement(namespaceURI, localName, qName, atts); xr.setContentHandler(feh); } } public void endElement(String namespaceURI, String localName, String qName) throws SAXException { xmlBaseHandler.endElement(); parent.set(); end(); } void setName(String name) throws SAXException { error(\"illegal_name_attribute\"); } void setOtherAttribute(String name, String value) throws SAXException { error(\"illegal_attribute_ignored\", name); } void endAttributes() throws SAXException { } void checkForeignElement() throws SAXException { } void attributes(Attributes atts) throws SAXException { int len = atts.getLength(); for (int i = 0; i < len; i++) { String uri = atts.getURI(i); if (uri.length() == 0) { String name = atts.getLocalName(i); if (name.equals(\"name\")) setName(atts.getValue(i).trim()); else if (name.equals(\"ns\")) ns = atts.getValue(i); else if (name.equals(\"datatypeLibrary\")) { datatypeLibrary = atts.getValue(i); checkUri(datatypeLibrary); if (!datatypeLibrary.equals(\"\") && !Uri.isAbsolute(datatypeLibrary)) error(\"relative_datatype_library\"); if (Uri.hasFragmentId(datatypeLibrary)) error(\"fragment_identifier_datatype_library\"); datatypeLibrary = Uri.escapeDisallowedChars(datatypeLibrary); } else setOtherAttribute(name, atts.getValue(i)); } else if (uri.equals(relaxngURI)) error(\"qualified_attribute\", atts.getLocalName(i)); else if (uri.equals(WellKnownNamespaces.XML) && atts.getLocalName(i).equals(\"base\")) xmlBaseHandler.xmlBaseAttribute(atts.getValue(i)); else { if (annotations == null) annotations = schemaBuilder.makeAnnotations(null, getContext()); annotations.addAttribute(uri, atts.getLocalName(i), findPrefix(atts.getQName(i), uri), atts.getValue(i), startLocation); } } endAttributes(); } abstract void end() throws SAXException; void endPatternChild(Pattern pattern) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set;  public abstract class AbstractNameClassNormalizer { private static final String IMPOSSIBLE = \"\\u0000\"; protected abstract boolean contains(Name name); protected abstract void accept(NameClassVisitor visitor); public NormalizedNameClass normalize() { final List<Name> mentionedNames = new ArrayList<Name>(); final List<String> mentionedNamespaces = new ArrayList<String>(); accept(new NameClassVisitor() { public void visitChoice(NameClass nc1, NameClass nc2) { nc1.accept(this); nc2.accept(this); } public void visitNsName(String ns) { mentionedNamespaces.add(ns); } public void visitNsNameExcept(String ns, NameClass nc) { mentionedNamespaces.add(ns); nc.accept(this); } public void visitAnyName() { } public void visitAnyNameExcept(NameClass nc) { nc.accept(this); } public void visitName(Name name) { mentionedNames.add(name); } public void visitNull() { } public void visitError() { } }); if (contains(new Name(IMPOSSIBLE, IMPOSSIBLE))) { Set<Name> includedNames = new HashSet<Name>(); Set<String> excludedNamespaces = new HashSet<String>(); Set<Name> excludedNames = new HashSet<Name>(); for (String ns : mentionedNamespaces) { if (!contains(new Name(ns, IMPOSSIBLE))) excludedNamespaces.add(ns); } for (Name name : mentionedNames) { boolean in = contains(name); if (excludedNamespaces.contains(name.getNamespaceUri())) { if (in) includedNames.add(name); } else if (!in) excludedNames.add(name); } return new NormalizedAnyNameClass(includedNames, excludedNamespaces, excludedNames); } Map<String, HashSet<String>> nsMap = new HashMap<String, HashSet<String>>(); for (String ns : mentionedNamespaces) { if (contains(new Name(ns, IMPOSSIBLE)) && nsMap.get(ns) == null) nsMap.put(ns, new HashSet<String>()); } Set<Name> includedNames = new HashSet<Name>(); for (Name name : mentionedNames) { boolean in = contains(name); Set<String> excluded = nsMap.get(name.getNamespaceUri()); if (excluded == null) { if (in) includedNames.add(name); } else if (!in) excluded.add(name.getLocalName()); } return new NormalizedNsNameClass(includedNames, nsMap); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; abstract class AbstractPatternFunction<T> implements PatternFunction<T> { public T caseEmpty(EmptyPattern p) { return caseOther(p); } public T caseNotAllowed(NotAllowedPattern p) { return caseOther(p); } public T caseError(ErrorPattern p) { return caseOther(p); } public T caseGroup(GroupPattern p) { return caseOther(p); } public T caseInterleave(InterleavePattern p) { return caseOther(p); } public T caseChoice(ChoicePattern p) { return caseOther(p); } public T caseOneOrMore(OneOrMorePattern p) { return caseOther(p); } public T caseElement(ElementPattern p) { return caseOther(p); } public T caseAttribute(AttributePattern p) { return caseOther(p); } public T caseData(DataPattern p) { return caseOther(p); } public T caseDataExcept(DataExceptPattern p) { return caseOther(p); } public T caseValue(ValuePattern p) { return caseOther(p); } public T caseText(TextPattern p) { return caseOther(p); } public T caseList(ListPattern p) { return caseOther(p); } public T caseAfter(AfterPattern p) { return caseOther(p); } public T caseRef(RefPattern p) { return caseOther(p); } public abstract T caseOther(Pattern p); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class AfterPattern extends BinaryPattern { AfterPattern(Pattern p1, Pattern p2) { super(false, combineHashCode(AFTER_HASH_CODE, p1.hashCode(), p2.hashCode()), p1, p2); } boolean isNotAllowed() { return p1.isNotAllowed(); } <T> T apply(PatternFunction<T> f) { return f.caseAfter(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class Alphabet { private NameClass nameClass; boolean isEmpty() { return nameClass == null; } void addElement(NameClass nc) { if (nameClass == null) nameClass = nc; else if (nc != null) nameClass = new ChoiceNameClass(nameClass, nc); } void addAlphabet(Alphabet a) { addElement(a.nameClass); } void checkOverlap(Alphabet a) throws RestrictionViolationException { if (nameClass != null && a.nameClass != null) OverlapDetector.checkOverlap(nameClass, a.nameClass, \"interleave_element_overlap_name\", \"interleave_element_overlap_ns\", \"interleave_element_overlap\"); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.relaxng.parse.Annotations; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.util.VoidValue; import org.xml.sax.Locator; public abstract class AnnotationsImpl extends CommentListImpl implements Annotations<Locator, VoidValue, CommentListImpl> { public void addAttribute(String ns, String localName, String prefix, String value, Locator loc) throws BuildException { } public void addElement(VoidValue voidValue) throws BuildException { } public void addComment(CommentListImpl comments) throws BuildException { } public void addLeadingComment(CommentListImpl comments) throws BuildException { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class AnyNameClass implements NameClass { public boolean contains(Name name) { return true; } public int containsSpecificity(Name name) { return SPECIFICITY_ANY_NAME; } public boolean equals(Object obj) { return obj != null && obj instanceof AnyNameClass; } public int hashCode() { return AnyNameClass.class.hashCode(); } public void accept(NameClassVisitor visitor) { visitor.visitAnyName(); } public boolean isOpen() { return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class AnyNameExceptNameClass implements NameClass { private final NameClass nameClass; AnyNameExceptNameClass(NameClass nameClass) { this.nameClass = nameClass; } public boolean contains(Name name) { return !nameClass.contains(name); } public int containsSpecificity(Name name) { return contains(name) ? SPECIFICITY_ANY_NAME : SPECIFICITY_NONE; } public boolean equals(Object obj) { if (obj == null || !(obj instanceof AnyNameExceptNameClass)) return false; return nameClass.equals(((AnyNameExceptNameClass)obj).nameClass); } public int hashCode() { return ~nameClass.hashCode(); } public void accept(NameClassVisitor visitor) { visitor.visitAnyNameExcept(nameClass); } public boolean isOpen() { return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; abstract class ApplyAfterFunction extends AbstractPatternFunction<Pattern> { private final ValidatorPatternBuilder builder; ApplyAfterFunction(ValidatorPatternBuilder builder) { this.builder = builder; } public Pattern caseAfter(AfterPattern p) { return builder.makeAfter(p.getOperand1(), apply(p.getOperand2())); } public Pattern caseChoice(ChoicePattern p) { return builder.makeChoice(p.getOperand1().apply(this), p.getOperand2().apply(this)); } public Pattern caseNotAllowed(NotAllowedPattern p) { return p; } public Pattern caseOther(Pattern p) { throw new AssertionError(\"ApplyAfterFunction applied to \" + p.getClass().getName()); } abstract Pattern apply(Pattern p); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.WellKnownNamespaces; import com.thaiopensource.xml.util.Name; class AttributeNameClassChecker implements NameClassVisitor { private String errorMessageId = null; public void visitChoice(NameClass nc1, NameClass nc2) { nc1.accept(this); nc2.accept(this); } public void visitNsName(String ns) { if (ns.equals(WellKnownNamespaces.XMLNS)) errorMessageId = \"xmlns_uri_attribute\"; } public void visitNsNameExcept(String ns, NameClass nc) { visitNsName(ns); nc.accept(this); } public void visitAnyName() { } public void visitAnyNameExcept(NameClass nc) { nc.accept(this); } public void visitName(Name name) { visitNsName(name.getNamespaceUri()); if (name.equals(new Name(\"\", \"xmlns\"))) errorMessageId = \"xmlns_attribute\"; } public void visitNull() { } public void visitError() { } String checkNameClass(NameClass nc) { errorMessageId = null; nc.accept(this); return errorMessageId; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.Locator; import org.xml.sax.SAXException; class AttributePattern extends Pattern { private final NameClass nameClass; private final Pattern p; private final Locator loc; AttributePattern(NameClass nameClass, Pattern value, Locator loc) { super(false, EMPTY_CONTENT_TYPE, combineHashCode(ATTRIBUTE_HASH_CODE, nameClass.hashCode(), value.hashCode())); this.nameClass = nameClass; this.p = value; this.loc = loc; } Pattern expand(SchemaPatternBuilder b) { Pattern ep = p.expand(b); if (ep != p) return b.makeAttribute(nameClass, ep, loc); else return this; } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_attribute\"); case ELEMENT_CONTEXT: if (nameClass.isOpen()) throw new RestrictionViolationException(\"open_name_class_not_repeated\"); break; case ELEMENT_REPEAT_GROUP_CONTEXT: throw new RestrictionViolationException(\"one_or_more_contains_group_contains_attribute\"); case ELEMENT_REPEAT_INTERLEAVE_CONTEXT: throw new RestrictionViolationException(\"one_or_more_contains_interleave_contains_attribute\"); case LIST_CONTEXT: throw new RestrictionViolationException(\"list_contains_attribute\"); case ATTRIBUTE_CONTEXT: throw new RestrictionViolationException(\"attribute_contains_attribute\"); case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_attribute\"); } dad.addAttribute(nameClass); try { p.checkRestrictions(ATTRIBUTE_CONTEXT, null, null); } catch (RestrictionViolationException e) { e.maybeSetLocator(loc); throw e; } } boolean samePattern(Pattern other) { if (!(other instanceof AttributePattern)) return false; AttributePattern ap = (AttributePattern)other; return nameClass.equals(ap.nameClass)&& p == ap.p; } void checkRecursion(int depth) throws SAXException { p.checkRecursion(depth); } <T> T apply(PatternFunction<T> f) { return f.caseAttribute(this); } Pattern getContent() { return p; } NameClass getNameClass() { return nameClass; } Locator getLocator() { return loc; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.SAXException; abstract class BinaryPattern extends Pattern { final Pattern p1; final Pattern p2; BinaryPattern(boolean nullable, int hc, Pattern p1, Pattern p2) { super(nullable, Math.max(p1.getContentType(), p2.getContentType()), hc); this.p1 = p1; this.p2 = p2; } void checkRecursion(int depth) throws SAXException { p1.checkRecursion(depth); p2.checkRecursion(depth); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { p1.checkRestrictions(context, dad, alpha); p2.checkRestrictions(context, dad, alpha); } boolean samePattern(Pattern other) { if (getClass() != other.getClass()) return false; BinaryPattern b = (BinaryPattern)other; return p1 == b.p1 && p2 == b.p2; } Pattern getOperand1() { return p1; } Pattern getOperand2() { return p2; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.ValidationContext; import java.util.List; class BlankDataDerivType extends DataDerivType { private PatternMemo blankMemo; private PatternMemo nonBlankMemo; BlankDataDerivType() { } PatternMemo dataDeriv(ValidatorPatternBuilder builder, Pattern p, String str, ValidationContext vc, List<DataDerivFailure> fail) { if (DataDerivFunction.isBlank(str)) { if (blankMemo == null || (fail != null && blankMemo.isNotAllowed())) blankMemo = super.dataDeriv(builder, p, str, vc, fail); return blankMemo; } else { if (nonBlankMemo == null || (fail != null && nonBlankMemo.isNotAllowed())) nonBlankMemo = super.dataDeriv(builder, p, str, vc, fail); return nonBlankMemo; } } DataDerivType copy() { return new BlankDataDerivType(); } DataDerivType combine(DataDerivType ddt) { if (ddt instanceof BlankDataDerivType || ddt instanceof SingleDataDerivType) return this; return InconsistentDataDerivType.getInstance(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; class BuiltinDatatypeBuilder implements DatatypeBuilder { private final Datatype dt; BuiltinDatatypeBuilder(Datatype dt) { this.dt = dt; } public void addParameter(String name, String value, ValidationContext context) throws DatatypeException { throw new DatatypeException(SchemaBuilderImpl.localizer.message(\"builtin_param\")); } public Datatype createDatatype() { return dt; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeLibrary; public class BuiltinDatatypeLibrary implements DatatypeLibrary { private final DatatypeBuilder tokenDatatypeBuilder = new BuiltinDatatypeBuilder(new TokenDatatype()); private final DatatypeBuilder stringDatatypeBuilder = new BuiltinDatatypeBuilder(new StringDatatype()); public DatatypeBuilder createDatatypeBuilder(String type) throws DatatypeException { if (type.equals(\"token\")) return tokenDatatypeBuilder; else if (type.equals(\"string\")) return stringDatatypeBuilder; throw new DatatypeException(); } public Datatype createDatatype(String type) throws DatatypeException { return createDatatypeBuilder(type).createDatatype(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory; import java.util.HashMap; import java.util.Map; class BuiltinDatatypeLibraryFactory implements DatatypeLibraryFactory { private final Map<String, DatatypeLibrary> cache = new HashMap<String, DatatypeLibrary>(); private final DatatypeLibraryFactory factory; private final DatatypeLibrary builtinDatatypeLibrary = new BuiltinDatatypeLibrary(); private DatatypeLibrary lastDatatypeLibrary = null; private String lastDatatypeLibraryUri = null; BuiltinDatatypeLibraryFactory(DatatypeLibraryFactory factory) { this.factory = factory; cache.put(WellKnownNamespaces.RELAX_NG_COMPATIBILITY_DATATYPES, new CompatibilityDatatypeLibrary(this)); } public DatatypeLibrary createDatatypeLibrary(String uri) { if (uri.equals(\"\")) return builtinDatatypeLibrary; if (uri.equals(lastDatatypeLibraryUri)) return lastDatatypeLibrary; DatatypeLibrary library = cache.get(uri); if (library == null) { if (factory == null) return null; library = factory.createDatatypeLibrary(uri); if (library == null) return null; cache.put(uri, library); } lastDatatypeLibraryUri = uri; return lastDatatypeLibrary = library; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class ChoiceNameClass implements NameClass { private final NameClass nameClass1; private final NameClass nameClass2; ChoiceNameClass(NameClass nameClass1, NameClass nameClass2) { this.nameClass1 = nameClass1; this.nameClass2 = nameClass2; } public boolean contains(Name name) { return (nameClass1.contains(name) || nameClass2.contains(name)); } public int containsSpecificity(Name name) { return Math.max(nameClass1.containsSpecificity(name), nameClass2.containsSpecificity(name)); } public int hashCode() { return nameClass1.hashCode() ^ nameClass2.hashCode(); } public boolean equals(Object obj) { if (obj == null || !(obj instanceof ChoiceNameClass)) return false; ChoiceNameClass other = (ChoiceNameClass)obj; return (nameClass1.equals(other.nameClass1) && nameClass2.equals(other.nameClass2)); } public void accept(NameClassVisitor visitor) { visitor.visitChoice(nameClass1, nameClass2); } public boolean isOpen() { return nameClass1.isOpen() || nameClass2.isOpen(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class ChoicePattern extends BinaryPattern { ChoicePattern(Pattern p1, Pattern p2) { super(p1.isNullable() || p2.isNullable(), combineHashCode(CHOICE_HASH_CODE, p1.hashCode(), p2.hashCode()), p1, p2); } Pattern expand(SchemaPatternBuilder b) { Pattern ep1 = p1.expand(b); Pattern ep2 = p2.expand(b); if (ep1 != p1 || ep2 != p2) return b.makeChoice(ep1, ep2); else return this; } boolean containsChoice(Pattern p) { return p1.containsChoice(p) || p2.containsChoice(p); } <T> T apply(PatternFunction<T> f) { return f.caseChoice(this); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { if (dad != null) dad.startChoice(); p1.checkRestrictions(context, dad, alpha); if (dad != null) dad.alternative(); p2.checkRestrictions(context, dad, alpha); if (dad != null) dad.endChoice(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.CommentList; import org.xml.sax.Locator; public class CommentListImpl implements CommentList<Locator> { public void addComment(String value, Locator loc) throws BuildException { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory; import com.thaiopensource.xml.util.WellKnownNamespaces; class CompatibilityDatatypeLibrary implements DatatypeLibrary { private final DatatypeLibraryFactory factory; private DatatypeLibrary xsdDatatypeLibrary = null; CompatibilityDatatypeLibrary(DatatypeLibraryFactory factory) { this.factory = factory; } public DatatypeBuilder createDatatypeBuilder(String type) throws DatatypeException { if (type.equals(\"ID\") || type.equals(\"IDREF\") || type.equals(\"IDREFS\")) { if (xsdDatatypeLibrary == null) { xsdDatatypeLibrary = factory.createDatatypeLibrary(WellKnownNamespaces.XML_SCHEMA_DATATYPES); if (xsdDatatypeLibrary == null) throw new DatatypeException(); } return xsdDatatypeLibrary.createDatatypeBuilder(type); } throw new DatatypeException(); } public Datatype createDatatype(String type) throws DatatypeException { return createDatatypeBuilder(type).createDatatype(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; import java.util.List; class DataDataDerivType extends DataDerivType { private final DataPattern dp; private PatternMemo validMemo; private PatternMemo invalidMemo; DataDataDerivType(DataPattern dp) { this.dp = dp; } PatternMemo dataDeriv(ValidatorPatternBuilder builder, Pattern p, String str, ValidationContext vc, List<DataDerivFailure> fail) { boolean isValid; final Datatype dt = dp.getDatatype(); DataDerivFailure ddf = null; if (fail != null) { try { dt.checkValid(str, vc); isValid = true; } catch (DatatypeException e) { isValid = false; ddf = new DataDerivFailure(dp, e); } } else isValid = dt.isValid(str, vc); if (isValid) { if (validMemo == null || (fail != null && validMemo.isNotAllowed())) validMemo = super.dataDeriv(builder, p, str, vc, fail); return validMemo; } else { if (invalidMemo == null) invalidMemo = super.dataDeriv(builder, p, str, vc, fail); else if (invalidMemo.isNotAllowed() && ddf != null) fail.add(ddf); return invalidMemo; } } DataDerivType copy() { return new DataDataDerivType(dp); } DataDerivType combine(DataDerivType ddt) { if (ddt instanceof DataDataDerivType) { if (((DataDataDerivType)ddt).dp.getDatatype() == dp.getDatatype()) return this; return InconsistentDataDerivType.getInstance(); } if (ddt instanceof ValueDataDerivType) { if (((ValueDataDerivType)ddt).getDatatype() == dp.getDatatype()) return ddt; return InconsistentDataDerivType.getInstance(); } return ddt.combine(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeException; import java.util.List;  final class DataDerivFailure { private final Datatype datatype; private final Name datatypeName; private final List<String> datatypeParams; private final String message; private final String stringValue; private final Object value; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.ValidationContext; import org.relaxng.datatype.DatatypeException; import java.util.List; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.ValidationContext; import java.util.List; abstract class DataDerivType { abstract DataDerivType copy(); abstract DataDerivType combine(DataDerivType ddt); PatternMemo dataDeriv(ValidatorPatternBuilder builder, Pattern p, String str, ValidationContext vc, List<DataDerivFailure> fail) { return builder.getPatternMemo(p.apply(new DataDerivFunction(str, vc, builder, fail))); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class DataDerivTypeFunction extends AbstractPatternFunction<DataDerivType> { private final ValidatorPatternBuilder builder; DataDerivTypeFunction(ValidatorPatternBuilder builder) { this.builder = builder; } static DataDerivType dataDerivType(ValidatorPatternBuilder builder, Pattern pattern) { return pattern.apply(builder.getDataDerivTypeFunction()); } public DataDerivType caseOther(Pattern p) { return new SingleDataDerivType(); } public DataDerivType caseRef(RefPattern p) { return apply(p.getPattern()); } public DataDerivType caseAfter(AfterPattern p) { Pattern p1 = p.getOperand1(); DataDerivType ddt = apply(p.getOperand1()); if (!p1.isNullable()) return ddt; return ddt.combine(new BlankDataDerivType()); } private DataDerivType caseBinary(BinaryPattern p) { return apply(p.getOperand1()).combine(apply(p.getOperand2())); } public DataDerivType caseChoice(ChoicePattern p) { return caseBinary(p); } public DataDerivType caseGroup(GroupPattern p) { return caseBinary(p); } public DataDerivType caseInterleave(InterleavePattern p) { return caseBinary(p); } public DataDerivType caseOneOrMore(OneOrMorePattern p) { return apply(p.getOperand()); } public DataDerivType caseList(ListPattern p) { return InconsistentDataDerivType.getInstance(); } public DataDerivType caseValue(ValuePattern p) { return new ValueDataDerivType(p.getDatatype(), p.getDatatypeName()); } public DataDerivType caseData(DataPattern p) { if (p.allowsAnyString()) return new SingleDataDerivType(); return new DataDataDerivType(p); } public DataDerivType caseDataExcept(DataExceptPattern p) { if (p.allowsAnyString()) return apply(p.getExcept()); return new DataDataDerivType(p).combine(apply(p.getExcept())); } private DataDerivType apply(Pattern p) { return builder.getPatternMemo(p).dataDerivType(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import org.xml.sax.Locator; import java.util.List; class DataExceptPattern extends DataPattern { private final Pattern except; private final Locator loc; DataExceptPattern(Datatype dt, Name dtName, List<String> params, Pattern except, Locator loc) { super(dt, dtName, params); this.except = except; this.loc = loc; } boolean samePattern(Pattern other) { if (!super.samePattern(other)) return false; return except.samePattern(((DataExceptPattern)other).except); } <T> T apply(PatternFunction<T> f) { return f.caseDataExcept(this); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { super.checkRestrictions(context, dad, alpha); try { except.checkRestrictions(DATA_EXCEPT_CONTEXT, null, null); } catch (RestrictionViolationException e) { e.maybeSetLocator(loc); throw e; } } Pattern getExcept() { return except; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.datatype.Datatype2; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import java.util.Collections; import java.util.List; class DataPattern extends StringPattern { private final Datatype dt; private final Name dtName; private final List<String> params; DataPattern(Datatype dt, Name dtName, List<String> params) { super(combineHashCode(DATA_HASH_CODE, dt.hashCode())); this.dt = dt; this.dtName = dtName; this.params = params; } boolean samePattern(Pattern other) { if (other.getClass() != this.getClass()) return false; return dt.equals(((DataPattern)other).dt); } <T> T apply(PatternFunction<T> f) { return f.caseData(this); } Datatype getDatatype() { return dt; } Name getDatatypeName() { return dtName; } List<String> getParams() { return Collections.unmodifiableList(params); } boolean allowsAnyString() { return dt instanceof Datatype2 && ((Datatype2)dt).alwaysValid(); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_data\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.Datatype; class DatatypeValue { private final Object value; private final Datatype dt; DatatypeValue(Object value, Datatype dt) { this.value = value; this.dt = dt; } public int hashCode() { return dt.hashCode() ^ dt.valueHashCode(value); } public boolean equals(Object obj) { if (!(obj instanceof DatatypeValue)) return false; DatatypeValue other = (DatatypeValue)obj; if (other.dt != dt) return false; return dt.sameValue(value, other.value); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import java.util.ArrayList; import java.util.List; class DuplicateAttributeDetector { private final List<NameClass> nameClasses = new ArrayList<NameClass>(); private Alternative alternatives = null; private static class Alternative { private final int startIndex; private int endIndex; private final Alternative parent; private Alternative(int startIndex, Alternative parent) { this.startIndex = startIndex; this.endIndex = startIndex; this.parent = parent; } } void addAttribute(NameClass nc) throws RestrictionViolationException { int lim = nameClasses.size(); for (Alternative a = alternatives; a != null; a = a.parent) { for (int i = a.endIndex; i < lim; i++) checkAttributeOverlap(nc, nameClasses.get(i)); lim = a.startIndex; } for (int i = 0; i < lim; i++) checkAttributeOverlap(nc, nameClasses.get(i)); nameClasses.add(nc); } static private void checkAttributeOverlap(NameClass nc1, NameClass nc2) throws RestrictionViolationException { OverlapDetector.checkOverlap(nc1, nc2, \"duplicate_attribute_name\", \"duplicate_attribute_ns\", \"duplicate_attribute\"); } void startChoice() { alternatives = new Alternative(nameClasses.size(), alternatives); } void alternative() { alternatives.endIndex = nameClasses.size(); } void endChoice() { alternatives = alternatives.parent; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.Locator; import org.xml.sax.SAXException; class ElementPattern extends Pattern { private Pattern p; private final NameClass origNameClass; private NameClass nameClass; private boolean expanded = false; private boolean checkedRestrictions = false; private final Locator loc; ElementPattern(NameClass nameClass, Pattern p, Locator loc) { super(false, ELEMENT_CONTENT_TYPE, combineHashCode(ELEMENT_HASH_CODE, nameClass.hashCode(), p.hashCode())); this.nameClass = nameClass; this.origNameClass = nameClass; this.p = p; this.loc = loc; } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { if (alpha != null) alpha.addElement(origNameClass); if (checkedRestrictions) return; switch (context) { case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_element\"); case LIST_CONTEXT: throw new RestrictionViolationException(\"list_contains_element\"); case ATTRIBUTE_CONTEXT: throw new RestrictionViolationException(\"attribute_contains_element\"); } checkedRestrictions = true; try { p.checkRestrictions(ELEMENT_CONTEXT, new DuplicateAttributeDetector(), null); } catch (RestrictionViolationException e) { checkedRestrictions = false; e.maybeSetLocator(loc); throw e; } } Pattern expand(SchemaPatternBuilder b) { if (!expanded) { expanded = true; p = p.expand(b); if (p.isNotAllowed()) nameClass = new NullNameClass(); } return this; } boolean samePattern(Pattern other) { if (!(other instanceof ElementPattern)) return false; ElementPattern ep = (ElementPattern)other; return nameClass.equals(ep.nameClass) && p == ep.p; } void checkRecursion(int depth) throws SAXException { p.checkRecursion(depth + 1); } <T> T apply(PatternFunction<T> f) { return f.caseElement(this); } void setContent(Pattern p) { this.p = p; } Pattern getContent() { return p; } NameClass getNameClass() { return nameClass; } Locator getLocator() { return loc; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class EmptyPattern extends Pattern { EmptyPattern() { super(true, EMPTY_CONTENT_TYPE, EMPTY_HASH_CODE); } boolean samePattern(Pattern other) { return other instanceof EmptyPattern; } <T> T apply(PatternFunction<T> f) { return f.caseEmpty(this); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_empty\"); case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_empty\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class EndAttributesFunction extends AbstractPatternFunction<Pattern> { private final ValidatorPatternBuilder builder; EndAttributesFunction(ValidatorPatternBuilder builder) { this.builder = builder; } public Pattern caseOther(Pattern p) { return p; } public Pattern caseGroup(GroupPattern p) { Pattern p1 = p.getOperand1(); Pattern p2 = p.getOperand2(); Pattern q1 = memoApply(p1); Pattern q2 = memoApply(p2); if (p1 == q1 && p2 == q2) return p; return builder.makeGroup(q1, q2); } public Pattern caseInterleave(InterleavePattern p) { Pattern p1 = p.getOperand1(); Pattern p2 = p.getOperand2(); Pattern q1 = memoApply(p1); Pattern q2 = memoApply(p2); if (p1 == q1 && p2 == q2) return p; return builder.makeInterleave(q1, q2); } public Pattern caseChoice(ChoicePattern p) { Pattern p1 = p.getOperand1(); Pattern p2 = p.getOperand2(); Pattern q1 = memoApply(p1); Pattern q2 = memoApply(p2); if (p1 == q1 && p2 == q2) return p; return builder.makeChoice(q1, q2); } public Pattern caseOneOrMore(OneOrMorePattern p) { Pattern p1 = p.getOperand(); Pattern q1 = memoApply(p1); if (p1 == q1) return p; return builder.makeOneOrMore(q1); } public Pattern caseAfter(AfterPattern p) { Pattern p1 = p.getOperand1(); Pattern q1 = memoApply(p1); if (p1 == q1) return p; return builder.makeAfter(q1, p.getOperand2()); } public Pattern caseAttribute(AttributePattern p) { return builder.makeNotAllowed(); } final Pattern memoApply(Pattern p) { return apply(builder.getPatternMemo(p)).getPattern(); } PatternMemo apply(PatternMemo memo) { return memo.endAttributes(this); } ValidatorPatternBuilder getPatternBuilder() { return builder; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class EndTagDerivFunction extends AbstractPatternFunction<Pattern> { private final ValidatorPatternBuilder builder; EndTagDerivFunction(ValidatorPatternBuilder builder) { this.builder = builder; } public Pattern caseOther(Pattern p) { return builder.makeNotAllowed(); } public Pattern caseChoice(ChoicePattern p) { return builder.makeChoice(memoApply(p.getOperand1()), memoApply(p.getOperand2())); } public Pattern caseAfter(AfterPattern p) { if (p.getOperand1().isNullable()) return p.getOperand2(); else return builder.makeNotAllowed(); } private Pattern memoApply(Pattern p) { return apply(builder.getPatternMemo(p)).getPattern(); } private PatternMemo apply(PatternMemo memo) { return memo.endTagDeriv(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class ErrorNameClass implements NameClass { public boolean contains(Name name) { return false; } public int containsSpecificity(Name name) { return SPECIFICITY_NONE; } public void accept(NameClassVisitor visitor) { visitor.visitError(); } public boolean isOpen() { return false; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class ErrorPattern extends Pattern { ErrorPattern() { super(false, EMPTY_CONTENT_TYPE, ERROR_HASH_CODE); } boolean samePattern(Pattern other) { return other instanceof ErrorPattern; } <T> T apply(PatternFunction<T> f) { return f.caseError(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import java.util.HashSet; import java.util.Set; public class FeasibleTransform { private static class FeasiblePatternFunction extends AbstractPatternFunction<Pattern> { private final SchemaPatternBuilder spb; private final Set<ElementPattern> elementDone = new HashSet<ElementPattern>(); FeasiblePatternFunction(SchemaPatternBuilder spb) { this.spb = spb; } public Pattern caseChoice(ChoicePattern p) { return spb.makeChoice(p.getOperand1().apply(this), p.getOperand2().apply(this)); } public Pattern caseGroup(GroupPattern p) { return spb.makeGroup(p.getOperand1().apply(this), p.getOperand2().apply(this)); } public Pattern caseInterleave(InterleavePattern p) { return spb.makeInterleave(p.getOperand1().apply(this), p.getOperand2().apply(this)); } public Pattern caseOneOrMore(OneOrMorePattern p) { return spb.makeOneOrMore(p.getOperand().apply(this)); } public Pattern caseElement(ElementPattern p) { if (!elementDone.contains(p)) { elementDone.add(p); p.setContent(p.getContent().apply(this)); } return spb.makeOptional(p); } public Pattern caseOther(Pattern p) { return spb.makeOptional(p); } } public static Pattern transform(SchemaPatternBuilder spb, Pattern p) { return p.apply(new FeasiblePatternFunction(spb)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.util.VoidValue; import com.thaiopensource.xml.util.Name; import java.util.HashSet; import java.util.Set; class FindElementFunction extends AbstractPatternFunction<VoidValue> { private final ValidatorPatternBuilder builder; private final Name name; private final Set<Pattern> processed = new HashSet<Pattern>(); private int specificity = NameClass.SPECIFICITY_NONE; private Pattern pattern = null; static public Pattern findElement(ValidatorPatternBuilder builder, Name name, Pattern start) { FindElementFunction f = new FindElementFunction(builder, name); start.apply(f); if (f.pattern == null) return builder.makeNotAllowed(); return f.pattern; } private FindElementFunction(ValidatorPatternBuilder builder, Name name) { this.builder = builder; this.name = name; } private boolean haveProcessed(Pattern p) { if (processed.contains(p)) return true; processed.add(p); return false; } private VoidValue caseBinary(BinaryPattern p) { if (!haveProcessed(p)) { p.getOperand1().apply(this); p.getOperand2().apply(this); } return VoidValue.VOID; } public VoidValue caseGroup(GroupPattern p) { return caseBinary(p); } public VoidValue caseInterleave(InterleavePattern p) { return caseBinary(p); } public VoidValue caseChoice(ChoicePattern p) { return caseBinary(p); } public VoidValue caseOneOrMore(OneOrMorePattern p) { if (!haveProcessed(p)) p.getOperand().apply(this); return VoidValue.VOID; } public VoidValue caseElement(ElementPattern p) { if (!haveProcessed(p)) { int s = p.getNameClass().containsSpecificity(name); if (s > specificity) { specificity = s; pattern = p.getContent(); } else if (s == specificity && s != NameClass.SPECIFICITY_NONE) pattern = builder.makeChoice(pattern, p.getContent()); p.getContent().apply(this); } return VoidValue.VOID; } public VoidValue caseOther(Pattern p) { return VoidValue.VOID; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class GroupPattern extends BinaryPattern { GroupPattern(Pattern p1, Pattern p2) { super(p1.isNullable() && p2.isNullable(), combineHashCode(GROUP_HASH_CODE, p1.hashCode(), p2.hashCode()), p1, p2); } Pattern expand(SchemaPatternBuilder b) { Pattern ep1 = p1.expand(b); Pattern ep2 = p2.expand(b); if (ep1 != p1 || ep2 != p2) return b.makeGroup(ep1, ep2); else return this; } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_group\"); case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_group\"); } super.checkRestrictions(context == ELEMENT_REPEAT_CONTEXT ? ELEMENT_REPEAT_GROUP_CONTEXT : context, dad, alpha); if (context != LIST_CONTEXT && !contentTypeGroupable(p1.getContentType(), p2.getContentType())) throw new RestrictionViolationException(\"group_string\"); } <T> T apply(PatternFunction<T> f) { return f.caseGroup(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import com.thaiopensource.xml.util.StringSplitter; import org.relaxng.datatype.Datatype; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.LocatorImpl; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class IdSoundnessChecker { private final IdTypeMap idTypeMap; private final ErrorHandler eh; private final Map<String, Entry> map = new HashMap<String, Entry>(); private static class Entry { Locator idLoc; List<LocatorImpl> idrefLocs; boolean hadId; } public IdSoundnessChecker(IdTypeMap idTypeMap, ErrorHandler eh) { this.idTypeMap = idTypeMap; this.eh = eh; } public void reset() { map.clear(); } public void endDocument() throws SAXException { for (String token : map.keySet()) { Entry entry = map.get(token); if (!entry.hadId) { for (LocatorImpl idrefLoc : entry.idrefLocs) error(\"missing_id\", token, idrefLoc); } } } public void attribute(Name elementName, Name attributeName, String value, Locator locator) throws SAXException { int idType = idTypeMap.getIdType(elementName, attributeName); if (idType != Datatype.ID_TYPE_NULL) { String[] tokens = StringSplitter.split(value); switch (idType) { case Datatype.ID_TYPE_ID: if (tokens.length == 1) id(tokens[0], locator); else if (tokens.length == 0) error(\"id_no_tokens\", locator); else error(\"id_multiple_tokens\", locator); break; case Datatype.ID_TYPE_IDREF: if (tokens.length == 1) idref(tokens[0], locator); else if (tokens.length == 0) error(\"idref_no_tokens\", locator); else error(\"idref_multiple_tokens\", locator); break; case Datatype.ID_TYPE_IDREFS: if (tokens.length > 0) { for (int j = 0; j < tokens.length; j++) idref(tokens[j], locator); } else error(\"idrefs_no_tokens\", locator); break; } } } private void id(String token, Locator locator) throws SAXException { Entry entry = map.get(token); if (entry == null) { entry = new Entry(); map.put(token, entry); } else if (entry.hadId) { error(\"duplicate_id\", token, locator); error(\"first_id\", token, entry.idLoc); return; } entry.idLoc = new LocatorImpl(locator); entry.hadId = true; } private void idref(String token, Locator locator) { Entry entry = map.get(token); if (entry == null) { entry = new Entry(); map.put(token, entry); } if (entry.hadId) return; if (entry.idrefLocs == null) entry.idrefLocs = new ArrayList<LocatorImpl>(); entry.idrefLocs.add(new LocatorImpl(locator)); } private void error(String key, Locator locator) throws SAXException { eh.error(new SAXParseException(SchemaBuilderImpl.localizer.message(key), locator)); } private void error(String key, String arg, Locator locator) throws SAXException { eh.error(new SAXParseException(SchemaBuilderImpl.localizer.message(key, arg), locator)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; public interface IdTypeMap { int getIdType(Name elementName, Name attributeName); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.util.VoidValue; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public class IdTypeMapBuilder { private boolean hadError; private final ErrorHandler eh; private final PatternFunction<Integer> idTypeFunction = new IdTypeFunction(); private final IdTypeMapImpl idTypeMap = new IdTypeMapImpl(); private final Set<ElementPattern> elementProcessed = new HashSet<ElementPattern>(); private final List<PossibleConflict> possibleConflicts = new ArrayList<PossibleConflict>(); private void notePossibleConflict(NameClass elementNameClass, NameClass attributeNameClass, Locator loc) { possibleConflicts.add(new PossibleConflict(elementNameClass, attributeNameClass, loc)); } private static class WrappedSAXException extends RuntimeException { private final SAXException cause; WrappedSAXException(SAXException cause) { this.cause = cause; } } private static class PossibleConflict { private final NameClass elementNameClass; private final NameClass attributeNameClass; private final Locator locator; private PossibleConflict(NameClass elementNameClass, NameClass attributeNameClass, Locator locator) { this.elementNameClass = elementNameClass; this.attributeNameClass = attributeNameClass; this.locator = locator; } } private static class ScopedName { private final Name elementName; private final Name attributeName; private ScopedName(Name elementName, Name attributeName) { this.elementName = elementName; this.attributeName = attributeName; } public int hashCode() { return elementName.hashCode() ^ attributeName.hashCode(); } public boolean equals(Object obj) { if (!(obj instanceof ScopedName)) return false; ScopedName other = (ScopedName)obj; return elementName.equals(other.elementName) && attributeName.equals(other.attributeName); } } private static class IdTypeMapImpl implements IdTypeMap { private final Map<ScopedName, Integer> table = new HashMap<ScopedName, Integer>(); public int getIdType(Name elementName, Name attributeName) { Integer n = table.get(new ScopedName(elementName, attributeName)); if (n == null) return Datatype.ID_TYPE_NULL; return n; } private void add(Name elementName, Name attributeName, int idType) { table.put(new ScopedName(elementName, attributeName), idType); } } private class IdTypeFunction extends AbstractPatternFunction<Integer> { public Integer caseOther(Pattern p) { return Datatype.ID_TYPE_NULL; } public Integer caseData(DataPattern p) { return p.getDatatype().getIdType(); } public Integer caseDataExcept(DataExceptPattern p) { return p.getDatatype().getIdType(); } public Integer caseValue(ValuePattern p) { return p.getDatatype().getIdType(); } } private class BuildFunction extends AbstractPatternFunction<VoidValue> { private final NameClass elementNameClass; private final Locator locator; private final boolean attributeIsParent; BuildFunction(NameClass elementNameClass, Locator locator) { this.elementNameClass = elementNameClass; this.locator = locator; this.attributeIsParent = false; } BuildFunction(NameClass elementNameClass, Locator locator, boolean attributeIsParent) { this.elementNameClass = elementNameClass; this.locator = locator; this.attributeIsParent = attributeIsParent; } private BuildFunction down() { if (!attributeIsParent) return this; return new BuildFunction(elementNameClass, locator, false); } public VoidValue caseChoice(ChoicePattern p) { BuildFunction f = down(); p.getOperand1().apply(f); p.getOperand2().apply(f); return VoidValue.VOID; } public VoidValue caseInterleave(InterleavePattern p) { BuildFunction f = down(); p.getOperand1().apply(f); p.getOperand2().apply(f); return VoidValue.VOID; } public VoidValue caseGroup(GroupPattern p) { BuildFunction f = down(); p.getOperand1().apply(f); p.getOperand2().apply(f); return VoidValue.VOID; } public VoidValue caseOneOrMore(OneOrMorePattern p) { p.getOperand().apply(down()); return VoidValue.VOID; } public VoidValue caseElement(ElementPattern p) { if (elementProcessed.contains(p)) return VoidValue.VOID; elementProcessed.add(p); p.getContent().apply(new BuildFunction(p.getNameClass(), p.getLocator())); return VoidValue.VOID; } public VoidValue caseAttribute(AttributePattern p) { int idType = p.getContent().apply(idTypeFunction); if (idType != Datatype.ID_TYPE_NULL) { NameClass attributeNameClass = p.getNameClass(); if (!(attributeNameClass instanceof SimpleNameClass)) { error(\"id_attribute_name_class\", p.getLocator()); return VoidValue.VOID; } elementNameClass.accept(new ElementNameClassVisitor(((SimpleNameClass)attributeNameClass).getName(), locator, idType)); } else notePossibleConflict(elementNameClass, p.getNameClass(), locator); p.getContent().apply(new BuildFunction(null, p.getLocator(), true)); return VoidValue.VOID; } private void datatype(Datatype dt) { if (dt.getIdType() != Datatype.ID_TYPE_NULL && !attributeIsParent) error(\"id_parent\", locator); } public VoidValue caseData(DataPattern p) { datatype(p.getDatatype()); return VoidValue.VOID; } public VoidValue caseDataExcept(DataExceptPattern p) { datatype(p.getDatatype()); p.getExcept().apply(down()); return VoidValue.VOID; } public VoidValue caseValue(ValuePattern p) { datatype(p.getDatatype()); return VoidValue.VOID; } public VoidValue caseList(ListPattern p) { p.getOperand().apply(down()); return VoidValue.VOID; } public VoidValue caseOther(Pattern p) { return VoidValue.VOID; } } private class ElementNameClassVisitor implements NameClassVisitor { private final Name attributeName; private final Locator locator; private final int idType; ElementNameClassVisitor(Name attributeName, Locator locator, int idType) { this.attributeName = attributeName; this.locator = locator; this.idType = idType; } public void visitChoice(NameClass nc1, NameClass nc2) { nc1.accept(this); nc2.accept(this); } public void visitName(Name elementName) { int tem = idTypeMap.getIdType(elementName, attributeName); if (tem != Datatype.ID_TYPE_NULL && tem != idType) error(\"id_type_conflict\", elementName, attributeName, locator); idTypeMap.add(elementName, attributeName, idType); } public void visitNsName(String ns) { visitOther(); } public void visitNsNameExcept(String ns, NameClass nc) { visitOther(); } public void visitAnyName() { visitOther(); } public void visitAnyNameExcept(NameClass nc) { visitOther(); } public void visitNull() { } public void visitError() { } private void visitOther() { error(\"id_element_name_class\", locator); } } private void error(String key, Locator locator) { hadError = true; if (eh != null) try { eh.error(new SAXParseException(SchemaBuilderImpl.localizer.message(key), locator)); } catch (SAXException e) { throw new WrappedSAXException(e); } } private void error(String key, Name arg1, Name arg2, Locator locator) { hadError = true; if (eh != null) try { eh.error(new SAXParseException(SchemaBuilderImpl.localizer.message(key, NameFormatter.format(arg1), NameFormatter.format(arg2)), locator)); } catch (SAXException e) { throw new WrappedSAXException(e); } } public IdTypeMapBuilder(ErrorHandler eh, Pattern pattern) throws SAXException { this.eh = eh; try { pattern.apply(new BuildFunction(null, null)); for (PossibleConflict pc : possibleConflicts) { if (pc.elementNameClass instanceof SimpleNameClass && pc.attributeNameClass instanceof SimpleNameClass) { Name elementName = ((SimpleNameClass)pc.elementNameClass).getName(); Name attributeName = ((SimpleNameClass)pc.attributeNameClass).getName(); int idType = idTypeMap.getIdType(elementName, attributeName); if (idType != Datatype.ID_TYPE_NULL) error(\"id_type_conflict\", elementName, attributeName, pc.locator); } else { for (ScopedName sn : idTypeMap.table.keySet()) { if (pc.elementNameClass.contains(sn.elementName) && pc.attributeNameClass.contains(sn.attributeName)) { error(\"id_type_conflict\", sn.elementName, sn.attributeName, pc.locator); break; } } } } } catch (WrappedSAXException e) { throw e.cause; } } public IdTypeMap getIdTypeMap() { if (hadError) return null; return idTypeMap; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class IgnoreMissingAttributesFunction extends EndAttributesFunction { IgnoreMissingAttributesFunction(ValidatorPatternBuilder builder) { super(builder); } public Pattern caseAttribute(AttributePattern p) { return getPatternBuilder().makeEmpty(); } PatternMemo apply(PatternMemo memo) { return memo.ignoreMissingAttributes(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class InconsistentDataDerivType extends DataDerivType { static private final InconsistentDataDerivType instance = new InconsistentDataDerivType(); static InconsistentDataDerivType getInstance() { return instance; } private InconsistentDataDerivType() { } DataDerivType combine(DataDerivType ddt) { return this; } DataDerivType copy() { return this; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class InterleavePattern extends BinaryPattern { InterleavePattern(Pattern p1, Pattern p2) { super(p1.isNullable() && p2.isNullable(), combineHashCode(INTERLEAVE_HASH_CODE, p1.hashCode(), p2.hashCode()), p1, p2); } Pattern expand(SchemaPatternBuilder b) { Pattern ep1 = p1.expand(b); Pattern ep2 = p2.expand(b); if (ep1 != p1 || ep2 != p2) return b.makeInterleave(ep1, ep2); else return this; } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_interleave\"); case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_interleave\"); case LIST_CONTEXT: throw new RestrictionViolationException(\"list_contains_interleave\"); } if (context == ELEMENT_REPEAT_CONTEXT) context = ELEMENT_REPEAT_INTERLEAVE_CONTEXT; Alphabet a1; if (alpha != null && alpha.isEmpty()) a1 = alpha; else a1 = new Alphabet(); p1.checkRestrictions(context, dad, a1); if (a1.isEmpty()) p2.checkRestrictions(context, dad, a1); else { Alphabet a2 = new Alphabet(); p2.checkRestrictions(context, dad, a2); a1.checkOverlap(a2); if (alpha != null) { if (alpha != a1) alpha.addAlphabet(a1); alpha.addAlphabet(a2); } } if (!contentTypeGroupable(p1.getContentType(), p2.getContentType())) throw new RestrictionViolationException(\"interleave_string\"); if (p1.getContentType() == MIXED_CONTENT_TYPE && p2.getContentType() == MIXED_CONTENT_TYPE) throw new RestrictionViolationException(\"interleave_text_overlap\"); } <T> T apply(PatternFunction<T> f) { return f.caseInterleave(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.ArrayList; import java.util.Iterator; import java.util.List;  public class IntersectionNameClassNormalizer extends AbstractNameClassNormalizer { private final List<NameClass> nameClasses = new ArrayList<NameClass>(); public void add(NameClass nc) { nameClasses.add(nc); } protected void accept(NameClassVisitor visitor) { for (NameClass nameClass : nameClasses) (nameClass).accept(visitor); } protected boolean contains(Name name) { Iterator<NameClass> iter = nameClasses.iterator(); if (!iter.hasNext()) return false; for (;;) { if (!(iter.next()).contains(name)) return false; if (!iter.hasNext()) break; } return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.Locator; import org.xml.sax.SAXException; class ListPattern extends Pattern { private final Pattern p; private final Locator locator; ListPattern(Pattern p, Locator locator) { super(false, DATA_CONTENT_TYPE, combineHashCode(LIST_HASH_CODE, p.hashCode())); this.p = p; this.locator = locator; } Pattern expand(SchemaPatternBuilder b) { Pattern ep = p.expand(b); if (ep != p) return b.makeList(ep, locator); else return this; } void checkRecursion(int depth) throws SAXException { p.checkRecursion(depth); } boolean samePattern(Pattern other) { return (other instanceof ListPattern && p == ((ListPattern)other).p); } <T> T apply(PatternFunction<T> f) { return f.caseList(this); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_list\"); case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_list\"); case LIST_CONTEXT: throw new RestrictionViolationException(\"list_contains_list\"); } try { p.checkRestrictions(LIST_CONTEXT, dad, null); } catch (RestrictionViolationException e) { e.maybeSetLocator(locator); throw e; } } Pattern getOperand() { return p; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.relaxng.match.MatchablePattern; import com.thaiopensource.relaxng.match.Matcher; public class MatchablePatternImpl implements MatchablePattern { private final SchemaPatternBuilder spb; private final Pattern start; public MatchablePatternImpl(SchemaPatternBuilder spb, Pattern start) { this.spb = spb; this.start = start; } public Matcher createMatcher() { return new PatternMatcher(start, new ValidatorPatternBuilder(spb)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class MixedTextDerivFunction extends EndAttributesFunction { MixedTextDerivFunction(ValidatorPatternBuilder builder) { super(builder); } public Pattern caseText(TextPattern p) { return p; } public Pattern caseGroup(GroupPattern p) { final Pattern p1 = p.getOperand1(); final Pattern p2 = p.getOperand2(); final Pattern q1 = memoApply(p1); Pattern tem = (q1 == p1) ? p : getPatternBuilder().makeGroup(q1, p2); if (!p1.isNullable()) return tem; return getPatternBuilder().makeChoice(tem, memoApply(p2)); } public Pattern caseInterleave(InterleavePattern p) { final Pattern p1 = p.getOperand1(); final Pattern p2 = p.getOperand2(); final Pattern q1 = memoApply(p1); final Pattern q2 = memoApply(p2); final Pattern i1 = (q1 == p1) ? p : getPatternBuilder().makeInterleave(q1, p2); final Pattern i2 = (q2 == p2) ? p : getPatternBuilder().makeInterleave(p1, q2); return getPatternBuilder().makeChoice(i1, i2); } public Pattern caseOneOrMore(OneOrMorePattern p) { return getPatternBuilder().makeGroup(memoApply(p.getOperand()), getPatternBuilder().makeOptional(p)); } public Pattern caseOther(Pattern p) { return getPatternBuilder().makeNotAllowed(); } PatternMemo apply(PatternMemo memo) { return memo.mixedTextDeriv(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; public interface NameClass { static final int SPECIFICITY_NONE = -1; static final int SPECIFICITY_ANY_NAME = 0; static final int SPECIFICITY_NS_NAME = 1; static final int SPECIFICITY_NAME = 2; boolean contains(Name name); int containsSpecificity(Name name); void accept(NameClassVisitor visitor); boolean isOpen(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name;  public class NameClassNormalizer extends AbstractNameClassNormalizer { private NameClass nameClass; public NameClassNormalizer(NameClass nameClass) { this.nameClass = nameClass; } protected boolean contains(Name name) { return nameClass.contains(name); } protected void accept(NameClassVisitor visitor) { nameClass.accept(visitor); } public NameClass getNameClass() { return nameClass; } public void setNameClass(NameClass nameClass) { this.nameClass = nameClass; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; public interface NameClassVisitor { void visitChoice(NameClass nc1, NameClass nc2); void visitNsName(String ns); void visitNsNameExcept(String ns, NameClass nc); void visitAnyName(); void visitAnyNameExcept(NameClass nc); void visitName(Name name); void visitNull(); void visitError(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class NameFormatter { static String format(Name name) { String localName = name.getLocalName(); String namespaceUri = name.getNamespaceUri(); if (namespaceUri.equals(\"\")) return SchemaBuilderImpl.localizer.message(\"name_absent_namespace\", localName); else return SchemaBuilderImpl.localizer.message(\"name_with_namespace\", namespaceUri, localName); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.Set;  public class NormalizedAnyNameClass extends NormalizedNameClass { private final Set<String> excludedNamespaces; private final Set<Name> excludedNames; public NormalizedAnyNameClass(Set<Name> includedNames, Set<String> excludedNamespaces, Set<Name> excludedNames) { super(includedNames); this.excludedNamespaces = immutable(excludedNamespaces); this.excludedNames = immutable(excludedNames); } public boolean isAnyNameIncluded() { return true; } public boolean contains(Name name) { if (excludedNamespaces.contains(name.getNamespaceUri())) return super.contains(name); else return !excludedNames.contains(name); } public boolean isEmpty() { return false; } public Set<String> getExcludedNamespaces() { return excludedNamespaces; } public Set<Name> getExcludedNames() { return excludedNames; } public int hashCode() { return super.hashCode() ^ excludedNamespaces.hashCode() ^ excludedNames.hashCode(); } public boolean equals(Object obj) { if (!(obj instanceof NormalizedAnyNameClass)) return false; NormalizedAnyNameClass other = (NormalizedAnyNameClass)obj; if (!(excludedNamespaces.equals(other.excludedNamespaces))) return false; if (!(excludedNames.equals(other.excludedNames))) return false; return equal(this, other); } boolean includesNamespace(String ns) { return !getExcludedNamespaces().contains(ns); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.Collections; import java.util.Set;  public abstract class NormalizedNameClass implements com.thaiopensource.relaxng.match.NameClass { private final Set<Name> includedNames;  public NormalizedNameClass(Set<Name> includedNames) { this.includedNames = immutable(includedNames); } public boolean isEmpty() { return includedNames.isEmpty(); } public boolean contains(Name name) { return includedNames.contains(name); } public boolean isAnyNameIncluded() { return false; } public Set<String> getExcludedNamespaces() { return null; } public Set<Name> getIncludedNames() { return includedNames; } public Set<Name> getExcludedNames() { return null; } public Set<String> getIncludedNamespaces() { return Collections.emptySet(); } public Set<String> getExcludedLocalNames(String ns) { return null; } public abstract boolean equals(Object obj); boolean equal(NormalizedNameClass nc1, NormalizedNameClass nc2) { return nc1.includedNames.equals(nc2.includedNames); } public int hashCode() { return includedNames.hashCode(); } <T> Set<T> immutable(Set<T> set) { if (set.isEmpty()) return Collections.emptySet(); return Collections.unmodifiableSet(set); } abstract boolean includesNamespace(String ns); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.Map; import java.util.Set;  public class NormalizedNsNameClass extends NormalizedNameClass { private final Map<String, ? extends Set<String>> nsMap; private final Set<String> includedNamespaces; public NormalizedNsNameClass(Set<Name> includedNames, Map<String, ? extends Set<String>> nsMap) { super(includedNames); this.nsMap = nsMap; includedNamespaces = immutable(nsMap.keySet()); } public boolean isEmpty() { return super.isEmpty() && nsMap.isEmpty(); } public boolean contains(Name name) { Set<String> excludedLocalNames = nsMap.get(name.getNamespaceUri()); if (excludedLocalNames == null) return super.contains(name); else return !excludedLocalNames.contains(name.getLocalName()); } public Set<String> getIncludedNamespaces() { return includedNamespaces; } public Set<String> getExcludedLocalNames(String ns) { return nsMap.get(ns); } public int hashCode() { return super.hashCode() ^ nsMap.hashCode(); } public boolean equals(Object obj) { if (!(obj instanceof NormalizedNsNameClass)) return false; NormalizedNsNameClass other = (NormalizedNsNameClass)obj; if (!nsMap.equals(other.nsMap)) return false; return equal(this, other); } boolean includesNamespace(String ns) { return getIncludedNamespaces().contains(ns); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class NotAllowedPattern extends Pattern { NotAllowedPattern() { super(false, EMPTY_CONTENT_TYPE, NOT_ALLOWED_HASH_CODE); } boolean isNotAllowed() { return true; } boolean samePattern(Pattern other) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class NsNameClass implements NameClass { private final String namespaceUri; NsNameClass(String namespaceUri) { this.namespaceUri = namespaceUri; } public boolean contains(Name name) { return this.namespaceUri.equals(name.getNamespaceUri()); } public int containsSpecificity(Name name) { return contains(name) ? SPECIFICITY_NS_NAME : SPECIFICITY_NONE; } public int hashCode() { return namespaceUri.hashCode(); } public boolean equals(Object obj) { if (obj == null || !(obj instanceof NsNameClass)) return false; return namespaceUri.equals(((NsNameClass)obj).namespaceUri); } public void accept(NameClassVisitor visitor) { visitor.visitNsName(namespaceUri); } public boolean isOpen() { return true; } public String getNamespaceUri() { return namespaceUri; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class NsNameExceptNameClass implements NameClass { private final NameClass nameClass; private final String namespaceURI; NsNameExceptNameClass(String namespaceURI, NameClass nameClass) { this.namespaceURI = namespaceURI; this.nameClass = nameClass; } public boolean contains(Name name) { return (this.namespaceURI.equals(name.getNamespaceUri()) && !nameClass.contains(name)); } public int containsSpecificity(Name name) { return contains(name) ? SPECIFICITY_NS_NAME : SPECIFICITY_NONE; } public boolean equals(Object obj) { if (obj == null || !(obj instanceof NsNameExceptNameClass)) return false; NsNameExceptNameClass other = (NsNameExceptNameClass)obj; return (namespaceURI.equals(other.namespaceURI) && nameClass.equals(other.nameClass)); } public int hashCode() { return namespaceURI.hashCode() ^ nameClass.hashCode(); } public void accept(NameClassVisitor visitor) { visitor.visitNsNameExcept(namespaceURI, nameClass); } public boolean isOpen() { return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name;  class NullNameClass implements NameClass { public boolean contains(Name name) { return false; } public int containsSpecificity(Name name) { return SPECIFICITY_NONE; } public int hashCode() { return NullNameClass.class.hashCode(); } public boolean equals(Object obj) { if (obj == null || !(obj instanceof NullNameClass)) return false; return true; } public void accept(NameClassVisitor visitor) { visitor.visitNull(); } public boolean isOpen() { return false; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.SAXException; class OneOrMorePattern extends Pattern { private final Pattern p; OneOrMorePattern(Pattern p) { super(p.isNullable(), p.getContentType(), combineHashCode(ONE_OR_MORE_HASH_CODE, p.hashCode())); this.p = p; } Pattern expand(SchemaPatternBuilder b) { Pattern ep = p.expand(b); if (ep != p) return b.makeOneOrMore(ep); else return this; } void checkRecursion(int depth) throws SAXException { p.checkRecursion(depth); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_one_or_more\"); case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_one_or_more\"); } p.checkRestrictions(context == ELEMENT_CONTEXT ? ELEMENT_REPEAT_CONTEXT : context, dad, alpha); if (context != LIST_CONTEXT && !contentTypeGroupable(p.getContentType(), p.getContentType())) throw new RestrictionViolationException(\"one_or_more_string\"); } boolean samePattern(Pattern other) { return (other instanceof OneOrMorePattern && p == ((OneOrMorePattern)other).p); } <T> T apply(PatternFunction<T> f) { return f.caseOneOrMore(this); } Pattern getOperand() { return p; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class OverlapDetector implements NameClassVisitor { private final NameClass nc1; private final NameClass nc2; private Name overlapExample = null; private static final String IMPOSSIBLE = \"\\u0000\"; private OverlapDetector(NameClass nc1, NameClass nc2) { this.nc1 = nc1; this.nc2 = nc2; nc1.accept(this); nc2.accept(this); } private void probe(Name name) { if (nc1.contains(name) && nc2.contains(name)) overlapExample = name; } public void visitChoice(NameClass nc1, NameClass nc2) { nc1.accept(this); nc2.accept(this); } public void visitNsName(String ns) { probe(new Name(ns, IMPOSSIBLE)); } public void visitNsNameExcept(String ns, NameClass ex) { probe(new Name(ns, IMPOSSIBLE)); ex.accept(this); } public void visitAnyName() { probe(new Name(IMPOSSIBLE, IMPOSSIBLE)); } public void visitAnyNameExcept(NameClass ex) { probe(new Name(IMPOSSIBLE, IMPOSSIBLE)); ex.accept(this); } public void visitName(Name name) { probe(name); } public void visitNull() { } public void visitError() { } static void checkOverlap(NameClass nc1, NameClass nc2, String messageForName, String messageForNs, String messageForOther) throws RestrictionViolationException { if (nc2 instanceof SimpleNameClass) { SimpleNameClass snc = (SimpleNameClass)nc2; if (nc1.contains(snc.getName())) throw new RestrictionViolationException(messageForName, snc.getName()); } else if (nc1 instanceof SimpleNameClass) { SimpleNameClass snc = (SimpleNameClass)nc1; if (nc2.contains(snc.getName())) throw new RestrictionViolationException(messageForName, snc.getName()); } else { Name name = new OverlapDetector(nc1, nc2).overlapExample; if (name != null) { String localName = name.getLocalName(); if (localName == IMPOSSIBLE) { String ns = name.getNamespaceUri(); if (ns == IMPOSSIBLE) throw new RestrictionViolationException(messageForOther); else throw new RestrictionViolationException(messageForNs, ns); } else throw new RestrictionViolationException(messageForName, name); } } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.SAXException; public abstract class Pattern { private final boolean nullable; private final int hc; private final int contentType; static final int TEXT_HASH_CODE = 1; static final int ERROR_HASH_CODE = 3; static final int EMPTY_HASH_CODE = 5; static final int NOT_ALLOWED_HASH_CODE = 7; static final int CHOICE_HASH_CODE = 11; static final int GROUP_HASH_CODE = 13; static final int INTERLEAVE_HASH_CODE = 17; static final int ONE_OR_MORE_HASH_CODE = 19; static final int ELEMENT_HASH_CODE = 23; static final int VALUE_HASH_CODE = 27; static final int ATTRIBUTE_HASH_CODE = 29; static final int DATA_HASH_CODE = 31; static final int LIST_HASH_CODE = 37; static final int AFTER_HASH_CODE = 41; static int combineHashCode(int hc1, int hc2, int hc3) { return hc1 * hc2 * hc3; } static int combineHashCode(int hc1, int hc2) { return hc1 * hc2; } static final int EMPTY_CONTENT_TYPE = 0; static final int ELEMENT_CONTENT_TYPE = 1; static final int MIXED_CONTENT_TYPE = 2; static final int DATA_CONTENT_TYPE = 3; Pattern(boolean nullable, int contentType, int hc) { this.nullable = nullable; this.contentType = contentType; this.hc = hc; } Pattern() { this.nullable = false; this.hc = hashCode(); this.contentType = EMPTY_CONTENT_TYPE; } void checkRecursion(int depth) throws SAXException { } Pattern expand(SchemaPatternBuilder b) { return this; } final boolean isNullable() { return nullable; } boolean isNotAllowed() { return false; } static final int START_CONTEXT = 0; static final int ELEMENT_CONTEXT = 1; static final int ELEMENT_REPEAT_CONTEXT = 2; static final int ELEMENT_REPEAT_GROUP_CONTEXT = 3; static final int ELEMENT_REPEAT_INTERLEAVE_CONTEXT = 4; static final int ATTRIBUTE_CONTEXT = 5; static final int LIST_CONTEXT = 6; static final int DATA_EXCEPT_CONTEXT = 7; void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; public class PatternBuilder { private final EmptyPattern empty; protected final NotAllowedPattern notAllowed; protected final PatternInterner interner; public PatternBuilder() { empty = new EmptyPattern(); notAllowed = new NotAllowedPattern(); interner = new PatternInterner(); } public PatternBuilder(PatternBuilder parent) { empty = parent.empty; notAllowed = parent.notAllowed; interner = new PatternInterner(parent.interner); } Pattern makeEmpty() { return empty; } Pattern makeNotAllowed() { return notAllowed; } Pattern makeGroup(Pattern p1, Pattern p2) { if (p1 == empty) return p2; if (p2 == empty) return p1; if (p1 == notAllowed || p2 == notAllowed) return notAllowed; if (false && p1 instanceof GroupPattern) { GroupPattern sp = (GroupPattern)p1; return makeGroup(sp.p1, makeGroup(sp.p2, p2)); } Pattern p = new GroupPattern(p1, p2); return interner.intern(p); } Pattern makeInterleave(Pattern p1, Pattern p2) { if (p1 == empty) return p2; if (p2 == empty) return p1; if (p1 == notAllowed || p2 == notAllowed) return notAllowed; if (false && p1 instanceof InterleavePattern) { InterleavePattern ip = (InterleavePattern)p1; return makeInterleave(ip.p1, makeInterleave(ip.p2, p2)); } if (false) { if (p2 instanceof InterleavePattern) { InterleavePattern ip = (InterleavePattern)p2; if (p1.hashCode() > ip.p1.hashCode()) return makeInterleave(ip.p1, makeInterleave(p1, ip.p2)); } else if (p1.hashCode() > p2.hashCode()) return makeInterleave(p2, p1); } Pattern p = new InterleavePattern(p1, p2); return interner.intern(p); } Pattern makeChoice(Pattern p1, Pattern p2) { if (p1 == empty && p2.isNullable()) return p2; if (p2 == empty && p1.isNullable()) return p1; Pattern p = new ChoicePattern(p1, p2); return interner.intern(p); } Pattern makeOneOrMore(Pattern p) { if (p == empty || p == notAllowed || p instanceof OneOrMorePattern) return p; Pattern p1 = new OneOrMorePattern(p); return interner.intern(p1); } Pattern makeOptional(Pattern p) { return makeChoice(p, empty); } Pattern makeZeroOrMore(Pattern p) { return makeOptional(makeOneOrMore(p)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.util.VoidValue; import com.thaiopensource.xml.util.Name; import com.thaiopensource.xml.util.WellKnownNamespaces; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; public class PatternDumper { private static final String INTERNAL_NAMESPACE = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; interface PatternFunction<T> { T caseEmpty(EmptyPattern p); T caseNotAllowed(NotAllowedPattern p); T caseError(ErrorPattern p); T caseGroup(GroupPattern p); T caseInterleave(InterleavePattern p); T caseChoice(ChoicePattern p); T caseOneOrMore(OneOrMorePattern p); T caseElement(ElementPattern p); T caseAttribute(AttributePattern p); T caseData(DataPattern p); T caseDataExcept(DataExceptPattern p); T caseValue(ValuePattern p); T caseText(TextPattern p); T caseList(ListPattern p); T caseRef(RefPattern p); T caseAfter(AfterPattern p); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.SAXException; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import java.io.IOException; public interface PatternFuture { Pattern getPattern(boolean isAttributesPattern) throws IllegalSchemaException, SAXException, IOException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; final class PatternInterner { private static final int INIT_SIZE = 256; private static final float LOAD_FACTOR = 0.3f; private Pattern[] table; private int used; private int usedLimit; PatternInterner() { table = null; used = 0; usedLimit = 0; } PatternInterner(PatternInterner parent) { table = parent.table; if (table != null) table = table.clone(); used = parent.used; usedLimit = parent.usedLimit; } Pattern intern(Pattern p) { int h; if (table == null) { table = new Pattern[INIT_SIZE]; usedLimit = (int)(INIT_SIZE * LOAD_FACTOR); h = firstIndex(p); } else { for (h = firstIndex(p); table[h] != null; h = nextIndex(h)) { if (p.samePattern(table[h])) return table[h]; } } if (used >= usedLimit) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.datatype.Datatype2; import com.thaiopensource.relaxng.match.MatchContext; import com.thaiopensource.relaxng.match.Matcher; import com.thaiopensource.util.Equal; import com.thaiopensource.util.Localizer; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public class PatternMatcher implements Cloneable, Matcher { static private class Shared { private final Pattern start; private final ValidatorPatternBuilder builder; private Map<Name, Pattern> recoverPatternTable; Shared(Pattern start, ValidatorPatternBuilder builder) { this.start = start; this.builder = builder; } Pattern findElement(Name name) { if (recoverPatternTable == null) recoverPatternTable = new HashMap<Name, Pattern>(); Pattern p = recoverPatternTable.get(name); if (p == null) { p = FindElementFunction.findElement(builder, name, start); recoverPatternTable.put(name, p); } return p; } } private PatternMemo memo; private boolean textTyped; private boolean hadError; private boolean ignoreNextEndTagOrAttributeValue; private String errorMessage; private final Shared shared; private List<DataDerivFailure> dataDerivFailureList = new ArrayList<DataDerivFailure>(); public PatternMatcher(Pattern start, ValidatorPatternBuilder builder) { shared = new Shared(start, builder); memo = builder.getPatternMemo(start); } private PatternMatcher(PatternMemo memo, Shared shared) { this.memo = memo; this.shared = shared; } public Matcher start() { return new PatternMatcher(shared.builder.getPatternMemo(shared.start), shared); } public boolean equals(Object obj) { if (!(obj instanceof PatternMatcher)) return false; PatternMatcher other = (PatternMatcher)obj; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.ValidationContext; import java.util.HashMap; import java.util.List; import java.util.Map; final class PatternMemo { private final Pattern pattern; private final ValidatorPatternBuilder builder; private final boolean notAllowed; private PatternMemo memoEndAttributes; private PatternMemo memoTextOnly; private PatternMemo memoEndTagDeriv; private PatternMemo memoMixedTextDeriv; private PatternMemo memoIgnoreMissingAttributes; private Map<Name, PatternMemo> startTagOpenDerivMap; private Map<Name, PatternMemo> startTagOpenRecoverDerivMap; private Map<Name, PatternMemo> startAttributeDerivMap; private DataDerivType memoDataDerivType; private PatternMemo memoRecoverAfter; private PatternMemo memoEmptyAfter; private NormalizedNameClass memoPossibleAttributeNames; private NormalizedNameClass memoPossibleStartTagNames; PatternMemo(Pattern pattern, ValidatorPatternBuilder builder) { this.pattern = pattern; this.builder = builder; this.notAllowed = pattern.isNotAllowed(); } Pattern getPattern() { return pattern; } ValidatorPatternBuilder getPatternBuilder() { return builder; } boolean isNotAllowed() { return notAllowed; } PatternMemo endAttributes() { if (memoEndAttributes == null) memoEndAttributes = applyForPatternMemo(builder.getEndAttributesFunction()); return memoEndAttributes; } PatternMemo endAttributes(PatternFunction<Pattern> f) { if (memoEndAttributes == null) memoEndAttributes = applyForPatternMemo(f); return memoEndAttributes; } PatternMemo ignoreMissingAttributes() { if (memoIgnoreMissingAttributes == null) memoIgnoreMissingAttributes = applyForPatternMemo(builder.getIgnoreMissingAttributesFunction()); return memoIgnoreMissingAttributes; } PatternMemo ignoreMissingAttributes(PatternFunction<Pattern> f) { if (memoIgnoreMissingAttributes == null) memoIgnoreMissingAttributes = applyForPatternMemo(f); return memoIgnoreMissingAttributes; } PatternMemo textOnly() { if (memoTextOnly == null) memoTextOnly = applyForPatternMemo(builder.getTextOnlyFunction()); return memoTextOnly; } PatternMemo textOnly(PatternFunction<Pattern> f) { if (memoTextOnly == null) memoTextOnly = applyForPatternMemo(f); return memoTextOnly; } PatternMemo endTagDeriv() { if (memoEndTagDeriv == null) memoEndTagDeriv = applyForPatternMemo(builder.getEndTagDerivFunction()); return memoEndTagDeriv; } PatternMemo endTagDeriv(PatternFunction<Pattern> f) { if (memoEndTagDeriv == null) memoEndTagDeriv = applyForPatternMemo(f); return memoEndTagDeriv; } PatternMemo mixedTextDeriv() { if (memoMixedTextDeriv == null) memoMixedTextDeriv = applyForPatternMemo(builder.getMixedTextDerivFunction()); return memoMixedTextDeriv; } PatternMemo mixedTextDeriv(PatternFunction<Pattern> f) { if (memoMixedTextDeriv == null) memoMixedTextDeriv = applyForPatternMemo(f); return memoMixedTextDeriv; } PatternMemo startTagOpenDeriv(Name name) { return startTagOpenDeriv(name, null); } PatternMemo startTagOpenDeriv(StartTagOpenDerivFunction f) { return startTagOpenDeriv(f.getName(), f); } private PatternMemo startTagOpenDeriv(Name name, StartTagOpenDerivFunction f) { PatternMemo tem; if (startTagOpenDerivMap == null) startTagOpenDerivMap = new HashMap<Name, PatternMemo>(); else { tem = startTagOpenDerivMap.get(name); if (tem != null) return tem; } if (f == null) f = new StartTagOpenDerivFunction(name, builder); tem = applyForPatternMemo(f); startTagOpenDerivMap.put(name, tem); return tem; } PatternMemo startTagOpenRecoverDeriv(Name name) { return startTagOpenRecoverDeriv(name, null); } PatternMemo startTagOpenRecoverDeriv(StartTagOpenRecoverDerivFunction f) { return startTagOpenRecoverDeriv(f.getName(), f); } private PatternMemo startTagOpenRecoverDeriv(Name name, StartTagOpenRecoverDerivFunction f) { PatternMemo tem; if (startTagOpenRecoverDerivMap == null) startTagOpenRecoverDerivMap = new HashMap<Name, PatternMemo>(); else { tem = startTagOpenRecoverDerivMap.get(name); if (tem != null) return tem; } if (f == null) f = new StartTagOpenRecoverDerivFunction(name, builder); tem = applyForPatternMemo(f); startTagOpenRecoverDerivMap.put(name, tem); return tem; } PatternMemo startAttributeDeriv(Name name) { return startAttributeDeriv(name, null); } PatternMemo startAttributeDeriv(StartAttributeDerivFunction f) { return startAttributeDeriv(f.getName(), f); } private PatternMemo startAttributeDeriv(Name name, StartAttributeDerivFunction f) { PatternMemo tem; if (startAttributeDerivMap == null) startAttributeDerivMap = new HashMap<Name, PatternMemo>(); else { tem = startAttributeDerivMap.get(name); if (tem != null) return tem; } if (f == null) f = new StartAttributeDerivFunction(name, builder); tem = applyForPatternMemo(f); startAttributeDerivMap.put(name, tem); return tem; } DataDerivType dataDerivType() { if (memoDataDerivType == null) memoDataDerivType = DataDerivTypeFunction.dataDerivType(builder, pattern).copy(); return memoDataDerivType; } PatternMemo dataDeriv(String str, ValidationContext vc) { return dataDerivType().dataDeriv(builder, pattern, str, vc, null); } PatternMemo dataDeriv(String str, ValidationContext vc, List<DataDerivFailure> fail) { return dataDerivType().dataDeriv(builder, pattern, str, vc, fail); } PatternMemo recoverAfter() { if (memoRecoverAfter == null) memoRecoverAfter = applyForPatternMemo(builder.getRecoverAfterFunction()); return memoRecoverAfter; } PatternMemo emptyAfter() { if (memoEmptyAfter == null) memoEmptyAfter = applyForPatternMemo(new ApplyAfterFunction(builder) { Pattern apply(Pattern p) { return builder.makeEmpty(); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.util.VoidValue;  class PossibleAttributeNamesFunction extends PossibleNamesFunction { public VoidValue caseAttribute(AttributePattern p) { add(p.getNameClass()); return VoidValue.VOID; } public VoidValue caseGroup(GroupPattern p) { return caseBinary(p); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.util.VoidValue;  abstract class PossibleNamesFunction extends AbstractPatternFunction<VoidValue> { private final UnionNameClassNormalizer normalizer = new UnionNameClassNormalizer(); NormalizedNameClass applyTo(Pattern p) { normalizer.setNameClass(new NullNameClass()); p.apply(this); return normalizer.normalize(); } void add(NameClass nc) { normalizer.add(nc); } public VoidValue caseAfter(AfterPattern p) { return p.getOperand1().apply(this); } public VoidValue caseBinary(BinaryPattern p) { p.getOperand1().apply(this); p.getOperand2().apply(this); return VoidValue.VOID; } public VoidValue caseChoice(ChoicePattern p) { return caseBinary(p); } public VoidValue caseInterleave(InterleavePattern p) { return caseBinary(p); } public VoidValue caseOneOrMore(OneOrMorePattern p) { return p.getOperand().apply(this); } public VoidValue caseOther(Pattern p) { return VoidValue.VOID; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.util.VoidValue;  class PossibleStartTagNamesFunction extends PossibleNamesFunction { public VoidValue caseElement(ElementPattern p) { add(p.getNameClass()); return VoidValue.VOID; } public VoidValue caseGroup(GroupPattern p) { p.getOperand1().apply(this); if (p.getOperand1().isNullable()) p.getOperand2().apply(this); return VoidValue.VOID; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class RecoverAfterFunction extends AbstractPatternFunction<Pattern> { private final ValidatorPatternBuilder builder; RecoverAfterFunction(ValidatorPatternBuilder builder) { this.builder = builder; } public Pattern caseOther(Pattern p) { throw new RuntimeException(\"recover after botch\"); } public Pattern caseChoice(ChoicePattern p) { return builder.makeChoice(p.getOperand1().apply(this), p.getOperand2().apply(this)); } public Pattern caseAfter(AfterPattern p) { return p.getOperand2(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; class RefPattern extends Pattern { private Pattern p; private Locator refLoc; private final String name; private int checkRecursionDepth = -1; private boolean combineImplicit = false; private byte combineType = COMBINE_NONE; private byte replacementStatus = REPLACEMENT_KEEP; private boolean expanded = false; static final byte REPLACEMENT_KEEP = 0; static final byte REPLACEMENT_REQUIRE = 1; static final byte REPLACEMENT_IGNORE = 2; static final byte COMBINE_NONE = 0; static final byte COMBINE_CHOICE = 1; static final byte COMBINE_INTERLEAVE = 2; RefPattern(String name) { this.name = name; } Pattern getPattern() { return p; } void setPattern(Pattern p) { this.p = p; } Locator getRefLocator() { return refLoc; } void setRefLocator(Locator loc) { this.refLoc = loc; } void checkRecursion(int depth) throws SAXException { if (checkRecursionDepth == -1) { checkRecursionDepth = depth; p.checkRecursion(depth); checkRecursionDepth = -2; } else if (depth == checkRecursionDepth) "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.Set;  class RequiredAttributesFunction extends RequiredElementsOrAttributesFunction { public Set<Name> caseAttribute(AttributePattern p) { return caseNamed(p.getNameClass()); } public Set<Name> caseGroup(GroupPattern p) { return union(p); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.Set;  public class RequiredElementsFunction extends RequiredElementsOrAttributesFunction { public Set<Name> caseElement(ElementPattern p) { return caseNamed(p.getNameClass()); } public Set<Name> caseGroup(GroupPattern p) { Pattern p1 = p.getOperand1(); if (!p1.isNullable()) return p1.apply(this); return p.getOperand2().apply(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import java.util.Collections; import java.util.HashSet; import java.util.Set;  abstract class RequiredElementsOrAttributesFunction extends AbstractPatternFunction<Set<Name>> { public Set<Name> caseOther(Pattern p) { return Collections.emptySet(); } public Set<Name> caseChoice(ChoicePattern p) { Set<Name> s1 = p.getOperand1().apply(this); Set<Name> s2 = p.getOperand2().apply(this); if (s1.isEmpty()) return s1; if (s2.isEmpty()) return s2; s1.retainAll(s2); return s1; } protected Set<Name> caseNamed(NameClass nc) { if (!(nc instanceof SimpleNameClass)) return Collections.emptySet(); Set<Name> s = new HashSet<Name>(); s.add(((SimpleNameClass)nc).getName()); return s; } protected Set<Name> union(BinaryPattern p) { Set<Name> s1 = p.getOperand1().apply(this); Set<Name> s2 = p.getOperand2().apply(this); if (s1.isEmpty()) return s2; if (s2.isEmpty()) return s1; s1.addAll(s2); return s1; } public Set<Name> caseInterleave(InterleavePattern p) { return union(p); } public Set<Name> caseAfter(AfterPattern p) { return p.getOperand1().apply(this); } public Set<Name> caseOneOrMore(OneOrMorePattern p) { return p.getOperand().apply(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.xml.sax.Locator; import com.thaiopensource.xml.util.Name; class RestrictionViolationException extends Exception { private final String messageId; private Locator loc; private Name name; private String namespaceUri; RestrictionViolationException(String messageId) { this.messageId = messageId; } RestrictionViolationException(String messageId, Name name) { this.messageId = messageId; this.name = name; } RestrictionViolationException(String messageId, String namespaceUri) { this.messageId = messageId; this.namespaceUri = namespaceUri; } String getMessageId() { return messageId; } Locator getLocator() { return loc; } void maybeSetLocator(Locator loc) { if (this.loc == null) this.loc = loc; } Name getName() { return name; } String getNamespaceUri() { return namespaceUri; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.Context; import com.thaiopensource.relaxng.parse.DataPatternBuilder; import com.thaiopensource.relaxng.parse.Div; import com.thaiopensource.relaxng.parse.ElementAnnotationBuilder; import com.thaiopensource.relaxng.parse.Grammar; import com.thaiopensource.relaxng.parse.GrammarSection; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.Include; import com.thaiopensource.relaxng.parse.IncludedGrammar; import com.thaiopensource.relaxng.parse.ParseReceiver; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.parse.ParsedPatternFuture; import com.thaiopensource.relaxng.parse.SchemaBuilder; import com.thaiopensource.relaxng.parse.Scope; import com.thaiopensource.relaxng.parse.SubParseable; import com.thaiopensource.relaxng.parse.SubParser; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.VoidValue; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory; import org.relaxng.datatype.ValidationContext; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class SchemaBuilderImpl extends AnnotationsImpl implements ElementAnnotationBuilder<Locator, VoidValue, CommentListImpl>, SchemaBuilder<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> { private final SchemaBuilderImpl parent; private boolean hadError = false; private final SubParser<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> subParser; private final SchemaPatternBuilder pb; private final DatatypeLibraryFactory datatypeLibraryFactory; private final String inheritNs; private final ErrorHandler eh; private final OpenIncludes openIncludes; private final AttributeNameClassChecker attributeNameClassChecker = new AttributeNameClassChecker(); static final Localizer localizer = new Localizer(SchemaBuilderImpl.class); static class OpenIncludes { final String uri; final OpenIncludes parent; OpenIncludes(String uri, OpenIncludes parent) { this.uri = uri; this.parent = parent; } } static public Pattern parse(Parseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> parseable, ErrorHandler eh, DatatypeLibraryFactory datatypeLibraryFactory, SchemaPatternBuilder pb, boolean isAttributesPattern) throws IllegalSchemaException, IOException, SAXException { try { SchemaBuilderImpl sb = new SchemaBuilderImpl(parseable, eh, new BuiltinDatatypeLibraryFactory(datatypeLibraryFactory), pb); Pattern pattern = parseable.parse(sb, new RootScope(sb)); if (isAttributesPattern) pattern = sb.wrapAttributesPattern(pattern); return sb.expandPattern(pattern); } catch (BuildException e) { throw unwrapBuildException(e); } } static public PatternFuture installHandlers(ParseReceiver<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> parser, XMLReader xr, ErrorHandler eh, DatatypeLibraryFactory dlf, SchemaPatternBuilder pb) throws SAXException { final SchemaBuilderImpl sb = new SchemaBuilderImpl(parser, eh, new BuiltinDatatypeLibraryFactory(dlf), pb); final ParsedPatternFuture<Pattern> pf = parser.installHandlers(xr, sb, new RootScope(sb)); return new PatternFuture() { public Pattern getPattern(boolean isAttributesPattern) throws IllegalSchemaException, SAXException, IOException { try { Pattern pattern = pf.getParsedPattern(); if (isAttributesPattern) pattern = sb.wrapAttributesPattern(pattern); return sb.expandPattern(pattern); } catch (BuildException e) { throw unwrapBuildException(e); } } }; } static public RuntimeException unwrapBuildException(BuildException e) throws SAXException, IllegalSchemaException, IOException { Throwable t = e.getCause(); if (t instanceof IOException) throw (IOException)t; if (t instanceof RuntimeException) return (RuntimeException)t; if (t instanceof IllegalSchemaException) throw new IllegalSchemaException(); if (t instanceof SAXException) throw (SAXException)t; if (t instanceof Exception) throw new SAXException((Exception)t); throw new SAXException(t.getClass().getName() + \" thrown\"); } private Pattern wrapAttributesPattern(Pattern pattern) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import org.xml.sax.Locator; import java.util.List; public class SchemaPatternBuilder extends PatternBuilder { private boolean idTypes; private final UnexpandedNotAllowedPattern unexpandedNotAllowed = new UnexpandedNotAllowedPattern(); private final TextPattern text = new TextPattern(); private final PatternInterner schemaInterner = new PatternInterner(); public SchemaPatternBuilder() { } public boolean hasIdTypes() { return idTypes; } Pattern makeElement(NameClass nameClass, Pattern content, Locator loc) { Pattern p = new ElementPattern(nameClass, content, loc); return schemaInterner.intern(p); } Pattern makeAttribute(NameClass nameClass, Pattern value, Locator loc) { if (value == notAllowed) return value; Pattern p = new AttributePattern(nameClass, value, loc); return schemaInterner.intern(p); } Pattern makeData(Datatype dt, Name dtName, List<String> params) { noteDatatype(dt); Pattern p = new DataPattern(dt, dtName, params); return schemaInterner.intern(p); } Pattern makeDataExcept(Datatype dt, Name dtName, List<String> params, Pattern except, Locator loc) { noteDatatype(dt); Pattern p = new DataExceptPattern(dt, dtName, params, except, loc); return schemaInterner.intern(p); } Pattern makeValue(Datatype dt, Name dtName, Object value, String stringValue) { noteDatatype(dt); Pattern p = new ValuePattern(dt, dtName, value, stringValue); return schemaInterner.intern(p); } Pattern makeText() { return text; } Pattern makeOneOrMore(Pattern p) { if (p == text) return p; return super.makeOneOrMore(p); } Pattern makeUnexpandedNotAllowed() { return unexpandedNotAllowed; } Pattern makeError() { Pattern p = new ErrorPattern(); return schemaInterner.intern(p); } Pattern makeChoice(Pattern p1, Pattern p2) { if (p1 == notAllowed || p1 == p2) return p2; if (p2 == notAllowed) return p1; return super.makeChoice(p1, p2); } Pattern makeList(Pattern p, Locator loc) { if (p == notAllowed) return p; Pattern p1 = new ListPattern(p, loc); return schemaInterner.intern(p1); } Pattern makeMixed(Pattern p) { return makeInterleave(text, p); } private void noteDatatype(Datatype dt) { if (dt.getIdType() != Datatype.ID_TYPE_NULL) idTypes = true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class SimpleNameClass implements NameClass { private final Name name; SimpleNameClass(Name name) { this.name = name; } public boolean contains(Name name) { return this.name.equals(name); } public int containsSpecificity(Name name) { return contains(name) ? SPECIFICITY_NAME : SPECIFICITY_NONE; } public int hashCode() { return name.hashCode(); } public boolean equals(Object obj) { if (obj == null || !(obj instanceof SimpleNameClass)) return false; SimpleNameClass other = (SimpleNameClass)obj; return name.equals(other.name); } Name getName() { return name; } public void accept(NameClassVisitor visitor) { visitor.visitName(name); } public boolean isOpen() { return false; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.ValidationContext; import java.util.List;  class SingleDataDerivType extends DataDerivType { private PatternMemo memo; SingleDataDerivType() { } PatternMemo dataDeriv(ValidatorPatternBuilder builder, Pattern p, String str, ValidationContext vc, List<DataDerivFailure> fail) { if (memo == null) "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class StartAttributeDerivFunction extends StartTagOpenDerivFunction { StartAttributeDerivFunction(Name name, ValidatorPatternBuilder builder) { super(name, builder); } public Pattern caseElement(ElementPattern p) { return getPatternBuilder().makeNotAllowed(); } public Pattern caseGroup(GroupPattern p) { final Pattern p1 = p.getOperand1(); final Pattern p2 = p.getOperand2(); return getPatternBuilder().makeChoice( memoApply(p1).apply(new ApplyAfterFunction(getPatternBuilder()) { Pattern apply(Pattern x) { return getPatternBuilder().makeGroup(x, p2); } }), memoApply(p2).apply(new ApplyAfterFunction(getPatternBuilder()) { Pattern apply(Pattern x) { return getPatternBuilder().makeGroup(p1, x); } })); } public Pattern caseAttribute(AttributePattern p) { if (!p.getNameClass().contains(getName())) return getPatternBuilder().makeNotAllowed(); return getPatternBuilder().makeAfter(p.getContent(), getPatternBuilder().makeEmpty()); } PatternMemo apply(PatternMemo memo) { return memo.startAttributeDeriv(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class StartTagOpenDerivFunction extends AbstractPatternFunction<Pattern> { private final Name name; private final ValidatorPatternBuilder builder; StartTagOpenDerivFunction(Name name, ValidatorPatternBuilder builder) { this.name = name; this.builder = builder; } public Pattern caseChoice(ChoicePattern p) { return builder.makeChoice(memoApply(p.getOperand1()), memoApply(p.getOperand2())); } public Pattern caseGroup(GroupPattern p) { final Pattern p1 = p.getOperand1(); final Pattern p2 = p.getOperand2(); Pattern tem = memoApply(p1).apply(new ApplyAfterFunction(builder) { Pattern apply(Pattern x) { return builder.makeGroup(x, p2); } }); return p1.isNullable() ? builder.makeChoice(tem, memoApply(p2)) : tem; } public Pattern caseInterleave(InterleavePattern p) { final Pattern p1 = p.getOperand1(); final Pattern p2 = p.getOperand2(); return builder.makeChoice( memoApply(p1).apply(new ApplyAfterFunction(builder) { Pattern apply(Pattern x) { return builder.makeInterleave(x, p2); } }), memoApply(p2).apply(new ApplyAfterFunction(builder) { Pattern apply(Pattern x) { return builder.makeInterleave(p1, x); } })); } public Pattern caseAfter(AfterPattern p) { final Pattern p1 = p.getOperand1(); final Pattern p2 = p.getOperand2(); return memoApply(p1).apply(new ApplyAfterFunction(builder) { Pattern apply(Pattern x) { return builder.makeAfter(x, p2); } }); } public Pattern caseOneOrMore(final OneOrMorePattern p) { final Pattern p1 = p.getOperand(); return memoApply(p1).apply(new ApplyAfterFunction(builder) { Pattern apply(Pattern x) { return builder.makeGroup(x, builder.makeOptional(p)); } }); } public Pattern caseElement(ElementPattern p) { if (!p.getNameClass().contains(name)) return builder.makeNotAllowed(); return builder.makeAfter(p.getContent(), builder.makeEmpty()); } public Pattern caseOther(Pattern p) { return builder.makeNotAllowed(); } final Pattern memoApply(Pattern p) { return apply(builder.getPatternMemo(p)).getPattern(); } PatternMemo apply(PatternMemo memo) { return memo.startTagOpenDeriv(this); } Name getName() { return name; } ValidatorPatternBuilder getPatternBuilder() { return builder; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; class StartTagOpenRecoverDerivFunction extends StartTagOpenDerivFunction { StartTagOpenRecoverDerivFunction(Name name, ValidatorPatternBuilder builder) { super(name, builder); } public Pattern caseGroup(GroupPattern p) { Pattern tem = super.caseGroup(p); if (p.getOperand1().isNullable()) return tem; return getPatternBuilder().makeChoice(tem, memoApply(p.getOperand2())); } PatternMemo apply(PatternMemo memo) { return memo.startTagOpenRecoverDeriv(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.datatype.Datatype2; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext; import org.relaxng.datatype.helpers.StreamingValidatorImpl; class StringDatatype implements Datatype2 { public boolean isValid(String str, ValidationContext vc) { return true; } public void checkValid(String str, ValidationContext vc) throws DatatypeException { if (!isValid(str, vc)) throw new DatatypeException(); } public Object createValue(String str, ValidationContext vc) { return str; } public boolean isContextDependent() { return false; } public boolean alwaysValid() { return true; } public int getIdType() { return ID_TYPE_NULL; } public boolean sameValue(Object obj1, Object obj2) { return obj1.equals(obj2); } public int valueHashCode(Object obj) { return obj.hashCode(); } public DatatypeStreamingValidator createStreamingValidator(ValidationContext vc) { return new StreamingValidatorImpl(this, vc); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import java.util.StringTokenizer; class StringNormalizer { static String normalize(String s) { StringBuilder buf = new StringBuilder(); for (StringTokenizer e = new StringTokenizer(s); e.hasMoreElements();) { if (buf.length() > 0) buf.append(' '); buf.append((String)e.nextElement()); } return buf.toString(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; abstract class StringPattern extends Pattern { StringPattern(int hc) { super(false, DATA_CONTENT_TYPE, hc); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class TextOnlyFunction extends EndAttributesFunction { TextOnlyFunction(ValidatorPatternBuilder builder) { super(builder); } public Pattern caseAttribute(AttributePattern p) { return p; } public Pattern caseElement(ElementPattern p) { return getPatternBuilder().makeNotAllowed(); } PatternMemo apply(PatternMemo memo) { return memo.textOnly(this); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class TextPattern extends Pattern { TextPattern() { super(true, MIXED_CONTENT_TYPE, TEXT_HASH_CODE); } boolean samePattern(Pattern other) { return other instanceof TextPattern; } <T> T apply(PatternFunction<T> f) { return f.caseText(this); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case DATA_EXCEPT_CONTEXT: throw new RestrictionViolationException(\"data_except_contains_text\"); case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_text\"); case LIST_CONTEXT: throw new RestrictionViolationException(\"list_contains_text\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import org.relaxng.datatype.ValidationContext; class TokenDatatype extends StringDatatype { public Object createValue(String str, ValidationContext vc) { return StringNormalizer.normalize(str); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; class UnexpandedNotAllowedPattern extends NotAllowedPattern { UnexpandedNotAllowedPattern() { } boolean isNotAllowed() { return false; } Pattern expand(SchemaPatternBuilder b) { return b.makeNotAllowed(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern;  public class UnionNameClassNormalizer extends NameClassNormalizer { public UnionNameClassNormalizer() { super(new NullNameClass()); } public void add(NameClass nameClass) { setNameClass(new ChoiceNameClass(getNameClass(), nameClass)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.util.VoidValue; import com.thaiopensource.xml.util.Name; import java.util.HashMap; import java.util.Map; import java.util.Set; public class ValidatorPatternBuilder extends PatternBuilder { private final Map<Pattern, PatternMemo> patternMemoMap = new HashMap<Pattern, PatternMemo>(); private final PatternFunction<Pattern> endAttributesFunction; private final PatternFunction<Pattern> ignoreMissingAttributesFunction; private final PatternFunction<Pattern> endTagDerivFunction; private final PatternFunction<Pattern> mixedTextDerivFunction; private final PatternFunction<Pattern> textOnlyFunction; private final PatternFunction<Pattern> recoverAfterFunction; private final PatternFunction<DataDerivType> dataDerivTypeFunction; private final Map<Pattern, Pattern> choiceMap = new HashMap<Pattern, Pattern>(); private final PatternFunction<Pattern> removeChoicesFunction = new RemoveChoicesFunction(); private final PatternFunction<VoidValue> noteChoicesFunction = new NoteChoicesFunction(); private final PatternFunction<Set<Name>> requiredElementsFunction = new RequiredElementsFunction(); private final PatternFunction<Set<Name>> requiredAttributesFunction = new RequiredAttributesFunction(); private final PossibleNamesFunction possibleStartTagNamesFunction = new PossibleStartTagNamesFunction(); private final PossibleNamesFunction possibleAttributeNamesFunction = new PossibleAttributeNamesFunction(); private class NoteChoicesFunction extends AbstractPatternFunction<VoidValue> { public VoidValue caseOther(Pattern p) { choiceMap.put(p, p); return VoidValue.VOID; } public VoidValue caseChoice(ChoicePattern p) { p.getOperand1().apply(this); p.getOperand2().apply(this); return VoidValue.VOID; } } private class RemoveChoicesFunction extends AbstractPatternFunction<Pattern> { public Pattern caseOther(Pattern p) { if (choiceMap.get(p) != null) return notAllowed; return p; } public Pattern caseChoice(ChoicePattern p) { Pattern p1 = p.getOperand1().apply(this); Pattern p2 = p.getOperand2().apply(this); if (p1 == p.getOperand1() && p2 == p.getOperand2()) return p; if (p1 == notAllowed) return p2; if (p2 == notAllowed) return p1; Pattern p3 = new ChoicePattern(p1, p2); return interner.intern(p3); } } public ValidatorPatternBuilder(PatternBuilder builder) { super(builder); endAttributesFunction = new EndAttributesFunction(this); ignoreMissingAttributesFunction = new IgnoreMissingAttributesFunction(this); endTagDerivFunction = new EndTagDerivFunction(this); mixedTextDerivFunction = new MixedTextDerivFunction(this); textOnlyFunction = new TextOnlyFunction(this); recoverAfterFunction = new RecoverAfterFunction(this); dataDerivTypeFunction = new DataDerivTypeFunction(this); } PatternMemo getPatternMemo(Pattern p) { PatternMemo memo = patternMemoMap.get(p); if (memo == null) { memo = new PatternMemo(p, this); patternMemoMap.put(p, memo); } return memo; } PatternFunction<Pattern> getEndAttributesFunction() { return endAttributesFunction; } PatternFunction<Pattern> getIgnoreMissingAttributesFunction() { return ignoreMissingAttributesFunction; } PatternFunction<Set<Name>> getRequiredElementsFunction() { return requiredElementsFunction; } PatternFunction<Set<Name>> getRequiredAttributesFunction() { return requiredAttributesFunction; } PossibleNamesFunction getPossibleStartTagNamesFunction() { return possibleStartTagNamesFunction; } PossibleNamesFunction getPossibleAttributeNamesFunction() { return possibleAttributeNamesFunction; } PatternFunction<Pattern> getEndTagDerivFunction() { return endTagDerivFunction; } PatternFunction<Pattern> getMixedTextDerivFunction() { return mixedTextDerivFunction; } PatternFunction<Pattern> getTextOnlyFunction() { return textOnlyFunction; } PatternFunction<Pattern> getRecoverAfterFunction() { return recoverAfterFunction; } PatternFunction<DataDerivType> getDataDerivTypeFunction() { return dataDerivTypeFunction; } Pattern makeAfter(Pattern p1, Pattern p2) { Pattern p = new AfterPattern(p1, p2); return interner.intern(p); } Pattern makeChoice(Pattern p1, Pattern p2) { if (p1 == p2) return p1; if (p1 == notAllowed) return p2; if (p2 == notAllowed) return p1; if (!(p1 instanceof ChoicePattern)) { if (p2.containsChoice(p1)) return p2; } else if (!(p2 instanceof ChoicePattern)) { if (p1.containsChoice(p2)) return p1; } else { p1.apply(noteChoicesFunction); p2 = p2.apply(removeChoicesFunction); if (choiceMap.size() > 0) choiceMap.clear(); } if (p1 instanceof AfterPattern && p2 instanceof AfterPattern) { AfterPattern ap1 = (AfterPattern)p1; AfterPattern ap2 = (AfterPattern)p2; if (ap1.getOperand1() == ap2.getOperand1()) return makeAfter(ap1.getOperand1(), makeChoice(ap1.getOperand2(), ap2.getOperand2())); if (ap1.getOperand1() == notAllowed) return ap2; if (ap2.getOperand1() == notAllowed) return ap1; if (ap1.getOperand2() == ap2.getOperand2()) return makeAfter(makeChoice(ap1.getOperand1(), ap2.getOperand1()), ap1.getOperand2()); } return super.makeChoice(p1, p2); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; import java.util.HashMap; import java.util.List; import java.util.Map;  class ValueDataDerivType extends DataDerivType { private final Datatype dt; private final Name dtName; private PatternMemo noValue; private Map<DatatypeValue, PatternMemo> valueMap; ValueDataDerivType(Datatype dt, Name dtName) { this.dt = dt; this.dtName = dtName; } DataDerivType copy() { return new ValueDataDerivType(dt, dtName); } PatternMemo dataDeriv(ValidatorPatternBuilder builder, Pattern p, String str, ValidationContext vc, List<DataDerivFailure> fail) { Object value = dt.createValue(str, vc); if (value == null) { if (noValue == null) noValue = super.dataDeriv(builder, p, str, vc, fail); else if (fail != null && noValue.isNotAllowed()) { try { dt.checkValid(str, vc); } catch (DatatypeException e) { fail.add(new DataDerivFailure(dt, dtName, e)); } } return noValue; } else { DatatypeValue dtv = new DatatypeValue(value, dt); if (valueMap == null) valueMap = new HashMap<DatatypeValue, PatternMemo>(); PatternMemo tem = valueMap.get(dtv); if (tem == null) { tem = super.dataDeriv(builder, p, str, vc, fail); valueMap.put(dtv, tem); } else if (tem.isNotAllowed() && fail != null) super.dataDeriv(builder, p, str, vc, fail); return tem; } } DataDerivType combine(DataDerivType ddt) { if (ddt instanceof ValueDataDerivType) { if (((ValueDataDerivType)ddt).dt == this.dt) return this; else return InconsistentDataDerivType.getInstance(); } else return ddt.combine(this); } Datatype getDatatype() { return dt; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.pattern; import com.thaiopensource.xml.util.Name; import org.relaxng.datatype.Datatype; class ValuePattern extends StringPattern { private final Object obj; private final Datatype dt; private final Name dtName; private final String stringValue; ValuePattern(Datatype dt, Name dtName, Object obj, String stringValue) { super(combineHashCode(VALUE_HASH_CODE, dt.valueHashCode(obj))); this.dt = dt; this.dtName = dtName; this.obj = obj; this.stringValue = stringValue; } boolean samePattern(Pattern other) { if (getClass() != other.getClass()) return false; if (!(other instanceof ValuePattern)) return false; return (dt.equals(((ValuePattern)other).dt) && dt.sameValue(obj, ((ValuePattern)other).obj)); } <T> T apply(PatternFunction<T> f) { return f.caseValue(this); } void checkRestrictions(int context, DuplicateAttributeDetector dad, Alphabet alpha) throws RestrictionViolationException { switch (context) { case START_CONTEXT: throw new RestrictionViolationException(\"start_contains_value\"); } } Datatype getDatatype() { return dt; } Name getDatatypeName() { return dtName; } Object getValue() { return obj; } String getStringValue() { return stringValue; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.sax; import com.thaiopensource.relaxng.match.MatchContext; import com.thaiopensource.relaxng.parse.sax.DtdContext; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.SAXException; public class Context extends DtdContext implements MatchContext { protected PrefixMapping prefixMapping = new PrefixMapping(\"xml\", WellKnownNamespaces.XML, null); public Context() { } public void startPrefixMapping(String prefix, String uri) throws SAXException { prefixMapping = new PrefixMapping(prefix, \"\".equals(uri) ? null : uri, prefixMapping); } public void endPrefixMapping(String prefix) throws SAXException { prefixMapping = prefixMapping.getPrevious(); } public String getBaseUri() { return null; } protected static final class PrefixMapping { private final String prefix; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.sax; import com.thaiopensource.relaxng.pattern.IdSoundnessChecker; import com.thaiopensource.relaxng.pattern.IdTypeMap; import com.thaiopensource.xml.util.Name; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; public class IdContentHandler implements ContentHandler { private final IdSoundnessChecker checker; private Locator locator; public IdContentHandler(IdTypeMap idTypeMap, ErrorHandler eh) { this.checker = new IdSoundnessChecker(idTypeMap, eh); } public void reset() { checker.reset(); locator = null; } public void setDocumentLocator(Locator locator) { this.locator = locator; } public void startDocument() throws SAXException { } public void endDocument() throws SAXException { checker.endDocument(); setComplete(); } protected void setComplete() { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.sax; import com.thaiopensource.relaxng.match.Matcher; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.PatternMatcher; import com.thaiopensource.relaxng.pattern.ValidatorPatternBuilder; import com.thaiopensource.xml.util.Name; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; public class PatternValidator extends Context implements ContentHandler, DTDHandler { private Matcher matcher; private final ErrorHandler eh; private boolean bufferingCharacters = false; private final StringBuilder charBuf = new StringBuilder(); private Locator locator = null; public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException { if (bufferingCharacters) { bufferingCharacters = false; check(matcher.matchTextBeforeStartTag(charBuf.toString(), this)); } Name name = new Name(namespaceURI, localName); check(matcher.matchStartTagOpen(name, qName, this)); int len = atts.getLength(); for (int i = 0; i < len; i++) { Name attName = new Name(atts.getURI(i), atts.getLocalName(i)); String attQName = atts.getQName(i); check(matcher.matchAttributeName(attName, attQName, this)); check(matcher.matchAttributeValue(atts.getValue(i), attName, attQName, this)); } check(matcher.matchStartTagClose(name, qName, this)); if (matcher.isTextTyped()) { bufferingCharacters = true; charBuf.setLength(0); } } public void endElement(String namespaceURI, String localName, String qName) throws SAXException { if (bufferingCharacters) { bufferingCharacters = false; if (charBuf.length() > 0) check(matcher.matchTextBeforeEndTag(charBuf.toString(), new Name(namespaceURI, localName), qName, this)); } check(matcher.matchEndTag(new Name(namespaceURI, localName), qName, this)); } public void characters(char ch[], int start, int length) throws SAXException { if (bufferingCharacters) { charBuf.append(ch, start, length); return; } for (int i = 0; i < length; i++) { switch (ch[start + i]) { case ' ': case '\\r': case '\\t': case '\\n': break; default: check(matcher.matchUntypedText(this)); return; } } } public void endDocument() throws SAXException { check(matcher.matchEndDocument()); } public void setDocumentLocator(Locator locator) { this.locator = locator; } public void startDocument() throws SAXException { check(matcher.matchStartDocument()); } public void processingInstruction(String target, String date) { } public void skippedEntity(String name) { } public void ignorableWhitespace(char[] ch, int start, int len) { } public void startPrefixMapping(String prefix, String uri) throws SAXException { if (bufferingCharacters) { bufferingCharacters = false; check(matcher.matchTextBeforeStartTag(charBuf.toString(), this)); } super.startPrefixMapping(prefix, uri); } public PatternValidator(Pattern pattern, ValidatorPatternBuilder builder, ErrorHandler eh) { this.matcher = new PatternMatcher(pattern, builder); this.eh = eh; } public void reset() { super.reset(); bufferingCharacters = false; locator = null; matcher = matcher.start(); } private void check(boolean ok) throws SAXException { if (!ok) eh.error(new SAXParseException(matcher.getErrorMessage(), locator)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.util; import com.thaiopensource.resolver.catalog.CatalogResolver; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.OptionParser; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.util.UriOrFile; import com.thaiopensource.util.Version; import com.thaiopensource.validate.Flag; import com.thaiopensource.validate.FlagOption; import com.thaiopensource.validate.OptionArgumentException; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.StringOption; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.ValidationDriver; import com.thaiopensource.validate.auto.AutoSchemaReader; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import com.thaiopensource.xml.sax.ErrorHandlerImpl; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import java.io.IOException; import java.util.ArrayList; import java.util.List; class Driver { static private String usageKey = \"usage\"; static public void setUsageKey(String key) { usageKey = key; } static public void main(String[] args) { System.exit(new Driver().doMain(args)); } private boolean timing = false; private String encoding = null; private Localizer localizer = new Localizer(Driver.class); public int doMain(String[] args) { ErrorHandlerImpl eh = new ErrorHandlerImpl(System.out); OptionParser op = new OptionParser(\"itcdfe:p:sC:\", args); PropertyMapBuilder properties = new PropertyMapBuilder(); properties.put(ValidateProperty.ERROR_HANDLER, eh); RngProperty.CHECK_ID_IDREF.add(properties); SchemaReader sr = null; boolean compact = false; boolean outputSimplifiedSchema = false; List<String> catalogUris = new ArrayList<String>(); try { while (op.moveToNextOption()) { switch (op.getOptionChar()) { case 'i': properties.put(RngProperty.CHECK_ID_IDREF, null); break; case 'C': catalogUris.add(UriOrFile.toUri(op.getOptionArg())); break; case 'c': compact = true; break; case 'd': { if (sr == null) sr = new AutoSchemaReader(); FlagOption option = (FlagOption)sr.getOption(SchemaReader.BASE_URI + \"diagnose\"); if (option == null) { eh.print(localizer.message(\"no_schematron\", op.getOptionCharString())); return 2; } properties.put(option.getPropertyId(), Flag.PRESENT); } break; case 't': timing = true; break; case 'e': encoding = op.getOptionArg(); break; case 'f': RngProperty.FEASIBLE.add(properties); break; case 's': outputSimplifiedSchema = true; break; case 'p': { if (sr == null) sr = new AutoSchemaReader(); StringOption option = (StringOption)sr.getOption(SchemaReader.BASE_URI + \"phase\"); if (option == null) { eh.print(localizer.message(\"no_schematron\", op.getOptionCharString())); return 2; } try { properties.put(option.getPropertyId(), option.valueOf(op.getOptionArg())); } catch (OptionArgumentException e) { eh.print(localizer.message(\"invalid_phase\", op.getOptionArg())); return 2; } } break; } } } catch (OptionParser.InvalidOptionException e) { eh.print(localizer.message(\"invalid_option\", op.getOptionCharString())); return 2; } catch (OptionParser.MissingArgumentException e) { eh.print(localizer.message(\"option_missing_argument\", op.getOptionCharString())); return 2; } if (!catalogUris.isEmpty()) { try { properties.put(ValidateProperty.RESOLVER, new CatalogResolver(catalogUris)); } catch (LinkageError e) { eh.print(localizer.message(\"resolver_not_found\")); return 2; } } if (compact) sr = CompactSchemaReader.getInstance(); args = op.getRemainingArgs(); if (args.length < 1) { eh.print(localizer.message(usageKey, Version.getVersion(Driver.class))); return 2; } long startTime = System.currentTimeMillis(); long loadedPatternTime = -1; boolean hadError = false; try { ValidationDriver driver = new ValidationDriver(properties.toPropertyMap(), sr); InputSource in = ValidationDriver.uriOrFileInputSource(args[0]); if (encoding != null) in.setEncoding(encoding); if (driver.loadSchema(in)) { loadedPatternTime = System.currentTimeMillis(); if (outputSimplifiedSchema) { String simplifiedSchema = driver.getSchemaProperties().get(RngProperty.SIMPLIFIED_SCHEMA); if (simplifiedSchema == null) { eh.print(localizer.message(\"no_simplified_schema\")); hadError = true; } else System.out.print(simplifiedSchema); } for (int i = 1; i < args.length; i++) { if (!driver.validate(ValidationDriver.uriOrFileInputSource(args[i]))) hadError = true; } } else hadError = true; } catch (SAXException e) { hadError = true; eh.printException(e); } catch (IOException e) { hadError = true; eh.printException(e); } if (timing) { long endTime = System.currentTimeMillis(); if (loadedPatternTime < 0) loadedPatternTime = endTime; eh.print(localizer.message(\"elapsed_time\", new Object[] { loadedPatternTime - startTime, endTime - loadedPatternTime, endTime - startTime })); } if (hadError) return 1; return 0; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.util; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.Flag; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.ValidationDriver; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.prop.schematron.SchematronProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import com.thaiopensource.xml.sax.ErrorHandlerImpl; import org.apache.tools.ant.BuildException; import org.apache.tools.ant.DirectoryScanner; import org.apache.tools.ant.Project; import org.apache.tools.ant.Task; import org.apache.tools.ant.types.FileSet; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List;  public class JingTask extends Task { private File schemaFile; private File src; private final List filesets = new ArrayList(); private PropertyMapBuilder properties = new PropertyMapBuilder(); private boolean failOnError = true; private SchemaReader schemaReader = null; private class LogErrorHandler extends ErrorHandlerImpl { int logLevel = Project.MSG_ERR; public void warning(SAXParseException e) throws SAXParseException { logLevel = Project.MSG_WARN; super.warning(e); } public void error(SAXParseException e) { logLevel = Project.MSG_ERR; super.error(e); } public void printException(Throwable e) { logLevel = Project.MSG_ERR; super.printException(e); } public void print(String message) { log(message, logLevel); } } public JingTask() { RngProperty.CHECK_ID_IDREF.add(properties); } public void execute() throws BuildException { if (schemaFile == null) throw new BuildException(\"There must be an rngFile or schemaFile attribute\", getLocation()); if (src == null && filesets.size() == 0) throw new BuildException(\"There must be a file attribute or a fileset child element\", getLocation()); ErrorHandlerImpl eh = new LogErrorHandler(); boolean hadError = false; try { ValidationDriver driver = new ValidationDriver(properties.toPropertyMap(), schemaReader); if (!driver.loadSchema(ValidationDriver.fileInputSource(schemaFile))) hadError = true; else { if (src != null) { if (!driver.validate(ValidationDriver.fileInputSource(src))) hadError = true; } for (int i = 0; i < filesets.size(); i++) { FileSet fs = (FileSet)filesets.get(i); DirectoryScanner ds = fs.getDirectoryScanner(getProject()); File dir = fs.getDir(getProject()); String[] srcs = ds.getIncludedFiles(); for (int j = 0; j < srcs.length; j++) { if (!driver.validate(ValidationDriver.fileInputSource(new File(dir, srcs[j])))) hadError = true; } } } } catch (SAXException e) { hadError = true; eh.printException(e); } catch (IOException e) { hadError = true; eh.printException(e); } if (hadError && failOnError) throw new BuildException(\"Validation failed, messages should have been provided.\", getLocation()); }  public void setRngfile(String rngFilename) { schemaFile = getProject().resolveFile(rngFilename); }  public void setSchemafile(String schemaFilename) { schemaFile = getProject().resolveFile(schemaFilename); } public void setFile(File file) { this.src = file; }  public void setCheckid(boolean checkid) { properties.put(RngProperty.CHECK_ID_IDREF, checkid ? Flag.PRESENT : null); }  public void setCompactsyntax(boolean compactsyntax) { schemaReader = compactsyntax ? CompactSchemaReader.getInstance() : null; }  public void setFeasible(boolean feasible) { properties.put(RngProperty.FEASIBLE, feasible ? Flag.PRESENT : null); }  public void setPhase(String phase) { properties.put(SchematronProperty.PHASE, phase); }  public void setFailonerror(boolean failOnError) { this.failOnError = failOnError; } public void addFileset(FileSet set) { filesets.add(set); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.relaxng.util; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.ValidationDriver; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import com.thaiopensource.xml.sax.XMLReaderCreator; import com.thaiopensource.xml.sax.Sax2XMLReaderCreator; import org.xml.sax.ErrorHandler;  public class ValidationEngine extends ValidationDriver {  public static final int CHECK_ID_IDREF = 01;  public static final int COMPACT_SYNTAX = 02;  public static final int FEASIBLE = 04;  public ValidationEngine() { this(null, null, CHECK_ID_IDREF); }  public ValidationEngine(XMLReaderCreator xrc, ErrorHandler eh, int flags) { super(makePropertyMap(xrc, eh, flags), (flags & COMPACT_SYNTAX) == 0 ? null : CompactSchemaReader.getInstance()); } private static PropertyMap makePropertyMap(XMLReaderCreator xrc, ErrorHandler eh, int flags) { PropertyMapBuilder builder = new PropertyMapBuilder(); if (xrc == null) xrc = new Sax2XMLReaderCreator(); builder.put(ValidateProperty.XML_READER_CREATOR, xrc); if (eh != null) builder.put(ValidateProperty.ERROR_HANDLER, eh); if ((flags & CHECK_ID_IDREF) != 0) RngProperty.CHECK_ID_IDREF.add(builder); if ((flags & FEASIBLE) != 0) RngProperty.FEASIBLE.add(builder); return builder.toPropertyMap(); }  public ValidationEngine(XMLReaderCreator xrc, ErrorHandler eh, boolean checkIdIdref) { this(xrc, eh, checkIdIdref ? CHECK_ID_IDREF : 0); }  public ValidationEngine(XMLReaderCreator xrc, ErrorHandler eh, boolean checkIdIdref, boolean compactSyntax) { this(xrc, eh, (checkIdIdref ? CHECK_ID_IDREF : 0) | (compactSyntax ? COMPACT_SYNTAX : 0)); } public ValidationEngine(XMLReaderCreator xrc, ErrorHandler eh, boolean checkIdIdref, boolean compactSyntax, boolean feasible) { this(xrc, eh, (checkIdIdref ? CHECK_ID_IDREF : 0) | (compactSyntax ? COMPACT_SYNTAX : 0) | (feasible ? FEASIBLE : 0)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver; import java.io.IOException;  public class AbstractResolver implements Resolver { public void resolve(Identifier id, Input input) throws IOException, ResolverException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.io.IOException;  public class BasicResolver implements Resolver { static private final BasicResolver theInstance = new BasicResolver(); protected BasicResolver() { } public static BasicResolver getInstance() { return theInstance; } public void resolve(Identifier id, Input input) throws IOException, ResolverException { if (!input.isResolved()) input.setUri(resolveUri(id)); } public void open(Input input) throws IOException, ResolverException { if (!input.isUriDefinitive()) return; URI uri; try { uri = new URI(input.getUri()); } catch (URISyntaxException e) { throw new ResolverException(e); } if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri); URL url = new URL(uri.toASCIIString()); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver;  public class Identifier { private final String href; private final String base; public Identifier(String href, String base) { if (href == null) throw new NullPointerException(); this.href = href; this.base = base; } public Identifier(String href) { this(href, null); }  public String getUriReference() { return href; }  public String getBase() { return base; }  public String getMediaType() { return \"*/*\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver; import java.io.InputStream; import java.io.Reader;  public class Input { private String uri; private String encoding; private InputStream byteStream; private Reader characterStream; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver;  public class MediaTypedIdentifier extends Identifier { private final String mediaType; public MediaTypedIdentifier(String href, String base, String mediaType) { super(href, base); this.mediaType = mediaType; } public String getMediaType() { return mediaType; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver; import java.io.IOException; public interface Resolver { void resolve(Identifier id, Input input) throws IOException, ResolverException; void open(Input input) throws IOException, ResolverException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver;  public class ResolverException extends Exception { public ResolverException(Throwable t) { super(t); } public ResolverException(String message) { super(message); } public Throwable unwrap() { if (getMessage() == null) { Throwable t = getCause(); if (t != null) return t; } return this; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver; import java.io.IOException;  public class SequenceResolver implements Resolver { private final Resolver r1; private final Resolver r2; public SequenceResolver(Resolver r1, Resolver r2) { this.r1 = r1; this.r2 = r2; } public void resolve(Identifier id, Input input) throws IOException, ResolverException { r1.resolve(id, input); r2.resolve(id, input); } public void open(Input input) throws IOException, ResolverException { r1.open(input); r2.open(input); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.catalog; import org.apache.xml.resolver.helpers.BootstrapResolver; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import java.io.IOException; import java.net.URL;  class CatalogEntityResolver implements EntityResolver { private final EntityResolver entityResolver; CatalogEntityResolver(EntityResolver entityResolver) { this.entityResolver = entityResolver; } public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException { if (BootstrapResolver.xmlCatalogPubId.equals(publicId) || BootstrapResolver.xmlCatalogSysId.equals(systemId)) { URL url = BootstrapResolver.class.getResource(\"/org/apache/xml/resolver/etc/catalog.dtd\"); if (url != null) { InputSource in = new InputSource(url.toString()); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.catalog; import com.thaiopensource.resolver.AbstractResolver; import com.thaiopensource.resolver.BasicResolver; import com.thaiopensource.resolver.Identifier; import com.thaiopensource.resolver.Input; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.ResolverException; import com.thaiopensource.resolver.xml.ExternalDTDSubsetIdentifier; import com.thaiopensource.resolver.xml.ExternalEntityIdentifier; import com.thaiopensource.resolver.xml.ExternalIdentifier; import com.thaiopensource.resolver.xml.sax.SAXResolver; import org.apache.xml.resolver.Catalog; import java.io.IOException; import java.util.List;  public class CatalogResolver extends AbstractResolver { private final Catalog catalog; private boolean catalogLoaded = false; private boolean hadCatalogError = false; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.catalog; import com.thaiopensource.resolver.ResolverException; import com.thaiopensource.resolver.xml.XMLDocumentIdentifier; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.xml.sax.DraconianErrorHandler; import org.apache.xml.resolver.Catalog; import org.apache.xml.resolver.CatalogManager; import org.apache.xml.resolver.readers.OASISXMLCatalogReader; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.sax.SAXSource; import java.io.IOException; import java.net.URL;  class OasisCatalog extends Catalog { private final SAXResolver saxResolver; OasisCatalog(CatalogManager catalogManager, SAXResolver saxResolver) { super(catalogManager); this.saxResolver = saxResolver; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.catalog; import com.thaiopensource.resolver.ResolverException; import java.io.IOException;  public class ResolverIOException extends IOException { private final ResolverException resolverException; public ResolverIOException(ResolverException resolverException) { this.resolverException = resolverException; } public ResolverException getResolverException() { return resolverException; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.catalog; import org.apache.xml.resolver.CatalogManager; import java.util.List; import java.util.Vector;  class SimpleCatalogManager extends CatalogManager { private final Vector<String> catalogUris; SimpleCatalogManager(List<String> catalogUris) { this.catalogUris = new Vector<String>(); this.catalogUris.addAll(catalogUris); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.load;  public class ResolverLoadException extends Exception { public ResolverLoadException(String message) { super(message); } public ResolverLoadException(Throwable cause) { super(cause); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.load; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.SequenceResolver; import com.thaiopensource.resolver.xml.sax.SAX; import com.thaiopensource.resolver.xml.transform.Transform; import org.xml.sax.EntityResolver; import javax.xml.transform.URIResolver;  public class ResolverLoader { public static Resolver loadResolver(String className, ClassLoader loader) throws ResolverLoadException { Object obj; try { if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); if (loader == null) { loader = ClassLoader.getSystemClassLoader(); if (loader == null) throw new ResolverLoadException(\"no class loader\"); } } obj = loader.loadClass(className).newInstance(); } catch (Exception e) { throw new ResolverLoadException(e); } if (obj instanceof Resolver) return (Resolver)obj; Resolver entityResolver = null; Resolver uriResolver = null; if (obj instanceof URIResolver) uriResolver = Transform.createResolver((URIResolver)obj); if (obj instanceof EntityResolver) entityResolver = SAX.createResolver((EntityResolver)obj, uriResolver == null); if (uriResolver == null) { if (entityResolver == null) throw new ResolverLoadException(className + \" not an instance of javax.xml.transform.URIResolver or org.xml.sax.EntityResolver\"); return entityResolver; } if (entityResolver == null) return uriResolver; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml;  public class ExternalDTDSubsetIdentifier extends ExternalIdentifier { private final String doctypeName; public ExternalDTDSubsetIdentifier(String href, String base, String publicId, String doctypeName) { super(href, base, publicId); this.doctypeName = doctypeName; } public String getDoctypeName() { return doctypeName; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml;  public class ExternalEntityIdentifier extends ExternalIdentifier { private final String entityName;  public ExternalEntityIdentifier(String href, String base, String publicId, String entityName) { super(href, base, publicId); this.entityName = entityName; } public String getEntityName() { return entityName; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml; import com.thaiopensource.resolver.Identifier;  public class ExternalIdentifier extends Identifier { private final String publicId; public ExternalIdentifier(String href, String base, String publicId) { super(href, base); this.publicId = publicId; } public String getPublicId() { return publicId; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml;  public interface TargetNamespaceIdentifier { public String getTargetNamespace(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml; import com.thaiopensource.resolver.Identifier;  public class XMLDocumentIdentifier extends Identifier { private final String namespaceUri; public static final String MEDIA_TYPE = \"application/xml\";  public XMLDocumentIdentifier(String href, String base, String namespaceUri) { super(href, base); this.namespaceUri = namespaceUri; }  public String getNamespaceUri() { return namespaceUri; } public String getMediaType() { return MEDIA_TYPE; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml.ls; import com.thaiopensource.resolver.AbstractResolver; import com.thaiopensource.resolver.Identifier; import com.thaiopensource.resolver.Input; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.ResolverException; import com.thaiopensource.resolver.xml.ExternalIdentifier; import com.thaiopensource.resolver.xml.TargetNamespaceIdentifier; import com.thaiopensource.resolver.xml.XMLDocumentIdentifier; import org.w3c.dom.ls.LSInput; import org.w3c.dom.ls.LSResourceResolver; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.io.StringReader;  public class LS { private static final String XML_TYPE = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml.sax; import com.thaiopensource.resolver.AbstractResolver; import com.thaiopensource.resolver.BasicResolver; import com.thaiopensource.resolver.Identifier; import com.thaiopensource.resolver.Input; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.ResolverException; import com.thaiopensource.resolver.xml.ExternalDTDSubsetIdentifier; import com.thaiopensource.resolver.xml.ExternalEntityIdentifier; import com.thaiopensource.resolver.xml.ExternalIdentifier; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.ext.EntityResolver2; import java.io.IOException;  public class SAX { private SAX() { } private static final class EntityResolverWrapper extends AbstractResolver { private final EntityResolver entityResolver; private final EntityResolver2 entityResolver2; private final boolean promiscuous; private EntityResolverWrapper(EntityResolver entityResolver, boolean promiscuous) { this.entityResolver = entityResolver; if (entityResolver instanceof EntityResolver2) entityResolver2 = (EntityResolver2)entityResolver; else entityResolver2 = null; this.promiscuous = promiscuous; } public void resolve(Identifier id, Input input) throws IOException, ResolverException { if (input.isResolved()) return; String publicId; String entityName = null; if (id instanceof ExternalIdentifier) { publicId = ((ExternalIdentifier)id).getPublicId(); if (id instanceof ExternalEntityIdentifier) entityName = ((ExternalEntityIdentifier)id).getEntityName(); else if (id instanceof ExternalDTDSubsetIdentifier) entityName = \"[dtd]\"; } else { if (!promiscuous) return; publicId = null; } try { InputSource inputSource; if (entityName != null && entityResolver2 != null) inputSource = entityResolver2.resolveEntity(entityName, publicId, id.getBase(), id.getUriReference()); else inputSource = entityResolver.resolveEntity(publicId, getSystemId(id)); if (inputSource != null) setInput(input, inputSource); } catch (SAXException e) { throw toResolverException(e); } } } public static Resolver createResolver(final EntityResolver entityResolver, boolean promiscuous) { return new EntityResolverWrapper(entityResolver, promiscuous); } public static EntityResolver2 createEntityResolver(Resolver resolver) { if (resolver == null) throw new NullPointerException(); return new EntityResolverImpl(resolver); } public static Input createInput(InputSource inputSource) { Input input = new Input(); setInput(input, inputSource); return input; } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml.sax; import com.thaiopensource.resolver.Input; import org.xml.sax.XMLReader;  public class SAXInput extends Input { private XMLReader reader; public XMLReader getXMLReader() { return reader; } public void setXMLReader(XMLReader reader) { this.reader = reader; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml.sax; import com.thaiopensource.resolver.BasicResolver; import com.thaiopensource.resolver.Identifier; import com.thaiopensource.resolver.Input; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.ResolverException; import com.thaiopensource.resolver.SequenceResolver; import com.thaiopensource.resolver.xml.XMLDocumentIdentifier; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.parsers.ParserConfigurationException; import javax.xml.parsers.SAXParserFactory; import javax.xml.transform.sax.SAXSource; import java.io.IOException;  public class SAXResolver { private final Resolver resolver; private final SAXParserFactory parserFactory; public SAXResolver(Resolver resolver) { Resolver tem = BasicResolver.getInstance(); if (resolver != null) tem = new SequenceResolver(resolver, tem); this.resolver = tem; parserFactory = SAXParserFactory.newInstance(); parserFactory.setNamespaceAware(true); parserFactory.setValidating(false); } public SAXResolver() { this(null); } public Resolver getResolver() { return resolver; } public SAXSource resolve(String href, String base) throws SAXException, IOException { return resolve(new Identifier(href, base)); } public SAXSource resolve(String href, String base, String rootNamespaceUri) throws SAXException, IOException { return resolve(new XMLDocumentIdentifier(href, base, rootNamespaceUri)); } public SAXSource resolve(Identifier id) throws SAXException, IOException { SAXInput input = new SAXInput(); try { resolver.resolve(id, input); if (!input.isResolved()) input.setUri(BasicResolver.resolveUri(id)); InputSource inputSource = SAX.createInputSource(id, input); XMLReader xr = input.getXMLReader(); if (xr == null) xr = createXMLReader(); return new SAXSource(xr, inputSource); } catch (ResolverException e) { throw SAX.toSAXException(e); } } public SAXSource createSAXSource(Input input) throws SAXException { InputSource inputSource = SAX.createInputSource(input); XMLReader xr = null; if (input instanceof SAXInput) xr = ((SAXInput)input).getXMLReader(); if (xr == null) xr = createXMLReader(); return new SAXSource(xr, inputSource); } public XMLReader createXMLReader() throws SAXException { XMLReader xr = createXMLReaderWithoutResolver(); xr.setEntityResolver(SAX.createEntityResolver(resolver)); return xr; } protected XMLReader createXMLReaderWithoutResolver() throws SAXException { try { return parserFactory.newSAXParser().getXMLReader(); } catch (ParserConfigurationException e) { throw new SAXException(e); } } public InputSource open(InputSource inputSource) throws SAXException, IOException { if (inputSource.getByteStream() != null || inputSource.getCharacterStream() != null) return inputSource; Input input = SAX.createInput(inputSource); try { resolver.open(input); } catch (ResolverException e) { throw SAX.toSAXException(e); } String publicId = inputSource.getPublicId(); inputSource = SAX.createInputSource(input); inputSource.setPublicId(publicId); return inputSource; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.resolver.xml.transform; import com.thaiopensource.resolver.AbstractResolver; import com.thaiopensource.resolver.Identifier; import com.thaiopensource.resolver.Input; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.ResolverException; import com.thaiopensource.resolver.xml.sax.SAX; import com.thaiopensource.resolver.xml.sax.SAXInput; import com.thaiopensource.resolver.xml.sax.SAXResolver; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.Source; import javax.xml.transform.TransformerException; import javax.xml.transform.URIResolver; import javax.xml.transform.sax.SAXSource; import java.io.IOException;  public class Transform { private Transform() { }  public static URIResolver createSAXURIResolver(Resolver resolver) { final SAXResolver saxResolver = new SAXResolver(resolver); return new URIResolver() { public Source resolve(String href, String base) throws TransformerException { try { return saxResolver.resolve(href, base); } catch (SAXException e) { throw toTransformerException(e); } catch (IOException e) { throw new TransformerException(e); } } }; } public static Resolver createResolver(final URIResolver uriResolver) { return new AbstractResolver() { public void resolve(Identifier id, Input input) throws IOException, ResolverException { if (input.isResolved()) return; Source source; try { source = uriResolver.resolve(id.getUriReference(), id.getBase()); } catch (TransformerException e) { throw toResolverException(e); } if (source == null) return; if (source instanceof SAXSource) { setInput(input, (SAXSource)source); return; } InputSource in = SAXSource.sourceToInputSource(source); if (in != null) { SAX.setInput(input, in); return; } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; public class Equal { private Equal() { } static public boolean equal(Object obj1, Object obj2) { return obj1 == null ? obj2 == null : obj1.equals(obj2); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; import java.util.ResourceBundle; import java.text.MessageFormat; public class Localizer { private final Class<?> cls; private ResourceBundle bundle; public Localizer(Class<?> cls) { this.cls = cls; } public String message(String key) { return MessageFormat.format(getBundle().getString(key), new Object[]{}); } public String message(String key, Object arg) { return MessageFormat.format(getBundle().getString(key), new Object[]{arg}); } public String message(String key, Object arg1, Object arg2) { return MessageFormat.format(getBundle().getString(key), new Object[]{arg1, arg2}); } public String message(String key, Object[] args) { return MessageFormat.format(getBundle().getString(key), args); } private ResourceBundle getBundle() { if (bundle == null){ String s = cls.getName(); int i = s.lastIndexOf('.'); if (i > 0) s = s.substring(0, i + 1); else s = \"\"; bundle = ResourceBundle.getBundle(s + \"resources.Messages\"); } return bundle; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; public class OptionParser { private final String optionSpec; private char optionChar = 0; private String optionArg = null; private int argIndex = 0; private int currentOptionIndex = 0; private final String[] args; private static final char OPTION_CHAR = '-'; public static class MissingArgumentException extends Exception { } public static class InvalidOptionException extends Exception { } public OptionParser(String optionSpec, String[] args) { this.optionSpec = optionSpec; this.args = new String[args.length]; System.arraycopy(args, 0, this.args, 0, args.length); } public char getOptionChar() { return optionChar; } public String getOptionCharString() { return new String(new char[]{optionChar}); } public String getOptionArg() { return optionArg; } public boolean moveToNextOption() throws InvalidOptionException, MissingArgumentException { if (currentOptionIndex > 0 && currentOptionIndex == args[argIndex].length()) { currentOptionIndex = 0; argIndex++; } if (currentOptionIndex == 0) { if (argIndex >= args.length) return false; String arg = args[argIndex]; if (arg.length() < 2 || arg.charAt(0) != OPTION_CHAR) return false; if (arg.length() == 2 && arg.charAt(1) == OPTION_CHAR) { argIndex++; return false; } currentOptionIndex = 1; } optionChar = args[argIndex].charAt(currentOptionIndex++); optionArg = null; int i = optionSpec.indexOf(optionChar); if (i < 0 || (optionChar == ':' && i > 0)) throw new InvalidOptionException(); if (i + 1 < optionSpec.length() && optionSpec.charAt(i + 1) == ':') { if (currentOptionIndex < args[argIndex].length()) { optionArg = args[argIndex].substring(currentOptionIndex); currentOptionIndex = 0; argIndex++; } else if (argIndex + 1 < args.length) { optionArg = args[++argIndex]; ++argIndex; currentOptionIndex = 0; } else throw new MissingArgumentException(); } return true; } public String[] getRemainingArgs() { String[] tem = new String[args.length - argIndex]; System.arraycopy(args, argIndex, tem, 0, tem.length); return tem; } public static void main(String[] args) { String optSpec = args[0]; String[] tem = new String[args.length - 1]; System.arraycopy(args, 1, tem, 0, tem.length); args = tem; OptionParser opts = new OptionParser(optSpec, args); try { while (opts.moveToNextOption()) { System.err.print(\"option \" + opts.getOptionChar()); String arg = opts.getOptionArg(); if (arg == null) System.err.println(\" (no argument)\"); else System.err.println(\" arg=\" + arg); } args = opts.getRemainingArgs(); for (int i = 0; i < args.length; i++) System.err.println(\"arg=\" + args[i]); } catch (OptionParser.MissingArgumentException e) { System.err.println(\"missing argument for option \" + opts.getOptionChar()); } catch (OptionParser.InvalidOptionException e) { System.err.println(\"invalid option \" + opts.getOptionChar()); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; public class PropertyId<T> { private final String name; private final Class<T> valueClass; public static <T> PropertyId<T> newInstance(String name, Class<T> valueClass) { return new PropertyId<T>(name, valueClass); } protected PropertyId(String name, Class<T> valueClass) { if (name == null || valueClass == null) throw new NullPointerException(); this.name = name; this.valueClass = valueClass; } public Class<T> getValueClass() { return valueClass; } public final int hashCode() { return super.hashCode(); } public final boolean equals(Object obj) { return super.equals(obj); } public String toString() { return name; }  public T get(PropertyMap map) { return map.get(this); }  public T put(PropertyMapBuilder builder, T value) { return builder.put(this, value); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; public interface PropertyMap { public static final PropertyMap EMPTY = new PropertyMap() { public <T> T get(PropertyId<T> pid) { return null; } public boolean contains(PropertyId<?> pid) { return false; } public int size() { return 0; } public PropertyId<?> getKey(int i) { throw new IndexOutOfBoundsException(); } }; <T> T get(PropertyId<T> pid); boolean contains(PropertyId<?> pid); int size(); PropertyId<?> getKey(int i); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; import java.util.HashMap; import java.util.Map; public class PropertyMapBuilder { private Map<PropertyId<?>, Object> map; private PropertyId<?>[] keys; private static class PropertyMapImpl implements PropertyMap { private final Map<PropertyId<?>, Object> map; private final PropertyId<?>[] keys; private PropertyMapImpl(Map<PropertyId<?>, Object> map, PropertyId<?>[] keys) { this.map = map; this.keys = keys; } public <T> T get(PropertyId<T> pid) { return pid.getValueClass().cast(map.get(pid)); } public int size() { return keys.length; } public boolean contains(PropertyId<?> pid) { return map.get(pid) != null; } public PropertyId<?> getKey(int i) { return keys[i]; } } public PropertyMapBuilder() { this.map = new HashMap<PropertyId<?>, Object>(); } public PropertyMapBuilder(PropertyMap pm) { if (pm instanceof PropertyMapImpl) { PropertyMapImpl pmi = (PropertyMapImpl)pm; this.map = pmi.map; this.keys = pmi.keys; } else { this.map = new HashMap<PropertyId<?>, Object>(); add(pm); } } public void add(PropertyMap pm) { for (int i = 0, len = pm.size(); i < len; i++) copy(pm.getKey(i), pm); } private <T> void copy(PropertyId<T> pid, PropertyMap pm) { put(pid, pm.get(pid)); } private void lock() { if (keys != null) return; keys = new PropertyId<?>[map.size()]; int i = 0; for (PropertyId<?> propertyId : map.keySet()) keys[i++] = propertyId; } private void copyIfLocked() { if (keys == null) return; Map<PropertyId<?>, Object> newMap = new HashMap<PropertyId<?>, Object>(); for (int i = 0; i < keys.length; i++) newMap.put(keys[i], map.get(keys[i])); map = newMap; keys = null; } public PropertyMap toPropertyMap() { lock(); return new PropertyMapImpl(map, keys); } public <T> T put(PropertyId<T> id, T value) { copyIfLocked(); final Class<T> cls = id.getValueClass(); if (value == null) return cls.cast(map.remove(id)); return cls.cast(map.put(id, cls.cast(value))); } public <T> T get(PropertyId<T> pid) { return pid.getValueClass().cast(map.get(pid)); } public boolean contains(PropertyId<?> pid) { return map.get(pid) != null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util;  public class Ref<T> { private T obj; public Ref() { } public Ref(T obj) { this.obj = obj; } public T get() { return obj; } public void set(T obj) { this.obj = obj; } public void clear() { this.obj = null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.io.UnsupportedEncodingException; import java.net.URL; import java.util.ArrayList; import java.util.Enumeration; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; public final class Service<T> { private final Class<T> serviceClass; private final Enumeration<URL> configFiles; private Iterator<String> classNames = null; private final List<T> providers = new ArrayList<T>(); private Loader loader; private class ProviderIterator implements Iterator<T> { private int nextIndex = 0; public boolean hasNext() { return nextIndex < providers.size() || moreProviders(); } public T next() { try { return providers.get(nextIndex++); } catch (IndexOutOfBoundsException e) { throw new NoSuchElementException(); } } public void remove() { throw new UnsupportedOperationException(); } } private static class Singleton<T> implements Enumeration<T> { private T obj; private Singleton(T obj) { this.obj = obj; } public boolean hasMoreElements() { return obj != null; } public T nextElement() { if (obj == null) throw new NoSuchElementException(); T tem = obj; obj = null; return tem; } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; public class SinglePropertyMap<T> implements PropertyMap { private final PropertyId<T> pid; private final T value; private SinglePropertyMap(PropertyId<T> pid, T value) { if (!(pid.getValueClass().isInstance(value))) { if (value == null) throw new NullPointerException(); throw new ClassCastException(); } this.pid = pid; this.value = value; } public <V> V get(PropertyId<V> pid) { if (pid != this.pid) return null; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; import java.net.URI; import java.net.URISyntaxException; public class Uri {  public static boolean isValid(String s) { try { new URI(UriEncoder.encode(s)); } catch (URISyntaxException e) { return false; } return true; } public static String escapeDisallowedChars(String s) { return UriEncoder.encodeAsAscii(s); } public static String resolve(String base, String uriReference) { if (!isAbsolute(uriReference) && base != null && isAbsolute(base)) { try { URI baseURI = new URI(UriEncoder.encode(base)); return baseURI.resolve(new URI(UriEncoder.encode(uriReference))).toString(); } catch (URISyntaxException e) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util;  public class UriEncoder {  static private final int C0_CONTROL = 0x01;  static private final int SPACE = 0x02;  static private final int DELIM = 0x04;  static private final int UNWISE = 0x08;  static private final int DELETE = 0x10;  static private final int C1_CONTROL = 0x20;  static private final int NON_ASCII_SEPARATOR = 0x40;  static private final int OTHER_NON_ASCII = 0x80; static private final int ASCII_CONTROL = C0_CONTROL|DELETE; static private final int CONTROL = ASCII_CONTROL|C1_CONTROL; static private final int SEPARATOR = NON_ASCII_SEPARATOR|SPACE; static private final int ASCII_GRAPHIC_FORBIDDEN = DELIM|UNWISE; static private final int ASCII_PRINTABLE_FORBIDDEN = ASCII_GRAPHIC_FORBIDDEN|SPACE; static private final int ASCII_FORBIDDEN = ASCII_CONTROL|ASCII_PRINTABLE_FORBIDDEN; static private final int NON_ASCII = C1_CONTROL|NON_ASCII_SEPARATOR|OTHER_NON_ASCII; static private final int JAVA_URI_FORBIDDEN = CONTROL|SEPARATOR|ASCII_PRINTABLE_FORBIDDEN; static private final int URI_FORBIDDEN = ASCII_FORBIDDEN|NON_ASCII; static public String encode(String s) { return encode(s, JAVA_URI_FORBIDDEN); } static public String encodeAsAscii(String s) { return encode(s, URI_FORBIDDEN); } static private String encode(String s, int flags) { StringBuffer encoded = null; final int len = s.length(); for (int i = 0; i < len; i++) { char c = s.charAt(i); boolean mustEncode; switch (c) { case '<': case '>': case '\"': mustEncode = ((flags & DELIM) != 0); break; case '{': case '}': case '|': case '\\\\': case '^': case '`': mustEncode = ((flags & UNWISE) != 0); break; case 0x20: mustEncode = ((flags & SPACE) != 0); break; case 0x7F: mustEncode = ((flags & DELETE) != 0); break; default: if (c < 0x20) mustEncode = ((flags & C0_CONTROL) != 0); else if (c < 0x80) mustEncode = false; else { switch (flags & NON_ASCII) { case NON_ASCII: "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; import java.io.File; import java.net.URI; import java.net.URISyntaxException; public class UriOrFile { private UriOrFile() { } public static String toUri(String uriOrFile) { String scheme = getScheme(uriOrFile); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; public abstract class Utf16 { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util;  public class Utf8 { private Utf8() { } static public byte[] encode(int c) { if (c < 0x80) return new byte[] { (byte)c }; byte[] buf; if (c < 0x800) { buf = new byte[2]; buf[0] = (byte)((c >> 6) | (0x80 | 0x40)); } else if (c < 0x10000) { buf = new byte[3]; buf[0] = (byte)((c >> (2 * 6)) | (0x80 | 0x40 | 0x20)); } else { buf = new byte[4]; buf[0] = (byte)((c >> (3 * 6)) | (0x80 | 0x40 | 0x20 | 0x10)); } for (int i = buf.length - 1; i > 0; i--) { buf[i] = (byte)((c & 0x3F) | 0x80); c >>= 6; } return buf; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; import java.io.InputStream; import java.io.IOException; import java.util.Properties; import java.util.MissingResourceException; public class Version { private Version() { } public static String getVersion(Class<?> cls) { InputStream in = cls.getResourceAsStream(\"resources/Version.properties\"); if (in != null) { Properties props = new Properties(); try { props.load(in); String version = props.getProperty(\"version\"); if (version != null) return version; } catch (IOException e) { } } throw new MissingResourceException(\"no version property\", cls.getName(), \"version\"); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.util; public class VoidValue { public static VoidValue VOID = new VoidValue(); private VoidValue() { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMapBuilder; public abstract class AbstractSchema implements Schema { private final PropertyMap properties; public AbstractSchema() { this(PropertyMap.EMPTY); } public AbstractSchema(PropertyMap properties) { this.properties = properties; } public AbstractSchema(PropertyMap properties, PropertyId<?>[] supportedPropertyIds) { this(filterProperties(properties, supportedPropertyIds)); } public PropertyMap getProperties() { return properties; } static public PropertyMap filterProperties(PropertyMap properties, PropertyId<?>[] supportedPropertyIds) { PropertyMapBuilder builder = new PropertyMapBuilder(); for (int i = 0; i < supportedPropertyIds.length; i++) copy(builder, supportedPropertyIds[i], properties); return builder.toPropertyMap(); } static private <T> void copy(PropertyMapBuilder builder, PropertyId<T> pid, PropertyMap properties) { T value = properties.get(pid); if (value != null) builder.put(pid, value); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyMap; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import javax.xml.transform.sax.SAXSource; import java.io.IOException; public abstract class AbstractSchemaReader implements SchemaReader { public Schema createSchema(InputSource in, PropertyMap properties) throws IOException, SAXException, IncorrectSchemaException { return createSchema(new SAXSource(in), properties); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.Validator; public class CombineSchema extends AbstractSchema { private final Schema schema1; private final Schema schema2; public CombineSchema(Schema schema1, Schema schema2, PropertyMap properties) { super(properties); this.schema1 = schema1; this.schema2 = schema2; } public Validator createValidator(PropertyMap properties) { return new CombineValidator(schema1.createValidator(properties), schema2.createValidator(properties)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.xml.sax.ForkContentHandler; import com.thaiopensource.xml.sax.ForkDTDHandler; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; public class CombineValidator implements Validator { private final Validator v1; private final Validator v2; private ContentHandler contentHandler; private DTDHandler dtdHandler; public CombineValidator(Validator v1, Validator v2) { this.v1 = v1; this.v2 = v2; createHandlers(); } public void reset() { v1.reset(); v2.reset(); createHandlers(); } public ContentHandler getContentHandler() { return contentHandler; } public DTDHandler getDTDHandler() { return dtdHandler; } private void createHandlers() { contentHandler = new ForkContentHandler(v1.getContentHandler(), v2.getContentHandler()); DTDHandler d1 = v1.getDTDHandler(); DTDHandler d2 = v2.getDTDHandler(); if (d1 != null && d2 != null) dtdHandler = new ForkDTDHandler(d1, d2); else if (d1 != null) dtdHandler = d1; else if (d2 != null) dtdHandler = d2; else dtdHandler = null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate;  public class Flag { private Flag() { }  public static final Flag PRESENT = new Flag(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; public class FlagOption implements Option { private final FlagPropertyId pid; public FlagOption(FlagPropertyId pid) { this.pid = pid; } public FlagPropertyId getPropertyId() { return pid; } public Flag valueOf(String arg) throws OptionArgumentException { if (arg != null) throw new OptionArgumentPresenceException(); return Flag.PRESENT; } public Object combine(Object[] values) { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMapBuilder;  public class FlagPropertyId extends PropertyId<Flag> { public FlagPropertyId(String name) { super(name, Flag.class); }  public void add(PropertyMapBuilder builder) { builder.put(this, Flag.PRESENT); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate;  public class IncorrectSchemaException extends Exception { }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyId; public interface Option { PropertyId<?> getPropertyId(); Object valueOf(String arg) throws OptionArgumentException;  Object combine(Object[] values); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; public class OptionArgumentException extends Exception { public OptionArgumentException() { } public OptionArgumentException(String message) { super(message); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; public class OptionArgumentFormatException extends OptionArgumentException { public OptionArgumentFormatException() { } public OptionArgumentFormatException(String message) { super(message); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; public class OptionArgumentPresenceException extends OptionArgumentException { public OptionArgumentPresenceException() { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.SequenceResolver; import com.thaiopensource.resolver.xml.sax.SAX; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.resolver.xml.transform.Transform; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.xml.sax.XMLReaderCreator; import org.xml.sax.EntityResolver; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.URIResolver; public class ResolverFactory { static private class CustomSAXResolver extends SAXResolver { private final XMLReaderCreator xrc; private CustomSAXResolver(Resolver resolver, XMLReaderCreator xrc) { super(resolver); this.xrc = xrc; } protected XMLReader createXMLReaderWithoutResolver() throws SAXException { return xrc.createXMLReader(); } } static public SAXResolver createResolver(PropertyMap properties) { Resolver[] resolvers = new Resolver[4]; int i = 0; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyMap;  public interface Schema {  Validator createValidator(PropertyMap properties); PropertyMap getProperties(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyMap; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import javax.xml.transform.sax.SAXSource; import java.io.IOException;  public interface SchemaReader { public static final String BASE_URI = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.validate.SchemaReader;  public interface SchemaReaderFactory {  public SchemaReader createSchemaReader(String namespaceUri); Option getOption(String uri); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.Service; import java.util.Iterator;  public class SchemaReaderLoader implements SchemaReaderFactory { private final Service<SchemaReaderFactory> service = Service.newInstance(SchemaReaderFactory.class); public SchemaReader createSchemaReader(String namespaceUri) { for (Iterator<SchemaReaderFactory> iter = service.getProviders(); iter.hasNext();) { SchemaReaderFactory srf = iter.next(); SchemaReader sr = srf.createSchemaReader(namespaceUri); if (sr != null) return sr; } return null; } public Option getOption(String uri) { for (Iterator<SchemaReaderFactory> iter = service.getProviders(); iter.hasNext();) { SchemaReaderFactory srf = iter.next(); Option option = srf.getOption(uri); if (option != null) return option; } return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; public class StringOption implements Option { private final StringPropertyId pid; public StringOption(StringPropertyId pid) { this.pid = pid; } public StringPropertyId getPropertyId() { return pid; } public String valueOf(String arg) throws OptionArgumentException { if (arg == null) return defaultValue(); return normalize(arg); } public String defaultValue() throws OptionArgumentPresenceException { throw new OptionArgumentPresenceException(); } public String normalize(String value) throws OptionArgumentFormatException { return value; } public Object combine(Object[] values) { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyId;  public class StringPropertyId extends PropertyId<String> { public StringPropertyId(String name) { super(name, String.class); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.xml.sax.XMLReaderCreator; import org.xml.sax.EntityResolver; import org.xml.sax.ErrorHandler; import javax.xml.transform.URIResolver;  public class ValidateProperty { private ValidateProperty() { }  public static final PropertyId<ErrorHandler> ERROR_HANDLER = PropertyId.newInstance(\"ERROR_HANDLER\", ErrorHandler.class);  public static PropertyId<EntityResolver> ENTITY_RESOLVER = PropertyId.newInstance(\"ENTITY_RESOLVER\", EntityResolver.class);  public static final PropertyId<URIResolver> URI_RESOLVER = PropertyId.newInstance(\"URI_RESOLVER\", URIResolver.class);  public static final PropertyId<Resolver> RESOLVER = PropertyId.newInstance(\"RESOLVER\", Resolver.class);  public static final PropertyId<XMLReaderCreator> XML_READER_CREATOR = PropertyId.newInstance(\"XML_READER_CREATOR\", XMLReaderCreator.class); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.util.UriOrFile; import com.thaiopensource.validate.auto.AutoSchemaReader; import com.thaiopensource.xml.sax.CountingErrorHandler; import com.thaiopensource.xml.sax.ErrorHandlerImpl; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.sax.SAXSource; import java.io.File; import java.io.IOException;  public class ValidationDriver { private XMLReader xr; private final CountingErrorHandler eh; private final SchemaReader sr; private final PropertyMap schemaProperties; private final PropertyMap instanceProperties; private Validator validator; private Schema schema;  public ValidationDriver(PropertyMap schemaProperties, PropertyMap instanceProperties, SchemaReader schemaReader) { ErrorHandler seh = schemaProperties.get(ValidateProperty.ERROR_HANDLER); PropertyMapBuilder builder; if (seh == null) { seh = new ErrorHandlerImpl(); builder = new PropertyMapBuilder(schemaProperties); builder.put(ValidateProperty.ERROR_HANDLER, seh); this.schemaProperties = builder.toPropertyMap(); } else this.schemaProperties = schemaProperties; builder = new PropertyMapBuilder(instanceProperties); ErrorHandler ieh = instanceProperties.get(ValidateProperty.ERROR_HANDLER); if (ieh == null) ieh = seh; eh = new CountingErrorHandler(ieh); builder.put(ValidateProperty.ERROR_HANDLER, eh); this.instanceProperties = builder.toPropertyMap(); this.sr = schemaReader == null ? new AutoSchemaReader() : schemaReader; }  public ValidationDriver(PropertyMap schemaProperties, PropertyMap instanceProperties) { this(schemaProperties, instanceProperties, null); }  public ValidationDriver(PropertyMap properties, SchemaReader sr) { this(properties, properties, sr); }  public ValidationDriver(PropertyMap properties) { this(properties, properties, null); }  public ValidationDriver(SchemaReader sr) { this(PropertyMap.EMPTY, sr); }  public ValidationDriver() { this(PropertyMap.EMPTY, PropertyMap.EMPTY, null); }  public boolean loadSchema(InputSource in) throws SAXException, IOException { try { schema = sr.createSchema(new SAXSource(in), schemaProperties); validator = null; return true; } catch (IncorrectSchemaException e) { return false; } }  public boolean validate(InputSource in) throws SAXException, IOException { if (schema == null) throw new IllegalStateException(\"cannot validate without schema\"); if (validator == null) validator = schema.createValidator(instanceProperties); if (xr == null) { xr = ResolverFactory.createResolver(instanceProperties).createXMLReader(); xr.setErrorHandler(eh); } eh.reset(); xr.setContentHandler(validator.getContentHandler()); DTDHandler dh = validator.getDTDHandler(); if (dh != null) xr.setDTDHandler(dh); try { xr.parse(in); return !eh.getHadErrorOrFatalError(); } finally { validator.reset(); } }  public PropertyMap getSchemaProperties() { if (schema == null) throw new IllegalStateException(\"getSchemaProperties requires a schema\"); return schema.getProperties(); }  static public InputSource fileInputSource(String filename) { return fileInputSource(new File(filename)); }  static public InputSource fileInputSource(File file) { return new InputSource(UriOrFile.fileToUri(file)); }  static public InputSource uriOrFileInputSource(String uriOrFile) { return new InputSource(UriOrFile.toUri(uriOrFile)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler;  public interface Validator {  ContentHandler getContentHandler();  DTDHandler getDTDHandler();  void reset(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.AbstractSchemaReader; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.ResolverFactory; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.sax.SAXSource; import java.io.IOException; import java.io.InputStream; public class AutoSchemaReader extends AbstractSchemaReader { private final SchemaReceiverFactory srf; public AutoSchemaReader() { this(new SchemaReceiverLoader()); } public AutoSchemaReader(SchemaReceiverFactory srf) { this.srf = srf == null ? new SchemaReceiverLoader() : srf; } public Schema createSchema(SAXSource source, PropertyMap properties) throws IOException, SAXException, IncorrectSchemaException { if (properties.get(SchemaReceiverFactory.PROPERTY) != srf) { PropertyMapBuilder builder = new PropertyMapBuilder(properties); builder.put(SchemaReceiverFactory.PROPERTY, srf); properties = builder.toPropertyMap(); } SAXResolver resolver = ResolverFactory.createResolver(properties); InputSource in = resolver.open(source.getInputSource()); InputSource in2 = new InputSource(); in2.setSystemId(in.getSystemId()); in2.setPublicId(in.getPublicId()); in2.setEncoding(in.getEncoding()); Rewindable rewindable; if (in.getCharacterStream() != null) { RewindableReader rewindableReader = new RewindableReader(in.getCharacterStream()); in.setCharacterStream(rewindableReader); in2.setCharacterStream(rewindableReader); rewindable = rewindableReader; } else { InputStream byteStream = in.getByteStream(); RewindableInputStream rewindableByteStream = new RewindableInputStream(byteStream); in.setByteStream(rewindableByteStream); in2.setByteStream(rewindableByteStream); rewindable = rewindableByteStream; } SchemaReceiver sr = new AutoSchemaReceiver(properties, rewindable); XMLReader xr = source.getXMLReader(); if (xr == null) xr = resolver.createXMLReader(); ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); if (eh != null) xr.setErrorHandler(eh); SchemaFuture sf = sr.installHandlers(xr); try { try { xr.parse(in); return sf.getSchema(); } catch (ReparseException e) { rewindable.rewind(); rewindable.willNotRewind(); return e.reparse(new SAXSource(xr, in2)); } finally { rewindable.willNotRewind(); } } catch (SAXException e) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import org.xml.sax.XMLReader; import org.xml.sax.SAXException; import org.xml.sax.Locator; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.DefaultHandler; import java.io.IOException; import java.util.Vector; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyMap; public class AutoSchemaReceiver implements SchemaReceiver { private final PropertyMap properties; private final Rewindable rewindable; private class Handler extends DefaultHandler implements SchemaFuture { private final XMLReader xr; private SchemaFuture sf = null; private Locator locator = null; private final Vector prefixMappings = new Vector(); private Handler(XMLReader xr) { this.xr = xr; } public void setDocumentLocator(Locator locator) { this.locator = locator; } public void startPrefixMapping(String prefix, String uri) { prefixMappings.addElement(prefix); prefixMappings.addElement(uri); } public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { SchemaReceiverFactory srf = properties.get(SchemaReceiverFactory.PROPERTY); SchemaReceiver sr = srf.createSchemaReceiver(uri, properties); if (sr == null) { Localizer localizer = new Localizer(AutoSchemaReceiver.class); String detail = (\"\".equals(uri) ? localizer.message(\"no_namespace\") : localizer.message(\"unknown_namespace\", uri)); throw new SAXParseException(detail, locator); } sf = sr.installHandlers(xr); rewindable.willNotRewind(); ContentHandler contentHandler = xr.getContentHandler(); if (contentHandler == null) return; if (locator != null) { contentHandler.setDocumentLocator(locator); contentHandler = xr.getContentHandler(); } contentHandler.startDocument(); contentHandler = xr.getContentHandler(); for (int i = 0, len = prefixMappings.size(); i < len; i += 2) { contentHandler.startPrefixMapping((String)prefixMappings.elementAt(i), (String)prefixMappings.elementAt(i + 1)); contentHandler = xr.getContentHandler(); } contentHandler.startElement(uri, localName, qName, attributes); } public Schema getSchema() throws IncorrectSchemaException, SAXException, IOException { if (sf == null) throw new IncorrectSchemaException(); return sf.getSchema(); } public RuntimeException unwrapException(RuntimeException e) throws SAXException, IOException, IncorrectSchemaException { if (sf == null) return e; return sf.unwrapException(e); } } public AutoSchemaReceiver(PropertyMap properties, Rewindable rewindable) { this.properties = properties; this.rewindable = rewindable; } public SchemaFuture installHandlers(XMLReader xr) { Handler h = new Handler(xr); xr.setContentHandler(h); return h; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Schema; import org.xml.sax.SAXException; import javax.xml.transform.sax.SAXSource; import java.io.IOException; public abstract class ReparseException extends SAXException { public ReparseException() { super((Exception)null); } public abstract Schema reparse(SAXSource source) throws IncorrectSchemaException, SAXException, IOException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; public interface Rewindable { void willNotRewind(); void rewind(); boolean canRewind(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import java.io.InputStream; import java.io.IOException; public class RewindableInputStream extends InputStream implements Rewindable { static class Block { Block next; final byte[] buf; int used = 0; static final int MIN_SIZE = 1024; Block(int minSize) { buf = new byte[Math.max(MIN_SIZE, minSize)]; } Block() { this(0); } void append(byte b) { buf[used++] = b; } void append(byte[] b, int off, int len) { System.arraycopy(b, off, buf, used, len); used += len; } } private Block head;  private int curBlockAvail; private Block curBlock; private int curBlockPos; private Block lastBlock;  private boolean saving = true; private final InputStream in; private boolean pretendClosed = false;  private boolean eof; public RewindableInputStream(InputStream in) { if (in == null) throw new NullPointerException(); this.in = in; } public void close() throws IOException { if (saving) { curBlockAvail = 0; curBlock = null; pretendClosed = true; } else { head = null; curBlock = null; lastBlock = null; saving = false; curBlockAvail = 0; in.close(); } } public void rewind() { if (!saving) throw new IllegalStateException(\"rewind() after willNotRewind()\"); pretendClosed = false; if (head == null) return; curBlock = head; curBlockPos = 0; curBlockAvail = curBlock.used; } public boolean canRewind() { return saving; } public void willNotRewind() { saving = false; head = null; lastBlock = null; if (pretendClosed) { pretendClosed = false; try { in.close(); } catch (IOException e) { } } } public int read() throws IOException { if (curBlockAvail > 0) { int c = curBlock.buf[curBlockPos++] & 0xFF; --curBlockAvail; if (curBlockAvail == 0) { curBlock = curBlock.next; if (curBlock != null) { curBlockPos = 0; curBlockAvail = curBlock.used; } } return c; } int c = in.read(); if (saving && c != -1) { if (lastBlock == null) lastBlock = head = new Block(); else if (lastBlock.used == lastBlock.buf.length) lastBlock = lastBlock.next = new Block(); lastBlock.append((byte)c); } return c; } public int read(byte b[], int off, int len) throws IOException { if (curBlockAvail == 0 && !saving) return in.read(b, off, len); if (b == null) throw new NullPointerException(); if (len < 0) throw new IndexOutOfBoundsException(); int nRead = 0; if (curBlockAvail != 0) { for (;;) { if (len == 0) return nRead; b[off++] = curBlock.buf[curBlockPos++]; --len; nRead++; --curBlockAvail; if (curBlockAvail == 0) { curBlock = curBlock.next; if (curBlock == null) break; curBlockAvail = curBlock.used; curBlockPos = 0; } } } if (len == 0) return nRead; if (eof) return nRead > 0 ? nRead : -1; try { int n = in.read(b, off, len); if (n < 0) { eof = true; return nRead > 0 ? nRead : -1; } nRead += n; if (saving) { if (lastBlock == null) lastBlock = head = new Block(n); else if (lastBlock.buf.length - lastBlock.used < n) { if (lastBlock.used != lastBlock.buf.length) { int free = lastBlock.buf.length - lastBlock.used; lastBlock.append(b, off, free); off += free; n -= free; } lastBlock = lastBlock.next = new Block(n); } lastBlock.append(b, off, n); } } catch (IOException e) { eof = true; if (nRead == 0) throw e; } return nRead; } public int available() throws IOException { if (curBlockAvail == 0) return in.available(); int n = curBlockAvail; for (Block b = curBlock.next; b != null; b = b.next) n += b.used; return n + in.available(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import java.io.IOException; import java.io.Reader;  public class RewindableReader extends Reader implements Rewindable { static class Block { Block next; final char[] buf; int used = 0; static final int MIN_SIZE = 1024; Block(int minSize) { buf = new char[Math.max(MIN_SIZE, minSize)]; } Block() { this(0); } void append(char b) { buf[used++] = b; } void append(char[] b, int off, int len) { System.arraycopy(b, off, buf, used, len); used += len; } } private Block head;  private int curBlockAvail; private Block curBlock; private int curBlockPos; private Block lastBlock;  private boolean saving = true; private final Reader in; private boolean pretendClosed = false;  private boolean eof; public RewindableReader(Reader in) { if (in == null) throw new NullPointerException(); this.in = in; } public void close() throws IOException { if (saving) { curBlockAvail = 0; curBlock = null; pretendClosed = true; } else { head = null; curBlock = null; lastBlock = null; saving = false; curBlockAvail = 0; in.close(); } } public void rewind() { if (!saving) throw new IllegalStateException(\"rewind() after willNotRewind()\"); pretendClosed = false; if (head == null) return; curBlock = head; curBlockPos = 0; curBlockAvail = curBlock.used; } public boolean canRewind() { return saving; } public void willNotRewind() { saving = false; head = null; lastBlock = null; if (pretendClosed) { pretendClosed = false; try { in.close(); } catch (IOException e) { } } } public int read() throws IOException { if (curBlockAvail > 0) { int c = curBlock.buf[curBlockPos++] & 0xFF; --curBlockAvail; if (curBlockAvail == 0) { curBlock = curBlock.next; if (curBlock != null) { curBlockPos = 0; curBlockAvail = curBlock.used; } } return c; } int c = in.read(); if (saving && c != -1) { if (lastBlock == null) lastBlock = head = new Block(); else if (lastBlock.used == lastBlock.buf.length) lastBlock = lastBlock.next = new Block(); lastBlock.append((char)c); } return c; } public int read(char b[], int off, int len) throws IOException { if (curBlockAvail == 0 && !saving) return in.read(b, off, len); if (b == null) throw new NullPointerException(); if (len < 0) throw new IndexOutOfBoundsException(); int nRead = 0; if (curBlockAvail != 0) { for (;;) { if (len == 0) return nRead; b[off++] = curBlock.buf[curBlockPos++]; --len; nRead++; --curBlockAvail; if (curBlockAvail == 0) { curBlock = curBlock.next; if (curBlock == null) break; curBlockAvail = curBlock.used; curBlockPos = 0; } } } if (len == 0) return nRead; if (eof) return nRead > 0 ? nRead : -1; try { int n = in.read(b, off, len); if (n < 0) { eof = true; return nRead > 0 ? nRead : -1; } nRead += n; if (saving) { if (lastBlock == null) lastBlock = head = new Block(n); else if (lastBlock.buf.length - lastBlock.used < n) { if (lastBlock.used != lastBlock.buf.length) { int free = lastBlock.buf.length - lastBlock.used; lastBlock.append(b, off, free); off += free; n -= free; } lastBlock = lastBlock.next = new Block(n); } lastBlock.append(b, off, n); } } catch (IOException e) { eof = true; if (nRead == 0) throw e; } return nRead; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import org.xml.sax.SAXException; import java.io.IOException; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.IncorrectSchemaException; public interface SchemaFuture { Schema getSchema() throws IncorrectSchemaException, SAXException, IOException; RuntimeException unwrapException(RuntimeException e) throws SAXException, IOException, IncorrectSchemaException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.SchemaReaderFactory; import com.thaiopensource.validate.Option; public class SchemaReaderFactorySchemaReceiverFactory implements SchemaReceiverFactory { private final SchemaReaderFactory srf; public SchemaReaderFactorySchemaReceiverFactory(SchemaReaderFactory srf) { this.srf = srf; } public SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties) { SchemaReader sr = srf.createSchemaReader(namespaceUri); if (sr == null) return null; return new SchemaReaderSchemaReceiver(sr, properties); } public Option getOption(String uri) { return srf.getOption(uri); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import com.thaiopensource.validate.SchemaReaderLoader; import com.thaiopensource.validate.auto.SchemaReaderFactorySchemaReceiverFactory; public class SchemaReaderLoaderSchemaReceiverFactory extends SchemaReaderFactorySchemaReceiverFactory { public SchemaReaderLoaderSchemaReceiverFactory() { super(new SchemaReaderLoader()); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.SchemaReader; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.sax.SAXSource; import java.io.IOException; public class SchemaReaderSchemaReceiver implements SchemaReceiver { private final SchemaReader schemaLanguage; private final PropertyMap properties; public SchemaReaderSchemaReceiver(SchemaReader schemaLanguage, PropertyMap properties) { this.schemaLanguage = schemaLanguage; this.properties = properties; } public SchemaFuture installHandlers(XMLReader xr) throws SAXException { throw new ReparseException() { public Schema reparse(SAXSource source) throws IncorrectSchemaException, SAXException, IOException { return schemaLanguage.createSchema(source, properties); } }; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import com.thaiopensource.validate.auto.SchemaFuture; public interface SchemaReceiver { SchemaFuture installHandlers(XMLReader xr) throws SAXException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Option; public interface SchemaReceiverFactory { static final PropertyId<SchemaReceiverFactory> PROPERTY = PropertyId.newInstance(\"SCHEMA_RECEIVER_FACTORY\", SchemaReceiverFactory.class); SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties); Option getOption(String uri); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.auto; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.Service; import com.thaiopensource.validate.Option; import java.util.Iterator; public class SchemaReceiverLoader implements SchemaReceiverFactory { private final Service<SchemaReceiverFactory> service = Service.newInstance(SchemaReceiverFactory.class); public SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties) { for (Iterator<SchemaReceiverFactory> iter = service.getProviders(); iter.hasNext();) { SchemaReceiverFactory srf = iter.next(); SchemaReceiver sr = srf.createSchemaReceiver(namespaceUri, properties); if (sr != null) return sr; } return null; } public Option getOption(String uri) { for (Iterator<SchemaReceiverFactory> iter = service.getProviders(); iter.hasNext();) { SchemaReceiverFactory srf = iter.next(); Option option = srf.getOption(uri); if (option != null) return option; } return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.jarv; import org.iso_relax.verifier.VerifierConfigurationException; public class JarvConfigurationException extends RuntimeException { private final VerifierConfigurationException wrapped; public JarvConfigurationException(VerifierConfigurationException wrapped) { this.wrapped = wrapped; } public VerifierConfigurationException getWrapped() { return wrapped; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.jarv; import com.thaiopensource.validate.SchemaReaderFactory; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.Option; import org.iso_relax.verifier.VerifierFactory; import org.iso_relax.verifier.VerifierConfigurationException; public class JarvSchemaReaderFactory implements SchemaReaderFactory { public SchemaReader createSchemaReader(String namespaceUri) { try { VerifierFactory vf = VerifierFactory.newInstance(namespaceUri); if (vf != null) return new VerifierFactorySchemaReader(vf); } catch (VerifierConfigurationException e) { } return null; } public Option getOption(String uri) { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.jarv; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.AbstractSchemaReader; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.Validator; import org.iso_relax.verifier.VerifierConfigurationException; import org.iso_relax.verifier.VerifierFactory; import org.xml.sax.SAXException; import javax.xml.transform.sax.SAXSource; import java.io.IOException; public class VerifierFactorySchemaReader extends AbstractSchemaReader { private final VerifierFactory vf; static private class SchemaImpl extends AbstractSchema { final org.iso_relax.verifier.Schema schema; private SchemaImpl(org.iso_relax.verifier.Schema schema) { this.schema = schema; } public Validator createValidator(PropertyMap properties) { try { return new VerifierValidator(schema.newVerifier(), properties); } catch (VerifierConfigurationException e) { Exception cause = e.getCauseException(); if (cause instanceof RuntimeException && (e.getMessage() == null || e.getMessage().equals(cause.getMessage()))) throw (RuntimeException)cause; throw new JarvConfigurationException(e); } } } public VerifierFactorySchemaReader(VerifierFactory vf) { this.vf = vf; } public Schema createSchema(SAXSource source, PropertyMap properties) throws IOException, SAXException, IncorrectSchemaException { try { return new SchemaImpl(vf.compileSchema(source.getInputSource())); } catch (SAXException e) { System.err.println(\"compileSchema threw a SAXException class \" + e.getClass().toString()); if (e.getException() != null) System.err.println(\"cause has class \" + e.getException().getClass().toString()); throw e; } catch (VerifierConfigurationException e) { for (;;) { Exception cause = e.getCauseException(); String message = e.getMessage(); if (cause != null && message != null && message.equals(cause.getMessage())) message = null; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.jarv; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import org.iso_relax.verifier.Verifier; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.EntityResolver; import org.xml.sax.SAXException; import org.xml.sax.helpers.DefaultHandler; public class VerifierValidator implements Validator { private final Verifier verifier; private ContentHandler handler; private static class ExceptionReportHandler extends DefaultHandler { private final SAXException storedException; ExceptionReportHandler(SAXException storedException) { this.storedException = storedException; } public void startDocument() throws SAXException { throw storedException; } } public VerifierValidator(Verifier verifier, PropertyMap properties) { this.verifier = verifier; verifier.setErrorHandler(properties.get(ValidateProperty.ERROR_HANDLER)); EntityResolver er = properties.get(ValidateProperty.ENTITY_RESOLVER); if (er != null) verifier.setEntityResolver(er); try { handler = verifier.getVerifierHandler(); } catch (SAXException e) { handler = new ExceptionReportHandler(e); } } public void reset() { try { handler = verifier.getVerifierHandler(); } catch (SAXException e) { handler = new ExceptionReportHandler(e); } } public ContentHandler getContentHandler() { return handler; } public DTDHandler getDTDHandler() { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; import com.thaiopensource.xml.util.Name; import java.util.Vector; import java.util.Hashtable; class ContextMap { private Object rootValue; private Object otherValue; private final Hashtable nameTable = new Hashtable(); Object get(Vector context) { return get(context, context.size()); } boolean put(boolean isRoot, Vector names, Object value) { return put(isRoot, names, names.size(), value); } private Object get(Vector context, int len) { if (len > 0) { ContextMap nestedMap = (ContextMap)nameTable.get(context.elementAt(len - 1)); if (nestedMap != null) { Object value = nestedMap.get(context, len - 1); if (value != null) return value; } } if (rootValue != null && len == 0) return rootValue; return otherValue; } private boolean put(boolean isRoot, Vector names, int len, Object value) { if (len == 0) { if (isRoot) { if (rootValue != null) return false; rootValue = value; } else { if (otherValue != null) return false; otherValue = value; } return true; } else { Name name = (Name)names.elementAt(len - 1); ContextMap nestedMap = (ContextMap)nameTable.get(name); if (nestedMap == null) { nestedMap = new ContextMap(); nameTable.put(name, nestedMap); } return nestedMap.put(isRoot, names, len - 1, value); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; class ElementsOrAttributes { private static final int ELEMENTS_FLAG = 01; private static final int ATTRIBUTES_FLAG = 02; static final ElementsOrAttributes NEITHER = new ElementsOrAttributes(0); static final ElementsOrAttributes ELEMENTS = new ElementsOrAttributes(ELEMENTS_FLAG); static final ElementsOrAttributes ATTRIBUTES = new ElementsOrAttributes(ATTRIBUTES_FLAG); static final ElementsOrAttributes BOTH = new ElementsOrAttributes(ELEMENTS_FLAG|ATTRIBUTES_FLAG); private static final ElementsOrAttributes values[] = { NEITHER, ELEMENTS, ATTRIBUTES, BOTH }; private int flags = 0; private ElementsOrAttributes(int flags) { this.flags = flags; } ElementsOrAttributes addElements() { return values[flags | ELEMENTS_FLAG]; } ElementsOrAttributes addAttributes() { return values[flags | ATTRIBUTES_FLAG]; } boolean containsAttributes() { return (flags & ATTRIBUTES_FLAG) != 0; } boolean containsElements() { return (flags & ELEMENTS_FLAG) != 0; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; import java.util.Hashtable; class Hashset { private final Hashtable table = new Hashtable(); boolean contains(Object key) { return table.get(key) != null; } void add(Object key) { table.put(key, key); } void clear() { table.clear(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.Option; public class MnsSchemaReceiverFactory implements SchemaReceiverFactory { public SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties) { if (!SchemaImpl.MNS_URI.equals(namespaceUri)) return null; return new SchemaReceiverImpl(properties); } public Option getOption(String uri) { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; import org.xml.sax.Attributes; class NamespaceFilteredAttributes implements Attributes { private final String ns; private final boolean keepLocal; private final Attributes attributes; private final int[] indexMap; private final int[] reverseIndexMap; public NamespaceFilteredAttributes(String ns, boolean keepLocal, Attributes attributes) { this.ns = ns; this.keepLocal = keepLocal; this.attributes = attributes; int n = 0; for (int i = 0, len = attributes.getLength(); i < len; i++) if (keepAttribute(attributes.getURI(i))) n++; indexMap = new int[n]; reverseIndexMap = new int[attributes.getLength()]; n = 0; for (int i = 0, len = attributes.getLength(); i < len; i++) { if (keepAttribute(attributes.getURI(i))) { reverseIndexMap[i] = n; indexMap[n++] = i; } else reverseIndexMap[i] = -1; } } private boolean keepAttribute(String uri) { return uri.equals(ns) || (keepLocal && uri.equals(\"\")); } public int getLength() { return indexMap.length; } public String getURI(int index) { if (index < 0 || index >= indexMap.length) return null; return attributes.getURI(indexMap[index]); } public String getLocalName(int index) { if (index < 0 || index >= indexMap.length) return null; return attributes.getLocalName(indexMap[index]); } public String getQName(int index) { if (index < 0 || index >= indexMap.length) return null; return attributes.getQName(indexMap[index]); } public String getType(int index) { if (index < 0 || index >= indexMap.length) return null; return attributes.getType(indexMap[index]); } public String getValue(int index) { if (index < 0 || index >= indexMap.length) return null; return attributes.getValue(indexMap[index]); } public int getIndex(String uri, String localName) { int n = attributes.getIndex(uri, localName); if (n < 0) return n; return reverseIndexMap[n]; } public int getIndex(String qName) { int n = attributes.getIndex(qName); if (n < 0) return n; return reverseIndexMap[n]; } public String getType(String uri, String localName) { if (keepAttribute(uri)) return attributes.getType(uri, localName); return null; } public String getValue(String uri, String localName) { if (keepAttribute(uri)) return attributes.getValue(uri, localName); return null; } public String getType(String qName) { int i = getIndex(qName); if (i < 0) return null; return getType(i); } public String getValue(String qName) { int i = getIndex(qName); if (i < 0) return null; return getValue(i); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.Uri; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.xml.sax.XmlBaseHandler; import com.thaiopensource.xml.sax.DelegatingContentHandler; import com.thaiopensource.xml.sax.CountingErrorHandler; import com.thaiopensource.xml.util.Name; import com.thaiopensource.xml.util.StringSplitter; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.Attributes; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.LocatorImpl; import java.io.IOException; import java.util.Enumeration; import java.util.Hashtable; import java.util.Stack; class SchemaImpl extends AbstractSchema { static final String MNS_URI = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.auto.AutoSchemaReader; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.prop.wrap.WrapProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import com.thaiopensource.validate.rng.SAXSchemaReader; import com.thaiopensource.xml.util.Name; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import java.io.IOException; import java.net.URL; class SchemaReceiverImpl implements SchemaReceiver { private static final String MNS_SCHEMA = \"mns.rng\"; private static final String RNC_MEDIA_TYPE = \"application/x-rnc\"; private final PropertyMap properties; private final PropertyMap attributeSchemaProperties; private final boolean attributesSchema; private final SchemaReader autoSchemaLanguage; private Schema mnsSchema = null; public SchemaReceiverImpl(PropertyMap properties) { Name attributeOwner = properties.get(WrapProperty.ATTRIBUTE_OWNER); attributesSchema = (attributeOwner != null); PropertyMapBuilder builder = new PropertyMapBuilder(properties); if (ValidatorImpl.OWNER_NAME.equals(attributeOwner)) { attributeSchemaProperties = properties; builder.put(WrapProperty.ATTRIBUTE_OWNER, null); this.properties = builder.toPropertyMap(); } else { if (attributeOwner == null) this.properties = properties; else { builder.put(WrapProperty.ATTRIBUTE_OWNER, null); this.properties = builder.toPropertyMap(); } builder.put(WrapProperty.ATTRIBUTE_OWNER, ValidatorImpl.OWNER_NAME); attributeSchemaProperties = builder.toPropertyMap(); } this.autoSchemaLanguage = new AutoSchemaReader(properties.get(SchemaReceiverFactory.PROPERTY)); } public SchemaFuture installHandlers(XMLReader xr) { return new SchemaImpl(attributesSchema).installHandlers(xr, this); } Schema getMnsSchema() throws IOException, IncorrectSchemaException, SAXException { if (mnsSchema == null) { String className = SchemaReceiverImpl.class.getName(); String resourceName = className.substring(0, className.lastIndexOf('.')).replace('.', '/') + \"/resources/\" + MNS_SCHEMA; URL mnsSchemaUrl = getResource(resourceName); mnsSchema = SAXSchemaReader.getInstance().createSchema( new InputSource(mnsSchemaUrl.toString()), properties); } return mnsSchema; } private static URL getResource(String resourceName) { ClassLoader cl = SchemaReceiverImpl.class.getClassLoader(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.mns; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.xml.util.Name; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.DefaultHandler; import java.util.Hashtable; import java.util.Stack; class ValidatorImpl extends DefaultHandler implements Validator { static final Name OWNER_NAME = new Name(\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; abstract class Action { private final ModeUsage modeUsage; Action(ModeUsage modeUsage) { this.modeUsage = modeUsage; } ModeUsage getModeUsage() { return modeUsage; } public boolean equals(Object obj) { return obj != null && obj.getClass() == getClass() && ((Action)obj).modeUsage.equals(modeUsage); } public int hashCode() { return getClass().hashCode() ^ modeUsage.hashCode(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; class ActionSet { private ResultAction resultAction; private NoResultAction[] noResultActions = new NoResultAction[0]; ResultAction getResultAction() { return resultAction; } void setResultAction(ResultAction resultAction) { this.resultAction = resultAction; } void addNoResultAction(NoResultAction action) { NoResultAction[] actions = new NoResultAction[noResultActions.length + 1]; System.arraycopy(noResultActions, 0, actions, 0, noResultActions.length); actions[noResultActions.length] = action; noResultActions = actions; } NoResultAction[] getNoResultActions() { return noResultActions; } ActionSet changeCurrentMode(Mode mode) { ActionSet actions = new ActionSet(); if (this.resultAction != null) actions.resultAction = this.resultAction.changeCurrentMode(mode); actions.noResultActions = new NoResultAction[this.noResultActions.length]; for (int i = 0; i < actions.noResultActions.length; i++) actions.noResultActions[i] = this.noResultActions[i].changeCurrentMode(mode); return actions; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; class AllowAction extends NoResultAction { AllowAction(ModeUsage modeUsage) { super(modeUsage); } void perform(SectionState state) { state.addChildMode(getModeUsage(), null); state.addAttributeValidationModeUsage(getModeUsage()); } NoResultAction changeCurrentMode(Mode mode) { return new AllowAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.nrl.Mode; import com.thaiopensource.validate.nrl.ModeUsage; import org.xml.sax.ContentHandler; class AttachAction extends ResultAction { AttachAction(ModeUsage modeUsage) { super(modeUsage); } void perform(ContentHandler handler, SectionState state) { final ModeUsage modeUsage = getModeUsage(); if (handler != null) state.addActiveHandler(handler, modeUsage); else state.addAttributeValidationModeUsage(modeUsage); state.addChildMode(modeUsage, handler); } ResultAction changeCurrentMode(Mode mode) { return new AttachAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.validate.Schema; class AttributeActionSet { private boolean attach; private boolean reject; private Schema[] schemas = new Schema[0]; boolean getAttach() { return attach; } void setAttach(boolean attach) { this.attach = attach; } boolean getReject() { return reject; } void setReject(boolean reject) { this.reject = reject; } Schema[] getSchemas() { return schemas; } void addSchema(Schema schema) { Schema[] s = new Schema[schemas.length + 1]; System.arraycopy(schemas, 0, s, 0, schemas.length); s[schemas.length] = schema; schemas = s; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.util.Equal; import java.util.Vector; import java.util.Hashtable; import java.util.Enumeration; import java.util.NoSuchElementException; class ContextMap { private Object rootValue; private Object otherValue; private final Hashtable nameTable = new Hashtable(); Object get(Vector context) { return get(context, context.size()); } boolean put(boolean isRoot, Vector names, Object value) { return put(isRoot, names, names.size(), value); } private Object get(Vector context, int len) { if (len > 0) { ContextMap nestedMap = (ContextMap)nameTable.get(context.elementAt(len - 1)); if (nestedMap != null) { Object value = nestedMap.get(context, len - 1); if (value != null) return value; } } if (rootValue != null && len == 0) return rootValue; return otherValue; } private boolean put(boolean isRoot, Vector names, int len, Object value) { if (len == 0) { if (isRoot) { if (rootValue != null) return false; rootValue = value; } else { if (otherValue != null) return false; otherValue = value; } return true; } else { Object name = names.elementAt(len - 1); ContextMap nestedMap = (ContextMap)nameTable.get(name); if (nestedMap == null) { nestedMap = new ContextMap(); nameTable.put(name, nestedMap); } return nestedMap.put(isRoot, names, len - 1, value); } } public boolean equals(Object obj) { if (!(obj instanceof ContextMap)) return false; ContextMap other = (ContextMap)obj; if (!Equal.equal(this.rootValue, other.rootValue) || !Equal.equal(this.otherValue, other.otherValue)) return false; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; class ElementsOrAttributes { private static final int ELEMENTS_FLAG = 01; private static final int ATTRIBUTES_FLAG = 02; static final ElementsOrAttributes NEITHER = new ElementsOrAttributes(0); static final ElementsOrAttributes ELEMENTS = new ElementsOrAttributes(ELEMENTS_FLAG); static final ElementsOrAttributes ATTRIBUTES = new ElementsOrAttributes(ATTRIBUTES_FLAG); static final ElementsOrAttributes BOTH = new ElementsOrAttributes(ELEMENTS_FLAG|ATTRIBUTES_FLAG); private static final ElementsOrAttributes values[] = { NEITHER, ELEMENTS, ATTRIBUTES, BOTH }; private int flags = 0; private ElementsOrAttributes(int flags) { this.flags = flags; } ElementsOrAttributes addElements() { return values[flags | ELEMENTS_FLAG]; } ElementsOrAttributes addAttributes() { return values[flags | ATTRIBUTES_FLAG]; } boolean containsAttributes() { return (flags & ATTRIBUTES_FLAG) != 0; } boolean containsElements() { return (flags & ELEMENTS_FLAG) != 0; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import org.xml.sax.Attributes; class FilteredAttributes implements Attributes { private final Attributes attributes; private final IntSet indexSet; private int[] reverseIndexMap; public FilteredAttributes(IntSet indexSet, Attributes attributes) { this.indexSet = indexSet; this.attributes = attributes; } private int reverseIndex(int k) { if (reverseIndexMap == null) { reverseIndexMap = new int[attributes.getLength()]; for (int i = 0, len = indexSet.size(); i < len; i++) reverseIndexMap[indexSet.get(i)] = i + 1; } return reverseIndexMap[k] - 1; } public int getLength() { return indexSet.size(); } public String getURI(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getURI(indexSet.get(index)); } public String getLocalName(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getLocalName(indexSet.get(index)); } public String getQName(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getQName(indexSet.get(index)); } public String getType(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getType(indexSet.get(index)); } public String getValue(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getValue(indexSet.get(index)); } public int getIndex(String uri, String localName) { int n = attributes.getIndex(uri, localName); if (n < 0) return n; return reverseIndex(n); } public int getIndex(String qName) { int n = attributes.getIndex(qName); if (n < 0) return n; return reverseIndex(n); } private int getRealIndex(String uri, String localName) { int index = attributes.getIndex(uri, localName); if (index < 0 || reverseIndex(index) < 0) return -1; return index; } private int getRealIndex(String qName) { int index = attributes.getIndex(qName); if (index < 0 || reverseIndex(index) < 0) return -1; return index; } public String getType(String uri, String localName) { return attributes.getType(getRealIndex(uri, localName)); } public String getValue(String uri, String localName) { return attributes.getValue(getRealIndex(uri, localName)); } public String getType(String qName) { return attributes.getType(getRealIndex(qName)); } public String getValue(String qName) { return attributes.getValue(getRealIndex(qName)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import java.util.Hashtable; import java.util.Enumeration; class Hashset { private final Hashtable table = new Hashtable(); boolean contains(Object key) { return table.get(key) != null; } void add(Object key) { table.put(key, key); } void addAll(Hashset set) { for (Enumeration e = set.table.keys(); e.hasMoreElements();) add(e.nextElement()); } void clear() { table.clear(); } Enumeration members() { return table.keys(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; class IntSet { static private final int INIT_SIZE = 4; private int[] v = null; private int len = 0; void add(int n) { if (v == null) { v = new int[INIT_SIZE]; v[0] = n; len = 1; return; } if (len == v.length) { int[] newv = new int[len*2]; System.arraycopy(v, 0, newv, 0, len); v = newv; } if (n > v[len - 1]) { v[len++] = n; return; } int i = 0; for (; i < len; i++) { if (n <= v[i]) { if (n == v[i]) return; break; } } for (int j = len; j >= i; j--) v[j + 1] = v[j]; v[i] = n; ++len; } void addAll(IntSet is) { if (is.len == 0) return; int[] newv = new int[len + is.len]; int i = 0, j = 0, k = 0; while (i < len && j < is.len) { if (v[i] < is.v[j]) newv[k++] = v[i++]; else if (is.v[j] < v[i]) newv[k++] = is.v[j++]; else { newv[k++] = v[i++]; j++; } } while (i < len) newv[k++] = v[i++]; while (j < is.len) newv[k++] = is.v[j++]; v = newv; len = k; } int size() { return len; } int get(int i) { if (i >= len) throw new IndexOutOfBoundsException(); try { return v[i]; } catch (NullPointerException e) { throw new IndexOutOfBoundsException(); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import org.xml.sax.Locator; import org.xml.sax.helpers.LocatorImpl; import java.util.Hashtable; import java.util.Enumeration; import com.thaiopensource.validate.nrl.ActionSet; import com.thaiopensource.validate.nrl.AttributeActionSet; class Mode { static final String ANY_NAMESPACE = \"##any\"; static final int ATTRIBUTE_PROCESSING_NONE = 0; static final int ATTRIBUTE_PROCESSING_QUALIFIED = 1; static final int ATTRIBUTE_PROCESSING_FULL = 2; static final Mode CURRENT = new Mode(\"#current\", null); private final String name; private Mode baseMode; private boolean defined; private Locator whereDefined; private Locator whereUsed; private final Hashtable elementMap = new Hashtable(); private final Hashtable attributeMap = new Hashtable(); private int attributeProcessing = -1; Mode(String name, Mode baseMode) { this.name = name; this.baseMode = baseMode; } String getName() { return name; } Mode getBaseMode() { return baseMode; } void setBaseMode(Mode baseMode) { this.baseMode = baseMode; } ActionSet getElementActions(String ns) { ActionSet actions = getElementActionsExplicit(ns); if (actions == null) { actions = getElementActionsExplicit(ANY_NAMESPACE); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.util.Equal; import com.thaiopensource.validate.nrl.ContextMap; import com.thaiopensource.validate.nrl.Mode; import java.util.Vector; import java.util.Enumeration; class ModeUsage { private final Mode mode; private final Mode currentMode; private ContextMap modeMap; private int attributeProcessing = -1; ModeUsage(Mode mode, Mode currentMode) { this(mode, currentMode, null); } private ModeUsage(Mode mode, Mode currentMode, ContextMap modeMap) { this.mode = mode; this.currentMode = currentMode; this.modeMap = modeMap; } ModeUsage changeCurrentMode(Mode currentMode) { return new ModeUsage(mode, currentMode, modeMap); } public boolean equals(Object obj) { if (!(obj instanceof ModeUsage)) return false; ModeUsage other = (ModeUsage)obj; return this.mode == other.mode && this.currentMode == other.currentMode && Equal.equal(this.modeMap, other.modeMap); } public int hashCode() { int hc = mode.hashCode() ^ currentMode.hashCode(); if (modeMap != null) hc ^= modeMap.hashCode(); return hc; } private Mode resolve(Mode mode) { return mode == Mode.CURRENT ? currentMode : mode; } int getAttributeProcessing() { if (attributeProcessing == -1) { attributeProcessing = resolve(mode).getAttributeProcessing(); if (modeMap != null) { for (Enumeration e = modeMap.values(); e.hasMoreElements() && attributeProcessing != Mode.ATTRIBUTE_PROCESSING_FULL;) attributeProcessing = Math.max(resolve((Mode)e.nextElement()).getAttributeProcessing(), attributeProcessing); } } return attributeProcessing; } boolean isContextDependent() { return modeMap != null; } Mode getMode(Vector context) { if (modeMap != null) { Mode m = (Mode)modeMap.get(context); if (m != null) return resolve(m); } return resolve(mode); } boolean addContext(boolean isRoot, Vector names, Mode mode) { if (modeMap == null) modeMap = new ContextMap(); return modeMap.put(isRoot, names, mode); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.nrl.Action; import com.thaiopensource.validate.nrl.Mode; import com.thaiopensource.validate.nrl.ModeUsage; import org.xml.sax.SAXException; abstract class NoResultAction extends Action { NoResultAction(ModeUsage modeUsage) { super(modeUsage); } abstract void perform(SectionState state) throws SAXException; abstract NoResultAction changeCurrentMode(Mode mode); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.Option; public class NrlSchemaReceiverFactory implements SchemaReceiverFactory { public SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties) { if (!SchemaImpl.NRL_URI.equals(namespaceUri)) return null; return new SchemaReceiverImpl(properties); } public Option getOption(String uri) { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.xml.util.Naming; import java.util.Vector; class Path { private final boolean root; private final Vector names; Path(boolean root, Vector names) { this.root = root; this.names = names; } boolean isRoot() { return root; } Vector getNames() { return names; } public String toString() { StringBuffer buf = new StringBuffer(); if (root) buf.append('/'); for (int i = 0, len = names.size(); i < len; i++) { if (i != 0) buf.append('/'); buf.append((String)names.elementAt(i)); } return buf.toString(); } static class ParseException extends Exception { private final String messageKey; ParseException(String messageKey) { super(messageKey); this.messageKey = messageKey; } public String getMessageKey() { return messageKey; } } private static final int START = 0; private static final int IN_NAME = 1; private static final int AFTER_NAME = 2; private static final int AFTER_SLASH = 3; static Vector parse(String str) throws ParseException { int state = START; int nameStartIndex = -1; Vector paths = new Vector(); Vector names = new Vector(); boolean root = false; for (int i = 0, len = str.length(); i < len; i++) { char c = str.charAt(i); switch (c) { case ' ': case '\\r': case '\\n': case '\\t': if (state == IN_NAME) { names.addElement(makeName(str, nameStartIndex, i)); state = AFTER_NAME; } break; case '/': switch (state) { case IN_NAME: names.addElement(makeName(str, nameStartIndex, i)); break; case START: root = true; break; case AFTER_SLASH: throw new ParseException(\"unexpected_slash\"); } state = AFTER_SLASH; break; case '|': switch (state) { case START: throw new ParseException(\"empty_path\"); case AFTER_NAME: break; case AFTER_SLASH: throw new ParseException(\"expected_name\"); case IN_NAME: names.addElement(makeName(str, nameStartIndex, i)); break; } paths.addElement(new Path(root, names)); root = false; names = new Vector(); state = START; break; default: switch (state) { case AFTER_NAME: throw new ParseException(\"expected_slash\"); case AFTER_SLASH: case START: nameStartIndex = i; state = IN_NAME; break; case IN_NAME: break; } break; } } switch (state) { case START: throw new ParseException(\"empty_path\"); case AFTER_NAME: break; case AFTER_SLASH: throw new ParseException(\"expected_name\"); case IN_NAME: names.addElement(makeName(str, nameStartIndex, str.length())); break; } paths.addElement(new Path(root, names)); return paths; } private static String makeName(String str, int start, int end) throws ParseException { String name = str.substring(start, end); if (!Naming.isNcname(name)) throw new ParseException(\"invalid_name\"); return name; } static public void main(String[] args) throws ParseException { Vector paths = parse(args[0]); for (int i = 0; i < paths.size(); i++) { if (i != 0) System.out.println(\"---\"); Path path = (Path)paths.elementAt(i); if (path.isRoot()) System.out.println(\"/\"); for (int j = 0; j < path.getNames().size(); j++) System.out.println(path.getNames().elementAt(j)); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import org.xml.sax.SAXException; import com.thaiopensource.validate.nrl.Mode; import com.thaiopensource.validate.nrl.ModeUsage; import com.thaiopensource.validate.nrl.NoResultAction; class RejectAction extends NoResultAction { RejectAction(ModeUsage modeUsage) { super(modeUsage); } void perform(SectionState state) throws SAXException { final ModeUsage modeUsage = getModeUsage(); state.reject(); state.addChildMode(modeUsage, null); state.addAttributeValidationModeUsage(modeUsage); } NoResultAction changeCurrentMode(Mode mode) { return new RejectAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.nrl.Action; import com.thaiopensource.validate.nrl.Mode; import com.thaiopensource.validate.nrl.ModeUsage; import org.xml.sax.SAXException; import org.xml.sax.ContentHandler; abstract class ResultAction extends Action { ResultAction(ModeUsage modeUsage) { super(modeUsage); } abstract void perform(ContentHandler handler, SectionState state) throws SAXException; abstract ResultAction changeCurrentMode(Mode mode); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.util.Uri; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.OptionArgumentException; import com.thaiopensource.validate.OptionArgumentPresenceException; import com.thaiopensource.validate.ResolverFactory; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.validate.prop.wrap.WrapProperty; import com.thaiopensource.xml.sax.CountingErrorHandler; import com.thaiopensource.xml.sax.DelegatingContentHandler; import com.thaiopensource.xml.sax.XmlBaseHandler; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.Attributes; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.LocatorImpl; import java.io.IOException; import java.util.Enumeration; import java.util.Hashtable; import java.util.Vector; class SchemaImpl extends AbstractSchema { static private final String IMPLICIT_MODE_NAME = \"#implicit\"; static private final String WRAPPER_MODE_NAME = \"#wrapper\"; static final String NRL_URI = SchemaReader.BASE_URI + \"nrl\"; private final Hashtable modeMap = new Hashtable(); private Mode startMode; private final Mode defaultBaseMode; private final boolean attributesSchema; static private final class WrappedIOException extends RuntimeException { private final IOException exception; private WrappedIOException(IOException exception) { this.exception = exception; } private IOException getException() { return exception; } } static private class MustSupportOption { private final String name; private final PropertyId pid; private final Locator locator; MustSupportOption(String name, PropertyId pid, Locator locator) { this.name = name; this.pid = pid; this.locator = locator; } } private class Handler extends DelegatingContentHandler implements SchemaFuture { private final SchemaReceiverImpl sr; private boolean hadError = false; private final ErrorHandler eh; private final SAXResolver resolver; private final CountingErrorHandler ceh; private final Localizer localizer = new Localizer(SchemaImpl.class); private Locator locator; private final XmlBaseHandler xmlBaseHandler = new XmlBaseHandler(); private int foreignDepth = 0; private Mode currentMode = null; private String defaultSchemaType; private Validator validator; private ElementsOrAttributes match; private ActionSet actions; private AttributeActionSet attributeActions; private String schemaUri; private String schemaUriBase; private String schemaType; private PropertyMapBuilder options; private final Vector mustSupportOptions = new Vector(); private ModeUsage modeUsage; private boolean anyNamespace; Handler(SchemaReceiverImpl sr) { this.sr = sr; this.eh = sr.getProperties().get(ValidateProperty.ERROR_HANDLER); this.ceh = new CountingErrorHandler(this.eh); this.resolver = ResolverFactory.createResolver(sr.getProperties()); } public void setDocumentLocator(Locator locator) { xmlBaseHandler.setLocator(locator); this.locator = locator; } public void startDocument() throws SAXException { try { PropertyMapBuilder builder = new PropertyMapBuilder(sr.getProperties()); builder.put(ValidateProperty.ERROR_HANDLER, ceh); validator = sr.getNrlSchema().createValidator(builder.toPropertyMap()); } catch (IOException e) { throw new WrappedIOException(e); } catch (IncorrectSchemaException e) { throw new RuntimeException(\"internal error in RNG schema for NRL\"); } setDelegate(validator.getContentHandler()); if (locator != null) super.setDocumentLocator(locator); super.startDocument(); } public Schema getSchema() throws IncorrectSchemaException, SAXException { if (validator == null || ceh.getHadErrorOrFatalError()) throw new IncorrectSchemaException(); Hashset openModes = new Hashset(); Hashset checkedModes = new Hashset(); for (Enumeration e = modeMap.keys(); e.hasMoreElements();) { String modeName = (String)e.nextElement(); Mode mode = (Mode)modeMap.get(modeName); if (!mode.isDefined()) error(\"undefined_mode\", modeName, mode.getWhereUsed()); for (Mode tem = mode; tem != null; tem = tem.getBaseMode()) { if (checkedModes.contains(tem)) break; if (openModes.contains(tem)) { error(\"mode_cycle\", tem.getName(), tem.getWhereDefined()); break; } openModes.add(tem); } checkedModes.addAll(openModes); openModes.clear(); } if (hadError) throw new IncorrectSchemaException(); return SchemaImpl.this; } public RuntimeException unwrapException(RuntimeException e) throws SAXException, IOException, IncorrectSchemaException { if (e instanceof WrappedIOException) throw ((WrappedIOException)e).getException(); return e; } public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { super.startElement(uri, localName, qName, attributes); xmlBaseHandler.startElement(); String xmlBase = attributes.getValue(WellKnownNamespaces.XML, \"base\"); if (xmlBase != null) xmlBaseHandler.xmlBaseAttribute(xmlBase); if (!NRL_URI.equals(uri) || foreignDepth > 0) { foreignDepth++; return; } if (ceh.getHadErrorOrFatalError()) return; if (localName.equals(\"rules\")) parseRules(attributes); else if (localName.equals(\"mode\")) parseMode(attributes); else if (localName.equals(\"namespace\")) parseNamespace(attributes); else if (localName.equals(\"anyNamespace\")) parseAnyNamespace(attributes); else if (localName.equals(\"validate\")) parseValidate(attributes); else if (localName.equals(\"reject\")) parseReject(attributes); else if (localName.equals(\"attach\")) parseAttach(attributes); else if (localName.equals(\"unwrap\")) parseUnwrap(attributes); else if (localName.equals(\"allow\")) parseAllow(attributes); else if (localName.equals(\"context\")) parseContext(attributes); else if (localName.equals(\"option\")) parseOption(attributes); else throw new RuntimeException(\"unexpected element \\\"\" + localName + \"\\\"\"); } public void endElement(String namespaceURI, String localName, String qName) throws SAXException { super.endElement(namespaceURI, localName, qName); xmlBaseHandler.endElement(); if (foreignDepth > 0) { foreignDepth--; return; } if (ceh.getHadErrorOrFatalError()) return; if (localName.equals(\"validate\")) finishValidate(); } private void parseRules(Attributes attributes) { startMode = getModeAttribute(attributes, \"startMode\"); if (startMode == null) { startMode = lookupCreateMode(IMPLICIT_MODE_NAME); currentMode = startMode; startMode.noteDefined(null); } startMode.noteUsed(locator); if (attributesSchema) { Mode wrapper = lookupCreateMode(WRAPPER_MODE_NAME); ActionSet actions = new ActionSet(); actions.addNoResultAction(new AllowAction(new ModeUsage(startMode, startMode))); wrapper.bindElement(Mode.ANY_NAMESPACE, actions); wrapper.noteDefined(null); startMode = wrapper; } defaultSchemaType = getSchemaType(attributes); } private void parseMode(Attributes attributes) throws SAXException { currentMode = getModeAttribute(attributes, \"name\"); if (currentMode.isDefined()) { error(\"duplicate_mode\", currentMode.getName()); error(\"first_mode\", currentMode.getName(), currentMode.getWhereDefined()); } else { Mode base = getModeAttribute(attributes, \"extends\"); if (base != null) currentMode.setBaseMode(base); currentMode.noteDefined(locator); } } private void parseNamespace(Attributes attributes) throws SAXException { anyNamespace = false; parseRule(getNs(attributes), attributes); } private void parseAnyNamespace(Attributes attributes) throws SAXException { anyNamespace = true; parseRule(Mode.ANY_NAMESPACE, attributes); } private void parseRule(String ns, Attributes attributes) throws SAXException { match = toElementsOrAttributes(attributes.getValue(\"\", \"match\"), ElementsOrAttributes.ELEMENTS); if (match.containsAttributes()) { attributeActions = new AttributeActionSet(); if (!currentMode.bindAttribute(ns, attributeActions)) { if (ns.equals(Mode.ANY_NAMESPACE)) error(\"duplicate_attribute_action_any_namespace\"); else error(\"duplicate_attribute_action\", ns); } } if (match.containsElements()) { actions = new ActionSet(); if (!currentMode.bindElement(ns, actions)) { if (ns.equals(Mode.ANY_NAMESPACE)) error(\"duplicate_element_action_any_namespace\"); else error(\"duplicate_element_action\", ns); } } else actions = null; } private void parseValidate(Attributes attributes) throws SAXException { schemaUri = getSchema(attributes); schemaUriBase = xmlBaseHandler.getBaseUri(); schemaType = getSchemaType(attributes); if (schemaType == null) schemaType = defaultSchemaType; if (actions != null) modeUsage = getModeUsage(attributes); else modeUsage = null; options = new PropertyMapBuilder(); mustSupportOptions.clear(); } private void finishValidate() throws SAXException { try { if (attributeActions != null) { Schema schema = createSubSchema(true); attributeActions.addSchema(schema); } if (actions != null) { Schema schema = createSubSchema(false); actions.addNoResultAction(new ValidateAction(modeUsage, schema)); } } catch (IncorrectSchemaException e) { hadError = true; } catch (IOException e) { throw new WrappedIOException(e); } } private Schema createSubSchema(boolean isAttributesSchema) throws IOException, IncorrectSchemaException, SAXException { PropertyMap requestedProperties = options.toPropertyMap(); Schema schema = sr.createChildSchema(resolver.resolve(schemaUri, schemaUriBase), schemaType, requestedProperties, isAttributesSchema); PropertyMap actualProperties = schema.getProperties(); for (Enumeration e = mustSupportOptions.elements(); e.hasMoreElements();) { MustSupportOption mso = (MustSupportOption)e.nextElement(); Object actualValue = actualProperties.get(mso.pid); if (actualValue == null) error(\"unsupported_option\", mso.name, mso.locator); else if (!actualValue.equals(requestedProperties.get(mso.pid))) error(\"unsupported_option_arg\", mso.name, mso.locator); } return schema; } private void parseOption(Attributes attributes) throws SAXException { boolean mustSupport; String mustSupportValue = attributes.getValue(\"\", \"mustSupport\"); if (mustSupportValue != null) { mustSupportValue = mustSupportValue.trim(); mustSupport = mustSupportValue.equals(\"1\") || mustSupportValue.equals(\"true\"); } else mustSupport = false; String name = Uri.resolve(NRL_URI, attributes.getValue(\"\", \"name\")); Option option = sr.getOption(name); if (option == null) { if (mustSupport) error(\"unknown_option\", name); } else { String arg = attributes.getValue(\"\", \"arg\"); try { PropertyId pid = option.getPropertyId(); Object value = option.valueOf(arg); Object oldValue = options.get(pid); if (oldValue != null) { value = option.combine(new Object[]{oldValue, value}); if (value == null) error(\"duplicate_option\", name); else options.put(pid, value); } else { options.put(pid, value); mustSupportOptions.addElement(new MustSupportOption(name, pid, locator == null ? null : new LocatorImpl(locator))); } } catch (OptionArgumentPresenceException e) { error(arg == null ? \"option_requires_argument\" : \"option_unexpected_argument\", name); } catch (OptionArgumentException e) { if (arg == null) error(\"option_requires_argument\", name); else error(\"option_bad_argument\", name, arg); } } } private void parseAttach(Attributes attributes) { if (attributeActions != null) attributeActions.setAttach(true); if (actions != null) { modeUsage = getModeUsage(attributes); actions.setResultAction(new AttachAction(modeUsage)); } else modeUsage = null; } private void parseUnwrap(Attributes attributes) { if (actions != null) { modeUsage = getModeUsage(attributes); actions.setResultAction(new UnwrapAction(modeUsage)); } else modeUsage = null; } private void parseAllow(Attributes attributes) { if (actions != null) { modeUsage = getModeUsage(attributes); actions.addNoResultAction(new AllowAction(modeUsage)); } else modeUsage = null; } private void parseReject(Attributes attributes) { if (actions != null) { modeUsage = getModeUsage(attributes); actions.addNoResultAction(new RejectAction(modeUsage)); } else modeUsage = null; if (attributeActions != null) attributeActions.setReject(true); } private void parseContext(Attributes attributes) throws SAXException { if (anyNamespace) { error(\"context_any_namespace\"); return; } Mode mode = getUseMode(attributes); try { Vector paths = Path.parse(attributes.getValue(\"\", \"path\")); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.auto.AutoSchemaReader; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.prop.wrap.WrapProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import com.thaiopensource.validate.rng.SAXSchemaReader; import com.thaiopensource.xml.util.Name; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.sax.SAXSource; import java.io.IOException; import java.net.URL; class SchemaReceiverImpl implements SchemaReceiver { private static final String NRL_SCHEMA = \"nrl.rng\"; private static final String RNC_MEDIA_TYPE = \"application/x-rnc\"; private final PropertyMap properties; private final Name attributeOwner; private final SchemaReader autoSchemaReader; private Schema nrlSchema = null; private static final PropertyId subSchemaProperties[] = { ValidateProperty.ERROR_HANDLER, ValidateProperty.XML_READER_CREATOR, ValidateProperty.ENTITY_RESOLVER, SchemaReceiverFactory.PROPERTY, }; public SchemaReceiverImpl(PropertyMap properties) { this.attributeOwner = properties.get(WrapProperty.ATTRIBUTE_OWNER); PropertyMapBuilder builder = new PropertyMapBuilder(); for (int i = 0; i < subSchemaProperties.length; i++) { Object value = properties.get(subSchemaProperties[i]); if (value != null) builder.put(subSchemaProperties[i], value); } this.properties = builder.toPropertyMap(); this.autoSchemaReader = new AutoSchemaReader(properties.get(SchemaReceiverFactory.PROPERTY)); } public SchemaFuture installHandlers(XMLReader xr) { PropertyMapBuilder builder = new PropertyMapBuilder(properties); if (attributeOwner != null) builder.put(WrapProperty.ATTRIBUTE_OWNER, attributeOwner); return new SchemaImpl(builder.toPropertyMap()).installHandlers(xr, this); } Schema getNrlSchema() throws IOException, IncorrectSchemaException, SAXException { if (nrlSchema == null) { String className = SchemaReceiverImpl.class.getName(); String resourceName = className.substring(0, className.lastIndexOf('.')).replace('.', '/') + \"/resources/\" + NRL_SCHEMA; URL nrlSchemaUrl = getResource(resourceName); nrlSchema = SAXSchemaReader.getInstance().createSchema(new InputSource(nrlSchemaUrl.openStream()), properties); } return nrlSchema; } private static URL getResource(String resourceName) { ClassLoader cl = SchemaReceiverImpl.class.getClassLoader(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.nrl.ModeUsage; import org.xml.sax.SAXException; import org.xml.sax.ContentHandler; interface SectionState {  void addChildMode(ModeUsage modeUsage, ContentHandler handler); void addValidator(Schema schema, ModeUsage modeUsage);  void addActiveHandler(ContentHandler handler, ModeUsage attributeModeUsage); void addAttributeValidationModeUsage(ModeUsage modeUsage); void reject() throws SAXException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import org.xml.sax.ContentHandler; class UnwrapAction extends ResultAction { UnwrapAction(ModeUsage modeUsage) { super(modeUsage); } void perform(ContentHandler handler, SectionState state) { state.addChildMode(getModeUsage(), handler); } ResultAction changeCurrentMode(Mode mode) { return new UnwrapAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.nrl.Mode; import com.thaiopensource.validate.nrl.ModeUsage; import com.thaiopensource.validate.nrl.NoResultAction; import com.thaiopensource.validate.nrl.SectionState; import org.xml.sax.SAXException; class ValidateAction extends NoResultAction { private final Schema schema; ValidateAction(ModeUsage modeUsage, Schema schema) { super(modeUsage); this.schema = schema; } void perform(SectionState state) throws SAXException { state.addValidator(schema, getModeUsage()); } NoResultAction changeCurrentMode(Mode mode) { return new ValidateAction(getModeUsage().changeCurrentMode(mode), schema); } public boolean equals(Object obj) { return super.equals(obj) && schema.equals(((ValidateAction)obj).schema); } public int hashCode() { return super.hashCode() ^ schema.hashCode(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nrl; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.xml.util.Name; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.DefaultHandler; import java.util.Enumeration; import java.util.Hashtable; import java.util.Stack; import java.util.Vector; class ValidatorImpl extends DefaultHandler implements Validator { static final Name OWNER_NAME = new Name(\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl;  abstract class Action {  private final ModeUsage modeUsage;  Action(ModeUsage modeUsage) { this.modeUsage = modeUsage; }  ModeUsage getModeUsage() { return modeUsage; }  public boolean equals(Object obj) { return obj != null && obj.getClass() == getClass() && ((Action)obj).modeUsage.equals(modeUsage); }  public int hashCode() { return getClass().hashCode() ^ modeUsage.hashCode(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl;  class ActionSet {  private ResultAction resultAction;  private NoResultAction[] noResultActions = new NoResultAction[0];  private boolean cancelNestedActions;  ResultAction getResultAction() { return resultAction; }  void setResultAction(ResultAction resultAction) { this.resultAction = resultAction; }  void addNoResultAction(NoResultAction action) { NoResultAction[] actions = new NoResultAction[noResultActions.length + 1]; System.arraycopy(noResultActions, 0, actions, 0, noResultActions.length); actions[noResultActions.length] = action; noResultActions = actions; }  NoResultAction[] getNoResultActions() { return noResultActions; }  boolean getCancelNestedActions() { return cancelNestedActions; }  void setCancelNestedActions(boolean cancelNestedActions) { this.cancelNestedActions = cancelNestedActions; }  ActionSet changeCurrentMode(Mode mode) { ActionSet actions = new ActionSet(); if (this.resultAction != null) actions.resultAction = this.resultAction.changeCurrentMode(mode); actions.noResultActions = new NoResultAction[this.noResultActions.length]; for (int i = 0; i < actions.noResultActions.length; i++) actions.noResultActions[i] = this.noResultActions[i].changeCurrentMode(mode); return actions; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl;  class AllowAction extends NoResultAction {  AllowAction(ModeUsage modeUsage) { super(modeUsage); }  void perform(SectionState state) { state.addChildMode(getModeUsage(), null); state.addAttributeValidationModeUsage(getModeUsage()); }  NoResultAction changeCurrentMode(Mode mode) { return new AllowAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.ContentHandler;  class AttachAction extends ResultAction {  AttachAction(ModeUsage modeUsage) { super(modeUsage); }  void perform(ContentHandler handler, SectionState state) { final ModeUsage modeUsage = getModeUsage(); if (handler != null) state.addActiveHandler(handler, modeUsage); else state.addAttributeValidationModeUsage(modeUsage); state.addChildMode(modeUsage, handler); }  ResultAction changeCurrentMode(Mode mode) { return new AttachAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.ContentHandler;  class AttachPlaceholderAction extends ResultAction {  AttachPlaceholderAction(ModeUsage modeUsage) { super(modeUsage); }  void perform(ContentHandler handler, SectionState state) { state.attachPlaceholder(getModeUsage(), handler); }  ResultAction changeCurrentMode(Mode mode) { return new AttachPlaceholderAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.validate.Schema;  class AttributeActionSet {  private boolean attach;  private boolean reject;  private boolean cancelNestedActions;  private Schema[] schemas = new Schema[0];  boolean getAttach() { return attach; }  void setAttach(boolean attach) { this.attach = attach; }  boolean getReject() { return reject; }  void setReject(boolean reject) { this.reject = reject; }  boolean getCancelNestedActions() { return cancelNestedActions; }  void setCancelNestedActions(boolean cancelNestedActions) { this.cancelNestedActions = cancelNestedActions; }  Schema[] getSchemas() { return schemas; }  void addSchema(Schema schema) { Schema[] s = new Schema[schemas.length + 1]; System.arraycopy(schemas, 0, s, 0, schemas.length); s[schemas.length] = schema; schemas = s; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.util.Equal; import java.util.Vector; import java.util.Hashtable; import java.util.Enumeration; import java.util.NoSuchElementException;  class ContextMap {  private Object rootValue;  private Object otherValue;  private final Hashtable nameTable = new Hashtable();  Object get(Vector context) { return get(context, context.size()); }  boolean put(boolean isRoot, Vector names, Object value) { return put(isRoot, names, names.size(), value); }  private Object get(Vector context, int len) { if (len > 0) { ContextMap nestedMap = (ContextMap)nameTable.get(context.elementAt(len - 1)); if (nestedMap != null) { Object value = nestedMap.get(context, len - 1); if (value != null) return value; } } if (rootValue != null && len == 0) return rootValue; return otherValue; }  private boolean put(boolean isRoot, Vector names, int len, Object value) { if (len == 0) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl;  class ElementsOrAttributes {  private static final int ELEMENTS_FLAG = 01;  private static final int ATTRIBUTES_FLAG = 02; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.Attributes;  class FilteredAttributes implements Attributes {  private final Attributes attributes;  private final IntSet indexSet;  private int[] reverseIndexMap;  public FilteredAttributes(IntSet indexSet, Attributes attributes) { this.indexSet = indexSet; this.attributes = attributes; }  private int reverseIndex(int k) { if (reverseIndexMap == null) { reverseIndexMap = new int[attributes.getLength()]; for (int i = 0, len = indexSet.size(); i < len; i++) reverseIndexMap[indexSet.get(i)] = i + 1; } return reverseIndexMap[k] - 1; }  public int getLength() { return indexSet.size(); }  public String getURI(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getURI(indexSet.get(index)); }  public String getLocalName(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getLocalName(indexSet.get(index)); }  public String getQName(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getQName(indexSet.get(index)); }  public String getType(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getType(indexSet.get(index)); }  public String getValue(int index) { if (index < 0 || index >= indexSet.size()) return null; return attributes.getValue(indexSet.get(index)); } public int getIndex(String uri, String localName) { int n = attributes.getIndex(uri, localName); if (n < 0) return n; return reverseIndex(n); } public int getIndex(String qName) { int n = attributes.getIndex(qName); if (n < 0) return n; return reverseIndex(n); }  private int getRealIndex(String uri, String localName) { int index = attributes.getIndex(uri, localName); if (index < 0 || reverseIndex(index) < 0) return -1; return index; }  private int getRealIndex(String qName) { int index = attributes.getIndex(qName); if (index < 0 || reverseIndex(index) < 0) return -1; return index; }  public String getType(String uri, String localName) { return attributes.getType(getRealIndex(uri, localName)); }  public String getValue(String uri, String localName) { return attributes.getValue(getRealIndex(uri, localName)); }  public String getType(String qName) { return attributes.getType(getRealIndex(qName)); }  public String getValue(String qName) { return attributes.getValue(getRealIndex(qName)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import java.util.Hashtable; import java.util.Enumeration;  class Hashset {  private final Hashtable table = new Hashtable();  boolean contains(Object key) { return table.get(key) != null; }  void add(Object key) { table.put(key, key); }  void addAll(Hashset set) { for (Enumeration e = set.table.keys(); e.hasMoreElements();) add(e.nextElement()); }  void clear() { table.clear(); }  Enumeration members() { return table.keys(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl;  class IntSet {  static private final int INIT_SIZE = 4;  private int[] v = null;  private int len = 0;  void add(int n) { if (v == null) { v = new int[INIT_SIZE]; v[0] = n; len = 1; return; } if (len == v.length) { int[] newv = new int[len*2]; System.arraycopy(v, 0, newv, 0, len); v = newv; } if (n > v[len - 1]) { v[len++] = n; return; } int i = 0; for (; i < len; i++) { if (n <= v[i]) { if (n == v[i]) return; break; } } for (int j = len; j >= i; j--) v[j + 1] = v[j]; v[i] = n; ++len; }  void addAll(IntSet is) { if (is.len == 0) return; int[] newv = new int[len + is.len]; int i = 0, j = 0, k = 0; while (i < len && j < is.len) { if (v[i] < is.v[j]) newv[k++] = v[i++]; else if (is.v[j] < v[i]) newv[k++] = is.v[j++]; else { newv[k++] = v[i++]; j++; } } while (i < len) newv[k++] = v[i++]; while (j < is.len) newv[k++] = is.v[j++]; v = newv; len = k; }  int size() { return len; }  int get(int i) { if (i >= len) throw new IndexOutOfBoundsException(); try { return v[i]; } catch (NullPointerException e) { throw new IndexOutOfBoundsException(); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.Locator; import org.xml.sax.helpers.LocatorImpl; import java.util.Hashtable; import java.util.Enumeration; import java.util.ArrayList; import java.util.Iterator; import java.util.List; class Mode { static final int ATTRIBUTE_PROCESSING_NONE = 0; static final int ATTRIBUTE_PROCESSING_QUALIFIED = 1; static final int ATTRIBUTE_PROCESSING_FULL = 2;  static final Mode CURRENT = new Mode(\"#current\", null);  private static final String ANONYMOUS_MODE_NAME_PREFIX = \"#anonymous#\";  private static int anonymousModeCounter = 0;  private boolean anonymous;  private final String name;  private Mode baseMode;  private boolean defined;  private Locator whereDefined;  private Locator whereUsed; private final Hashtable elementMap = new Hashtable(); private final Hashtable attributeMap = new Hashtable(); private int attributeProcessing = -1;  private final Hashtable nssElementMap = new Hashtable();  private final Hashtable nssAttributeMap = new Hashtable();  private List includedModes = new ArrayList(); void addIncludedMode(Mode mode) { includedModes.add(mode); }  Mode(String name, Mode baseMode) { this.name = name; this.baseMode = baseMode; }  public Mode(Mode baseMode) { this(ANONYMOUS_MODE_NAME_PREFIX+anonymousModeCounter++, baseMode); anonymous = true; }  String getName() { return name; }  Mode getBaseMode() { return baseMode; }  void setBaseMode(Mode baseMode) { this.baseMode = baseMode; }  ActionSet getElementActions(String ns) { ActionSet actions = getElementActionsExplicit(ns); if (actions == null) { actions = getElementActionsExplicit(NamespaceSpecification.ANY_NAMESPACE); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.util.Equal; import java.util.Vector; import java.util.Enumeration;  class ModeUsage {  private final Mode mode;  private final Mode currentMode;  private ContextMap modeMap; private int attributeProcessing = -1;  ModeUsage(Mode mode, Mode currentMode) { this(mode, currentMode, null); }  private ModeUsage(Mode mode, Mode currentMode, ContextMap modeMap) { this.mode = mode; this.currentMode = currentMode; this.modeMap = modeMap; }  ModeUsage changeCurrentMode(Mode currentMode) { return new ModeUsage(mode, currentMode, modeMap); }  public boolean equals(Object obj) { if (!(obj instanceof ModeUsage)) return false; ModeUsage other = (ModeUsage)obj; return this.mode == other.mode && this.currentMode == other.currentMode && Equal.equal(this.modeMap, other.modeMap); }  public int hashCode() { int hc = mode.hashCode() ^ currentMode.hashCode(); if (modeMap != null) hc ^= modeMap.hashCode(); return hc; }  private Mode resolve(Mode mode) { if (mode == Mode.CURRENT) { return currentMode; } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import java.util.StringTokenizer;  class NamespaceSpecification {  public static String DEFAULT_WILDCARD = \"*\";  static final String ANY_NAMESPACE = \"##any\";  String ns=\"\\0\";  String wildcard = DEFAULT_WILDCARD;  public NamespaceSpecification(String ns) { this(ns, DEFAULT_WILDCARD); }  public NamespaceSpecification(String ns, String wildcard) { this.ns = ns; this.wildcard = wildcard; }  public boolean compete(NamespaceSpecification other) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.SAXException;  abstract class NoResultAction extends Action {  NoResultAction(ModeUsage modeUsage) { super(modeUsage); }  abstract void perform(SectionState state) throws SAXException;  abstract NoResultAction changeCurrentMode(Mode mode); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.Option;  public class NvdlSchemaReceiverFactory implements SchemaReceiverFactory {  public SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties) { if (!SchemaImpl.NVDL_URI.equals(namespaceUri)) return null; return new SchemaReceiverImpl(properties); }  public Option getOption(String uri) { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.xml.util.Naming; import java.util.Vector;  class Path {  private final boolean root;  private final Vector names;  Path(boolean root, Vector names) { this.root = root; this.names = names; }  boolean isRoot() { return root; }  Vector getNames() { return names; }  public String toString() { StringBuffer buf = new StringBuffer(); if (root) buf.append('/'); for (int i = 0, len = names.size(); i < len; i++) { if (i != 0) buf.append('/'); buf.append((String)names.elementAt(i)); } return buf.toString(); }  static class ParseException extends Exception {  private final String messageKey;  ParseException(String messageKey) { super(messageKey); this.messageKey = messageKey; }  public String getMessageKey() { return messageKey; } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.SAXException;  class RejectAction extends NoResultAction {  RejectAction(ModeUsage modeUsage) { super(modeUsage); }  void perform(SectionState state) throws SAXException { final ModeUsage modeUsage = getModeUsage(); state.reject(); state.addChildMode(modeUsage, null); state.addAttributeValidationModeUsage(modeUsage); }  NoResultAction changeCurrentMode(Mode mode) { return new RejectAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.SAXException; import org.xml.sax.ContentHandler;  abstract class ResultAction extends Action {  ResultAction(ModeUsage modeUsage) { super(modeUsage); }  abstract void perform(ContentHandler handler, SectionState state) throws SAXException;  abstract ResultAction changeCurrentMode(Mode mode); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.util.Uri; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.OptionArgumentException; import com.thaiopensource.validate.OptionArgumentPresenceException; import com.thaiopensource.validate.ResolverFactory; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.validate.prop.wrap.WrapProperty; import com.thaiopensource.xml.sax.CountingErrorHandler; import com.thaiopensource.xml.sax.DelegatingContentHandler; import com.thaiopensource.xml.sax.XmlBaseHandler; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.Attributes; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.LocatorImpl; import java.io.IOException; import java.util.ArrayList; import java.util.Enumeration; import java.util.HashSet; import java.util.Hashtable; import java.util.List; import java.util.Set; import java.util.Stack; import java.util.StringTokenizer; import java.util.Vector;  class SchemaImpl extends AbstractSchema {  static private final String IMPLICIT_MODE_NAME = \"#implicit\";  static private final String WRAPPER_MODE_NAME = \"#wrapper\";  static final String NVDL_URI = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.auto.AutoSchemaReader; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.prop.wrap.WrapProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import com.thaiopensource.validate.rng.SAXSchemaReader; import com.thaiopensource.xml.util.Name; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import javax.xml.transform.sax.SAXSource; import java.io.IOException; import java.io.InputStream; import java.net.URL;  class SchemaReceiverImpl implements SchemaReceiver {  private static final String NVDL_SCHEMA = \"nvdl.rng\";  private static final String RNC_MEDIA_TYPE = \"application/relax-ng-compact-syntax\";  static final String LEGACY_RNC_MEDIA_TYPE = \"application/x-rnc\";  private final PropertyMap properties;  private final Name attributeOwner;  private final SchemaReader autoSchemaReader;  private Schema nvdlSchema = null;  private static final PropertyId subSchemaProperties[] = { ValidateProperty.ERROR_HANDLER, ValidateProperty.XML_READER_CREATOR, ValidateProperty.ENTITY_RESOLVER, ValidateProperty.URI_RESOLVER, ValidateProperty.RESOLVER, SchemaReceiverFactory.PROPERTY, };  public SchemaReceiverImpl(PropertyMap properties) { this.attributeOwner = properties.get(WrapProperty.ATTRIBUTE_OWNER); PropertyMapBuilder builder = new PropertyMapBuilder(); for (int i = 0; i < subSchemaProperties.length; i++) { Object value = properties.get(subSchemaProperties[i]); if (value != null) builder.put(subSchemaProperties[i], value); } this.properties = builder.toPropertyMap(); this.autoSchemaReader = new AutoSchemaReader(properties.get(SchemaReceiverFactory.PROPERTY)); } public SchemaFuture installHandlers(XMLReader xr) { PropertyMapBuilder builder = new PropertyMapBuilder(properties); if (attributeOwner != null) builder.put(WrapProperty.ATTRIBUTE_OWNER, attributeOwner); return new SchemaImpl(builder.toPropertyMap()).installHandlers(xr, this); } Schema getNvdlSchema() throws IOException, IncorrectSchemaException, SAXException { if (nvdlSchema == null) { String className = SchemaReceiverImpl.class.getName(); String resourceName = className.substring(0, className.lastIndexOf('.')).replace('.', '/') + \"/resources/\" + NVDL_SCHEMA; URL nvdlSchemaUrl = getResource(resourceName); InputStream stream = nvdlSchemaUrl.openStream(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.validate.Schema; import org.xml.sax.SAXException; import org.xml.sax.ContentHandler; interface SectionState {  void addChildMode(ModeUsage modeUsage, ContentHandler handler); void addValidator(Schema schema, ModeUsage modeUsage);  void addActiveHandler(ContentHandler handler, ModeUsage attributeModeUsage); void addAttributeValidationModeUsage(ModeUsage modeUsage); void reject() throws SAXException; void attachPlaceholder(ModeUsage modeUsage, ContentHandler handler); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import java.util.Set;  public class Trigger {  String namespace;  Set elementNames;  Trigger(String namespace, Set elementNames) { this.elementNames = elementNames; this.namespace = namespace; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import org.xml.sax.ContentHandler;  class UnwrapAction extends ResultAction {  UnwrapAction(ModeUsage modeUsage) { super(modeUsage); }  void perform(ContentHandler handler, SectionState state) { state.addChildMode(getModeUsage(), handler); }  ResultAction changeCurrentMode(Mode mode) { return new UnwrapAction(getModeUsage().changeCurrentMode(mode)); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.validate.Schema; import org.xml.sax.SAXException;  class ValidateAction extends NoResultAction {  private final Schema schema;  ValidateAction(ModeUsage modeUsage, Schema schema) { super(modeUsage); this.schema = schema; }  void perform(SectionState state) throws SAXException { state.addValidator(schema, getModeUsage()); }  NoResultAction changeCurrentMode(Mode mode) { return new ValidateAction(getModeUsage().changeCurrentMode(mode), schema); }  public boolean equals(Object obj) { return super.equals(obj) && schema.equals(((ValidateAction)obj).schema); }  public int hashCode() { return super.hashCode() ^ schema.hashCode(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.nvdl; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.xml.util.Name; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.AttributesImpl; import org.xml.sax.helpers.DefaultHandler; import java.util.Enumeration; import java.util.Hashtable; import java.util.Iterator; import java.util.List; import java.util.Stack; import java.util.Vector;  class ValidatorImpl extends DefaultHandler implements Validator { /** * The name for the virtual element that we use for attribute section validation. * It has http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; class AttributePathPattern extends PathPattern { AttributePathPattern(String[] names, boolean[] descendantsOrSelf) { super(names, descendantsOrSelf); } boolean isAttribute() { return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; class ChoicePattern extends Pattern { private final Pattern[] choices; ChoicePattern(Pattern[] choices) { this.choices = choices; } boolean matches(Path path, int rootDepth) { for (int i = 0; i < choices.length; i++) if (choices[i].matches(path, rootDepth)) return true; return false; } public String toString() { StringBuffer buf = new StringBuffer(); for (int i = 0; i < choices.length; i++) { if (i != 0) buf.append('|'); buf.append(choices[i].toString()); } return buf.toString(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; interface Constraint { void activate(PatternManager pm); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; class ElementPathPattern extends PathPattern { ElementPathPattern(String[] names, boolean[] descendantsOrSelf) { super(names, descendantsOrSelf); } boolean isAttribute() { return false; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import org.xml.sax.Locator; interface ErrorContext {  void error(Locator locator, String key);  void error(Locator locator, String key, String arg);  Locator saveLocator(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; class InvalidPatternException extends Exception { }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import org.xml.sax.Locator; import java.util.Hashtable; import java.util.Vector; import java.util.Enumeration; class KeyConstraint implements Constraint { private final Pattern key; KeyConstraint(Pattern key) { this.key = key; } static class KeyIndex { private final Hashtable table; KeyIndex() { table = new Hashtable(); } KeyInfo lookupCreate(Object key) { KeyInfo info = (KeyInfo)table.get(key); if (info == null) { info = new KeyInfo(); table.put(key, info); } return info; } Enumeration keys() { return table.keys(); } } static class KeyInfo { String representation; Locator firstKeyLocator; Vector pendingRefLocators; } static class KeySelectionHandler extends SelectedValueHandler { private final KeyIndex index; KeySelectionHandler(KeyIndex index) { this.index = index; } void select(ErrorContext ec, Locator locator, Object value, String representation) { KeyInfo info = index.lookupCreate(value); if (info.firstKeyLocator == null) { if (locator == null) locator = ec.saveLocator(); info.firstKeyLocator = locator; info.pendingRefLocators = null; info.representation = representation; } else ec.error(locator, \"duplicate_key\", representation); } } public void activate(PatternManager pm) { activate(pm, new KeyIndex()); } void activate(PatternManager pm, KeyIndex index) { pm.registerPattern(key, new ValueSelectionHandler(new KeySelectionHandler(index))); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import org.xml.sax.Locator; import java.util.Vector; import java.util.Enumeration; class KeyRefConstraint extends KeyConstraint { private final Pattern ref; static class RefSelectionHandler extends SelectedValueHandler { private final KeyIndex index; RefSelectionHandler(KeyConstraint.KeyIndex index) { this.index = index; } void select(ErrorContext ec, Locator locator, Object value, String representation) { KeyInfo info = index.lookupCreate(value); if (info.firstKeyLocator == null) { if (info.pendingRefLocators == null) info.pendingRefLocators = new Vector(); if (locator == null) locator = ec.saveLocator(); info.pendingRefLocators.addElement(locator); } if (info.representation == null) info.representation = representation; } public void selectComplete(ErrorContext ec) { for (Enumeration e = index.keys(); e.hasMoreElements();) { Object key = e.nextElement(); KeyInfo info = index.lookupCreate(key); if (info.pendingRefLocators == null) continue; for (int i = 0, len = info.pendingRefLocators.size(); i < len; i++) { Locator loc = (Locator)info.pendingRefLocators.elementAt(i); ec.error(loc, \"undefined_key\", info.representation); } } } } KeyRefConstraint(Pattern key, Pattern ref) { super(key); this.ref = ref; } void activate(PatternManager pm, KeyIndex index) { super.activate(pm, index); pm.registerPattern(ref, new ValueSelectionHandler(new RefSelectionHandler(index))); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; class MultiConstraint implements Constraint { private final Constraint[] constraints; MultiConstraint(Constraint[] constraints) { this.constraints = constraints; } public void activate(PatternManager pm) { for (int i = 0; i < constraints.length; i++) constraints[i].activate(pm); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; interface NamespaceContext { String getNamespaceUri(String string); String defaultPrefix(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; class NotAllowedPattern extends Pattern { boolean matches(Path path, int rootDepth) { return false; } public String toString() { return \"(notAllowed)\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; interface Path { int length(); String getLocalName(int i); String getNamespaceUri(int i); boolean isAttribute(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; abstract class PathPattern extends Pattern { private final String[] names; private final boolean[] descendantsOrSelf; static final String ANY = \"#any\"; PathPattern(String[] names, boolean[] descendantsOrSelf) { this.names = names; this.descendantsOrSelf = descendantsOrSelf; } abstract boolean isAttribute(); boolean matches(Path path, int rootDepth) { return (isAttribute() == path.isAttribute() && matchSegment(path, rootDepth, path.length() - rootDepth, 0, names.length >> 1, false)); } private boolean matchSegment(Path path, int pathStartIndex, int pathLength, int patternStartIndex, int patternLength, boolean ignoreRightmostDescendantsOrSelf) { if (patternLength > pathLength) return false; while (patternLength > 0 && (ignoreRightmostDescendantsOrSelf || !descendantsOrSelf[patternStartIndex + patternLength])) { if (!matchStep(path, pathStartIndex + pathLength - 1, patternStartIndex + patternLength - 1)) return false; pathLength--; patternLength--; ignoreRightmostDescendantsOrSelf = false; } while (patternLength > 0 && !descendantsOrSelf[patternStartIndex]) { if (!matchStep(path, pathStartIndex, patternStartIndex)) return false; pathStartIndex++; patternStartIndex++; pathLength--; patternLength--; } if (patternLength == 0) return descendantsOrSelf[patternStartIndex] || pathLength == 0; for (pathLength--; pathLength >= patternLength; pathLength--) if (matchSegment(path, pathStartIndex, pathLength, patternStartIndex, patternLength, true)) return true; return false; } private boolean matchStep(Path path, int pathIndex, int patternIndex) { patternIndex *= 2; return (matchName(path.getNamespaceUri(pathIndex), names[patternIndex]) && matchName(path.getLocalName(pathIndex), names[patternIndex + 1])); } private static boolean matchName(String str, String pattern) { if (pattern == ElementPathPattern.ANY) return true; return str.equals(pattern); } public String toString() { StringBuffer buf = new StringBuffer(); for (int i = 0, j = 0; i < names.length; i += 2, j++) { if (j != 0) buf.append(descendantsOrSelf[j] ? \""}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; abstract class Pattern { abstract boolean matches(Path path, int rootDepth); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import java.util.Vector; class PatternBuilder { static final byte CHILD = 0; static final byte ATTRIBUTE = 1; private boolean hadDescendantOrSelf = false; private final Vector choices = new Vector(); private final Vector names = new Vector(); private final Vector descendantsOrSelf = new Vector(); private static final int NO_ATTRIBUTE = 0; private static final int LAST_WAS_ATTRIBUTE = 1; private static final int NON_LEAF_ATTRIBUTE = 2; private int attributeType = NO_ATTRIBUTE; void addName(byte type, String namespaceUri, String localName) { descendantsOrSelf.addElement(Boolean.valueOf(hadDescendantOrSelf)); hadDescendantOrSelf = false; names.addElement(namespaceUri); names.addElement(localName); switch (attributeType) { case LAST_WAS_ATTRIBUTE: attributeType = NON_LEAF_ATTRIBUTE; break; case NO_ATTRIBUTE: if (type == ATTRIBUTE) attributeType = LAST_WAS_ATTRIBUTE; break; } } void addAnyName(byte type) { addName(type, PathPattern.ANY, PathPattern.ANY); } void addNsName(byte type, String namespaceUri) { addName(type, namespaceUri, PathPattern.ANY); } void addDescendantsOrSelf() { if (attributeType == NO_ATTRIBUTE) hadDescendantOrSelf = true; } private PathPattern wrapUpAlternative() { PathPattern result; if (attributeType == NON_LEAF_ATTRIBUTE) result = null; else { String[] namesArray = new String[names.size()]; for (int i = 0; i < namesArray.length; i++) namesArray[i] = (String)names.elementAt(i); boolean[] descendantsOrSelfArray = new boolean[descendantsOrSelf.size() + 1]; for (int i = 0; i < descendantsOrSelfArray.length - 1; i++) descendantsOrSelfArray[i] = ((Boolean)descendantsOrSelf.elementAt(i)).booleanValue(); descendantsOrSelfArray[descendantsOrSelfArray.length - 1] = hadDescendantOrSelf; if (attributeType == NO_ATTRIBUTE) result = new ElementPathPattern(namesArray, descendantsOrSelfArray); else result = new AttributePathPattern(namesArray, descendantsOrSelfArray); } cleanupAlternative(); return result; } private void cleanupAlternative() { attributeType = NO_ATTRIBUTE; hadDescendantOrSelf = false; names.setSize(0); descendantsOrSelf.setSize(0); } void cleanup() { cleanupAlternative(); choices.setSize(0); } void alternative() { Pattern pattern = wrapUpAlternative(); if (pattern != null) choices.addElement(pattern); } Pattern createPattern() { Pattern pattern = wrapUpAlternative(); if (choices.size() == 0) { if (pattern == null) return new NotAllowedPattern(); return pattern; } else { if (pattern != null) choices.addElement(pattern); Pattern[] patterns = new Pattern[choices.size()]; for (int i = 0; i < patterns.length; i++) patterns[i] = (Pattern)choices.elementAt(i); return new ChoicePattern(patterns); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; interface PatternManager { void registerPattern(Pattern pattern, SelectionHandler handler); void registerValueHandler(ValueHandler handler); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import com.thaiopensource.util.Localizer; import com.thaiopensource.xml.util.Naming; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.Locator; import org.xml.sax.SAXParseException; class PatternParser { private final ErrorHandler eh; private final Localizer localizer; private String pattern; private int patternOffset; private int patternLength; private int currentToken; private int tokenStartOffset; private String tokenNamespaceUri; private String tokenLocalName; private final PatternBuilder builder = new PatternBuilder(); private NamespaceContext namespaceContext; private final StringBuffer nameBuffer = new StringBuffer(); private static final int TOKEN_EOF = 0; private static final int TOKEN_SLASH = 1; private static final int TOKEN_SLASH_SLASH = 2; private static final int TOKEN_CHOICE = 3; private static final int TOKEN_CHILD_AXIS = 4; private static final int TOKEN_ATTRIBUTE_AXIS = 5; private static final int TOKEN_DOT = 6; private static final int TOKEN_QNAME = 7; private static final int TOKEN_NCNAME_STAR = 8; private static final int TOKEN_STAR = 9; private Locator locator; PatternParser(ErrorHandler eh, Localizer localizer) { this.eh = eh; this.localizer = localizer; } Pattern parse(String pattern, Locator locator, NamespaceContext namespaceContext) throws SAXException, InvalidPatternException { this.pattern = pattern; this.patternOffset = 0; this.patternLength = pattern.length(); this.locator = locator; this.namespaceContext = namespaceContext; try { do { parseChoice(); } while (currentToken == TOKEN_CHOICE); return builder.createPattern(); } finally { builder.cleanup(); } } private void parseChoice() throws SAXException, InvalidPatternException { for (;;) { parseStep(); advance(); switch (currentToken) { case TOKEN_SLASH: break; case TOKEN_SLASH_SLASH: builder.addDescendantsOrSelf(); break; case TOKEN_CHOICE: builder.alternative(); return; case TOKEN_EOF: return; default: throw error(\"expected_step_connector\"); } } } private void parseStep() throws SAXException, InvalidPatternException { advance(); byte type; switch (currentToken) { case TOKEN_ATTRIBUTE_AXIS: type = PatternBuilder.ATTRIBUTE; advance(); break; case TOKEN_CHILD_AXIS: type = PatternBuilder.CHILD; advance(); break; case TOKEN_DOT: return; default: type = PatternBuilder.CHILD; break; } switch (currentToken) { case TOKEN_QNAME: builder.addName(type, tokenNamespaceUri, tokenLocalName); break; case TOKEN_STAR: builder.addAnyName(type); break; case TOKEN_NCNAME_STAR: builder.addNsName(type, tokenNamespaceUri); break; default: throw error(\"expected_name_test\"); } } private void advance() throws SAXException, InvalidPatternException { for (;;) { tokenStartOffset = patternOffset; if (patternOffset >= patternLength) { currentToken = TOKEN_EOF; return; } char ch = pattern.charAt(patternOffset); switch (ch) { case ' ': case '\\t': case '\\r': case '\\n': patternOffset++; continue; case '.': patternOffset++; currentToken = TOKEN_DOT; return; case '@': patternOffset++; currentToken = TOKEN_ATTRIBUTE_AXIS; return; case '|': patternOffset++; currentToken = TOKEN_CHOICE; return; case '/': if (++patternOffset < patternLength && pattern.charAt(patternOffset) == '/') { patternOffset++; currentToken = TOKEN_SLASH_SLASH; } else currentToken = TOKEN_SLASH; return; case '*': patternOffset++; currentToken = TOKEN_STAR; return; } String name = scanNCName(\"illegal_char\"); if ((name.equals(\"child\") || name.equals(\"attribute\")) && tryScanDoubleColon()) { currentToken = name.charAt(0) == 'c' ? TOKEN_CHILD_AXIS : TOKEN_ATTRIBUTE_AXIS; return; } if (patternOffset < patternLength && pattern.charAt(patternOffset) == ':') { tokenNamespaceUri = expandPrefix(name); patternOffset++; if (patternOffset == patternLength) throw error(\"expected_star_or_ncname\"); if (pattern.charAt(patternOffset) == '*') { patternOffset++; currentToken = TOKEN_NCNAME_STAR; return; } tokenLocalName = scanNCName(\"expected_star_or_ncname\"); currentToken = TOKEN_QNAME; return; } tokenLocalName = name; tokenNamespaceUri = namespaceContext.defaultPrefix(); currentToken = TOKEN_QNAME; return; } } private boolean tryScanDoubleColon() { for (int i = patternOffset; i < patternLength; i++) { switch (pattern.charAt(i)) { case ' ': case '\\t': case '\\r': case '\\n': break; case ':': if (++i < patternLength && pattern.charAt(i) == ':') { patternOffset = i + 1; return true; } default: return false; } } return false; } private String expandPrefix(String prefix) throws SAXException, InvalidPatternException { String ns = namespaceContext.getNamespaceUri(prefix); if (ns == null) throw error(\"unbound_prefix\", prefix); return ns; } private String scanNCName(String message) throws SAXException, InvalidPatternException { char ch = pattern.charAt(patternOffset++); if (!maybeNameStartChar(ch)) throw error(message); nameBuffer.setLength(0); nameBuffer.append(ch); for (; patternOffset < patternLength; patternOffset++) { ch = pattern.charAt(patternOffset); if (!maybeNameChar(ch)) break; nameBuffer.append(ch); } String name = nameBuffer.toString(); if (!Naming.isNcname(name)) throw error(\"illegal_ncname\", name); return name; } private static boolean maybeNameStartChar(char ch) { return ch > 0x80 || Character.isLetter(ch) || ch == '_'; } private static boolean maybeNameChar(char ch) { return ch > 0x80 || Character.isLetterOrDigit(ch) || \".-_\".indexOf(ch) >= 0; } private InvalidPatternException error(String key) throws SAXException { if (eh != null) eh.error(new SAXParseException(addContext(localizer.message(key)), locator)); return new InvalidPatternException(); } private InvalidPatternException error(String key, String arg) throws SAXException { if (eh != null) eh.error(new SAXParseException(addContext(localizer.message(key, arg)), locator)); return new InvalidPatternException(); } private String addContext(String message) { return localizer.message(\"context\", new Object[] { message, pattern.substring(0, tokenStartOffset), pattern.substring(tokenStartOffset, patternOffset), pattern.substring(patternOffset) }); } static public void main(String[] args) throws SAXException { PatternParser parser = new PatternParser(new com.thaiopensource.xml.sax.ErrorHandlerImpl(), new Localizer(PatternParser.class)); String[] tests = { \"foo"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.Option; import com.thaiopensource.util.PropertyMap; public class PiclSchemaReceiverFactory implements SchemaReceiverFactory { private static final String PICL_URI = SchemaReader.BASE_URI + \"picl\"; public SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties) { if (!PICL_URI.equals(namespaceUri)) return null; return new SchemaReceiverImpl(properties); } public Option getOption(String uri) { return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.Validator; import com.thaiopensource.util.PropertyMap; class SchemaImpl extends AbstractSchema { private final Constraint constraint; SchemaImpl(PropertyMap properties, Constraint constraint) { super(properties); this.constraint = constraint; } public Validator createValidator(PropertyMap properties) { return new ValidatorImpl(constraint, properties); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.SinglePropertyMap; import com.thaiopensource.util.Localizer; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.xml.sax.CountingErrorHandler; import com.thaiopensource.xml.sax.DelegatingContentHandler; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.Attributes; import java.util.Vector; import java.util.Stack; class SchemaParser extends DelegatingContentHandler implements SchemaFuture, NamespaceContext { private final Vector constraints = new Vector(); private final PropertyMap properties; private final CountingErrorHandler ceh; private Locator locator; private final Stack prefixes = new Stack(); private final Localizer localizer = new Localizer(SchemaParser.class); private final PatternParser patternParser; SchemaParser(PropertyMap properties, Schema piclSchema) { this.properties = properties; ceh = new CountingErrorHandler(properties.get(ValidateProperty.ERROR_HANDLER)); Validator validator = piclSchema.createValidator(SinglePropertyMap.newInstance(ValidateProperty.ERROR_HANDLER, ceh)); setDelegate(validator.getContentHandler()); patternParser = new PatternParser(ceh, localizer); } public void setDocumentLocator(Locator locator) { super.setDocumentLocator(locator); this.locator = locator; } public void startDocument() throws SAXException { super.startDocument(); prefixes.push(\"xml\"); prefixes.push(WellKnownNamespaces.XML); } public void startPrefixMapping(String prefix, String uri) throws SAXException { if (prefix == null) prefix = \"\"; prefixes.push(prefix); if (uri != null && uri.length() == 0) uri = null; prefixes.push(uri); super.startPrefixMapping(prefix, uri); } public void endPrefixMapping(String prefix) throws SAXException { prefixes.pop(); prefixes.pop(); super.endPrefixMapping(prefix); } public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException { super.startElement(namespaceURI, localName, qName, atts); if (ceh.getHadErrorOrFatalError()) return; if (!localName.equals(\"constraint\")) return; String key = atts.getValue(\"\", \"key\"); try { Pattern keyPattern = patternParser.parse(key, locator, this); String ref = atts.getValue(\"\", \"ref\"); if (ref != null) { Pattern refPattern = patternParser.parse(ref, locator, this); constraints.addElement(new KeyRefConstraint(keyPattern, refPattern)); } else constraints.addElement(new KeyConstraint(keyPattern)); } catch (InvalidPatternException e) { } } public Schema getSchema() throws IncorrectSchemaException { if (ceh.getHadErrorOrFatalError()) throw new IncorrectSchemaException(); Constraint constraint; if (constraints.size() == 1) constraint = (Constraint)constraints.elementAt(0); else { Constraint[] v = new Constraint[constraints.size()]; for (int i = 0; i < v.length; i++) v[i] = (Constraint)constraints.elementAt(i); constraint = new MultiConstraint(v); } return new SchemaImpl(properties, constraint); } public RuntimeException unwrapException(RuntimeException e) { return e; } public String getNamespaceUri(String prefix) { for (int i = prefixes.size(); i > 0; i -= 2) { if (prefixes.elementAt(i - 2).equals(prefix)) return (String)prefixes.elementAt(i - 1); } return null; } public String defaultPrefix() { return \"\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.SinglePropertyMap; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.rng.CompactSchemaReader; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import java.io.IOException; import java.net.URL; class SchemaReceiverImpl implements SchemaReceiver { private final String PICL_SCHEMA = \"picl.rnc\"; private Schema piclSchema = null; private final PropertyMap properties; SchemaReceiverImpl(PropertyMap properties) { this.properties = SinglePropertyMap.newInstance(ValidateProperty.ERROR_HANDLER, properties.get(ValidateProperty.ERROR_HANDLER)); } public SchemaFuture installHandlers(XMLReader xr) throws SAXException { SchemaParser parser = new SchemaParser(properties, getPiclSchema()); xr.setContentHandler(parser); return parser; } private Schema getPiclSchema() throws SAXException { if (piclSchema == null) { String className = SchemaReceiverImpl.class.getName(); String resourceName = className.substring(0, className.lastIndexOf('.')).replace('.', '/') + \"/resources/\" + PICL_SCHEMA; URL nrlSchemaUrl = getResource(resourceName); try { piclSchema = CompactSchemaReader.getInstance().createSchema(new InputSource(nrlSchemaUrl.toString()), properties); } catch (IncorrectSchemaException e) { throw new SAXException(\"unexpected internal error in RNC schema for picl\"); } catch (IOException e) { throw new SAXException(e); } } return piclSchema; } private static URL getResource(String resourceName) { ClassLoader cl = SchemaReceiverImpl.class.getClassLoader(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import org.xml.sax.Locator; abstract class SelectedValueHandler {  abstract void select(ErrorContext ec, Locator locator, Object value, String representation); void selectComplete(ErrorContext ec) { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; interface SelectionHandler { void selectElement(ErrorContext ec, Path path, PatternManager pm); void selectAttribute(ErrorContext ec, Path path, String value); void selectComplete(ErrorContext ec); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyMap; import org.xml.sax.helpers.DefaultHandler; import org.xml.sax.helpers.LocatorImpl; import org.xml.sax.ContentHandler; import org.xml.sax.Attributes; import org.xml.sax.DTDHandler; import org.xml.sax.SAXException; import org.xml.sax.Locator; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXParseException; import java.util.Stack; class ValidatorImpl extends DefaultHandler implements Validator, Path, PatternManager, ErrorContext { private final Constraint constraint; private final Stack openElements = new Stack(); private final Stack valueHandlers = new Stack(); private final Stack activePatterns = new Stack(); private final AttributePath attributePath = new AttributePath(); private Locator locator; private final ErrorHandler eh; private final Localizer localizer = new Localizer(ValidatorImpl.class); private static class WrappedSAXException extends RuntimeException { final SAXException exception; WrappedSAXException(SAXException exception) { this.exception = exception; } } static class ActivePattern { final int rootDepth; final Pattern pattern; final SelectionHandler handler; ActivePattern(int rootDepth, Pattern pattern, SelectionHandler handler) { this.rootDepth = rootDepth; this.pattern = pattern; this.handler = handler; } } static class OpenElement { final String namespaceUri; final String localName; int nActivePatterns; int nValueHandlers; OpenElement(String namespaceUri, String localName) { this.namespaceUri = namespaceUri; this.localName = localName; } } class AttributePath implements Path { private Attributes atts; private int attIndex; void set(Attributes atts, int attIndex) { this.atts = atts; this.attIndex = attIndex; } public boolean isAttribute() { return true; } public int length() { return ValidatorImpl.this.length() + 1; } public String getLocalName(int i) { if (i == openElements.size()) return atts.getLocalName(attIndex); return ValidatorImpl.this.getLocalName(i); } public String getNamespaceUri(int i) { if (i == openElements.size()) return atts.getURI(attIndex); return ValidatorImpl.this.getNamespaceUri(i); } } ValidatorImpl(Constraint constraint, PropertyMap properties) { this.constraint = constraint; this.eh = properties.get(ValidateProperty.ERROR_HANDLER); } public ContentHandler getContentHandler() { return this; } public DTDHandler getDTDHandler() { return null; } public void reset() { openElements.setSize(0); valueHandlers.setSize(0); activePatterns.setSize(0); locator = null; } public int length() { return openElements.size(); } public String getLocalName(int i) { return ((OpenElement)openElements.elementAt(i)).localName; } public String getNamespaceUri(int i) { return ((OpenElement)openElements.elementAt(i)).namespaceUri; } public boolean isAttribute() { return false; } public void registerPattern(Pattern pattern, SelectionHandler handler) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; interface ValueHandler { void characters(ErrorContext ec, char[] buf, int start, int len); void tag(ErrorContext ec); void valueComplete(ErrorContext ec); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.picl; import org.xml.sax.Locator; class ValueSelectionHandler implements SelectionHandler { private final SelectedValueHandler handler; ValueSelectionHandler(SelectedValueHandler handler) { this.handler = handler; } public void selectAttribute(ErrorContext ec, Path path, String value) { handler.select(ec, null, value, value); } static class ValueHandlerImpl implements ValueHandler { private final StringBuffer buf = new StringBuffer(); private final Locator locator; private final SelectedValueHandler handler; ValueHandlerImpl(SelectedValueHandler handler, Locator locator) { this.handler = handler; this.locator = locator; } public void characters(ErrorContext ec, char[] chars, int start, int len) { buf.append(chars, start, len); } public void tag(ErrorContext ec) { } public void valueComplete(ErrorContext ec) { String value = buf.toString(); handler.select(ec, locator, value, value); } } public void selectElement(ErrorContext ec, Path path, PatternManager pm) { pm.registerValueHandler(new ValueHandlerImpl(handler, ec.saveLocator())); } public void selectComplete(ErrorContext ec) { handler.selectComplete(ec); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.prop.rng; import com.thaiopensource.util.PropertyId; import com.thaiopensource.validate.FlagOption; import com.thaiopensource.validate.FlagPropertyId; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.StringPropertyId; import org.relaxng.datatype.DatatypeLibraryFactory; public class RngProperty { private RngProperty() { } public static final PropertyId<DatatypeLibraryFactory> DATATYPE_LIBRARY_FACTORY = PropertyId.newInstance(\"DATATYPE_LIBRARY_FACTORY\", DatatypeLibraryFactory.class); public static final FlagPropertyId CHECK_ID_IDREF = new FlagPropertyId(\"CHECK_ID_IDREF\"); public static final FlagPropertyId FEASIBLE = new FlagPropertyId(\"FEASIBLE\"); public static final StringPropertyId SIMPLIFIED_SCHEMA = new StringPropertyId(\"SIMPLIFIED_SCHEMA\"); public static Option getOption(String uri) { if (!uri.startsWith(SchemaReader.BASE_URI)) return null; uri = uri.substring(SchemaReader.BASE_URI.length()); if (uri.equals(\"feasible\")) return new FlagOption(FEASIBLE); if (uri.equals(\"check-id-idref\")) return new FlagOption(CHECK_ID_IDREF); return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.prop.schematron; import com.thaiopensource.validate.StringPropertyId; import com.thaiopensource.validate.FlagPropertyId; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.FlagOption; import com.thaiopensource.validate.StringOption; import com.thaiopensource.validate.OptionArgumentFormatException; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.xml.util.Naming;  public class SchematronProperty { private SchematronProperty() { }  public static final StringPropertyId PHASE = new StringPropertyId(\"PHASE\"); static public class PhaseOption extends StringOption { private PhaseOption() { super(PHASE); } public String normalize(String value) throws OptionArgumentFormatException { value = value.trim(); if (!value.equals(\"#ALL\") && !Naming.isNcname(value)) throw new OptionArgumentFormatException(); return value; } } public static final StringOption PHASE_OPTION = new PhaseOption();  public static final FlagPropertyId DIAGNOSE = new FlagPropertyId(\"DIAGNOSE\"); public static Option getOption(String uri) { if (!uri.startsWith(SchemaReader.BASE_URI)) return null; uri = uri.substring(SchemaReader.BASE_URI.length()); if (uri.equals(\"diagnose\")) return new FlagOption(DIAGNOSE); if (uri.equals(\"phase\")) return PHASE_OPTION; return null; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.prop.wrap; import com.thaiopensource.util.PropertyId; import com.thaiopensource.xml.util.Name; public class WrapProperty { public static final PropertyId<Name> ATTRIBUTE_OWNER = PropertyId.newInstance(\"ATTRIBUTE_OWNER\", Name.class); private WrapProperty() { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.parse.compact.CompactParseable; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.NameClass; import com.thaiopensource.relaxng.pattern.CommentListImpl; import com.thaiopensource.relaxng.pattern.AnnotationsImpl; import com.thaiopensource.resolver.xml.sax.SAX; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.VoidValue; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.rng.impl.SchemaReaderImpl; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import javax.xml.transform.sax.SAXSource; public class CompactSchemaReader extends SchemaReaderImpl { private static final SchemaReader theInstance = new CompactSchemaReader(); private CompactSchemaReader() { } public static SchemaReader getInstance() { return theInstance; } protected Parseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> createParseable(SAXSource source, SAXResolver saxResolver, ErrorHandler eh, PropertyMap properties) { return new CompactParseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl>(SAX.createInput(source.getInputSource()), saxResolver.getResolver(), eh); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.parse.sax.SAXParseable; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.NameClass; import com.thaiopensource.relaxng.pattern.CommentListImpl; import com.thaiopensource.relaxng.pattern.AnnotationsImpl; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.rng.impl.SchemaReaderImpl; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.VoidValue; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.Locator; import javax.xml.transform.sax.SAXSource; public class SAXSchemaReader extends SchemaReaderImpl { private static final SchemaReader theInstance = new SAXSchemaReader(); private SAXSchemaReader() { } public static SchemaReader getInstance() { return theInstance; } protected Parseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> createParseable(SAXSource source, SAXResolver resolver, ErrorHandler eh, PropertyMap properties) throws SAXException { if (source.getXMLReader() == null) source = new SAXSource(resolver.createXMLReader(), source.getInputSource()); return new SAXParseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl>(source, resolver, eh); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng; import com.thaiopensource.relaxng.parse.sax.SAXParseReceiver; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.ResolverFactory; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.auto.SchemaReceiverFactory; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.rng.impl.SchemaReceiverImpl; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.xml.sax.ErrorHandler; public class SAXSchemaReceiverFactory implements SchemaReceiverFactory { public SchemaReceiver createSchemaReceiver(String namespaceUri, PropertyMap properties) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng.impl; import com.thaiopensource.relaxng.pattern.IdTypeMap; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import org.xml.sax.ErrorHandler; public class FeasibleIdTypeMapSchema extends AbstractSchema { private final IdTypeMap idTypeMap; public FeasibleIdTypeMapSchema(IdTypeMap idTypeMap, PropertyMap properties) { super(properties); this.idTypeMap = idTypeMap; } public Validator createValidator(PropertyMap properties) { ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); return new IdValidator(idTypeMap, eh) { public void endDocument() { setComplete(); } }; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng.impl; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.relaxng.pattern.IdTypeMap; import org.xml.sax.ErrorHandler; public class IdTypeMapSchema extends AbstractSchema { private final IdTypeMap idTypeMap; public IdTypeMapSchema(IdTypeMap idTypeMap, PropertyMap properties) { super(properties); this.idTypeMap = idTypeMap; } public Validator createValidator(PropertyMap properties) { ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); return new IdValidator(idTypeMap, eh); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng.impl; import com.thaiopensource.relaxng.pattern.IdTypeMap; import com.thaiopensource.relaxng.sax.IdContentHandler; import com.thaiopensource.validate.Validator; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; public class IdValidator extends IdContentHandler implements Validator { public IdValidator(IdTypeMap idTypeMap, ErrorHandler eh) { super(idTypeMap, eh); } public ContentHandler getContentHandler() { return this; } public DTDHandler getDTDHandler() { return null; } public void reset() { super.reset(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng.impl; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.SchemaPatternBuilder; import com.thaiopensource.relaxng.pattern.ValidatorPatternBuilder; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import org.xml.sax.ErrorHandler; public class PatternSchema extends AbstractSchema { private final SchemaPatternBuilder spb; private final Pattern start; public PatternSchema(SchemaPatternBuilder spb, Pattern start, PropertyMap properties) { super(properties); this.spb = spb; this.start = start; } public Validator createValidator(PropertyMap properties) { ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); return new RngValidator(start, new ValidatorPatternBuilder(spb), eh); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng.impl; import com.thaiopensource.relaxng.sax.PatternValidator; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.ValidatorPatternBuilder; import com.thaiopensource.validate.Validator; import org.xml.sax.ErrorHandler; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; public class RngValidator extends PatternValidator implements Validator { public RngValidator(Pattern pattern, ValidatorPatternBuilder builder, ErrorHandler eh) { super(pattern, builder, eh); } public ContentHandler getContentHandler() { return this; } public DTDHandler getDTDHandler() { return this; } public void reset() { super.reset(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng.impl; import com.thaiopensource.datatype.DatatypeLibraryLoader; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.parse.Parseable; import com.thaiopensource.relaxng.pattern.AnnotationsImpl; import com.thaiopensource.relaxng.pattern.CommentListImpl; import com.thaiopensource.relaxng.pattern.FeasibleTransform; import com.thaiopensource.relaxng.pattern.IdTypeMap; import com.thaiopensource.relaxng.pattern.IdTypeMapBuilder; import com.thaiopensource.relaxng.pattern.NameClass; import com.thaiopensource.relaxng.pattern.Pattern; import com.thaiopensource.relaxng.pattern.PatternDumper; import com.thaiopensource.relaxng.pattern.SchemaBuilderImpl; import com.thaiopensource.relaxng.pattern.SchemaPatternBuilder; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.VoidValue; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.AbstractSchemaReader; import com.thaiopensource.validate.CombineSchema; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.ResolverFactory; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.prop.wrap.WrapProperty; import org.relaxng.datatype.DatatypeLibraryFactory; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import javax.xml.transform.sax.SAXSource; import java.io.IOException; public abstract class SchemaReaderImpl extends AbstractSchemaReader { private static final PropertyId<?>[] supportedPropertyIds = { ValidateProperty.XML_READER_CREATOR, ValidateProperty.ERROR_HANDLER, ValidateProperty.ENTITY_RESOLVER, ValidateProperty.URI_RESOLVER, ValidateProperty.RESOLVER, RngProperty.DATATYPE_LIBRARY_FACTORY, RngProperty.CHECK_ID_IDREF, RngProperty.FEASIBLE, WrapProperty.ATTRIBUTE_OWNER, }; public Schema createSchema(SAXSource source, PropertyMap properties) throws IOException, SAXException, IncorrectSchemaException { SchemaPatternBuilder spb = new SchemaPatternBuilder(); SAXResolver resolver = ResolverFactory.createResolver(properties); ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); DatatypeLibraryFactory dlf = properties.get(RngProperty.DATATYPE_LIBRARY_FACTORY); if (dlf == null) dlf = new DatatypeLibraryLoader(); try { Pattern start = SchemaBuilderImpl.parse(createParseable(source, resolver, eh, properties), eh, dlf, spb, properties.contains(WrapProperty.ATTRIBUTE_OWNER)); return wrapPattern(start, spb, properties); } catch (IllegalSchemaException e) { throw new IncorrectSchemaException(); } } public Option getOption(String uri) { return RngProperty.getOption(uri); } static private class SimplifiedSchemaPropertyMap implements PropertyMap { private final PropertyMap base; private final Pattern start; SimplifiedSchemaPropertyMap(PropertyMap base, Pattern start) { this.base = base; this.start = start; } public <T> T get(PropertyId<T> pid) { if (pid == RngProperty.SIMPLIFIED_SCHEMA) { String simplifiedSchema = PatternDumper.toString(start); return pid.getValueClass().cast(simplifiedSchema); } else return base.get(pid); } public PropertyId<?> getKey(int i) { return i == base.size() ? RngProperty.SIMPLIFIED_SCHEMA : base.getKey(i); } public int size() { return base.size() + 1; } public boolean contains(PropertyId<?> pid) { return base.contains(pid) || pid == RngProperty.SIMPLIFIED_SCHEMA; } } static Schema wrapPattern(Pattern start, SchemaPatternBuilder spb, PropertyMap properties) throws SAXException, IncorrectSchemaException { if (properties.contains(RngProperty.FEASIBLE)) start = FeasibleTransform.transform(spb, start); properties = new SimplifiedSchemaPropertyMap(AbstractSchema.filterProperties(properties, supportedPropertyIds), start); Schema schema = new PatternSchema(spb, start, properties); if (spb.hasIdTypes() && properties.contains(RngProperty.CHECK_ID_IDREF)) { ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); IdTypeMap idTypeMap = new IdTypeMapBuilder(eh, start).getIdTypeMap(); if (idTypeMap == null) throw new IncorrectSchemaException(); Schema idSchema; if (properties.contains(RngProperty.FEASIBLE)) idSchema = new FeasibleIdTypeMapSchema(idTypeMap, properties); else idSchema = new IdTypeMapSchema(idTypeMap, properties); schema = new CombineSchema(schema, idSchema, properties); } return schema; } protected abstract Parseable<Pattern, NameClass, Locator, VoidValue, CommentListImpl, AnnotationsImpl> createParseable(SAXSource source, SAXResolver resolver, ErrorHandler eh, PropertyMap properties) throws SAXException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.rng.impl; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.auto.SchemaReceiver; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.prop.wrap.WrapProperty; import com.thaiopensource.validate.auto.SchemaFuture; import com.thaiopensource.relaxng.parse.ParseReceiver; import com.thaiopensource.relaxng.parse.BuildException; import com.thaiopensource.relaxng.parse.IllegalSchemaException; import com.thaiopensource.relaxng.pattern.SchemaPatternBuilder; import com.thaiopensource.relaxng.pattern.PatternFuture; import com.thaiopensource.relaxng.pattern.SchemaBuilderImpl; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.datatype.DatatypeLibraryLoader; import org.relaxng.datatype.DatatypeLibraryFactory; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import java.io.IOException; public class SchemaReceiverImpl implements SchemaReceiver { private final ParseReceiver parser; private final PropertyMap properties; public SchemaReceiverImpl(ParseReceiver parser, PropertyMap properties) { this.parser = parser; this.properties = properties; } public SchemaFuture installHandlers(XMLReader xr) throws SAXException { final SchemaPatternBuilder pb = new SchemaPatternBuilder(); ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); DatatypeLibraryFactory dlf = properties.get(RngProperty.DATATYPE_LIBRARY_FACTORY); if (dlf == null) dlf = new DatatypeLibraryLoader(); final PatternFuture pf = SchemaBuilderImpl.installHandlers(parser, xr, eh, dlf, pb); return new SchemaFuture() { public Schema getSchema() throws IncorrectSchemaException, SAXException, IOException { try { return SchemaReaderImpl.wrapPattern(pf.getPattern(properties.contains(WrapProperty.ATTRIBUTE_OWNER)), pb, properties); } catch (IllegalSchemaException e) { throw new IncorrectSchemaException(); } } public RuntimeException unwrapException(RuntimeException e) throws SAXException, IOException, IncorrectSchemaException { if (e instanceof BuildException) { try { return SchemaBuilderImpl.unwrapBuildException((BuildException)e); } catch (IllegalSchemaException ise) { throw new IncorrectSchemaException(); } } return e; } }; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import javax.xml.transform.ErrorListener; import javax.xml.transform.TransformerException; class DraconianErrorListener implements ErrorListener { DraconianErrorListener() { } public void warning(TransformerException exception) throws TransformerException { } public void error(TransformerException exception) throws TransformerException { throw exception; } public void fatalError(TransformerException exception) throws TransformerException { throw exception; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; class IfValidHandler implements ContentHandler, ErrorHandler { private ContentHandler validator; private ContentHandler delegate; private ErrorHandler errorHandler; private boolean valid = true; public ContentHandler getValidator() { return validator; } public void setValidator(ContentHandler validator) { this.validator = validator; } public ContentHandler getDelegate() { return delegate; } public void setDelegate(ContentHandler delegate) { this.delegate = delegate; } public ErrorHandler getErrorHandler() { return errorHandler; } public void setErrorHandler(ErrorHandler errorHandler) { this.errorHandler = errorHandler; } public void setDocumentLocator(Locator locator) { validator.setDocumentLocator(locator); if (valid) delegate.setDocumentLocator(locator); } public void startDocument() throws SAXException { validator.startDocument(); if (valid) delegate.startDocument(); } public void endDocument() throws SAXException { validator.endDocument(); if (valid) delegate.endDocument(); } public void startPrefixMapping(String prefix, String uri) throws SAXException { validator.startPrefixMapping(prefix, uri); if (valid) delegate.startPrefixMapping(prefix, uri); } public void endPrefixMapping(String prefix) throws SAXException { validator.endPrefixMapping(prefix); if (valid) delegate.endPrefixMapping(prefix); } public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { validator.startElement(uri, localName, qName, attributes); if (valid) delegate.startElement(uri, localName, qName, attributes); } public void endElement(String uri, String localName, String qName) throws SAXException { validator.endElement(uri, localName, qName); if (valid) delegate.endElement(uri, localName, qName); } public void characters(char[] chars, int start, int length) throws SAXException { validator.characters(chars, start, length); if (valid) delegate.characters(chars, start, length); } public void ignorableWhitespace(char[] chars, int start, int length) throws SAXException { validator.ignorableWhitespace(chars, start, length); if (valid) delegate.ignorableWhitespace(chars, start, length); } public void processingInstruction(String target, String data) throws SAXException { validator.processingInstruction(target, data); if (valid) delegate.processingInstruction(target, data); } public void skippedEntity(String name) throws SAXException { validator.skippedEntity(name); if (valid) delegate.skippedEntity(name); } public void warning(SAXParseException exception) throws SAXException { errorHandler.warning(exception); } public void error(SAXParseException exception) throws SAXException { valid = false; errorHandler.error(exception); } public void fatalError(SAXParseException exception) throws SAXException { valid = false; errorHandler.fatalError(exception); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import javax.xml.transform.TransformerFactory; import javax.xml.transform.sax.SAXTransformerFactory; import net.sf.saxon.TransformerFactoryImpl; import net.sf.saxon.lib.FeatureKeys; public class NewSaxonSchemaReaderFactory extends SchematronSchemaReaderFactory { public SAXTransformerFactory newTransformerFactory() { return new TransformerFactoryImpl(); } public void initTransformerFactory(TransformerFactory factory) { factory.setAttribute(FeatureKeys.LINE_NUMBERING, Boolean.TRUE); factory.setAttribute(FeatureKeys.VERSION_WARNING, Boolean.FALSE); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import org.xml.sax.helpers.DefaultHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXParseException; import org.xml.sax.SAXException; import org.xml.sax.Attributes; import com.thaiopensource.util.Localizer; class OutputHandler extends DefaultHandler { private final ErrorHandler eh; private int lineNumber = -1; private int columnNumber = -1; private String systemId = null; private final StringBuffer message = new StringBuffer(); private boolean inMessage = false; private final String lineSeparator; private static final String indent = \" \"; private final Localizer localizer = new Localizer(OutputHandler.class); OutputHandler(ErrorHandler eh) { this.eh = eh; this.lineSeparator = System.getProperty(\"line.separator\"); } public void characters(char ch[], int start, int length) throws SAXException { if (inMessage) { for (int i = 0; i < length; i++) { char c = ch[start + i]; switch (c) { case ' ': case '\\r': case '\\n': case '\\t': if (message.length() == 0 || message.charAt(message.length() - 1) != ' ') message.append(' '); break; default: message.append(c); break; } } } } public void ignorableWhitespace(char ch[], int start, int length) throws SAXException { characters(ch, start, length); } public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { if (localName.equals(\"failed-assertion\") || localName.equals(\"report\")) { lineNumber = toInteger(attributes.getValue(\"\", \"line-number\")); columnNumber = toInteger(attributes.getValue(\"\", \"column-number\")); systemId = attributes.getValue(\"\", \"system-id\"); if (\"\".equals(systemId)) systemId = null; message.append(localizer.message(localName.equals(\"failed-assertion\") ? \"failed_assertion\" : \"report\")); } else if (localName.equals(\"statement\") || localName.equals(\"diagnostic\")) { inMessage = true; message.append(lineSeparator); message.append(indent); } } private static int toInteger(String value) { if (value == null) return -1; try { return Integer.parseInt(value); } catch (NumberFormatException e) { return -1; } } public void endElement(String uri, String localName, String qName) throws SAXException { if (localName.equals(\"statement\") || localName.equals(\"diagnostic\")) { if (message.length() > 0 && message.charAt(message.length() - 1) == ' ') message.setLength(message.length() - 1); inMessage = false; } else if (localName.equals(\"failed-assertion\") || localName.equals(\"report\")) { eh.error(new SAXParseException(message.toString(), null, systemId, lineNumber, columnNumber)); message.setLength(0); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.Validator; import javax.xml.transform.Templates; import javax.xml.transform.sax.SAXTransformerFactory; class SchemaImpl extends AbstractSchema { private final Templates templates; private final Class<? extends SAXTransformerFactory> factoryClass; SchemaImpl(Templates templates, Class<? extends SAXTransformerFactory> factoryClass, PropertyMap properties, PropertyId<?>[] supportedPropertyIds) { super(properties, supportedPropertyIds); this.templates = templates; this.factoryClass = factoryClass; } public Validator createValidator(PropertyMap properties) { try { return new ValidatorImpl(templates, factoryClass.newInstance(), properties); } catch (InstantiationException e) { throw new RuntimeException(\"unexpected InstantiationException creating SAXTransformerFactory\"); } catch (IllegalAccessException e) { throw new RuntimeException(\"unexpected IllegalAccessException creating SAXTransformerFactory\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import com.thaiopensource.util.Localizer; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.util.PropertyMapBuilder; import com.thaiopensource.validate.AbstractSchemaReader; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.ResolverFactory; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import com.thaiopensource.validate.prop.rng.RngProperty; import com.thaiopensource.validate.prop.schematron.SchematronProperty; import com.thaiopensource.validate.rng.CompactSchemaReader; import com.thaiopensource.xml.sax.CountingErrorHandler; import com.thaiopensource.xml.sax.DelegatingContentHandler; import com.thaiopensource.xml.sax.DraconianErrorHandler; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import javax.xml.transform.ErrorListener; import javax.xml.transform.SourceLocator; import javax.xml.transform.Templates; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.sax.SAXResult; import javax.xml.transform.sax.SAXSource; import javax.xml.transform.sax.SAXTransformerFactory; import javax.xml.transform.sax.TemplatesHandler; import javax.xml.transform.sax.TransformerHandler; import javax.xml.transform.stream.StreamSource; import java.io.IOException; import java.io.InputStream; class SchemaReaderImpl extends AbstractSchemaReader { static final String SCHEMATRON_URI = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.SchemaReaderFactory; import com.thaiopensource.validate.prop.schematron.SchematronProperty; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.TransformerFactoryConfigurationError; import javax.xml.transform.sax.SAXTransformerFactory; public class SchematronSchemaReaderFactory implements SchemaReaderFactory, TransformerFactoryInitializer { public SchemaReader createSchemaReader(String namespaceUri) { if (namespaceUri.equals(SchemaReaderImpl.SCHEMATRON_URI)) { try { return new SchemaReaderImpl(newTransformerFactory(), this); } catch (TransformerFactoryConfigurationError e) { } catch (IncorrectSchemaException e) { } catch (TransformerConfigurationException e) { } } return null; } public Option getOption(String uri) { return SchematronProperty.getOption(uri); } public SAXTransformerFactory newTransformerFactory() { TransformerFactory factory = TransformerFactory.newInstance(); if (factory.getFeature(SAXTransformerFactory.FEATURE)) return (SAXTransformerFactory)factory; throw new TransformerFactoryConfigurationError(\"JAXP TransformerFactory must support SAXTransformerFactory feature\"); } public void initTransformerFactory(TransformerFactory factory) { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import javax.xml.transform.TransformerFactory; public interface TransformerFactoryInitializer { void initTransformerFactory(TransformerFactory factory); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.xml.transform.Transform; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.ResolverFactory; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import javax.xml.transform.Templates; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.sax.SAXResult; import javax.xml.transform.sax.SAXTransformerFactory; import javax.xml.transform.sax.TransformerHandler; class ValidatorImpl implements Validator { private final Templates templates; private final SAXTransformerFactory factory; private final ContentHandler outputHandler; private TransformerHandler transformerHandler; private final Resolver resolver; ValidatorImpl(Templates templates, SAXTransformerFactory factory, PropertyMap properties) { this.templates = templates; this.factory = factory; ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); outputHandler = new OutputHandler(eh); resolver = ResolverFactory.createResolver(properties).getResolver(); initTransformerHandler(); } public ContentHandler getContentHandler() { return transformerHandler; } public DTDHandler getDTDHandler() { return transformerHandler; } public void reset() { initTransformerHandler(); } private void initTransformerHandler() { try { transformerHandler = factory.newTransformerHandler(templates); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.schematron; import org.apache.xalan.processor.TransformerFactoryImpl; import javax.xml.transform.TransformerFactory; import javax.xml.transform.sax.SAXTransformerFactory; public class XalanSchemaReaderFactory extends SchematronSchemaReaderFactory { public SAXTransformerFactory newTransformerFactory() { return new TransformerFactoryImpl(); } public void initTransformerFactory(TransformerFactory factory) { factory.setAttribute(TransformerFactoryImpl.FEATURE_SOURCE_LOCATION, Boolean.TRUE); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.xerces; import org.apache.xerces.impl.Constants; class Features { private Features() { } static final String SCHEMA_AUGMENT_PSVI = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_AUGMENT_PSVI; static final String SCHEMA_FULL_CHECKING = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_FULL_CHECKING; static final String VALIDATION = Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE; static final String SCHEMA_VALIDATION = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.xerces; import org.apache.xerces.impl.Constants; class Properties { private Properties() { } static final String XMLGRAMMAR_POOL = Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY; static final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY; static final String ERROR_REPORTER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY; static final String ERROR_HANDLER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_HANDLER_PROPERTY; static final String VALIDATION_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.VALIDATION_MANAGER_PROPERTY; static final String ENTITY_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_MANAGER_PROPERTY; static final String ENTITY_RESOLVER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.xerces; import org.apache.xerces.util.ErrorHandlerWrapper; import org.apache.xerces.xni.parser.XMLParseException; import org.apache.xerces.xni.XNIException; import org.xml.sax.ErrorHandler; class SAXXMLErrorHandler extends ErrorHandlerWrapper { private boolean hadError = false; SAXXMLErrorHandler(ErrorHandler errorHandler) { super(errorHandler); } void reset() { hadError = false; } public void error(String domain, String key, XMLParseException exception) throws XNIException { hadError = true; if (fErrorHandler == null) return; super.error(domain, key, exception); } public void warning(String domain, String key, XMLParseException exception) throws XNIException { if (fErrorHandler == null) return; super.warning(domain, key, exception); } public void fatalError(String domain, String key, XMLParseException exception) throws XNIException { hadError = true; if (fErrorHandler == null) return; super.fatalError(domain, key, exception); } boolean getHadError() { return hadError; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.xerces; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchema; import com.thaiopensource.validate.Validator; import org.apache.xerces.util.SymbolTable; import org.apache.xerces.xni.grammars.XMLGrammarPool; class SchemaImpl extends AbstractSchema { private final SymbolTable symbolTable; private final XMLGrammarPool grammarPool; SchemaImpl(SymbolTable symbolTable, XMLGrammarPool grammarPool, PropertyMap properties, PropertyId<?>[] supportedPropertyIds) { super(properties, supportedPropertyIds); this.symbolTable = symbolTable; this.grammarPool = grammarPool; } public Validator createValidator(PropertyMap properties) { return new ValidatorImpl(symbolTable, grammarPool, properties); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.xerces; import com.thaiopensource.util.PropertyId; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.AbstractSchemaReader; import com.thaiopensource.validate.IncorrectSchemaException; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.prop.wrap.WrapProperty; import com.thaiopensource.xml.util.Name; import org.apache.xerces.parsers.CachingParserPool; import org.apache.xerces.parsers.XMLGrammarPreparser; import org.apache.xerces.util.EntityResolverWrapper; import org.apache.xerces.util.SymbolTable; import org.apache.xerces.util.SynchronizedSymbolTable; import org.apache.xerces.util.XMLGrammarPoolImpl; import org.apache.xerces.xni.XNIException; import org.apache.xerces.xni.grammars.XMLGrammarDescription; import org.apache.xerces.xni.grammars.XMLGrammarPool; import org.apache.xerces.xni.parser.XMLInputSource; import org.xml.sax.EntityResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import javax.xml.transform.sax.SAXSource; import java.io.IOException; import java.io.Reader; import java.io.StringReader; class SchemaReaderImpl extends AbstractSchemaReader { private static final PropertyId<?>[] supportedPropertyIds = { ValidateProperty.ERROR_HANDLER, ValidateProperty.ENTITY_RESOLVER, }; public Schema createSchema(SAXSource source, PropertyMap properties) throws IOException, SAXException, IncorrectSchemaException { SymbolTable symbolTable = new SymbolTable(); XMLGrammarPreparser preparser = new XMLGrammarPreparser(symbolTable); XMLGrammarPool grammarPool = new XMLGrammarPoolImpl(); preparser.registerPreparser(XMLGrammarDescription.XML_SCHEMA, null); preparser.setGrammarPool(grammarPool); ErrorHandler eh = properties.get(ValidateProperty.ERROR_HANDLER); SAXXMLErrorHandler xeh = new SAXXMLErrorHandler(eh); preparser.setErrorHandler(xeh); EntityResolver er = properties.get(ValidateProperty.ENTITY_RESOLVER); if (er != null) preparser.setEntityResolver(new EntityResolverWrapper(er)); try { preparser.preparseGrammar(XMLGrammarDescription.XML_SCHEMA, toXMLInputSource(source.getInputSource())); Name attributeOwner = properties.get(WrapProperty.ATTRIBUTE_OWNER); if (attributeOwner != null) { Reader r = new StringReader(createWrapper(attributeOwner)); preparser.preparseGrammar(XMLGrammarDescription.XML_SCHEMA, new XMLInputSource(null, null, null, r, null)); } } catch (XNIException e) { throw ValidatorImpl.toSAXException(e); } if (xeh.getHadError()) throw new IncorrectSchemaException(); return new SchemaImpl(new SynchronizedSymbolTable(symbolTable), new CachingParserPool.SynchronizedGrammarPool(grammarPool), properties, supportedPropertyIds); } public Option getOption(String uri) { return null; } static private String createWrapper(Name attributeOwner) { return \"<xs:schema xmlns:xs=\\\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.xerces; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator; import org.apache.xerces.impl.XMLErrorReporter; import org.apache.xerces.impl.validation.EntityState; import org.apache.xerces.impl.validation.ValidationManager; import org.apache.xerces.impl.xs.XMLSchemaValidator; import org.apache.xerces.util.ErrorHandlerWrapper; import org.apache.xerces.util.NamespaceSupport; import org.apache.xerces.util.ParserConfigurationSettings; import org.apache.xerces.util.SymbolTable; import org.apache.xerces.util.XMLAttributesImpl; import org.apache.xerces.util.XMLSymbols; import org.apache.xerces.xni.NamespaceContext; import org.apache.xerces.xni.QName; import org.apache.xerces.xni.XMLAttributes; import org.apache.xerces.xni.XMLLocator; import org.apache.xerces.xni.XMLResourceIdentifier; import org.apache.xerces.xni.XMLString; import org.apache.xerces.xni.XNIException; import org.apache.xerces.xni.grammars.XMLGrammarPool; import org.apache.xerces.xni.parser.XMLComponent; import org.apache.xerces.xni.parser.XMLEntityResolver; import org.apache.xerces.xni.parser.XMLErrorHandler; import org.apache.xerces.xni.parser.XMLInputSource; import org.apache.xerces.xni.parser.XMLParseException; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import java.io.IOException; import java.util.HashSet; import java.util.Set; class ValidatorImpl extends ParserConfigurationSettings implements Validator, ContentHandler, DTDHandler, XMLLocator, XMLEntityResolver, EntityState { private final XMLSchemaValidator schemaValidator = new XMLSchemaValidator(); private final XMLErrorReporter errorReporter = new XMLErrorReporter(); private final ValidationManager validationManager = new ValidationManager(); private final NamespaceContext namespaceContext = new NamespaceSupport(); private final XMLAttributes attributes = new XMLAttributesImpl(); private final SymbolTable symbolTable; private final XMLComponent[] components; private Locator locator; private final Set<String> entities = new HashSet<String>(); private boolean pushedContext = false; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validate.xerces; import com.thaiopensource.validate.SchemaReaderFactory; import com.thaiopensource.validate.SchemaReader; import com.thaiopensource.validate.Option; import com.thaiopensource.validate.xerces.SchemaReaderImpl; import com.thaiopensource.xml.util.WellKnownNamespaces; import org.apache.xerces.parsers.XMLGrammarPreparser; public class XsdSchemaReaderFactory implements SchemaReaderFactory { public XsdSchemaReaderFactory() { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validation; import javax.xml.XMLConstants;  public class Constants { private Constants() { }  static public final String RELAXNG_COMPACT_URI = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validation; import org.w3c.dom.ls.LSInput; import java.io.InputStream; import java.io.Reader;  public class LSInputImpl implements LSInput { private Reader characterStream; private InputStream byteStream; private String systemId; private String publicId; private String baseURI; private String encoding; private boolean certifiedText; private String stringData; public Reader getCharacterStream() { return characterStream; } public void setCharacterStream(Reader characterStream) { this.characterStream = characterStream; } public InputStream getByteStream() { return byteStream; } public void setByteStream(InputStream byteStream) { this.byteStream = byteStream; } public String getSystemId() { return systemId; } public void setSystemId(String systemId) { this.systemId = systemId; } public String getPublicId() { return publicId; } public void setPublicId(String publicId) { this.publicId = publicId; } public String getBaseURI() { return baseURI; } public void setBaseURI(String baseURI) { this.baseURI = baseURI; } public String getEncoding() { return encoding; } public void setEncoding(String encoding) { this.encoding = encoding; } public boolean getCertifiedText() { return certifiedText; } public void setCertifiedText(boolean certifiedText) { this.certifiedText = certifiedText; } public String getStringData() { return stringData; } public void setStringData(String stringData) { this.stringData = stringData; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validation; import javax.xml.validation.Schema;  public abstract class Schema2 extends Schema { protected Schema2() { } public Validator2 newValidator() { return new ValidatorImpl(newValidatorHandler()); } public abstract ValidatorHandler2 newValidatorHandler(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validation; import org.xml.sax.SAXException; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.InputSource; import org.w3c.dom.ls.LSResourceResolver; import javax.xml.transform.Source; import javax.xml.transform.sax.SAXSource; import javax.xml.transform.stream.StreamSource; import javax.xml.validation.SchemaFactory; import javax.xml.XMLConstants; import java.io.File; import java.net.URL;  public abstract class SchemaFactory2 extends SchemaFactory { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validation; import org.xml.sax.SAXException; import javax.xml.transform.stream.StreamSource; import javax.xml.validation.Validator; import java.io.File; import java.io.IOException; import java.net.URL;  abstract public class Validator2 extends Validator { protected Validator2() { }  public void validate(File file) throws SAXException, IOException { validate(new StreamSource(file)); }  public void validate(URL url) throws SAXException, IOException { validate(new StreamSource(url.toExternalForm())); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validation; import org.xml.sax.DTDHandler; import javax.xml.validation.ValidatorHandler;  public abstract class ValidatorHandler2 extends ValidatorHandler implements DTDHandler { abstract public void reset();  abstract public void setDTDHandler(DTDHandler dtdHandler);  abstract public DTDHandler getDTDHandler(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.validation; import com.thaiopensource.resolver.Resolver; import com.thaiopensource.resolver.xml.ls.LS; import com.thaiopensource.resolver.xml.sax.SAXResolver; import com.thaiopensource.xml.sax.DraconianErrorHandler; import org.w3c.dom.ls.LSResourceResolver; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXException; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.XMLReader; import org.xml.sax.ext.LexicalHandler; import javax.xml.transform.Result; import javax.xml.transform.Source; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMResult; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.sax.SAXResult; import javax.xml.transform.sax.SAXSource; import javax.xml.transform.sax.SAXTransformerFactory; import javax.xml.transform.sax.TransformerHandler; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource; import java.io.IOException;  class ValidatorImpl extends Validator2 { private final ValidatorHandler2 handler; private XMLReader cachedXMLReader = null; private LSResourceResolver cachedResourceResolver = null; private boolean needReset = false; private static final String LEXICAL_HANDLER_PROPERTY = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.out; import java.io.UnsupportedEncodingException; public class CharRepertoire { private final byte[] allUnknown = new byte[256]; private final byte[][] charTable = new byte[256][]; private static final byte UNKNOWN = 0; private static final byte IN = 1; private static final byte OUT = -1; private final String enc; CharRepertoire(String enc) { this.enc = enc; for (int i = 0; i < charTable.length; i++) charTable[i] = allUnknown; } public static CharRepertoire getInstance(String enc) throws UnsupportedEncodingException { \"x\".getBytes(enc); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.out; import java.io.Writer; import java.io.IOException; import java.io.CharConversionException; import com.thaiopensource.util.Utf16; public class XmlWriter { static final private String indentString = \" \"; private final Writer writer; private final CharRepertoire cr; private static final int OTHER = 0; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.ext.LexicalHandler; import org.xml.sax.SAXException; public class AbstractLexicalHandler implements LexicalHandler { public void startDTD(String s, String s1, String s2) throws SAXException { } public void endDTD() throws SAXException { } public void startEntity(String s) throws SAXException { } public void endEntity(String s) throws SAXException { } public void startCDATA() throws SAXException { } public void endCDATA() throws SAXException { } public void comment(char[] chars, int start, int length) throws SAXException { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXParseException; import org.xml.sax.SAXException; public class CountingErrorHandler implements ErrorHandler { private ErrorHandler errorHandler; private int fatalErrorCount = 0; private int errorCount = 0; private int warningCount = 0; private boolean hadErrorOrFatalError = false; public CountingErrorHandler() { this(null); } public CountingErrorHandler(ErrorHandler errorHandler) { this.errorHandler = errorHandler; } public void reset() { fatalErrorCount = 0; errorCount = 0; warningCount = 0; hadErrorOrFatalError = false; } public boolean getHadErrorOrFatalError() { return hadErrorOrFatalError; } public int getFatalErrorCount() { return fatalErrorCount; } public int getErrorCount() { return errorCount; } public int getWarningCount() { return warningCount; } public ErrorHandler getErrorHandler() { return errorHandler; } public void setErrorHandler(ErrorHandler errorHandler) { this.errorHandler = errorHandler; } public void warning(SAXParseException exception) throws SAXException { warningCount++; if (errorHandler != null) errorHandler.warning(exception); } public void error(SAXParseException exception) throws SAXException { errorCount++; hadErrorOrFatalError = true; if (errorHandler != null) errorHandler.error(exception); } public void fatalError(SAXParseException exception) throws SAXException { fatalErrorCount++; hadErrorOrFatalError = true; if (errorHandler != null) errorHandler.fatalError(exception); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.ContentHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.Attributes; public class DelegatingContentHandler implements ContentHandler { private ContentHandler delegate; public DelegatingContentHandler() { } public DelegatingContentHandler(ContentHandler delegate) { this.delegate = delegate; } public ContentHandler getDelegate() { return delegate; } public void setDelegate(ContentHandler delegate) { this.delegate = delegate; } public void setDocumentLocator (Locator locator) { if (delegate != null) delegate.setDocumentLocator(locator); } public void startDocument () throws SAXException { if (delegate != null) delegate.startDocument(); } public void endDocument() throws SAXException { if (delegate != null) delegate.endDocument(); } public void startPrefixMapping (String prefix, String uri) throws SAXException { if (delegate != null) delegate.startPrefixMapping(prefix, uri); } public void endPrefixMapping (String prefix) throws SAXException { if (delegate != null) delegate.endPrefixMapping(prefix); } public void startElement (String namespaceURI, String localName, String qName, Attributes atts) throws SAXException { if (delegate != null) delegate.startElement(namespaceURI, localName, qName, atts); } public void endElement (String namespaceURI, String localName, String qName) throws SAXException { if (delegate != null) delegate.endElement(namespaceURI, localName, qName); } public void characters (char ch[], int start, int length) throws SAXException { if (delegate != null) delegate.characters(ch, start, length); } public void ignorableWhitespace (char ch[], int start, int length) throws SAXException { if (delegate != null) delegate.ignorableWhitespace(ch, start, length); } public void processingInstruction (String target, String data) throws SAXException { if (delegate != null) delegate.processingInstruction(target, data); } public void skippedEntity (String name) throws SAXException { if (delegate != null) delegate.skippedEntity(name); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXParseException; import org.xml.sax.SAXException;  public class DraconianErrorHandler implements ErrorHandler { public void warning(SAXParseException e) throws SAXException { } public void error(SAXParseException e) throws SAXException { throw e; } public void fatalError(SAXParseException e) throws SAXException { throw e; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import java.util.ResourceBundle; import java.text.MessageFormat; import java.io.PrintWriter; import java.io.Writer; import java.io.OutputStream; import java.io.FileNotFoundException; import org.xml.sax.ErrorHandler; import org.xml.sax.SAXParseException; import org.xml.sax.SAXException; import com.thaiopensource.util.UriOrFile; public class ErrorHandlerImpl implements ErrorHandler { private final PrintWriter err; private final String bundleName = \"com.thaiopensource.xml.sax.resources.Messages\"; private ResourceBundle bundle = null; public ErrorHandlerImpl() { this(System.err); } public ErrorHandlerImpl(OutputStream os) { this.err = new PrintWriter(os); } public ErrorHandlerImpl(Writer w) { this.err = new PrintWriter(w); } public void close() { err.close(); } private String getString(String key) { if (bundle == null) bundle = ResourceBundle.getBundle(bundleName); return bundle.getString(key); } private String format(String key, Object[] args) { return MessageFormat.format(getString(key), args); } public void warning(SAXParseException e) throws SAXParseException { print(format(\"warning\", new Object[] { formatMessage(e), formatLocation(e) })); } public void error(SAXParseException e) { print(format(\"error\", new Object[] { formatMessage(e), formatLocation(e) })); } public void fatalError(SAXParseException e) throws SAXParseException { throw e; } public void printException(Throwable e) { String loc; if (e instanceof SAXParseException) loc = formatLocation((SAXParseException)e); else loc = \"\"; String message; if (e instanceof SAXException) message = formatMessage((SAXException)e); else message = formatMessage(e); print(format(\"fatal\", new Object[] { message, loc })); } public void print(String message) { if (message.length() != 0) { err.println(message); err.flush(); } } private String formatLocation(SAXParseException e) { String systemId = e.getSystemId(); int n = e.getLineNumber(); Integer lineNumber = n >= 0 ? new Integer(n) : null; n = e.getColumnNumber(); Integer columnNumber = n >= 0 ? new Integer(n) : null; if (systemId != null) { systemId = UriOrFile.uriToUriOrFile(systemId); if (lineNumber != null) { if (columnNumber != null) return format(\"locator_system_id_line_number_column_number\", new Object[] { systemId, lineNumber, columnNumber }); else return format(\"locator_system_id_line_number\", new Object[] { systemId, lineNumber }); } else return format(\"locator_system_id\", new Object[] { systemId }); } else if (lineNumber != null) { if (columnNumber != null) return format(\"locator_line_number_column_number\", new Object[] { lineNumber, columnNumber }); else return format(\"locator_line_number\", new Object[] { lineNumber }); } else return \"\"; } private String formatMessage(SAXException se) { Exception e = se.getException(); String detail = se.getMessage(); if (e != null) { String detail2 = e.getMessage(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; public class ForkContentHandler implements ContentHandler { private final ContentHandler ch1; private final ContentHandler ch2; public ForkContentHandler(ContentHandler ch1, ContentHandler ch2) { this.ch1 = ch1; this.ch2 = ch2; } public void setDocumentLocator(Locator locator) { ch1.setDocumentLocator(locator); ch2.setDocumentLocator(locator); } public void startDocument() throws SAXException { ch1.startDocument(); ch2.startDocument(); } public void endDocument() throws SAXException { ch1.endDocument(); ch2.endDocument(); } public void startPrefixMapping(String s, String s1) throws SAXException { ch1.startPrefixMapping(s, s1); ch2.startPrefixMapping(s, s1); } public void endPrefixMapping(String s) throws SAXException { ch1.endPrefixMapping(s); ch2.endPrefixMapping(s); } public void startElement(String s, String s1, String s2, Attributes attributes) throws SAXException { ch1.startElement(s, s1, s2, attributes); ch2.startElement(s, s1, s2, attributes); } public void endElement(String s, String s1, String s2) throws SAXException { ch1.endElement(s, s1, s2); ch2.endElement(s, s1, s2); } public void characters(char[] chars, int i, int i1) throws SAXException { ch1.characters(chars, i, i1); ch2.characters(chars, i, i1); } public void ignorableWhitespace(char[] chars, int i, int i1) throws SAXException { ch1.ignorableWhitespace(chars, i, i1); ch2.ignorableWhitespace(chars, i, i1); } public void processingInstruction(String s, String s1) throws SAXException { ch1.processingInstruction(s, s1); ch2.processingInstruction(s, s1); } public void skippedEntity(String s) throws SAXException { ch1.skippedEntity(s); ch2.skippedEntity(s); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.DTDHandler; import org.xml.sax.SAXException; public class ForkDTDHandler implements DTDHandler { private final DTDHandler dh1; private final DTDHandler dh2; public ForkDTDHandler(DTDHandler dh1, DTDHandler dh2) { this.dh1 = dh1; this.dh2 = dh2; } public void notationDecl(String name, String publicId, String systemId) throws SAXException { dh1.notationDecl(name, publicId, systemId); dh2.notationDecl(name, publicId, systemId); } public void unparsedEntityDecl(String name, String publicId, String systemId, String notationName) throws SAXException { dh1.unparsedEntityDecl(name, publicId, systemId, notationName); dh2.unparsedEntityDecl(name, publicId, systemId, notationName); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import javax.xml.parsers.SAXParserFactory; import javax.xml.parsers.ParserConfigurationException; import org.xml.sax.XMLReader; import org.xml.sax.SAXException; import com.thaiopensource.xml.sax.XMLReaderCreator;  public class Jaxp11XMLReaderCreator implements XMLReaderCreator { private final SAXParserFactory factory;  public Jaxp11XMLReaderCreator() { factory = SAXParserFactory.newInstance(); factory.setNamespaceAware(true); factory.setValidating(false); } public XMLReader createXMLReader() throws SAXException { try { return factory.newSAXParser().getXMLReader(); } catch (ParserConfigurationException e) { throw new SAXException(e); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import org.xml.sax.SAXNotRecognizedException; import org.xml.sax.SAXNotSupportedException; import org.xml.sax.helpers.XMLReaderFactory; import com.thaiopensource.xml.sax.XMLReaderCreator;  public class Sax2XMLReaderCreator implements XMLReaderCreator { private final String className;  public Sax2XMLReaderCreator() { this.className = null; }  public Sax2XMLReaderCreator(String className) { this.className = className; } public XMLReader createXMLReader() throws SAXException { XMLReader xr; if (className == null) xr = XMLReaderFactory.createXMLReader(); else xr = XMLReaderFactory.createXMLReader(className); xr.setFeature(\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import org.xml.sax.SAXException; import org.xml.sax.XMLReader;  public interface XMLReaderCreator {  XMLReader createXMLReader() throws SAXException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.sax; import com.thaiopensource.util.Uri; import org.xml.sax.Locator; public class XmlBaseHandler { private int depth = 0; private Locator loc; private Entry stack = null; private static class Entry { private Entry parent; private String attValue; private String systemId; private int depth; } public void setLocator(Locator loc) { this.loc = loc; } public void startElement() { ++depth; } public void endElement() { if (stack != null && stack.depth == depth) stack = stack.parent; --depth; } public void xmlBaseAttribute(String value) { Entry entry = new Entry(); entry.parent = stack; stack = entry; entry.attValue = value; entry.systemId = getSystemId(); entry.depth = depth; } private String getSystemId() { return loc == null ? null : loc.getSystemId(); } public String getBaseUri() { return getBaseUri1(getSystemId(), stack); } private static String getBaseUri1(String baseUri, Entry stack) { if (stack == null || (baseUri != null && !baseUri.equals(stack.systemId))) return baseUri; baseUri = stack.attValue; if (Uri.isAbsolute(baseUri)) return baseUri; return Uri.resolve(getBaseUri1(stack.systemId, stack.parent), baseUri); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.util; import java.io.UnsupportedEncodingException; public abstract class EncodingMap { private static final String[] aliases = { \"UTF-8\", \"UTF8\", \"UTF-16\", \"Unicode\", \"UTF-16BE\", \"UnicodeBigUnmarked\", \"UTF-16LE\", \"UnicodeLittleUnmarked\", \"US-ASCII\", \"ASCII\", \"TIS-620\", \"TIS620\" }; static public String getJavaName(String enc) { try { \"x\".getBytes(enc); } catch (UnsupportedEncodingException e) { for (int i = 0; i < aliases.length; i += 2) { if (enc.equalsIgnoreCase(aliases[i])) { try { \"x\".getBytes(aliases[i + 1]); return aliases[i + 1]; } catch (UnsupportedEncodingException e2) {} } } } return enc; } static public void main(String[] args) { System.err.println(getJavaName(args[0])); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.util; public final class Name { final private String namespaceUri; final private String localName; final private int hc; public Name(String namespaceUri, String localName) { this.namespaceUri = namespaceUri; this.localName = localName; this.hc = namespaceUri.hashCode() ^ localName.hashCode(); } public String getNamespaceUri() { return namespaceUri; } public String getLocalName() { return localName; } public boolean equals(Object obj) { if (!(obj instanceof Name)) return false; Name other = (Name)obj; return (this.hc == other.hc && this.namespaceUri.equals(other.namespaceUri) && this.localName.equals(other.localName)); } public int hashCode() { return hc; } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.util; public class Naming { private Naming() { } private static final int CT_NAME = 1; private static final int CT_NMSTRT = 2; private static final String nameStartSingles = \"\\u003a\\u005f\\u0386\\u038c\\u03da\\u03dc\\u03de\\u03e0\\u0559\\u06d5\\u093d\\u09b2\" + \"\\u0a5e\\u0a8d\\u0abd\\u0ae0\\u0b3d\\u0b9c\\u0cde\\u0e30\\u0e84\\u0e8a\\u0e8d\\u0ea5\" + \"\\u0ea7\\u0eb0\\u0ebd\\u1100\\u1109\\u113c\\u113e\\u1140\\u114c\\u114e\\u1150\\u1159\" + \"\\u1163\\u1165\\u1167\\u1169\\u1175\\u119e\\u11a8\\u11ab\\u11ba\\u11eb\\u11f0\\u11f9\" + \"\\u1f59\\u1f5b\\u1f5d\\u1fbe\\u2126\\u212e\\u3007\"; private static final String nameStartRanges = \"\\u0041\\u005a\\u0061\\u007a\\u00c0\\u00d6\\u00d8\\u00f6\\u00f8\\u00ff\\u0100\\u0131\" + \"\\u0134\\u013e\\u0141\\u0148\\u014a\\u017e\\u0180\\u01c3\\u01cd\\u01f0\\u01f4\\u01f5\" + \"\\u01fa\\u0217\\u0250\\u02a8\\u02bb\\u02c1\\u0388\\u038a\\u038e\\u03a1\\u03a3\\u03ce\" + \"\\u03d0\\u03d6\\u03e2\\u03f3\\u0401\\u040c\\u040e\\u044f\\u0451\\u045c\\u045e\\u0481\" + \"\\u0490\\u04c4\\u04c7\\u04c8\\u04cb\\u04cc\\u04d0\\u04eb\\u04ee\\u04f5\\u04f8\\u04f9\" + \"\\u0531\\u0556\\u0561\\u0586\\u05d0\\u05ea\\u05f0\\u05f2\\u0621\\u063a\\u0641\\u064a\" + \"\\u0671\\u06b7\\u06ba\\u06be\\u06c0\\u06ce\\u06d0\\u06d3\\u06e5\\u06e6\\u0905\\u0939\" + \"\\u0958\\u0961\\u0985\\u098c\\u098f\\u0990\\u0993\\u09a8\\u09aa\\u09b0\\u09b6\\u09b9\" + \"\\u09dc\\u09dd\\u09df\\u09e1\\u09f0\\u09f1\\u0a05\\u0a0a\\u0a0f\\u0a10\\u0a13\\u0a28\" + \"\\u0a2a\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59\\u0a5c\\u0a72\\u0a74\" + \"\\u0a85\\u0a8b\\u0a8f\\u0a91\\u0a93\\u0aa8\\u0aaa\\u0ab0\\u0ab2\\u0ab3\\u0ab5\\u0ab9\" + \"\\u0b05\\u0b0c\\u0b0f\\u0b10\\u0b13\\u0b28\\u0b2a\\u0b30\\u0b32\\u0b33\\u0b36\\u0b39\" + \"\\u0b5c\\u0b5d\\u0b5f\\u0b61\\u0b85\\u0b8a\\u0b8e\\u0b90\\u0b92\\u0b95\\u0b99\\u0b9a\" + \"\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8\\u0baa\\u0bae\\u0bb5\\u0bb7\\u0bb9\\u0c05\\u0c0c\" + \"\\u0c0e\\u0c10\\u0c12\\u0c28\\u0c2a\\u0c33\\u0c35\\u0c39\\u0c60\\u0c61\\u0c85\\u0c8c\" + \"\\u0c8e\\u0c90\\u0c92\\u0ca8\\u0caa\\u0cb3\\u0cb5\\u0cb9\\u0ce0\\u0ce1\\u0d05\\u0d0c\" + \"\\u0d0e\\u0d10\\u0d12\\u0d28\\u0d2a\\u0d39\\u0d60\\u0d61\\u0e01\\u0e2e\\u0e32\\u0e33\" + \"\\u0e40\\u0e45\\u0e81\\u0e82\\u0e87\\u0e88\\u0e94\\u0e97\\u0e99\\u0e9f\\u0ea1\\u0ea3\" + \"\\u0eaa\\u0eab\\u0ead\\u0eae\\u0eb2\\u0eb3\\u0ec0\\u0ec4\\u0f40\\u0f47\\u0f49\\u0f69\" + \"\\u10a0\\u10c5\\u10d0\\u10f6\\u1102\\u1103\\u1105\\u1107\\u110b\\u110c\\u110e\\u1112\" + \"\\u1154\\u1155\\u115f\\u1161\\u116d\\u116e\\u1172\\u1173\\u11ae\\u11af\\u11b7\\u11b8\" + \"\\u11bc\\u11c2\\u1e00\\u1e9b\\u1ea0\\u1ef9\\u1f00\\u1f15\\u1f18\\u1f1d\\u1f20\\u1f45\" + \"\\u1f48\\u1f4d\\u1f50\\u1f57\\u1f5f\\u1f7d\\u1f80\\u1fb4\\u1fb6\\u1fbc\\u1fc2\\u1fc4\" + \"\\u1fc6\\u1fcc\\u1fd0\\u1fd3\\u1fd6\\u1fdb\\u1fe0\\u1fec\\u1ff2\\u1ff4\\u1ff6\\u1ffc\" + \"\\u212a\\u212b\\u2180\\u2182\\u3041\\u3094\\u30a1\\u30fa\\u3105\\u312c\\uac00\\ud7a3\" + \"\\u4e00\\u9fa5\\u3021\\u3029\"; private static final String nameSingles = \"\\u002d\\u002e\\u05bf\\u05c4\\u0670\\u093c\\u094d\\u09bc\\u09be\\u09bf\\u09d7\\u0a02\" + \"\\u0a3c\\u0a3e\\u0a3f\\u0abc\\u0b3c\\u0bd7\\u0d57\\u0e31\\u0eb1\\u0f35\\u0f37\\u0f39\" + \"\\u0f3e\\u0f3f\\u0f97\\u0fb9\\u20e1\\u3099\\u309a\\u00b7\\u02d0\\u02d1\\u0387\\u0640\" + \"\\u0e46\\u0ec6\\u3005\"; private static final String nameRanges = \"\\u0300\\u0345\\u0360\\u0361\\u0483\\u0486\\u0591\\u05a1\\u05a3\\u05b9\\u05bb\\u05bd\" + \"\\u05c1\\u05c2\\u064b\\u0652\\u06d6\\u06dc\\u06dd\\u06df\\u06e0\\u06e4\\u06e7\\u06e8\" + \"\\u06ea\\u06ed\\u0901\\u0903\\u093e\\u094c\\u0951\\u0954\\u0962\\u0963\\u0981\\u0983\" + \"\\u09c0\\u09c4\\u09c7\\u09c8\\u09cb\\u09cd\\u09e2\\u09e3\\u0a40\\u0a42\\u0a47\\u0a48\" + \"\\u0a4b\\u0a4d\\u0a70\\u0a71\\u0a81\\u0a83\\u0abe\\u0ac5\\u0ac7\\u0ac9\\u0acb\\u0acd\" + \"\\u0b01\\u0b03\\u0b3e\\u0b43\\u0b47\\u0b48\\u0b4b\\u0b4d\\u0b56\\u0b57\\u0b82\\u0b83\" + \"\\u0bbe\\u0bc2\\u0bc6\\u0bc8\\u0bca\\u0bcd\\u0c01\\u0c03\\u0c3e\\u0c44\\u0c46\\u0c48\" + \"\\u0c4a\\u0c4d\\u0c55\\u0c56\\u0c82\\u0c83\\u0cbe\\u0cc4\\u0cc6\\u0cc8\\u0cca\\u0ccd\" + \"\\u0cd5\\u0cd6\\u0d02\\u0d03\\u0d3e\\u0d43\\u0d46\\u0d48\\u0d4a\\u0d4d\\u0e34\\u0e3a\" + \"\\u0e47\\u0e4e\\u0eb4\\u0eb9\\u0ebb\\u0ebc\\u0ec8\\u0ecd\\u0f18\\u0f19\\u0f71\\u0f84\" + \"\\u0f86\\u0f8b\\u0f90\\u0f95\\u0f99\\u0fad\\u0fb1\\u0fb7\\u20d0\\u20dc\\u302a\\u302f\" + \"\\u0030\\u0039\\u0660\\u0669\\u06f0\\u06f9\\u0966\\u096f\\u09e6\\u09ef\\u0a66\\u0a6f\" + \"\\u0ae6\\u0aef\\u0b66\\u0b6f\\u0be7\\u0bef\\u0c66\\u0c6f\\u0ce6\\u0cef\\u0d66\\u0d6f\" + \"\\u0e50\\u0e59\\u0ed0\\u0ed9\\u0f20\\u0f29\\u3031\\u3035\\u309d\\u309e\\u30fc\\u30fe\"; private final static byte[][] charTypeTable; static { charTypeTable = new byte[256][]; for (int i = 0; i < nameSingles.length(); i++) setCharType(nameSingles.charAt(i), CT_NAME); for (int i = 0; i < nameRanges.length(); i += 2) setCharType(nameRanges.charAt(i), nameRanges.charAt(i + 1), CT_NAME); for (int i = 0; i < nameStartSingles.length(); i++) setCharType(nameStartSingles.charAt(i), CT_NMSTRT); for (int i = 0; i < nameStartRanges.length(); i += 2) setCharType(nameStartRanges.charAt(i), nameStartRanges.charAt(i + 1), CT_NMSTRT); byte[] other = new byte[256]; for (int i = 0; i < 256; i++) if (charTypeTable[i] == null) charTypeTable[i] = other; } private static void setCharType(char c, int type) { int hi = c >> 8; if (charTypeTable[hi] == null) charTypeTable[hi] = new byte[256]; charTypeTable[hi][c & 0xFF] = (byte)type; } private static void setCharType(char min, char max, int type) { byte[] shared = null; do { if ((min & 0xFF) == 0) { for (; min + 0xFF <= max; min += 0x100) { if (shared == null) { shared = new byte[256]; for (int i = 0; i < 256; i++) shared[i] = (byte)type; } charTypeTable[min >> 8] = shared; if (min + 0xFF == max) return; } } setCharType(min, type); } while (min++ != max); } private static boolean isNameStartChar(char c) { return charTypeTable[c >> 8][c & 0xff] == CT_NMSTRT; } private static boolean isNameStartCharNs(char c) { return isNameStartChar(c) && c != ':'; } private static boolean isNameChar(char c) { return charTypeTable[c >> 8][c & 0xff] != 0; } private static boolean isNameCharNs(char c) { return isNameChar(c) && c != ':'; } public static boolean isName(String s) { int len = s.length(); if (len == 0) return false; if (!isNameStartChar(s.charAt(0))) return false; for (int i = 1; i < len; i++) if (!isNameChar(s.charAt(i))) return false; return true; } public static boolean isNmtoken(String s) { int len = s.length(); if (len == 0) return false; for (int i = 0; i < len; i++) if (!isNameChar(s.charAt(i))) return false; return true; } public static boolean isNcname(String s) { int len = s.length(); if (len == 0) return false; if (!isNameStartCharNs(s.charAt(0))) return false; for (int i = 1; i < len; i++) if (!isNameCharNs(s.charAt(i))) return false; return true; } public static boolean isQname(String s) { int len = s.length(); if (len == 0) return false; if (!isNameStartCharNs(s.charAt(0))) return false; for (int i = 1; i < len; i++) { char c = s.charAt(i); if (!isNameCharNs(c)) { if (c == ':' && ++i < len && isNameStartCharNs(s.charAt(i))) { for (++i; i < len; i++) if (!isNameCharNs(s.charAt(i))) return false; return true; } return false; } } return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.util; public class StringSplitter { private StringSplitter() { } public static String[] split(String str) { int len = str.length(); int nTokens = 0; for (int i = 0; i < len; i++) if (!isSpace(str.charAt(i)) && (i == 0 || isSpace(str.charAt(i - 1)))) nTokens++; String[] tokens = new String[nTokens]; nTokens = 0; int tokenStart = -1; for (int i = 0; i < len; i++) { if (isSpace(str.charAt(i))) { if (tokenStart >= 0) { tokens[nTokens++] = str.substring(tokenStart, i); tokenStart = -1; } } else if (i == 0 || isSpace(str.charAt(i - 1))) tokenStart = i; } if (tokenStart >= 0) tokens[nTokens] = str.substring(tokenStart, len); return tokens; } private static boolean isSpace(char c) { switch (c) { case ' ': case '\\r': case '\\n': case '\\t': return true; } return false; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package com.thaiopensource.xml.util; public class WellKnownNamespaces { static public final String XML = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype;  public interface Datatype {  boolean isValid( String literal, ValidationContext context );  void checkValid( String literal, ValidationContext context ) throws DatatypeException;  DatatypeStreamingValidator createStreamingValidator( ValidationContext context );  Object createValue( String literal, ValidationContext context );  boolean sameValue( Object value1, Object value2 );  int valueHashCode( Object value );  public static final int ID_TYPE_NULL = 0;  public static final int ID_TYPE_ID = 1;  public static final int ID_TYPE_IDREF = 2;  public static final int ID_TYPE_IDREFS = 3;  public int getIdType();  public boolean isContextDependent(); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype;  public interface DatatypeBuilder {  void addParameter( String name, String strValue, ValidationContext context ) throws DatatypeException;  Datatype createDatatype() throws DatatypeException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype;  public class DatatypeException extends Exception { public DatatypeException( int index, String msg ) { super(msg); this.index = index; } public DatatypeException( String msg ) { this(UNKNOWN,msg); }  public DatatypeException() { this(UNKNOWN,null); } private final int index; public static final int UNKNOWN = -1;  public int getIndex() { return index; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype;  public interface DatatypeLibrary {  DatatypeBuilder createDatatypeBuilder( String baseTypeLocalName ) throws DatatypeException;  Datatype createDatatype( String typeLocalName ) throws DatatypeException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype;  public interface DatatypeLibraryFactory {  DatatypeLibrary createDatatypeLibrary( String namespaceURI ); }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype;  public interface DatatypeStreamingValidator {  void addCharacters( char[] buf, int start, int len );  boolean isValid();  void checkValid() throws DatatypeException; }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype;  public interface ValidationContext { /** * Resolves a namespace prefix to the corresponding namespace URI. * * This method is used for validating the QName type, for example. * * <p> * If the prefix is \"\" (empty string), it indicates * an unprefixed value. The callee * should resolve it as for an unprefixed * element, rather than for an unprefixed attribute. * * <p> * If the prefix is \"xml\", then the callee must resolve * this prefix into \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.relaxng.datatype.helpers; import org.relaxng.datatype.DatatypeLibraryFactory; import org.relaxng.datatype.DatatypeLibrary; import java.util.Enumeration; import java.util.NoSuchElementException; import java.util.Vector; import java.io.Reader; import java.io.InputStream; import java.io.InputStreamReader; import java.io.BufferedReader; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URL;  public class DatatypeLibraryLoader implements DatatypeLibraryFactory { private final Service service = new Service(DatatypeLibraryFactory.class); public DatatypeLibrary createDatatypeLibrary(String uri) { for (Enumeration e = service.getProviders(); e.hasMoreElements();) { DatatypeLibraryFactory factory = (DatatypeLibraryFactory)e.nextElement(); DatatypeLibrary library = factory.createDatatypeLibrary(uri); if (library != null) return library; } return null; } private static class Service { private final Class serviceClass; private final Enumeration configFiles; private Enumeration classNames = null; private final Vector providers = new Vector(); private Loader loader; private class ProviderEnumeration implements Enumeration { private int nextIndex = 0; public boolean hasMoreElements() { return nextIndex < providers.size() || moreProviders(); } public Object nextElement() { try { return providers.elementAt(nextIndex++); } catch (ArrayIndexOutOfBoundsException e) { throw new NoSuchElementException(); } } } private static class Singleton implements Enumeration { private Object obj; private Singleton(Object obj) { this.obj = obj; } public boolean hasMoreElements() { return obj != null; } public Object nextElement() { if (obj == null) throw new NoSuchElementException(); Object tem = obj; obj = null; return tem; } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype.helpers; import org.relaxng.datatype.*;  public final class ParameterlessDatatypeBuilder implements DatatypeBuilder {  private final Datatype baseType; public ParameterlessDatatypeBuilder( Datatype baseType ) { this.baseType = baseType; } public void addParameter( String name, String strValue, ValidationContext context ) throws DatatypeException { throw new DatatypeException(); } public Datatype createDatatype() throws DatatypeException { return baseType; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.relaxng.datatype.helpers; import org.relaxng.datatype.*;  public final class StreamingValidatorImpl implements DatatypeStreamingValidator {  private final StringBuffer buffer = new StringBuffer();  private final Datatype baseType;  private final ValidationContext context; public void addCharacters( char[] buf, int start, int len ) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.whattf.checker; import java.util.LinkedList; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class AttributeUtil {  private final static String[] EMPTY_STRING_ARRAY = {};  private static Pattern INTEGER_PATTERN = Pattern.compile(\"^[ \\t\\n\\r]*(-?[0-9]+)\");  private AttributeUtil() { super(); }  public static int parseInteger(String attrVal) { if (attrVal == null) { return Integer.MIN_VALUE; } Matcher m = INTEGER_PATTERN.matcher(attrVal); if (!m.matches()) { return Integer.MIN_VALUE; } try { return Integer.parseInt(m.group(1)); } catch (NumberFormatException e) { return Integer.MIN_VALUE; } }  public static int parseNonNegativeInteger(String attrVal) { int rv = parseInteger(attrVal); if (rv < 0) { return -1; } else { return rv; } }  public static int parsePositiveInteger(String attrVal) { int rv = parseInteger(attrVal); if (rv < 1) { return -1; } else { return rv; } }  public static String[] split(String value) { if (value == null || \"\".equals(value)) { return EMPTY_STRING_ARRAY; } int len = value.length(); List<String> list = new LinkedList<String>(); boolean collectingSpace = true; int start = 0; for (int i = 0; i < len; i++) { char c = value.charAt(i); if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') { if (!collectingSpace) { list.add(value.substring(start, i)); collectingSpace = true; } } else { if (collectingSpace) { start = i; collectingSpace = false; } } } if (start < len) { list.add(value.substring(start, len)); } return list.toArray(EMPTY_STRING_ARRAY); }  public static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString(String lowerCaseLiteral, String string) { if (string == null) { return false; } if (lowerCaseLiteral.length() != string.length()) { return false; } for (int i = 0; i < lowerCaseLiteral.length(); i++) { char c0 = lowerCaseLiteral.charAt(i); char c1 = string.charAt(i); if (c1 >= 'A' && c1 <= 'Z') { c1 += 0x20; } if (c0 != c1) { return false; } } return true; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException;  public abstract class Checker implements ContentHandler { private ErrorHandler errorHandler; private Locator locator;  public Checker() { super(); }  public void warn(String message) throws SAXException { if (errorHandler != null) { SAXParseException spe = new SAXParseException(message, locator); errorHandler.warning(spe); } }  public void warn(String message, Locator overrideLocator) throws SAXException { if (errorHandler != null) { SAXParseException spe = new SAXParseException(message, overrideLocator); errorHandler.warning(spe); } }  public void err(String message, Locator overrideLocator) throws SAXException { if (errorHandler != null) { SAXParseException spe = new SAXParseException(message, overrideLocator); errorHandler.error(spe); } }  public void err(String message) throws SAXException { if (errorHandler != null) { SAXParseException spe = new SAXParseException(message, locator); errorHandler.error(spe); } }  public void reset() { }  public ErrorHandler getErrorHandler() { return errorHandler; }  public void setErrorHandler(ErrorHandler errorHandler) { this.errorHandler = errorHandler; }  public Locator getDocumentLocator() { return this.locator; }  public void setDocumentLocator(Locator locator) { this.locator = locator; }  public void startDocument() throws SAXException { reset(); }  public void endDocument() throws SAXException { reset(); }  public final void ignorableWhitespace(char[] ch, int start, int length) throws SAXException { characters(ch, start, length); }  public void characters(char[] ch, int start, int length) throws SAXException { }  public void endElement(String uri, String localName, String qName) throws SAXException { }  public void endPrefixMapping(String prefix) throws SAXException { }  public void processingInstruction(String target, String data) throws SAXException { }  public void skippedEntity(String name) throws SAXException { }  public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { }  public void startPrefixMapping(String prefix, String uri) throws SAXException { } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.SAXException; public class ConformingButObsoleteWarner extends Checker {  @Override public void startElement(String uri, String localName, String name, Attributes atts) throws SAXException { if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import java.util.Map; import java.util.HashMap; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.whattf.datatype.Html5DatatypeException; import org.relaxng.datatype.DatatypeException;  public class DatatypeMismatchException extends SAXParseException { private final Map<String, DatatypeException> exceptions; final boolean warning;  public DatatypeMismatchException(String message, Locator locator, Class<?> datatypeClass, boolean warning) throws SAXException, ClassNotFoundException { super(message, locator); this.warning = warning; Html5DatatypeException ex5 = new Html5DatatypeException(0, datatypeClass, \"\", \"\", warning); this.exceptions = new HashMap<String, DatatypeException>(); this.exceptions.put(\"\", ex5); }  public Map<String, DatatypeException> getExceptions() { return exceptions; }  public boolean isWarning() { return warning; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.SAXException;  public final class DebugChecker extends Checker {  public DebugChecker() { super(); }  @Override public void characters(char[] ch, int start, int length) throws SAXException { StringBuilder buf = new StringBuilder(); buf.append(\"Characters: \\u201C\"); buf.append(ch, start, length); buf.append(\"\\u201D.\"); warn(buf.toString()); }  @Override public void endDocument() throws SAXException { }  @Override public void endElement(String uri, String localName, String qName) throws SAXException { warn(\"EndElement: \\u201C\" + localName + \"\\u201D from namespace \\u201C\" + uri + \"\\u201D.\"); }  @Override public void endPrefixMapping(String prefix) throws SAXException { warn(\"EndPrefixMapping: \\u201C\" + prefix + \"\\u201D.\"); }  @Override public void processingInstruction(String target, String data) throws SAXException { warn(\"ProcessingInstruction: \\u201C\" + target + \"\\u201D, \\u201C\" + data + \"\\u201D.\"); }  @Override public void skippedEntity(String name) throws SAXException { warn(\"SkippedEntity: \\u201C\" + name + \"\\u201D.\"); }  @Override public void startDocument() throws SAXException { }  @Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { warn(\"StartElement: \\u201C\" + localName + \"\\u201D from namespace \\u201C\" + uri + \"\\u201D.\"); int len = atts.getLength(); for (int i = 0; i < len; i++) { warn(\"Attribute: \\u201C\" + atts.getLocalName(i) + \"\\u201D\" + (\"\".equals(atts.getURI(i)) ? \"\" : \"from namespace \\u201C\" + atts.getURI(i) + \"\\u201D\") + \" has value: \\u201C\" + atts.getValue(i) + \"\\u201D.\"); } }  @Override public void startPrefixMapping(String prefix, String uri) throws SAXException { warn(\"StartPrefixMapping: \\u201C\" + prefix + \"\\u201D, \\u201C\" + uri + \"\\u201D.\"); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Locator; public class LocatorImpl implements Locator { private final String systemId; private final String publicId; private final int column; private final int line; public LocatorImpl(Locator locator) { this.systemId = locator.getSystemId(); this.publicId = locator.getPublicId(); this.column = locator.getColumnNumber(); this.line = locator.getLineNumber(); } public int getColumnNumber() { return column; } public int getLineNumber() { return line; } public String getPublicId() { return publicId; } public String getSystemId() { return systemId; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import java.util.ArrayDeque; import java.util.Deque; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Set; import org.xml.sax.Attributes; import org.xml.sax.Locator; import org.xml.sax.SAXException;  public class MicrodataChecker extends Checker {  class Element { public final Locator locator; public final String[] itemProp; public final String[] itemRef; public final boolean itemScope; public final List<Element> children; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.SAXException; import com.ibm.icu.lang.UCharacter; import com.ibm.icu.text.Normalizer; import com.ibm.icu.text.UnicodeSet;  public final class NormalizationChecker extends Checker {  @SuppressWarnings(\"deprecation\") private static final UnicodeSet COMPOSING_CHARACTERS = (UnicodeSet) new UnicodeSet( \"[[:nfc_qc=maybe:][:^ccc=0:]]\").freeze(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.SAXException; public class RdfaLiteChecker extends Checker { private static final String GUIDANCE = \" Consider checking against the HTML5 + RDFa 1.1 schema instead.\"; private void warnNonRDFaLite(String localName, String att) throws SAXException { warn(\"RDFa Core attribute \\u201C\" + att + \"\\u201D is not allowed on the \\u201C\" + localName + \"\\u201D element in HTML5 + RDFa 1.1 Lite documents.\" + GUIDANCE); }  @Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Locator; public class TaintableLocatorImpl extends LocatorImpl { private boolean tainted; public TaintableLocatorImpl(Locator locator) { super(locator); this.tainted = false; } public void markTainted() { tainted = true; } public boolean isTainted() { return tainted; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import java.util.LinkedList; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.whattf.datatype.Html5DatatypeException; import org.whattf.datatype.CdoCdcPair; import org.whattf.datatype.TimeDatetime; import org.whattf.datatype.ScriptDocumentation; import org.whattf.datatype.Script; import org.xml.sax.Attributes; import org.xml.sax.SAXException;  public final class TextContentChecker extends Checker {  private final LinkedList<DatatypeStreamingValidator> stack = new LinkedList<DatatypeStreamingValidator>(); private boolean inEmptyTitleOrOption = false;  public TextContentChecker() { super(); }  private DatatypeStreamingValidator streamingValidatorFor(String uri, String localName, Attributes atts) { if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.SAXException; public class UncheckedSubtreeWarner extends Checker { private boolean alreadyWarnedAboutRdf; private boolean alreadyWarnedAboutOpenMath; private boolean alreadyWarnedAboutInkscape; private boolean alreadyWarnedAboutSvgVersion; public UncheckedSubtreeWarner() { alreadyWarnedAboutRdf = false; alreadyWarnedAboutOpenMath = false; alreadyWarnedAboutInkscape = false; alreadyWarnedAboutSvgVersion = false; }  @Override public void startDocument() throws SAXException { alreadyWarnedAboutRdf = false; alreadyWarnedAboutOpenMath = false; alreadyWarnedAboutInkscape = false; alreadyWarnedAboutSvgVersion = false; }  @Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { if (!alreadyWarnedAboutRdf && \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.SAXException; public class UnsupportedFeatureChecker extends Checker {  @Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { boolean w3cBranding = \"1\".equals(System.getProperty(\"nu.validator.servlet.w3cbranding\")) ? true : false; if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.Map; import java.util.Set; import org.xml.sax.Attributes; import org.xml.sax.Locator; import org.xml.sax.SAXException; public class UsemapChecker extends Checker { private final Map<String, Locator> usemapLocationsByName = new LinkedHashMap<String, Locator>(); private final Set<String> mapNames = new HashSet<String>(); private Locator locator = null; public UsemapChecker() { }  @Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker; import org.xml.sax.Attributes; import org.xml.sax.SAXParseException; import org.xml.sax.SAXException; import org.xml.sax.ext.LexicalHandler; import org.xml.sax.helpers.AttributesImpl; import org.relaxng.datatype.DatatypeException; import org.whattf.datatype.Html5DatatypeLibrary; import org.whattf.datatype.Html5DatatypeException; import org.whattf.datatype.Charset; import org.whattf.datatype.IriRef; import org.whattf.datatype.MediaQuery; import org.whattf.datatype.MimeType; public class XmlPiChecker extends Checker implements LexicalHandler { private static final char[][] NAMES = { \"amp;\".toCharArray(), \"lt;\".toCharArray(), \"gt;\".toCharArray(), \"quot;\".toCharArray(), \"apos;\".toCharArray(), }; private static final char[][] VALUES = { { '\\u0026' }, { '\\u003c' }, { '\\u003e' }, { '\\u0022' }, { '\\'' }, }; private static final int DATA_AND_RCDATA_MASK = ~1; private static final int BEFORE_ATTRIBUTE_NAME = 0; private static final int ATTRIBUTE_NAME = 1; private static final int AFTER_ATTRIBUTE_NAME = 2; private static final int BEFORE_ATTRIBUTE_VALUE = 3; private static final int ATTRIBUTE_VALUE_DOUBLE_QUOTED = 4; private static final int ATTRIBUTE_VALUE_SINGLE_QUOTED = 5; private static final int ATTRIBUTE_VALUE_UNQUOTED = 6; private static final int AFTER_ATTRIBUTE_VALUE_QUOTED = 7; private static final int CONSUME_CHARACTER_REFERENCE = 8; private static final int CONSUME_NCR = 9; private static final int CHARACTER_REFERENCE_LOOP = 10; private static final int HEX_NCR_LOOP = 11; private static final int DECIMAL_NRC_LOOP = 12; private static final int HANDLE_NCR_VALUE = 13; private static final int BUFFER_GROW_BY = 1024; private static final char[] REPLACEMENT_CHARACTER = { '\\uFFFD' }; private static final int LEAD_OFFSET = (0xD800 - (0x10000 >> 10)); private char[] strBuf = new char[64]; private int strBufLen; private char[] longStrBuf = new char[1024]; private int longStrBufLen; private final char[] bmpChar = new char[1]; private final char[] astralChar = new char[2]; private int entCol; private int lo; private int hi; private int candidate; private int strBufMark; private int prevValue; private int value; private boolean seenDigits; private char additional; private boolean alreadyWarnedAboutPrivateUseCharacters; private AttributesImpl attributes; private String attributeName; private boolean inDoctype; private boolean alreadyHasElement; private String piTarget = null; private boolean hasXsltPi; private enum PseudoAttrName { HREF, TYPE, TITLE, MEDIA, CHARSET, ALTERNATE, INVALID; private static PseudoAttrName toCaps(String str) { try { if (!str.toLowerCase().equals(str)) { return INVALID; } return valueOf(newAsciiUpperCaseStringFromString(str)); } catch (Exception ex) { return INVALID; } } } public XmlPiChecker() { super(); inDoctype = false; hasXsltPi = false; alreadyHasElement = false; } public void startDTD(String name, String publicId, String systemId) throws SAXException { inDoctype = true; } public void endDTD() throws SAXException { inDoctype = false; } public void startEntity(String name) throws SAXException { } public void endEntity(String name) throws SAXException { } public void startCDATA() throws SAXException { } public void endCDATA() throws SAXException { } public void comment(char[] ch, int start, int len) throws SAXException { } @Override public void startDocument() throws SAXException { inDoctype = false; hasXsltPi = false; alreadyHasElement = false; } @Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { alreadyHasElement = true; } @Override public void processingInstruction(String target, String data) throws SAXException { piTarget = target; if (\"xml-stylesheet\".equals(piTarget)) { checkXmlStylesheetPiData(data); } } private void errBadPseudoAttrDatatype(DatatypeException e, Class<?> datatypeClass, String attrName, String attrValue) throws SAXException, ClassNotFoundException { if (getErrorHandler() != null) { Html5DatatypeException ex5 = (Html5DatatypeException) e; boolean warning = ex5.isWarning() ? true : false; DatatypeMismatchException bpe = new DatatypeMismatchException( \"Bad value \\u201c\" + attrValue + \"\\u201d for \\u201c\" + piTarget + \"\\u201d pseudo-attribute \\u201c\" + attrName + \"\\u201d. \" + e.getMessage(), getDocumentLocator(), datatypeClass, warning); getErrorHandler().error(bpe); } } private void errAttributeWithNoValue() throws SAXException { err(\"Found \\u201c\" + piTarget + \"\\u201d pseudo-attribute \\u201c\" + attributeName + \"\\u201d without a value. All pseudo-attributes in \\u201c\" + piTarget + \"\\u201d instructions must have values.\"); } private void errAttributeValueContainsLt() throws SAXException { err(\"Found \\u201c\" + piTarget + \"\\u201d pseudo-attribute \\u201c\" + attributeName + \"\\u201d with the character \\u201c<\\u201d in its value. All pseudo-attribute values in \\u201c\" + piTarget + \"\\u201d instructions must not contain the character \\u201c<\\u201d.\"); } private void errUpperCaseXinHexNcr() throws SAXException { err(\"In XML documents, a hexadecimal character reference must begin with \" + \"\\u201c&#x\\u201d (lowercase \\u201cx\\u201d), not \\u201c&#X\\u201d (uppercase \\u201cX\\u201d).\"); } private void checkXmlStylesheetPiData(String data) throws SAXException { boolean hasHref = false; boolean hasTitle = false; boolean hasMedia = false; boolean hasCharset = false; boolean hasAlternate = false; boolean hasNonEmptyTitle = false; boolean alternateIsYes = false; boolean badDatatype = false; if (inDoctype) { warn(\"An \\u201cxml-stylesheet\\u201d instruction should not be used within a \\u201cDOCTYPE\\u201d declaration.\"); } if (alreadyHasElement) { err(\"Any \\u201cxml-stylesheet\\u201d instruction in a document must occur before any elements in the document. \" + \"Suppressing any further errors for this \\u201cxml-stylesheet\\u201d instruction.\"); return; } if (!\"\".equals(data)) { Html5DatatypeLibrary dl = new Html5DatatypeLibrary(); AttributesImpl patts = getPseudoAttributesFromPiData(data); String attrName; String attrValue; for (int i = 0; i < patts.getLength(); i++) { attrName = patts.getQName(i); attrValue = patts.getValue(i); switch (PseudoAttrName.toCaps(attrName)) { case HREF: hasHref = true; if (attrValue == null) { break; } try { IriRef ir = (IriRef) dl.createDatatype(\"iri-ref\"); ir.checkValid(attrValue); } catch (DatatypeException e) { try { errBadPseudoAttrDatatype(e, IriRef.class, \"href\", attrValue); } catch (ClassNotFoundException ce) { } } break; case TYPE: if (attrValue == null) { break; } try { MimeType mt = (MimeType) dl.createDatatype(\"mime-type\"); mt.checkValid(attrValue); attrValue = newAsciiLowerCaseStringFromString(attrValue); } catch (DatatypeException e) { badDatatype = true; try { errBadPseudoAttrDatatype(e, MimeType.class, \"type\", attrValue); } catch (ClassNotFoundException ce) { } } if (!badDatatype) { if (attrValue.matches(\"application/xml(;.*)?\") || attrValue.matches(\"text/xml(;.*)?\") || attrValue.matches(\"application/xslt+xml(;.*)?\") || attrValue.matches(\"text/xsl(;.*)?\") || attrValue.matches(\"text/xslt(;.*)?\")) { if (!attrValue.matches(\"text/xsl(;.*)?\")) { warn(\"For indicating XSLT, \\u201ctext/xsl\\u201d is the only MIME type for the \" + \"\\u201cxml-stylesheet\\u201d pseudo-attribute \\u201ctype\\u201d that is supported across browsers.\"); } if (hasXsltPi) { warn(\"Browsers do not support multiple \\u201cxml-stylesheet\\u201d instructions with a \" + \"\\u201ctype\\u201d value that indicates XSLT.\"); } hasXsltPi = true; } else if (!attrValue.matches(\"^text/css(;.*)?$\")) { warn(\"\\u201ctext/css\\u201d and \\u201ctext/xsl\\u201d are the only MIME types for the \" + \"\\u201cxml-stylesheet\\u201d pseudo-attribute \\u201ctype\\u201d that are supported across browsers.\"); } } break; case TITLE: hasTitle = true; if (attrValue == null) { break; } if (!\"\".equals(attrValue)) { hasNonEmptyTitle = true; } break; case MEDIA: hasMedia = true; if (attrValue == null) { break; } try { MediaQuery mq = (MediaQuery) dl.createDatatype(\"media-query\"); mq.checkValid(attrValue); } catch (DatatypeException e) { try { errBadPseudoAttrDatatype(e, MediaQuery.class, \"media\", attrValue); } catch (ClassNotFoundException ce) { } } break; case CHARSET: hasCharset = true; if (attrValue == null) { break; } try { Charset c = (Charset) dl.createDatatype(\"charset\"); c.checkValid(attrValue); } catch (DatatypeException e) { try { errBadPseudoAttrDatatype(e, Charset.class, \"charset\", attrValue); } catch (ClassNotFoundException ce) { } } break; case ALTERNATE: hasAlternate = true; if (attrValue == null) { break; } if (\"yes\".equals(attrValue)) { alternateIsYes = true; } else if (!\"no\".equals(attrValue)) { err(\"The value of the \\u201cxml-stylesheet\\u201d pseudo-attribute \\u201calternate\\u201d \" + \"must be either \\u201cyes\\u201d or \\u201cno\\u201d.\"); } break; default: err(\"Pseudo-attribute \\u201c\" + attrName + \"\\u201D not allowed in \\u201cxml-stylesheet\\u201d instruction.\"); break; } } if (alternateIsYes && !hasNonEmptyTitle) { err(\"An \\u201cxml-stylesheet\\u201d instruction with an \\u201calternate\\u201d pseudo-attribute \" + \"whose value is \\u201cyes\\u201d must also have a \\u201ctitle\\u201d pseudo-attribute with a non-empty value.\"); } } if (!hasHref) { err(\"\\u201cxml-stylesheet\\u201d instruction lacks \\u201chref\\u201d pseudo-attribute. \" + \"The \\u201chref\\u201d pseudo-attribute is required in all \\u201cxml-stylesheet\\u201d instructions.\"); } if (hasXsltPi && (hasTitle || hasMedia || hasCharset || hasAlternate)) { warn(\"When processing \\u201cxml-stylesheet\\u201d instructions, browsers ignore the pseudo-attributes \" + \"\\u201ctitle\\u201d, \\u201cmedia\\u201d, \\u201ccharset\\u201d, and \\u201calternate\\u201d.\"); } else if (hasCharset) { warn(\"Some browsers ignore the value of the \\u201cxml-stylesheet\\u201d pseudo-attribute \\u201ccharset\\u201d.\"); } }  private AttributesImpl getPseudoAttributesFromPiData(String buf) throws SAXException { int state = BEFORE_ATTRIBUTE_NAME; int returnState = BEFORE_ATTRIBUTE_NAME; char c = '\\u0000'; int pos = -1; int endPos = buf.length(); boolean reconsume = false; attributes = null; attributeName = null; stateloop: for (;;) { switch (state) { case BEFORE_ATTRIBUTE_NAME: beforeattributenameloop: for (;;) { if (reconsume) { reconsume = false; } else { if (++pos == endPos) { break stateloop; } c = buf.charAt(pos); }  switch (c) { case '\\n': case ' ': case '\\t': continue; case '/': case '>': case '\\\"': case '\\'': case '<': case '=':  errBadCharBeforeAttributeNameOrNull(c);  default:   clearStrBufAndAppendCurrentC(c);  "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.jing; import org.whattf.checker.Checker; import org.whattf.checker.ConformingButObsoleteWarner; import org.whattf.checker.DebugChecker; import org.whattf.checker.MicrodataChecker; import org.whattf.checker.RdfaLiteChecker; import org.whattf.checker.NormalizationChecker; import org.whattf.checker.TextContentChecker; import org.whattf.checker.UncheckedSubtreeWarner; import org.whattf.checker.UnsupportedFeatureChecker; import org.whattf.checker.UsemapChecker; import org.whattf.checker.XmlPiChecker; import org.whattf.checker.schematronequiv.Assertions; import org.whattf.checker.schematronequiv.Html4Assertions; import org.whattf.checker.table.TableChecker; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.Schema; import com.thaiopensource.validate.Validator; public class CheckerSchema implements Schema { public static final CheckerSchema DEBUG_CHECKER = new CheckerSchema(PropertyMap.EMPTY, DebugChecker.class); public static final CheckerSchema NORMALIZATION_CHECKER = new CheckerSchema(PropertyMap.EMPTY, NormalizationChecker.class); public static final CheckerSchema TEXT_CONTENT_CHECKER = new CheckerSchema(PropertyMap.EMPTY, TextContentChecker.class); public static final CheckerSchema UNCHECKED_SUBTREE_WARNER = new CheckerSchema(PropertyMap.EMPTY, UncheckedSubtreeWarner.class); public static final CheckerSchema USEMAP_CHECKER = new CheckerSchema(PropertyMap.EMPTY, UsemapChecker.class); public static final CheckerSchema TABLE_CHECKER = new CheckerSchema(PropertyMap.EMPTY, TableChecker.class); public static final CheckerSchema ASSERTION_SCH = new CheckerSchema(PropertyMap.EMPTY, Assertions.class); public static final CheckerSchema HTML4ASSERTION_SCH = new CheckerSchema(PropertyMap.EMPTY, Html4Assertions.class); public static final CheckerSchema CONFORMING_BUT_OBSOLETE_WARNER = new CheckerSchema(PropertyMap.EMPTY, ConformingButObsoleteWarner.class); public static final CheckerSchema XML_PI_CHECKER = new CheckerSchema(PropertyMap.EMPTY, XmlPiChecker.class); public static final CheckerSchema UNSUPPORTED_CHECKER = new CheckerSchema(PropertyMap.EMPTY, UnsupportedFeatureChecker.class); public static final CheckerSchema MICRODATA_CHECKER = new CheckerSchema(PropertyMap.EMPTY, MicrodataChecker.class); public static final CheckerSchema RDFALITE_CHECKER = new CheckerSchema(PropertyMap.EMPTY, RdfaLiteChecker.class); private final PropertyMap properties; private final Class<? extends Checker> klazz;  public CheckerSchema(PropertyMap properties, Class<? extends Checker> klazz) { this.properties = properties; this.klazz = klazz; } public Validator createValidator(PropertyMap props) { try { return new CheckerValidator(klazz.newInstance(), props); } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } public PropertyMap getProperties() { return properties; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.jing; import org.whattf.checker.Checker; import org.xml.sax.ContentHandler; import org.xml.sax.DTDHandler; import org.xml.sax.ErrorHandler; import com.thaiopensource.util.PropertyMap; import com.thaiopensource.validate.ValidateProperty; import com.thaiopensource.validate.Validator;  public final class CheckerValidator implements Validator {  private final Checker checker;  public CheckerValidator(Checker checker, PropertyMap propertyMap) { super(); this.checker = checker; this.checker.setErrorHandler((ErrorHandler) propertyMap.get(ValidateProperty.ERROR_HANDLER)); }  public ContentHandler getContentHandler() { return checker; }  public DTDHandler getDTDHandler() { return null; }  public void reset() { this.checker.reset(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.schematronequiv; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.Map; import java.util.Set; import java.util.Arrays; import org.whattf.checker.AttributeUtil; import org.whattf.checker.Checker; import org.whattf.checker.LocatorImpl; import org.whattf.checker.TaintableLocatorImpl; import org.xml.sax.Attributes; import org.xml.sax.Locator; import org.xml.sax.SAXException; public class Assertions extends Checker { private static boolean w3cBranding = \"1\".equals(System.getProperty(\"nu.validator.servlet.w3cbranding\")) ? true : false; private static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString( String lowerCaseLiteral, String string) { if (string == null) { return false; } if (lowerCaseLiteral.length() != string.length()) { return false; } for (int i = 0; i < lowerCaseLiteral.length(); i++) { char c0 = lowerCaseLiteral.charAt(i); char c1 = string.charAt(i); if (c1 >= 'A' && c1 <= 'Z') { c1 += 0x20; } if (c0 != c1) { return false; } } return true; } private static boolean equalsIgnoreAsciiCase(String one, String other) { if (other == null) { if (one == null) { return true; } else { return false; } } if (one.length() != other.length()) { return false; } for (int i = 0; i < one.length(); i++) { char c0 = one.charAt(i); char c1 = other.charAt(i); if (c0 >= 'A' && c0 <= 'Z') { c0 += 0x20; } if (c1 >= 'A' && c1 <= 'Z') { c1 += 0x20; } if (c0 != c1) { return false; } } return true; } private static final String trimSpaces(String str) { return trimLeadingSpaces(trimTrailingSpaces(str)); } private static final String trimLeadingSpaces(String str) { if (str == null) { return null; } for (int i = str.length(); i > 0; --i) { char c = str.charAt(str.length() - i); if (!(' ' == c || '\\t' == c || '\\n' == c || '\\f' == c || '\\r' == c)) { return str.substring(str.length() - i, str.length()); } } return \"\"; } private static final String trimTrailingSpaces(String str) { if (str == null) { return null; } for (int i = str.length() - 1; i >= 0; --i) { char c = str.charAt(i); if (!(' ' == c || '\\t' == c || '\\n' == c || '\\f' == c || '\\r' == c)) { return str.substring(0, i + 1); } } return \"\"; } private static final Map<String, String> OBSOLETE_ELEMENTS = new HashMap<String, String>(); static { OBSOLETE_ELEMENTS.put(\"center\", \"Use CSS instead.\"); OBSOLETE_ELEMENTS.put(\"font\", \"Use CSS instead.\"); OBSOLETE_ELEMENTS.put(\"big\", \"Use CSS instead.\"); OBSOLETE_ELEMENTS.put(\"strike\", \"Use CSS instead.\"); OBSOLETE_ELEMENTS.put(\"tt\", \"Use CSS instead.\"); OBSOLETE_ELEMENTS.put(\"acronym\", \"Use the \\u201Cabbr\\u201D element instead.\"); OBSOLETE_ELEMENTS.put(\"dir\", \"Use the \\u201Cul\\u201D element instead.\"); OBSOLETE_ELEMENTS.put(\"applet\", \"Use the \\u201Cobject\\u201D element instead.\"); OBSOLETE_ELEMENTS.put(\"basefont\", \"Use CSS instead.\"); OBSOLETE_ELEMENTS.put( \"frameset\", \"Use the \\u201Ciframe\\u201D element and CSS instead, or use server-side includes.\"); OBSOLETE_ELEMENTS.put( \"noframes\", \"Use the \\u201Ciframe\\u201D element and CSS instead, or use server-side includes.\"); if (w3cBranding) { OBSOLETE_ELEMENTS.put( \"hgroup\", \"To mark up subheadings, consider either just putting the \" + \"subheading into a \\u201Cp\\u201D element after the \" + \"\\u201Ch1\\u201D-\\u201Ch6\\u201D element containing the \" + \"main heading, or else putting the subheading directly \" + \"within the \\u201Ch1\\u201D-\\u201Ch6\\u201D element \" + \"containing the main heading, but separated from the main \" + \"heading by punctuation and/or within, for example, a \" + \"\\u201Cspan class=\\\"subheading\\\"\\u201D element with \" + \"differentiated styling. \" + \"To group headings and subheadings, alternative titles, \" + \"or taglines, consider using the \\u201Cheader\\u201D or \" + \"\\u201Cdiv\\u201D elements.\"); } } private static final Map<String, String[]> OBSOLETE_ATTRIBUTES = new HashMap<String, String[]>(); static { OBSOLETE_ATTRIBUTES.put(\"abbr\", new String[] { \"td\", \"th\" }); OBSOLETE_ATTRIBUTES.put(\"archive\", new String[] { \"object\" }); OBSOLETE_ATTRIBUTES.put(\"axis\", new String[] { \"td\", \"th\" }); OBSOLETE_ATTRIBUTES.put(\"charset\", new String[] { \"link\", \"a\" }); OBSOLETE_ATTRIBUTES.put(\"classid\", new String[] { \"object\" }); OBSOLETE_ATTRIBUTES.put(\"code\", new String[] { \"object\" }); OBSOLETE_ATTRIBUTES.put(\"codebase\", new String[] { \"object\" }); OBSOLETE_ATTRIBUTES.put(\"codetype\", new String[] { \"object\" }); OBSOLETE_ATTRIBUTES.put(\"coords\", new String[] { \"a\" }); OBSOLETE_ATTRIBUTES.put(\"datafld\", new String[] { \"span\", \"div\", \"object\", \"input\", \"select\", \"textarea\", \"button\", \"table\" }); OBSOLETE_ATTRIBUTES.put(\"dataformatas\", new String[] { \"span\", \"div\", \"object\", \"input\", \"select\", \"textarea\", \"button\", \"table\" }); OBSOLETE_ATTRIBUTES.put(\"datasrc\", new String[] { \"span\", \"div\", \"object\", \"input\", \"select\", \"textarea\", \"button\", \"table\" }); OBSOLETE_ATTRIBUTES.put(\"datapagesize\", new String[] { \"table\" }); OBSOLETE_ATTRIBUTES.put(\"declare\", new String[] { \"object\" }); OBSOLETE_ATTRIBUTES.put(\"event\", new String[] { \"script\" }); OBSOLETE_ATTRIBUTES.put(\"for\", new String[] { \"script\" }); OBSOLETE_ATTRIBUTES.put(\"language\", new String[] { \"script\" }); if (!w3cBranding) { OBSOLETE_ATTRIBUTES.put(\"longdesc\", new String[] { \"img\", \"iframe\" }); } OBSOLETE_ATTRIBUTES.put(\"methods\", new String[] { \"link\", \"a\" }); OBSOLETE_ATTRIBUTES.put(\"name\", new String[] { \"img\", \"embed\", \"option\" }); OBSOLETE_ATTRIBUTES.put(\"nohref\", new String[] { \"area\" }); OBSOLETE_ATTRIBUTES.put(\"profile\", new String[] { \"head\" }); OBSOLETE_ATTRIBUTES.put(\"scheme\", new String[] { \"meta\" }); OBSOLETE_ATTRIBUTES.put(\"scope\", new String[] { \"td\" }); OBSOLETE_ATTRIBUTES.put(\"shape\", new String[] { \"a\" }); OBSOLETE_ATTRIBUTES.put(\"standby\", new String[] { \"object\" }); OBSOLETE_ATTRIBUTES.put(\"target\", new String[] { \"link\" }); OBSOLETE_ATTRIBUTES.put(\"type\", new String[] { \"param\" }); OBSOLETE_ATTRIBUTES.put(\"urn\", new String[] { \"a\", \"link\" }); OBSOLETE_ATTRIBUTES.put(\"usemap\", new String[] { \"input\" }); OBSOLETE_ATTRIBUTES.put(\"valuetype\", new String[] { \"param\" }); OBSOLETE_ATTRIBUTES.put(\"version\", new String[] { \"html\" }); } private static final Map<String, String> OBSOLETE_ATTRIBUTES_MSG = new HashMap<String, String>(); static { OBSOLETE_ATTRIBUTES_MSG.put( \"abbr\", \"Consider instead beginning the cell contents with concise text, followed by further elaboration if needed.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"archive\", \"Use the \\u201Cdata\\u201D and \\u201Ctype\\u201D attributes to invoke plugins. To set a parameter with the name \\u201Carchive\\u201D, use the \\u201Cparam\\u201D element.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"axis\", \"Use the \\u201Cscope\\u201D attribute.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"charset\", \"Use an HTTP Content-Type header on the linked resource instead.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"classid\", \"Use the \\u201Cdata\\u201D and \\u201Ctype\\u201D attributes to invoke plugins. To set a parameter with the name \\u201Cclassid\\u201D, use the \\u201Cparam\\u201D element.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"code\", \"Use the \\u201Cdata\\u201D and \\u201Ctype\\u201D attributes to invoke plugins. To set a parameter with the name \\u201Ccode\\u201D, use the \\u201Cparam\\u201D element.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"codebase\", \"Use the \\u201Cdata\\u201D and \\u201Ctype\\u201D attributes to invoke plugins. To set a parameter with the name \\u201Ccodebase\\u201D, use the \\u201Cparam\\u201D element.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"codetype\", \"Use the \\u201Cdata\\u201D and \\u201Ctype\\u201D attributes to invoke plugins. To set a parameter with the name \\u201Ccodetype\\u201D, use the \\u201Cparam\\u201D element.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"coords\", \"Use \\u201Carea\\u201D instead of \\u201Ca\\u201D for image maps.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"datapagesize\", \"You can safely omit it.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"datafld\", \"Use script and a mechanism such as XMLHttpRequest to populate the page dynamically\"); OBSOLETE_ATTRIBUTES_MSG.put(\"dataformatas\", \"Use script and a mechanism such as XMLHttpRequest to populate the page dynamically\"); OBSOLETE_ATTRIBUTES_MSG.put(\"datasrc\", \"Use script and a mechanism such as XMLHttpRequest to populate the page dynamically\"); OBSOLETE_ATTRIBUTES_MSG.put(\"for\", \"Use DOM Events mechanisms to register event listeners.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"event\", \"Use DOM Events mechanisms to register event listeners.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"declare\", \"Repeat the \\u201Cobject\\u201D element completely each time the resource is to be reused.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"language\", \"Use the \\u201Ctype\\u201D attribute instead.\"); if (!w3cBranding) { OBSOLETE_ATTRIBUTES_MSG.put(\"longdesc\", \"Use a regular \\u201Ca\\u201D element to link to the description.\"); } OBSOLETE_ATTRIBUTES_MSG.put(\"methods\", \"Use the HTTP OPTIONS feature instead.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"name\", \"Use the \\u201Cid\\u201D attribute instead.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"nohref\", \"Omitting the \\u201Chref\\u201D attribute is sufficient.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"profile\", \"To declare which \\u201Cmeta\\u201D terms are used in the document, instead register the names as meta extensions. To trigger specific UA behaviors, use a \\u201Clink\\u201D element instead.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"scheme\", \"Use only one scheme per field, or make the scheme declaration part of the value.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"scope\", \"Use the \\u201Cscope\\u201D attribute on a \\u201Cth\\u201D element instead.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"shape\", \"Use \\u201Carea\\u201D instead of \\u201Ca\\u201D for image maps.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"standby\", \"Optimise the linked resource so that it loads quickly or, at least, incrementally.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"target\", \"You can safely omit it.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"type\", \"Use the \\u201Cname\\u201D and \\u201Cvalue\\u201D attributes without declaring value types.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"urn\", \"Specify the preferred persistent identifier using the \\u201Chref\\u201D attribute instead.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"usemap\", \"Use the \\u201Cimg\\u201D element instead of the \\u201Cinput\\u201D element for image maps.\"); OBSOLETE_ATTRIBUTES_MSG.put( \"valuetype\", \"Use the \\u201Cname\\u201D and \\u201Cvalue\\u201D attributes without declaring value types.\"); OBSOLETE_ATTRIBUTES_MSG.put(\"version\", \"You can safely omit it.\"); } private static final Map<String, String[]> OBSOLETE_STYLE_ATTRS = new HashMap<String, String[]>(); static { OBSOLETE_STYLE_ATTRS.put(\"align\", new String[] { \"caption\", \"iframe\", \"img\", \"input\", \"object\", \"embed\", \"legend\", \"table\", \"hr\", \"div\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"p\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\" }); OBSOLETE_STYLE_ATTRS.put(\"alink\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"allowtransparency\", new String[] { \"iframe\" }); OBSOLETE_STYLE_ATTRS.put(\"background\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"bgcolor\", new String[] { \"table\", \"tr\", \"td\", \"th\", \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"border\", new String[] { \"object\", \"table\" }); OBSOLETE_STYLE_ATTRS.put(\"cellpadding\", new String[] { \"table\" }); OBSOLETE_STYLE_ATTRS.put(\"cellspacing\", new String[] { \"table\" }); OBSOLETE_STYLE_ATTRS.put(\"char\", new String[] { \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\" }); OBSOLETE_STYLE_ATTRS.put(\"charoff\", new String[] { \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\" }); OBSOLETE_STYLE_ATTRS.put(\"clear\", new String[] { \"br\" }); OBSOLETE_STYLE_ATTRS.put(\"color\", new String[] { \"hr\" }); OBSOLETE_STYLE_ATTRS.put(\"compact\", new String[] { \"dl\", \"menu\", \"ol\", \"ul\" }); OBSOLETE_STYLE_ATTRS.put(\"frameborder\", new String[] { \"iframe\" }); OBSOLETE_STYLE_ATTRS.put(\"frame\", new String[] { \"table\" }); OBSOLETE_STYLE_ATTRS.put(\"height\", new String[] { \"td\", \"th\" }); OBSOLETE_STYLE_ATTRS.put(\"hspace\", new String[] { \"img\", \"object\", \"embed\" }); OBSOLETE_STYLE_ATTRS.put(\"link\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"marginbottom\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"marginheight\", new String[] { \"iframe\", \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"marginleft\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"marginright\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"margintop\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"marginwidth\", new String[] { \"iframe\", \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"noshade\", new String[] { \"hr\" }); OBSOLETE_STYLE_ATTRS.put(\"nowrap\", new String[] { \"td\", \"th\" }); OBSOLETE_STYLE_ATTRS.put(\"rules\", new String[] { \"table\" }); OBSOLETE_STYLE_ATTRS.put(\"scrolling\", new String[] { \"iframe\" }); OBSOLETE_STYLE_ATTRS.put(\"size\", new String[] { \"hr\" }); OBSOLETE_STYLE_ATTRS.put(\"text\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"type\", new String[] { \"li\", \"ul\" }); OBSOLETE_STYLE_ATTRS.put(\"valign\", new String[] { \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\" }); OBSOLETE_STYLE_ATTRS.put(\"vlink\", new String[] { \"body\" }); OBSOLETE_STYLE_ATTRS.put(\"vspace\", new String[] { \"img\", \"object\", \"embed\" }); OBSOLETE_STYLE_ATTRS.put(\"width\", new String[] { \"hr\", \"table\", \"td\", \"th\", \"col\", \"colgroup\", \"pre\" }); } private static final String[] SPECIAL_ANCESTORS = { \"a\", \"address\", \"button\", \"caption\", \"dfn\", \"dt\", \"figcaption\", \"figure\", \"footer\", \"form\", \"header\", \"label\", \"map\", \"noscript\", \"th\", \"time\", \"progress\", \"meter\", \"article\", \"aside\", \"nav\" }; private static int specialAncestorNumber(String name) { for (int i = 0; i < SPECIAL_ANCESTORS.length; i++) { if (name == SPECIAL_ANCESTORS[i]) { return i; } } return -1; } private static Map<String, Integer> ANCESTOR_MASK_BY_DESCENDANT = new HashMap<String, Integer>(); private static void registerProhibitedAncestor(String ancestor, String descendant) { int number = specialAncestorNumber(ancestor); if (number == -1) { throw new IllegalStateException(\"Ancestor not found in array: \" + ancestor); } Integer maskAsObject = ANCESTOR_MASK_BY_DESCENDANT.get(descendant); int mask = 0; if (maskAsObject != null) { mask = maskAsObject.intValue(); } mask |= (1 << number); ANCESTOR_MASK_BY_DESCENDANT.put(descendant, new Integer(mask)); } static { registerProhibitedAncestor(\"form\", \"form\"); registerProhibitedAncestor(\"time\", \"time\"); registerProhibitedAncestor(\"progress\", \"progress\"); registerProhibitedAncestor(\"meter\", \"meter\"); registerProhibitedAncestor(\"dfn\", \"dfn\"); registerProhibitedAncestor(\"noscript\", \"noscript\"); registerProhibitedAncestor(\"label\", \"label\"); registerProhibitedAncestor(\"address\", \"address\"); registerProhibitedAncestor(\"address\", \"section\"); registerProhibitedAncestor(\"address\", \"nav\"); registerProhibitedAncestor(\"address\", \"article\"); registerProhibitedAncestor(\"address\", \"aside\"); registerProhibitedAncestor(\"header\", \"header\"); registerProhibitedAncestor(\"footer\", \"header\"); registerProhibitedAncestor(\"address\", \"header\"); registerProhibitedAncestor(\"header\", \"footer\"); registerProhibitedAncestor(\"footer\", \"footer\"); registerProhibitedAncestor(\"dt\", \"header\"); registerProhibitedAncestor(\"dt\", \"footer\"); registerProhibitedAncestor(\"dt\", \"article\"); registerProhibitedAncestor(\"dt\", \"aside\"); registerProhibitedAncestor(\"dt\", \"nav\"); registerProhibitedAncestor(\"dt\", \"section\"); registerProhibitedAncestor(\"dt\", \"h1\"); registerProhibitedAncestor(\"dt\", \"h2\"); registerProhibitedAncestor(\"dt\", \"h2\"); registerProhibitedAncestor(\"dt\", \"h3\"); registerProhibitedAncestor(\"dt\", \"h4\"); registerProhibitedAncestor(\"dt\", \"h5\"); registerProhibitedAncestor(\"dt\", \"h6\"); registerProhibitedAncestor(\"dt\", \"hgroup\"); registerProhibitedAncestor(\"th\", \"header\"); registerProhibitedAncestor(\"th\", \"footer\"); registerProhibitedAncestor(\"th\", \"article\"); registerProhibitedAncestor(\"th\", \"aside\"); registerProhibitedAncestor(\"th\", \"nav\"); registerProhibitedAncestor(\"th\", \"section\"); registerProhibitedAncestor(\"th\", \"h1\"); registerProhibitedAncestor(\"th\", \"h2\"); registerProhibitedAncestor(\"th\", \"h2\"); registerProhibitedAncestor(\"th\", \"h3\"); registerProhibitedAncestor(\"th\", \"h4\"); registerProhibitedAncestor(\"th\", \"h5\"); registerProhibitedAncestor(\"th\", \"h6\"); registerProhibitedAncestor(\"th\", \"hgroup\"); registerProhibitedAncestor(\"address\", \"footer\"); registerProhibitedAncestor(\"address\", \"h1\"); registerProhibitedAncestor(\"address\", \"h2\"); registerProhibitedAncestor(\"address\", \"h3\"); registerProhibitedAncestor(\"address\", \"h4\"); registerProhibitedAncestor(\"address\", \"h5\"); registerProhibitedAncestor(\"address\", \"h6\"); registerProhibitedAncestor(\"a\", \"a\"); registerProhibitedAncestor(\"button\", \"a\"); registerProhibitedAncestor(\"a\", \"details\"); registerProhibitedAncestor(\"button\", \"details\"); registerProhibitedAncestor(\"a\", \"button\"); registerProhibitedAncestor(\"button\", \"button\"); registerProhibitedAncestor(\"a\", \"textarea\"); registerProhibitedAncestor(\"button\", \"textarea\"); registerProhibitedAncestor(\"a\", \"select\"); registerProhibitedAncestor(\"button\", \"select\"); registerProhibitedAncestor(\"a\", \"keygen\"); registerProhibitedAncestor(\"button\", \"keygen\"); registerProhibitedAncestor(\"a\", \"embed\"); registerProhibitedAncestor(\"button\", \"embed\"); registerProhibitedAncestor(\"a\", \"iframe\"); registerProhibitedAncestor(\"button\", \"iframe\"); registerProhibitedAncestor(\"a\", \"label\"); registerProhibitedAncestor(\"button\", \"label\"); registerProhibitedAncestor(\"caption\", \"table\"); registerProhibitedAncestor(\"article\", \"main\"); registerProhibitedAncestor(\"aside\", \"main\"); registerProhibitedAncestor(\"header\", \"main\"); registerProhibitedAncestor(\"footer\", \"main\"); registerProhibitedAncestor(\"nav\", \"main\"); } private static final int A_BUTTON_MASK = (1 << specialAncestorNumber(\"a\")) | (1 << specialAncestorNumber(\"button\")); private static final int FIGCAPTION_MASK = (1 << specialAncestorNumber(\"figcaption\")); private static final int FIGURE_MASK = (1 << specialAncestorNumber(\"figure\")); private static final int MAP_MASK = (1 << specialAncestorNumber(\"map\")); private static final int HREF_MASK = (1 << 30); private static final int LABEL_FOR_MASK = (1 << 28); private static final Map<String, Set<String>> REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT = new HashMap<String, Set<String>>(); private static final Map<String, Set<String>> ariaOwnsIdsByRole = new HashMap<String, Set<String>>(); private static void registerRequiredAncestorRole(String parent, String child) { Set<String> parents = REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT.get(child); if (parents == null) { parents = new HashSet<String>(); } parents.add(parent); REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT.put(child, parents); } static { registerRequiredAncestorRole(\"combobox\", \"option\"); registerRequiredAncestorRole(\"listbox\", \"option\"); registerRequiredAncestorRole(\"radiogroup\", \"option\"); registerRequiredAncestorRole(\"menu\", \"option\"); registerRequiredAncestorRole(\"menu\", \"menuitem\"); registerRequiredAncestorRole(\"menu\", \"menuitemcheckbox\"); registerRequiredAncestorRole(\"menu\", \"menuitemradio\"); registerRequiredAncestorRole(\"menubar\", \"menuitem\"); registerRequiredAncestorRole(\"menubar\", \"menuitemcheckbox\"); registerRequiredAncestorRole(\"menubar\", \"menuitemradio\"); registerRequiredAncestorRole(\"tablist\", \"tab\"); registerRequiredAncestorRole(\"tree\", \"treeitem\"); registerRequiredAncestorRole(\"tree\", \"option\"); registerRequiredAncestorRole(\"group\", \"treeitem\"); registerRequiredAncestorRole(\"group\", \"listitem\"); registerRequiredAncestorRole(\"group\", \"menuitemradio\"); registerRequiredAncestorRole(\"list\", \"listitem\"); registerRequiredAncestorRole(\"row\", \"gridcell\"); registerRequiredAncestorRole(\"row\", \"columnheader\"); registerRequiredAncestorRole(\"row\", \"rowheader\"); registerRequiredAncestorRole(\"grid\", \"row\"); registerRequiredAncestorRole(\"grid\", \"rowgroup\"); registerRequiredAncestorRole(\"rowgroup\", \"row\"); registerRequiredAncestorRole(\"treegrid\", \"row\"); } private static final Set<String> MUST_NOT_DANGLE_IDREFS = new HashSet<String>(); static { MUST_NOT_DANGLE_IDREFS.add(\"aria-controls\"); MUST_NOT_DANGLE_IDREFS.add(\"aria-describedby\"); MUST_NOT_DANGLE_IDREFS.add(\"aria-flowto\"); MUST_NOT_DANGLE_IDREFS.add(\"aria-labelledby\"); MUST_NOT_DANGLE_IDREFS.add(\"aria-owns\"); } private class IdrefLocator { private final Locator locator; private final String idref; private final String additional;  public IdrefLocator(Locator locator, String idref) { this.locator = new LocatorImpl(locator); this.idref = idref; this.additional = null; } public IdrefLocator(Locator locator, String idref, String additional) { this.locator = new LocatorImpl(locator); this.idref = idref; this.additional = additional; }  public Locator getLocator() { return locator; }  public String getIdref() { return idref; }  public String getAdditional() { return additional; } } private class StackNode { private final int ancestorMask; private final String name; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.schematronequiv; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.Map; import java.util.Set; import org.whattf.checker.Checker; import org.whattf.checker.LocatorImpl; import org.xml.sax.Attributes; import org.xml.sax.Locator; import org.xml.sax.SAXException; public class Html4Assertions extends Checker { private static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString( String lowerCaseLiteral, String string) { if (string == null) { return false; } if (lowerCaseLiteral.length() != string.length()) { return false; } for (int i = 0; i < lowerCaseLiteral.length(); i++) { char c0 = lowerCaseLiteral.charAt(i); char c1 = string.charAt(i); if (c1 >= 'A' && c1 <= 'Z') { c1 += 0x20; } if (c0 != c1) { return false; } } return true; } private static boolean equalsIgnoreAsciiCase(String one, String other) { if (other == null) { if (one == null) { return true; } else { return false; } } if (one.length() != other.length()) { return false; } for (int i = 0; i < one.length(); i++) { char c0 = one.charAt(i); char c1 = other.charAt(i); if (c0 >= 'A' && c0 <= 'Z') { c0 += 0x20; } if (c1 >= 'A' && c1 <= 'Z') { c1 += 0x20; } if (c0 != c1) { return false; } } return true; } private static final String[] SPECIAL_ANCESTORS = { \"a\", \"button\", \"form\", \"label\", \"pre\" }; private static int specialAncestorNumber(String name) { for (int i = 0; i < SPECIAL_ANCESTORS.length; i++) { if (name == SPECIAL_ANCESTORS[i]) { return i; } } return -1; } private static Map<String, Integer> ANCESTOR_MASK_BY_DESCENDANT = new HashMap<String, Integer>(); private static void registerProhibitedAncestor(String ancestor, String descendant) { int number = specialAncestorNumber(ancestor); if (number == -1) { throw new IllegalStateException(\"Ancestor not found in array: \" + ancestor); } Integer maskAsObject = ANCESTOR_MASK_BY_DESCENDANT.get(descendant); int mask = 0; if (maskAsObject != null) { mask = maskAsObject.intValue(); } mask |= (1 << number); ANCESTOR_MASK_BY_DESCENDANT.put(descendant, new Integer(mask)); } static { registerProhibitedAncestor(\"a\", \"a\"); registerProhibitedAncestor(\"button\", \"a\"); registerProhibitedAncestor(\"button\", \"button\"); registerProhibitedAncestor(\"button\", \"fieldset\"); registerProhibitedAncestor(\"button\", \"form\"); registerProhibitedAncestor(\"button\", \"iframe\"); registerProhibitedAncestor(\"button\", \"input\"); registerProhibitedAncestor(\"button\", \"isindex\"); registerProhibitedAncestor(\"button\", \"select\"); registerProhibitedAncestor(\"button\", \"textarea\"); registerProhibitedAncestor(\"form\", \"form\"); registerProhibitedAncestor(\"label\", \"label\"); registerProhibitedAncestor(\"pre\", \"pre\"); registerProhibitedAncestor(\"pre\", \"img\"); registerProhibitedAncestor(\"pre\", \"object\"); registerProhibitedAncestor(\"pre\", \"applet\"); registerProhibitedAncestor(\"pre\", \"big\"); registerProhibitedAncestor(\"pre\", \"small\"); registerProhibitedAncestor(\"pre\", \"sub\"); registerProhibitedAncestor(\"pre\", \"sup\"); registerProhibitedAncestor(\"pre\", \"font\"); } private static final int BUTTON_MASK = (1 << specialAncestorNumber(\"button\")); private static final int LABEL_FOR_MASK = (1 << 28); private class IdrefLocator { private final Locator locator; private final String idref;  public IdrefLocator(Locator locator, String idref) { this.locator = new LocatorImpl(locator); this.idref = idref; }  public Locator getLocator() { return locator; }  public String getIdref() { return idref; } } private class StackNode { private final int ancestorMask; private boolean selectedOptions = false; private boolean optionFound = false;  public StackNode(int ancestorMask, String name, String role, String activeDescendant, String forAttr) { this.ancestorMask = ancestorMask; }  public int getAncestorMask() { return ancestorMask; }  public boolean isSelectedOptions() { return selectedOptions; }  public void setSelectedOptions() { this.selectedOptions = true; }  public boolean hasOption() { return optionFound; }  public void setOptionFound() { this.optionFound = true; } } private StackNode[] stack; private int currentPtr; public Html4Assertions() { super(); } private void push(StackNode node) { currentPtr++; if (currentPtr == stack.length) { StackNode[] newStack = new StackNode[stack.length + 64]; System.arraycopy(stack, 0, newStack, 0, stack.length); stack = newStack; } stack[currentPtr] = node; } private StackNode pop() { return stack[currentPtr--]; } private StackNode peek() { return stack[currentPtr]; } private Map<StackNode, Locator> openSingleSelects = new HashMap<StackNode, Locator>(); private LinkedHashSet<IdrefLocator> formControlReferences = new LinkedHashSet<IdrefLocator>(); private Set<String> formControlIds = new HashSet<String>(); private LinkedHashSet<IdrefLocator> listReferences = new LinkedHashSet<IdrefLocator>(); private Set<String> listIds = new HashSet<String>(); private Set<String> allIds = new HashSet<String>();  @Override public void endDocument() throws SAXException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.table; import org.xml.sax.ErrorHandler; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException;  final class Cell implements Locator { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.table; import org.xml.sax.Locator;  final class ColumnRange {  private final Locator locator;  private final String element;  private int left;  private int right;  private ColumnRange next;  public ColumnRange(String element, Locator locator, int left, int right) { super(); assert right > left; this.element = element; this.locator = locator; this.left = left; this.right = right; this.next = null; }  String getElement() { return element; }  Locator getLocator() { return locator; }  int hits(int column) { if (column < left) { return -1; } if (column >= right) { return 1; } else { return 0; } }  ColumnRange removeColumn(int column) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.table; import java.util.Comparator;  final class HorizontalCellComparator implements Comparator<Cell> { public static final HorizontalCellComparator THE_INSTANCE = new HorizontalCellComparator(); private HorizontalCellComparator() { super(); } public final int compare(Cell cell0, Cell cell1) { if (cell0.getLeft() < cell1.getLeft()) { return -1; } else if (cell0.getLeft() > cell1.getLeft()) { return 1; } else { throw new IllegalStateException(\"Two cells in effect cannot start on the same column, so this should never happen!\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.table; import java.util.Arrays; import java.util.Iterator; import java.util.SortedSet; import java.util.TreeSet; import org.xml.sax.SAXException;  final class RowGroup {  private final Cell[] EMPTY_CELL_ARRAY = {};  private int currentRow = -1;  private int insertionPoint = 0;  private int nextOldCell = 0;  private final Table owner;  private final SortedSet<Cell> cellsIfEffect = new TreeSet<Cell>( VerticalCellComparator.THE_INSTANCE);  private Cell[] cellsOnCurrentRow;  private boolean rowHadCells;  private final String type; RowGroup(Table owner, String type) { super(); this.owner = owner; this.type = type; } public void cell(Cell cell) throws SAXException { rowHadCells = true; findInsertionPoint(); cell.setPosition(currentRow, insertionPoint); owner.cell(cell); if (cell.getBottom() > currentRow + 1) { cellsIfEffect.add(cell); } insertionPoint = cell.getRight(); for (int i = nextOldCell; i < cellsOnCurrentRow.length; i++) { cellsOnCurrentRow[i].errOnHorizontalOverlap(cell); } }  private void findInsertionPoint() { for (;;) { if (nextOldCell == cellsOnCurrentRow.length) { break; } Cell other = cellsOnCurrentRow[nextOldCell]; int newInsertionPoint = other.freeSlot(insertionPoint); if (newInsertionPoint == insertionPoint) { break; } nextOldCell++; insertionPoint = newInsertionPoint; } } public void end() throws SAXException { for (Cell cell : cellsIfEffect) { cell.errIfNotRowspanZero(type); } } public void endRow() throws SAXException { if (!rowHadCells) { owner.err(\"Row \" + (currentRow + 1) + \" of \" + (type == null ? \"an implicit row group\" : \"a row group established by a \\u201C\" + type + \"\\u201D element\") + \" has no cells beginning on it.\"); } findInsertionPoint(); cellsOnCurrentRow = null; int columnCount = owner.getColumnCount(); if (owner.isHardWidth()) { if (insertionPoint > columnCount) { owner.err(\"A table row was \" + insertionPoint + \" columns wide and exceeded the column count established using column markup (\" + columnCount + \").\"); } else if (insertionPoint < columnCount) { owner.err(\"A table row was \" + insertionPoint + \" columns wide, which is less than the column count established using column markup (\" + columnCount + \").\"); } } else if (columnCount == -1) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.table; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Set; import org.whattf.checker.AttributeUtil; import org.xml.sax.Attributes; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.LocatorImpl;  final class Table {  private enum State {  IN_TABLE_AT_START,  IN_TABLE_AT_POTENTIAL_ROW_GROUP_START,  IN_COLGROUP,  IN_COL_IN_COLGROUP,  IN_COL_IN_IMPLICIT_GROUP,  IN_ROW_GROUP,  IN_ROW_IN_ROW_GROUP,  IN_CELL_IN_ROW_GROUP,  IN_ROW_IN_IMPLICIT_ROW_GROUP,  IN_IMPLICIT_ROW_GROUP,  IN_CELL_IN_IMPLICIT_ROW_GROUP,  IN_TABLE_COLS_SEEN }  private State state = State.IN_TABLE_AT_START;  private int suppressedStarts = 0;  private boolean hardWidth = false;  private int columnCount = -1;  private int realColumnCount = 0;  private int pendingColGroupSpan = 0;  private final Set<String> headerIds = new HashSet<String>();  private final List<Cell> cellsReferringToHeaders = new LinkedList<Cell>();  private final TableChecker owner;  private RowGroup current;  private ColumnRange first = null;  private ColumnRange last = null;  private ColumnRange currentColRange = null;  private ColumnRange previousColRange = null;  public Table(TableChecker owner) { super(); this.owner = owner; } private boolean needSuppressStart() { if (suppressedStarts > 0) { suppressedStarts++; return true; } else { return false; } } private boolean needSuppressEnd() { if (suppressedStarts > 0) { suppressedStarts--; return true; } else { return false; } } void startRowGroup(String type) throws SAXException { if (needSuppressStart()) { return; } switch (state) { case IN_IMPLICIT_ROW_GROUP: current.end(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.table; import java.util.LinkedList; import org.whattf.checker.AttributeUtil; import org.whattf.checker.Checker; import org.xml.sax.Attributes; import org.xml.sax.SAXException;  public final class TableChecker extends Checker {  public TableChecker() { super(); }  private Table current;  private final LinkedList<Table> stack = new LinkedList<Table>();  private void push() { if (current != null) { stack.addLast(current); } current = new Table(this); }  private void pop() throws SAXException { if (current == null) { throw new IllegalStateException(\"Bug!\"); } current.end(); if (stack.isEmpty()) { current = null; } else { current = stack.removeLast(); } }  public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { if (\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.checker.table; import java.util.Comparator;  final class VerticalCellComparator implements Comparator<Cell> { public static final VerticalCellComparator THE_INSTANCE = new VerticalCellComparator(); private VerticalCellComparator() { super(); } public final int compare(Cell cell0, Cell cell1) { if (cell0.getBottom() < cell1.getBottom()) { return -1; } else if (cell0.getBottom() > cell1.getBottom()) { return 1; } else if (cell0 == cell1) { return 0; } else { if (cell0.getLeft() < cell1.getLeft()) { return -1; } else if (cell0.getLeft() > cell1.getLeft()) { return 1; } else { throw new IllegalStateException( \"Two cells in effect cannot start on the same column, so this should never happen!!\\n\" + \"cell0 from line \" + cell0.getLineNumber() + \", bottom=\" + cell0.getBottom() + \", left=\" + cell0.getLeft() + \"\\n\" + \"cell1 from line \" + cell1.getLineNumber() + \", bottom=\" + cell1.getBottom() + \", left=\" + cell1.getLeft()); } } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; public class ARel extends AbstractRel { private static final String[] REGISTERED_TOKENS = { \"#voverlay\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.ArrayList; import java.util.List; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext;  public abstract class AbstractDatatype implements Datatype {  AbstractDatatype() { super(); }  public final boolean isValid(String literal, ValidationContext context) { try { checkValid(literal); } catch (DatatypeException e) { return false; } return true; }  public void checkValid(String literal, ValidationContext context) throws DatatypeException { checkValid(literal); } public abstract void checkValid(CharSequence literal) throws DatatypeException;  public DatatypeStreamingValidator createStreamingValidator( ValidationContext context) { return new DatatypeStreamingValidatorImpl(this); }  public Object createValue(String literal, ValidationContext context) { return literal; }  public final boolean sameValue(Object value1, Object value2) { if (value1 == null) { return (value2 == null); } return value1.equals(value2); }  public final int valueHashCode(Object value) { return value.hashCode(); }  public final int getIdType() { return Datatype.ID_TYPE_NULL; }  public boolean isContextDependent() { return false; }  protected final boolean isWhitespace(char c) { return c == ' ' || c == '\\t' || c == '\\f' || c == '\\n' || c == '\\r'; } protected final boolean isAsciiDigit(char c) { return c >= '0' && c <= '9'; } protected static final char toAsciiLowerCase(char c) { if (c >= 'A' && c <= 'Z') { c += 0x20; } return c; } protected static final String toAsciiLowerCase(CharSequence str) { if (str == null) { return null; } char[] buf = new char[str.length()]; for (int i = 0; i < str.length(); i++) { char c = str.charAt(i); if (c >= 'A' && c <= 'Z') { c += 0x20; } buf[i] = c; } return new String(buf); } protected static final char toAsciiUpperCase(char c) { if (c >= 'a' && c <= 'z') { c -= 0x20; } return c; } protected static final String toAsciiUpperCase(CharSequence str) { if (str == null) { return null; } char[] buf = new char[str.length()]; for (int i = 0; i < str.length(); i++) { char c = str.charAt(i); if (c >= 'a' && c <= 'z') { c -= 0x20; } buf[i] = c; } return new String(buf); } protected DatatypeException newDatatypeException(String message) { return new Html5DatatypeException(this.getClass(), this.getName(), message); } protected DatatypeException newDatatypeException(String head, String literal, String tail) { return new Html5DatatypeException(this.getClass(), this.getName(), head, literal, tail); } protected DatatypeException newDatatypeException(String head, char literal, String tail) { return new Html5DatatypeException(this.getClass(), this.getName(), head, String.valueOf(literal), tail); } protected DatatypeException newDatatypeException(int position, String message) { return new Html5DatatypeException(position, this.getClass(), this.getName(), message); } protected DatatypeException newDatatypeException(int position, String head, String literal, String tail) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, literal, tail); } protected DatatypeException newDatatypeException(int position, String head, char literal, String tail) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, String.valueOf(literal), tail); }  protected DatatypeException newDatatypeException(String message, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), message, warning); } protected DatatypeException newDatatypeException(String head, String literal, String tail, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), head, literal, tail, warning); } protected DatatypeException newDatatypeException(String head, char literal, String tail, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), head, String.valueOf(literal), tail, warning); } protected DatatypeException newDatatypeException(int position, String message, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), message, warning); } protected DatatypeException newDatatypeException(int position, String head, String literal, String tail, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, literal, tail, warning); } protected DatatypeException newDatatypeException(int position, String head, char literal, String tail, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, String.valueOf(literal), tail, warning); } public abstract String getName(); protected List<CharSequenceWithOffset> split(CharSequence sequence, char delimiter) { List<CharSequenceWithOffset> rv = new ArrayList<CharSequenceWithOffset>(); int offset = 0; for (int i = 0; i < sequence.length(); i++) { char c = sequence.charAt(i); if (c == delimiter) { rv.add(new CharSequenceWithOffset(sequence.subSequence(offset, i), offset)); offset = i + 1; } } rv.add(new CharSequenceWithOffset(sequence.subSequence(offset, sequence.length()), offset)); return rv; } protected class CharSequenceWithOffset { private final CharSequence sequence; private final int offset;  public CharSequenceWithOffset(final CharSequence sequence, final int offset) { this.sequence = sequence; this.offset = offset; }  public int getOffset() { return offset; }  public CharSequence getSequence() { return sequence; } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  abstract class AbstractDatetime extends AbstractDatatype {  private static int[] DAYS_IN_MONTHS = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };  AbstractDatetime() { super(); } private void checkMonth(String year, String month) throws DatatypeException { checkMonth(Integer.parseInt(year), Integer.parseInt(month)); } private void checkMonth(int year, int month) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } } private void checkDate(String year, String month, String day) throws DatatypeException { checkDate(Integer.parseInt(year), Integer.parseInt(month), Integer.parseInt(day)); } private void checkDate(int year, int month, int day) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } if (day < 1) { throw newDatatypeException(\"Day cannot be less than 1.\"); } if (day > DAYS_IN_MONTHS[month - 1]) { if (!(day == 29 && month == 2 && isLeapYear(year))) { throw newDatatypeException(\"Day out of range.\"); } } } private boolean isLeapYear(int year) { return (year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)); } private void checkYearlessDate(String month, String day) throws DatatypeException { checkYearlessDate(Integer.parseInt(month), Integer.parseInt(day)); } private void checkYearlessDate(int month, int day) throws DatatypeException { if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } if (day < 1) { throw newDatatypeException(\"Day cannot be less than 1.\"); } } private void checkWeek(String year, String week) throws DatatypeException { checkWeek(Integer.parseInt(year), Integer.parseInt(week)); } private void checkWeek(int year, int week) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (week< 1) { throw newDatatypeException(\"Week cannot be less than 1.\"); } if (week > 53) { throw newDatatypeException(\"Week cannot be greater than 53.\"); } } protected final void checkHour(String hour) throws DatatypeException { checkHour(Integer.parseInt(hour)); } private void checkHour(int hour) throws DatatypeException { if (hour > 23) { throw newDatatypeException(\"Hour cannot be greater than 23.\"); } } protected final void checkMinute(String minute) throws DatatypeException { checkMinute(Integer.parseInt(minute)); } private void checkMinute(int minute) throws DatatypeException { if (minute > 59) { throw newDatatypeException(\"Minute cannot be greater than 59.\"); } } protected final void checkSecond(String second) throws DatatypeException { checkSecond(Integer.parseInt(second)); } private void checkSecond(int second) throws DatatypeException { if (second > 59) { throw newDatatypeException(\"Second cannot be greater than 59.\"); } } protected final void checkMilliSecond(String millisecond) throws DatatypeException { if (millisecond.length() > 3) { throw newDatatypeException(\"A fraction of a second must be one, two, or three digits.\"); } } private void checkTzd(String hours, String minutes) throws DatatypeException { if (hours.charAt(0) == '+') { hours = hours.substring(1); } checkTzd(Integer.parseInt(hours), Integer.parseInt(minutes)); } private void checkTzd(int hours, int minutes) throws DatatypeException { if (hours < -23 || hours > 23) { throw newDatatypeException(\"Hours out of range in time zone designator.\"); } if (minutes > 59) { throw newDatatypeException(\"Minutes out of range in time zone designator.\"); } } protected abstract Pattern getPattern(); public void checkValid(CharSequence literal) throws DatatypeException { String year; String month; String day; String hour; String minute; String seconds; String milliseconds; String tzdHours; String tzdMinutes; Matcher m = getPattern().matcher(literal); if (m.matches()) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public abstract class AbstractInt extends AbstractDatatype {  protected AbstractInt() { super(); }  protected void checkInt(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid integer.\"); } char c = literal.charAt(0); if (!(c == '-' || isAsciiDigit(c))) { throw newDatatypeException(0, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } for (int i = 1; i < literal.length(); i++) { c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } } }  protected void checkIntNonNegative(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid non-negative integer.\"); } for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } } }  protected void checkIntPositive(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid positive integer.\"); } boolean zero = true; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } if (c != '0') { zero = false; } } if (zero) { throw newDatatypeException(\"Zero is not a positive integer.\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.HashSet; import java.util.Set; import org.relaxng.datatype.DatatypeException; abstract class AbstractRel extends AbstractDatatype { @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext; import com.ibm.icu.lang.UCharacter; import com.ibm.icu.text.UnicodeSet; public abstract class AbstractUnicodeClassCharacter extends AbstractDatatype { private static final int SURROGATE_OFFSET = 0x10000 - (0xD800 << 10) - 0xDC00; protected abstract UnicodeSet getUnicodeSet(); @Override public void checkValid(CharSequence literal) throws DatatypeException { switch (literal.length()) { case 0: throw newDatatypeException(\"The empty string is not a \" + getName() + \".\"); case 1: char c = literal.charAt(0); if (!getUnicodeSet().contains(c)) { throw newDatatypeException(0, \"The character \", c, \" is not a \" + getName() + \".\"); } return; case 2: char hi = literal.charAt(0); char lo = literal.charAt(1); if ((lo & 0xFC00) == 0xDC00 && (hi & 0xFC00) == 0xD800) { int codepoint = (hi << 10) + lo + SURROGATE_OFFSET; if (!getUnicodeSet().contains(codepoint)) { throw newDatatypeException(0, \"The character \", \"\" + hi + lo, \" is not a \" + getName() + \".\"); } return; } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; public class AsciiCaseInsensitiveString extends AbstractDatatype {  public static final AsciiCaseInsensitiveString THE_INSTANCE = new AsciiCaseInsensitiveString();  protected AsciiCaseInsensitiveString() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { }  @Override public Object createValue(String literal, ValidationContext context) { return toAsciiLowerCase(literal); } @Override public String getName() { return \"ASCII-case-insensitive string\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class BrowsingContext extends AbstractDatatype {  public static final BrowsingContext THE_INSTANCE = new BrowsingContext();  private BrowsingContext() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Browsing context name must be at least one character long.\"); } if (literal.charAt(0) == '_') { throw newDatatypeException(\"Browsing context name started with the underscore.\"); } else { return; } } @Override public String getName() { return \"browsing context name\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class BrowsingContextOrKeyword extends AbstractDatatype {  public static final BrowsingContextOrKeyword THE_INSTANCE = new BrowsingContextOrKeyword();  private BrowsingContextOrKeyword() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Browsing context name must be at least one character long.\"); } if (literal.charAt(0) == '_') { String kw = toAsciiLowerCase(literal.toString().substring(1)); if (!(\"blank\".equals(kw) || \"self\".equals(kw) || \"top\".equals(kw) || \"parent\".equals(kw))) { throw newDatatypeException(\"Reserved keyword \", kw, \" used.\"); } } else { return; } } @Override public String getName() { return \"browsing context name or keyword\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class CdoCdcPair extends AbstractDatatype { private enum State { DATA, LESS_THAN_SIGN, LESS_THAN_SIGN_BANG, LESS_THAN_SIGN_BANG_HYPHEN, HAS_CDO, HAS_CDO_AND_HYPHEN, HAS_CDO_AND_DOUBLE_HYPHEN }  public static final CdoCdcPair THE_INSTANCE = new CdoCdcPair(); protected CdoCdcPair() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.DATA; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case DATA: if ('<' == c) { state = State.LESS_THAN_SIGN; continue; } continue; case LESS_THAN_SIGN: if ('!' == c) { state = State.LESS_THAN_SIGN_BANG; continue; } state = State.DATA; continue; case LESS_THAN_SIGN_BANG: if ('-' == c) { state = State.LESS_THAN_SIGN_BANG_HYPHEN; continue; } state = State.DATA; continue; case LESS_THAN_SIGN_BANG_HYPHEN: if ('-' == c) { state = State.HAS_CDO; continue; } state = State.DATA; continue; case HAS_CDO: if ('-' == c) { state = State.HAS_CDO_AND_HYPHEN; continue; } continue; case HAS_CDO_AND_HYPHEN: if ('-' == c) { state = State.HAS_CDO_AND_DOUBLE_HYPHEN; continue; } state = State.HAS_CDO; continue; case HAS_CDO_AND_DOUBLE_HYPHEN: if ('>' == c) { state = State.DATA; continue; } else if ('-' == c) { continue; } state = State.HAS_CDO; continue; default: assert false : state; } } if (state == State.HAS_CDO) { throw newDatatypeException(\"Content contains the character sequence \\u201c<!--\\u201d without\" + \" a later occurrence of the character sequence \\u201c-->\\u201d.\"); } } @Override public String getName() { return \"text content with CDO-CDC pair\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.whattf.datatype.data.CharsetData; import org.relaxng.datatype.DatatypeException; public class Charset extends AbstractDatatype {  public static final Charset THE_INSTANCE = new Charset(); public Charset() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid character encoding name.\"); } for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class CharsetList extends AbstractDatatype {  public static final CharsetList THE_INSTANCE = new CharsetList(); private enum State { WS_BEFORE_TOKEN } private CharsetList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.WS_BEFORE_TOKEN; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { } } switch (state) { } } private boolean isTokenChar(char c) { return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '+' || c == '-' || c == '^' || c == '_' || c == '`' || c == '{' || c == '}' || c == '~'; } @Override public String getName() { return \"character encoding list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Circle extends AbstractInt {  public static final Circle THE_INSTANCE = new Circle();  private Circle() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() != 3) { throw newDatatypeException(\"A circle must have three comma-separated integers.\"); } CharSequenceWithOffset withOffset = list.get(0); checkInt(withOffset.getSequence(), withOffset.getOffset()); withOffset = list.get(1); checkInt(withOffset.getSequence(), withOffset.getOffset()); withOffset = list.get(2); checkIntNonNegative(withOffset.getSequence(), withOffset.getOffset()); } @Override public String getName() { return \"circle\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; public final class DatatypeStreamingValidatorImpl implements DatatypeStreamingValidator { private final AbstractDatatype datatype; private final StringBuilder buffer; public DatatypeStreamingValidatorImpl(AbstractDatatype datatype) { super(); this.datatype = datatype; this.buffer = new StringBuilder(); } public void addCharacters(char[] buf, int start, int len) { buffer.append(buf, start, len); } public boolean isValid() { try { datatype.checkValid(buffer); } catch (DatatypeException e) { return false; } return true; } public void checkValid() throws DatatypeException { datatype.checkValid(buffer); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; public class DateOrTime extends AbstractDatetime {  public static final DateOrTime THE_INSTANCE = new DateOrTime();  private static final Pattern THE_PATTERN = Pattern.compile(\"^(?:(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:[T ]([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?(?:Z|(?:([+-][0-9]{2}):([0-9]{2})))?)?)|(?:([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?(?:Z|(?:([+-][0-9]{2}):([0-9]{2})))?))$\"); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class EmailAddress extends AbstractDatatype {  public static final EmailAddress THE_INSTANCE = new EmailAddress();  public EmailAddress() { super(); }  @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class EmailAddressList extends AbstractDatatype {  public static final EmailAddressList THE_INSTANCE = new EmailAddressList();  public EmailAddressList() { super(); }  @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponent extends AbstractDatatype {  public static final FloatingPointExponent THE_INSTANCE = new FloatingPointExponent(); private enum State { AT_START, AT_START_MINUS_SEEN, IN_INTEGER_PART_DIGITS_SEEN, DOT_SEEN, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponent() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { state = State.AT_START_MINUS_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } case AT_START_MINUS_SEEN: if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_EXPONENT_DIGITS_SEEN: return; case AT_START: throw newDatatypeException(\"The empty string is not a valid floating point number.\"); case AT_START_MINUS_SEEN: throw newDatatypeException(\"The minus sign alone is not a valid floating point number.\"); case DOT_SEEN: throw newDatatypeException(\"A floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponentNonNegative extends AbstractDatatype {  public static final FloatingPointExponentNonNegative THE_INSTANCE = new FloatingPointExponentNonNegative(); private enum State { AT_START, AT_START_MINUS_SEEN, IN_INTEGER_PART_DIGITS_SEEN, IN_INTEGER_PART_DIGITS_SEEN_ZERO, DOT_SEEN, DOT_SEEN_ZERO, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_DECIMAL_PART_DIGITS_SEEN_ZERO, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponentNonNegative() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { state = State.AT_START_MINUS_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } case AT_START_MINUS_SEEN: if (c == '0') { state = State.IN_INTEGER_PART_DIGITS_SEEN_ZERO; continue; } else { throw newDatatypeException(i, \"Expected a zero but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN_ZERO: if (c == '.') { state = State.DOT_SEEN_ZERO; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (c == '0') { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a zero but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case DOT_SEEN_ZERO: if (c == '0') { state = State.IN_DECIMAL_PART_DIGITS_SEEN_ZERO; continue; } else { throw newDatatypeException(i, \"Expected a zero after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN_ZERO: if (c == '0') { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a zero but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_INTEGER_PART_DIGITS_SEEN_ZERO: case IN_DECIMAL_PART_DIGITS_SEEN_ZERO: case IN_EXPONENT_DIGITS_SEEN: return; case AT_START: throw newDatatypeException(\"The empty string is not a valid non-negative floating point number.\"); case AT_START_MINUS_SEEN: throw newDatatypeException(\"The minus sign alone is not a valid non-negative floating point number.\"); case DOT_SEEN: case DOT_SEEN_ZERO: throw newDatatypeException(\"A non-negative floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A non-negative floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A non-negative floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"non-negative floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponentPositive extends AbstractDatatype {  public static final FloatingPointExponentPositive THE_INSTANCE = new FloatingPointExponentPositive(); private enum State { AT_START, IN_INTEGER_PART_DIGITS_SEEN, DOT_SEEN, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponentPositive() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; boolean zero = true; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { throw newDatatypeException(i, \"A positive floating point number cannot start with the minus sign.\"); } else if (isAsciiDigit(c)) { if (c != '0') { zero = false; } state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { if (c != '0') { zero = false; } continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { if (c != '0') { zero = false; } state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { if (c != '0') { zero = false; } continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_EXPONENT_DIGITS_SEEN: if (zero) { throw newDatatypeException(\"Zero is not a valid positive floating point number.\"); } return; case AT_START: throw newDatatypeException(\"The empty string is not a valid positive floating point number.\"); case DOT_SEEN: throw newDatatypeException(\"A positive floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A positive floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A positive floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"positive floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.BufferedReader; import java.io.IOException; import java.io.Reader; import java.io.StringReader; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.RhinoException; import org.relaxng.datatype.DatatypeException; public class FunctionBody extends AbstractDatatype {  public static final FunctionBody THE_INSTANCE = new FunctionBody(); protected FunctionBody() { super(); } public void checkValid(CharSequence literal) throws DatatypeException { try { Reader reader = new BufferedReader((new StringReader( \"function(event){\" + literal.toString() + \"}\"))); reader.mark(1); try { Context context = ContextFactory.getGlobal().enterContext(); context.setOptimizationLevel(0); context.setLanguageVersion(Context.VERSION_1_6); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class HashName extends AbstractDatatype {  public static final HashName THE_INSTANCE = new HashName();  private HashName() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid hash-name reference.\"); } else if (literal.charAt(0) != '#') { throw newDatatypeException(\"A hash-name reference must start with \\u201C#\\u201D.\"); } else if (literal.length() == 1) { throw newDatatypeException(\"A hash-name reference must have at least one character after \\u201C#\\u201D.\"); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class Html5DatatypeException extends DatatypeException { private Class datatypeClass; private String[] segments;  final boolean warning; public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String message) { super(index, \"Bad \" + datatypeName + \": \" + message); this.datatypeClass = datatypeClass; this.segments = new String[1]; this.segments[0] = message; this.warning = false; } public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String head, String literal, String tail) { super(index, \"Bad \" + datatypeName + \": \" + head + '\\u201C' + literal + '\\u201D' + tail); this.datatypeClass = datatypeClass; this.segments = new String[3]; this.segments[0] = head; this.segments[1] = literal; this.segments[2] = tail; this.warning = false; } public Html5DatatypeException(Class datatypeClass, String datatypeName, String message) { this(-1, datatypeClass, datatypeName, message); } public Html5DatatypeException(Class datatypeClass, String datatypeName, String head, String literal, String tail) { this(-1, datatypeClass, datatypeName, head, literal, tail); }  public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String message, boolean warning) { super(index, \"Bad \" + datatypeName + \": \" + message); this.datatypeClass = datatypeClass; this.segments = new String[1]; this.segments[0] = message; this.warning = warning; } public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String head, String literal, String tail, boolean warning) { super(index, \"Bad \" + datatypeName + \": \" + head + '\\u201C' + literal + '\\u201D' + tail); this.datatypeClass = datatypeClass; this.segments = new String[3]; this.segments[0] = head; this.segments[1] = literal; this.segments[2] = tail; this.warning = warning; } public Html5DatatypeException(Class datatypeClass, String datatypeName, String message, boolean warning) { this(-1, datatypeClass, datatypeName, message, warning); } public Html5DatatypeException(Class datatypeClass, String datatypeName, String head, String literal, String tail, boolean warning) { this(-1, datatypeClass, datatypeName, head, literal, tail, warning); }  public Class getDatatypeClass() { return datatypeClass; }  public String[] getSegments() { return segments; }  public boolean isWarning() { return warning; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.helpers.ParameterlessDatatypeBuilder;  public class Html5DatatypeLibrary implements DatatypeLibrary { public Html5DatatypeLibrary() { super(); }  public DatatypeBuilder createDatatypeBuilder(String baseTypeLocalName) throws DatatypeException { return new ParameterlessDatatypeBuilder(createDatatype(baseTypeLocalName)); }  public Datatype createDatatype(String typeLocalName) throws DatatypeException { if (\"ID\".equals(typeLocalName)) { return new Id(); } else if (\"IDREF\".equals(typeLocalName)) { return Idref.THE_INSTANCE; } else if (\"IDREFS\".equals(typeLocalName)) { return Idrefs.THE_INSTANCE; } else if (\"pattern\".equals(typeLocalName)) { return Pattern.THE_INSTANCE; } else if (\"datetime\".equals(typeLocalName)) { return Datetime.THE_INSTANCE; } else if (\"datetime-local\".equals(typeLocalName)) { return DatetimeLocal.THE_INSTANCE; } else if (\"datetime-tz\".equals(typeLocalName)) { return DatetimeTz.THE_INSTANCE; } else if (\"date-or-time\".equals(typeLocalName)) { return DateOrTime.THE_INSTANCE; } else if (\"date\".equals(typeLocalName)) { return Date.THE_INSTANCE; } else if (\"month\".equals(typeLocalName)) { return Month.THE_INSTANCE; } else if (\"week\".equals(typeLocalName)) { return Week.THE_INSTANCE; } else if (\"time\".equals(typeLocalName)) { return Time.THE_INSTANCE; } else if (\"iri\".equals(typeLocalName)) { return Iri.THE_INSTANCE; } else if (\"iri-ref\".equals(typeLocalName)) { return IriRef.THE_INSTANCE; } else if (\"string\".equals(typeLocalName)) { return AsciiCaseInsensitiveString.THE_INSTANCE; } else if (\"language\".equals(typeLocalName)) { return Language.THE_INSTANCE; } else if (\"media-query\".equals(typeLocalName)) { return MediaQuery.THE_INSTANCE; } else if (\"mime-type\".equals(typeLocalName)) { return MimeType.THE_INSTANCE; } else if (\"browsing-context\".equals(typeLocalName)) { return BrowsingContext.THE_INSTANCE; } else if (\"browsing-context-or-keyword\".equals(typeLocalName)) { return BrowsingContextOrKeyword.THE_INSTANCE; } else if (\"hash-name\".equals(typeLocalName)) { return HashName.THE_INSTANCE; } else if (\"integer\".equals(typeLocalName)) { return Int.THE_INSTANCE; } else if (\"integer-non-negative\".equals(typeLocalName)) { return IntNonNegative.THE_INSTANCE; } else if (\"integer-positive\".equals(typeLocalName)) { return IntPositive.THE_INSTANCE; } else if (\"float\".equals(typeLocalName)) { return FloatingPointExponent.THE_INSTANCE; } else if (\"float-non-negative\".equals(typeLocalName)) { return FloatingPointExponentNonNegative.THE_INSTANCE; } else if (\"float-positive\".equals(typeLocalName)) { return FloatingPointExponentPositive.THE_INSTANCE; } else if (\"mime-type-list\".equals(typeLocalName)) { return MimeTypeList.THE_INSTANCE; } else if (\"circle\".equals(typeLocalName)) { return Circle.THE_INSTANCE; } else if (\"rectangle\".equals(typeLocalName)) { return Rectangle.THE_INSTANCE; } else if (\"polyline\".equals(typeLocalName)) { return Polyline.THE_INSTANCE; } else if (\"xml-name\".equals(typeLocalName)) { return XmlName.THE_INSTANCE; } else if (\"meta-charset\".equals(typeLocalName)) { return MetaCharset.THE_INSTANCE; } else if (\"microdata-property\".equals(typeLocalName)) { return MicrodataProperty.THE_INSTANCE; } else if (\"charset\".equals(typeLocalName)) { return Charset.THE_INSTANCE; } else if (\"refresh\".equals(typeLocalName)) { return Refresh.THE_INSTANCE; } else if (\"paren-start\".equals(typeLocalName)) { return ParenthesisStart.THE_INSTANCE; } else if (\"paren-end\".equals(typeLocalName)) { return ParenthesisEnd.THE_INSTANCE; } else if (\"email-address\".equals(typeLocalName)) { return EmailAddress.THE_INSTANCE; } else if (\"email-address-list\".equals(typeLocalName)) { return EmailAddressList.THE_INSTANCE; } else if (\"keylabellist\".equals(typeLocalName)) { return KeyLabelList.THE_INSTANCE; } else if (\"zero\".equals(typeLocalName)) { return Zero.THE_INSTANCE; } else if (\"cdo-cdc-pair\".equals(typeLocalName)) { return CdoCdcPair.THE_INSTANCE; } else if (\"script\".equals(typeLocalName)) { return Script.THE_INSTANCE; } else if (\"script-documentation\".equals(typeLocalName)) { return ScriptDocumentation.THE_INSTANCE; } else if (\"functionbody\".equals(typeLocalName)) { return FunctionBody.THE_INSTANCE; } else if (\"a-rel\".equals(typeLocalName)) { return ARel.THE_INSTANCE; } else if (\"link-rel\".equals(typeLocalName)) { return LinkRel.THE_INSTANCE; } else if (\"meta-name\".equals(typeLocalName)) { return MetaName.THE_INSTANCE; } else if (\"non-empty-string\".equals(typeLocalName)) { return NonEmptyString.THE_INSTANCE; } else if (\"string-without-line-breaks\".equals(typeLocalName)) { return StringWithoutLineBreaks.THE_INSTANCE; } else if (\"simple-color\".equals(typeLocalName)) { return SimpleColor.THE_INSTANCE; } else if (\"time-datetime\".equals(typeLocalName)) { return TimeDatetime.THE_INSTANCE; } else if (\"svg-pathdata\".equals(typeLocalName)) { return new SvgPathData(); } throw new DatatypeException(\"Unknown local name for datatype: \" + typeLocalName); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory;  public class Html5DatatypeLibraryFactory implements DatatypeLibraryFactory {  private static final String NAMESPACE = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class Id extends AbstractDatatype {  public static final Id THE_INSTANCE = new Id();  protected Id() { super(); }  public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); if (len == 0) { throw newDatatypeException(\"An ID must not be the empty string.\"); } for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (isWhitespace(c)) { throw newDatatypeException(i, \"An ID must not contain whitespace.\"); } } } @Override public String getName() { return \"id\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype;  public final class Idref extends Id {  public static final Idref THE_INSTANCE = new Idref();  private Idref() { super(); } @Override public String getName() { return \"id reference\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public final class Idrefs extends AbstractDatatype {  public static final Idrefs THE_INSTANCE = new Idrefs();  private Idrefs() { super(); }  public void checkValid(CharSequence literal) throws DatatypeException { for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isWhitespace(c)) { return; } } throw newDatatypeException(\"An IDREFS value must contain at least one non-whitespace character.\"); } @Override public String getName() { return \"id references\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Int extends AbstractInt {  public static final Int THE_INSTANCE = new Int();  private Int() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkInt(literal, 0); } @Override public String getName() { return \"integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class IntNonNegative extends AbstractInt {  public static final IntNonNegative THE_INSTANCE = new IntNonNegative();  private IntNonNegative() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkIntNonNegative(literal, 0); } @Override public String getName() { return \"non-negative integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class IntPositive extends AbstractInt {  public static final IntPositive THE_INSTANCE = new IntPositive();  private IntPositive() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkIntPositive(literal, 0); } @Override public String getName() { return \"positive integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; public class Iri extends IriRef {  public static final Iri THE_INSTANCE = new Iri(); protected Iri() { super(); } protected boolean isAbsolute() { return true; } @Override public String getName() { return \"absolute IRI\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.io.StringReader; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.RhinoException; import org.relaxng.datatype.DatatypeException; import org.whattf.io.DataUri; import org.whattf.io.DataUriException; import org.whattf.io.Utf8PercentDecodingReader; import com.hp.hpl.jena.iri.IRI; import com.hp.hpl.jena.iri.IRIException; import com.hp.hpl.jena.iri.IRIFactory; import com.hp.hpl.jena.iri.Violation; public class IriRef extends AbstractDatatype {  public static final IriRef THE_INSTANCE = new IriRef(); protected IriRef() { super(); } private final static boolean WARN = System.getProperty(\"org.whattf.datatype.warn\",\"\").equals(\"true\") ? true : false;  private enum KnownViolationCode { COMPATIBILITY_CHARACTER, CONTROL_CHARACTER, DNS_LABEL_DASH_START_OR_END, DOUBLE_WHITESPACE, EMPTY_SCHEME, HAS_PASSWORD, ILLEGAL_CHARACTER, ILLEGAL_PERCENT_ENCODING, IP_V4_HAS_FOUR_COMPONENTS, IP_V4_OCTET_RANGE, IP_V6_OR_FUTURE_ADDRESS_SYNTAX, NON_INITIAL_DOT_SEGMENT, NOT_DNS_NAME, PORT_SHOULD_NOT_BE_WELL_KNOWN, REQUIRED_COMPONENT_MISSING, SCHEME_MUST_START_WITH_LETTER, UNDEFINED_UNICODE_CHARACTER, UNICODE_WHITESPACE, UNREGISTERED_NONIETF_SCHEME_TREE, WHITESPACE, ZZZ_DUMMY_DEFAULT } private final CharSequencePair splitScheme(CharSequence iri) { StringBuilder sb = new StringBuilder(); Boolean atSchemeBeginning = true; for (int i = 0; i < iri.length(); i++) { char c = toAsciiLowerCase(iri.charAt(i)); if (atSchemeBeginning) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import java.util.Arrays; import com.ibm.icu.lang.UCharacter; public class KeyLabelList extends AbstractDatatype {  public static final KeyLabelList THE_INSTANCE = new KeyLabelList(); private KeyLabelList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { String[] keylabels = literal.toString().split(\"\\\\s+\"); Arrays.sort(keylabels); for (int i = 0; i < keylabels.length; i++) { String label = keylabels[i]; if (i > 0 && label.equals(keylabels[i-1])) { throw newDatatypeException( \"Duplicate key label. Each key label must be unique.\"); } if (label.length() == 2) { char[] chars = label.toCharArray(); if (!(UCharacter.isHighSurrogate(chars[0]) && UCharacter.isLowSurrogate(chars[1]))) { throw newDatatypeException( \"Key label has multiple characters. Each key label must be a single character.\"); } } if (label.length() > 2) { throw newDatatypeException( \"Key label has multiple characters. Each key label must be a single character.\"); } } } @Override public String getName() { return \"key label list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException; import org.whattf.datatype.data.LanguageData;  public final class Language extends AbstractDatatype {  public static final Language THE_INSTANCE = new Language(); private static final Pattern HYPHEN = Pattern.compile(\"-\"); private static final boolean WARN = System.getProperty( \"org.whattf.datatype.warn\", \"\").equals(\"true\") ? true : false; private static String[] languages = null; private static String[] extlangs = null; private static String[] scripts = null; private static String[] regions = null; private static String[] variants = null; private static String[] grandfathered = null; private static String[] redundant = null; private static String[] deprecated = null; private static String[] deprecatedLang = null; private static int[] suppressedScriptByLanguage = null; private static Map<String, String> preferredValueByLanguageMap = new HashMap<String, String>(); private static String[][][] prefixesByVariant = null; private static int[] prefixByExtlang = null; static { try { LanguageData data = new LanguageData(); languages = data.getLanguages(); extlangs = data.getExtlangs(); scripts = data.getScripts(); regions = data.getRegions(); variants = data.getVariants(); grandfathered = data.getGrandfathered(); redundant = data.getRedundant(); deprecated = data.getDeprecated(); deprecatedLang = data.getDeprecatedLang(); suppressedScriptByLanguage = data.getSuppressedScriptByLanguage(); prefixByExtlang = data.getPrefixByExtlang(); preferredValueByLanguageMap = data.getPreferredValueByLanguageMap(); prefixesByVariant = data.getPrefixesByVariant(); } catch (IOException e) { throw new RuntimeException(e); } }  private Language() { super(); } public void checkValid(CharSequence lit) throws DatatypeException { String literal = lit.toString(); if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid language tag.\"); } literal = toAsciiLowerCase(literal); if (isGrandfathered(literal)) { if (isDeprecated(literal) && WARN) { throw newDatatypeException(\"The grandfathered language tag \", literal, \" is deprecated.\" + \" Use \\u201C\" + preferredValueByLanguageMap.get(literal) + \"\\u201D instead.\", WARN); } return; } if (isRedundant(literal)) { if (isDeprecated(literal) && WARN) { throw newDatatypeException(\"The language tag \", lit.toString(), \" is deprecated.\" + \" Use \\u201C\" + preferredValueByLanguageMap.get(literal) + \"\\u201D instead.\", WARN); } return; } if (literal.startsWith(\"-\")) { throw newDatatypeException(\"Language tag must not start with HYPHEN-MINUS.\"); } if (literal.endsWith(\"-\")) { throw newDatatypeException(\"Language tag must not end with HYPHEN-MINUS.\"); } String[] subtags = HYPHEN.split(literal); for (int j = 0; j < subtags.length; j++) { int len = subtags[j].length(); if (len == 0) { throw newDatatypeException(\"Zero-length subtag.\"); } else if (len > 8) { throw newDatatypeException(\"Subtags must not exceed 8 characters in length.\"); } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; public class LinkRel extends AbstractRel { private static final String[] REGISTERED_TOKENS = { \"alternate\", \"appendix\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.Set; import org.relaxng.datatype.DatatypeException; public class MediaQuery extends AbstractDatatype {  public static final MediaQuery THE_INSTANCE = new MediaQuery(); private static final boolean WARN = System.getProperty( \"org.whattf.datatype.warn\", \"\").equals(\"true\") ? true : false; private enum State { INITIAL_WS, OPEN_PAREN_SEEN, IN_ONLY_OR_NOT, IN_MEDIA_TYPE, IN_MEDIA_FEATURE, WS_BEFORE_MEDIA_TYPE, WS_BEFORE_AND, IN_AND, WS_BEFORE_EXPRESSION, WS_BEFORE_COLON, WS_BEFORE_VALUE, IN_VALUE_DIGITS, IN_VALUE_SCAN, IN_VALUE_ORIENTATION, WS_BEFORE_CLOSE_PAREN, IN_VALUE_UNIT, IN_VALUE_DIGITS_AFTER_DOT, RATIO_SECOND_INTEGER_START, IN_VALUE_BEFORE_DIGITS, IN_VALUE_DIGITS_AFTER_DOT_TRAIL, AFTER_CLOSE_PAREN, IN_VALUE_ONEORZERO } private enum ValueType { LENGTH, RATIO, INTEGER, RESOLUTION, SCAN, ORIENTATION, NONZEROINTEGER, ONEORZERO } private static final Set<String> LENGTH_UNITS = new HashSet<String>(); static { LENGTH_UNITS.add(\"em\"); LENGTH_UNITS.add(\"ex\"); LENGTH_UNITS.add(\"px\"); LENGTH_UNITS.add(\"gd\"); LENGTH_UNITS.add(\"rem\"); LENGTH_UNITS.add(\"vw\"); LENGTH_UNITS.add(\"vh\"); LENGTH_UNITS.add(\"vm\"); LENGTH_UNITS.add(\"ch\"); LENGTH_UNITS.add(\"in\"); LENGTH_UNITS.add(\"cm\"); LENGTH_UNITS.add(\"mm\"); LENGTH_UNITS.add(\"pt\"); LENGTH_UNITS.add(\"pc\"); } private static final Set<String> MEDIA_TYPES = new HashSet<String>(); static { MEDIA_TYPES.add(\"all\"); MEDIA_TYPES.add(\"aural\"); MEDIA_TYPES.add(\"braille\"); MEDIA_TYPES.add(\"handheld\"); MEDIA_TYPES.add(\"print\"); MEDIA_TYPES.add(\"projection\"); MEDIA_TYPES.add(\"screen\"); MEDIA_TYPES.add(\"tty\"); MEDIA_TYPES.add(\"tv\"); MEDIA_TYPES.add(\"embossed\"); MEDIA_TYPES.add(\"speech\"); } private enum MediaType { ALL, AURAL, BRAILLE, HANDHELD, PRINT, PROJECTION, SCREEN, TTY, TV, EMBOSSED, SPEECH, INVALID; private static MediaType toCaps(String str) { try { return valueOf(toAsciiUpperCase(str)); } catch (Exception ex) { return INVALID; } } } private static final Map<String, ValueType> FEATURES_TO_VALUE_TYPES = new HashMap<String, ValueType>(); static { FEATURES_TO_VALUE_TYPES.put(\"width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"min-device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"max-device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"min-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"max-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"min-resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"max-resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"scan\", ValueType.SCAN); FEATURES_TO_VALUE_TYPES.put(\"orientation\", ValueType.ORIENTATION); FEATURES_TO_VALUE_TYPES.put(\"grid\", ValueType.ONEORZERO); } private static final String[] visualFeatures = { \"aspect-ratio\", \"color\", \"color-index\", \"device-aspect-ratio\", \"max-aspect-ratio\", \"max-color\", \"max-color-index\", \"max-device-aspect-ratio\", \"max-monochrome\", \"max-resolution\", \"min-aspect-ratio\", \"min-color\", \"min-color-index\", \"min-device-aspect-ratio\", \"min-monochrome\", \"min-resolution\", \"monochrome\", \"orientation\", \"resolution\", }; private static final String[] bitmapFeatures = { \"aspect-ratio\", \"device-aspect-ratio\", \"max-aspect-ratio\", \"max-device-aspect-ratio\", \"max-resolution\", \"min-aspect-ratio\", \"min-device-aspect-ratio\", \"min-resolution\", \"orientation\", \"resolution\", }; private static final String scanWarning = \"The media feature \\u201cscan\\u201d is applicable only to the media type \\u201ctv\\u201d. \"; private MediaQuery() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<String> warnings = new ArrayList<String>(); List<CharSequenceWithOffset> queries = split(literal, ','); for (CharSequenceWithOffset query : queries) { warnings = checkQuery(query.getSequence(), query.getOffset(), warnings); } if (!warnings.isEmpty() && WARN) { StringBuilder sb = new StringBuilder(); for (String s : warnings) { sb.append(s + \" \"); } throw newDatatypeException(sb.toString().trim(), WARN); } } private List<String> checkQuery(CharSequence query, int offset, List<String> warnings) throws DatatypeException { boolean containsAural = false; boolean zero = true; String type = null; String feature = null; ValueType valueExpectation = null; query = toAsciiLowerCase(query); StringBuilder sb = new StringBuilder(); State state = State.INITIAL_WS; for (int i = 0; i < query.length(); i++) { char c = query.charAt(i); switch (state) { case INITIAL_WS: if (isWhitespace(c)) { continue; } else if ('(' == c) { state = State.OPEN_PAREN_SEEN; continue; } else if ('o' == c || 'n' == c) { sb.append(c); state = State.IN_ONLY_OR_NOT; continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_TYPE; continue; } else { throw newDatatypeException( offset + i, \"Expected \\u201C(\\u201D or letter at start of a media query part but saw \", c, \" instead.\"); } case IN_ONLY_OR_NOT: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c)) { String kw = sb.toString(); sb.setLength(0); if (\"only\".equals(kw) || \"not\".equals(kw)) { state = State.WS_BEFORE_MEDIA_TYPE; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201Conly\\u201D or \\u201Cnot\\u201D but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_MEDIA_TYPE: if (isWhitespace(c)) { continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_TYPE; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_MEDIA_TYPE: if (('a' <= c && 'z' >= c) || c == '-') { sb.append(c); continue; } else if (isWhitespace(c)) {  type = sb.toString(); sb.setLength(0); if (isMediaType(type)) { if (\"aural\".equals(type)) { containsAural = true; } state = State.WS_BEFORE_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected a CSS media type but saw \\u201C\" + type + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter, hyphen or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_AND: if (isWhitespace(c)) { continue; } else if ('a' == c) { sb.append(c); state = State.IN_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or \\u201Cand\\u201D but saw\" + \" \\u201C\" + c + \"\\u201D instead.\"); } case IN_AND: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c)) { String kw = sb.toString(); sb.setLength(0); if (\"and\".equals(kw)) { state = State.WS_BEFORE_EXPRESSION; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201Cand\\u201D but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_EXPRESSION: if (isWhitespace(c)) { continue; } else if ('(' == c) { state = State.OPEN_PAREN_SEEN; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201C(\\u201D or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case OPEN_PAREN_SEEN: if (isWhitespace(c)) { continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_FEATURE; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter at start of a media feature part but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_MEDIA_FEATURE: if (('a' <= c && 'z' >= c) || c == '-') { sb.append(c); continue; } else if (c == ')') { String kw = sb.toString(); sb.setLength(0); checkApplicability(offset + i, kw, type, warnings); checkIfValueRequired(offset + i, kw); state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c) || c == ':') { String kw = sb.toString(); sb.setLength(0); checkApplicability(offset + i, kw, type, warnings); feature = kw; valueExpectation = valueExpectationFor(kw); if (valueExpectation != null) { if (c == ':') { state = State.WS_BEFORE_VALUE; continue; } else { state = State.WS_BEFORE_COLON; continue; } } else { throw newDatatypeException(offset + i, \"Expected a CSS media feature but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter, hyphen, colon or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_COLON: if (isWhitespace(c)) { continue; } else if (':' == c) { state = State.WS_BEFORE_VALUE; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or colon but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_VALUE: if (isWhitespace(c)) { continue; } else { zero = true; switch (valueExpectation) { case SCAN: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_SCAN; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter but saw \\u201C\" + c + \"\\u201D instead.\"); } case ORIENTATION: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_ORIENTATION; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter but saw \\u201C\" + c + \"\\u201D instead.\"); } case ONEORZERO: if (c == '0' || c == '1') { sb.append(c); state = State.IN_VALUE_ONEORZERO; continue; } else { throw newDatatypeException( offset + i, \"Expected \\u201C0\\u201D or \\u201C1\\u201D as \\u201c\" + feature + \"\\u201d value but found \\u201C\" + c + \"\\u201D instead.\"); } default: if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else if ('0' == c) { state = State.IN_VALUE_DIGITS; continue; } else if ('+' == c) { state = State.IN_VALUE_BEFORE_DIGITS; continue; } else if ('.' == c && valueExpectation == ValueType.LENGTH) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Expected a digit, a dot or a plus sign but saw \\u201C\" + c + \"\\u201D instead.\"); } else { throw newDatatypeException(offset + i, \"Expected a digit or a plus sign but saw \\u201C\" + c + \"\\u201D instead.\"); } } } case IN_VALUE_SCAN: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (!(\"progressive\".equals(kw) || \"interlace\".equals(kw))) { throw newDatatypeException( offset + i, \"Expected \\u201Cprogressive\\u201D or \\u201Cinterlace\\u201D as the scan mode value but saw \\u201C\" + kw + \"\\u201D instead.\"); } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_ORIENTATION: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (!(\"portrait\".equals(kw) || \"landscape\".equals(kw))) { throw newDatatypeException( offset + i, \"Expected \\u201Cportrait\\u201D or \\u201Clandscape\\u201D as the \\u201corientation\\u201d value but saw \\u201C\" + kw + \"\\u201D instead.\"); } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_ONEORZERO: if (isWhitespace(c) || c == ')') { sb.setLength(0); if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { sb.append(c); String kw = sb.toString(); throw newDatatypeException(offset + i, \"Expected \\u201C0\\u201D or \\u201C1\\u201D as \\u201c\" + feature + \"\\u201d value but saw \\u201C\" + kw + \"\\u201D instead.\"); } case IN_VALUE_BEFORE_DIGITS: if ('0' == c) { state = State.IN_VALUE_DIGITS; continue; } else if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('.' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else { throw newDatatypeException(offset + i, \"Expected a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case INTEGER: case RATIO: throw newDatatypeException(offset + i, \"Expected a digit but saw \\u201C\" + c + \"\\u201D instead.\"); default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_DIGITS: if ('0' == c) { continue; } else if ('1' <= c && '9' >= c) { zero = false; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('.' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_UNIT; continue; } else if (isWhitespace(c) || c == ')') { if (!zero) { if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Non-zero lengths require a unit.\"); } else { throw newDatatypeException(offset + i, \"Non-zero resolutions require a unit.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case INTEGER: if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case NONZEROINTEGER: if (c == ')') { if (zero) { throw newDatatypeException(offset + i, \"Expected a non-zero positive integer.\"); } state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case RATIO: if (isWhitespace(c)) { continue; } else if (c == '/') { if (zero) { throw newDatatypeException(offset + i, \"Expected non-zero positive integer in ratio value.\"); } valueExpectation = ValueType.NONZEROINTEGER; state = State.RATIO_SECOND_INTEGER_START; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or\" + \" \\u201C/\\u201D for \" + feature + \" value but saw \\u201C\" + c + \"\\u201D instead.\"); } default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_DIGITS_AFTER_DOT: if ('0' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT_TRAIL; continue; } else if ('1' <= c && '9' >= c) { state = State.IN_VALUE_DIGITS_AFTER_DOT_TRAIL; zero = false; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_DIGITS_AFTER_DOT_TRAIL: if ('0' == c) { continue; } else if ('1' <= c && '9' >= c) { zero = false; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_UNIT; continue; } else if (isWhitespace(c) || c == ')') { if (!zero) { if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Non-zero lengths require a unit.\"); } else { throw newDatatypeException(offset + i, \"Non-zero resolutions require a unit.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_UNIT: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (valueExpectation == ValueType.LENGTH) { if (!isLengthUnit(kw)) { throw newDatatypeException(offset + i, \"Expected a length unit but saw \\u201C\" + c + \"\\u201D instead.\"); } } else { if (!(\"dpi\".equals(kw) || \"dpcm\".equals(kw))) { throw newDatatypeException(offset + i, \"Expected a resolution unit but saw \\u201C\" + c + \"\\u201D instead.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case RATIO_SECOND_INTEGER_START: valueExpectation = ValueType.NONZEROINTEGER; if (isWhitespace(c)) { continue; } else if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else if ('0' == c) { zero = true; state = State.IN_VALUE_DIGITS; continue; } else if ('+' == c) { state = State.IN_VALUE_BEFORE_DIGITS; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or a plus sign\" + \" for \" + feature + \" value but saw \\u201C\" + c + \"\\u201D instead.\"); } case AFTER_CLOSE_PAREN: if (isWhitespace(c)) { state = State.WS_BEFORE_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_CLOSE_PAREN: if (isWhitespace(c)) { continue; } else if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } } } switch (state) { case AFTER_CLOSE_PAREN: case WS_BEFORE_AND: if (containsAural && WARN) { warnings.add(\"The media type \\u201caural\\u201d is deprecated. Use \\u201cspeech\\u201d instead. \"); } return warnings; case IN_MEDIA_TYPE: String kw = sb.toString(); sb.setLength(0); if (isMediaType(kw)) { if (\"aural\".equals(kw) && WARN) { warnings.add(\"The media type \\u201caural\\u201d is deprecated. Use \\u201cspeech\\u201d instead. \"); } return warnings; } else { throw newDatatypeException(\"Expected a CSS media type but the query ended.\"); } default: throw newDatatypeException(\"Media query ended prematurely.\"); } } private boolean isMediaFeature(String feature) { return FEATURES_TO_VALUE_TYPES.containsKey(feature); } private ValueType valueExpectationFor(String feature) { return FEATURES_TO_VALUE_TYPES.get(feature); } private boolean isMediaType(String type) { return MEDIA_TYPES.contains(type); } private boolean isLengthUnit(String unit) { return LENGTH_UNITS.contains(unit); } private List<String> checkApplicability(int index, String feature, String type, List<String> warnings) throws DatatypeException { if (!isMediaType(type)) { return warnings; } if (!isMediaFeature(feature)) { throw newDatatypeException(index, \"Expected a CSS media feature but saw \\u201C\" + feature + \"\\u201D instead.\"); } if (\"scan\".equals(feature) && !\"tv\".equals(type)) { warnings.add(scanWarning); return warnings; } switch (MediaType.toCaps(type)) { case SPEECH: warnings.add(\"The media feature \\u201c\" + feature + \"\\u201d is not applicable to the media type \\u201cspeech\\u201d. \"); return warnings; case BRAILLE: case EMBOSSED: if (Arrays.binarySearch(visualFeatures, feature) > -1) { warnings.add(\"The visual media feature \\u201c\" + feature + \"\\u201d is not applicable to the tactile media type \\u201c\" + type + \"\\u201d. \"); } return warnings; case TTY: if (Arrays.binarySearch(bitmapFeatures, feature) > -1) { warnings.add(\"The bitmap media feature \\u201c\" + feature + \"\\u201d is not applicable to the media type \\u201ctty\\u201d. \"); } return warnings; default: return warnings; } } private void checkIfValueRequired(int index, String feature) throws DatatypeException { if (feature.startsWith(\"min-\") || feature.startsWith(\"max-\")) { throw newDatatypeException(index, \"Expected a value for the media feature \\u201C\" + feature + \"\\u201D.\"); } } @Override public String getName() { return \"media query\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.whattf.datatype.data.CharsetData; import org.relaxng.datatype.DatatypeException; public class MetaCharset extends AbstractDatatype {  public static final MetaCharset THE_INSTANCE = new MetaCharset(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import org.relaxng.datatype.DatatypeException; public class MetaName extends AbstractDatatype { private static final String[] VALID_NAMES = { \"aglsterms.act\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class MicrodataProperty extends Iri {  public static final MicrodataProperty THE_INSTANCE = new MicrodataProperty(); protected MicrodataProperty() { super(); } @Override public String getName() { return \"microdata property\"; } @Override public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (c == '.' || c == ':') { super.checkValid(literal); break; } } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class MimeType extends AbstractDatatype {  public static final MimeType THE_INSTANCE = new MimeType(); private enum State { AT_START, IN_SUPERTYPE, AT_SUBTYPE_START, IN_SUBTYPE, SEMICOLON_SEEN, WS_BEFORE_SEMICOLON, IN_PARAM_NAME, EQUALS_SEEN, IN_QUOTED_STRING, IN_UNQUOTED_STRING, IN_QUOTED_PAIR, CLOSE_QUOTE_SEEN } private MimeType() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (isTokenChar(c)) { state = State.IN_SUPERTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character but saw \", c, \" instead.\"); } case IN_SUPERTYPE: if (isTokenChar(c)) { continue; } else if (c == '/') { state = State.AT_SUBTYPE_START; continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C/\\u201D but saw \", c, \" instead.\"); } case AT_SUBTYPE_START: if (isTokenChar(c)) { state = State.IN_SUBTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character but saw \", c, \" instead.\"); } case IN_SUBTYPE: if (isTokenChar(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a semicolon but saw \", c, \" instead.\"); } case WS_BEFORE_SEMICOLON: if (isWhitespace(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else { throw newDatatypeException(i, \"Expected whitespace or a semicolon but saw \", c, \" instead.\"); } case SEMICOLON_SEEN: if (isWhitespace(c)) { continue; } else if (isTokenChar(c)) { state = State.IN_PARAM_NAME; continue; } else { throw newDatatypeException(i, \"Expected whitespace or a token character but saw \", c, \" instead.\"); } case IN_PARAM_NAME: if (isTokenChar(c)) { continue; } else if (c == '=') { state = State.EQUALS_SEEN; continue; } case EQUALS_SEEN: if (c == '\\\"') { state = State.IN_QUOTED_STRING; continue; } else if (isTokenChar(c)) { state = State.IN_UNQUOTED_STRING; continue; } else { throw newDatatypeException(i, \"Expected a double quote or a token character but saw \", c, \" instead.\"); } case IN_QUOTED_STRING: if (c == '\\\\') { state = State.IN_QUOTED_PAIR; continue; } else if (c == '\\\"') { state = State.CLOSE_QUOTE_SEEN; continue; } else if (isQDTextChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a non-control ASCII character but saw \", c, \" instead.\"); } case IN_QUOTED_PAIR: if (c <= 127) { state = State.IN_QUOTED_STRING; continue; } else { throw newDatatypeException(i, \"Expected an ASCII character but saw \", c, \" instead.\"); } case CLOSE_QUOTE_SEEN: if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected an ASCII character but saw \", c, \" instead.\"); } case IN_UNQUOTED_STRING: if (isTokenChar(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a semicolon but saw \", c, \" instead.\"); } } } switch (state) { case IN_SUBTYPE: case IN_UNQUOTED_STRING: case CLOSE_QUOTE_SEEN: return; case AT_START: throw newDatatypeException( \"Expected a MIME type but saw the empty string.\"); case IN_SUPERTYPE: case AT_SUBTYPE_START: throw newDatatypeException(literal.length() - 1, \"Subtype missing.\"); case EQUALS_SEEN: case IN_PARAM_NAME: throw newDatatypeException(literal.length() - 1, \"Parameter value missing.\"); case IN_QUOTED_PAIR: case IN_QUOTED_STRING: throw newDatatypeException(literal.length() - 1, \"Unfinished quoted string.\"); case SEMICOLON_SEEN: throw newDatatypeException(literal.length() - 1, \"Semicolon seen but there was no parameter following it.\"); case WS_BEFORE_SEMICOLON: throw newDatatypeException(literal.length() - 1, \"Extraneous trailing whitespace.\"); } } private boolean isQDTextChar(char c) { return (c >= ' ' && c <= 126) || (c == '\\n') || (c == '\\r') || (c == '\\t'); } private boolean isTokenChar(char c) { return (c >= 33 && c <= 126) && !(c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\\\' || c == '\\\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}'); } @Override public String getName() { return \"MIME type\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class MimeTypeList extends AbstractDatatype {  public static final MimeTypeList THE_INSTANCE = new MimeTypeList(); private enum State { WS_BEFORE_TYPE, IN_TYPE, ASTERISK_TYPE_SEEN, ASTERISK_AND_SLASH_SEEN, WS_BEFORE_COMMA, SLASH_SEEN, IN_SUBTYPE } private MimeTypeList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.WS_BEFORE_TYPE; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case WS_BEFORE_TYPE: if (isWhitespace(c)) { continue; } else if (c == '*') { state = State.ASTERISK_TYPE_SEEN; } else if (isTokenChar(c)) { state = State.IN_TYPE; continue; } else { throw newDatatypeException(i, \"Expected whitespace, a token character or \\u201C*\\u201D but saw \", c , \" instead.\"); } case ASTERISK_TYPE_SEEN: if (c == '/') { state = State.ASTERISK_AND_SLASH_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201C/\\u201D but saw \", c , \" instead.\"); } case ASTERISK_AND_SLASH_SEEN: if (c == '*') { state = State.WS_BEFORE_COMMA; continue; } else { throw newDatatypeException(i, \"Expected \\u201C*\\u201D but saw \", c , \" instead.\"); } case IN_TYPE: if (c == '/') { state = State.SLASH_SEEN; continue; } else if (isTokenChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C/\\u201D but saw \", c , \" instead.\"); } case SLASH_SEEN: if (c == '*') { state = State.WS_BEFORE_COMMA; continue; } else if (isTokenChar(c)) { state = State.IN_SUBTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C*\\u201D but saw \", c , \" instead.\"); } case IN_SUBTYPE: if (isWhitespace(c)) { state = State.WS_BEFORE_COMMA; continue; } else if (c == ',') { state = State.WS_BEFORE_TYPE; continue; } else if (isTokenChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a comma but saw \", c , \" instead.\"); } case WS_BEFORE_COMMA: if (c == ',') { state = State.WS_BEFORE_TYPE; continue; } else if (isWhitespace(c)) { continue; } else { throw newDatatypeException(i, \"Expected whitespace or a comma but saw \", c , \" instead.\"); } } } switch (state) { case IN_SUBTYPE: case WS_BEFORE_COMMA: return; case ASTERISK_AND_SLASH_SEEN: throw newDatatypeException(\"Expected \\u201C*\\u201D but the literal ended.\"); case ASTERISK_TYPE_SEEN: throw newDatatypeException(\"Expected \\u201C/\\u201D but the literal ended.\"); case IN_TYPE: throw newDatatypeException(\"Expected \\u201C/\\u201D but the literal ended.\"); case SLASH_SEEN: throw newDatatypeException(\"Expected subtype but the literal ended.\"); case WS_BEFORE_TYPE: throw newDatatypeException(\"Expected a MIME type but the literal ended.\"); } } private boolean isTokenChar(char c) { return (c >= 33 && c <= 126) && !(c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\\\' || c == '\\\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}'); } @Override public String getName() { return \"MIME type list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  public final class Month extends AbstractDatatype {  public static final Month THE_INSTANCE = new Month();  private static final Pattern THE_PATTERN = Pattern.compile(\"^([0-9]{4,})-([0-9]{2})$\");  private Month() { super(); } private void checkMonth(String year, String month) throws DatatypeException { checkMonth(Integer.parseInt(year), Integer.parseInt(month)); } private void checkMonth(int year, int month) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } } public final void checkValid(CharSequence literal) throws DatatypeException { Matcher m = THE_PATTERN.matcher(literal); if (m.matches()) { checkMonth(m.group(1), m.group(2)); } else { throw newDatatypeException( \"The literal did not satisfy the format for month.\"); } } @Override public String getName() { return \"month\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class NonEmptyString extends AbstractDatatype {  public static final NonEmptyString THE_INSTANCE = new NonEmptyString();  private NonEmptyString() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Must not be empty.\"); } } @Override public String getName() { return \"non-empty string\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import com.ibm.icu.text.UnicodeSet; public class ParenthesisEnd extends AbstractUnicodeClassCharacter { private static final UnicodeSet UNICODE_SET = new UnicodeSet(\"[:Pe:]\");  public static final ParenthesisEnd THE_INSTANCE = new ParenthesisEnd(); private ParenthesisEnd() { } @Override public String getName() { return \"end parenthesis\"; } @Override protected UnicodeSet getUnicodeSet() { return UNICODE_SET; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import com.ibm.icu.text.UnicodeSet; public class ParenthesisStart extends AbstractUnicodeClassCharacter { private static final UnicodeSet UNICODE_SET = new UnicodeSet(\"[:Ps:]\");  public static final ParenthesisStart THE_INSTANCE = new ParenthesisStart(); private ParenthesisStart() { } @Override public String getName() { return \"start parenthesis\"; } @Override protected UnicodeSet getUnicodeSet() { return UNICODE_SET; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.EcmaError; import org.mozilla.javascript.regexp.RegExpImpl; import org.relaxng.datatype.DatatypeException; /** * This datatype shall accept the strings that are allowed as the value of the Web Forms 2.0 * <a href=\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Polyline extends AbstractInt {  public static final Polyline THE_INSTANCE = new Polyline();  private Polyline() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() < 6) { throw newDatatypeException(\"A polyline must have at least six comma-separated integers.\"); } if (list.size() % 2 != 0) { throw newDatatypeException(\"A polyline must have an even number of comma-separated integers.\"); } for (CharSequenceWithOffset item : list) { checkInt(item.getSequence(), item.getOffset()); } } @Override public String getName() { return \"polyline\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Rectangle extends AbstractInt {  public static final Rectangle THE_INSTANCE = new Rectangle();  private Rectangle() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() != 4) { throw newDatatypeException(\"A rectangle must have four comma-separated integers.\"); } for (CharSequenceWithOffset item : list) { checkInt(item.getSequence(), item.getOffset()); } if (Integer.parseInt(list.get(0).getSequence().toString()) >= Integer.parseInt(list.get(2).getSequence().toString())) { throw newDatatypeException(\"The first integer must be less than the third.\"); } if (Integer.parseInt(list.get(1).getSequence().toString()) >= Integer.parseInt(list.get(3).getSequence().toString())) { throw newDatatypeException(\"The second integer must be less than the fourth.\"); } } @Override public String getName() { return \"rectangle\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public final class Refresh extends IriRef {  public static final Refresh THE_INSTANCE = new Refresh(); private Refresh() { super(); } private enum State { AT_START, DIGIT_SEEN, SEMICOLON_SEEN, SPACE_SEEN, U_SEEN, R_SEEN, L_SEEN, EQUALS_SEEN } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Empty literal.\"); } State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (isAsciiDigit(c)) { state = State.DIGIT_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit, but saw \", c, \" instead.\"); } case DIGIT_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit or a semicolon, but saw \", c, \" instead.\"); } case SEMICOLON_SEEN: if (isWhitespace(c)) { state = State.SPACE_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a space character, but saw \", c, \" instead.\"); } case SPACE_SEEN: if (isWhitespace(c)) { continue; } else if (c == 'u' || c == 'U') { state = State.U_SEEN; continue; } else { throw newDatatypeException( i, \"Expected a space character or the letter \\u201Cu\\u201D, but saw \", c, \" instead.\"); } case U_SEEN: if (c == 'r' || c == 'R') { state = State.R_SEEN; continue; } else { throw newDatatypeException(i, \"Expected the letter \\u201Cr\\u201D, but saw \", c, \" instead.\"); } case R_SEEN: if (c == 'l' || c == 'L') { state = State.L_SEEN; continue; } else { throw newDatatypeException(i, \"Expected the letter \\u201Cl\\u201D, but saw \", c, \" instead.\"); } case L_SEEN: if (c == '=') { state = State.EQUALS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201C=\\u201D, but saw \", c, \" instead.\"); } case EQUALS_SEEN: if (c == '\"' || c == '\\'') { throw newDatatypeException( \"Expected an unquoted IRI reference, but saw \", c, \" instead.\"); } if (' ' == c || '\\t' == c || '\\n' == c || '\\f' == c || '\\r' == c) { throw newDatatypeException(\"Expected an IRI reference, but saw whitespace instead.\"); } char l = literal.charAt(literal.length() - 1); if (' ' == l || '\\t' == l || '\\n' == l || '\\f' == l || '\\r' == l) { throw newDatatypeException(\"Trailing whitespace.\"); } super.checkValid(literal.subSequence(i, literal.length())); return; } } switch (state) { case AT_START: throw newDatatypeException(\"Expected a digit, but the literal ended.\"); case DIGIT_SEEN: return; case SEMICOLON_SEEN: throw newDatatypeException(\"Expected a space character, but the literal ended.\"); case SPACE_SEEN: throw newDatatypeException(\"Expected a space character or the letter \\u201Cu\\u201D, but the literal ended.\"); case U_SEEN: throw newDatatypeException(\"Expected the letter \\u201Cr\\u201D, but the literal ended.\"); case R_SEEN: throw newDatatypeException(\"Expected the letter \\u201Cl\\u201D, but the literal ended.\"); case L_SEEN: throw newDatatypeException(\"Expected \\u201C=\\u201D, but the literal ended.\"); case EQUALS_SEEN: throw newDatatypeException(\"Expected an IRI reference, but the literal ended.\"); } } @Override public String getName() { return \"refresh\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Script extends CdoCdcPair {  public static final Script THE_INSTANCE = new Script(); protected Script() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public final class ScriptDocumentation extends Script { private enum State { BEFORE_DOCUMENTATION, SLASH, IN_COMMENT, IN_LINE_COMMENT, STAR }  public static final ScriptDocumentation THE_INSTANCE = new ScriptDocumentation(); private ScriptDocumentation() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.BEFORE_DOCUMENTATION; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case BEFORE_DOCUMENTATION: switch (c) { case ' ': case '\\t': case '\\n': continue; case '/': if (i == literal.length() - 1) { throw newDatatypeException(\"Expected asterisk or slash but content ended with a \" + \"single slash instead.\"); } state = State.SLASH; continue; default: throw newDatatypeException(\"Expected space, tab, newline, or slash but found \\u201c\" + c + \"\\u201d instead.\"); } case SLASH: switch (c) { case '*': state = State.IN_COMMENT; continue; case '/': state = State.IN_LINE_COMMENT; continue; default: throw newDatatypeException(\"Expected asterisk or slash but found \\u201c\" + c + \"\\u201d instead.\"); } case IN_COMMENT: switch (c) { case '*': state = State.STAR; continue; default: continue; } case STAR: switch (c) { case '/': state = State.BEFORE_DOCUMENTATION; continue; default: continue; } case IN_LINE_COMMENT: switch (c) { case '\\n': state = State.BEFORE_DOCUMENTATION; continue; default: continue; } default: throw newDatatypeException(\"Content ended prematurely.\"); } } if (state == State.IN_LINE_COMMENT) { throw newDatatypeException(\"Content contains a line starting with\" + \" the character sequence \\u201c"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class SimpleColor extends AbstractDatatype {  public static final SimpleColor THE_INSTANCE = new SimpleColor();  private SimpleColor() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() != 7) { throw newDatatypeException(\"Incorrect length for color string.\"); } char c = literal.charAt(0); if (c != '#') { throw newDatatypeException(0, \"Color starts with incorrect character \", c, \". Expected the number sign.\"); } for (int i = 1; i < 7; i++) { c = literal.charAt(i); if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) { throw newDatatypeException(0, \"\", c, \" is not a valid hexadecimal digit.\"); } } } @Override public String getName() { return \"simple color\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class StringWithoutLineBreaks extends AbstractDatatype {  public static final StringWithoutLineBreaks THE_INSTANCE = new StringWithoutLineBreaks();  private StringWithoutLineBreaks() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (c == '\\n') { throw newDatatypeException(i, \"Line feed not allowed.\"); } else if (c == '\\r') { throw newDatatypeException(i, \"Carriage return not allowed.\"); } } } @Override public String getName() { return \"string without line breaks\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "/* * Copyright 2000-2013 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  public final class Time extends AbstractDatetime {  public static final Time THE_INSTANCE = new Time();  private static final Pattern THE_PATTERN = Pattern.compile(\"^([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?$\");  private Time() { super(); } public void checkValid(CharSequence literal) throws DatatypeException { Matcher m = getPattern().matcher(literal); if (m.matches()) { checkHour(m.group(1)); checkMinute(m.group(2)); String seconds = m.group(3); if (seconds != null) { checkSecond(seconds); } } else { throw newDatatypeException( \"The literal did not satisfy the format for time.\"); } }  protected final Pattern getPattern() { return THE_PATTERN; } @Override public String getName() { return \"time\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; public class TimeDatetime extends AbstractDatetime {  public static final TimeDatetime THE_INSTANCE = new TimeDatetime(); public int i;  private static final Pattern THE_PATTERN = Pattern.compile(\"^[ \\\\t\\\\r\\\\n\\\\f]*(?:(?:([0-9]{4,})-([0-9]{2}))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2}))|(?:([0-9]{2})-([0-9]{2}))|(?:([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?)|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?)|(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2})))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2}))))|(?:([0-9]{4,})-W([0-9]{2}))|(?:([0-9]{4,}))|(?:P(?:(?:[0-9]+D)|(?:(?:[0-9]+D)?T[0-9]+H)|(?:(?:[0-9]+D)?T(?:[0-9]+H)?[0-9]+M)|(?:(?:[0-9]+D)?T(?:(?:[0-9]+)H)?(?:(?:[0-9]+)M)?(?:[0-9]+(?:\\\\.([0-9]+))?S))))|(?:[ \\\\t\\\\r\\\\n\\\\f]*[0-9]+(?:(?:[ \\\\t\\\\r\\\\n\\\\f]*(?:[Ww]|[Dd]|[Hh]|[Mm]))|(?:(?:\\\\.([0-9]+))?[ \\\\t\\\\r\\\\n\\\\f]*[Ss])))+)[ \\\\t\\\\r\\\\n\\\\f]*$\"); private TimeDatetime() { super(); } @Override protected Pattern getPattern() { return THE_PATTERN; } @Override public String getName() { return \"time-datetime\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException; /** * This datatype shall accept strings that conform to the format of * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class XmlName extends AbstractDatatype { public static boolean isNameStart(char c) { return ((c >= '\\u0041' && c <= '\\u005A') || (c >= '\\u0061' && c <= '\\u007A') || (c >= '\\u00C0' && c <= '\\u00D6') || (c >= '\\u00D8' && c <= '\\u00F6') || (c >= '\\u00F8' && c <= '\\u00FF') || (c >= '\\u0100' && c <= '\\u0131') || (c >= '\\u0134' && c <= '\\u013E') || (c >= '\\u0141' && c <= '\\u0148') || (c >= '\\u014A' && c <= '\\u017E') || (c >= '\\u0180' && c <= '\\u01C3') || (c >= '\\u01CD' && c <= '\\u01F0') || (c >= '\\u01F4' && c <= '\\u01F5') || (c >= '\\u01FA' && c <= '\\u0217') || (c >= '\\u0250' && c <= '\\u02A8') || (c >= '\\u02BB' && c <= '\\u02C1') || (c == '\\u0386') || (c >= '\\u0388' && c <= '\\u038A') || (c == '\\u038C') || (c >= '\\u038E' && c <= '\\u03A1') || (c >= '\\u03A3' && c <= '\\u03CE') || (c >= '\\u03D0' && c <= '\\u03D6') || (c == '\\u03DA') || (c == '\\u03DC') || (c == '\\u03DE') || (c == '\\u03E0') || (c >= '\\u03E2' && c <= '\\u03F3') || (c >= '\\u0401' && c <= '\\u040C') || (c >= '\\u040E' && c <= '\\u044F') || (c >= '\\u0451' && c <= '\\u045C') || (c >= '\\u045E' && c <= '\\u0481') || (c >= '\\u0490' && c <= '\\u04C4') || (c >= '\\u04C7' && c <= '\\u04C8') || (c >= '\\u04CB' && c <= '\\u04CC') || (c >= '\\u04D0' && c <= '\\u04EB') || (c >= '\\u04EE' && c <= '\\u04F5') || (c >= '\\u04F8' && c <= '\\u04F9') || (c >= '\\u0531' && c <= '\\u0556') || (c == '\\u0559') || (c >= '\\u0561' && c <= '\\u0586') || (c >= '\\u05D0' && c <= '\\u05EA') || (c >= '\\u05F0' && c <= '\\u05F2') || (c >= '\\u0621' && c <= '\\u063A') || (c >= '\\u0641' && c <= '\\u064A') || (c >= '\\u0671' && c <= '\\u06B7') || (c >= '\\u06BA' && c <= '\\u06BE') || (c >= '\\u06C0' && c <= '\\u06CE') || (c >= '\\u06D0' && c <= '\\u06D3') || (c == '\\u06D5') || (c >= '\\u06E5' && c <= '\\u06E6') || (c >= '\\u0905' && c <= '\\u0939') || (c == '\\u093D') || (c >= '\\u0958' && c <= '\\u0961') || (c >= '\\u0985' && c <= '\\u098C') || (c >= '\\u098F' && c <= '\\u0990') || (c >= '\\u0993' && c <= '\\u09A8') || (c >= '\\u09AA' && c <= '\\u09B0') || (c == '\\u09B2') || (c >= '\\u09B6' && c <= '\\u09B9') || (c >= '\\u09DC' && c <= '\\u09DD') || (c >= '\\u09DF' && c <= '\\u09E1') || (c >= '\\u09F0' && c <= '\\u09F1') || (c >= '\\u0A05' && c <= '\\u0A0A') || (c >= '\\u0A0F' && c <= '\\u0A10') || (c >= '\\u0A13' && c <= '\\u0A28') || (c >= '\\u0A2A' && c <= '\\u0A30') || (c >= '\\u0A32' && c <= '\\u0A33') || (c >= '\\u0A35' && c <= '\\u0A36') || (c >= '\\u0A38' && c <= '\\u0A39') || (c >= '\\u0A59' && c <= '\\u0A5C') || (c == '\\u0A5E') || (c >= '\\u0A72' && c <= '\\u0A74') || (c >= '\\u0A85' && c <= '\\u0A8B') || (c == '\\u0A8D') || (c >= '\\u0A8F' && c <= '\\u0A91') || (c >= '\\u0A93' && c <= '\\u0AA8') || (c >= '\\u0AAA' && c <= '\\u0AB0') || (c >= '\\u0AB2' && c <= '\\u0AB3') || (c >= '\\u0AB5' && c <= '\\u0AB9') || (c == '\\u0ABD') || (c == '\\u0AE0') || (c >= '\\u0B05' && c <= '\\u0B0C') || (c >= '\\u0B0F' && c <= '\\u0B10') || (c >= '\\u0B13' && c <= '\\u0B28') || (c >= '\\u0B2A' && c <= '\\u0B30') || (c >= '\\u0B32' && c <= '\\u0B33') || (c >= '\\u0B36' && c <= '\\u0B39') || (c == '\\u0B3D') || (c >= '\\u0B5C' && c <= '\\u0B5D') || (c >= '\\u0B5F' && c <= '\\u0B61') || (c >= '\\u0B85' && c <= '\\u0B8A') || (c >= '\\u0B8E' && c <= '\\u0B90') || (c >= '\\u0B92' && c <= '\\u0B95') || (c >= '\\u0B99' && c <= '\\u0B9A') || (c == '\\u0B9C') || (c >= '\\u0B9E' && c <= '\\u0B9F') || (c >= '\\u0BA3' && c <= '\\u0BA4') || (c >= '\\u0BA8' && c <= '\\u0BAA') || (c >= '\\u0BAE' && c <= '\\u0BB5') || (c >= '\\u0BB7' && c <= '\\u0BB9') || (c >= '\\u0C05' && c <= '\\u0C0C') || (c >= '\\u0C0E' && c <= '\\u0C10') || (c >= '\\u0C12' && c <= '\\u0C28') || (c >= '\\u0C2A' && c <= '\\u0C33') || (c >= '\\u0C35' && c <= '\\u0C39') || (c >= '\\u0C60' && c <= '\\u0C61') || (c >= '\\u0C85' && c <= '\\u0C8C') || (c >= '\\u0C8E' && c <= '\\u0C90') || (c >= '\\u0C92' && c <= '\\u0CA8') || (c >= '\\u0CAA' && c <= '\\u0CB3') || (c >= '\\u0CB5' && c <= '\\u0CB9') || (c == '\\u0CDE') || (c >= '\\u0CE0' && c <= '\\u0CE1') || (c >= '\\u0D05' && c <= '\\u0D0C') || (c >= '\\u0D0E' && c <= '\\u0D10') || (c >= '\\u0D12' && c <= '\\u0D28') || (c >= '\\u0D2A' && c <= '\\u0D39') || (c >= '\\u0D60' && c <= '\\u0D61') || (c >= '\\u0E01' && c <= '\\u0E2E') || (c == '\\u0E30') || (c >= '\\u0E32' && c <= '\\u0E33') || (c >= '\\u0E40' && c <= '\\u0E45') || (c >= '\\u0E81' && c <= '\\u0E82') || (c == '\\u0E84') || (c >= '\\u0E87' && c <= '\\u0E88') || (c == '\\u0E8A') || (c == '\\u0E8D') || (c >= '\\u0E94' && c <= '\\u0E97') || (c >= '\\u0E99' && c <= '\\u0E9F') || (c >= '\\u0EA1' && c <= '\\u0EA3') || (c == '\\u0EA5') || (c == '\\u0EA7') || (c >= '\\u0EAA' && c <= '\\u0EAB') || (c >= '\\u0EAD' && c <= '\\u0EAE') || (c == '\\u0EB0') || (c >= '\\u0EB2' && c <= '\\u0EB3') || (c == '\\u0EBD') || (c >= '\\u0EC0' && c <= '\\u0EC4') || (c >= '\\u0F40' && c <= '\\u0F47') || (c >= '\\u0F49' && c <= '\\u0F69') || (c >= '\\u10A0' && c <= '\\u10C5') || (c >= '\\u10D0' && c <= '\\u10F6') || (c == '\\u1100') || (c >= '\\u1102' && c <= '\\u1103') || (c >= '\\u1105' && c <= '\\u1107') || (c == '\\u1109') || (c >= '\\u110B' && c <= '\\u110C') || (c >= '\\u110E' && c <= '\\u1112') || (c == '\\u113C') || (c == '\\u113E') || (c == '\\u1140') || (c == '\\u114C') || (c == '\\u114E') || (c == '\\u1150') || (c >= '\\u1154' && c <= '\\u1155') || (c == '\\u1159') || (c >= '\\u115F' && c <= '\\u1161') || (c == '\\u1163') || (c == '\\u1165') || (c == '\\u1167') || (c == '\\u1169') || (c >= '\\u116D' && c <= '\\u116E') || (c >= '\\u1172' && c <= '\\u1173') || (c == '\\u1175') || (c == '\\u119E') || (c == '\\u11A8') || (c == '\\u11AB') || (c >= '\\u11AE' && c <= '\\u11AF') || (c >= '\\u11B7' && c <= '\\u11B8') || (c == '\\u11BA') || (c >= '\\u11BC' && c <= '\\u11C2') || (c == '\\u11EB') || (c == '\\u11F0') || (c == '\\u11F9') || (c >= '\\u1E00' && c <= '\\u1E9B') || (c >= '\\u1EA0' && c <= '\\u1EF9') || (c >= '\\u1F00' && c <= '\\u1F15') || (c >= '\\u1F18' && c <= '\\u1F1D') || (c >= '\\u1F20' && c <= '\\u1F45') || (c >= '\\u1F48' && c <= '\\u1F4D') || (c >= '\\u1F50' && c <= '\\u1F57') || (c == '\\u1F59') || (c == '\\u1F5B') || (c == '\\u1F5D') || (c >= '\\u1F5F' && c <= '\\u1F7D') || (c >= '\\u1F80' && c <= '\\u1FB4') || (c >= '\\u1FB6' && c <= '\\u1FBC') || (c == '\\u1FBE') || (c >= '\\u1FC2' && c <= '\\u1FC4') || (c >= '\\u1FC6' && c <= '\\u1FCC') || (c >= '\\u1FD0' && c <= '\\u1FD3') || (c >= '\\u1FD6' && c <= '\\u1FDB') || (c >= '\\u1FE0' && c <= '\\u1FEC') || (c >= '\\u1FF2' && c <= '\\u1FF4') || (c >= '\\u1FF6' && c <= '\\u1FFC') || (c == '\\u2126') || (c >= '\\u212A' && c <= '\\u212B') || (c == '\\u212E') || (c >= '\\u2180' && c <= '\\u2182') || (c >= '\\u3041' && c <= '\\u3094') || (c >= '\\u30A1' && c <= '\\u30FA') || (c >= '\\u3105' && c <= '\\u312C') || (c >= '\\uAC00' && c <= '\\uD7A3') || (c >= '\\u4E00' && c <= '\\u9FA5') || (c == '\\u3007') || (c >= '\\u3021' && c <= '\\u3029') || (c == '_') || (c == ':')); } public static boolean isNameTrail(char c) { return ((c >= '\\u0030' && c <= '\\u0039') || (c >= '\\u0660' && c <= '\\u0669') || (c >= '\\u06F0' && c <= '\\u06F9') || (c >= '\\u0966' && c <= '\\u096F') || (c >= '\\u09E6' && c <= '\\u09EF') || (c >= '\\u0A66' && c <= '\\u0A6F') || (c >= '\\u0AE6' && c <= '\\u0AEF') || (c >= '\\u0B66' && c <= '\\u0B6F') || (c >= '\\u0BE7' && c <= '\\u0BEF') || (c >= '\\u0C66' && c <= '\\u0C6F') || (c >= '\\u0CE6' && c <= '\\u0CEF') || (c >= '\\u0D66' && c <= '\\u0D6F') || (c >= '\\u0E50' && c <= '\\u0E59') || (c >= '\\u0ED0' && c <= '\\u0ED9') || (c >= '\\u0F20' && c <= '\\u0F29') || (c >= '\\u0041' && c <= '\\u005A') || (c >= '\\u0061' && c <= '\\u007A') || (c >= '\\u00C0' && c <= '\\u00D6') || (c >= '\\u00D8' && c <= '\\u00F6') || (c >= '\\u00F8' && c <= '\\u00FF') || (c >= '\\u0100' && c <= '\\u0131') || (c >= '\\u0134' && c <= '\\u013E') || (c >= '\\u0141' && c <= '\\u0148') || (c >= '\\u014A' && c <= '\\u017E') || (c >= '\\u0180' && c <= '\\u01C3') || (c >= '\\u01CD' && c <= '\\u01F0') || (c >= '\\u01F4' && c <= '\\u01F5') || (c >= '\\u01FA' && c <= '\\u0217') || (c >= '\\u0250' && c <= '\\u02A8') || (c >= '\\u02BB' && c <= '\\u02C1') || (c == '\\u0386') || (c >= '\\u0388' && c <= '\\u038A') || (c == '\\u038C') || (c >= '\\u038E' && c <= '\\u03A1') || (c >= '\\u03A3' && c <= '\\u03CE') || (c >= '\\u03D0' && c <= '\\u03D6') || (c == '\\u03DA') || (c == '\\u03DC') || (c == '\\u03DE') || (c == '\\u03E0') || (c >= '\\u03E2' && c <= '\\u03F3') || (c >= '\\u0401' && c <= '\\u040C') || (c >= '\\u040E' && c <= '\\u044F') || (c >= '\\u0451' && c <= '\\u045C') || (c >= '\\u045E' && c <= '\\u0481') || (c >= '\\u0490' && c <= '\\u04C4') || (c >= '\\u04C7' && c <= '\\u04C8') || (c >= '\\u04CB' && c <= '\\u04CC') || (c >= '\\u04D0' && c <= '\\u04EB') || (c >= '\\u04EE' && c <= '\\u04F5') || (c >= '\\u04F8' && c <= '\\u04F9') || (c >= '\\u0531' && c <= '\\u0556') || (c == '\\u0559') || (c >= '\\u0561' && c <= '\\u0586') || (c >= '\\u05D0' && c <= '\\u05EA') || (c >= '\\u05F0' && c <= '\\u05F2') || (c >= '\\u0621' && c <= '\\u063A') || (c >= '\\u0641' && c <= '\\u064A') || (c >= '\\u0671' && c <= '\\u06B7') || (c >= '\\u06BA' && c <= '\\u06BE') || (c >= '\\u06C0' && c <= '\\u06CE') || (c >= '\\u06D0' && c <= '\\u06D3') || (c == '\\u06D5') || (c >= '\\u06E5' && c <= '\\u06E6') || (c >= '\\u0905' && c <= '\\u0939') || (c == '\\u093D') || (c >= '\\u0958' && c <= '\\u0961') || (c >= '\\u0985' && c <= '\\u098C') || (c >= '\\u098F' && c <= '\\u0990') || (c >= '\\u0993' && c <= '\\u09A8') || (c >= '\\u09AA' && c <= '\\u09B0') || (c == '\\u09B2') || (c >= '\\u09B6' && c <= '\\u09B9') || (c >= '\\u09DC' && c <= '\\u09DD') || (c >= '\\u09DF' && c <= '\\u09E1') || (c >= '\\u09F0' && c <= '\\u09F1') || (c >= '\\u0A05' && c <= '\\u0A0A') || (c >= '\\u0A0F' && c <= '\\u0A10') || (c >= '\\u0A13' && c <= '\\u0A28') || (c >= '\\u0A2A' && c <= '\\u0A30') || (c >= '\\u0A32' && c <= '\\u0A33') || (c >= '\\u0A35' && c <= '\\u0A36') || (c >= '\\u0A38' && c <= '\\u0A39') || (c >= '\\u0A59' && c <= '\\u0A5C') || (c == '\\u0A5E') || (c >= '\\u0A72' && c <= '\\u0A74') || (c >= '\\u0A85' && c <= '\\u0A8B') || (c == '\\u0A8D') || (c >= '\\u0A8F' && c <= '\\u0A91') || (c >= '\\u0A93' && c <= '\\u0AA8') || (c >= '\\u0AAA' && c <= '\\u0AB0') || (c >= '\\u0AB2' && c <= '\\u0AB3') || (c >= '\\u0AB5' && c <= '\\u0AB9') || (c == '\\u0ABD') || (c == '\\u0AE0') || (c >= '\\u0B05' && c <= '\\u0B0C') || (c >= '\\u0B0F' && c <= '\\u0B10') || (c >= '\\u0B13' && c <= '\\u0B28') || (c >= '\\u0B2A' && c <= '\\u0B30') || (c >= '\\u0B32' && c <= '\\u0B33') || (c >= '\\u0B36' && c <= '\\u0B39') || (c == '\\u0B3D') || (c >= '\\u0B5C' && c <= '\\u0B5D') || (c >= '\\u0B5F' && c <= '\\u0B61') || (c >= '\\u0B85' && c <= '\\u0B8A') || (c >= '\\u0B8E' && c <= '\\u0B90') || (c >= '\\u0B92' && c <= '\\u0B95') || (c >= '\\u0B99' && c <= '\\u0B9A') || (c == '\\u0B9C') || (c >= '\\u0B9E' && c <= '\\u0B9F') || (c >= '\\u0BA3' && c <= '\\u0BA4') || (c >= '\\u0BA8' && c <= '\\u0BAA') || (c >= '\\u0BAE' && c <= '\\u0BB5') || (c >= '\\u0BB7' && c <= '\\u0BB9') || (c >= '\\u0C05' && c <= '\\u0C0C') || (c >= '\\u0C0E' && c <= '\\u0C10') || (c >= '\\u0C12' && c <= '\\u0C28') || (c >= '\\u0C2A' && c <= '\\u0C33') || (c >= '\\u0C35' && c <= '\\u0C39') || (c >= '\\u0C60' && c <= '\\u0C61') || (c >= '\\u0C85' && c <= '\\u0C8C') || (c >= '\\u0C8E' && c <= '\\u0C90') || (c >= '\\u0C92' && c <= '\\u0CA8') || (c >= '\\u0CAA' && c <= '\\u0CB3') || (c >= '\\u0CB5' && c <= '\\u0CB9') || (c == '\\u0CDE') || (c >= '\\u0CE0' && c <= '\\u0CE1') || (c >= '\\u0D05' && c <= '\\u0D0C') || (c >= '\\u0D0E' && c <= '\\u0D10') || (c >= '\\u0D12' && c <= '\\u0D28') || (c >= '\\u0D2A' && c <= '\\u0D39') || (c >= '\\u0D60' && c <= '\\u0D61') || (c >= '\\u0E01' && c <= '\\u0E2E') || (c == '\\u0E30') || (c >= '\\u0E32' && c <= '\\u0E33') || (c >= '\\u0E40' && c <= '\\u0E45') || (c >= '\\u0E81' && c <= '\\u0E82') || (c == '\\u0E84') || (c >= '\\u0E87' && c <= '\\u0E88') || (c == '\\u0E8A') || (c == '\\u0E8D') || (c >= '\\u0E94' && c <= '\\u0E97') || (c >= '\\u0E99' && c <= '\\u0E9F') || (c >= '\\u0EA1' && c <= '\\u0EA3') || (c == '\\u0EA5') || (c == '\\u0EA7') || (c >= '\\u0EAA' && c <= '\\u0EAB') || (c >= '\\u0EAD' && c <= '\\u0EAE') || (c == '\\u0EB0') || (c >= '\\u0EB2' && c <= '\\u0EB3') || (c == '\\u0EBD') || (c >= '\\u0EC0' && c <= '\\u0EC4') || (c >= '\\u0F40' && c <= '\\u0F47') || (c >= '\\u0F49' && c <= '\\u0F69') || (c >= '\\u10A0' && c <= '\\u10C5') || (c >= '\\u10D0' && c <= '\\u10F6') || (c == '\\u1100') || (c >= '\\u1102' && c <= '\\u1103') || (c >= '\\u1105' && c <= '\\u1107') || (c == '\\u1109') || (c >= '\\u110B' && c <= '\\u110C') || (c >= '\\u110E' && c <= '\\u1112') || (c == '\\u113C') || (c == '\\u113E') || (c == '\\u1140') || (c == '\\u114C') || (c == '\\u114E') || (c == '\\u1150') || (c >= '\\u1154' && c <= '\\u1155') || (c == '\\u1159') || (c >= '\\u115F' && c <= '\\u1161') || (c == '\\u1163') || (c == '\\u1165') || (c == '\\u1167') || (c == '\\u1169') || (c >= '\\u116D' && c <= '\\u116E') || (c >= '\\u1172' && c <= '\\u1173') || (c == '\\u1175') || (c == '\\u119E') || (c == '\\u11A8') || (c == '\\u11AB') || (c >= '\\u11AE' && c <= '\\u11AF') || (c >= '\\u11B7' && c <= '\\u11B8') || (c == '\\u11BA') || (c >= '\\u11BC' && c <= '\\u11C2') || (c == '\\u11EB') || (c == '\\u11F0') || (c == '\\u11F9') || (c >= '\\u1E00' && c <= '\\u1E9B') || (c >= '\\u1EA0' && c <= '\\u1EF9') || (c >= '\\u1F00' && c <= '\\u1F15') || (c >= '\\u1F18' && c <= '\\u1F1D') || (c >= '\\u1F20' && c <= '\\u1F45') || (c >= '\\u1F48' && c <= '\\u1F4D') || (c >= '\\u1F50' && c <= '\\u1F57') || (c == '\\u1F59') || (c == '\\u1F5B') || (c == '\\u1F5D') || (c >= '\\u1F5F' && c <= '\\u1F7D') || (c >= '\\u1F80' && c <= '\\u1FB4') || (c >= '\\u1FB6' && c <= '\\u1FBC') || (c == '\\u1FBE') || (c >= '\\u1FC2' && c <= '\\u1FC4') || (c >= '\\u1FC6' && c <= '\\u1FCC') || (c >= '\\u1FD0' && c <= '\\u1FD3') || (c >= '\\u1FD6' && c <= '\\u1FDB') || (c >= '\\u1FE0' && c <= '\\u1FEC') || (c >= '\\u1FF2' && c <= '\\u1FF4') || (c >= '\\u1FF6' && c <= '\\u1FFC') || (c == '\\u2126') || (c >= '\\u212A' && c <= '\\u212B') || (c == '\\u212E') || (c >= '\\u2180' && c <= '\\u2182') || (c >= '\\u3041' && c <= '\\u3094') || (c >= '\\u30A1' && c <= '\\u30FA') || (c >= '\\u3105' && c <= '\\u312C') || (c >= '\\uAC00' && c <= '\\uD7A3') || (c >= '\\u4E00' && c <= '\\u9FA5') || (c == '\\u3007') || (c >= '\\u3021' && c <= '\\u3029') || (c == '_') || (c == ':') || (c == '.') || (c == '-') || (c >= '\\u0300' && c <= '\\u0345') || (c >= '\\u0360' && c <= '\\u0361') || (c >= '\\u0483' && c <= '\\u0486') || (c >= '\\u0591' && c <= '\\u05A1') || (c >= '\\u05A3' && c <= '\\u05B9') || (c >= '\\u05BB' && c <= '\\u05BD') || (c == '\\u05BF') || (c >= '\\u05C1' && c <= '\\u05C2') || (c == '\\u05C4') || (c >= '\\u064B' && c <= '\\u0652') || (c == '\\u0670') || (c >= '\\u06D6' && c <= '\\u06DC') || (c >= '\\u06DD' && c <= '\\u06DF') || (c >= '\\u06E0' && c <= '\\u06E4') || (c >= '\\u06E7' && c <= '\\u06E8') || (c >= '\\u06EA' && c <= '\\u06ED') || (c >= '\\u0901' && c <= '\\u0903') || (c == '\\u093C') || (c >= '\\u093E' && c <= '\\u094C') || (c == '\\u094D') || (c >= '\\u0951' && c <= '\\u0954') || (c >= '\\u0962' && c <= '\\u0963') || (c >= '\\u0981' && c <= '\\u0983') || (c == '\\u09BC') || (c == '\\u09BE') || (c == '\\u09BF') || (c >= '\\u09C0' && c <= '\\u09C4') || (c >= '\\u09C7' && c <= '\\u09C8') || (c >= '\\u09CB' && c <= '\\u09CD') || (c == '\\u09D7') || (c >= '\\u09E2' && c <= '\\u09E3') || (c == '\\u0A02') || (c == '\\u0A3C') || (c == '\\u0A3E') || (c == '\\u0A3F') || (c >= '\\u0A40' && c <= '\\u0A42') || (c >= '\\u0A47' && c <= '\\u0A48') || (c >= '\\u0A4B' && c <= '\\u0A4D') || (c >= '\\u0A70' && c <= '\\u0A71') || (c >= '\\u0A81' && c <= '\\u0A83') || (c == '\\u0ABC') || (c >= '\\u0ABE' && c <= '\\u0AC5') || (c >= '\\u0AC7' && c <= '\\u0AC9') || (c >= '\\u0ACB' && c <= '\\u0ACD') || (c >= '\\u0B01' && c <= '\\u0B03') || (c == '\\u0B3C') || (c >= '\\u0B3E' && c <= '\\u0B43') || (c >= '\\u0B47' && c <= '\\u0B48') || (c >= '\\u0B4B' && c <= '\\u0B4D') || (c >= '\\u0B56' && c <= '\\u0B57') || (c >= '\\u0B82' && c <= '\\u0B83') || (c >= '\\u0BBE' && c <= '\\u0BC2') || (c >= '\\u0BC6' && c <= '\\u0BC8') || (c >= '\\u0BCA' && c <= '\\u0BCD') || (c == '\\u0BD7') || (c >= '\\u0C01' && c <= '\\u0C03') || (c >= '\\u0C3E' && c <= '\\u0C44') || (c >= '\\u0C46' && c <= '\\u0C48') || (c >= '\\u0C4A' && c <= '\\u0C4D') || (c >= '\\u0C55' && c <= '\\u0C56') || (c >= '\\u0C82' && c <= '\\u0C83') || (c >= '\\u0CBE' && c <= '\\u0CC4') || (c >= '\\u0CC6' && c <= '\\u0CC8') || (c >= '\\u0CCA' && c <= '\\u0CCD') || (c >= '\\u0CD5' && c <= '\\u0CD6') || (c >= '\\u0D02' && c <= '\\u0D03') || (c >= '\\u0D3E' && c <= '\\u0D43') || (c >= '\\u0D46' && c <= '\\u0D48') || (c >= '\\u0D4A' && c <= '\\u0D4D') || (c == '\\u0D57') || (c == '\\u0E31') || (c >= '\\u0E34' && c <= '\\u0E3A') || (c >= '\\u0E47' && c <= '\\u0E4E') || (c == '\\u0EB1') || (c >= '\\u0EB4' && c <= '\\u0EB9') || (c >= '\\u0EBB' && c <= '\\u0EBC') || (c >= '\\u0EC8' && c <= '\\u0ECD') || (c >= '\\u0F18' && c <= '\\u0F19') || (c == '\\u0F35') || (c == '\\u0F37') || (c == '\\u0F39') || (c == '\\u0F3E') || (c == '\\u0F3F') || (c >= '\\u0F71' && c <= '\\u0F84') || (c >= '\\u0F86' && c <= '\\u0F8B') || (c >= '\\u0F90' && c <= '\\u0F95') || (c == '\\u0F97') || (c >= '\\u0F99' && c <= '\\u0FAD') || (c >= '\\u0FB1' && c <= '\\u0FB7') || (c == '\\u0FB9') || (c >= '\\u20D0' && c <= '\\u20DC') || (c == '\\u20E1') || (c >= '\\u302A' && c <= '\\u302F') || (c == '\\u3099') || (c == '\\u309A') || (c == '\\u00B7') || (c == '\\u02D0') || (c == '\\u02D1') || (c == '\\u0387') || (c == '\\u0640') || (c == '\\u0E46') || (c == '\\u0EC6') || (c == '\\u3005') || (c >= '\\u3031' && c <= '\\u3035') || (c >= '\\u309D' && c <= '\\u309E') || (c >= '\\u30FC' && c <= '\\u30FE')); } public static boolean isName(CharSequence str) { if (str == null) { return false; } else { int len = str.length(); switch (len) { case 0: return false; case 1: return XmlName.isNameStart(str.charAt(0)); default: if (!XmlName.isNameStart(str.charAt(0))) { return false; } for (int i = 1; i < len; i++) { if (!XmlName.isNameTrail(str.charAt(i))) { return false; } } } return true; } }  public static final XmlName THE_INSTANCE = new XmlName(); private XmlName() { } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (!isName(literal)) { throw newDatatypeException(\"Not a valid XML 1.0 name.\"); } } @Override public String getName() { return \"XML name\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Zero extends AbstractDatatype {  public static final Zero THE_INSTANCE = new Zero(); private Zero() { } @Override public String getName() { return \"zero\"; } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() != 1 || literal.charAt(0) != '0') { throw newDatatypeException(0, \"Only \\u201C0\\u201D is a permitted zero literal.\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "  package org.whattf.datatype.data; import java.util.Arrays; public class CharsetData { private static final String[] LABELS = { \"866\", \"ansi_x3.4-1968\", \"arabic\", \"ascii\", \"asmo-708\", \"big5\", \"big5-hkscs\", \"chinese\", \"cn-big5\", \"cp1250\", \"cp1251\", \"cp1252\", \"cp1253\", \"cp1254\", \"cp1255\", \"cp1256\", \"cp1257\", \"cp1258\", \"cp819\", \"cp866\", \"csbig5\", \"cseuckr\", \"cseucpkdfmtjapanese\", \"csgb2312\", \"csibm866\", \"csiso2022jp\", \"csiso2022kr\", \"csiso58gb231280\", \"csiso88596e\", \"csiso88596i\", \"csiso88598e\", \"csiso88598i\", \"csisolatin1\", \"csisolatin2\", \"csisolatin3\", \"csisolatin4\", \"csisolatin5\", \"csisolatin6\", \"csisolatin9\", \"csisolatinarabic\", \"csisolatincyrillic\", \"csisolatingreek\", \"csisolatinhebrew\", \"cskoi8r\", \"csksc56011987\", \"csmacintosh\", \"csshiftjis\", \"cyrillic\", \"dos-874\", \"ecma-114\", \"ecma-118\", \"elot_928\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gb2312\", \"gb_2312\", \"gb_2312-80\", \"gbk\", \"greek\", \"greek8\", \"hebrew\", \"hz-gb-2312\", \"ibm819\", \"ibm866\", \"iso-2022-cn\", \"iso-2022-cn-ext\", \"iso-2022-jp\", \"iso-2022-kr\", \"iso-8859-1\", \"iso-8859-10\", \"iso-8859-11\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6-e\", \"iso-8859-6-i\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8-e\", \"iso-8859-8-i\", \"iso-8859-9\", \"iso-ir-100\", \"iso-ir-101\", \"iso-ir-109\", \"iso-ir-110\", \"iso-ir-126\", \"iso-ir-127\", \"iso-ir-138\", \"iso-ir-144\", \"iso-ir-148\", \"iso-ir-149\", \"iso-ir-157\", \"iso-ir-58\", \"iso8859-1\", \"iso8859-10\", \"iso8859-11\", \"iso8859-13\", \"iso8859-14\", \"iso8859-15\", \"iso8859-2\", \"iso8859-3\", \"iso8859-4\", \"iso8859-5\", \"iso8859-6\", \"iso8859-7\", \"iso8859-8\", \"iso8859-9\", \"iso88591\", \"iso885910\", \"iso885911\", \"iso885913\", \"iso885914\", \"iso885915\", \"iso88592\", \"iso88593\", \"iso88594\", \"iso88595\", \"iso88596\", \"iso88597\", \"iso88598\", \"iso88599\", \"iso_8859-1\", \"iso_8859-15\", \"iso_8859-1:1987\", \"iso_8859-2\", \"iso_8859-2:1987\", \"iso_8859-3\", \"iso_8859-3:1988\", \"iso_8859-4\", \"iso_8859-4:1988\", \"iso_8859-5\", \"iso_8859-5:1988\", \"iso_8859-6\", \"iso_8859-6:1987\", \"iso_8859-7\", \"iso_8859-7:1987\", \"iso_8859-8\", \"iso_8859-8:1988\", \"iso_8859-9\", \"iso_8859-9:1989\", \"koi\", \"koi8\", \"koi8-r\", \"koi8-u\", \"koi8_r\", \"korean\", \"ks_c_5601-1987\", \"ks_c_5601-1989\", \"ksc5601\", \"ksc_5601\", \"l1\", \"l2\", \"l3\", \"l4\", \"l5\", \"l6\", \"l9\", \"latin1\", \"latin2\", \"latin3\", \"latin4\", \"latin5\", \"latin6\", \"logical\", \"mac\", \"macintosh\", \"ms_kanji\", \"shift-jis\", \"shift_jis\", \"sjis\", \"sun_eu_greek\", \"tis-620\", \"unicode-1-1-utf-8\", \"us-ascii\", \"utf-16\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"utf8\", \"visual\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-31j\", \"windows-874\", \"windows-949\", \"x-cp1250\", \"x-cp1251\", \"x-cp1252\", \"x-cp1253\", \"x-cp1254\", \"x-cp1255\", \"x-cp1256\", \"x-cp1257\", \"x-cp1258\", \"x-euc-jp\", \"x-gbk\", \"x-mac-cyrillic\", \"x-mac-roman\", \"x-mac-ukrainian\", \"x-sjis\", \"x-user-defined\", \"x-x-big5\", }; private static final String[] PREFERRED_FOR_LABELS = { \"ibm866\", \"windows-1252\", \"iso-8859-6\", \"windows-1252\", \"iso-8859-6\", \"big5\", \"big5\", \"gbk\", \"big5\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-1252\", \"ibm866\", \"big5\", \"euc-kr\", \"euc-jp\", \"gbk\", \"ibm866\", \"iso-2022-jp\", \"iso-2022-kr\", \"gbk\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-8\", \"iso-8859-8-i\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-15\", \"iso-8859-6\", \"iso-8859-5\", \"iso-8859-7\", \"iso-8859-8\", \"koi8-r\", \"euc-kr\", \"macintosh\", \"shift_jis\", \"iso-8859-5\", \"windows-874\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-7\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gbk\", \"gbk\", \"gbk\", \"gbk\", \"iso-8859-7\", \"iso-8859-7\", \"iso-8859-8\", \"hz-gb-2312\", \"windows-1252\", \"ibm866\", \"replacement\", \"replacement\", \"iso-2022-jp\", \"iso-2022-kr\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8\", \"iso-8859-8-i\", \"windows-1254\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-7\", \"iso-8859-6\", \"iso-8859-8\", \"iso-8859-5\", \"windows-1254\", \"euc-kr\", \"iso-8859-10\", \"gbk\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"windows-1254\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"windows-1254\", \"windows-1252\", \"iso-8859-15\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8\", \"windows-1254\", \"windows-1254\", \"koi8-r\", \"koi8-r\", \"koi8-r\", \"koi8-u\", \"koi8-r\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-15\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-8-i\", \"macintosh\", \"macintosh\", \"shift_jis\", \"shift_jis\", \"shift_jis\", \"shift_jis\", \"iso-8859-7\", \"windows-874\", \"utf-8\", \"windows-1252\", \"utf-16le\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"utf-8\", \"iso-8859-8\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"shift_jis\", \"windows-874\", \"euc-kr\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"euc-jp\", \"gbk\", \"x-mac-cyrillic\", \"macintosh\", \"x-mac-cyrillic\", \"shift_jis\", \"x-user-defined\", \"big5\", }; private static final String[] PREFERRED = { \"big5\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gbk\", \"hz-gb-2312\", \"ibm866\", \"iso-2022-jp\", \"iso-2022-kr\", \"iso-8859-10\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8-i\", \"koi8-r\", \"koi8-u\", \"macintosh\", \"replacement\", \"shift_jis\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-874\", \"x-mac-cyrillic\", \"x-user-defined\", }; public static boolean isPreferred(String label) { return Arrays.binarySearch(PREFERRED, label) > -1; } public static String preferredForLabel(String label) { int index = Arrays.binarySearch(LABELS, label); if (index < 0) { return null; } return PREFERRED_FOR_LABELS[index]; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype.data; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet; import java.util.regex.Pattern; public class LanguageData { private static final Pattern HYPHEN = Pattern.compile(\"-\"); private static final String[][] EMPTY_DOUBLE_STRING_ARRAY = {}; private static final String[] EMPTY_STRING_ARRAY = {}; private static final String PREFIX = \"prefix: \"; private static final String SUPPRESS_SCRIPT = \"suppress-script: \"; private static final String SUBTAG = \"subtag: \"; private static final String TAG = \"tag: \"; private static final String TYPE = \"type: \"; private static final String DEPRECATED = \"deprecated: \"; private static final String PREFERRED_VALUE = \"preferred-value: \"; private BufferedReader in; private SortedSet<String> languageSet = new TreeSet<String>(); private SortedSet<String> extlangSet = new TreeSet<String>(); private SortedSet<String> scriptSet = new TreeSet<String>(); private SortedSet<String> regionSet = new TreeSet<String>(); private SortedSet<String> variantSet = new TreeSet<String>(); private SortedSet<String> grandfatheredSet = new TreeSet<String>(); private SortedSet<String> redundantSet = new TreeSet<String>(); private SortedSet<String> deprecatedLangSet = new TreeSet<String>(); private SortedSet<String> deprecatedSet = new TreeSet<String>(); private Map<String, String> suppressedScriptByLanguageMap = new HashMap<String, String>(); private Map<String, String> prefixByExtlangMap = new HashMap<String, String>(); private Map<String, String> preferredValueByLanguageMap = new HashMap<String, String>(); private Map<String, Set<String[]>> prefixesByVariantMap = new HashMap<String, Set<String[]>>(); private String[] languages = null; private String[] extlangs = null; private String[] scripts = null; private String[] regions = null; private String[] variants = null; private String[] grandfathered = null; private String[] redundant = null; private String[] deprecatedLang = null; private String[] deprecated = null; private int[] suppressedScriptByLanguage = null; private int[] prefixByExtlang = null; private String[][][] prefixesByVariant = null; public LanguageData() throws IOException { super(); in = new BufferedReader( new InputStreamReader( LanguageData.class.getClassLoader().getResourceAsStream( \"nu/validator/localentities/files/language-subtag-registry\"), \"UTF-8\")); consumeRegistry(); prepareArrays(); } private void consumeRegistry() throws IOException { while (consumeRecord()) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.EOFException; import java.io.IOException; import java.io.InputStream;  public class Base64InputStream extends InputStream { private static final int[] DECODING_TABLE = new int[256]; static { for (int i = 0; i < DECODING_TABLE.length; i++) { if (i >= 'A' && i <= 'Z') { DECODING_TABLE[i] = (i - 'A'); } else if (i >= 'a' && i <= 'z') { DECODING_TABLE[i] = (i - 'a' + 26); } else if (i >= '0' && i <= '9') { DECODING_TABLE[i] = (i - '0' + 52); } else if (i == '+') { DECODING_TABLE[i] = 62; } else if (i == '/') { DECODING_TABLE[i] = 63; } else if (i == '=') { DECODING_TABLE[i] = -2; } else { DECODING_TABLE[i] = -1; } } } private final InputStream delegate; private int bytesLeftInBuffer = 0; private int buffer = 0;  public Base64InputStream(InputStream delegate) { this.delegate = delegate; } @Override public int read() throws IOException { if (bytesLeftInBuffer == 0) { bytesLeftInBuffer = 3; for (int i = 0; i < 4; i++) { int c = delegate.read(); buffer <<= 6; if (c < 0) { if (i == 0) { bytesLeftInBuffer = 0; return -1; } else { throw new EOFException(); } } else if (bytesLeftInBuffer == 2) { if (c == '=') { bytesLeftInBuffer = 1; } else { throw new IOException(\"Non-padding in Base64 stream after padding had started.\"); } } else { int b = DECODING_TABLE[c]; if (b == -2) { if (i <= 1) { throw new IOException( \"Base 64 padding in a bad position.\"); } bytesLeftInBuffer = 2; } else if (b == -1) { throw new IOException(\"Non-Base64 input: \\u201C0x\" + Integer.toHexString(c) + \"\\u201D.\"); } else { buffer |= b; } } } } int rv = (buffer & 0xFF0000) >> 16; buffer <<= 8; bytesLeftInBuffer--; return rv; }  public void close() throws IOException { delegate.close(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.InputStream; import java.io.StringReader; import java.net.MalformedURLException; import com.hp.hpl.jena.iri.IRI; import com.hp.hpl.jena.iri.IRIFactory; public class DataUri { public static boolean startsWithData(String uri) { return uri != null && uri.length() >= 5 && (uri.charAt(0) == 'd' || uri.charAt(0) == 'D') && (uri.charAt(1) == 'a' || uri.charAt(1) == 'A') && (uri.charAt(2) == 't' || uri.charAt(2) == 'T') && (uri.charAt(3) == 'a' || uri.charAt(3) == 'A') && (uri.charAt(4) == ':'); } private enum State { AT_START, IN_SUPERTYPE, AT_SUBTYPE_START, IN_SUBTYPE, SEMICOLON_SEEN, WS_BEFORE_SEMICOLON, IN_PARAM_NAME, EQUALS_SEEN, IN_QUOTED_STRING, IN_UNQUOTED_STRING, IN_QUOTED_PAIR, CLOSE_QUOTE_SEEN } private String contentType; private InputStream inputStream;  protected void init(IRI uri) throws IOException, MalformedURLException { if (!uri.getScheme().equals(\"data\")) { throw new IllegalArgumentException(\"The input did not start with data:.\"); } if (uri.getRawFragment() != null) { throw new MalformedURLException(\"Fragment is not allowed for data: URIs according to RFC 2397. But if strictly comply with RFC 3986, ignore this error.\"); } InputStream is = new PercentDecodingReaderInputStream(new StringReader(uri.getRawPath())); StringBuilder sb = new StringBuilder(); State state = State.AT_START; int i = 0; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; public class DataUriException extends IOException { private final int index; private final String head; private final char literal; private final String tail;  public DataUriException(int index, String head, char literal, String tail) { super(head + '\\u201C' + literal + '\\u201D' + tail); this.index = index; this.head = head; this.literal = literal; this.tail = tail; }  public int getIndex() { return index; }  public String getHead() { return head; }  public char getLiteral() { return literal; }  public String getTail() { return tail; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.net.MalformedURLException; public final class PercentDecodingReaderInputStream extends InputStream { private final Reader delegate;  public PercentDecodingReaderInputStream(final Reader delegate) { this.delegate = delegate; }  @Override public int read() throws IOException { int c = delegate.read(); if (c == -1) { return -1; } if (c == '%') { return readHexByte(); } else if (c < 0x80) { return c; } else { throw new MalformedURLException(\"Unescaped non-ASCII character.\"); } } private int readHexByte() throws IOException { int c = delegate.read(); if (isHexDigit(c)) { int hi = Character.getNumericValue(c) << 4; c = delegate.read(); if (isHexDigit(c)) { return hi | Character.getNumericValue(c); } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } private boolean isHexDigit(int c) { return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); } @Override public void close() throws IOException { delegate.close(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.Reader; import java.net.MalformedURLException; public final class Utf8PercentDecodingReader extends Reader { private final Reader delegate; private char pending = '\\u0000';  public Utf8PercentDecodingReader(final Reader delegate) { this.delegate = delegate; }  @Override public int read() throws IOException { if (pending != '\\u0000') { char rv = pending; pending = '\\u0000'; return rv; } int byteVal = 0; int codePoint = 0; int c = delegate.read(); int trailBytes = 0; if (c == -1) { return -1; } if (c == '%') { byteVal = readHexByte(); if (byteVal < 0x80) { return byteVal; } else if ((0xE0 & byteVal) == 0xC0) { trailBytes = 1; codePoint = byteVal & 0x1F; } else if ((0xF0 & byteVal) == 0xE0) { trailBytes = 2; codePoint = byteVal & 0x0F; } else if ((0xF8 & byteVal) == 0xF0) { trailBytes = 3; codePoint = byteVal & 0x07; } else { throw new MalformedURLException(\"Percent escape decodes to a byte that is not a valid UTF-8 lead byte.\"); } for (int i = 0; i < trailBytes; i++) { byteVal = readPercentHexByte(); if ((0xC0 & byteVal) == 0x80) { codePoint = (codePoint << 6) | (byteVal & 0x3F); } else { throw new MalformedURLException(\"Percent escape decodes to a byte that is not a valid UTF-8 trail byte.\"); } } switch (trailBytes) { case 3: if (codePoint <= 0xFFFF) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { int rv = (0xD7C0 + (codePoint >> 10)); pending = (char) (0xDC00 + (codePoint & 0x3FF)); return rv; } case 2: if (codePoint <= 0x07FF) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { return codePoint; } default: if (codePoint <= 0x007F) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { return codePoint; } } } else { return c; } } private int readPercentHexByte() throws IOException { int c = delegate.read(); if (c != '%') { throw new MalformedURLException(\"Percent-encoded trail byte missing.\"); } return readHexByte(); } private int readHexByte() throws IOException { int c = delegate.read(); if (isHexDigit(c)) { int hi = Character.getNumericValue(c) << 4; c = delegate.read(); if (isHexDigit(c)) { return hi | Character.getNumericValue(c); } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } private boolean isHexDigit(int c) { return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); } @Override public void close() throws IOException { pending = '\\u0000'; delegate.close(); } @Override public int read(char[] cbuf, int off, int len) throws IOException { int i = 0; while (i < len) { int c = read(); if (c == -1) { if (i == 0) { return -1; } else { return i; } } cbuf[off] = (char) c; off++; i++; } return i; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "package nu.validator.localentities; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.HashMap; import java.util.Map; import nu.validator.xml.TypedInputSource; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; import org.xml.sax.SAXException;  public class LocalCacheEntityResolver implements EntityResolver { private static final ClassLoader LOADER = LocalCacheEntityResolver.class.getClassLoader(); private static final Map<String, String> PATH_MAP = new HashMap<String, String>(); static { try { BufferedReader r = new BufferedReader(new InputStreamReader( LOADER.getResourceAsStream(\"nu/validator/localentities/files/entitymap\"), \"UTF-8\")); String line; while ((line = r.readLine()) != null) { if (\"\".equals(line.trim())) { break; } String s[] = line.split(\"\\t\"); PATH_MAP.put(s[0], \"nu/validator/localentities/files/\" + s[1]); } } catch (IOException e) { throw new RuntimeException(e); } } public static InputStream getPresetsAsStream() { return LOADER.getResourceAsStream(\"nu/validator/localentities/files/presets\"); } public static InputStream getHtml5SpecAsStream() { return LOADER.getResourceAsStream(\"nu/validator/localentities/files/html5spec\"); } private EntityResolver delegate; private boolean allowRnc = false;  public LocalCacheEntityResolver(EntityResolver delegate) { this.delegate = delegate; }  public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException { String path = PATH_MAP.get(systemId); if (path != null) { InputStream stream = LOADER.getResourceAsStream(path); if (stream != null) { TypedInputSource is = new TypedInputSource(); is.setByteStream(stream); is.setSystemId(systemId); is.setPublicId(publicId); if (systemId.endsWith(\".rnc\")) { is.setType(\"application/relax-ng-compact-syntax\"); if (!allowRnc) { throw new IOException(\"Not an XML resource: \" + systemId); } } else if (systemId.endsWith(\".dtd\")) { is.setType(\"application/xml-dtd\"); } else if (systemId.endsWith(\".ent\")) { is.setType(\"application/xml-external-parsed-entity\"); } else { is.setType(\"application/xml\"); } return is; } } return delegate.resolveEntity(publicId, systemId); }  public boolean isAllowRnc() { return allowRnc; }  public void setAllowRnc(boolean allowRnc) { this.allowRnc = allowRnc; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; public class ARel extends AbstractRel { private static final String[] REGISTERED_TOKENS = { \"#voverlay\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.ArrayList; import java.util.List; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext;  public abstract class AbstractDatatype implements Datatype {  AbstractDatatype() { super(); }  public final boolean isValid(String literal, ValidationContext context) { try { checkValid(literal); } catch (DatatypeException e) { return false; } return true; }  public void checkValid(String literal, ValidationContext context) throws DatatypeException { checkValid(literal); } public abstract void checkValid(CharSequence literal) throws DatatypeException;  public DatatypeStreamingValidator createStreamingValidator( ValidationContext context) { return new DatatypeStreamingValidatorImpl(this); }  public Object createValue(String literal, ValidationContext context) { return literal; }  public final boolean sameValue(Object value1, Object value2) { if (value1 == null) { return (value2 == null); } return value1.equals(value2); }  public final int valueHashCode(Object value) { return value.hashCode(); }  public final int getIdType() { return Datatype.ID_TYPE_NULL; }  public boolean isContextDependent() { return false; }  protected final boolean isWhitespace(char c) { return c == ' ' || c == '\\t' || c == '\\f' || c == '\\n' || c == '\\r'; } protected final boolean isAsciiDigit(char c) { return c >= '0' && c <= '9'; } protected static final char toAsciiLowerCase(char c) { if (c >= 'A' && c <= 'Z') { c += 0x20; } return c; } protected static final String toAsciiLowerCase(CharSequence str) { if (str == null) { return null; } char[] buf = new char[str.length()]; for (int i = 0; i < str.length(); i++) { char c = str.charAt(i); if (c >= 'A' && c <= 'Z') { c += 0x20; } buf[i] = c; } return new String(buf); } protected static final char toAsciiUpperCase(char c) { if (c >= 'a' && c <= 'z') { c -= 0x20; } return c; } protected static final String toAsciiUpperCase(CharSequence str) { if (str == null) { return null; } char[] buf = new char[str.length()]; for (int i = 0; i < str.length(); i++) { char c = str.charAt(i); if (c >= 'a' && c <= 'z') { c -= 0x20; } buf[i] = c; } return new String(buf); } protected DatatypeException newDatatypeException(String message) { return new Html5DatatypeException(this.getClass(), this.getName(), message); } protected DatatypeException newDatatypeException(String head, String literal, String tail) { return new Html5DatatypeException(this.getClass(), this.getName(), head, literal, tail); } protected DatatypeException newDatatypeException(String head, char literal, String tail) { return new Html5DatatypeException(this.getClass(), this.getName(), head, String.valueOf(literal), tail); } protected DatatypeException newDatatypeException(int position, String message) { return new Html5DatatypeException(position, this.getClass(), this.getName(), message); } protected DatatypeException newDatatypeException(int position, String head, String literal, String tail) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, literal, tail); } protected DatatypeException newDatatypeException(int position, String head, char literal, String tail) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, String.valueOf(literal), tail); }  protected DatatypeException newDatatypeException(String message, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), message, warning); } protected DatatypeException newDatatypeException(String head, String literal, String tail, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), head, literal, tail, warning); } protected DatatypeException newDatatypeException(String head, char literal, String tail, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), head, String.valueOf(literal), tail, warning); } protected DatatypeException newDatatypeException(int position, String message, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), message, warning); } protected DatatypeException newDatatypeException(int position, String head, String literal, String tail, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, literal, tail, warning); } protected DatatypeException newDatatypeException(int position, String head, char literal, String tail, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, String.valueOf(literal), tail, warning); } public abstract String getName(); protected List<CharSequenceWithOffset> split(CharSequence sequence, char delimiter) { List<CharSequenceWithOffset> rv = new ArrayList<CharSequenceWithOffset>(); int offset = 0; for (int i = 0; i < sequence.length(); i++) { char c = sequence.charAt(i); if (c == delimiter) { rv.add(new CharSequenceWithOffset(sequence.subSequence(offset, i), offset)); offset = i + 1; } } rv.add(new CharSequenceWithOffset(sequence.subSequence(offset, sequence.length()), offset)); return rv; } protected class CharSequenceWithOffset { private final CharSequence sequence; private final int offset;  public CharSequenceWithOffset(final CharSequence sequence, final int offset) { this.sequence = sequence; this.offset = offset; }  public int getOffset() { return offset; }  public CharSequence getSequence() { return sequence; } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  abstract class AbstractDatetime extends AbstractDatatype {  private static int[] DAYS_IN_MONTHS = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };  AbstractDatetime() { super(); } private void checkMonth(String year, String month) throws DatatypeException { checkMonth(Integer.parseInt(year), Integer.parseInt(month)); } private void checkMonth(int year, int month) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } } private void checkDate(String year, String month, String day) throws DatatypeException { checkDate(Integer.parseInt(year), Integer.parseInt(month), Integer.parseInt(day)); } private void checkDate(int year, int month, int day) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } if (day < 1) { throw newDatatypeException(\"Day cannot be less than 1.\"); } if (day > DAYS_IN_MONTHS[month - 1]) { if (!(day == 29 && month == 2 && isLeapYear(year))) { throw newDatatypeException(\"Day out of range.\"); } } } private boolean isLeapYear(int year) { return (year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)); } private void checkYearlessDate(String month, String day) throws DatatypeException { checkYearlessDate(Integer.parseInt(month), Integer.parseInt(day)); } private void checkYearlessDate(int month, int day) throws DatatypeException { if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } if (day < 1) { throw newDatatypeException(\"Day cannot be less than 1.\"); } } private void checkWeek(String year, String week) throws DatatypeException { checkWeek(Integer.parseInt(year), Integer.parseInt(week)); } private void checkWeek(int year, int week) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (week< 1) { throw newDatatypeException(\"Week cannot be less than 1.\"); } if (week > 53) { throw newDatatypeException(\"Week cannot be greater than 53.\"); } } protected final void checkHour(String hour) throws DatatypeException { checkHour(Integer.parseInt(hour)); } private void checkHour(int hour) throws DatatypeException { if (hour > 23) { throw newDatatypeException(\"Hour cannot be greater than 23.\"); } } protected final void checkMinute(String minute) throws DatatypeException { checkMinute(Integer.parseInt(minute)); } private void checkMinute(int minute) throws DatatypeException { if (minute > 59) { throw newDatatypeException(\"Minute cannot be greater than 59.\"); } } protected final void checkSecond(String second) throws DatatypeException { checkSecond(Integer.parseInt(second)); } private void checkSecond(int second) throws DatatypeException { if (second > 59) { throw newDatatypeException(\"Second cannot be greater than 59.\"); } } protected final void checkMilliSecond(String millisecond) throws DatatypeException { if (millisecond.length() > 3) { throw newDatatypeException(\"A fraction of a second must be one, two, or three digits.\"); } } private void checkTzd(String hours, String minutes) throws DatatypeException { if (hours.charAt(0) == '+') { hours = hours.substring(1); } checkTzd(Integer.parseInt(hours), Integer.parseInt(minutes)); } private void checkTzd(int hours, int minutes) throws DatatypeException { if (hours < -23 || hours > 23) { throw newDatatypeException(\"Hours out of range in time zone designator.\"); } if (minutes > 59) { throw newDatatypeException(\"Minutes out of range in time zone designator.\"); } } protected abstract Pattern getPattern(); public void checkValid(CharSequence literal) throws DatatypeException { String year; String month; String day; String hour; String minute; String seconds; String milliseconds; String tzdHours; String tzdMinutes; Matcher m = getPattern().matcher(literal); if (m.matches()) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public abstract class AbstractInt extends AbstractDatatype {  protected AbstractInt() { super(); }  protected void checkInt(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid integer.\"); } char c = literal.charAt(0); if (!(c == '-' || isAsciiDigit(c))) { throw newDatatypeException(0, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } for (int i = 1; i < literal.length(); i++) { c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } } }  protected void checkIntNonNegative(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid non-negative integer.\"); } for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } } }  protected void checkIntPositive(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid positive integer.\"); } boolean zero = true; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } if (c != '0') { zero = false; } } if (zero) { throw newDatatypeException(\"Zero is not a positive integer.\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.HashSet; import java.util.Set; import org.relaxng.datatype.DatatypeException; abstract class AbstractRel extends AbstractDatatype { @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext; import com.ibm.icu.lang.UCharacter; import com.ibm.icu.text.UnicodeSet; public abstract class AbstractUnicodeClassCharacter extends AbstractDatatype { private static final int SURROGATE_OFFSET = 0x10000 - (0xD800 << 10) - 0xDC00; protected abstract UnicodeSet getUnicodeSet(); @Override public void checkValid(CharSequence literal) throws DatatypeException { switch (literal.length()) { case 0: throw newDatatypeException(\"The empty string is not a \" + getName() + \".\"); case 1: char c = literal.charAt(0); if (!getUnicodeSet().contains(c)) { throw newDatatypeException(0, \"The character \", c, \" is not a \" + getName() + \".\"); } return; case 2: char hi = literal.charAt(0); char lo = literal.charAt(1); if ((lo & 0xFC00) == 0xDC00 && (hi & 0xFC00) == 0xD800) { int codepoint = (hi << 10) + lo + SURROGATE_OFFSET; if (!getUnicodeSet().contains(codepoint)) { throw newDatatypeException(0, \"The character \", \"\" + hi + lo, \" is not a \" + getName() + \".\"); } return; } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; public class AsciiCaseInsensitiveString extends AbstractDatatype {  public static final AsciiCaseInsensitiveString THE_INSTANCE = new AsciiCaseInsensitiveString();  protected AsciiCaseInsensitiveString() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { }  @Override public Object createValue(String literal, ValidationContext context) { return toAsciiLowerCase(literal); } @Override public String getName() { return \"ASCII-case-insensitive string\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class BrowsingContext extends AbstractDatatype {  public static final BrowsingContext THE_INSTANCE = new BrowsingContext();  private BrowsingContext() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Browsing context name must be at least one character long.\"); } if (literal.charAt(0) == '_') { throw newDatatypeException(\"Browsing context name started with the underscore.\"); } else { return; } } @Override public String getName() { return \"browsing context name\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class BrowsingContextOrKeyword extends AbstractDatatype {  public static final BrowsingContextOrKeyword THE_INSTANCE = new BrowsingContextOrKeyword();  private BrowsingContextOrKeyword() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Browsing context name must be at least one character long.\"); } if (literal.charAt(0) == '_') { String kw = toAsciiLowerCase(literal.toString().substring(1)); if (!(\"blank\".equals(kw) || \"self\".equals(kw) || \"top\".equals(kw) || \"parent\".equals(kw))) { throw newDatatypeException(\"Reserved keyword \", kw, \" used.\"); } } else { return; } } @Override public String getName() { return \"browsing context name or keyword\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class CdoCdcPair extends AbstractDatatype { private enum State { DATA, LESS_THAN_SIGN, LESS_THAN_SIGN_BANG, LESS_THAN_SIGN_BANG_HYPHEN, HAS_CDO, HAS_CDO_AND_HYPHEN, HAS_CDO_AND_DOUBLE_HYPHEN }  public static final CdoCdcPair THE_INSTANCE = new CdoCdcPair(); protected CdoCdcPair() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.DATA; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case DATA: if ('<' == c) { state = State.LESS_THAN_SIGN; continue; } continue; case LESS_THAN_SIGN: if ('!' == c) { state = State.LESS_THAN_SIGN_BANG; continue; } state = State.DATA; continue; case LESS_THAN_SIGN_BANG: if ('-' == c) { state = State.LESS_THAN_SIGN_BANG_HYPHEN; continue; } state = State.DATA; continue; case LESS_THAN_SIGN_BANG_HYPHEN: if ('-' == c) { state = State.HAS_CDO; continue; } state = State.DATA; continue; case HAS_CDO: if ('-' == c) { state = State.HAS_CDO_AND_HYPHEN; continue; } continue; case HAS_CDO_AND_HYPHEN: if ('-' == c) { state = State.HAS_CDO_AND_DOUBLE_HYPHEN; continue; } state = State.HAS_CDO; continue; case HAS_CDO_AND_DOUBLE_HYPHEN: if ('>' == c) { state = State.DATA; continue; } else if ('-' == c) { continue; } state = State.HAS_CDO; continue; default: assert false : state; } } if (state == State.HAS_CDO) { throw newDatatypeException(\"Content contains the character sequence \\u201c<!--\\u201d without\" + \" a later occurrence of the character sequence \\u201c-->\\u201d.\"); } } @Override public String getName() { return \"text content with CDO-CDC pair\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.whattf.datatype.data.CharsetData; import org.relaxng.datatype.DatatypeException; public class Charset extends AbstractDatatype {  public static final Charset THE_INSTANCE = new Charset(); public Charset() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid character encoding name.\"); } for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class CharsetList extends AbstractDatatype {  public static final CharsetList THE_INSTANCE = new CharsetList(); private enum State { WS_BEFORE_TOKEN } private CharsetList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.WS_BEFORE_TOKEN; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { } } switch (state) { } } private boolean isTokenChar(char c) { return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '+' || c == '-' || c == '^' || c == '_' || c == '`' || c == '{' || c == '}' || c == '~'; } @Override public String getName() { return \"character encoding list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Circle extends AbstractInt {  public static final Circle THE_INSTANCE = new Circle();  private Circle() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() != 3) { throw newDatatypeException(\"A circle must have three comma-separated integers.\"); } CharSequenceWithOffset withOffset = list.get(0); checkInt(withOffset.getSequence(), withOffset.getOffset()); withOffset = list.get(1); checkInt(withOffset.getSequence(), withOffset.getOffset()); withOffset = list.get(2); checkIntNonNegative(withOffset.getSequence(), withOffset.getOffset()); } @Override public String getName() { return \"circle\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; public final class DatatypeStreamingValidatorImpl implements DatatypeStreamingValidator { private final AbstractDatatype datatype; private final StringBuilder buffer; public DatatypeStreamingValidatorImpl(AbstractDatatype datatype) { super(); this.datatype = datatype; this.buffer = new StringBuilder(); } public void addCharacters(char[] buf, int start, int len) { buffer.append(buf, start, len); } public boolean isValid() { try { datatype.checkValid(buffer); } catch (DatatypeException e) { return false; } return true; } public void checkValid() throws DatatypeException { datatype.checkValid(buffer); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; public class DateOrTime extends AbstractDatetime {  public static final DateOrTime THE_INSTANCE = new DateOrTime();  private static final Pattern THE_PATTERN = Pattern.compile(\"^(?:(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:[T ]([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?(?:Z|(?:([+-][0-9]{2}):([0-9]{2})))?)?)|(?:([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?(?:Z|(?:([+-][0-9]{2}):([0-9]{2})))?))$\"); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class EmailAddress extends AbstractDatatype {  public static final EmailAddress THE_INSTANCE = new EmailAddress();  public EmailAddress() { super(); }  @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class EmailAddressList extends AbstractDatatype {  public static final EmailAddressList THE_INSTANCE = new EmailAddressList();  public EmailAddressList() { super(); }  @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponent extends AbstractDatatype {  public static final FloatingPointExponent THE_INSTANCE = new FloatingPointExponent(); private enum State { AT_START, AT_START_MINUS_SEEN, IN_INTEGER_PART_DIGITS_SEEN, DOT_SEEN, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponent() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { state = State.AT_START_MINUS_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } case AT_START_MINUS_SEEN: if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_EXPONENT_DIGITS_SEEN: return; case AT_START: throw newDatatypeException(\"The empty string is not a valid floating point number.\"); case AT_START_MINUS_SEEN: throw newDatatypeException(\"The minus sign alone is not a valid floating point number.\"); case DOT_SEEN: throw newDatatypeException(\"A floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponentNonNegative extends AbstractDatatype {  public static final FloatingPointExponentNonNegative THE_INSTANCE = new FloatingPointExponentNonNegative(); private enum State { AT_START, AT_START_MINUS_SEEN, IN_INTEGER_PART_DIGITS_SEEN, IN_INTEGER_PART_DIGITS_SEEN_ZERO, DOT_SEEN, DOT_SEEN_ZERO, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_DECIMAL_PART_DIGITS_SEEN_ZERO, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponentNonNegative() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { state = State.AT_START_MINUS_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } case AT_START_MINUS_SEEN: if (c == '0') { state = State.IN_INTEGER_PART_DIGITS_SEEN_ZERO; continue; } else { throw newDatatypeException(i, \"Expected a zero but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN_ZERO: if (c == '.') { state = State.DOT_SEEN_ZERO; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (c == '0') { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a zero but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case DOT_SEEN_ZERO: if (c == '0') { state = State.IN_DECIMAL_PART_DIGITS_SEEN_ZERO; continue; } else { throw newDatatypeException(i, \"Expected a zero after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN_ZERO: if (c == '0') { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a zero but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_INTEGER_PART_DIGITS_SEEN_ZERO: case IN_DECIMAL_PART_DIGITS_SEEN_ZERO: case IN_EXPONENT_DIGITS_SEEN: return; case AT_START: throw newDatatypeException(\"The empty string is not a valid non-negative floating point number.\"); case AT_START_MINUS_SEEN: throw newDatatypeException(\"The minus sign alone is not a valid non-negative floating point number.\"); case DOT_SEEN: case DOT_SEEN_ZERO: throw newDatatypeException(\"A non-negative floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A non-negative floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A non-negative floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"non-negative floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponentPositive extends AbstractDatatype {  public static final FloatingPointExponentPositive THE_INSTANCE = new FloatingPointExponentPositive(); private enum State { AT_START, IN_INTEGER_PART_DIGITS_SEEN, DOT_SEEN, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponentPositive() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; boolean zero = true; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { throw newDatatypeException(i, \"A positive floating point number cannot start with the minus sign.\"); } else if (isAsciiDigit(c)) { if (c != '0') { zero = false; } state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { if (c != '0') { zero = false; } continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { if (c != '0') { zero = false; } state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { if (c != '0') { zero = false; } continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_EXPONENT_DIGITS_SEEN: if (zero) { throw newDatatypeException(\"Zero is not a valid positive floating point number.\"); } return; case AT_START: throw newDatatypeException(\"The empty string is not a valid positive floating point number.\"); case DOT_SEEN: throw newDatatypeException(\"A positive floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A positive floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A positive floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"positive floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.BufferedReader; import java.io.IOException; import java.io.Reader; import java.io.StringReader; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.RhinoException; import org.relaxng.datatype.DatatypeException; public class FunctionBody extends AbstractDatatype {  public static final FunctionBody THE_INSTANCE = new FunctionBody(); protected FunctionBody() { super(); } public void checkValid(CharSequence literal) throws DatatypeException { try { Reader reader = new BufferedReader((new StringReader( \"function(event){\" + literal.toString() + \"}\"))); reader.mark(1); try { Context context = ContextFactory.getGlobal().enterContext(); context.setOptimizationLevel(0); context.setLanguageVersion(Context.VERSION_1_6); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class HashName extends AbstractDatatype {  public static final HashName THE_INSTANCE = new HashName();  private HashName() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid hash-name reference.\"); } else if (literal.charAt(0) != '#') { throw newDatatypeException(\"A hash-name reference must start with \\u201C#\\u201D.\"); } else if (literal.length() == 1) { throw newDatatypeException(\"A hash-name reference must have at least one character after \\u201C#\\u201D.\"); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class Html5DatatypeException extends DatatypeException { private Class datatypeClass; private String[] segments;  final boolean warning; public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String message) { super(index, \"Bad \" + datatypeName + \": \" + message); this.datatypeClass = datatypeClass; this.segments = new String[1]; this.segments[0] = message; this.warning = false; } public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String head, String literal, String tail) { super(index, \"Bad \" + datatypeName + \": \" + head + '\\u201C' + literal + '\\u201D' + tail); this.datatypeClass = datatypeClass; this.segments = new String[3]; this.segments[0] = head; this.segments[1] = literal; this.segments[2] = tail; this.warning = false; } public Html5DatatypeException(Class datatypeClass, String datatypeName, String message) { this(-1, datatypeClass, datatypeName, message); } public Html5DatatypeException(Class datatypeClass, String datatypeName, String head, String literal, String tail) { this(-1, datatypeClass, datatypeName, head, literal, tail); }  public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String message, boolean warning) { super(index, \"Bad \" + datatypeName + \": \" + message); this.datatypeClass = datatypeClass; this.segments = new String[1]; this.segments[0] = message; this.warning = warning; } public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String head, String literal, String tail, boolean warning) { super(index, \"Bad \" + datatypeName + \": \" + head + '\\u201C' + literal + '\\u201D' + tail); this.datatypeClass = datatypeClass; this.segments = new String[3]; this.segments[0] = head; this.segments[1] = literal; this.segments[2] = tail; this.warning = warning; } public Html5DatatypeException(Class datatypeClass, String datatypeName, String message, boolean warning) { this(-1, datatypeClass, datatypeName, message, warning); } public Html5DatatypeException(Class datatypeClass, String datatypeName, String head, String literal, String tail, boolean warning) { this(-1, datatypeClass, datatypeName, head, literal, tail, warning); }  public Class getDatatypeClass() { return datatypeClass; }  public String[] getSegments() { return segments; }  public boolean isWarning() { return warning; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.helpers.ParameterlessDatatypeBuilder;  public class Html5DatatypeLibrary implements DatatypeLibrary { public Html5DatatypeLibrary() { super(); }  public DatatypeBuilder createDatatypeBuilder(String baseTypeLocalName) throws DatatypeException { return new ParameterlessDatatypeBuilder(createDatatype(baseTypeLocalName)); }  public Datatype createDatatype(String typeLocalName) throws DatatypeException { if (\"ID\".equals(typeLocalName)) { return new Id(); } else if (\"IDREF\".equals(typeLocalName)) { return Idref.THE_INSTANCE; } else if (\"IDREFS\".equals(typeLocalName)) { return Idrefs.THE_INSTANCE; } else if (\"pattern\".equals(typeLocalName)) { return Pattern.THE_INSTANCE; } else if (\"datetime\".equals(typeLocalName)) { return Datetime.THE_INSTANCE; } else if (\"datetime-local\".equals(typeLocalName)) { return DatetimeLocal.THE_INSTANCE; } else if (\"datetime-tz\".equals(typeLocalName)) { return DatetimeTz.THE_INSTANCE; } else if (\"date-or-time\".equals(typeLocalName)) { return DateOrTime.THE_INSTANCE; } else if (\"date\".equals(typeLocalName)) { return Date.THE_INSTANCE; } else if (\"month\".equals(typeLocalName)) { return Month.THE_INSTANCE; } else if (\"week\".equals(typeLocalName)) { return Week.THE_INSTANCE; } else if (\"time\".equals(typeLocalName)) { return Time.THE_INSTANCE; } else if (\"iri\".equals(typeLocalName)) { return Iri.THE_INSTANCE; } else if (\"iri-ref\".equals(typeLocalName)) { return IriRef.THE_INSTANCE; } else if (\"string\".equals(typeLocalName)) { return AsciiCaseInsensitiveString.THE_INSTANCE; } else if (\"language\".equals(typeLocalName)) { return Language.THE_INSTANCE; } else if (\"media-query\".equals(typeLocalName)) { return MediaQuery.THE_INSTANCE; } else if (\"mime-type\".equals(typeLocalName)) { return MimeType.THE_INSTANCE; } else if (\"browsing-context\".equals(typeLocalName)) { return BrowsingContext.THE_INSTANCE; } else if (\"browsing-context-or-keyword\".equals(typeLocalName)) { return BrowsingContextOrKeyword.THE_INSTANCE; } else if (\"hash-name\".equals(typeLocalName)) { return HashName.THE_INSTANCE; } else if (\"integer\".equals(typeLocalName)) { return Int.THE_INSTANCE; } else if (\"integer-non-negative\".equals(typeLocalName)) { return IntNonNegative.THE_INSTANCE; } else if (\"integer-positive\".equals(typeLocalName)) { return IntPositive.THE_INSTANCE; } else if (\"float\".equals(typeLocalName)) { return FloatingPointExponent.THE_INSTANCE; } else if (\"float-non-negative\".equals(typeLocalName)) { return FloatingPointExponentNonNegative.THE_INSTANCE; } else if (\"float-positive\".equals(typeLocalName)) { return FloatingPointExponentPositive.THE_INSTANCE; } else if (\"mime-type-list\".equals(typeLocalName)) { return MimeTypeList.THE_INSTANCE; } else if (\"circle\".equals(typeLocalName)) { return Circle.THE_INSTANCE; } else if (\"rectangle\".equals(typeLocalName)) { return Rectangle.THE_INSTANCE; } else if (\"polyline\".equals(typeLocalName)) { return Polyline.THE_INSTANCE; } else if (\"xml-name\".equals(typeLocalName)) { return XmlName.THE_INSTANCE; } else if (\"meta-charset\".equals(typeLocalName)) { return MetaCharset.THE_INSTANCE; } else if (\"microdata-property\".equals(typeLocalName)) { return MicrodataProperty.THE_INSTANCE; } else if (\"charset\".equals(typeLocalName)) { return Charset.THE_INSTANCE; } else if (\"refresh\".equals(typeLocalName)) { return Refresh.THE_INSTANCE; } else if (\"paren-start\".equals(typeLocalName)) { return ParenthesisStart.THE_INSTANCE; } else if (\"paren-end\".equals(typeLocalName)) { return ParenthesisEnd.THE_INSTANCE; } else if (\"email-address\".equals(typeLocalName)) { return EmailAddress.THE_INSTANCE; } else if (\"email-address-list\".equals(typeLocalName)) { return EmailAddressList.THE_INSTANCE; } else if (\"keylabellist\".equals(typeLocalName)) { return KeyLabelList.THE_INSTANCE; } else if (\"zero\".equals(typeLocalName)) { return Zero.THE_INSTANCE; } else if (\"cdo-cdc-pair\".equals(typeLocalName)) { return CdoCdcPair.THE_INSTANCE; } else if (\"script\".equals(typeLocalName)) { return Script.THE_INSTANCE; } else if (\"script-documentation\".equals(typeLocalName)) { return ScriptDocumentation.THE_INSTANCE; } else if (\"functionbody\".equals(typeLocalName)) { return FunctionBody.THE_INSTANCE; } else if (\"a-rel\".equals(typeLocalName)) { return ARel.THE_INSTANCE; } else if (\"link-rel\".equals(typeLocalName)) { return LinkRel.THE_INSTANCE; } else if (\"meta-name\".equals(typeLocalName)) { return MetaName.THE_INSTANCE; } else if (\"non-empty-string\".equals(typeLocalName)) { return NonEmptyString.THE_INSTANCE; } else if (\"string-without-line-breaks\".equals(typeLocalName)) { return StringWithoutLineBreaks.THE_INSTANCE; } else if (\"simple-color\".equals(typeLocalName)) { return SimpleColor.THE_INSTANCE; } else if (\"time-datetime\".equals(typeLocalName)) { return TimeDatetime.THE_INSTANCE; } else if (\"svg-pathdata\".equals(typeLocalName)) { return new SvgPathData(); } throw new DatatypeException(\"Unknown local name for datatype: \" + typeLocalName); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory;  public class Html5DatatypeLibraryFactory implements DatatypeLibraryFactory {  private static final String NAMESPACE = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class Id extends AbstractDatatype {  public static final Id THE_INSTANCE = new Id();  protected Id() { super(); }  public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); if (len == 0) { throw newDatatypeException(\"An ID must not be the empty string.\"); } for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (isWhitespace(c)) { throw newDatatypeException(i, \"An ID must not contain whitespace.\"); } } } @Override public String getName() { return \"id\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype;  public final class Idref extends Id {  public static final Idref THE_INSTANCE = new Idref();  private Idref() { super(); } @Override public String getName() { return \"id reference\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public final class Idrefs extends AbstractDatatype {  public static final Idrefs THE_INSTANCE = new Idrefs();  private Idrefs() { super(); }  public void checkValid(CharSequence literal) throws DatatypeException { for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isWhitespace(c)) { return; } } throw newDatatypeException(\"An IDREFS value must contain at least one non-whitespace character.\"); } @Override public String getName() { return \"id references\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Int extends AbstractInt {  public static final Int THE_INSTANCE = new Int();  private Int() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkInt(literal, 0); } @Override public String getName() { return \"integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class IntNonNegative extends AbstractInt {  public static final IntNonNegative THE_INSTANCE = new IntNonNegative();  private IntNonNegative() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkIntNonNegative(literal, 0); } @Override public String getName() { return \"non-negative integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class IntPositive extends AbstractInt {  public static final IntPositive THE_INSTANCE = new IntPositive();  private IntPositive() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkIntPositive(literal, 0); } @Override public String getName() { return \"positive integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; public class Iri extends IriRef {  public static final Iri THE_INSTANCE = new Iri(); protected Iri() { super(); } protected boolean isAbsolute() { return true; } @Override public String getName() { return \"absolute IRI\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.io.StringReader; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.RhinoException; import org.relaxng.datatype.DatatypeException; import org.whattf.io.DataUri; import org.whattf.io.DataUriException; import org.whattf.io.Utf8PercentDecodingReader; import com.hp.hpl.jena.iri.IRI; import com.hp.hpl.jena.iri.IRIException; import com.hp.hpl.jena.iri.IRIFactory; import com.hp.hpl.jena.iri.Violation; public class IriRef extends AbstractDatatype {  public static final IriRef THE_INSTANCE = new IriRef(); protected IriRef() { super(); } private final static boolean WARN = System.getProperty(\"org.whattf.datatype.warn\",\"\").equals(\"true\") ? true : false;  private enum KnownViolationCode { COMPATIBILITY_CHARACTER, CONTROL_CHARACTER, DNS_LABEL_DASH_START_OR_END, DOUBLE_WHITESPACE, EMPTY_SCHEME, HAS_PASSWORD, ILLEGAL_CHARACTER, ILLEGAL_PERCENT_ENCODING, IP_V4_HAS_FOUR_COMPONENTS, IP_V4_OCTET_RANGE, IP_V6_OR_FUTURE_ADDRESS_SYNTAX, NON_INITIAL_DOT_SEGMENT, NOT_DNS_NAME, PORT_SHOULD_NOT_BE_WELL_KNOWN, REQUIRED_COMPONENT_MISSING, SCHEME_MUST_START_WITH_LETTER, UNDEFINED_UNICODE_CHARACTER, UNICODE_WHITESPACE, UNREGISTERED_NONIETF_SCHEME_TREE, WHITESPACE, ZZZ_DUMMY_DEFAULT } private final CharSequencePair splitScheme(CharSequence iri) { StringBuilder sb = new StringBuilder(); Boolean atSchemeBeginning = true; for (int i = 0; i < iri.length(); i++) { char c = toAsciiLowerCase(iri.charAt(i)); if (atSchemeBeginning) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import java.util.Arrays; import com.ibm.icu.lang.UCharacter; public class KeyLabelList extends AbstractDatatype {  public static final KeyLabelList THE_INSTANCE = new KeyLabelList(); private KeyLabelList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { String[] keylabels = literal.toString().split(\"\\\\s+\"); Arrays.sort(keylabels); for (int i = 0; i < keylabels.length; i++) { String label = keylabels[i]; if (i > 0 && label.equals(keylabels[i-1])) { throw newDatatypeException( \"Duplicate key label. Each key label must be unique.\"); } if (label.length() == 2) { char[] chars = label.toCharArray(); if (!(UCharacter.isHighSurrogate(chars[0]) && UCharacter.isLowSurrogate(chars[1]))) { throw newDatatypeException( \"Key label has multiple characters. Each key label must be a single character.\"); } } if (label.length() > 2) { throw newDatatypeException( \"Key label has multiple characters. Each key label must be a single character.\"); } } } @Override public String getName() { return \"key label list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException; import org.whattf.datatype.data.LanguageData;  public final class Language extends AbstractDatatype {  public static final Language THE_INSTANCE = new Language(); private static final Pattern HYPHEN = Pattern.compile(\"-\"); private static final boolean WARN = System.getProperty( \"org.whattf.datatype.warn\", \"\").equals(\"true\") ? true : false; private static String[] languages = null; private static String[] extlangs = null; private static String[] scripts = null; private static String[] regions = null; private static String[] variants = null; private static String[] grandfathered = null; private static String[] redundant = null; private static String[] deprecated = null; private static String[] deprecatedLang = null; private static int[] suppressedScriptByLanguage = null; private static Map<String, String> preferredValueByLanguageMap = new HashMap<String, String>(); private static String[][][] prefixesByVariant = null; private static int[] prefixByExtlang = null; static { try { LanguageData data = new LanguageData(); languages = data.getLanguages(); extlangs = data.getExtlangs(); scripts = data.getScripts(); regions = data.getRegions(); variants = data.getVariants(); grandfathered = data.getGrandfathered(); redundant = data.getRedundant(); deprecated = data.getDeprecated(); deprecatedLang = data.getDeprecatedLang(); suppressedScriptByLanguage = data.getSuppressedScriptByLanguage(); prefixByExtlang = data.getPrefixByExtlang(); preferredValueByLanguageMap = data.getPreferredValueByLanguageMap(); prefixesByVariant = data.getPrefixesByVariant(); } catch (IOException e) { throw new RuntimeException(e); } }  private Language() { super(); } public void checkValid(CharSequence lit) throws DatatypeException { String literal = lit.toString(); if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid language tag.\"); } literal = toAsciiLowerCase(literal); if (isGrandfathered(literal)) { if (isDeprecated(literal) && WARN) { throw newDatatypeException(\"The grandfathered language tag \", literal, \" is deprecated.\" + \" Use \\u201C\" + preferredValueByLanguageMap.get(literal) + \"\\u201D instead.\", WARN); } return; } if (isRedundant(literal)) { if (isDeprecated(literal) && WARN) { throw newDatatypeException(\"The language tag \", lit.toString(), \" is deprecated.\" + \" Use \\u201C\" + preferredValueByLanguageMap.get(literal) + \"\\u201D instead.\", WARN); } return; } if (literal.startsWith(\"-\")) { throw newDatatypeException(\"Language tag must not start with HYPHEN-MINUS.\"); } if (literal.endsWith(\"-\")) { throw newDatatypeException(\"Language tag must not end with HYPHEN-MINUS.\"); } String[] subtags = HYPHEN.split(literal); for (int j = 0; j < subtags.length; j++) { int len = subtags[j].length(); if (len == 0) { throw newDatatypeException(\"Zero-length subtag.\"); } else if (len > 8) { throw newDatatypeException(\"Subtags must not exceed 8 characters in length.\"); } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; public class LinkRel extends AbstractRel { private static final String[] REGISTERED_TOKENS = { \"alternate\", \"appendix\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.Set; import org.relaxng.datatype.DatatypeException; public class MediaQuery extends AbstractDatatype {  public static final MediaQuery THE_INSTANCE = new MediaQuery(); private static final boolean WARN = System.getProperty( \"org.whattf.datatype.warn\", \"\").equals(\"true\") ? true : false; private enum State { INITIAL_WS, OPEN_PAREN_SEEN, IN_ONLY_OR_NOT, IN_MEDIA_TYPE, IN_MEDIA_FEATURE, WS_BEFORE_MEDIA_TYPE, WS_BEFORE_AND, IN_AND, WS_BEFORE_EXPRESSION, WS_BEFORE_COLON, WS_BEFORE_VALUE, IN_VALUE_DIGITS, IN_VALUE_SCAN, IN_VALUE_ORIENTATION, WS_BEFORE_CLOSE_PAREN, IN_VALUE_UNIT, IN_VALUE_DIGITS_AFTER_DOT, RATIO_SECOND_INTEGER_START, IN_VALUE_BEFORE_DIGITS, IN_VALUE_DIGITS_AFTER_DOT_TRAIL, AFTER_CLOSE_PAREN, IN_VALUE_ONEORZERO } private enum ValueType { LENGTH, RATIO, INTEGER, RESOLUTION, SCAN, ORIENTATION, NONZEROINTEGER, ONEORZERO } private static final Set<String> LENGTH_UNITS = new HashSet<String>(); static { LENGTH_UNITS.add(\"em\"); LENGTH_UNITS.add(\"ex\"); LENGTH_UNITS.add(\"px\"); LENGTH_UNITS.add(\"gd\"); LENGTH_UNITS.add(\"rem\"); LENGTH_UNITS.add(\"vw\"); LENGTH_UNITS.add(\"vh\"); LENGTH_UNITS.add(\"vm\"); LENGTH_UNITS.add(\"ch\"); LENGTH_UNITS.add(\"in\"); LENGTH_UNITS.add(\"cm\"); LENGTH_UNITS.add(\"mm\"); LENGTH_UNITS.add(\"pt\"); LENGTH_UNITS.add(\"pc\"); } private static final Set<String> MEDIA_TYPES = new HashSet<String>(); static { MEDIA_TYPES.add(\"all\"); MEDIA_TYPES.add(\"aural\"); MEDIA_TYPES.add(\"braille\"); MEDIA_TYPES.add(\"handheld\"); MEDIA_TYPES.add(\"print\"); MEDIA_TYPES.add(\"projection\"); MEDIA_TYPES.add(\"screen\"); MEDIA_TYPES.add(\"tty\"); MEDIA_TYPES.add(\"tv\"); MEDIA_TYPES.add(\"embossed\"); MEDIA_TYPES.add(\"speech\"); } private enum MediaType { ALL, AURAL, BRAILLE, HANDHELD, PRINT, PROJECTION, SCREEN, TTY, TV, EMBOSSED, SPEECH, INVALID; private static MediaType toCaps(String str) { try { return valueOf(toAsciiUpperCase(str)); } catch (Exception ex) { return INVALID; } } } private static final Map<String, ValueType> FEATURES_TO_VALUE_TYPES = new HashMap<String, ValueType>(); static { FEATURES_TO_VALUE_TYPES.put(\"width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"min-device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"max-device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"min-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"max-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"min-resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"max-resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"scan\", ValueType.SCAN); FEATURES_TO_VALUE_TYPES.put(\"orientation\", ValueType.ORIENTATION); FEATURES_TO_VALUE_TYPES.put(\"grid\", ValueType.ONEORZERO); } private static final String[] visualFeatures = { \"aspect-ratio\", \"color\", \"color-index\", \"device-aspect-ratio\", \"max-aspect-ratio\", \"max-color\", \"max-color-index\", \"max-device-aspect-ratio\", \"max-monochrome\", \"max-resolution\", \"min-aspect-ratio\", \"min-color\", \"min-color-index\", \"min-device-aspect-ratio\", \"min-monochrome\", \"min-resolution\", \"monochrome\", \"orientation\", \"resolution\", }; private static final String[] bitmapFeatures = { \"aspect-ratio\", \"device-aspect-ratio\", \"max-aspect-ratio\", \"max-device-aspect-ratio\", \"max-resolution\", \"min-aspect-ratio\", \"min-device-aspect-ratio\", \"min-resolution\", \"orientation\", \"resolution\", }; private static final String scanWarning = \"The media feature \\u201cscan\\u201d is applicable only to the media type \\u201ctv\\u201d. \"; private MediaQuery() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<String> warnings = new ArrayList<String>(); List<CharSequenceWithOffset> queries = split(literal, ','); for (CharSequenceWithOffset query : queries) { warnings = checkQuery(query.getSequence(), query.getOffset(), warnings); } if (!warnings.isEmpty() && WARN) { StringBuilder sb = new StringBuilder(); for (String s : warnings) { sb.append(s + \" \"); } throw newDatatypeException(sb.toString().trim(), WARN); } } private List<String> checkQuery(CharSequence query, int offset, List<String> warnings) throws DatatypeException { boolean containsAural = false; boolean zero = true; String type = null; String feature = null; ValueType valueExpectation = null; query = toAsciiLowerCase(query); StringBuilder sb = new StringBuilder(); State state = State.INITIAL_WS; for (int i = 0; i < query.length(); i++) { char c = query.charAt(i); switch (state) { case INITIAL_WS: if (isWhitespace(c)) { continue; } else if ('(' == c) { state = State.OPEN_PAREN_SEEN; continue; } else if ('o' == c || 'n' == c) { sb.append(c); state = State.IN_ONLY_OR_NOT; continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_TYPE; continue; } else { throw newDatatypeException( offset + i, \"Expected \\u201C(\\u201D or letter at start of a media query part but saw \", c, \" instead.\"); } case IN_ONLY_OR_NOT: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c)) { String kw = sb.toString(); sb.setLength(0); if (\"only\".equals(kw) || \"not\".equals(kw)) { state = State.WS_BEFORE_MEDIA_TYPE; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201Conly\\u201D or \\u201Cnot\\u201D but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_MEDIA_TYPE: if (isWhitespace(c)) { continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_TYPE; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_MEDIA_TYPE: if (('a' <= c && 'z' >= c) || c == '-') { sb.append(c); continue; } else if (isWhitespace(c)) {  type = sb.toString(); sb.setLength(0); if (isMediaType(type)) { if (\"aural\".equals(type)) { containsAural = true; } state = State.WS_BEFORE_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected a CSS media type but saw \\u201C\" + type + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter, hyphen or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_AND: if (isWhitespace(c)) { continue; } else if ('a' == c) { sb.append(c); state = State.IN_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or \\u201Cand\\u201D but saw\" + \" \\u201C\" + c + \"\\u201D instead.\"); } case IN_AND: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c)) { String kw = sb.toString(); sb.setLength(0); if (\"and\".equals(kw)) { state = State.WS_BEFORE_EXPRESSION; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201Cand\\u201D but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_EXPRESSION: if (isWhitespace(c)) { continue; } else if ('(' == c) { state = State.OPEN_PAREN_SEEN; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201C(\\u201D or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case OPEN_PAREN_SEEN: if (isWhitespace(c)) { continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_FEATURE; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter at start of a media feature part but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_MEDIA_FEATURE: if (('a' <= c && 'z' >= c) || c == '-') { sb.append(c); continue; } else if (c == ')') { String kw = sb.toString(); sb.setLength(0); checkApplicability(offset + i, kw, type, warnings); checkIfValueRequired(offset + i, kw); state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c) || c == ':') { String kw = sb.toString(); sb.setLength(0); checkApplicability(offset + i, kw, type, warnings); feature = kw; valueExpectation = valueExpectationFor(kw); if (valueExpectation != null) { if (c == ':') { state = State.WS_BEFORE_VALUE; continue; } else { state = State.WS_BEFORE_COLON; continue; } } else { throw newDatatypeException(offset + i, \"Expected a CSS media feature but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter, hyphen, colon or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_COLON: if (isWhitespace(c)) { continue; } else if (':' == c) { state = State.WS_BEFORE_VALUE; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or colon but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_VALUE: if (isWhitespace(c)) { continue; } else { zero = true; switch (valueExpectation) { case SCAN: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_SCAN; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter but saw \\u201C\" + c + \"\\u201D instead.\"); } case ORIENTATION: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_ORIENTATION; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter but saw \\u201C\" + c + \"\\u201D instead.\"); } case ONEORZERO: if (c == '0' || c == '1') { sb.append(c); state = State.IN_VALUE_ONEORZERO; continue; } else { throw newDatatypeException( offset + i, \"Expected \\u201C0\\u201D or \\u201C1\\u201D as \\u201c\" + feature + \"\\u201d value but found \\u201C\" + c + \"\\u201D instead.\"); } default: if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else if ('0' == c) { state = State.IN_VALUE_DIGITS; continue; } else if ('+' == c) { state = State.IN_VALUE_BEFORE_DIGITS; continue; } else if ('.' == c && valueExpectation == ValueType.LENGTH) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Expected a digit, a dot or a plus sign but saw \\u201C\" + c + \"\\u201D instead.\"); } else { throw newDatatypeException(offset + i, \"Expected a digit or a plus sign but saw \\u201C\" + c + \"\\u201D instead.\"); } } } case IN_VALUE_SCAN: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (!(\"progressive\".equals(kw) || \"interlace\".equals(kw))) { throw newDatatypeException( offset + i, \"Expected \\u201Cprogressive\\u201D or \\u201Cinterlace\\u201D as the scan mode value but saw \\u201C\" + kw + \"\\u201D instead.\"); } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_ORIENTATION: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (!(\"portrait\".equals(kw) || \"landscape\".equals(kw))) { throw newDatatypeException( offset + i, \"Expected \\u201Cportrait\\u201D or \\u201Clandscape\\u201D as the \\u201corientation\\u201d value but saw \\u201C\" + kw + \"\\u201D instead.\"); } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_ONEORZERO: if (isWhitespace(c) || c == ')') { sb.setLength(0); if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { sb.append(c); String kw = sb.toString(); throw newDatatypeException(offset + i, \"Expected \\u201C0\\u201D or \\u201C1\\u201D as \\u201c\" + feature + \"\\u201d value but saw \\u201C\" + kw + \"\\u201D instead.\"); } case IN_VALUE_BEFORE_DIGITS: if ('0' == c) { state = State.IN_VALUE_DIGITS; continue; } else if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('.' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else { throw newDatatypeException(offset + i, \"Expected a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case INTEGER: case RATIO: throw newDatatypeException(offset + i, \"Expected a digit but saw \\u201C\" + c + \"\\u201D instead.\"); default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_DIGITS: if ('0' == c) { continue; } else if ('1' <= c && '9' >= c) { zero = false; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('.' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_UNIT; continue; } else if (isWhitespace(c) || c == ')') { if (!zero) { if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Non-zero lengths require a unit.\"); } else { throw newDatatypeException(offset + i, \"Non-zero resolutions require a unit.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case INTEGER: if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case NONZEROINTEGER: if (c == ')') { if (zero) { throw newDatatypeException(offset + i, \"Expected a non-zero positive integer.\"); } state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case RATIO: if (isWhitespace(c)) { continue; } else if (c == '/') { if (zero) { throw newDatatypeException(offset + i, \"Expected non-zero positive integer in ratio value.\"); } valueExpectation = ValueType.NONZEROINTEGER; state = State.RATIO_SECOND_INTEGER_START; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or\" + \" \\u201C/\\u201D for \" + feature + \" value but saw \\u201C\" + c + \"\\u201D instead.\"); } default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_DIGITS_AFTER_DOT: if ('0' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT_TRAIL; continue; } else if ('1' <= c && '9' >= c) { state = State.IN_VALUE_DIGITS_AFTER_DOT_TRAIL; zero = false; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_DIGITS_AFTER_DOT_TRAIL: if ('0' == c) { continue; } else if ('1' <= c && '9' >= c) { zero = false; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_UNIT; continue; } else if (isWhitespace(c) || c == ')') { if (!zero) { if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Non-zero lengths require a unit.\"); } else { throw newDatatypeException(offset + i, \"Non-zero resolutions require a unit.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_UNIT: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (valueExpectation == ValueType.LENGTH) { if (!isLengthUnit(kw)) { throw newDatatypeException(offset + i, \"Expected a length unit but saw \\u201C\" + c + \"\\u201D instead.\"); } } else { if (!(\"dpi\".equals(kw) || \"dpcm\".equals(kw))) { throw newDatatypeException(offset + i, \"Expected a resolution unit but saw \\u201C\" + c + \"\\u201D instead.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case RATIO_SECOND_INTEGER_START: valueExpectation = ValueType.NONZEROINTEGER; if (isWhitespace(c)) { continue; } else if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else if ('0' == c) { zero = true; state = State.IN_VALUE_DIGITS; continue; } else if ('+' == c) { state = State.IN_VALUE_BEFORE_DIGITS; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or a plus sign\" + \" for \" + feature + \" value but saw \\u201C\" + c + \"\\u201D instead.\"); } case AFTER_CLOSE_PAREN: if (isWhitespace(c)) { state = State.WS_BEFORE_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_CLOSE_PAREN: if (isWhitespace(c)) { continue; } else if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } } } switch (state) { case AFTER_CLOSE_PAREN: case WS_BEFORE_AND: if (containsAural && WARN) { warnings.add(\"The media type \\u201caural\\u201d is deprecated. Use \\u201cspeech\\u201d instead. \"); } return warnings; case IN_MEDIA_TYPE: String kw = sb.toString(); sb.setLength(0); if (isMediaType(kw)) { if (\"aural\".equals(kw) && WARN) { warnings.add(\"The media type \\u201caural\\u201d is deprecated. Use \\u201cspeech\\u201d instead. \"); } return warnings; } else { throw newDatatypeException(\"Expected a CSS media type but the query ended.\"); } default: throw newDatatypeException(\"Media query ended prematurely.\"); } } private boolean isMediaFeature(String feature) { return FEATURES_TO_VALUE_TYPES.containsKey(feature); } private ValueType valueExpectationFor(String feature) { return FEATURES_TO_VALUE_TYPES.get(feature); } private boolean isMediaType(String type) { return MEDIA_TYPES.contains(type); } private boolean isLengthUnit(String unit) { return LENGTH_UNITS.contains(unit); } private List<String> checkApplicability(int index, String feature, String type, List<String> warnings) throws DatatypeException { if (!isMediaType(type)) { return warnings; } if (!isMediaFeature(feature)) { throw newDatatypeException(index, \"Expected a CSS media feature but saw \\u201C\" + feature + \"\\u201D instead.\"); } if (\"scan\".equals(feature) && !\"tv\".equals(type)) { warnings.add(scanWarning); return warnings; } switch (MediaType.toCaps(type)) { case SPEECH: warnings.add(\"The media feature \\u201c\" + feature + \"\\u201d is not applicable to the media type \\u201cspeech\\u201d. \"); return warnings; case BRAILLE: case EMBOSSED: if (Arrays.binarySearch(visualFeatures, feature) > -1) { warnings.add(\"The visual media feature \\u201c\" + feature + \"\\u201d is not applicable to the tactile media type \\u201c\" + type + \"\\u201d. \"); } return warnings; case TTY: if (Arrays.binarySearch(bitmapFeatures, feature) > -1) { warnings.add(\"The bitmap media feature \\u201c\" + feature + \"\\u201d is not applicable to the media type \\u201ctty\\u201d. \"); } return warnings; default: return warnings; } } private void checkIfValueRequired(int index, String feature) throws DatatypeException { if (feature.startsWith(\"min-\") || feature.startsWith(\"max-\")) { throw newDatatypeException(index, \"Expected a value for the media feature \\u201C\" + feature + \"\\u201D.\"); } } @Override public String getName() { return \"media query\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.whattf.datatype.data.CharsetData; import org.relaxng.datatype.DatatypeException; public class MetaCharset extends AbstractDatatype {  public static final MetaCharset THE_INSTANCE = new MetaCharset(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import org.relaxng.datatype.DatatypeException; public class MetaName extends AbstractDatatype { private static final String[] VALID_NAMES = { \"aglsterms.act\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class MicrodataProperty extends Iri {  public static final MicrodataProperty THE_INSTANCE = new MicrodataProperty(); protected MicrodataProperty() { super(); } @Override public String getName() { return \"microdata property\"; } @Override public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (c == '.' || c == ':') { super.checkValid(literal); break; } } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class MimeType extends AbstractDatatype {  public static final MimeType THE_INSTANCE = new MimeType(); private enum State { AT_START, IN_SUPERTYPE, AT_SUBTYPE_START, IN_SUBTYPE, SEMICOLON_SEEN, WS_BEFORE_SEMICOLON, IN_PARAM_NAME, EQUALS_SEEN, IN_QUOTED_STRING, IN_UNQUOTED_STRING, IN_QUOTED_PAIR, CLOSE_QUOTE_SEEN } private MimeType() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (isTokenChar(c)) { state = State.IN_SUPERTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character but saw \", c, \" instead.\"); } case IN_SUPERTYPE: if (isTokenChar(c)) { continue; } else if (c == '/') { state = State.AT_SUBTYPE_START; continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C/\\u201D but saw \", c, \" instead.\"); } case AT_SUBTYPE_START: if (isTokenChar(c)) { state = State.IN_SUBTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character but saw \", c, \" instead.\"); } case IN_SUBTYPE: if (isTokenChar(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a semicolon but saw \", c, \" instead.\"); } case WS_BEFORE_SEMICOLON: if (isWhitespace(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else { throw newDatatypeException(i, \"Expected whitespace or a semicolon but saw \", c, \" instead.\"); } case SEMICOLON_SEEN: if (isWhitespace(c)) { continue; } else if (isTokenChar(c)) { state = State.IN_PARAM_NAME; continue; } else { throw newDatatypeException(i, \"Expected whitespace or a token character but saw \", c, \" instead.\"); } case IN_PARAM_NAME: if (isTokenChar(c)) { continue; } else if (c == '=') { state = State.EQUALS_SEEN; continue; } case EQUALS_SEEN: if (c == '\\\"') { state = State.IN_QUOTED_STRING; continue; } else if (isTokenChar(c)) { state = State.IN_UNQUOTED_STRING; continue; } else { throw newDatatypeException(i, \"Expected a double quote or a token character but saw \", c, \" instead.\"); } case IN_QUOTED_STRING: if (c == '\\\\') { state = State.IN_QUOTED_PAIR; continue; } else if (c == '\\\"') { state = State.CLOSE_QUOTE_SEEN; continue; } else if (isQDTextChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a non-control ASCII character but saw \", c, \" instead.\"); } case IN_QUOTED_PAIR: if (c <= 127) { state = State.IN_QUOTED_STRING; continue; } else { throw newDatatypeException(i, \"Expected an ASCII character but saw \", c, \" instead.\"); } case CLOSE_QUOTE_SEEN: if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected an ASCII character but saw \", c, \" instead.\"); } case IN_UNQUOTED_STRING: if (isTokenChar(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a semicolon but saw \", c, \" instead.\"); } } } switch (state) { case IN_SUBTYPE: case IN_UNQUOTED_STRING: case CLOSE_QUOTE_SEEN: return; case AT_START: throw newDatatypeException( \"Expected a MIME type but saw the empty string.\"); case IN_SUPERTYPE: case AT_SUBTYPE_START: throw newDatatypeException(literal.length() - 1, \"Subtype missing.\"); case EQUALS_SEEN: case IN_PARAM_NAME: throw newDatatypeException(literal.length() - 1, \"Parameter value missing.\"); case IN_QUOTED_PAIR: case IN_QUOTED_STRING: throw newDatatypeException(literal.length() - 1, \"Unfinished quoted string.\"); case SEMICOLON_SEEN: throw newDatatypeException(literal.length() - 1, \"Semicolon seen but there was no parameter following it.\"); case WS_BEFORE_SEMICOLON: throw newDatatypeException(literal.length() - 1, \"Extraneous trailing whitespace.\"); } } private boolean isQDTextChar(char c) { return (c >= ' ' && c <= 126) || (c == '\\n') || (c == '\\r') || (c == '\\t'); } private boolean isTokenChar(char c) { return (c >= 33 && c <= 126) && !(c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\\\' || c == '\\\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}'); } @Override public String getName() { return \"MIME type\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class MimeTypeList extends AbstractDatatype {  public static final MimeTypeList THE_INSTANCE = new MimeTypeList(); private enum State { WS_BEFORE_TYPE, IN_TYPE, ASTERISK_TYPE_SEEN, ASTERISK_AND_SLASH_SEEN, WS_BEFORE_COMMA, SLASH_SEEN, IN_SUBTYPE } private MimeTypeList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.WS_BEFORE_TYPE; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case WS_BEFORE_TYPE: if (isWhitespace(c)) { continue; } else if (c == '*') { state = State.ASTERISK_TYPE_SEEN; } else if (isTokenChar(c)) { state = State.IN_TYPE; continue; } else { throw newDatatypeException(i, \"Expected whitespace, a token character or \\u201C*\\u201D but saw \", c , \" instead.\"); } case ASTERISK_TYPE_SEEN: if (c == '/') { state = State.ASTERISK_AND_SLASH_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201C/\\u201D but saw \", c , \" instead.\"); } case ASTERISK_AND_SLASH_SEEN: if (c == '*') { state = State.WS_BEFORE_COMMA; continue; } else { throw newDatatypeException(i, \"Expected \\u201C*\\u201D but saw \", c , \" instead.\"); } case IN_TYPE: if (c == '/') { state = State.SLASH_SEEN; continue; } else if (isTokenChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C/\\u201D but saw \", c , \" instead.\"); } case SLASH_SEEN: if (c == '*') { state = State.WS_BEFORE_COMMA; continue; } else if (isTokenChar(c)) { state = State.IN_SUBTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C*\\u201D but saw \", c , \" instead.\"); } case IN_SUBTYPE: if (isWhitespace(c)) { state = State.WS_BEFORE_COMMA; continue; } else if (c == ',') { state = State.WS_BEFORE_TYPE; continue; } else if (isTokenChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a comma but saw \", c , \" instead.\"); } case WS_BEFORE_COMMA: if (c == ',') { state = State.WS_BEFORE_TYPE; continue; } else if (isWhitespace(c)) { continue; } else { throw newDatatypeException(i, \"Expected whitespace or a comma but saw \", c , \" instead.\"); } } } switch (state) { case IN_SUBTYPE: case WS_BEFORE_COMMA: return; case ASTERISK_AND_SLASH_SEEN: throw newDatatypeException(\"Expected \\u201C*\\u201D but the literal ended.\"); case ASTERISK_TYPE_SEEN: throw newDatatypeException(\"Expected \\u201C/\\u201D but the literal ended.\"); case IN_TYPE: throw newDatatypeException(\"Expected \\u201C/\\u201D but the literal ended.\"); case SLASH_SEEN: throw newDatatypeException(\"Expected subtype but the literal ended.\"); case WS_BEFORE_TYPE: throw newDatatypeException(\"Expected a MIME type but the literal ended.\"); } } private boolean isTokenChar(char c) { return (c >= 33 && c <= 126) && !(c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\\\' || c == '\\\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}'); } @Override public String getName() { return \"MIME type list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  public final class Month extends AbstractDatatype {  public static final Month THE_INSTANCE = new Month();  private static final Pattern THE_PATTERN = Pattern.compile(\"^([0-9]{4,})-([0-9]{2})$\");  private Month() { super(); } private void checkMonth(String year, String month) throws DatatypeException { checkMonth(Integer.parseInt(year), Integer.parseInt(month)); } private void checkMonth(int year, int month) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } } public final void checkValid(CharSequence literal) throws DatatypeException { Matcher m = THE_PATTERN.matcher(literal); if (m.matches()) { checkMonth(m.group(1), m.group(2)); } else { throw newDatatypeException( \"The literal did not satisfy the format for month.\"); } } @Override public String getName() { return \"month\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class NonEmptyString extends AbstractDatatype {  public static final NonEmptyString THE_INSTANCE = new NonEmptyString();  private NonEmptyString() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Must not be empty.\"); } } @Override public String getName() { return \"non-empty string\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import com.ibm.icu.text.UnicodeSet; public class ParenthesisEnd extends AbstractUnicodeClassCharacter { private static final UnicodeSet UNICODE_SET = new UnicodeSet(\"[:Pe:]\");  public static final ParenthesisEnd THE_INSTANCE = new ParenthesisEnd(); private ParenthesisEnd() { } @Override public String getName() { return \"end parenthesis\"; } @Override protected UnicodeSet getUnicodeSet() { return UNICODE_SET; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import com.ibm.icu.text.UnicodeSet; public class ParenthesisStart extends AbstractUnicodeClassCharacter { private static final UnicodeSet UNICODE_SET = new UnicodeSet(\"[:Ps:]\");  public static final ParenthesisStart THE_INSTANCE = new ParenthesisStart(); private ParenthesisStart() { } @Override public String getName() { return \"start parenthesis\"; } @Override protected UnicodeSet getUnicodeSet() { return UNICODE_SET; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.EcmaError; import org.mozilla.javascript.regexp.RegExpImpl; import org.relaxng.datatype.DatatypeException; /** * This datatype shall accept the strings that are allowed as the value of the Web Forms 2.0 * <a href=\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Polyline extends AbstractInt {  public static final Polyline THE_INSTANCE = new Polyline();  private Polyline() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() < 6) { throw newDatatypeException(\"A polyline must have at least six comma-separated integers.\"); } if (list.size() % 2 != 0) { throw newDatatypeException(\"A polyline must have an even number of comma-separated integers.\"); } for (CharSequenceWithOffset item : list) { checkInt(item.getSequence(), item.getOffset()); } } @Override public String getName() { return \"polyline\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Rectangle extends AbstractInt {  public static final Rectangle THE_INSTANCE = new Rectangle();  private Rectangle() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() != 4) { throw newDatatypeException(\"A rectangle must have four comma-separated integers.\"); } for (CharSequenceWithOffset item : list) { checkInt(item.getSequence(), item.getOffset()); } if (Integer.parseInt(list.get(0).getSequence().toString()) >= Integer.parseInt(list.get(2).getSequence().toString())) { throw newDatatypeException(\"The first integer must be less than the third.\"); } if (Integer.parseInt(list.get(1).getSequence().toString()) >= Integer.parseInt(list.get(3).getSequence().toString())) { throw newDatatypeException(\"The second integer must be less than the fourth.\"); } } @Override public String getName() { return \"rectangle\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public final class Refresh extends IriRef {  public static final Refresh THE_INSTANCE = new Refresh(); private Refresh() { super(); } private enum State { AT_START, DIGIT_SEEN, SEMICOLON_SEEN, SPACE_SEEN, U_SEEN, R_SEEN, L_SEEN, EQUALS_SEEN } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Empty literal.\"); } State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (isAsciiDigit(c)) { state = State.DIGIT_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit, but saw \", c, \" instead.\"); } case DIGIT_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit or a semicolon, but saw \", c, \" instead.\"); } case SEMICOLON_SEEN: if (isWhitespace(c)) { state = State.SPACE_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a space character, but saw \", c, \" instead.\"); } case SPACE_SEEN: if (isWhitespace(c)) { continue; } else if (c == 'u' || c == 'U') { state = State.U_SEEN; continue; } else { throw newDatatypeException( i, \"Expected a space character or the letter \\u201Cu\\u201D, but saw \", c, \" instead.\"); } case U_SEEN: if (c == 'r' || c == 'R') { state = State.R_SEEN; continue; } else { throw newDatatypeException(i, \"Expected the letter \\u201Cr\\u201D, but saw \", c, \" instead.\"); } case R_SEEN: if (c == 'l' || c == 'L') { state = State.L_SEEN; continue; } else { throw newDatatypeException(i, \"Expected the letter \\u201Cl\\u201D, but saw \", c, \" instead.\"); } case L_SEEN: if (c == '=') { state = State.EQUALS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201C=\\u201D, but saw \", c, \" instead.\"); } case EQUALS_SEEN: if (c == '\"' || c == '\\'') { throw newDatatypeException( \"Expected an unquoted IRI reference, but saw \", c, \" instead.\"); } if (' ' == c || '\\t' == c || '\\n' == c || '\\f' == c || '\\r' == c) { throw newDatatypeException(\"Expected an IRI reference, but saw whitespace instead.\"); } char l = literal.charAt(literal.length() - 1); if (' ' == l || '\\t' == l || '\\n' == l || '\\f' == l || '\\r' == l) { throw newDatatypeException(\"Trailing whitespace.\"); } super.checkValid(literal.subSequence(i, literal.length())); return; } } switch (state) { case AT_START: throw newDatatypeException(\"Expected a digit, but the literal ended.\"); case DIGIT_SEEN: return; case SEMICOLON_SEEN: throw newDatatypeException(\"Expected a space character, but the literal ended.\"); case SPACE_SEEN: throw newDatatypeException(\"Expected a space character or the letter \\u201Cu\\u201D, but the literal ended.\"); case U_SEEN: throw newDatatypeException(\"Expected the letter \\u201Cr\\u201D, but the literal ended.\"); case R_SEEN: throw newDatatypeException(\"Expected the letter \\u201Cl\\u201D, but the literal ended.\"); case L_SEEN: throw newDatatypeException(\"Expected \\u201C=\\u201D, but the literal ended.\"); case EQUALS_SEEN: throw newDatatypeException(\"Expected an IRI reference, but the literal ended.\"); } } @Override public String getName() { return \"refresh\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Script extends CdoCdcPair {  public static final Script THE_INSTANCE = new Script(); protected Script() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public final class ScriptDocumentation extends Script { private enum State { BEFORE_DOCUMENTATION, SLASH, IN_COMMENT, IN_LINE_COMMENT, STAR }  public static final ScriptDocumentation THE_INSTANCE = new ScriptDocumentation(); private ScriptDocumentation() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.BEFORE_DOCUMENTATION; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case BEFORE_DOCUMENTATION: switch (c) { case ' ': case '\\t': case '\\n': continue; case '/': if (i == literal.length() - 1) { throw newDatatypeException(\"Expected asterisk or slash but content ended with a \" + \"single slash instead.\"); } state = State.SLASH; continue; default: throw newDatatypeException(\"Expected space, tab, newline, or slash but found \\u201c\" + c + \"\\u201d instead.\"); } case SLASH: switch (c) { case '*': state = State.IN_COMMENT; continue; case '/': state = State.IN_LINE_COMMENT; continue; default: throw newDatatypeException(\"Expected asterisk or slash but found \\u201c\" + c + \"\\u201d instead.\"); } case IN_COMMENT: switch (c) { case '*': state = State.STAR; continue; default: continue; } case STAR: switch (c) { case '/': state = State.BEFORE_DOCUMENTATION; continue; default: continue; } case IN_LINE_COMMENT: switch (c) { case '\\n': state = State.BEFORE_DOCUMENTATION; continue; default: continue; } default: throw newDatatypeException(\"Content ended prematurely.\"); } } if (state == State.IN_LINE_COMMENT) { throw newDatatypeException(\"Content contains a line starting with\" + \" the character sequence \\u201c"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class SimpleColor extends AbstractDatatype {  public static final SimpleColor THE_INSTANCE = new SimpleColor();  private SimpleColor() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() != 7) { throw newDatatypeException(\"Incorrect length for color string.\"); } char c = literal.charAt(0); if (c != '#') { throw newDatatypeException(0, \"Color starts with incorrect character \", c, \". Expected the number sign.\"); } for (int i = 1; i < 7; i++) { c = literal.charAt(i); if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) { throw newDatatypeException(0, \"\", c, \" is not a valid hexadecimal digit.\"); } } } @Override public String getName() { return \"simple color\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class StringWithoutLineBreaks extends AbstractDatatype {  public static final StringWithoutLineBreaks THE_INSTANCE = new StringWithoutLineBreaks();  private StringWithoutLineBreaks() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (c == '\\n') { throw newDatatypeException(i, \"Line feed not allowed.\"); } else if (c == '\\r') { throw newDatatypeException(i, \"Carriage return not allowed.\"); } } } @Override public String getName() { return \"string without line breaks\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "/* * Copyright 2000-2013 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  public final class Time extends AbstractDatetime {  public static final Time THE_INSTANCE = new Time();  private static final Pattern THE_PATTERN = Pattern.compile(\"^([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?$\");  private Time() { super(); } public void checkValid(CharSequence literal) throws DatatypeException { Matcher m = getPattern().matcher(literal); if (m.matches()) { checkHour(m.group(1)); checkMinute(m.group(2)); String seconds = m.group(3); if (seconds != null) { checkSecond(seconds); } } else { throw newDatatypeException( \"The literal did not satisfy the format for time.\"); } }  protected final Pattern getPattern() { return THE_PATTERN; } @Override public String getName() { return \"time\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; public class TimeDatetime extends AbstractDatetime {  public static final TimeDatetime THE_INSTANCE = new TimeDatetime(); public int i;  private static final Pattern THE_PATTERN = Pattern.compile(\"^[ \\\\t\\\\r\\\\n\\\\f]*(?:(?:([0-9]{4,})-([0-9]{2}))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2}))|(?:([0-9]{2})-([0-9]{2}))|(?:([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?)|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?)|(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2})))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2}))))|(?:([0-9]{4,})-W([0-9]{2}))|(?:([0-9]{4,}))|(?:P(?:(?:[0-9]+D)|(?:(?:[0-9]+D)?T[0-9]+H)|(?:(?:[0-9]+D)?T(?:[0-9]+H)?[0-9]+M)|(?:(?:[0-9]+D)?T(?:(?:[0-9]+)H)?(?:(?:[0-9]+)M)?(?:[0-9]+(?:\\\\.([0-9]+))?S))))|(?:[ \\\\t\\\\r\\\\n\\\\f]*[0-9]+(?:(?:[ \\\\t\\\\r\\\\n\\\\f]*(?:[Ww]|[Dd]|[Hh]|[Mm]))|(?:(?:\\\\.([0-9]+))?[ \\\\t\\\\r\\\\n\\\\f]*[Ss])))+)[ \\\\t\\\\r\\\\n\\\\f]*$\"); private TimeDatetime() { super(); } @Override protected Pattern getPattern() { return THE_PATTERN; } @Override public String getName() { return \"time-datetime\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException; /** * This datatype shall accept strings that conform to the format of * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class XmlName extends AbstractDatatype { public static boolean isNameStart(char c) { return ((c >= '\\u0041' && c <= '\\u005A') || (c >= '\\u0061' && c <= '\\u007A') || (c >= '\\u00C0' && c <= '\\u00D6') || (c >= '\\u00D8' && c <= '\\u00F6') || (c >= '\\u00F8' && c <= '\\u00FF') || (c >= '\\u0100' && c <= '\\u0131') || (c >= '\\u0134' && c <= '\\u013E') || (c >= '\\u0141' && c <= '\\u0148') || (c >= '\\u014A' && c <= '\\u017E') || (c >= '\\u0180' && c <= '\\u01C3') || (c >= '\\u01CD' && c <= '\\u01F0') || (c >= '\\u01F4' && c <= '\\u01F5') || (c >= '\\u01FA' && c <= '\\u0217') || (c >= '\\u0250' && c <= '\\u02A8') || (c >= '\\u02BB' && c <= '\\u02C1') || (c == '\\u0386') || (c >= '\\u0388' && c <= '\\u038A') || (c == '\\u038C') || (c >= '\\u038E' && c <= '\\u03A1') || (c >= '\\u03A3' && c <= '\\u03CE') || (c >= '\\u03D0' && c <= '\\u03D6') || (c == '\\u03DA') || (c == '\\u03DC') || (c == '\\u03DE') || (c == '\\u03E0') || (c >= '\\u03E2' && c <= '\\u03F3') || (c >= '\\u0401' && c <= '\\u040C') || (c >= '\\u040E' && c <= '\\u044F') || (c >= '\\u0451' && c <= '\\u045C') || (c >= '\\u045E' && c <= '\\u0481') || (c >= '\\u0490' && c <= '\\u04C4') || (c >= '\\u04C7' && c <= '\\u04C8') || (c >= '\\u04CB' && c <= '\\u04CC') || (c >= '\\u04D0' && c <= '\\u04EB') || (c >= '\\u04EE' && c <= '\\u04F5') || (c >= '\\u04F8' && c <= '\\u04F9') || (c >= '\\u0531' && c <= '\\u0556') || (c == '\\u0559') || (c >= '\\u0561' && c <= '\\u0586') || (c >= '\\u05D0' && c <= '\\u05EA') || (c >= '\\u05F0' && c <= '\\u05F2') || (c >= '\\u0621' && c <= '\\u063A') || (c >= '\\u0641' && c <= '\\u064A') || (c >= '\\u0671' && c <= '\\u06B7') || (c >= '\\u06BA' && c <= '\\u06BE') || (c >= '\\u06C0' && c <= '\\u06CE') || (c >= '\\u06D0' && c <= '\\u06D3') || (c == '\\u06D5') || (c >= '\\u06E5' && c <= '\\u06E6') || (c >= '\\u0905' && c <= '\\u0939') || (c == '\\u093D') || (c >= '\\u0958' && c <= '\\u0961') || (c >= '\\u0985' && c <= '\\u098C') || (c >= '\\u098F' && c <= '\\u0990') || (c >= '\\u0993' && c <= '\\u09A8') || (c >= '\\u09AA' && c <= '\\u09B0') || (c == '\\u09B2') || (c >= '\\u09B6' && c <= '\\u09B9') || (c >= '\\u09DC' && c <= '\\u09DD') || (c >= '\\u09DF' && c <= '\\u09E1') || (c >= '\\u09F0' && c <= '\\u09F1') || (c >= '\\u0A05' && c <= '\\u0A0A') || (c >= '\\u0A0F' && c <= '\\u0A10') || (c >= '\\u0A13' && c <= '\\u0A28') || (c >= '\\u0A2A' && c <= '\\u0A30') || (c >= '\\u0A32' && c <= '\\u0A33') || (c >= '\\u0A35' && c <= '\\u0A36') || (c >= '\\u0A38' && c <= '\\u0A39') || (c >= '\\u0A59' && c <= '\\u0A5C') || (c == '\\u0A5E') || (c >= '\\u0A72' && c <= '\\u0A74') || (c >= '\\u0A85' && c <= '\\u0A8B') || (c == '\\u0A8D') || (c >= '\\u0A8F' && c <= '\\u0A91') || (c >= '\\u0A93' && c <= '\\u0AA8') || (c >= '\\u0AAA' && c <= '\\u0AB0') || (c >= '\\u0AB2' && c <= '\\u0AB3') || (c >= '\\u0AB5' && c <= '\\u0AB9') || (c == '\\u0ABD') || (c == '\\u0AE0') || (c >= '\\u0B05' && c <= '\\u0B0C') || (c >= '\\u0B0F' && c <= '\\u0B10') || (c >= '\\u0B13' && c <= '\\u0B28') || (c >= '\\u0B2A' && c <= '\\u0B30') || (c >= '\\u0B32' && c <= '\\u0B33') || (c >= '\\u0B36' && c <= '\\u0B39') || (c == '\\u0B3D') || (c >= '\\u0B5C' && c <= '\\u0B5D') || (c >= '\\u0B5F' && c <= '\\u0B61') || (c >= '\\u0B85' && c <= '\\u0B8A') || (c >= '\\u0B8E' && c <= '\\u0B90') || (c >= '\\u0B92' && c <= '\\u0B95') || (c >= '\\u0B99' && c <= '\\u0B9A') || (c == '\\u0B9C') || (c >= '\\u0B9E' && c <= '\\u0B9F') || (c >= '\\u0BA3' && c <= '\\u0BA4') || (c >= '\\u0BA8' && c <= '\\u0BAA') || (c >= '\\u0BAE' && c <= '\\u0BB5') || (c >= '\\u0BB7' && c <= '\\u0BB9') || (c >= '\\u0C05' && c <= '\\u0C0C') || (c >= '\\u0C0E' && c <= '\\u0C10') || (c >= '\\u0C12' && c <= '\\u0C28') || (c >= '\\u0C2A' && c <= '\\u0C33') || (c >= '\\u0C35' && c <= '\\u0C39') || (c >= '\\u0C60' && c <= '\\u0C61') || (c >= '\\u0C85' && c <= '\\u0C8C') || (c >= '\\u0C8E' && c <= '\\u0C90') || (c >= '\\u0C92' && c <= '\\u0CA8') || (c >= '\\u0CAA' && c <= '\\u0CB3') || (c >= '\\u0CB5' && c <= '\\u0CB9') || (c == '\\u0CDE') || (c >= '\\u0CE0' && c <= '\\u0CE1') || (c >= '\\u0D05' && c <= '\\u0D0C') || (c >= '\\u0D0E' && c <= '\\u0D10') || (c >= '\\u0D12' && c <= '\\u0D28') || (c >= '\\u0D2A' && c <= '\\u0D39') || (c >= '\\u0D60' && c <= '\\u0D61') || (c >= '\\u0E01' && c <= '\\u0E2E') || (c == '\\u0E30') || (c >= '\\u0E32' && c <= '\\u0E33') || (c >= '\\u0E40' && c <= '\\u0E45') || (c >= '\\u0E81' && c <= '\\u0E82') || (c == '\\u0E84') || (c >= '\\u0E87' && c <= '\\u0E88') || (c == '\\u0E8A') || (c == '\\u0E8D') || (c >= '\\u0E94' && c <= '\\u0E97') || (c >= '\\u0E99' && c <= '\\u0E9F') || (c >= '\\u0EA1' && c <= '\\u0EA3') || (c == '\\u0EA5') || (c == '\\u0EA7') || (c >= '\\u0EAA' && c <= '\\u0EAB') || (c >= '\\u0EAD' && c <= '\\u0EAE') || (c == '\\u0EB0') || (c >= '\\u0EB2' && c <= '\\u0EB3') || (c == '\\u0EBD') || (c >= '\\u0EC0' && c <= '\\u0EC4') || (c >= '\\u0F40' && c <= '\\u0F47') || (c >= '\\u0F49' && c <= '\\u0F69') || (c >= '\\u10A0' && c <= '\\u10C5') || (c >= '\\u10D0' && c <= '\\u10F6') || (c == '\\u1100') || (c >= '\\u1102' && c <= '\\u1103') || (c >= '\\u1105' && c <= '\\u1107') || (c == '\\u1109') || (c >= '\\u110B' && c <= '\\u110C') || (c >= '\\u110E' && c <= '\\u1112') || (c == '\\u113C') || (c == '\\u113E') || (c == '\\u1140') || (c == '\\u114C') || (c == '\\u114E') || (c == '\\u1150') || (c >= '\\u1154' && c <= '\\u1155') || (c == '\\u1159') || (c >= '\\u115F' && c <= '\\u1161') || (c == '\\u1163') || (c == '\\u1165') || (c == '\\u1167') || (c == '\\u1169') || (c >= '\\u116D' && c <= '\\u116E') || (c >= '\\u1172' && c <= '\\u1173') || (c == '\\u1175') || (c == '\\u119E') || (c == '\\u11A8') || (c == '\\u11AB') || (c >= '\\u11AE' && c <= '\\u11AF') || (c >= '\\u11B7' && c <= '\\u11B8') || (c == '\\u11BA') || (c >= '\\u11BC' && c <= '\\u11C2') || (c == '\\u11EB') || (c == '\\u11F0') || (c == '\\u11F9') || (c >= '\\u1E00' && c <= '\\u1E9B') || (c >= '\\u1EA0' && c <= '\\u1EF9') || (c >= '\\u1F00' && c <= '\\u1F15') || (c >= '\\u1F18' && c <= '\\u1F1D') || (c >= '\\u1F20' && c <= '\\u1F45') || (c >= '\\u1F48' && c <= '\\u1F4D') || (c >= '\\u1F50' && c <= '\\u1F57') || (c == '\\u1F59') || (c == '\\u1F5B') || (c == '\\u1F5D') || (c >= '\\u1F5F' && c <= '\\u1F7D') || (c >= '\\u1F80' && c <= '\\u1FB4') || (c >= '\\u1FB6' && c <= '\\u1FBC') || (c == '\\u1FBE') || (c >= '\\u1FC2' && c <= '\\u1FC4') || (c >= '\\u1FC6' && c <= '\\u1FCC') || (c >= '\\u1FD0' && c <= '\\u1FD3') || (c >= '\\u1FD6' && c <= '\\u1FDB') || (c >= '\\u1FE0' && c <= '\\u1FEC') || (c >= '\\u1FF2' && c <= '\\u1FF4') || (c >= '\\u1FF6' && c <= '\\u1FFC') || (c == '\\u2126') || (c >= '\\u212A' && c <= '\\u212B') || (c == '\\u212E') || (c >= '\\u2180' && c <= '\\u2182') || (c >= '\\u3041' && c <= '\\u3094') || (c >= '\\u30A1' && c <= '\\u30FA') || (c >= '\\u3105' && c <= '\\u312C') || (c >= '\\uAC00' && c <= '\\uD7A3') || (c >= '\\u4E00' && c <= '\\u9FA5') || (c == '\\u3007') || (c >= '\\u3021' && c <= '\\u3029') || (c == '_') || (c == ':')); } public static boolean isNameTrail(char c) { return ((c >= '\\u0030' && c <= '\\u0039') || (c >= '\\u0660' && c <= '\\u0669') || (c >= '\\u06F0' && c <= '\\u06F9') || (c >= '\\u0966' && c <= '\\u096F') || (c >= '\\u09E6' && c <= '\\u09EF') || (c >= '\\u0A66' && c <= '\\u0A6F') || (c >= '\\u0AE6' && c <= '\\u0AEF') || (c >= '\\u0B66' && c <= '\\u0B6F') || (c >= '\\u0BE7' && c <= '\\u0BEF') || (c >= '\\u0C66' && c <= '\\u0C6F') || (c >= '\\u0CE6' && c <= '\\u0CEF') || (c >= '\\u0D66' && c <= '\\u0D6F') || (c >= '\\u0E50' && c <= '\\u0E59') || (c >= '\\u0ED0' && c <= '\\u0ED9') || (c >= '\\u0F20' && c <= '\\u0F29') || (c >= '\\u0041' && c <= '\\u005A') || (c >= '\\u0061' && c <= '\\u007A') || (c >= '\\u00C0' && c <= '\\u00D6') || (c >= '\\u00D8' && c <= '\\u00F6') || (c >= '\\u00F8' && c <= '\\u00FF') || (c >= '\\u0100' && c <= '\\u0131') || (c >= '\\u0134' && c <= '\\u013E') || (c >= '\\u0141' && c <= '\\u0148') || (c >= '\\u014A' && c <= '\\u017E') || (c >= '\\u0180' && c <= '\\u01C3') || (c >= '\\u01CD' && c <= '\\u01F0') || (c >= '\\u01F4' && c <= '\\u01F5') || (c >= '\\u01FA' && c <= '\\u0217') || (c >= '\\u0250' && c <= '\\u02A8') || (c >= '\\u02BB' && c <= '\\u02C1') || (c == '\\u0386') || (c >= '\\u0388' && c <= '\\u038A') || (c == '\\u038C') || (c >= '\\u038E' && c <= '\\u03A1') || (c >= '\\u03A3' && c <= '\\u03CE') || (c >= '\\u03D0' && c <= '\\u03D6') || (c == '\\u03DA') || (c == '\\u03DC') || (c == '\\u03DE') || (c == '\\u03E0') || (c >= '\\u03E2' && c <= '\\u03F3') || (c >= '\\u0401' && c <= '\\u040C') || (c >= '\\u040E' && c <= '\\u044F') || (c >= '\\u0451' && c <= '\\u045C') || (c >= '\\u045E' && c <= '\\u0481') || (c >= '\\u0490' && c <= '\\u04C4') || (c >= '\\u04C7' && c <= '\\u04C8') || (c >= '\\u04CB' && c <= '\\u04CC') || (c >= '\\u04D0' && c <= '\\u04EB') || (c >= '\\u04EE' && c <= '\\u04F5') || (c >= '\\u04F8' && c <= '\\u04F9') || (c >= '\\u0531' && c <= '\\u0556') || (c == '\\u0559') || (c >= '\\u0561' && c <= '\\u0586') || (c >= '\\u05D0' && c <= '\\u05EA') || (c >= '\\u05F0' && c <= '\\u05F2') || (c >= '\\u0621' && c <= '\\u063A') || (c >= '\\u0641' && c <= '\\u064A') || (c >= '\\u0671' && c <= '\\u06B7') || (c >= '\\u06BA' && c <= '\\u06BE') || (c >= '\\u06C0' && c <= '\\u06CE') || (c >= '\\u06D0' && c <= '\\u06D3') || (c == '\\u06D5') || (c >= '\\u06E5' && c <= '\\u06E6') || (c >= '\\u0905' && c <= '\\u0939') || (c == '\\u093D') || (c >= '\\u0958' && c <= '\\u0961') || (c >= '\\u0985' && c <= '\\u098C') || (c >= '\\u098F' && c <= '\\u0990') || (c >= '\\u0993' && c <= '\\u09A8') || (c >= '\\u09AA' && c <= '\\u09B0') || (c == '\\u09B2') || (c >= '\\u09B6' && c <= '\\u09B9') || (c >= '\\u09DC' && c <= '\\u09DD') || (c >= '\\u09DF' && c <= '\\u09E1') || (c >= '\\u09F0' && c <= '\\u09F1') || (c >= '\\u0A05' && c <= '\\u0A0A') || (c >= '\\u0A0F' && c <= '\\u0A10') || (c >= '\\u0A13' && c <= '\\u0A28') || (c >= '\\u0A2A' && c <= '\\u0A30') || (c >= '\\u0A32' && c <= '\\u0A33') || (c >= '\\u0A35' && c <= '\\u0A36') || (c >= '\\u0A38' && c <= '\\u0A39') || (c >= '\\u0A59' && c <= '\\u0A5C') || (c == '\\u0A5E') || (c >= '\\u0A72' && c <= '\\u0A74') || (c >= '\\u0A85' && c <= '\\u0A8B') || (c == '\\u0A8D') || (c >= '\\u0A8F' && c <= '\\u0A91') || (c >= '\\u0A93' && c <= '\\u0AA8') || (c >= '\\u0AAA' && c <= '\\u0AB0') || (c >= '\\u0AB2' && c <= '\\u0AB3') || (c >= '\\u0AB5' && c <= '\\u0AB9') || (c == '\\u0ABD') || (c == '\\u0AE0') || (c >= '\\u0B05' && c <= '\\u0B0C') || (c >= '\\u0B0F' && c <= '\\u0B10') || (c >= '\\u0B13' && c <= '\\u0B28') || (c >= '\\u0B2A' && c <= '\\u0B30') || (c >= '\\u0B32' && c <= '\\u0B33') || (c >= '\\u0B36' && c <= '\\u0B39') || (c == '\\u0B3D') || (c >= '\\u0B5C' && c <= '\\u0B5D') || (c >= '\\u0B5F' && c <= '\\u0B61') || (c >= '\\u0B85' && c <= '\\u0B8A') || (c >= '\\u0B8E' && c <= '\\u0B90') || (c >= '\\u0B92' && c <= '\\u0B95') || (c >= '\\u0B99' && c <= '\\u0B9A') || (c == '\\u0B9C') || (c >= '\\u0B9E' && c <= '\\u0B9F') || (c >= '\\u0BA3' && c <= '\\u0BA4') || (c >= '\\u0BA8' && c <= '\\u0BAA') || (c >= '\\u0BAE' && c <= '\\u0BB5') || (c >= '\\u0BB7' && c <= '\\u0BB9') || (c >= '\\u0C05' && c <= '\\u0C0C') || (c >= '\\u0C0E' && c <= '\\u0C10') || (c >= '\\u0C12' && c <= '\\u0C28') || (c >= '\\u0C2A' && c <= '\\u0C33') || (c >= '\\u0C35' && c <= '\\u0C39') || (c >= '\\u0C60' && c <= '\\u0C61') || (c >= '\\u0C85' && c <= '\\u0C8C') || (c >= '\\u0C8E' && c <= '\\u0C90') || (c >= '\\u0C92' && c <= '\\u0CA8') || (c >= '\\u0CAA' && c <= '\\u0CB3') || (c >= '\\u0CB5' && c <= '\\u0CB9') || (c == '\\u0CDE') || (c >= '\\u0CE0' && c <= '\\u0CE1') || (c >= '\\u0D05' && c <= '\\u0D0C') || (c >= '\\u0D0E' && c <= '\\u0D10') || (c >= '\\u0D12' && c <= '\\u0D28') || (c >= '\\u0D2A' && c <= '\\u0D39') || (c >= '\\u0D60' && c <= '\\u0D61') || (c >= '\\u0E01' && c <= '\\u0E2E') || (c == '\\u0E30') || (c >= '\\u0E32' && c <= '\\u0E33') || (c >= '\\u0E40' && c <= '\\u0E45') || (c >= '\\u0E81' && c <= '\\u0E82') || (c == '\\u0E84') || (c >= '\\u0E87' && c <= '\\u0E88') || (c == '\\u0E8A') || (c == '\\u0E8D') || (c >= '\\u0E94' && c <= '\\u0E97') || (c >= '\\u0E99' && c <= '\\u0E9F') || (c >= '\\u0EA1' && c <= '\\u0EA3') || (c == '\\u0EA5') || (c == '\\u0EA7') || (c >= '\\u0EAA' && c <= '\\u0EAB') || (c >= '\\u0EAD' && c <= '\\u0EAE') || (c == '\\u0EB0') || (c >= '\\u0EB2' && c <= '\\u0EB3') || (c == '\\u0EBD') || (c >= '\\u0EC0' && c <= '\\u0EC4') || (c >= '\\u0F40' && c <= '\\u0F47') || (c >= '\\u0F49' && c <= '\\u0F69') || (c >= '\\u10A0' && c <= '\\u10C5') || (c >= '\\u10D0' && c <= '\\u10F6') || (c == '\\u1100') || (c >= '\\u1102' && c <= '\\u1103') || (c >= '\\u1105' && c <= '\\u1107') || (c == '\\u1109') || (c >= '\\u110B' && c <= '\\u110C') || (c >= '\\u110E' && c <= '\\u1112') || (c == '\\u113C') || (c == '\\u113E') || (c == '\\u1140') || (c == '\\u114C') || (c == '\\u114E') || (c == '\\u1150') || (c >= '\\u1154' && c <= '\\u1155') || (c == '\\u1159') || (c >= '\\u115F' && c <= '\\u1161') || (c == '\\u1163') || (c == '\\u1165') || (c == '\\u1167') || (c == '\\u1169') || (c >= '\\u116D' && c <= '\\u116E') || (c >= '\\u1172' && c <= '\\u1173') || (c == '\\u1175') || (c == '\\u119E') || (c == '\\u11A8') || (c == '\\u11AB') || (c >= '\\u11AE' && c <= '\\u11AF') || (c >= '\\u11B7' && c <= '\\u11B8') || (c == '\\u11BA') || (c >= '\\u11BC' && c <= '\\u11C2') || (c == '\\u11EB') || (c == '\\u11F0') || (c == '\\u11F9') || (c >= '\\u1E00' && c <= '\\u1E9B') || (c >= '\\u1EA0' && c <= '\\u1EF9') || (c >= '\\u1F00' && c <= '\\u1F15') || (c >= '\\u1F18' && c <= '\\u1F1D') || (c >= '\\u1F20' && c <= '\\u1F45') || (c >= '\\u1F48' && c <= '\\u1F4D') || (c >= '\\u1F50' && c <= '\\u1F57') || (c == '\\u1F59') || (c == '\\u1F5B') || (c == '\\u1F5D') || (c >= '\\u1F5F' && c <= '\\u1F7D') || (c >= '\\u1F80' && c <= '\\u1FB4') || (c >= '\\u1FB6' && c <= '\\u1FBC') || (c == '\\u1FBE') || (c >= '\\u1FC2' && c <= '\\u1FC4') || (c >= '\\u1FC6' && c <= '\\u1FCC') || (c >= '\\u1FD0' && c <= '\\u1FD3') || (c >= '\\u1FD6' && c <= '\\u1FDB') || (c >= '\\u1FE0' && c <= '\\u1FEC') || (c >= '\\u1FF2' && c <= '\\u1FF4') || (c >= '\\u1FF6' && c <= '\\u1FFC') || (c == '\\u2126') || (c >= '\\u212A' && c <= '\\u212B') || (c == '\\u212E') || (c >= '\\u2180' && c <= '\\u2182') || (c >= '\\u3041' && c <= '\\u3094') || (c >= '\\u30A1' && c <= '\\u30FA') || (c >= '\\u3105' && c <= '\\u312C') || (c >= '\\uAC00' && c <= '\\uD7A3') || (c >= '\\u4E00' && c <= '\\u9FA5') || (c == '\\u3007') || (c >= '\\u3021' && c <= '\\u3029') || (c == '_') || (c == ':') || (c == '.') || (c == '-') || (c >= '\\u0300' && c <= '\\u0345') || (c >= '\\u0360' && c <= '\\u0361') || (c >= '\\u0483' && c <= '\\u0486') || (c >= '\\u0591' && c <= '\\u05A1') || (c >= '\\u05A3' && c <= '\\u05B9') || (c >= '\\u05BB' && c <= '\\u05BD') || (c == '\\u05BF') || (c >= '\\u05C1' && c <= '\\u05C2') || (c == '\\u05C4') || (c >= '\\u064B' && c <= '\\u0652') || (c == '\\u0670') || (c >= '\\u06D6' && c <= '\\u06DC') || (c >= '\\u06DD' && c <= '\\u06DF') || (c >= '\\u06E0' && c <= '\\u06E4') || (c >= '\\u06E7' && c <= '\\u06E8') || (c >= '\\u06EA' && c <= '\\u06ED') || (c >= '\\u0901' && c <= '\\u0903') || (c == '\\u093C') || (c >= '\\u093E' && c <= '\\u094C') || (c == '\\u094D') || (c >= '\\u0951' && c <= '\\u0954') || (c >= '\\u0962' && c <= '\\u0963') || (c >= '\\u0981' && c <= '\\u0983') || (c == '\\u09BC') || (c == '\\u09BE') || (c == '\\u09BF') || (c >= '\\u09C0' && c <= '\\u09C4') || (c >= '\\u09C7' && c <= '\\u09C8') || (c >= '\\u09CB' && c <= '\\u09CD') || (c == '\\u09D7') || (c >= '\\u09E2' && c <= '\\u09E3') || (c == '\\u0A02') || (c == '\\u0A3C') || (c == '\\u0A3E') || (c == '\\u0A3F') || (c >= '\\u0A40' && c <= '\\u0A42') || (c >= '\\u0A47' && c <= '\\u0A48') || (c >= '\\u0A4B' && c <= '\\u0A4D') || (c >= '\\u0A70' && c <= '\\u0A71') || (c >= '\\u0A81' && c <= '\\u0A83') || (c == '\\u0ABC') || (c >= '\\u0ABE' && c <= '\\u0AC5') || (c >= '\\u0AC7' && c <= '\\u0AC9') || (c >= '\\u0ACB' && c <= '\\u0ACD') || (c >= '\\u0B01' && c <= '\\u0B03') || (c == '\\u0B3C') || (c >= '\\u0B3E' && c <= '\\u0B43') || (c >= '\\u0B47' && c <= '\\u0B48') || (c >= '\\u0B4B' && c <= '\\u0B4D') || (c >= '\\u0B56' && c <= '\\u0B57') || (c >= '\\u0B82' && c <= '\\u0B83') || (c >= '\\u0BBE' && c <= '\\u0BC2') || (c >= '\\u0BC6' && c <= '\\u0BC8') || (c >= '\\u0BCA' && c <= '\\u0BCD') || (c == '\\u0BD7') || (c >= '\\u0C01' && c <= '\\u0C03') || (c >= '\\u0C3E' && c <= '\\u0C44') || (c >= '\\u0C46' && c <= '\\u0C48') || (c >= '\\u0C4A' && c <= '\\u0C4D') || (c >= '\\u0C55' && c <= '\\u0C56') || (c >= '\\u0C82' && c <= '\\u0C83') || (c >= '\\u0CBE' && c <= '\\u0CC4') || (c >= '\\u0CC6' && c <= '\\u0CC8') || (c >= '\\u0CCA' && c <= '\\u0CCD') || (c >= '\\u0CD5' && c <= '\\u0CD6') || (c >= '\\u0D02' && c <= '\\u0D03') || (c >= '\\u0D3E' && c <= '\\u0D43') || (c >= '\\u0D46' && c <= '\\u0D48') || (c >= '\\u0D4A' && c <= '\\u0D4D') || (c == '\\u0D57') || (c == '\\u0E31') || (c >= '\\u0E34' && c <= '\\u0E3A') || (c >= '\\u0E47' && c <= '\\u0E4E') || (c == '\\u0EB1') || (c >= '\\u0EB4' && c <= '\\u0EB9') || (c >= '\\u0EBB' && c <= '\\u0EBC') || (c >= '\\u0EC8' && c <= '\\u0ECD') || (c >= '\\u0F18' && c <= '\\u0F19') || (c == '\\u0F35') || (c == '\\u0F37') || (c == '\\u0F39') || (c == '\\u0F3E') || (c == '\\u0F3F') || (c >= '\\u0F71' && c <= '\\u0F84') || (c >= '\\u0F86' && c <= '\\u0F8B') || (c >= '\\u0F90' && c <= '\\u0F95') || (c == '\\u0F97') || (c >= '\\u0F99' && c <= '\\u0FAD') || (c >= '\\u0FB1' && c <= '\\u0FB7') || (c == '\\u0FB9') || (c >= '\\u20D0' && c <= '\\u20DC') || (c == '\\u20E1') || (c >= '\\u302A' && c <= '\\u302F') || (c == '\\u3099') || (c == '\\u309A') || (c == '\\u00B7') || (c == '\\u02D0') || (c == '\\u02D1') || (c == '\\u0387') || (c == '\\u0640') || (c == '\\u0E46') || (c == '\\u0EC6') || (c == '\\u3005') || (c >= '\\u3031' && c <= '\\u3035') || (c >= '\\u309D' && c <= '\\u309E') || (c >= '\\u30FC' && c <= '\\u30FE')); } public static boolean isName(CharSequence str) { if (str == null) { return false; } else { int len = str.length(); switch (len) { case 0: return false; case 1: return XmlName.isNameStart(str.charAt(0)); default: if (!XmlName.isNameStart(str.charAt(0))) { return false; } for (int i = 1; i < len; i++) { if (!XmlName.isNameTrail(str.charAt(i))) { return false; } } } return true; } }  public static final XmlName THE_INSTANCE = new XmlName(); private XmlName() { } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (!isName(literal)) { throw newDatatypeException(\"Not a valid XML 1.0 name.\"); } } @Override public String getName() { return \"XML name\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Zero extends AbstractDatatype {  public static final Zero THE_INSTANCE = new Zero(); private Zero() { } @Override public String getName() { return \"zero\"; } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() != 1 || literal.charAt(0) != '0') { throw newDatatypeException(0, \"Only \\u201C0\\u201D is a permitted zero literal.\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "  package org.whattf.datatype.data; import java.util.Arrays; public class CharsetData { private static final String[] LABELS = { \"866\", \"ansi_x3.4-1968\", \"arabic\", \"ascii\", \"asmo-708\", \"big5\", \"big5-hkscs\", \"chinese\", \"cn-big5\", \"cp1250\", \"cp1251\", \"cp1252\", \"cp1253\", \"cp1254\", \"cp1255\", \"cp1256\", \"cp1257\", \"cp1258\", \"cp819\", \"cp866\", \"csbig5\", \"cseuckr\", \"cseucpkdfmtjapanese\", \"csgb2312\", \"csibm866\", \"csiso2022jp\", \"csiso2022kr\", \"csiso58gb231280\", \"csiso88596e\", \"csiso88596i\", \"csiso88598e\", \"csiso88598i\", \"csisolatin1\", \"csisolatin2\", \"csisolatin3\", \"csisolatin4\", \"csisolatin5\", \"csisolatin6\", \"csisolatin9\", \"csisolatinarabic\", \"csisolatincyrillic\", \"csisolatingreek\", \"csisolatinhebrew\", \"cskoi8r\", \"csksc56011987\", \"csmacintosh\", \"csshiftjis\", \"cyrillic\", \"dos-874\", \"ecma-114\", \"ecma-118\", \"elot_928\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gb2312\", \"gb_2312\", \"gb_2312-80\", \"gbk\", \"greek\", \"greek8\", \"hebrew\", \"hz-gb-2312\", \"ibm819\", \"ibm866\", \"iso-2022-cn\", \"iso-2022-cn-ext\", \"iso-2022-jp\", \"iso-2022-kr\", \"iso-8859-1\", \"iso-8859-10\", \"iso-8859-11\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6-e\", \"iso-8859-6-i\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8-e\", \"iso-8859-8-i\", \"iso-8859-9\", \"iso-ir-100\", \"iso-ir-101\", \"iso-ir-109\", \"iso-ir-110\", \"iso-ir-126\", \"iso-ir-127\", \"iso-ir-138\", \"iso-ir-144\", \"iso-ir-148\", \"iso-ir-149\", \"iso-ir-157\", \"iso-ir-58\", \"iso8859-1\", \"iso8859-10\", \"iso8859-11\", \"iso8859-13\", \"iso8859-14\", \"iso8859-15\", \"iso8859-2\", \"iso8859-3\", \"iso8859-4\", \"iso8859-5\", \"iso8859-6\", \"iso8859-7\", \"iso8859-8\", \"iso8859-9\", \"iso88591\", \"iso885910\", \"iso885911\", \"iso885913\", \"iso885914\", \"iso885915\", \"iso88592\", \"iso88593\", \"iso88594\", \"iso88595\", \"iso88596\", \"iso88597\", \"iso88598\", \"iso88599\", \"iso_8859-1\", \"iso_8859-15\", \"iso_8859-1:1987\", \"iso_8859-2\", \"iso_8859-2:1987\", \"iso_8859-3\", \"iso_8859-3:1988\", \"iso_8859-4\", \"iso_8859-4:1988\", \"iso_8859-5\", \"iso_8859-5:1988\", \"iso_8859-6\", \"iso_8859-6:1987\", \"iso_8859-7\", \"iso_8859-7:1987\", \"iso_8859-8\", \"iso_8859-8:1988\", \"iso_8859-9\", \"iso_8859-9:1989\", \"koi\", \"koi8\", \"koi8-r\", \"koi8-u\", \"koi8_r\", \"korean\", \"ks_c_5601-1987\", \"ks_c_5601-1989\", \"ksc5601\", \"ksc_5601\", \"l1\", \"l2\", \"l3\", \"l4\", \"l5\", \"l6\", \"l9\", \"latin1\", \"latin2\", \"latin3\", \"latin4\", \"latin5\", \"latin6\", \"logical\", \"mac\", \"macintosh\", \"ms_kanji\", \"shift-jis\", \"shift_jis\", \"sjis\", \"sun_eu_greek\", \"tis-620\", \"unicode-1-1-utf-8\", \"us-ascii\", \"utf-16\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"utf8\", \"visual\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-31j\", \"windows-874\", \"windows-949\", \"x-cp1250\", \"x-cp1251\", \"x-cp1252\", \"x-cp1253\", \"x-cp1254\", \"x-cp1255\", \"x-cp1256\", \"x-cp1257\", \"x-cp1258\", \"x-euc-jp\", \"x-gbk\", \"x-mac-cyrillic\", \"x-mac-roman\", \"x-mac-ukrainian\", \"x-sjis\", \"x-user-defined\", \"x-x-big5\", }; private static final String[] PREFERRED_FOR_LABELS = { \"ibm866\", \"windows-1252\", \"iso-8859-6\", \"windows-1252\", \"iso-8859-6\", \"big5\", \"big5\", \"gbk\", \"big5\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-1252\", \"ibm866\", \"big5\", \"euc-kr\", \"euc-jp\", \"gbk\", \"ibm866\", \"iso-2022-jp\", \"iso-2022-kr\", \"gbk\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-8\", \"iso-8859-8-i\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-15\", \"iso-8859-6\", \"iso-8859-5\", \"iso-8859-7\", \"iso-8859-8\", \"koi8-r\", \"euc-kr\", \"macintosh\", \"shift_jis\", \"iso-8859-5\", \"windows-874\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-7\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gbk\", \"gbk\", \"gbk\", \"gbk\", \"iso-8859-7\", \"iso-8859-7\", \"iso-8859-8\", \"hz-gb-2312\", \"windows-1252\", \"ibm866\", \"replacement\", \"replacement\", \"iso-2022-jp\", \"iso-2022-kr\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8\", \"iso-8859-8-i\", \"windows-1254\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-7\", \"iso-8859-6\", \"iso-8859-8\", \"iso-8859-5\", \"windows-1254\", \"euc-kr\", \"iso-8859-10\", \"gbk\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"windows-1254\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"windows-1254\", \"windows-1252\", \"iso-8859-15\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8\", \"windows-1254\", \"windows-1254\", \"koi8-r\", \"koi8-r\", \"koi8-r\", \"koi8-u\", \"koi8-r\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-15\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-8-i\", \"macintosh\", \"macintosh\", \"shift_jis\", \"shift_jis\", \"shift_jis\", \"shift_jis\", \"iso-8859-7\", \"windows-874\", \"utf-8\", \"windows-1252\", \"utf-16le\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"utf-8\", \"iso-8859-8\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"shift_jis\", \"windows-874\", \"euc-kr\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"euc-jp\", \"gbk\", \"x-mac-cyrillic\", \"macintosh\", \"x-mac-cyrillic\", \"shift_jis\", \"x-user-defined\", \"big5\", }; private static final String[] PREFERRED = { \"big5\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gbk\", \"hz-gb-2312\", \"ibm866\", \"iso-2022-jp\", \"iso-2022-kr\", \"iso-8859-10\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8-i\", \"koi8-r\", \"koi8-u\", \"macintosh\", \"replacement\", \"shift_jis\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-874\", \"x-mac-cyrillic\", \"x-user-defined\", }; public static boolean isPreferred(String label) { return Arrays.binarySearch(PREFERRED, label) > -1; } public static String preferredForLabel(String label) { int index = Arrays.binarySearch(LABELS, label); if (index < 0) { return null; } return PREFERRED_FOR_LABELS[index]; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype.data; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet; import java.util.regex.Pattern; public class LanguageData { private static final Pattern HYPHEN = Pattern.compile(\"-\"); private static final String[][] EMPTY_DOUBLE_STRING_ARRAY = {}; private static final String[] EMPTY_STRING_ARRAY = {}; private static final String PREFIX = \"prefix: \"; private static final String SUPPRESS_SCRIPT = \"suppress-script: \"; private static final String SUBTAG = \"subtag: \"; private static final String TAG = \"tag: \"; private static final String TYPE = \"type: \"; private static final String DEPRECATED = \"deprecated: \"; private static final String PREFERRED_VALUE = \"preferred-value: \"; private BufferedReader in; private SortedSet<String> languageSet = new TreeSet<String>(); private SortedSet<String> extlangSet = new TreeSet<String>(); private SortedSet<String> scriptSet = new TreeSet<String>(); private SortedSet<String> regionSet = new TreeSet<String>(); private SortedSet<String> variantSet = new TreeSet<String>(); private SortedSet<String> grandfatheredSet = new TreeSet<String>(); private SortedSet<String> redundantSet = new TreeSet<String>(); private SortedSet<String> deprecatedLangSet = new TreeSet<String>(); private SortedSet<String> deprecatedSet = new TreeSet<String>(); private Map<String, String> suppressedScriptByLanguageMap = new HashMap<String, String>(); private Map<String, String> prefixByExtlangMap = new HashMap<String, String>(); private Map<String, String> preferredValueByLanguageMap = new HashMap<String, String>(); private Map<String, Set<String[]>> prefixesByVariantMap = new HashMap<String, Set<String[]>>(); private String[] languages = null; private String[] extlangs = null; private String[] scripts = null; private String[] regions = null; private String[] variants = null; private String[] grandfathered = null; private String[] redundant = null; private String[] deprecatedLang = null; private String[] deprecated = null; private int[] suppressedScriptByLanguage = null; private int[] prefixByExtlang = null; private String[][][] prefixesByVariant = null; public LanguageData() throws IOException { super(); in = new BufferedReader( new InputStreamReader( LanguageData.class.getClassLoader().getResourceAsStream( \"nu/validator/localentities/files/language-subtag-registry\"), \"UTF-8\")); consumeRegistry(); prepareArrays(); } private void consumeRegistry() throws IOException { while (consumeRecord()) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.EOFException; import java.io.IOException; import java.io.InputStream;  public class Base64InputStream extends InputStream { private static final int[] DECODING_TABLE = new int[256]; static { for (int i = 0; i < DECODING_TABLE.length; i++) { if (i >= 'A' && i <= 'Z') { DECODING_TABLE[i] = (i - 'A'); } else if (i >= 'a' && i <= 'z') { DECODING_TABLE[i] = (i - 'a' + 26); } else if (i >= '0' && i <= '9') { DECODING_TABLE[i] = (i - '0' + 52); } else if (i == '+') { DECODING_TABLE[i] = 62; } else if (i == '/') { DECODING_TABLE[i] = 63; } else if (i == '=') { DECODING_TABLE[i] = -2; } else { DECODING_TABLE[i] = -1; } } } private final InputStream delegate; private int bytesLeftInBuffer = 0; private int buffer = 0;  public Base64InputStream(InputStream delegate) { this.delegate = delegate; } @Override public int read() throws IOException { if (bytesLeftInBuffer == 0) { bytesLeftInBuffer = 3; for (int i = 0; i < 4; i++) { int c = delegate.read(); buffer <<= 6; if (c < 0) { if (i == 0) { bytesLeftInBuffer = 0; return -1; } else { throw new EOFException(); } } else if (bytesLeftInBuffer == 2) { if (c == '=') { bytesLeftInBuffer = 1; } else { throw new IOException(\"Non-padding in Base64 stream after padding had started.\"); } } else { int b = DECODING_TABLE[c]; if (b == -2) { if (i <= 1) { throw new IOException( \"Base 64 padding in a bad position.\"); } bytesLeftInBuffer = 2; } else if (b == -1) { throw new IOException(\"Non-Base64 input: \\u201C0x\" + Integer.toHexString(c) + \"\\u201D.\"); } else { buffer |= b; } } } } int rv = (buffer & 0xFF0000) >> 16; buffer <<= 8; bytesLeftInBuffer--; return rv; }  public void close() throws IOException { delegate.close(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.InputStream; import java.io.StringReader; import java.net.MalformedURLException; import com.hp.hpl.jena.iri.IRI; import com.hp.hpl.jena.iri.IRIFactory; public class DataUri { public static boolean startsWithData(String uri) { return uri != null && uri.length() >= 5 && (uri.charAt(0) == 'd' || uri.charAt(0) == 'D') && (uri.charAt(1) == 'a' || uri.charAt(1) == 'A') && (uri.charAt(2) == 't' || uri.charAt(2) == 'T') && (uri.charAt(3) == 'a' || uri.charAt(3) == 'A') && (uri.charAt(4) == ':'); } private enum State { AT_START, IN_SUPERTYPE, AT_SUBTYPE_START, IN_SUBTYPE, SEMICOLON_SEEN, WS_BEFORE_SEMICOLON, IN_PARAM_NAME, EQUALS_SEEN, IN_QUOTED_STRING, IN_UNQUOTED_STRING, IN_QUOTED_PAIR, CLOSE_QUOTE_SEEN } private String contentType; private InputStream inputStream;  protected void init(IRI uri) throws IOException, MalformedURLException { if (!uri.getScheme().equals(\"data\")) { throw new IllegalArgumentException(\"The input did not start with data:.\"); } if (uri.getRawFragment() != null) { throw new MalformedURLException(\"Fragment is not allowed for data: URIs according to RFC 2397. But if strictly comply with RFC 3986, ignore this error.\"); } InputStream is = new PercentDecodingReaderInputStream(new StringReader(uri.getRawPath())); StringBuilder sb = new StringBuilder(); State state = State.AT_START; int i = 0; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; public class DataUriException extends IOException { private final int index; private final String head; private final char literal; private final String tail;  public DataUriException(int index, String head, char literal, String tail) { super(head + '\\u201C' + literal + '\\u201D' + tail); this.index = index; this.head = head; this.literal = literal; this.tail = tail; }  public int getIndex() { return index; }  public String getHead() { return head; }  public char getLiteral() { return literal; }  public String getTail() { return tail; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.net.MalformedURLException; public final class PercentDecodingReaderInputStream extends InputStream { private final Reader delegate;  public PercentDecodingReaderInputStream(final Reader delegate) { this.delegate = delegate; }  @Override public int read() throws IOException { int c = delegate.read(); if (c == -1) { return -1; } if (c == '%') { return readHexByte(); } else if (c < 0x80) { return c; } else { throw new MalformedURLException(\"Unescaped non-ASCII character.\"); } } private int readHexByte() throws IOException { int c = delegate.read(); if (isHexDigit(c)) { int hi = Character.getNumericValue(c) << 4; c = delegate.read(); if (isHexDigit(c)) { return hi | Character.getNumericValue(c); } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } private boolean isHexDigit(int c) { return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); } @Override public void close() throws IOException { delegate.close(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.Reader; import java.net.MalformedURLException; public final class Utf8PercentDecodingReader extends Reader { private final Reader delegate; private char pending = '\\u0000';  public Utf8PercentDecodingReader(final Reader delegate) { this.delegate = delegate; }  @Override public int read() throws IOException { if (pending != '\\u0000') { char rv = pending; pending = '\\u0000'; return rv; } int byteVal = 0; int codePoint = 0; int c = delegate.read(); int trailBytes = 0; if (c == -1) { return -1; } if (c == '%') { byteVal = readHexByte(); if (byteVal < 0x80) { return byteVal; } else if ((0xE0 & byteVal) == 0xC0) { trailBytes = 1; codePoint = byteVal & 0x1F; } else if ((0xF0 & byteVal) == 0xE0) { trailBytes = 2; codePoint = byteVal & 0x0F; } else if ((0xF8 & byteVal) == 0xF0) { trailBytes = 3; codePoint = byteVal & 0x07; } else { throw new MalformedURLException(\"Percent escape decodes to a byte that is not a valid UTF-8 lead byte.\"); } for (int i = 0; i < trailBytes; i++) { byteVal = readPercentHexByte(); if ((0xC0 & byteVal) == 0x80) { codePoint = (codePoint << 6) | (byteVal & 0x3F); } else { throw new MalformedURLException(\"Percent escape decodes to a byte that is not a valid UTF-8 trail byte.\"); } } switch (trailBytes) { case 3: if (codePoint <= 0xFFFF) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { int rv = (0xD7C0 + (codePoint >> 10)); pending = (char) (0xDC00 + (codePoint & 0x3FF)); return rv; } case 2: if (codePoint <= 0x07FF) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { return codePoint; } default: if (codePoint <= 0x007F) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { return codePoint; } } } else { return c; } } private int readPercentHexByte() throws IOException { int c = delegate.read(); if (c != '%') { throw new MalformedURLException(\"Percent-encoded trail byte missing.\"); } return readHexByte(); } private int readHexByte() throws IOException { int c = delegate.read(); if (isHexDigit(c)) { int hi = Character.getNumericValue(c) << 4; c = delegate.read(); if (isHexDigit(c)) { return hi | Character.getNumericValue(c); } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } private boolean isHexDigit(int c) { return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); } @Override public void close() throws IOException { pending = '\\u0000'; delegate.close(); } @Override public int read(char[] cbuf, int off, int len) throws IOException { int i = 0; while (i < len) { int c = read(); if (c == -1) { if (i == 0) { return -1; } else { return i; } } cbuf[off] = (char) c; off++; i++; } return i; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; public class ARel extends AbstractRel { private static final String[] REGISTERED_TOKENS = { \"#voverlay\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.ArrayList; import java.util.List; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext;  public abstract class AbstractDatatype implements Datatype {  AbstractDatatype() { super(); }  public final boolean isValid(String literal, ValidationContext context) { try { checkValid(literal); } catch (DatatypeException e) { return false; } return true; }  public void checkValid(String literal, ValidationContext context) throws DatatypeException { checkValid(literal); } public abstract void checkValid(CharSequence literal) throws DatatypeException;  public DatatypeStreamingValidator createStreamingValidator( ValidationContext context) { return new DatatypeStreamingValidatorImpl(this); }  public Object createValue(String literal, ValidationContext context) { return literal; }  public final boolean sameValue(Object value1, Object value2) { if (value1 == null) { return (value2 == null); } return value1.equals(value2); }  public final int valueHashCode(Object value) { return value.hashCode(); }  public final int getIdType() { return Datatype.ID_TYPE_NULL; }  public boolean isContextDependent() { return false; }  protected final boolean isWhitespace(char c) { return c == ' ' || c == '\\t' || c == '\\f' || c == '\\n' || c == '\\r'; } protected final boolean isAsciiDigit(char c) { return c >= '0' && c <= '9'; } protected static final char toAsciiLowerCase(char c) { if (c >= 'A' && c <= 'Z') { c += 0x20; } return c; } protected static final String toAsciiLowerCase(CharSequence str) { if (str == null) { return null; } char[] buf = new char[str.length()]; for (int i = 0; i < str.length(); i++) { char c = str.charAt(i); if (c >= 'A' && c <= 'Z') { c += 0x20; } buf[i] = c; } return new String(buf); } protected static final char toAsciiUpperCase(char c) { if (c >= 'a' && c <= 'z') { c -= 0x20; } return c; } protected static final String toAsciiUpperCase(CharSequence str) { if (str == null) { return null; } char[] buf = new char[str.length()]; for (int i = 0; i < str.length(); i++) { char c = str.charAt(i); if (c >= 'a' && c <= 'z') { c -= 0x20; } buf[i] = c; } return new String(buf); } protected DatatypeException newDatatypeException(String message) { return new Html5DatatypeException(this.getClass(), this.getName(), message); } protected DatatypeException newDatatypeException(String head, String literal, String tail) { return new Html5DatatypeException(this.getClass(), this.getName(), head, literal, tail); } protected DatatypeException newDatatypeException(String head, char literal, String tail) { return new Html5DatatypeException(this.getClass(), this.getName(), head, String.valueOf(literal), tail); } protected DatatypeException newDatatypeException(int position, String message) { return new Html5DatatypeException(position, this.getClass(), this.getName(), message); } protected DatatypeException newDatatypeException(int position, String head, String literal, String tail) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, literal, tail); } protected DatatypeException newDatatypeException(int position, String head, char literal, String tail) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, String.valueOf(literal), tail); }  protected DatatypeException newDatatypeException(String message, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), message, warning); } protected DatatypeException newDatatypeException(String head, String literal, String tail, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), head, literal, tail, warning); } protected DatatypeException newDatatypeException(String head, char literal, String tail, boolean warning) { return new Html5DatatypeException(this.getClass(), this.getName(), head, String.valueOf(literal), tail, warning); } protected DatatypeException newDatatypeException(int position, String message, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), message, warning); } protected DatatypeException newDatatypeException(int position, String head, String literal, String tail, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, literal, tail, warning); } protected DatatypeException newDatatypeException(int position, String head, char literal, String tail, boolean warning) { return new Html5DatatypeException(position, this.getClass(), this.getName(), head, String.valueOf(literal), tail, warning); } public abstract String getName(); protected List<CharSequenceWithOffset> split(CharSequence sequence, char delimiter) { List<CharSequenceWithOffset> rv = new ArrayList<CharSequenceWithOffset>(); int offset = 0; for (int i = 0; i < sequence.length(); i++) { char c = sequence.charAt(i); if (c == delimiter) { rv.add(new CharSequenceWithOffset(sequence.subSequence(offset, i), offset)); offset = i + 1; } } rv.add(new CharSequenceWithOffset(sequence.subSequence(offset, sequence.length()), offset)); return rv; } protected class CharSequenceWithOffset { private final CharSequence sequence; private final int offset;  public CharSequenceWithOffset(final CharSequence sequence, final int offset) { this.sequence = sequence; this.offset = offset; }  public int getOffset() { return offset; }  public CharSequence getSequence() { return sequence; } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  abstract class AbstractDatetime extends AbstractDatatype {  private static int[] DAYS_IN_MONTHS = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };  AbstractDatetime() { super(); } private void checkMonth(String year, String month) throws DatatypeException { checkMonth(Integer.parseInt(year), Integer.parseInt(month)); } private void checkMonth(int year, int month) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } } private void checkDate(String year, String month, String day) throws DatatypeException { checkDate(Integer.parseInt(year), Integer.parseInt(month), Integer.parseInt(day)); } private void checkDate(int year, int month, int day) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } if (day < 1) { throw newDatatypeException(\"Day cannot be less than 1.\"); } if (day > DAYS_IN_MONTHS[month - 1]) { if (!(day == 29 && month == 2 && isLeapYear(year))) { throw newDatatypeException(\"Day out of range.\"); } } } private boolean isLeapYear(int year) { return (year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)); } private void checkYearlessDate(String month, String day) throws DatatypeException { checkYearlessDate(Integer.parseInt(month), Integer.parseInt(day)); } private void checkYearlessDate(int month, int day) throws DatatypeException { if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } if (day < 1) { throw newDatatypeException(\"Day cannot be less than 1.\"); } } private void checkWeek(String year, String week) throws DatatypeException { checkWeek(Integer.parseInt(year), Integer.parseInt(week)); } private void checkWeek(int year, int week) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (week< 1) { throw newDatatypeException(\"Week cannot be less than 1.\"); } if (week > 53) { throw newDatatypeException(\"Week cannot be greater than 53.\"); } } protected final void checkHour(String hour) throws DatatypeException { checkHour(Integer.parseInt(hour)); } private void checkHour(int hour) throws DatatypeException { if (hour > 23) { throw newDatatypeException(\"Hour cannot be greater than 23.\"); } } protected final void checkMinute(String minute) throws DatatypeException { checkMinute(Integer.parseInt(minute)); } private void checkMinute(int minute) throws DatatypeException { if (minute > 59) { throw newDatatypeException(\"Minute cannot be greater than 59.\"); } } protected final void checkSecond(String second) throws DatatypeException { checkSecond(Integer.parseInt(second)); } private void checkSecond(int second) throws DatatypeException { if (second > 59) { throw newDatatypeException(\"Second cannot be greater than 59.\"); } } protected final void checkMilliSecond(String millisecond) throws DatatypeException { if (millisecond.length() > 3) { throw newDatatypeException(\"A fraction of a second must be one, two, or three digits.\"); } } private void checkTzd(String hours, String minutes) throws DatatypeException { if (hours.charAt(0) == '+') { hours = hours.substring(1); } checkTzd(Integer.parseInt(hours), Integer.parseInt(minutes)); } private void checkTzd(int hours, int minutes) throws DatatypeException { if (hours < -23 || hours > 23) { throw newDatatypeException(\"Hours out of range in time zone designator.\"); } if (minutes > 59) { throw newDatatypeException(\"Minutes out of range in time zone designator.\"); } } protected abstract Pattern getPattern(); public void checkValid(CharSequence literal) throws DatatypeException { String year; String month; String day; String hour; String minute; String seconds; String milliseconds; String tzdHours; String tzdMinutes; Matcher m = getPattern().matcher(literal); if (m.matches()) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public abstract class AbstractInt extends AbstractDatatype {  protected AbstractInt() { super(); }  protected void checkInt(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid integer.\"); } char c = literal.charAt(0); if (!(c == '-' || isAsciiDigit(c))) { throw newDatatypeException(0, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } for (int i = 1; i < literal.length(); i++) { c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } } }  protected void checkIntNonNegative(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid non-negative integer.\"); } for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } } }  protected void checkIntPositive(CharSequence literal, int offset) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid positive integer.\"); } boolean zero = true; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isAsciiDigit(c)) { throw newDatatypeException(offset + i, \"Expected a digit but saw \", c, \" instead.\"); } if (c != '0') { zero = false; } } if (zero) { throw newDatatypeException(\"Zero is not a positive integer.\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.HashSet; import java.util.Set; import org.relaxng.datatype.DatatypeException; abstract class AbstractRel extends AbstractDatatype { @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; import org.relaxng.datatype.ValidationContext; import com.ibm.icu.lang.UCharacter; import com.ibm.icu.text.UnicodeSet; public abstract class AbstractUnicodeClassCharacter extends AbstractDatatype { private static final int SURROGATE_OFFSET = 0x10000 - (0xD800 << 10) - 0xDC00; protected abstract UnicodeSet getUnicodeSet(); @Override public void checkValid(CharSequence literal) throws DatatypeException { switch (literal.length()) { case 0: throw newDatatypeException(\"The empty string is not a \" + getName() + \".\"); case 1: char c = literal.charAt(0); if (!getUnicodeSet().contains(c)) { throw newDatatypeException(0, \"The character \", c, \" is not a \" + getName() + \".\"); } return; case 2: char hi = literal.charAt(0); char lo = literal.charAt(1); if ((lo & 0xFC00) == 0xDC00 && (hi & 0xFC00) == 0xD800) { int codepoint = (hi << 10) + lo + SURROGATE_OFFSET; if (!getUnicodeSet().contains(codepoint)) { throw newDatatypeException(0, \"The character \", \"\" + hi + lo, \" is not a \" + getName() + \".\"); } return; } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.ValidationContext; public class AsciiCaseInsensitiveString extends AbstractDatatype {  public static final AsciiCaseInsensitiveString THE_INSTANCE = new AsciiCaseInsensitiveString();  protected AsciiCaseInsensitiveString() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { }  @Override public Object createValue(String literal, ValidationContext context) { return toAsciiLowerCase(literal); } @Override public String getName() { return \"ASCII-case-insensitive string\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class BrowsingContext extends AbstractDatatype {  public static final BrowsingContext THE_INSTANCE = new BrowsingContext();  private BrowsingContext() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Browsing context name must be at least one character long.\"); } if (literal.charAt(0) == '_') { throw newDatatypeException(\"Browsing context name started with the underscore.\"); } else { return; } } @Override public String getName() { return \"browsing context name\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class BrowsingContextOrKeyword extends AbstractDatatype {  public static final BrowsingContextOrKeyword THE_INSTANCE = new BrowsingContextOrKeyword();  private BrowsingContextOrKeyword() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Browsing context name must be at least one character long.\"); } if (literal.charAt(0) == '_') { String kw = toAsciiLowerCase(literal.toString().substring(1)); if (!(\"blank\".equals(kw) || \"self\".equals(kw) || \"top\".equals(kw) || \"parent\".equals(kw))) { throw newDatatypeException(\"Reserved keyword \", kw, \" used.\"); } } else { return; } } @Override public String getName() { return \"browsing context name or keyword\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class CdoCdcPair extends AbstractDatatype { private enum State { DATA, LESS_THAN_SIGN, LESS_THAN_SIGN_BANG, LESS_THAN_SIGN_BANG_HYPHEN, HAS_CDO, HAS_CDO_AND_HYPHEN, HAS_CDO_AND_DOUBLE_HYPHEN }  public static final CdoCdcPair THE_INSTANCE = new CdoCdcPair(); protected CdoCdcPair() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.DATA; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case DATA: if ('<' == c) { state = State.LESS_THAN_SIGN; continue; } continue; case LESS_THAN_SIGN: if ('!' == c) { state = State.LESS_THAN_SIGN_BANG; continue; } state = State.DATA; continue; case LESS_THAN_SIGN_BANG: if ('-' == c) { state = State.LESS_THAN_SIGN_BANG_HYPHEN; continue; } state = State.DATA; continue; case LESS_THAN_SIGN_BANG_HYPHEN: if ('-' == c) { state = State.HAS_CDO; continue; } state = State.DATA; continue; case HAS_CDO: if ('-' == c) { state = State.HAS_CDO_AND_HYPHEN; continue; } continue; case HAS_CDO_AND_HYPHEN: if ('-' == c) { state = State.HAS_CDO_AND_DOUBLE_HYPHEN; continue; } state = State.HAS_CDO; continue; case HAS_CDO_AND_DOUBLE_HYPHEN: if ('>' == c) { state = State.DATA; continue; } else if ('-' == c) { continue; } state = State.HAS_CDO; continue; default: assert false : state; } } if (state == State.HAS_CDO) { throw newDatatypeException(\"Content contains the character sequence \\u201c<!--\\u201d without\" + \" a later occurrence of the character sequence \\u201c-->\\u201d.\"); } } @Override public String getName() { return \"text content with CDO-CDC pair\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.whattf.datatype.data.CharsetData; import org.relaxng.datatype.DatatypeException; public class Charset extends AbstractDatatype {  public static final Charset THE_INSTANCE = new Charset(); public Charset() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid character encoding name.\"); } for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class CharsetList extends AbstractDatatype {  public static final CharsetList THE_INSTANCE = new CharsetList(); private enum State { WS_BEFORE_TOKEN } private CharsetList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.WS_BEFORE_TOKEN; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { } } switch (state) { } } private boolean isTokenChar(char c) { return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '+' || c == '-' || c == '^' || c == '_' || c == '`' || c == '{' || c == '}' || c == '~'; } @Override public String getName() { return \"character encoding list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Circle extends AbstractInt {  public static final Circle THE_INSTANCE = new Circle();  private Circle() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() != 3) { throw newDatatypeException(\"A circle must have three comma-separated integers.\"); } CharSequenceWithOffset withOffset = list.get(0); checkInt(withOffset.getSequence(), withOffset.getOffset()); withOffset = list.get(1); checkInt(withOffset.getSequence(), withOffset.getOffset()); withOffset = list.get(2); checkIntNonNegative(withOffset.getSequence(), withOffset.getOffset()); } @Override public String getName() { return \"circle\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeStreamingValidator; public final class DatatypeStreamingValidatorImpl implements DatatypeStreamingValidator { private final AbstractDatatype datatype; private final StringBuilder buffer; public DatatypeStreamingValidatorImpl(AbstractDatatype datatype) { super(); this.datatype = datatype; this.buffer = new StringBuilder(); } public void addCharacters(char[] buf, int start, int len) { buffer.append(buf, start, len); } public boolean isValid() { try { datatype.checkValid(buffer); } catch (DatatypeException e) { return false; } return true; } public void checkValid() throws DatatypeException { datatype.checkValid(buffer); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; public class DateOrTime extends AbstractDatetime {  public static final DateOrTime THE_INSTANCE = new DateOrTime();  private static final Pattern THE_PATTERN = Pattern.compile(\"^(?:(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:[T ]([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?(?:Z|(?:([+-][0-9]{2}):([0-9]{2})))?)?)|(?:([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?(?:Z|(?:([+-][0-9]{2}):([0-9]{2})))?))$\"); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; /** * This datatype shall accept strings that conform to the format specified for * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class EmailAddress extends AbstractDatatype {  public static final EmailAddress THE_INSTANCE = new EmailAddress();  public EmailAddress() { super(); }  @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class EmailAddressList extends AbstractDatatype {  public static final EmailAddressList THE_INSTANCE = new EmailAddressList();  public EmailAddressList() { super(); }  @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponent extends AbstractDatatype {  public static final FloatingPointExponent THE_INSTANCE = new FloatingPointExponent(); private enum State { AT_START, AT_START_MINUS_SEEN, IN_INTEGER_PART_DIGITS_SEEN, DOT_SEEN, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponent() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { state = State.AT_START_MINUS_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } case AT_START_MINUS_SEEN: if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_EXPONENT_DIGITS_SEEN: return; case AT_START: throw newDatatypeException(\"The empty string is not a valid floating point number.\"); case AT_START_MINUS_SEEN: throw newDatatypeException(\"The minus sign alone is not a valid floating point number.\"); case DOT_SEEN: throw newDatatypeException(\"A floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponentNonNegative extends AbstractDatatype {  public static final FloatingPointExponentNonNegative THE_INSTANCE = new FloatingPointExponentNonNegative(); private enum State { AT_START, AT_START_MINUS_SEEN, IN_INTEGER_PART_DIGITS_SEEN, IN_INTEGER_PART_DIGITS_SEEN_ZERO, DOT_SEEN, DOT_SEEN_ZERO, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_DECIMAL_PART_DIGITS_SEEN_ZERO, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponentNonNegative() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { state = State.AT_START_MINUS_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign or a digit but saw \", c, \" instead.\"); } case AT_START_MINUS_SEEN: if (c == '0') { state = State.IN_INTEGER_PART_DIGITS_SEEN_ZERO; continue; } else { throw newDatatypeException(i, \"Expected a zero but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN_ZERO: if (c == '.') { state = State.DOT_SEEN_ZERO; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (c == '0') { continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a zero but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case DOT_SEEN_ZERO: if (c == '0') { state = State.IN_DECIMAL_PART_DIGITS_SEEN_ZERO; continue; } else { throw newDatatypeException(i, \"Expected a zero after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN_ZERO: if (c == '0') { continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a zero but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_INTEGER_PART_DIGITS_SEEN_ZERO: case IN_DECIMAL_PART_DIGITS_SEEN_ZERO: case IN_EXPONENT_DIGITS_SEEN: return; case AT_START: throw newDatatypeException(\"The empty string is not a valid non-negative floating point number.\"); case AT_START_MINUS_SEEN: throw newDatatypeException(\"The minus sign alone is not a valid non-negative floating point number.\"); case DOT_SEEN: case DOT_SEEN_ZERO: throw newDatatypeException(\"A non-negative floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A non-negative floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A non-negative floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"non-negative floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class FloatingPointExponentPositive extends AbstractDatatype {  public static final FloatingPointExponentPositive THE_INSTANCE = new FloatingPointExponentPositive(); private enum State { AT_START, IN_INTEGER_PART_DIGITS_SEEN, DOT_SEEN, E_SEEN, IN_DECIMAL_PART_DIGITS_SEEN, IN_EXPONENT_SIGN_SEEN, IN_EXPONENT_DIGITS_SEEN }  private FloatingPointExponentPositive() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; boolean zero = true; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (c == '-') { throw newDatatypeException(i, \"A positive floating point number cannot start with the minus sign.\"); } else if (isAsciiDigit(c)) { if (c != '0') { zero = false; } state = State.IN_INTEGER_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_INTEGER_PART_DIGITS_SEEN: if (c == '.') { state = State.DOT_SEEN; continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else if (isAsciiDigit(c)) { if (c != '0') { zero = false; } continue; } else { throw newDatatypeException(i, \"Expected a decimal point, \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case DOT_SEEN: if (isAsciiDigit(c)) { if (c != '0') { zero = false; } state = State.IN_DECIMAL_PART_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit after the decimal point but saw \", c, \" instead.\"); } case IN_DECIMAL_PART_DIGITS_SEEN: if (isAsciiDigit(c)) { if (c != '0') { zero = false; } continue; } else if (c == 'e' || c == 'E') { state = State.E_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201Ce\\u201D, \\u201CE\\u201D or a digit but saw \", c, \" instead.\"); } case E_SEEN: if (c == '-' || c == '+') { state = State.IN_EXPONENT_SIGN_SEEN; continue; } else if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a minus sign, a plus sign or a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_SIGN_SEEN: if (isAsciiDigit(c)) { state = State.IN_EXPONENT_DIGITS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } case IN_EXPONENT_DIGITS_SEEN: if (isAsciiDigit(c)) { continue; } else { throw newDatatypeException(i, \"Expected a digit but saw \", c, \" instead.\"); } } } switch (state) { case IN_INTEGER_PART_DIGITS_SEEN: case IN_DECIMAL_PART_DIGITS_SEEN: case IN_EXPONENT_DIGITS_SEEN: if (zero) { throw newDatatypeException(\"Zero is not a valid positive floating point number.\"); } return; case AT_START: throw newDatatypeException(\"The empty string is not a valid positive floating point number.\"); case DOT_SEEN: throw newDatatypeException(\"A positive floating point number must not end with the decimal point.\"); case E_SEEN: throw newDatatypeException(\"A positive floating point number must not end with the exponent \\u201Ce\\u201D.\"); case IN_EXPONENT_SIGN_SEEN: throw newDatatypeException(\"A positive floating point number must not end with only a sign in the exponent.\"); } } @Override public String getName() { return \"positive floating point number\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.BufferedReader; import java.io.IOException; import java.io.Reader; import java.io.StringReader; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.RhinoException; import org.relaxng.datatype.DatatypeException; public class FunctionBody extends AbstractDatatype {  public static final FunctionBody THE_INSTANCE = new FunctionBody(); protected FunctionBody() { super(); } public void checkValid(CharSequence literal) throws DatatypeException { try { Reader reader = new BufferedReader((new StringReader( \"function(event){\" + literal.toString() + \"}\"))); reader.mark(1); try { Context context = ContextFactory.getGlobal().enterContext(); context.setOptimizationLevel(0); context.setLanguageVersion(Context.VERSION_1_6); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class HashName extends AbstractDatatype {  public static final HashName THE_INSTANCE = new HashName();  private HashName() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid hash-name reference.\"); } else if (literal.charAt(0) != '#') { throw newDatatypeException(\"A hash-name reference must start with \\u201C#\\u201D.\"); } else if (literal.length() == 1) { throw newDatatypeException(\"A hash-name reference must have at least one character after \\u201C#\\u201D.\"); } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class Html5DatatypeException extends DatatypeException { private Class datatypeClass; private String[] segments;  final boolean warning; public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String message) { super(index, \"Bad \" + datatypeName + \": \" + message); this.datatypeClass = datatypeClass; this.segments = new String[1]; this.segments[0] = message; this.warning = false; } public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String head, String literal, String tail) { super(index, \"Bad \" + datatypeName + \": \" + head + '\\u201C' + literal + '\\u201D' + tail); this.datatypeClass = datatypeClass; this.segments = new String[3]; this.segments[0] = head; this.segments[1] = literal; this.segments[2] = tail; this.warning = false; } public Html5DatatypeException(Class datatypeClass, String datatypeName, String message) { this(-1, datatypeClass, datatypeName, message); } public Html5DatatypeException(Class datatypeClass, String datatypeName, String head, String literal, String tail) { this(-1, datatypeClass, datatypeName, head, literal, tail); }  public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String message, boolean warning) { super(index, \"Bad \" + datatypeName + \": \" + message); this.datatypeClass = datatypeClass; this.segments = new String[1]; this.segments[0] = message; this.warning = warning; } public Html5DatatypeException(int index, Class datatypeClass, String datatypeName, String head, String literal, String tail, boolean warning) { super(index, \"Bad \" + datatypeName + \": \" + head + '\\u201C' + literal + '\\u201D' + tail); this.datatypeClass = datatypeClass; this.segments = new String[3]; this.segments[0] = head; this.segments[1] = literal; this.segments[2] = tail; this.warning = warning; } public Html5DatatypeException(Class datatypeClass, String datatypeName, String message, boolean warning) { this(-1, datatypeClass, datatypeName, message, warning); } public Html5DatatypeException(Class datatypeClass, String datatypeName, String head, String literal, String tail, boolean warning) { this(-1, datatypeClass, datatypeName, head, literal, tail, warning); }  public Class getDatatypeClass() { return datatypeClass; }  public String[] getSegments() { return segments; }  public boolean isWarning() { return warning; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.Datatype; import org.relaxng.datatype.DatatypeBuilder; import org.relaxng.datatype.DatatypeException; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.helpers.ParameterlessDatatypeBuilder;  public class Html5DatatypeLibrary implements DatatypeLibrary { public Html5DatatypeLibrary() { super(); }  public DatatypeBuilder createDatatypeBuilder(String baseTypeLocalName) throws DatatypeException { return new ParameterlessDatatypeBuilder(createDatatype(baseTypeLocalName)); }  public Datatype createDatatype(String typeLocalName) throws DatatypeException { if (\"ID\".equals(typeLocalName)) { return new Id(); } else if (\"IDREF\".equals(typeLocalName)) { return Idref.THE_INSTANCE; } else if (\"IDREFS\".equals(typeLocalName)) { return Idrefs.THE_INSTANCE; } else if (\"pattern\".equals(typeLocalName)) { return Pattern.THE_INSTANCE; } else if (\"datetime\".equals(typeLocalName)) { return Datetime.THE_INSTANCE; } else if (\"datetime-local\".equals(typeLocalName)) { return DatetimeLocal.THE_INSTANCE; } else if (\"datetime-tz\".equals(typeLocalName)) { return DatetimeTz.THE_INSTANCE; } else if (\"date-or-time\".equals(typeLocalName)) { return DateOrTime.THE_INSTANCE; } else if (\"date\".equals(typeLocalName)) { return Date.THE_INSTANCE; } else if (\"month\".equals(typeLocalName)) { return Month.THE_INSTANCE; } else if (\"week\".equals(typeLocalName)) { return Week.THE_INSTANCE; } else if (\"time\".equals(typeLocalName)) { return Time.THE_INSTANCE; } else if (\"iri\".equals(typeLocalName)) { return Iri.THE_INSTANCE; } else if (\"iri-ref\".equals(typeLocalName)) { return IriRef.THE_INSTANCE; } else if (\"string\".equals(typeLocalName)) { return AsciiCaseInsensitiveString.THE_INSTANCE; } else if (\"language\".equals(typeLocalName)) { return Language.THE_INSTANCE; } else if (\"media-query\".equals(typeLocalName)) { return MediaQuery.THE_INSTANCE; } else if (\"mime-type\".equals(typeLocalName)) { return MimeType.THE_INSTANCE; } else if (\"browsing-context\".equals(typeLocalName)) { return BrowsingContext.THE_INSTANCE; } else if (\"browsing-context-or-keyword\".equals(typeLocalName)) { return BrowsingContextOrKeyword.THE_INSTANCE; } else if (\"hash-name\".equals(typeLocalName)) { return HashName.THE_INSTANCE; } else if (\"integer\".equals(typeLocalName)) { return Int.THE_INSTANCE; } else if (\"integer-non-negative\".equals(typeLocalName)) { return IntNonNegative.THE_INSTANCE; } else if (\"integer-positive\".equals(typeLocalName)) { return IntPositive.THE_INSTANCE; } else if (\"float\".equals(typeLocalName)) { return FloatingPointExponent.THE_INSTANCE; } else if (\"float-non-negative\".equals(typeLocalName)) { return FloatingPointExponentNonNegative.THE_INSTANCE; } else if (\"float-positive\".equals(typeLocalName)) { return FloatingPointExponentPositive.THE_INSTANCE; } else if (\"mime-type-list\".equals(typeLocalName)) { return MimeTypeList.THE_INSTANCE; } else if (\"circle\".equals(typeLocalName)) { return Circle.THE_INSTANCE; } else if (\"rectangle\".equals(typeLocalName)) { return Rectangle.THE_INSTANCE; } else if (\"polyline\".equals(typeLocalName)) { return Polyline.THE_INSTANCE; } else if (\"xml-name\".equals(typeLocalName)) { return XmlName.THE_INSTANCE; } else if (\"meta-charset\".equals(typeLocalName)) { return MetaCharset.THE_INSTANCE; } else if (\"microdata-property\".equals(typeLocalName)) { return MicrodataProperty.THE_INSTANCE; } else if (\"charset\".equals(typeLocalName)) { return Charset.THE_INSTANCE; } else if (\"refresh\".equals(typeLocalName)) { return Refresh.THE_INSTANCE; } else if (\"paren-start\".equals(typeLocalName)) { return ParenthesisStart.THE_INSTANCE; } else if (\"paren-end\".equals(typeLocalName)) { return ParenthesisEnd.THE_INSTANCE; } else if (\"email-address\".equals(typeLocalName)) { return EmailAddress.THE_INSTANCE; } else if (\"email-address-list\".equals(typeLocalName)) { return EmailAddressList.THE_INSTANCE; } else if (\"keylabellist\".equals(typeLocalName)) { return KeyLabelList.THE_INSTANCE; } else if (\"zero\".equals(typeLocalName)) { return Zero.THE_INSTANCE; } else if (\"cdo-cdc-pair\".equals(typeLocalName)) { return CdoCdcPair.THE_INSTANCE; } else if (\"script\".equals(typeLocalName)) { return Script.THE_INSTANCE; } else if (\"script-documentation\".equals(typeLocalName)) { return ScriptDocumentation.THE_INSTANCE; } else if (\"functionbody\".equals(typeLocalName)) { return FunctionBody.THE_INSTANCE; } else if (\"a-rel\".equals(typeLocalName)) { return ARel.THE_INSTANCE; } else if (\"link-rel\".equals(typeLocalName)) { return LinkRel.THE_INSTANCE; } else if (\"meta-name\".equals(typeLocalName)) { return MetaName.THE_INSTANCE; } else if (\"non-empty-string\".equals(typeLocalName)) { return NonEmptyString.THE_INSTANCE; } else if (\"string-without-line-breaks\".equals(typeLocalName)) { return StringWithoutLineBreaks.THE_INSTANCE; } else if (\"simple-color\".equals(typeLocalName)) { return SimpleColor.THE_INSTANCE; } else if (\"time-datetime\".equals(typeLocalName)) { return TimeDatetime.THE_INSTANCE; } else if (\"svg-pathdata\".equals(typeLocalName)) { return new SvgPathData(); } throw new DatatypeException(\"Unknown local name for datatype: \" + typeLocalName); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeLibrary; import org.relaxng.datatype.DatatypeLibraryFactory;  public class Html5DatatypeLibraryFactory implements DatatypeLibraryFactory {  private static final String NAMESPACE = \"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class Id extends AbstractDatatype {  public static final Id THE_INSTANCE = new Id();  protected Id() { super(); }  public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); if (len == 0) { throw newDatatypeException(\"An ID must not be the empty string.\"); } for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (isWhitespace(c)) { throw newDatatypeException(i, \"An ID must not contain whitespace.\"); } } } @Override public String getName() { return \"id\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype;  public final class Idref extends Id {  public static final Idref THE_INSTANCE = new Idref();  private Idref() { super(); } @Override public String getName() { return \"id reference\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public final class Idrefs extends AbstractDatatype {  public static final Idrefs THE_INSTANCE = new Idrefs();  private Idrefs() { super(); }  public void checkValid(CharSequence literal) throws DatatypeException { for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); if (!isWhitespace(c)) { return; } } throw newDatatypeException(\"An IDREFS value must contain at least one non-whitespace character.\"); } @Override public String getName() { return \"id references\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Int extends AbstractInt {  public static final Int THE_INSTANCE = new Int();  private Int() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkInt(literal, 0); } @Override public String getName() { return \"integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class IntNonNegative extends AbstractInt {  public static final IntNonNegative THE_INSTANCE = new IntNonNegative();  private IntNonNegative() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkIntNonNegative(literal, 0); } @Override public String getName() { return \"non-negative integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class IntPositive extends AbstractInt {  public static final IntPositive THE_INSTANCE = new IntPositive();  private IntPositive() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { checkIntPositive(literal, 0); } @Override public String getName() { return \"positive integer\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; public class Iri extends IriRef {  public static final Iri THE_INSTANCE = new Iri(); protected Iri() { super(); } protected boolean isAbsolute() { return true; } @Override public String getName() { return \"absolute IRI\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.io.StringReader; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.RhinoException; import org.relaxng.datatype.DatatypeException; import org.whattf.io.DataUri; import org.whattf.io.DataUriException; import org.whattf.io.Utf8PercentDecodingReader; import com.hp.hpl.jena.iri.IRI; import com.hp.hpl.jena.iri.IRIException; import com.hp.hpl.jena.iri.IRIFactory; import com.hp.hpl.jena.iri.Violation; public class IriRef extends AbstractDatatype {  public static final IriRef THE_INSTANCE = new IriRef(); protected IriRef() { super(); } private final static boolean WARN = System.getProperty(\"org.whattf.datatype.warn\",\"\").equals(\"true\") ? true : false;  private enum KnownViolationCode { COMPATIBILITY_CHARACTER, CONTROL_CHARACTER, DNS_LABEL_DASH_START_OR_END, DOUBLE_WHITESPACE, EMPTY_SCHEME, HAS_PASSWORD, ILLEGAL_CHARACTER, ILLEGAL_PERCENT_ENCODING, IP_V4_HAS_FOUR_COMPONENTS, IP_V4_OCTET_RANGE, IP_V6_OR_FUTURE_ADDRESS_SYNTAX, NON_INITIAL_DOT_SEGMENT, NOT_DNS_NAME, PORT_SHOULD_NOT_BE_WELL_KNOWN, REQUIRED_COMPONENT_MISSING, SCHEME_MUST_START_WITH_LETTER, UNDEFINED_UNICODE_CHARACTER, UNICODE_WHITESPACE, UNREGISTERED_NONIETF_SCHEME_TREE, WHITESPACE, ZZZ_DUMMY_DEFAULT } private final CharSequencePair splitScheme(CharSequence iri) { StringBuilder sb = new StringBuilder(); Boolean atSchemeBeginning = true; for (int i = 0; i < iri.length(); i++) { char c = toAsciiLowerCase(iri.charAt(i)); if (atSchemeBeginning) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; import java.util.Arrays; import com.ibm.icu.lang.UCharacter; public class KeyLabelList extends AbstractDatatype {  public static final KeyLabelList THE_INSTANCE = new KeyLabelList(); private KeyLabelList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { String[] keylabels = literal.toString().split(\"\\\\s+\"); Arrays.sort(keylabels); for (int i = 0; i < keylabels.length; i++) { String label = keylabels[i]; if (i > 0 && label.equals(keylabels[i-1])) { throw newDatatypeException( \"Duplicate key label. Each key label must be unique.\"); } if (label.length() == 2) { char[] chars = label.toCharArray(); if (!(UCharacter.isHighSurrogate(chars[0]) && UCharacter.isLowSurrogate(chars[1]))) { throw newDatatypeException( \"Key label has multiple characters. Each key label must be a single character.\"); } } if (label.length() > 2) { throw newDatatypeException( \"Key label has multiple characters. Each key label must be a single character.\"); } } } @Override public String getName() { return \"key label list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException; import org.whattf.datatype.data.LanguageData;  public final class Language extends AbstractDatatype {  public static final Language THE_INSTANCE = new Language(); private static final Pattern HYPHEN = Pattern.compile(\"-\"); private static final boolean WARN = System.getProperty( \"org.whattf.datatype.warn\", \"\").equals(\"true\") ? true : false; private static String[] languages = null; private static String[] extlangs = null; private static String[] scripts = null; private static String[] regions = null; private static String[] variants = null; private static String[] grandfathered = null; private static String[] redundant = null; private static String[] deprecated = null; private static String[] deprecatedLang = null; private static int[] suppressedScriptByLanguage = null; private static Map<String, String> preferredValueByLanguageMap = new HashMap<String, String>(); private static String[][][] prefixesByVariant = null; private static int[] prefixByExtlang = null; static { try { LanguageData data = new LanguageData(); languages = data.getLanguages(); extlangs = data.getExtlangs(); scripts = data.getScripts(); regions = data.getRegions(); variants = data.getVariants(); grandfathered = data.getGrandfathered(); redundant = data.getRedundant(); deprecated = data.getDeprecated(); deprecatedLang = data.getDeprecatedLang(); suppressedScriptByLanguage = data.getSuppressedScriptByLanguage(); prefixByExtlang = data.getPrefixByExtlang(); preferredValueByLanguageMap = data.getPreferredValueByLanguageMap(); prefixesByVariant = data.getPrefixesByVariant(); } catch (IOException e) { throw new RuntimeException(e); } }  private Language() { super(); } public void checkValid(CharSequence lit) throws DatatypeException { String literal = lit.toString(); if (literal.length() == 0) { throw newDatatypeException(\"The empty string is not a valid language tag.\"); } literal = toAsciiLowerCase(literal); if (isGrandfathered(literal)) { if (isDeprecated(literal) && WARN) { throw newDatatypeException(\"The grandfathered language tag \", literal, \" is deprecated.\" + \" Use \\u201C\" + preferredValueByLanguageMap.get(literal) + \"\\u201D instead.\", WARN); } return; } if (isRedundant(literal)) { if (isDeprecated(literal) && WARN) { throw newDatatypeException(\"The language tag \", lit.toString(), \" is deprecated.\" + \" Use \\u201C\" + preferredValueByLanguageMap.get(literal) + \"\\u201D instead.\", WARN); } return; } if (literal.startsWith(\"-\")) { throw newDatatypeException(\"Language tag must not start with HYPHEN-MINUS.\"); } if (literal.endsWith(\"-\")) { throw newDatatypeException(\"Language tag must not end with HYPHEN-MINUS.\"); } String[] subtags = HYPHEN.split(literal); for (int j = 0; j < subtags.length; j++) { int len = subtags[j].length(); if (len == 0) { throw newDatatypeException(\"Zero-length subtag.\"); } else if (len > 8) { throw newDatatypeException(\"Subtags must not exceed 8 characters in length.\"); } } "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; public class LinkRel extends AbstractRel { private static final String[] REGISTERED_TOKENS = { \"alternate\", \"appendix\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.Set; import org.relaxng.datatype.DatatypeException; public class MediaQuery extends AbstractDatatype {  public static final MediaQuery THE_INSTANCE = new MediaQuery(); private static final boolean WARN = System.getProperty( \"org.whattf.datatype.warn\", \"\").equals(\"true\") ? true : false; private enum State { INITIAL_WS, OPEN_PAREN_SEEN, IN_ONLY_OR_NOT, IN_MEDIA_TYPE, IN_MEDIA_FEATURE, WS_BEFORE_MEDIA_TYPE, WS_BEFORE_AND, IN_AND, WS_BEFORE_EXPRESSION, WS_BEFORE_COLON, WS_BEFORE_VALUE, IN_VALUE_DIGITS, IN_VALUE_SCAN, IN_VALUE_ORIENTATION, WS_BEFORE_CLOSE_PAREN, IN_VALUE_UNIT, IN_VALUE_DIGITS_AFTER_DOT, RATIO_SECOND_INTEGER_START, IN_VALUE_BEFORE_DIGITS, IN_VALUE_DIGITS_AFTER_DOT_TRAIL, AFTER_CLOSE_PAREN, IN_VALUE_ONEORZERO } private enum ValueType { LENGTH, RATIO, INTEGER, RESOLUTION, SCAN, ORIENTATION, NONZEROINTEGER, ONEORZERO } private static final Set<String> LENGTH_UNITS = new HashSet<String>(); static { LENGTH_UNITS.add(\"em\"); LENGTH_UNITS.add(\"ex\"); LENGTH_UNITS.add(\"px\"); LENGTH_UNITS.add(\"gd\"); LENGTH_UNITS.add(\"rem\"); LENGTH_UNITS.add(\"vw\"); LENGTH_UNITS.add(\"vh\"); LENGTH_UNITS.add(\"vm\"); LENGTH_UNITS.add(\"ch\"); LENGTH_UNITS.add(\"in\"); LENGTH_UNITS.add(\"cm\"); LENGTH_UNITS.add(\"mm\"); LENGTH_UNITS.add(\"pt\"); LENGTH_UNITS.add(\"pc\"); } private static final Set<String> MEDIA_TYPES = new HashSet<String>(); static { MEDIA_TYPES.add(\"all\"); MEDIA_TYPES.add(\"aural\"); MEDIA_TYPES.add(\"braille\"); MEDIA_TYPES.add(\"handheld\"); MEDIA_TYPES.add(\"print\"); MEDIA_TYPES.add(\"projection\"); MEDIA_TYPES.add(\"screen\"); MEDIA_TYPES.add(\"tty\"); MEDIA_TYPES.add(\"tv\"); MEDIA_TYPES.add(\"embossed\"); MEDIA_TYPES.add(\"speech\"); } private enum MediaType { ALL, AURAL, BRAILLE, HANDHELD, PRINT, PROJECTION, SCREEN, TTY, TV, EMBOSSED, SPEECH, INVALID; private static MediaType toCaps(String str) { try { return valueOf(toAsciiUpperCase(str)); } catch (Exception ex) { return INVALID; } } } private static final Map<String, ValueType> FEATURES_TO_VALUE_TYPES = new HashMap<String, ValueType>(); static { FEATURES_TO_VALUE_TYPES.put(\"width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-device-width\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"min-device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"max-device-height\", ValueType.LENGTH); FEATURES_TO_VALUE_TYPES.put(\"device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"min-device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"max-device-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"min-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"max-aspect-ratio\", ValueType.RATIO); FEATURES_TO_VALUE_TYPES.put(\"color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-color\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-color-index\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"min-monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"max-monochrome\", ValueType.INTEGER); FEATURES_TO_VALUE_TYPES.put(\"resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"min-resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"max-resolution\", ValueType.RESOLUTION); FEATURES_TO_VALUE_TYPES.put(\"scan\", ValueType.SCAN); FEATURES_TO_VALUE_TYPES.put(\"orientation\", ValueType.ORIENTATION); FEATURES_TO_VALUE_TYPES.put(\"grid\", ValueType.ONEORZERO); } private static final String[] visualFeatures = { \"aspect-ratio\", \"color\", \"color-index\", \"device-aspect-ratio\", \"max-aspect-ratio\", \"max-color\", \"max-color-index\", \"max-device-aspect-ratio\", \"max-monochrome\", \"max-resolution\", \"min-aspect-ratio\", \"min-color\", \"min-color-index\", \"min-device-aspect-ratio\", \"min-monochrome\", \"min-resolution\", \"monochrome\", \"orientation\", \"resolution\", }; private static final String[] bitmapFeatures = { \"aspect-ratio\", \"device-aspect-ratio\", \"max-aspect-ratio\", \"max-device-aspect-ratio\", \"max-resolution\", \"min-aspect-ratio\", \"min-device-aspect-ratio\", \"min-resolution\", \"orientation\", \"resolution\", }; private static final String scanWarning = \"The media feature \\u201cscan\\u201d is applicable only to the media type \\u201ctv\\u201d. \"; private MediaQuery() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<String> warnings = new ArrayList<String>(); List<CharSequenceWithOffset> queries = split(literal, ','); for (CharSequenceWithOffset query : queries) { warnings = checkQuery(query.getSequence(), query.getOffset(), warnings); } if (!warnings.isEmpty() && WARN) { StringBuilder sb = new StringBuilder(); for (String s : warnings) { sb.append(s + \" \"); } throw newDatatypeException(sb.toString().trim(), WARN); } } private List<String> checkQuery(CharSequence query, int offset, List<String> warnings) throws DatatypeException { boolean containsAural = false; boolean zero = true; String type = null; String feature = null; ValueType valueExpectation = null; query = toAsciiLowerCase(query); StringBuilder sb = new StringBuilder(); State state = State.INITIAL_WS; for (int i = 0; i < query.length(); i++) { char c = query.charAt(i); switch (state) { case INITIAL_WS: if (isWhitespace(c)) { continue; } else if ('(' == c) { state = State.OPEN_PAREN_SEEN; continue; } else if ('o' == c || 'n' == c) { sb.append(c); state = State.IN_ONLY_OR_NOT; continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_TYPE; continue; } else { throw newDatatypeException( offset + i, \"Expected \\u201C(\\u201D or letter at start of a media query part but saw \", c, \" instead.\"); } case IN_ONLY_OR_NOT: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c)) { String kw = sb.toString(); sb.setLength(0); if (\"only\".equals(kw) || \"not\".equals(kw)) { state = State.WS_BEFORE_MEDIA_TYPE; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201Conly\\u201D or \\u201Cnot\\u201D but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_MEDIA_TYPE: if (isWhitespace(c)) { continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_TYPE; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_MEDIA_TYPE: if (('a' <= c && 'z' >= c) || c == '-') { sb.append(c); continue; } else if (isWhitespace(c)) {  type = sb.toString(); sb.setLength(0); if (isMediaType(type)) { if (\"aural\".equals(type)) { containsAural = true; } state = State.WS_BEFORE_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected a CSS media type but saw \\u201C\" + type + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter, hyphen or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_AND: if (isWhitespace(c)) { continue; } else if ('a' == c) { sb.append(c); state = State.IN_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or \\u201Cand\\u201D but saw\" + \" \\u201C\" + c + \"\\u201D instead.\"); } case IN_AND: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c)) { String kw = sb.toString(); sb.setLength(0); if (\"and\".equals(kw)) { state = State.WS_BEFORE_EXPRESSION; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201Cand\\u201D but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_EXPRESSION: if (isWhitespace(c)) { continue; } else if ('(' == c) { state = State.OPEN_PAREN_SEEN; continue; } else { throw newDatatypeException(offset + i, \"Expected \\u201C(\\u201D or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case OPEN_PAREN_SEEN: if (isWhitespace(c)) { continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_MEDIA_FEATURE; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter at start of a media feature part but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_MEDIA_FEATURE: if (('a' <= c && 'z' >= c) || c == '-') { sb.append(c); continue; } else if (c == ')') { String kw = sb.toString(); sb.setLength(0); checkApplicability(offset + i, kw, type, warnings); checkIfValueRequired(offset + i, kw); state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c) || c == ':') { String kw = sb.toString(); sb.setLength(0); checkApplicability(offset + i, kw, type, warnings); feature = kw; valueExpectation = valueExpectationFor(kw); if (valueExpectation != null) { if (c == ':') { state = State.WS_BEFORE_VALUE; continue; } else { state = State.WS_BEFORE_COLON; continue; } } else { throw newDatatypeException(offset + i, \"Expected a CSS media feature but saw \\u201C\" + kw + \"\\u201D instead.\"); } } else { throw newDatatypeException(offset + i, \"Expected a letter, hyphen, colon or whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_COLON: if (isWhitespace(c)) { continue; } else if (':' == c) { state = State.WS_BEFORE_VALUE; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or colon but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_VALUE: if (isWhitespace(c)) { continue; } else { zero = true; switch (valueExpectation) { case SCAN: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_SCAN; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter but saw \\u201C\" + c + \"\\u201D instead.\"); } case ORIENTATION: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_ORIENTATION; continue; } else { throw newDatatypeException(offset + i, \"Expected a letter but saw \\u201C\" + c + \"\\u201D instead.\"); } case ONEORZERO: if (c == '0' || c == '1') { sb.append(c); state = State.IN_VALUE_ONEORZERO; continue; } else { throw newDatatypeException( offset + i, \"Expected \\u201C0\\u201D or \\u201C1\\u201D as \\u201c\" + feature + \"\\u201d value but found \\u201C\" + c + \"\\u201D instead.\"); } default: if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else if ('0' == c) { state = State.IN_VALUE_DIGITS; continue; } else if ('+' == c) { state = State.IN_VALUE_BEFORE_DIGITS; continue; } else if ('.' == c && valueExpectation == ValueType.LENGTH) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Expected a digit, a dot or a plus sign but saw \\u201C\" + c + \"\\u201D instead.\"); } else { throw newDatatypeException(offset + i, \"Expected a digit or a plus sign but saw \\u201C\" + c + \"\\u201D instead.\"); } } } case IN_VALUE_SCAN: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (!(\"progressive\".equals(kw) || \"interlace\".equals(kw))) { throw newDatatypeException( offset + i, \"Expected \\u201Cprogressive\\u201D or \\u201Cinterlace\\u201D as the scan mode value but saw \\u201C\" + kw + \"\\u201D instead.\"); } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_ORIENTATION: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (!(\"portrait\".equals(kw) || \"landscape\".equals(kw))) { throw newDatatypeException( offset + i, \"Expected \\u201Cportrait\\u201D or \\u201Clandscape\\u201D as the \\u201corientation\\u201d value but saw \\u201C\" + kw + \"\\u201D instead.\"); } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_ONEORZERO: if (isWhitespace(c) || c == ')') { sb.setLength(0); if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { sb.append(c); String kw = sb.toString(); throw newDatatypeException(offset + i, \"Expected \\u201C0\\u201D or \\u201C1\\u201D as \\u201c\" + feature + \"\\u201d value but saw \\u201C\" + kw + \"\\u201D instead.\"); } case IN_VALUE_BEFORE_DIGITS: if ('0' == c) { state = State.IN_VALUE_DIGITS; continue; } else if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('.' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else { throw newDatatypeException(offset + i, \"Expected a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case INTEGER: case RATIO: throw newDatatypeException(offset + i, \"Expected a digit but saw \\u201C\" + c + \"\\u201D instead.\"); default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_DIGITS: if ('0' == c) { continue; } else if ('1' <= c && '9' >= c) { zero = false; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('.' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT; continue; } else if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_UNIT; continue; } else if (isWhitespace(c) || c == ')') { if (!zero) { if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Non-zero lengths require a unit.\"); } else { throw newDatatypeException(offset + i, \"Non-zero resolutions require a unit.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case INTEGER: if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case NONZEROINTEGER: if (c == ')') { if (zero) { throw newDatatypeException(offset + i, \"Expected a non-zero positive integer.\"); } state = State.AFTER_CLOSE_PAREN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } case RATIO: if (isWhitespace(c)) { continue; } else if (c == '/') { if (zero) { throw newDatatypeException(offset + i, \"Expected non-zero positive integer in ratio value.\"); } valueExpectation = ValueType.NONZEROINTEGER; state = State.RATIO_SECOND_INTEGER_START; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or\" + \" \\u201C/\\u201D for \" + feature + \" value but saw \\u201C\" + c + \"\\u201D instead.\"); } default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_DIGITS_AFTER_DOT: if ('0' == c) { state = State.IN_VALUE_DIGITS_AFTER_DOT_TRAIL; continue; } else if ('1' <= c && '9' >= c) { state = State.IN_VALUE_DIGITS_AFTER_DOT_TRAIL; zero = false; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case IN_VALUE_DIGITS_AFTER_DOT_TRAIL: if ('0' == c) { continue; } else if ('1' <= c && '9' >= c) { zero = false; continue; } else { switch (valueExpectation) { case LENGTH: case RESOLUTION: if ('a' <= c && 'z' >= c) { sb.append(c); state = State.IN_VALUE_UNIT; continue; } else if (isWhitespace(c) || c == ')') { if (!zero) { if (valueExpectation == ValueType.LENGTH) { throw newDatatypeException(offset + i, \"Non-zero lengths require a unit.\"); } else { throw newDatatypeException(offset + i, \"Non-zero resolutions require a unit.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a digit, whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } default: throw new RuntimeException(\"Impossible state.\"); } } case IN_VALUE_UNIT: if ('a' <= c && 'z' >= c) { sb.append(c); continue; } else if (isWhitespace(c) || c == ')') { String kw = sb.toString(); sb.setLength(0); if (valueExpectation == ValueType.LENGTH) { if (!isLengthUnit(kw)) { throw newDatatypeException(offset + i, \"Expected a length unit but saw \\u201C\" + c + \"\\u201D instead.\"); } } else { if (!(\"dpi\".equals(kw) || \"dpcm\".equals(kw))) { throw newDatatypeException(offset + i, \"Expected a resolution unit but saw \\u201C\" + c + \"\\u201D instead.\"); } } if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { state = State.WS_BEFORE_CLOSE_PAREN; continue; } } else { throw newDatatypeException(offset + i, \"Expected a letter, a dot or a digit but saw \\u201C\" + c + \"\\u201D instead.\"); } case RATIO_SECOND_INTEGER_START: valueExpectation = ValueType.NONZEROINTEGER; if (isWhitespace(c)) { continue; } else if ('1' <= c && '9' >= c) { zero = false; state = State.IN_VALUE_DIGITS; continue; } else if ('0' == c) { zero = true; state = State.IN_VALUE_DIGITS; continue; } else if ('+' == c) { state = State.IN_VALUE_BEFORE_DIGITS; continue; } else { throw newDatatypeException(offset + i, \"Expected a digit, whitespace or a plus sign\" + \" for \" + feature + \" value but saw \\u201C\" + c + \"\\u201D instead.\"); } case AFTER_CLOSE_PAREN: if (isWhitespace(c)) { state = State.WS_BEFORE_AND; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace but saw \\u201C\" + c + \"\\u201D instead.\"); } case WS_BEFORE_CLOSE_PAREN: if (isWhitespace(c)) { continue; } else if (c == ')') { state = State.AFTER_CLOSE_PAREN; continue; } else { throw newDatatypeException(offset + i, \"Expected whitespace or \\u201C)\\u201D but saw \\u201C\" + c + \"\\u201D instead.\"); } } } switch (state) { case AFTER_CLOSE_PAREN: case WS_BEFORE_AND: if (containsAural && WARN) { warnings.add(\"The media type \\u201caural\\u201d is deprecated. Use \\u201cspeech\\u201d instead. \"); } return warnings; case IN_MEDIA_TYPE: String kw = sb.toString(); sb.setLength(0); if (isMediaType(kw)) { if (\"aural\".equals(kw) && WARN) { warnings.add(\"The media type \\u201caural\\u201d is deprecated. Use \\u201cspeech\\u201d instead. \"); } return warnings; } else { throw newDatatypeException(\"Expected a CSS media type but the query ended.\"); } default: throw newDatatypeException(\"Media query ended prematurely.\"); } } private boolean isMediaFeature(String feature) { return FEATURES_TO_VALUE_TYPES.containsKey(feature); } private ValueType valueExpectationFor(String feature) { return FEATURES_TO_VALUE_TYPES.get(feature); } private boolean isMediaType(String type) { return MEDIA_TYPES.contains(type); } private boolean isLengthUnit(String unit) { return LENGTH_UNITS.contains(unit); } private List<String> checkApplicability(int index, String feature, String type, List<String> warnings) throws DatatypeException { if (!isMediaType(type)) { return warnings; } if (!isMediaFeature(feature)) { throw newDatatypeException(index, \"Expected a CSS media feature but saw \\u201C\" + feature + \"\\u201D instead.\"); } if (\"scan\".equals(feature) && !\"tv\".equals(type)) { warnings.add(scanWarning); return warnings; } switch (MediaType.toCaps(type)) { case SPEECH: warnings.add(\"The media feature \\u201c\" + feature + \"\\u201d is not applicable to the media type \\u201cspeech\\u201d. \"); return warnings; case BRAILLE: case EMBOSSED: if (Arrays.binarySearch(visualFeatures, feature) > -1) { warnings.add(\"The visual media feature \\u201c\" + feature + \"\\u201d is not applicable to the tactile media type \\u201c\" + type + \"\\u201d. \"); } return warnings; case TTY: if (Arrays.binarySearch(bitmapFeatures, feature) > -1) { warnings.add(\"The bitmap media feature \\u201c\" + feature + \"\\u201d is not applicable to the media type \\u201ctty\\u201d. \"); } return warnings; default: return warnings; } } private void checkIfValueRequired(int index, String feature) throws DatatypeException { if (feature.startsWith(\"min-\") || feature.startsWith(\"max-\")) { throw newDatatypeException(index, \"Expected a value for the media feature \\u201C\" + feature + \"\\u201D.\"); } } @Override public String getName() { return \"media query\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.whattf.datatype.data.CharsetData; import org.relaxng.datatype.DatatypeException; public class MetaCharset extends AbstractDatatype {  public static final MetaCharset THE_INSTANCE = new MetaCharset(); "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import org.relaxng.datatype.DatatypeException; public class MetaName extends AbstractDatatype { private static final String[] VALID_NAMES = { \"aglsterms.act\", "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException;  public class MicrodataProperty extends Iri {  public static final MicrodataProperty THE_INSTANCE = new MicrodataProperty(); protected MicrodataProperty() { super(); } @Override public String getName() { return \"microdata property\"; } @Override public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (c == '.' || c == ':') { super.checkValid(literal); break; } } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class MimeType extends AbstractDatatype {  public static final MimeType THE_INSTANCE = new MimeType(); private enum State { AT_START, IN_SUPERTYPE, AT_SUBTYPE_START, IN_SUBTYPE, SEMICOLON_SEEN, WS_BEFORE_SEMICOLON, IN_PARAM_NAME, EQUALS_SEEN, IN_QUOTED_STRING, IN_UNQUOTED_STRING, IN_QUOTED_PAIR, CLOSE_QUOTE_SEEN } private MimeType() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (isTokenChar(c)) { state = State.IN_SUPERTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character but saw \", c, \" instead.\"); } case IN_SUPERTYPE: if (isTokenChar(c)) { continue; } else if (c == '/') { state = State.AT_SUBTYPE_START; continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C/\\u201D but saw \", c, \" instead.\"); } case AT_SUBTYPE_START: if (isTokenChar(c)) { state = State.IN_SUBTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character but saw \", c, \" instead.\"); } case IN_SUBTYPE: if (isTokenChar(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a semicolon but saw \", c, \" instead.\"); } case WS_BEFORE_SEMICOLON: if (isWhitespace(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else { throw newDatatypeException(i, \"Expected whitespace or a semicolon but saw \", c, \" instead.\"); } case SEMICOLON_SEEN: if (isWhitespace(c)) { continue; } else if (isTokenChar(c)) { state = State.IN_PARAM_NAME; continue; } else { throw newDatatypeException(i, \"Expected whitespace or a token character but saw \", c, \" instead.\"); } case IN_PARAM_NAME: if (isTokenChar(c)) { continue; } else if (c == '=') { state = State.EQUALS_SEEN; continue; } case EQUALS_SEEN: if (c == '\\\"') { state = State.IN_QUOTED_STRING; continue; } else if (isTokenChar(c)) { state = State.IN_UNQUOTED_STRING; continue; } else { throw newDatatypeException(i, \"Expected a double quote or a token character but saw \", c, \" instead.\"); } case IN_QUOTED_STRING: if (c == '\\\\') { state = State.IN_QUOTED_PAIR; continue; } else if (c == '\\\"') { state = State.CLOSE_QUOTE_SEEN; continue; } else if (isQDTextChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a non-control ASCII character but saw \", c, \" instead.\"); } case IN_QUOTED_PAIR: if (c <= 127) { state = State.IN_QUOTED_STRING; continue; } else { throw newDatatypeException(i, \"Expected an ASCII character but saw \", c, \" instead.\"); } case CLOSE_QUOTE_SEEN: if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected an ASCII character but saw \", c, \" instead.\"); } case IN_UNQUOTED_STRING: if (isTokenChar(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else if (isWhitespace(c)) { state = State.WS_BEFORE_SEMICOLON; continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a semicolon but saw \", c, \" instead.\"); } } } switch (state) { case IN_SUBTYPE: case IN_UNQUOTED_STRING: case CLOSE_QUOTE_SEEN: return; case AT_START: throw newDatatypeException( \"Expected a MIME type but saw the empty string.\"); case IN_SUPERTYPE: case AT_SUBTYPE_START: throw newDatatypeException(literal.length() - 1, \"Subtype missing.\"); case EQUALS_SEEN: case IN_PARAM_NAME: throw newDatatypeException(literal.length() - 1, \"Parameter value missing.\"); case IN_QUOTED_PAIR: case IN_QUOTED_STRING: throw newDatatypeException(literal.length() - 1, \"Unfinished quoted string.\"); case SEMICOLON_SEEN: throw newDatatypeException(literal.length() - 1, \"Semicolon seen but there was no parameter following it.\"); case WS_BEFORE_SEMICOLON: throw newDatatypeException(literal.length() - 1, \"Extraneous trailing whitespace.\"); } } private boolean isQDTextChar(char c) { return (c >= ' ' && c <= 126) || (c == '\\n') || (c == '\\r') || (c == '\\t'); } private boolean isTokenChar(char c) { return (c >= 33 && c <= 126) && !(c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\\\' || c == '\\\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}'); } @Override public String getName() { return \"MIME type\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class MimeTypeList extends AbstractDatatype {  public static final MimeTypeList THE_INSTANCE = new MimeTypeList(); private enum State { WS_BEFORE_TYPE, IN_TYPE, ASTERISK_TYPE_SEEN, ASTERISK_AND_SLASH_SEEN, WS_BEFORE_COMMA, SLASH_SEEN, IN_SUBTYPE } private MimeTypeList() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.WS_BEFORE_TYPE; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case WS_BEFORE_TYPE: if (isWhitespace(c)) { continue; } else if (c == '*') { state = State.ASTERISK_TYPE_SEEN; } else if (isTokenChar(c)) { state = State.IN_TYPE; continue; } else { throw newDatatypeException(i, \"Expected whitespace, a token character or \\u201C*\\u201D but saw \", c , \" instead.\"); } case ASTERISK_TYPE_SEEN: if (c == '/') { state = State.ASTERISK_AND_SLASH_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201C/\\u201D but saw \", c , \" instead.\"); } case ASTERISK_AND_SLASH_SEEN: if (c == '*') { state = State.WS_BEFORE_COMMA; continue; } else { throw newDatatypeException(i, \"Expected \\u201C*\\u201D but saw \", c , \" instead.\"); } case IN_TYPE: if (c == '/') { state = State.SLASH_SEEN; continue; } else if (isTokenChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C/\\u201D but saw \", c , \" instead.\"); } case SLASH_SEEN: if (c == '*') { state = State.WS_BEFORE_COMMA; continue; } else if (isTokenChar(c)) { state = State.IN_SUBTYPE; continue; } else { throw newDatatypeException(i, \"Expected a token character or \\u201C*\\u201D but saw \", c , \" instead.\"); } case IN_SUBTYPE: if (isWhitespace(c)) { state = State.WS_BEFORE_COMMA; continue; } else if (c == ',') { state = State.WS_BEFORE_TYPE; continue; } else if (isTokenChar(c)) { continue; } else { throw newDatatypeException(i, \"Expected a token character, whitespace or a comma but saw \", c , \" instead.\"); } case WS_BEFORE_COMMA: if (c == ',') { state = State.WS_BEFORE_TYPE; continue; } else if (isWhitespace(c)) { continue; } else { throw newDatatypeException(i, \"Expected whitespace or a comma but saw \", c , \" instead.\"); } } } switch (state) { case IN_SUBTYPE: case WS_BEFORE_COMMA: return; case ASTERISK_AND_SLASH_SEEN: throw newDatatypeException(\"Expected \\u201C*\\u201D but the literal ended.\"); case ASTERISK_TYPE_SEEN: throw newDatatypeException(\"Expected \\u201C/\\u201D but the literal ended.\"); case IN_TYPE: throw newDatatypeException(\"Expected \\u201C/\\u201D but the literal ended.\"); case SLASH_SEEN: throw newDatatypeException(\"Expected subtype but the literal ended.\"); case WS_BEFORE_TYPE: throw newDatatypeException(\"Expected a MIME type but the literal ended.\"); } } private boolean isTokenChar(char c) { return (c >= 33 && c <= 126) && !(c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\\\' || c == '\\\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}'); } @Override public String getName() { return \"MIME type list\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  public final class Month extends AbstractDatatype {  public static final Month THE_INSTANCE = new Month();  private static final Pattern THE_PATTERN = Pattern.compile(\"^([0-9]{4,})-([0-9]{2})$\");  private Month() { super(); } private void checkMonth(String year, String month) throws DatatypeException { checkMonth(Integer.parseInt(year), Integer.parseInt(month)); } private void checkMonth(int year, int month) throws DatatypeException { if (year < 1) { throw newDatatypeException(\"Year cannot be less than 1.\"); } if (month < 1) { throw newDatatypeException(\"Month cannot be less than 1.\"); } if (month > 12) { throw newDatatypeException(\"Month cannot be greater than 12.\"); } } public final void checkValid(CharSequence literal) throws DatatypeException { Matcher m = THE_PATTERN.matcher(literal); if (m.matches()) { checkMonth(m.group(1), m.group(2)); } else { throw newDatatypeException( \"The literal did not satisfy the format for month.\"); } } @Override public String getName() { return \"month\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class NonEmptyString extends AbstractDatatype {  public static final NonEmptyString THE_INSTANCE = new NonEmptyString();  private NonEmptyString() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Must not be empty.\"); } } @Override public String getName() { return \"non-empty string\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import com.ibm.icu.text.UnicodeSet; public class ParenthesisEnd extends AbstractUnicodeClassCharacter { private static final UnicodeSet UNICODE_SET = new UnicodeSet(\"[:Pe:]\");  public static final ParenthesisEnd THE_INSTANCE = new ParenthesisEnd(); private ParenthesisEnd() { } @Override public String getName() { return \"end parenthesis\"; } @Override protected UnicodeSet getUnicodeSet() { return UNICODE_SET; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import com.ibm.icu.text.UnicodeSet; public class ParenthesisStart extends AbstractUnicodeClassCharacter { private static final UnicodeSet UNICODE_SET = new UnicodeSet(\"[:Ps:]\");  public static final ParenthesisStart THE_INSTANCE = new ParenthesisStart(); private ParenthesisStart() { } @Override public String getName() { return \"start parenthesis\"; } @Override protected UnicodeSet getUnicodeSet() { return UNICODE_SET; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.mozilla.javascript.Context; import org.mozilla.javascript.ContextFactory; import org.mozilla.javascript.EcmaError; import org.mozilla.javascript.regexp.RegExpImpl; import org.relaxng.datatype.DatatypeException; /** * This datatype shall accept the strings that are allowed as the value of the Web Forms 2.0 * <a href=\"http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Polyline extends AbstractInt {  public static final Polyline THE_INSTANCE = new Polyline();  private Polyline() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() < 6) { throw newDatatypeException(\"A polyline must have at least six comma-separated integers.\"); } if (list.size() % 2 != 0) { throw newDatatypeException(\"A polyline must have an even number of comma-separated integers.\"); } for (CharSequenceWithOffset item : list) { checkInt(item.getSequence(), item.getOffset()); } } @Override public String getName() { return \"polyline\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.List; import org.relaxng.datatype.DatatypeException; public class Rectangle extends AbstractInt {  public static final Rectangle THE_INSTANCE = new Rectangle();  private Rectangle() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { List<CharSequenceWithOffset> list = split(literal, ','); if (list.size() != 4) { throw newDatatypeException(\"A rectangle must have four comma-separated integers.\"); } for (CharSequenceWithOffset item : list) { checkInt(item.getSequence(), item.getOffset()); } if (Integer.parseInt(list.get(0).getSequence().toString()) >= Integer.parseInt(list.get(2).getSequence().toString())) { throw newDatatypeException(\"The first integer must be less than the third.\"); } if (Integer.parseInt(list.get(1).getSequence().toString()) >= Integer.parseInt(list.get(3).getSequence().toString())) { throw newDatatypeException(\"The second integer must be less than the fourth.\"); } } @Override public String getName() { return \"rectangle\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public final class Refresh extends IriRef {  public static final Refresh THE_INSTANCE = new Refresh(); private Refresh() { super(); } private enum State { AT_START, DIGIT_SEEN, SEMICOLON_SEEN, SPACE_SEEN, U_SEEN, R_SEEN, L_SEEN, EQUALS_SEEN } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() == 0) { throw newDatatypeException(\"Empty literal.\"); } State state = State.AT_START; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case AT_START: if (isAsciiDigit(c)) { state = State.DIGIT_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit, but saw \", c, \" instead.\"); } case DIGIT_SEEN: if (isAsciiDigit(c)) { continue; } else if (c == ';') { state = State.SEMICOLON_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a digit or a semicolon, but saw \", c, \" instead.\"); } case SEMICOLON_SEEN: if (isWhitespace(c)) { state = State.SPACE_SEEN; continue; } else { throw newDatatypeException(i, \"Expected a space character, but saw \", c, \" instead.\"); } case SPACE_SEEN: if (isWhitespace(c)) { continue; } else if (c == 'u' || c == 'U') { state = State.U_SEEN; continue; } else { throw newDatatypeException( i, \"Expected a space character or the letter \\u201Cu\\u201D, but saw \", c, \" instead.\"); } case U_SEEN: if (c == 'r' || c == 'R') { state = State.R_SEEN; continue; } else { throw newDatatypeException(i, \"Expected the letter \\u201Cr\\u201D, but saw \", c, \" instead.\"); } case R_SEEN: if (c == 'l' || c == 'L') { state = State.L_SEEN; continue; } else { throw newDatatypeException(i, \"Expected the letter \\u201Cl\\u201D, but saw \", c, \" instead.\"); } case L_SEEN: if (c == '=') { state = State.EQUALS_SEEN; continue; } else { throw newDatatypeException(i, \"Expected \\u201C=\\u201D, but saw \", c, \" instead.\"); } case EQUALS_SEEN: if (c == '\"' || c == '\\'') { throw newDatatypeException( \"Expected an unquoted IRI reference, but saw \", c, \" instead.\"); } if (' ' == c || '\\t' == c || '\\n' == c || '\\f' == c || '\\r' == c) { throw newDatatypeException(\"Expected an IRI reference, but saw whitespace instead.\"); } char l = literal.charAt(literal.length() - 1); if (' ' == l || '\\t' == l || '\\n' == l || '\\f' == l || '\\r' == l) { throw newDatatypeException(\"Trailing whitespace.\"); } super.checkValid(literal.subSequence(i, literal.length())); return; } } switch (state) { case AT_START: throw newDatatypeException(\"Expected a digit, but the literal ended.\"); case DIGIT_SEEN: return; case SEMICOLON_SEEN: throw newDatatypeException(\"Expected a space character, but the literal ended.\"); case SPACE_SEEN: throw newDatatypeException(\"Expected a space character or the letter \\u201Cu\\u201D, but the literal ended.\"); case U_SEEN: throw newDatatypeException(\"Expected the letter \\u201Cr\\u201D, but the literal ended.\"); case R_SEEN: throw newDatatypeException(\"Expected the letter \\u201Cl\\u201D, but the literal ended.\"); case L_SEEN: throw newDatatypeException(\"Expected \\u201C=\\u201D, but the literal ended.\"); case EQUALS_SEEN: throw newDatatypeException(\"Expected an IRI reference, but the literal ended.\"); } } @Override public String getName() { return \"refresh\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Script extends CdoCdcPair {  public static final Script THE_INSTANCE = new Script(); protected Script() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public final class ScriptDocumentation extends Script { private enum State { BEFORE_DOCUMENTATION, SLASH, IN_COMMENT, IN_LINE_COMMENT, STAR }  public static final ScriptDocumentation THE_INSTANCE = new ScriptDocumentation(); private ScriptDocumentation() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { State state = State.BEFORE_DOCUMENTATION; for (int i = 0; i < literal.length(); i++) { char c = literal.charAt(i); switch (state) { case BEFORE_DOCUMENTATION: switch (c) { case ' ': case '\\t': case '\\n': continue; case '/': if (i == literal.length() - 1) { throw newDatatypeException(\"Expected asterisk or slash but content ended with a \" + \"single slash instead.\"); } state = State.SLASH; continue; default: throw newDatatypeException(\"Expected space, tab, newline, or slash but found \\u201c\" + c + \"\\u201d instead.\"); } case SLASH: switch (c) { case '*': state = State.IN_COMMENT; continue; case '/': state = State.IN_LINE_COMMENT; continue; default: throw newDatatypeException(\"Expected asterisk or slash but found \\u201c\" + c + \"\\u201d instead.\"); } case IN_COMMENT: switch (c) { case '*': state = State.STAR; continue; default: continue; } case STAR: switch (c) { case '/': state = State.BEFORE_DOCUMENTATION; continue; default: continue; } case IN_LINE_COMMENT: switch (c) { case '\\n': state = State.BEFORE_DOCUMENTATION; continue; default: continue; } default: throw newDatatypeException(\"Content ended prematurely.\"); } } if (state == State.IN_LINE_COMMENT) { throw newDatatypeException(\"Content contains a line starting with\" + \" the character sequence \\u201c"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class SimpleColor extends AbstractDatatype {  public static final SimpleColor THE_INSTANCE = new SimpleColor();  private SimpleColor() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() != 7) { throw newDatatypeException(\"Incorrect length for color string.\"); } char c = literal.charAt(0); if (c != '#') { throw newDatatypeException(0, \"Color starts with incorrect character \", c, \". Expected the number sign.\"); } for (int i = 1; i < 7; i++) { c = literal.charAt(i); if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) { throw newDatatypeException(0, \"\", c, \" is not a valid hexadecimal digit.\"); } } } @Override public String getName() { return \"simple color\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class StringWithoutLineBreaks extends AbstractDatatype {  public static final StringWithoutLineBreaks THE_INSTANCE = new StringWithoutLineBreaks();  private StringWithoutLineBreaks() { super(); } @Override public void checkValid(CharSequence literal) throws DatatypeException { int len = literal.length(); for (int i = 0; i < len; i++) { char c = literal.charAt(i); if (c == '\\n') { throw newDatatypeException(i, \"Line feed not allowed.\"); } else if (c == '\\r') { throw newDatatypeException(i, \"Carriage return not allowed.\"); } } } @Override public String getName() { return \"string without line breaks\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "/* * Copyright 2000-2013 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException;  public final class Time extends AbstractDatetime {  public static final Time THE_INSTANCE = new Time();  private static final Pattern THE_PATTERN = Pattern.compile(\"^([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.[0-9]{1,3})?)?$\");  private Time() { super(); } public void checkValid(CharSequence literal) throws DatatypeException { Matcher m = getPattern().matcher(literal); if (m.matches()) { checkHour(m.group(1)); checkMinute(m.group(2)); String seconds = m.group(3); if (seconds != null) { checkSecond(seconds); } } else { throw newDatatypeException( \"The literal did not satisfy the format for time.\"); } }  protected final Pattern getPattern() { return THE_PATTERN; } @Override public String getName() { return \"time\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.regex.Pattern; public class TimeDatetime extends AbstractDatetime {  public static final TimeDatetime THE_INSTANCE = new TimeDatetime(); public int i;  private static final Pattern THE_PATTERN = Pattern.compile(\"^[ \\\\t\\\\r\\\\n\\\\f]*(?:(?:([0-9]{4,})-([0-9]{2}))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2}))|(?:([0-9]{2})-([0-9]{2}))|(?:([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?)|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?)|(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2})))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\\\.([0-9]+))?)?(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2}))))|(?:([0-9]{4,})-W([0-9]{2}))|(?:([0-9]{4,}))|(?:P(?:(?:[0-9]+D)|(?:(?:[0-9]+D)?T[0-9]+H)|(?:(?:[0-9]+D)?T(?:[0-9]+H)?[0-9]+M)|(?:(?:[0-9]+D)?T(?:(?:[0-9]+)H)?(?:(?:[0-9]+)M)?(?:[0-9]+(?:\\\\.([0-9]+))?S))))|(?:[ \\\\t\\\\r\\\\n\\\\f]*[0-9]+(?:(?:[ \\\\t\\\\r\\\\n\\\\f]*(?:[Ww]|[Dd]|[Hh]|[Mm]))|(?:(?:\\\\.([0-9]+))?[ \\\\t\\\\r\\\\n\\\\f]*[Ss])))+)[ \\\\t\\\\r\\\\n\\\\f]*$\"); private TimeDatetime() { super(); } @Override protected Pattern getPattern() { return THE_PATTERN; } @Override public String getName() { return \"time-datetime\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import java.util.Arrays; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.relaxng.datatype.DatatypeException; /** * This datatype shall accept strings that conform to the format of * <a href='http:"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class XmlName extends AbstractDatatype { public static boolean isNameStart(char c) { return ((c >= '\\u0041' && c <= '\\u005A') || (c >= '\\u0061' && c <= '\\u007A') || (c >= '\\u00C0' && c <= '\\u00D6') || (c >= '\\u00D8' && c <= '\\u00F6') || (c >= '\\u00F8' && c <= '\\u00FF') || (c >= '\\u0100' && c <= '\\u0131') || (c >= '\\u0134' && c <= '\\u013E') || (c >= '\\u0141' && c <= '\\u0148') || (c >= '\\u014A' && c <= '\\u017E') || (c >= '\\u0180' && c <= '\\u01C3') || (c >= '\\u01CD' && c <= '\\u01F0') || (c >= '\\u01F4' && c <= '\\u01F5') || (c >= '\\u01FA' && c <= '\\u0217') || (c >= '\\u0250' && c <= '\\u02A8') || (c >= '\\u02BB' && c <= '\\u02C1') || (c == '\\u0386') || (c >= '\\u0388' && c <= '\\u038A') || (c == '\\u038C') || (c >= '\\u038E' && c <= '\\u03A1') || (c >= '\\u03A3' && c <= '\\u03CE') || (c >= '\\u03D0' && c <= '\\u03D6') || (c == '\\u03DA') || (c == '\\u03DC') || (c == '\\u03DE') || (c == '\\u03E0') || (c >= '\\u03E2' && c <= '\\u03F3') || (c >= '\\u0401' && c <= '\\u040C') || (c >= '\\u040E' && c <= '\\u044F') || (c >= '\\u0451' && c <= '\\u045C') || (c >= '\\u045E' && c <= '\\u0481') || (c >= '\\u0490' && c <= '\\u04C4') || (c >= '\\u04C7' && c <= '\\u04C8') || (c >= '\\u04CB' && c <= '\\u04CC') || (c >= '\\u04D0' && c <= '\\u04EB') || (c >= '\\u04EE' && c <= '\\u04F5') || (c >= '\\u04F8' && c <= '\\u04F9') || (c >= '\\u0531' && c <= '\\u0556') || (c == '\\u0559') || (c >= '\\u0561' && c <= '\\u0586') || (c >= '\\u05D0' && c <= '\\u05EA') || (c >= '\\u05F0' && c <= '\\u05F2') || (c >= '\\u0621' && c <= '\\u063A') || (c >= '\\u0641' && c <= '\\u064A') || (c >= '\\u0671' && c <= '\\u06B7') || (c >= '\\u06BA' && c <= '\\u06BE') || (c >= '\\u06C0' && c <= '\\u06CE') || (c >= '\\u06D0' && c <= '\\u06D3') || (c == '\\u06D5') || (c >= '\\u06E5' && c <= '\\u06E6') || (c >= '\\u0905' && c <= '\\u0939') || (c == '\\u093D') || (c >= '\\u0958' && c <= '\\u0961') || (c >= '\\u0985' && c <= '\\u098C') || (c >= '\\u098F' && c <= '\\u0990') || (c >= '\\u0993' && c <= '\\u09A8') || (c >= '\\u09AA' && c <= '\\u09B0') || (c == '\\u09B2') || (c >= '\\u09B6' && c <= '\\u09B9') || (c >= '\\u09DC' && c <= '\\u09DD') || (c >= '\\u09DF' && c <= '\\u09E1') || (c >= '\\u09F0' && c <= '\\u09F1') || (c >= '\\u0A05' && c <= '\\u0A0A') || (c >= '\\u0A0F' && c <= '\\u0A10') || (c >= '\\u0A13' && c <= '\\u0A28') || (c >= '\\u0A2A' && c <= '\\u0A30') || (c >= '\\u0A32' && c <= '\\u0A33') || (c >= '\\u0A35' && c <= '\\u0A36') || (c >= '\\u0A38' && c <= '\\u0A39') || (c >= '\\u0A59' && c <= '\\u0A5C') || (c == '\\u0A5E') || (c >= '\\u0A72' && c <= '\\u0A74') || (c >= '\\u0A85' && c <= '\\u0A8B') || (c == '\\u0A8D') || (c >= '\\u0A8F' && c <= '\\u0A91') || (c >= '\\u0A93' && c <= '\\u0AA8') || (c >= '\\u0AAA' && c <= '\\u0AB0') || (c >= '\\u0AB2' && c <= '\\u0AB3') || (c >= '\\u0AB5' && c <= '\\u0AB9') || (c == '\\u0ABD') || (c == '\\u0AE0') || (c >= '\\u0B05' && c <= '\\u0B0C') || (c >= '\\u0B0F' && c <= '\\u0B10') || (c >= '\\u0B13' && c <= '\\u0B28') || (c >= '\\u0B2A' && c <= '\\u0B30') || (c >= '\\u0B32' && c <= '\\u0B33') || (c >= '\\u0B36' && c <= '\\u0B39') || (c == '\\u0B3D') || (c >= '\\u0B5C' && c <= '\\u0B5D') || (c >= '\\u0B5F' && c <= '\\u0B61') || (c >= '\\u0B85' && c <= '\\u0B8A') || (c >= '\\u0B8E' && c <= '\\u0B90') || (c >= '\\u0B92' && c <= '\\u0B95') || (c >= '\\u0B99' && c <= '\\u0B9A') || (c == '\\u0B9C') || (c >= '\\u0B9E' && c <= '\\u0B9F') || (c >= '\\u0BA3' && c <= '\\u0BA4') || (c >= '\\u0BA8' && c <= '\\u0BAA') || (c >= '\\u0BAE' && c <= '\\u0BB5') || (c >= '\\u0BB7' && c <= '\\u0BB9') || (c >= '\\u0C05' && c <= '\\u0C0C') || (c >= '\\u0C0E' && c <= '\\u0C10') || (c >= '\\u0C12' && c <= '\\u0C28') || (c >= '\\u0C2A' && c <= '\\u0C33') || (c >= '\\u0C35' && c <= '\\u0C39') || (c >= '\\u0C60' && c <= '\\u0C61') || (c >= '\\u0C85' && c <= '\\u0C8C') || (c >= '\\u0C8E' && c <= '\\u0C90') || (c >= '\\u0C92' && c <= '\\u0CA8') || (c >= '\\u0CAA' && c <= '\\u0CB3') || (c >= '\\u0CB5' && c <= '\\u0CB9') || (c == '\\u0CDE') || (c >= '\\u0CE0' && c <= '\\u0CE1') || (c >= '\\u0D05' && c <= '\\u0D0C') || (c >= '\\u0D0E' && c <= '\\u0D10') || (c >= '\\u0D12' && c <= '\\u0D28') || (c >= '\\u0D2A' && c <= '\\u0D39') || (c >= '\\u0D60' && c <= '\\u0D61') || (c >= '\\u0E01' && c <= '\\u0E2E') || (c == '\\u0E30') || (c >= '\\u0E32' && c <= '\\u0E33') || (c >= '\\u0E40' && c <= '\\u0E45') || (c >= '\\u0E81' && c <= '\\u0E82') || (c == '\\u0E84') || (c >= '\\u0E87' && c <= '\\u0E88') || (c == '\\u0E8A') || (c == '\\u0E8D') || (c >= '\\u0E94' && c <= '\\u0E97') || (c >= '\\u0E99' && c <= '\\u0E9F') || (c >= '\\u0EA1' && c <= '\\u0EA3') || (c == '\\u0EA5') || (c == '\\u0EA7') || (c >= '\\u0EAA' && c <= '\\u0EAB') || (c >= '\\u0EAD' && c <= '\\u0EAE') || (c == '\\u0EB0') || (c >= '\\u0EB2' && c <= '\\u0EB3') || (c == '\\u0EBD') || (c >= '\\u0EC0' && c <= '\\u0EC4') || (c >= '\\u0F40' && c <= '\\u0F47') || (c >= '\\u0F49' && c <= '\\u0F69') || (c >= '\\u10A0' && c <= '\\u10C5') || (c >= '\\u10D0' && c <= '\\u10F6') || (c == '\\u1100') || (c >= '\\u1102' && c <= '\\u1103') || (c >= '\\u1105' && c <= '\\u1107') || (c == '\\u1109') || (c >= '\\u110B' && c <= '\\u110C') || (c >= '\\u110E' && c <= '\\u1112') || (c == '\\u113C') || (c == '\\u113E') || (c == '\\u1140') || (c == '\\u114C') || (c == '\\u114E') || (c == '\\u1150') || (c >= '\\u1154' && c <= '\\u1155') || (c == '\\u1159') || (c >= '\\u115F' && c <= '\\u1161') || (c == '\\u1163') || (c == '\\u1165') || (c == '\\u1167') || (c == '\\u1169') || (c >= '\\u116D' && c <= '\\u116E') || (c >= '\\u1172' && c <= '\\u1173') || (c == '\\u1175') || (c == '\\u119E') || (c == '\\u11A8') || (c == '\\u11AB') || (c >= '\\u11AE' && c <= '\\u11AF') || (c >= '\\u11B7' && c <= '\\u11B8') || (c == '\\u11BA') || (c >= '\\u11BC' && c <= '\\u11C2') || (c == '\\u11EB') || (c == '\\u11F0') || (c == '\\u11F9') || (c >= '\\u1E00' && c <= '\\u1E9B') || (c >= '\\u1EA0' && c <= '\\u1EF9') || (c >= '\\u1F00' && c <= '\\u1F15') || (c >= '\\u1F18' && c <= '\\u1F1D') || (c >= '\\u1F20' && c <= '\\u1F45') || (c >= '\\u1F48' && c <= '\\u1F4D') || (c >= '\\u1F50' && c <= '\\u1F57') || (c == '\\u1F59') || (c == '\\u1F5B') || (c == '\\u1F5D') || (c >= '\\u1F5F' && c <= '\\u1F7D') || (c >= '\\u1F80' && c <= '\\u1FB4') || (c >= '\\u1FB6' && c <= '\\u1FBC') || (c == '\\u1FBE') || (c >= '\\u1FC2' && c <= '\\u1FC4') || (c >= '\\u1FC6' && c <= '\\u1FCC') || (c >= '\\u1FD0' && c <= '\\u1FD3') || (c >= '\\u1FD6' && c <= '\\u1FDB') || (c >= '\\u1FE0' && c <= '\\u1FEC') || (c >= '\\u1FF2' && c <= '\\u1FF4') || (c >= '\\u1FF6' && c <= '\\u1FFC') || (c == '\\u2126') || (c >= '\\u212A' && c <= '\\u212B') || (c == '\\u212E') || (c >= '\\u2180' && c <= '\\u2182') || (c >= '\\u3041' && c <= '\\u3094') || (c >= '\\u30A1' && c <= '\\u30FA') || (c >= '\\u3105' && c <= '\\u312C') || (c >= '\\uAC00' && c <= '\\uD7A3') || (c >= '\\u4E00' && c <= '\\u9FA5') || (c == '\\u3007') || (c >= '\\u3021' && c <= '\\u3029') || (c == '_') || (c == ':')); } public static boolean isNameTrail(char c) { return ((c >= '\\u0030' && c <= '\\u0039') || (c >= '\\u0660' && c <= '\\u0669') || (c >= '\\u06F0' && c <= '\\u06F9') || (c >= '\\u0966' && c <= '\\u096F') || (c >= '\\u09E6' && c <= '\\u09EF') || (c >= '\\u0A66' && c <= '\\u0A6F') || (c >= '\\u0AE6' && c <= '\\u0AEF') || (c >= '\\u0B66' && c <= '\\u0B6F') || (c >= '\\u0BE7' && c <= '\\u0BEF') || (c >= '\\u0C66' && c <= '\\u0C6F') || (c >= '\\u0CE6' && c <= '\\u0CEF') || (c >= '\\u0D66' && c <= '\\u0D6F') || (c >= '\\u0E50' && c <= '\\u0E59') || (c >= '\\u0ED0' && c <= '\\u0ED9') || (c >= '\\u0F20' && c <= '\\u0F29') || (c >= '\\u0041' && c <= '\\u005A') || (c >= '\\u0061' && c <= '\\u007A') || (c >= '\\u00C0' && c <= '\\u00D6') || (c >= '\\u00D8' && c <= '\\u00F6') || (c >= '\\u00F8' && c <= '\\u00FF') || (c >= '\\u0100' && c <= '\\u0131') || (c >= '\\u0134' && c <= '\\u013E') || (c >= '\\u0141' && c <= '\\u0148') || (c >= '\\u014A' && c <= '\\u017E') || (c >= '\\u0180' && c <= '\\u01C3') || (c >= '\\u01CD' && c <= '\\u01F0') || (c >= '\\u01F4' && c <= '\\u01F5') || (c >= '\\u01FA' && c <= '\\u0217') || (c >= '\\u0250' && c <= '\\u02A8') || (c >= '\\u02BB' && c <= '\\u02C1') || (c == '\\u0386') || (c >= '\\u0388' && c <= '\\u038A') || (c == '\\u038C') || (c >= '\\u038E' && c <= '\\u03A1') || (c >= '\\u03A3' && c <= '\\u03CE') || (c >= '\\u03D0' && c <= '\\u03D6') || (c == '\\u03DA') || (c == '\\u03DC') || (c == '\\u03DE') || (c == '\\u03E0') || (c >= '\\u03E2' && c <= '\\u03F3') || (c >= '\\u0401' && c <= '\\u040C') || (c >= '\\u040E' && c <= '\\u044F') || (c >= '\\u0451' && c <= '\\u045C') || (c >= '\\u045E' && c <= '\\u0481') || (c >= '\\u0490' && c <= '\\u04C4') || (c >= '\\u04C7' && c <= '\\u04C8') || (c >= '\\u04CB' && c <= '\\u04CC') || (c >= '\\u04D0' && c <= '\\u04EB') || (c >= '\\u04EE' && c <= '\\u04F5') || (c >= '\\u04F8' && c <= '\\u04F9') || (c >= '\\u0531' && c <= '\\u0556') || (c == '\\u0559') || (c >= '\\u0561' && c <= '\\u0586') || (c >= '\\u05D0' && c <= '\\u05EA') || (c >= '\\u05F0' && c <= '\\u05F2') || (c >= '\\u0621' && c <= '\\u063A') || (c >= '\\u0641' && c <= '\\u064A') || (c >= '\\u0671' && c <= '\\u06B7') || (c >= '\\u06BA' && c <= '\\u06BE') || (c >= '\\u06C0' && c <= '\\u06CE') || (c >= '\\u06D0' && c <= '\\u06D3') || (c == '\\u06D5') || (c >= '\\u06E5' && c <= '\\u06E6') || (c >= '\\u0905' && c <= '\\u0939') || (c == '\\u093D') || (c >= '\\u0958' && c <= '\\u0961') || (c >= '\\u0985' && c <= '\\u098C') || (c >= '\\u098F' && c <= '\\u0990') || (c >= '\\u0993' && c <= '\\u09A8') || (c >= '\\u09AA' && c <= '\\u09B0') || (c == '\\u09B2') || (c >= '\\u09B6' && c <= '\\u09B9') || (c >= '\\u09DC' && c <= '\\u09DD') || (c >= '\\u09DF' && c <= '\\u09E1') || (c >= '\\u09F0' && c <= '\\u09F1') || (c >= '\\u0A05' && c <= '\\u0A0A') || (c >= '\\u0A0F' && c <= '\\u0A10') || (c >= '\\u0A13' && c <= '\\u0A28') || (c >= '\\u0A2A' && c <= '\\u0A30') || (c >= '\\u0A32' && c <= '\\u0A33') || (c >= '\\u0A35' && c <= '\\u0A36') || (c >= '\\u0A38' && c <= '\\u0A39') || (c >= '\\u0A59' && c <= '\\u0A5C') || (c == '\\u0A5E') || (c >= '\\u0A72' && c <= '\\u0A74') || (c >= '\\u0A85' && c <= '\\u0A8B') || (c == '\\u0A8D') || (c >= '\\u0A8F' && c <= '\\u0A91') || (c >= '\\u0A93' && c <= '\\u0AA8') || (c >= '\\u0AAA' && c <= '\\u0AB0') || (c >= '\\u0AB2' && c <= '\\u0AB3') || (c >= '\\u0AB5' && c <= '\\u0AB9') || (c == '\\u0ABD') || (c == '\\u0AE0') || (c >= '\\u0B05' && c <= '\\u0B0C') || (c >= '\\u0B0F' && c <= '\\u0B10') || (c >= '\\u0B13' && c <= '\\u0B28') || (c >= '\\u0B2A' && c <= '\\u0B30') || (c >= '\\u0B32' && c <= '\\u0B33') || (c >= '\\u0B36' && c <= '\\u0B39') || (c == '\\u0B3D') || (c >= '\\u0B5C' && c <= '\\u0B5D') || (c >= '\\u0B5F' && c <= '\\u0B61') || (c >= '\\u0B85' && c <= '\\u0B8A') || (c >= '\\u0B8E' && c <= '\\u0B90') || (c >= '\\u0B92' && c <= '\\u0B95') || (c >= '\\u0B99' && c <= '\\u0B9A') || (c == '\\u0B9C') || (c >= '\\u0B9E' && c <= '\\u0B9F') || (c >= '\\u0BA3' && c <= '\\u0BA4') || (c >= '\\u0BA8' && c <= '\\u0BAA') || (c >= '\\u0BAE' && c <= '\\u0BB5') || (c >= '\\u0BB7' && c <= '\\u0BB9') || (c >= '\\u0C05' && c <= '\\u0C0C') || (c >= '\\u0C0E' && c <= '\\u0C10') || (c >= '\\u0C12' && c <= '\\u0C28') || (c >= '\\u0C2A' && c <= '\\u0C33') || (c >= '\\u0C35' && c <= '\\u0C39') || (c >= '\\u0C60' && c <= '\\u0C61') || (c >= '\\u0C85' && c <= '\\u0C8C') || (c >= '\\u0C8E' && c <= '\\u0C90') || (c >= '\\u0C92' && c <= '\\u0CA8') || (c >= '\\u0CAA' && c <= '\\u0CB3') || (c >= '\\u0CB5' && c <= '\\u0CB9') || (c == '\\u0CDE') || (c >= '\\u0CE0' && c <= '\\u0CE1') || (c >= '\\u0D05' && c <= '\\u0D0C') || (c >= '\\u0D0E' && c <= '\\u0D10') || (c >= '\\u0D12' && c <= '\\u0D28') || (c >= '\\u0D2A' && c <= '\\u0D39') || (c >= '\\u0D60' && c <= '\\u0D61') || (c >= '\\u0E01' && c <= '\\u0E2E') || (c == '\\u0E30') || (c >= '\\u0E32' && c <= '\\u0E33') || (c >= '\\u0E40' && c <= '\\u0E45') || (c >= '\\u0E81' && c <= '\\u0E82') || (c == '\\u0E84') || (c >= '\\u0E87' && c <= '\\u0E88') || (c == '\\u0E8A') || (c == '\\u0E8D') || (c >= '\\u0E94' && c <= '\\u0E97') || (c >= '\\u0E99' && c <= '\\u0E9F') || (c >= '\\u0EA1' && c <= '\\u0EA3') || (c == '\\u0EA5') || (c == '\\u0EA7') || (c >= '\\u0EAA' && c <= '\\u0EAB') || (c >= '\\u0EAD' && c <= '\\u0EAE') || (c == '\\u0EB0') || (c >= '\\u0EB2' && c <= '\\u0EB3') || (c == '\\u0EBD') || (c >= '\\u0EC0' && c <= '\\u0EC4') || (c >= '\\u0F40' && c <= '\\u0F47') || (c >= '\\u0F49' && c <= '\\u0F69') || (c >= '\\u10A0' && c <= '\\u10C5') || (c >= '\\u10D0' && c <= '\\u10F6') || (c == '\\u1100') || (c >= '\\u1102' && c <= '\\u1103') || (c >= '\\u1105' && c <= '\\u1107') || (c == '\\u1109') || (c >= '\\u110B' && c <= '\\u110C') || (c >= '\\u110E' && c <= '\\u1112') || (c == '\\u113C') || (c == '\\u113E') || (c == '\\u1140') || (c == '\\u114C') || (c == '\\u114E') || (c == '\\u1150') || (c >= '\\u1154' && c <= '\\u1155') || (c == '\\u1159') || (c >= '\\u115F' && c <= '\\u1161') || (c == '\\u1163') || (c == '\\u1165') || (c == '\\u1167') || (c == '\\u1169') || (c >= '\\u116D' && c <= '\\u116E') || (c >= '\\u1172' && c <= '\\u1173') || (c == '\\u1175') || (c == '\\u119E') || (c == '\\u11A8') || (c == '\\u11AB') || (c >= '\\u11AE' && c <= '\\u11AF') || (c >= '\\u11B7' && c <= '\\u11B8') || (c == '\\u11BA') || (c >= '\\u11BC' && c <= '\\u11C2') || (c == '\\u11EB') || (c == '\\u11F0') || (c == '\\u11F9') || (c >= '\\u1E00' && c <= '\\u1E9B') || (c >= '\\u1EA0' && c <= '\\u1EF9') || (c >= '\\u1F00' && c <= '\\u1F15') || (c >= '\\u1F18' && c <= '\\u1F1D') || (c >= '\\u1F20' && c <= '\\u1F45') || (c >= '\\u1F48' && c <= '\\u1F4D') || (c >= '\\u1F50' && c <= '\\u1F57') || (c == '\\u1F59') || (c == '\\u1F5B') || (c == '\\u1F5D') || (c >= '\\u1F5F' && c <= '\\u1F7D') || (c >= '\\u1F80' && c <= '\\u1FB4') || (c >= '\\u1FB6' && c <= '\\u1FBC') || (c == '\\u1FBE') || (c >= '\\u1FC2' && c <= '\\u1FC4') || (c >= '\\u1FC6' && c <= '\\u1FCC') || (c >= '\\u1FD0' && c <= '\\u1FD3') || (c >= '\\u1FD6' && c <= '\\u1FDB') || (c >= '\\u1FE0' && c <= '\\u1FEC') || (c >= '\\u1FF2' && c <= '\\u1FF4') || (c >= '\\u1FF6' && c <= '\\u1FFC') || (c == '\\u2126') || (c >= '\\u212A' && c <= '\\u212B') || (c == '\\u212E') || (c >= '\\u2180' && c <= '\\u2182') || (c >= '\\u3041' && c <= '\\u3094') || (c >= '\\u30A1' && c <= '\\u30FA') || (c >= '\\u3105' && c <= '\\u312C') || (c >= '\\uAC00' && c <= '\\uD7A3') || (c >= '\\u4E00' && c <= '\\u9FA5') || (c == '\\u3007') || (c >= '\\u3021' && c <= '\\u3029') || (c == '_') || (c == ':') || (c == '.') || (c == '-') || (c >= '\\u0300' && c <= '\\u0345') || (c >= '\\u0360' && c <= '\\u0361') || (c >= '\\u0483' && c <= '\\u0486') || (c >= '\\u0591' && c <= '\\u05A1') || (c >= '\\u05A3' && c <= '\\u05B9') || (c >= '\\u05BB' && c <= '\\u05BD') || (c == '\\u05BF') || (c >= '\\u05C1' && c <= '\\u05C2') || (c == '\\u05C4') || (c >= '\\u064B' && c <= '\\u0652') || (c == '\\u0670') || (c >= '\\u06D6' && c <= '\\u06DC') || (c >= '\\u06DD' && c <= '\\u06DF') || (c >= '\\u06E0' && c <= '\\u06E4') || (c >= '\\u06E7' && c <= '\\u06E8') || (c >= '\\u06EA' && c <= '\\u06ED') || (c >= '\\u0901' && c <= '\\u0903') || (c == '\\u093C') || (c >= '\\u093E' && c <= '\\u094C') || (c == '\\u094D') || (c >= '\\u0951' && c <= '\\u0954') || (c >= '\\u0962' && c <= '\\u0963') || (c >= '\\u0981' && c <= '\\u0983') || (c == '\\u09BC') || (c == '\\u09BE') || (c == '\\u09BF') || (c >= '\\u09C0' && c <= '\\u09C4') || (c >= '\\u09C7' && c <= '\\u09C8') || (c >= '\\u09CB' && c <= '\\u09CD') || (c == '\\u09D7') || (c >= '\\u09E2' && c <= '\\u09E3') || (c == '\\u0A02') || (c == '\\u0A3C') || (c == '\\u0A3E') || (c == '\\u0A3F') || (c >= '\\u0A40' && c <= '\\u0A42') || (c >= '\\u0A47' && c <= '\\u0A48') || (c >= '\\u0A4B' && c <= '\\u0A4D') || (c >= '\\u0A70' && c <= '\\u0A71') || (c >= '\\u0A81' && c <= '\\u0A83') || (c == '\\u0ABC') || (c >= '\\u0ABE' && c <= '\\u0AC5') || (c >= '\\u0AC7' && c <= '\\u0AC9') || (c >= '\\u0ACB' && c <= '\\u0ACD') || (c >= '\\u0B01' && c <= '\\u0B03') || (c == '\\u0B3C') || (c >= '\\u0B3E' && c <= '\\u0B43') || (c >= '\\u0B47' && c <= '\\u0B48') || (c >= '\\u0B4B' && c <= '\\u0B4D') || (c >= '\\u0B56' && c <= '\\u0B57') || (c >= '\\u0B82' && c <= '\\u0B83') || (c >= '\\u0BBE' && c <= '\\u0BC2') || (c >= '\\u0BC6' && c <= '\\u0BC8') || (c >= '\\u0BCA' && c <= '\\u0BCD') || (c == '\\u0BD7') || (c >= '\\u0C01' && c <= '\\u0C03') || (c >= '\\u0C3E' && c <= '\\u0C44') || (c >= '\\u0C46' && c <= '\\u0C48') || (c >= '\\u0C4A' && c <= '\\u0C4D') || (c >= '\\u0C55' && c <= '\\u0C56') || (c >= '\\u0C82' && c <= '\\u0C83') || (c >= '\\u0CBE' && c <= '\\u0CC4') || (c >= '\\u0CC6' && c <= '\\u0CC8') || (c >= '\\u0CCA' && c <= '\\u0CCD') || (c >= '\\u0CD5' && c <= '\\u0CD6') || (c >= '\\u0D02' && c <= '\\u0D03') || (c >= '\\u0D3E' && c <= '\\u0D43') || (c >= '\\u0D46' && c <= '\\u0D48') || (c >= '\\u0D4A' && c <= '\\u0D4D') || (c == '\\u0D57') || (c == '\\u0E31') || (c >= '\\u0E34' && c <= '\\u0E3A') || (c >= '\\u0E47' && c <= '\\u0E4E') || (c == '\\u0EB1') || (c >= '\\u0EB4' && c <= '\\u0EB9') || (c >= '\\u0EBB' && c <= '\\u0EBC') || (c >= '\\u0EC8' && c <= '\\u0ECD') || (c >= '\\u0F18' && c <= '\\u0F19') || (c == '\\u0F35') || (c == '\\u0F37') || (c == '\\u0F39') || (c == '\\u0F3E') || (c == '\\u0F3F') || (c >= '\\u0F71' && c <= '\\u0F84') || (c >= '\\u0F86' && c <= '\\u0F8B') || (c >= '\\u0F90' && c <= '\\u0F95') || (c == '\\u0F97') || (c >= '\\u0F99' && c <= '\\u0FAD') || (c >= '\\u0FB1' && c <= '\\u0FB7') || (c == '\\u0FB9') || (c >= '\\u20D0' && c <= '\\u20DC') || (c == '\\u20E1') || (c >= '\\u302A' && c <= '\\u302F') || (c == '\\u3099') || (c == '\\u309A') || (c == '\\u00B7') || (c == '\\u02D0') || (c == '\\u02D1') || (c == '\\u0387') || (c == '\\u0640') || (c == '\\u0E46') || (c == '\\u0EC6') || (c == '\\u3005') || (c >= '\\u3031' && c <= '\\u3035') || (c >= '\\u309D' && c <= '\\u309E') || (c >= '\\u30FC' && c <= '\\u30FE')); } public static boolean isName(CharSequence str) { if (str == null) { return false; } else { int len = str.length(); switch (len) { case 0: return false; case 1: return XmlName.isNameStart(str.charAt(0)); default: if (!XmlName.isNameStart(str.charAt(0))) { return false; } for (int i = 1; i < len; i++) { if (!XmlName.isNameTrail(str.charAt(i))) { return false; } } } return true; } }  public static final XmlName THE_INSTANCE = new XmlName(); private XmlName() { } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (!isName(literal)) { throw newDatatypeException(\"Not a valid XML 1.0 name.\"); } } @Override public String getName() { return \"XML name\"; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype; import org.relaxng.datatype.DatatypeException; public class Zero extends AbstractDatatype {  public static final Zero THE_INSTANCE = new Zero(); private Zero() { } @Override public String getName() { return \"zero\"; } @Override public void checkValid(CharSequence literal) throws DatatypeException { if (literal.length() != 1 || literal.charAt(0) != '0') { throw newDatatypeException(0, \"Only \\u201C0\\u201D is a permitted zero literal.\"); } } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": "  package org.whattf.datatype.data; import java.util.Arrays; public class CharsetData { private static final String[] LABELS = { \"866\", \"ansi_x3.4-1968\", \"arabic\", \"ascii\", \"asmo-708\", \"big5\", \"big5-hkscs\", \"chinese\", \"cn-big5\", \"cp1250\", \"cp1251\", \"cp1252\", \"cp1253\", \"cp1254\", \"cp1255\", \"cp1256\", \"cp1257\", \"cp1258\", \"cp819\", \"cp866\", \"csbig5\", \"cseuckr\", \"cseucpkdfmtjapanese\", \"csgb2312\", \"csibm866\", \"csiso2022jp\", \"csiso2022kr\", \"csiso58gb231280\", \"csiso88596e\", \"csiso88596i\", \"csiso88598e\", \"csiso88598i\", \"csisolatin1\", \"csisolatin2\", \"csisolatin3\", \"csisolatin4\", \"csisolatin5\", \"csisolatin6\", \"csisolatin9\", \"csisolatinarabic\", \"csisolatincyrillic\", \"csisolatingreek\", \"csisolatinhebrew\", \"cskoi8r\", \"csksc56011987\", \"csmacintosh\", \"csshiftjis\", \"cyrillic\", \"dos-874\", \"ecma-114\", \"ecma-118\", \"elot_928\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gb2312\", \"gb_2312\", \"gb_2312-80\", \"gbk\", \"greek\", \"greek8\", \"hebrew\", \"hz-gb-2312\", \"ibm819\", \"ibm866\", \"iso-2022-cn\", \"iso-2022-cn-ext\", \"iso-2022-jp\", \"iso-2022-kr\", \"iso-8859-1\", \"iso-8859-10\", \"iso-8859-11\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6-e\", \"iso-8859-6-i\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8-e\", \"iso-8859-8-i\", \"iso-8859-9\", \"iso-ir-100\", \"iso-ir-101\", \"iso-ir-109\", \"iso-ir-110\", \"iso-ir-126\", \"iso-ir-127\", \"iso-ir-138\", \"iso-ir-144\", \"iso-ir-148\", \"iso-ir-149\", \"iso-ir-157\", \"iso-ir-58\", \"iso8859-1\", \"iso8859-10\", \"iso8859-11\", \"iso8859-13\", \"iso8859-14\", \"iso8859-15\", \"iso8859-2\", \"iso8859-3\", \"iso8859-4\", \"iso8859-5\", \"iso8859-6\", \"iso8859-7\", \"iso8859-8\", \"iso8859-9\", \"iso88591\", \"iso885910\", \"iso885911\", \"iso885913\", \"iso885914\", \"iso885915\", \"iso88592\", \"iso88593\", \"iso88594\", \"iso88595\", \"iso88596\", \"iso88597\", \"iso88598\", \"iso88599\", \"iso_8859-1\", \"iso_8859-15\", \"iso_8859-1:1987\", \"iso_8859-2\", \"iso_8859-2:1987\", \"iso_8859-3\", \"iso_8859-3:1988\", \"iso_8859-4\", \"iso_8859-4:1988\", \"iso_8859-5\", \"iso_8859-5:1988\", \"iso_8859-6\", \"iso_8859-6:1987\", \"iso_8859-7\", \"iso_8859-7:1987\", \"iso_8859-8\", \"iso_8859-8:1988\", \"iso_8859-9\", \"iso_8859-9:1989\", \"koi\", \"koi8\", \"koi8-r\", \"koi8-u\", \"koi8_r\", \"korean\", \"ks_c_5601-1987\", \"ks_c_5601-1989\", \"ksc5601\", \"ksc_5601\", \"l1\", \"l2\", \"l3\", \"l4\", \"l5\", \"l6\", \"l9\", \"latin1\", \"latin2\", \"latin3\", \"latin4\", \"latin5\", \"latin6\", \"logical\", \"mac\", \"macintosh\", \"ms_kanji\", \"shift-jis\", \"shift_jis\", \"sjis\", \"sun_eu_greek\", \"tis-620\", \"unicode-1-1-utf-8\", \"us-ascii\", \"utf-16\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"utf8\", \"visual\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-31j\", \"windows-874\", \"windows-949\", \"x-cp1250\", \"x-cp1251\", \"x-cp1252\", \"x-cp1253\", \"x-cp1254\", \"x-cp1255\", \"x-cp1256\", \"x-cp1257\", \"x-cp1258\", \"x-euc-jp\", \"x-gbk\", \"x-mac-cyrillic\", \"x-mac-roman\", \"x-mac-ukrainian\", \"x-sjis\", \"x-user-defined\", \"x-x-big5\", }; private static final String[] PREFERRED_FOR_LABELS = { \"ibm866\", \"windows-1252\", \"iso-8859-6\", \"windows-1252\", \"iso-8859-6\", \"big5\", \"big5\", \"gbk\", \"big5\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-1252\", \"ibm866\", \"big5\", \"euc-kr\", \"euc-jp\", \"gbk\", \"ibm866\", \"iso-2022-jp\", \"iso-2022-kr\", \"gbk\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-8\", \"iso-8859-8-i\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-15\", \"iso-8859-6\", \"iso-8859-5\", \"iso-8859-7\", \"iso-8859-8\", \"koi8-r\", \"euc-kr\", \"macintosh\", \"shift_jis\", \"iso-8859-5\", \"windows-874\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-7\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gbk\", \"gbk\", \"gbk\", \"gbk\", \"iso-8859-7\", \"iso-8859-7\", \"iso-8859-8\", \"hz-gb-2312\", \"windows-1252\", \"ibm866\", \"replacement\", \"replacement\", \"iso-2022-jp\", \"iso-2022-kr\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8\", \"iso-8859-8-i\", \"windows-1254\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-7\", \"iso-8859-6\", \"iso-8859-8\", \"iso-8859-5\", \"windows-1254\", \"euc-kr\", \"iso-8859-10\", \"gbk\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"windows-1254\", \"windows-1252\", \"iso-8859-10\", \"windows-874\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"windows-1254\", \"windows-1252\", \"iso-8859-15\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8\", \"windows-1254\", \"windows-1254\", \"koi8-r\", \"koi8-r\", \"koi8-r\", \"koi8-u\", \"koi8-r\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"euc-kr\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-15\", \"windows-1252\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"windows-1254\", \"iso-8859-10\", \"iso-8859-8-i\", \"macintosh\", \"macintosh\", \"shift_jis\", \"shift_jis\", \"shift_jis\", \"shift_jis\", \"iso-8859-7\", \"windows-874\", \"utf-8\", \"windows-1252\", \"utf-16le\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"utf-8\", \"iso-8859-8\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"shift_jis\", \"windows-874\", \"euc-kr\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"euc-jp\", \"gbk\", \"x-mac-cyrillic\", \"macintosh\", \"x-mac-cyrillic\", \"shift_jis\", \"x-user-defined\", \"big5\", }; private static final String[] PREFERRED = { \"big5\", \"euc-jp\", \"euc-kr\", \"gb18030\", \"gbk\", \"hz-gb-2312\", \"ibm866\", \"iso-2022-jp\", \"iso-2022-kr\", \"iso-8859-10\", \"iso-8859-13\", \"iso-8859-14\", \"iso-8859-15\", \"iso-8859-16\", \"iso-8859-2\", \"iso-8859-3\", \"iso-8859-4\", \"iso-8859-5\", \"iso-8859-6\", \"iso-8859-7\", \"iso-8859-8\", \"iso-8859-8-i\", \"koi8-r\", \"koi8-u\", \"macintosh\", \"replacement\", \"shift_jis\", \"utf-16be\", \"utf-16le\", \"utf-8\", \"windows-1250\", \"windows-1251\", \"windows-1252\", \"windows-1253\", \"windows-1254\", \"windows-1255\", \"windows-1256\", \"windows-1257\", \"windows-1258\", \"windows-874\", \"x-mac-cyrillic\", \"x-user-defined\", }; public static boolean isPreferred(String label) { return Arrays.binarySearch(PREFERRED, label) > -1; } public static String preferredForLabel(String label) { int index = Arrays.binarySearch(LABELS, label); if (index < 0) { return null; } return PREFERRED_FOR_LABELS[index]; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.datatype.data; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet; import java.util.regex.Pattern; public class LanguageData { private static final Pattern HYPHEN = Pattern.compile(\"-\"); private static final String[][] EMPTY_DOUBLE_STRING_ARRAY = {}; private static final String[] EMPTY_STRING_ARRAY = {}; private static final String PREFIX = \"prefix: \"; private static final String SUPPRESS_SCRIPT = \"suppress-script: \"; private static final String SUBTAG = \"subtag: \"; private static final String TAG = \"tag: \"; private static final String TYPE = \"type: \"; private static final String DEPRECATED = \"deprecated: \"; private static final String PREFERRED_VALUE = \"preferred-value: \"; private BufferedReader in; private SortedSet<String> languageSet = new TreeSet<String>(); private SortedSet<String> extlangSet = new TreeSet<String>(); private SortedSet<String> scriptSet = new TreeSet<String>(); private SortedSet<String> regionSet = new TreeSet<String>(); private SortedSet<String> variantSet = new TreeSet<String>(); private SortedSet<String> grandfatheredSet = new TreeSet<String>(); private SortedSet<String> redundantSet = new TreeSet<String>(); private SortedSet<String> deprecatedLangSet = new TreeSet<String>(); private SortedSet<String> deprecatedSet = new TreeSet<String>(); private Map<String, String> suppressedScriptByLanguageMap = new HashMap<String, String>(); private Map<String, String> prefixByExtlangMap = new HashMap<String, String>(); private Map<String, String> preferredValueByLanguageMap = new HashMap<String, String>(); private Map<String, Set<String[]>> prefixesByVariantMap = new HashMap<String, Set<String[]>>(); private String[] languages = null; private String[] extlangs = null; private String[] scripts = null; private String[] regions = null; private String[] variants = null; private String[] grandfathered = null; private String[] redundant = null; private String[] deprecatedLang = null; private String[] deprecated = null; private int[] suppressedScriptByLanguage = null; private int[] prefixByExtlang = null; private String[][][] prefixesByVariant = null; public LanguageData() throws IOException { super(); in = new BufferedReader( new InputStreamReader( LanguageData.class.getClassLoader().getResourceAsStream( \"nu/validator/localentities/files/language-subtag-registry\"), \"UTF-8\")); consumeRegistry(); prepareArrays(); } private void consumeRegistry() throws IOException { while (consumeRecord()) { "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.EOFException; import java.io.IOException; import java.io.InputStream;  public class Base64InputStream extends InputStream { private static final int[] DECODING_TABLE = new int[256]; static { for (int i = 0; i < DECODING_TABLE.length; i++) { if (i >= 'A' && i <= 'Z') { DECODING_TABLE[i] = (i - 'A'); } else if (i >= 'a' && i <= 'z') { DECODING_TABLE[i] = (i - 'a' + 26); } else if (i >= '0' && i <= '9') { DECODING_TABLE[i] = (i - '0' + 52); } else if (i == '+') { DECODING_TABLE[i] = 62; } else if (i == '/') { DECODING_TABLE[i] = 63; } else if (i == '=') { DECODING_TABLE[i] = -2; } else { DECODING_TABLE[i] = -1; } } } private final InputStream delegate; private int bytesLeftInBuffer = 0; private int buffer = 0;  public Base64InputStream(InputStream delegate) { this.delegate = delegate; } @Override public int read() throws IOException { if (bytesLeftInBuffer == 0) { bytesLeftInBuffer = 3; for (int i = 0; i < 4; i++) { int c = delegate.read(); buffer <<= 6; if (c < 0) { if (i == 0) { bytesLeftInBuffer = 0; return -1; } else { throw new EOFException(); } } else if (bytesLeftInBuffer == 2) { if (c == '=') { bytesLeftInBuffer = 1; } else { throw new IOException(\"Non-padding in Base64 stream after padding had started.\"); } } else { int b = DECODING_TABLE[c]; if (b == -2) { if (i <= 1) { throw new IOException( \"Base 64 padding in a bad position.\"); } bytesLeftInBuffer = 2; } else if (b == -1) { throw new IOException(\"Non-Base64 input: \\u201C0x\" + Integer.toHexString(c) + \"\\u201D.\"); } else { buffer |= b; } } } } int rv = (buffer & 0xFF0000) >> 16; buffer <<= 8; bytesLeftInBuffer--; return rv; }  public void close() throws IOException { delegate.close(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.InputStream; import java.io.StringReader; import java.net.MalformedURLException; import com.hp.hpl.jena.iri.IRI; import com.hp.hpl.jena.iri.IRIFactory; public class DataUri { public static boolean startsWithData(String uri) { return uri != null && uri.length() >= 5 && (uri.charAt(0) == 'd' || uri.charAt(0) == 'D') && (uri.charAt(1) == 'a' || uri.charAt(1) == 'A') && (uri.charAt(2) == 't' || uri.charAt(2) == 'T') && (uri.charAt(3) == 'a' || uri.charAt(3) == 'A') && (uri.charAt(4) == ':'); } private enum State { AT_START, IN_SUPERTYPE, AT_SUBTYPE_START, IN_SUBTYPE, SEMICOLON_SEEN, WS_BEFORE_SEMICOLON, IN_PARAM_NAME, EQUALS_SEEN, IN_QUOTED_STRING, IN_UNQUOTED_STRING, IN_QUOTED_PAIR, CLOSE_QUOTE_SEEN } private String contentType; private InputStream inputStream;  protected void init(IRI uri) throws IOException, MalformedURLException { if (!uri.getScheme().equals(\"data\")) { throw new IllegalArgumentException(\"The input did not start with data:.\"); } if (uri.getRawFragment() != null) { throw new MalformedURLException(\"Fragment is not allowed for data: URIs according to RFC 2397. But if strictly comply with RFC 3986, ignore this error.\"); } InputStream is = new PercentDecodingReaderInputStream(new StringReader(uri.getRawPath())); StringBuilder sb = new StringBuilder(); State state = State.AT_START; int i = 0; "}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; public class DataUriException extends IOException { private final int index; private final String head; private final char literal; private final String tail;  public DataUriException(int index, String head, char literal, String tail) { super(head + '\\u201C' + literal + '\\u201D' + tail); this.index = index; this.head = head; this.literal = literal; this.tail = tail; }  public int getIndex() { return index; }  public String getHead() { return head; }  public char getLiteral() { return literal; }  public String getTail() { return tail; } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.net.MalformedURLException; public final class PercentDecodingReaderInputStream extends InputStream { private final Reader delegate;  public PercentDecodingReaderInputStream(final Reader delegate) { this.delegate = delegate; }  @Override public int read() throws IOException { int c = delegate.read(); if (c == -1) { return -1; } if (c == '%') { return readHexByte(); } else if (c < 0x80) { return c; } else { throw new MalformedURLException(\"Unescaped non-ASCII character.\"); } } private int readHexByte() throws IOException { int c = delegate.read(); if (isHexDigit(c)) { int hi = Character.getNumericValue(c) << 4; c = delegate.read(); if (isHexDigit(c)) { return hi | Character.getNumericValue(c); } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } private boolean isHexDigit(int c) { return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); } @Override public void close() throws IOException { delegate.close(); } }"}
{"name": "dashorst/wicket-stuff-markup-validator", "content": " package org.whattf.io; import java.io.IOException; import java.io.Reader; import java.net.MalformedURLException; public final class Utf8PercentDecodingReader extends Reader { private final Reader delegate; private char pending = '\\u0000';  public Utf8PercentDecodingReader(final Reader delegate) { this.delegate = delegate; }  @Override public int read() throws IOException { if (pending != '\\u0000') { char rv = pending; pending = '\\u0000'; return rv; } int byteVal = 0; int codePoint = 0; int c = delegate.read(); int trailBytes = 0; if (c == -1) { return -1; } if (c == '%') { byteVal = readHexByte(); if (byteVal < 0x80) { return byteVal; } else if ((0xE0 & byteVal) == 0xC0) { trailBytes = 1; codePoint = byteVal & 0x1F; } else if ((0xF0 & byteVal) == 0xE0) { trailBytes = 2; codePoint = byteVal & 0x0F; } else if ((0xF8 & byteVal) == 0xF0) { trailBytes = 3; codePoint = byteVal & 0x07; } else { throw new MalformedURLException(\"Percent escape decodes to a byte that is not a valid UTF-8 lead byte.\"); } for (int i = 0; i < trailBytes; i++) { byteVal = readPercentHexByte(); if ((0xC0 & byteVal) == 0x80) { codePoint = (codePoint << 6) | (byteVal & 0x3F); } else { throw new MalformedURLException(\"Percent escape decodes to a byte that is not a valid UTF-8 trail byte.\"); } } switch (trailBytes) { case 3: if (codePoint <= 0xFFFF) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { int rv = (0xD7C0 + (codePoint >> 10)); pending = (char) (0xDC00 + (codePoint & 0x3FF)); return rv; } case 2: if (codePoint <= 0x07FF) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { return codePoint; } default: if (codePoint <= 0x007F) { throw new MalformedURLException(\"Non-shortest form UTF-8 percent escape sequence.\"); } else { return codePoint; } } } else { return c; } } private int readPercentHexByte() throws IOException { int c = delegate.read(); if (c != '%') { throw new MalformedURLException(\"Percent-encoded trail byte missing.\"); } return readHexByte(); } private int readHexByte() throws IOException { int c = delegate.read(); if (isHexDigit(c)) { int hi = Character.getNumericValue(c) << 4; c = delegate.read(); if (isHexDigit(c)) { return hi | Character.getNumericValue(c); } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } else { throw new MalformedURLException(\"Malformed percent escape.\"); } } private boolean isHexDigit(int c) { return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); } @Override public void close() throws IOException { pending = '\\u0000'; delegate.close(); } @Override public int read(char[] cbuf, int off, int len) throws IOException { int i = 0; while (i < len) { int c = read(); if (c == -1) { if (i == 0) { return -1; } else { return i; } } cbuf[off] = (char) c; off++; i++; } return i; } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; import java.io.BufferedWriter; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PushbackInputStream; import java.io.UnsupportedEncodingException; import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; public abstract class HttpMessage { protected Map<String, String> headers; public abstract String firstLine(); protected byte[] body; protected String httpVersion; public HttpMessage() { super(); } public Map<String, String> getHeaders() { return headers; } public void setHeaders(Map<String, String> headers) { this.headers = headers; } public void setHeader(String key, String value) { if (this.headers == null) { this.headers = new HashMap<String, String>(); } this.headers.put(key, value); } public String getHeader(String headerName) { return getHeader(headerName, null); } public String getHeader(String headerName, String defaultValue) { if (headers != null) { String lcHeader = headerName.toLowerCase(); if (headers.containsKey(lcHeader)) { return headers.get(lcHeader); } } return defaultValue; } public byte[] getBody() { return body; } public void setBody(byte[] body) { this.body = body; }  public void setBody(String body) { try { setBody(body.getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException uee) { throw new RuntimeException(uee); } } public String toString() { return this.getClass().getName() + \"(\" + this.firstLine().trim() + \")\"; } public String getHttpVersion() { return httpVersion; } public void setHttpVersion(String httpVersion) { this.httpVersion = httpVersion; } protected String checkHttpVersion(String v) throws IOException { if (v.startsWith(\"HTTP/\")) { return v.substring(5); } else { throw new IOException(\"Invalid http version string: \" + v); } } public void writeOn(OutputStream o) throws IOException { BufferedWriter w = new BufferedWriter(new OutputStreamWriter(o)); w.write(this.firstLine()); if (headers != null) { for (Entry<String, String> entry : headers.entrySet()) { w.write(entry.getKey() + \": \" + entry.getValue() + \"\\r\\n\"); } } w.write(\"\\r\\n\"); w.flush(); if (body != null) { o.write(body); } } protected abstract void readFirstLine(PushbackInputStream r) throws IOException; public boolean readFrom(InputStream s) { PushbackInputStream r = new PushbackInputStream(s); try { readFirstLine(r); readHeaders(r); return readBody(s); } catch (NumberFormatException nfe) { return false; } catch (IOException ioe) { return false; } } protected boolean readBody(InputStream s) throws IOException { if (headers != null && headers.containsKey(\"content-length\")) { int contentLength = Integer.parseInt((String) headers .get(\"content-length\")); body = new byte[contentLength]; int readCount = 0; int remaining = contentLength; while (readCount < contentLength) { int n = s.read(body, readCount, remaining); if (n == -1) return false; readCount += n; remaining -= n; } } return true; } protected void readHeaders(PushbackInputStream r) throws IOException { headers = null; while (true) { if (consumeEol(r)) { break; } String key = readUpTo(r, ':'); String value = readUpToEol(r); setHeader(key.trim().toLowerCase(), value.trim()); } } protected boolean consumeEol(PushbackInputStream r) throws IOException { int ch = r.read(); if (ch == -1) { return false; } if (ch == '\\r') { ch = r.read(); if (ch != -1 && ch != '\\n') { r.unread(ch); } return true; } if (ch == '\\n') { return true; } r.unread(ch); return false; } protected String readUpTo(PushbackInputStream r, char separator) throws IOException { StringBuffer buf = new StringBuffer(); while (true) { int ch = r.read(); if (ch == -1 || ch == separator) { return buf.toString(); } if (ch == '\\r' || ch == '\\n') { throw new IOException(\"Unexpected embedded CR or LF\"); } buf.append((char) ch); } } protected String readUpToEol(PushbackInputStream r) throws IOException { StringBuffer buf = new StringBuffer(); while (true) { if (consumeEol(r)) { return buf.toString(); } int ch = r.read(); if (ch == -1) { throw new IOException(\"Unexpected EOF\"); } buf.append((char) ch); } } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.net.URLEncoder; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class HttpQuery { public interface KeyValueHandler { void handle(String key, String value); } public static void foreachKeyValue(String queryStr, KeyValueHandler handler) { if (queryStr != null) { for (String item : queryStr.split(\"&\")) { String[] pieces = item.split(\"=\"); try { String key = URLDecoder.decode(pieces[0], \"UTF-8\"); String value = pieces.length > 1 ? URLDecoder.decode(pieces[1], \"UTF-8\") : \"\"; handler.handle(key, value); } catch (UnsupportedEncodingException uee) { throw new RuntimeException(uee); } } } } public static Map<String, String> parse(String queryStr) { final Map<String, String> result = new HashMap<String, String>(); foreachKeyValue(queryStr, new KeyValueHandler() { public void handle(String key, String value) { result.put(key, value); } }); return result; } public static Map<String, List<String>> parseMultiple(String queryStr) { final Map<String, List<String>> result = new HashMap<String, List<String>>(); foreachKeyValue(queryStr, new KeyValueHandler() { public void handle(String key, String value) { if (!result.containsKey(key)) { result.put(key, new ArrayList<String>()); } result.get(key).add(value); } }); return result; } private static boolean appendEntry(StringBuilder sb, boolean needAmpersand, String key, String value) { try { if (needAmpersand) { sb.append('&'); } sb.append(URLEncoder.encode(key, \"UTF-8\")); sb.append('='); sb.append(URLEncoder.encode(value, \"UTF-8\")); return true; } catch (UnsupportedEncodingException uee) { throw new RuntimeException(uee); } } public static String unparse(Map<String, String> parsedQuery) { StringBuilder sb = new StringBuilder(); boolean needAmpersand = false; for (Map.Entry<String, String> e : parsedQuery.entrySet()) { needAmpersand = appendEntry(sb, needAmpersand, e.getKey(), e.getValue()); } return sb.toString(); } public static String unparseMultiple(Map<String, List<String>> parsedQuery) { StringBuilder sb = new StringBuilder(); boolean needAmpersand = false; for (Map.Entry<String, List<String>> e : parsedQuery.entrySet()) { for (String value : e.getValue()) { needAmpersand = appendEntry(sb, needAmpersand, e.getKey(), value); } } return sb.toString(); } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; import java.io.IOException; import java.io.PushbackInputStream; import java.util.Map; public class HttpRequest extends HttpMessage { private String method; private String rawPath; private String clientHost; private int clientPort; private HttpResponse response; public HttpRequest() { } public HttpRequest(String clientHost, int clientPort, String method, String rawPath, String httpVersion, Map<String, String> headers, byte[] body) { this.clientHost = clientHost; this.clientPort = clientPort; this.method = method; this.rawPath = rawPath; this.httpVersion = httpVersion; this.headers = headers; this.body = body; this.response = null; } public HttpResponse getResponse() { return response; } public void setResponse(HttpResponse response) { this.response = response; } public String getMethod() { return method; } public void setMethod(String method) { this.method = method; } public String getRawPath() { return rawPath; } public void setRawPath(String rawPath) { this.rawPath = rawPath; } public String getClientHost() { return clientHost; } public int getClientPort() { return clientPort; } public void setClientHost(String clientHost) { this.clientHost = clientHost; } public void setClientPort(int clientPort) { this.clientPort = clientPort; } @Override protected void readFirstLine(PushbackInputStream r) throws IOException { method = readUpTo(r, ' '); rawPath = readUpTo(r, ' '); httpVersion = checkHttpVersion(readUpToEol(r)); } public void setResponse(int statusCode, String statusText) { setResponse(new HttpResponse(httpVersion, statusCode, statusText, null, null)); } public String firstLine() { return method + \" \" + rawPath + \" HTTP/\" + httpVersion + \"\\r\\n\"; } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; import java.io.IOException; import java.io.PushbackInputStream; import java.util.Map; public class HttpResponse extends HttpMessage { private int statusCode; private String statusText; public HttpResponse() { } public HttpResponse(String httpVersion, int statusCode, String statusText, Map<String, String> headers, byte[] body) { this.httpVersion = httpVersion; this.statusCode = statusCode; this.statusText = statusText; this.headers = headers; this.body = body; } public int getStatusCode() { return statusCode; } public void setStatusCode(int statusCode) { this.statusCode = statusCode; } public String getStatusText() { return statusText; } public void setStatusText(String statusText) { this.statusText = statusText; } @Override public String firstLine() { return \"HTTP/\" + httpVersion + \" \" + statusCode + \" \" + statusText + \"\\r\\n\"; } protected void readFirstLine(PushbackInputStream r) throws IOException { httpVersion = checkHttpVersion(readUpTo(r, ' ')); statusCode = Integer.parseInt(readUpTo(r, ' ')); statusText = readUpToEol(r); } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; import java.io.IOException; import java.util.logging.Level; import java.util.logging.LogRecord; import java.util.logging.Logger; abstract public class HttpServer { protected RequestHandler handler; private boolean running; public HttpServer(RequestHandler handler) { this.handler = handler; this.running = false; } public void serve() throws IOException { running = true; while (running) { pollOnce(); } } public void stop() { running = false; } abstract public void pollOnce() throws IOException; protected void complain(String msg) { Logger.getLogger(this.getClass().getName()).severe(msg); } protected void complain(String msg, Throwable thrown) { LogRecord r = new LogRecord(Level.SEVERE, msg); r.setThrown(thrown); Logger.getLogger(this.getClass().getName()).log(r); } public Object getHandler() { return handler; } public void setHandler(RequestHandler handler) { this.handler = handler; } protected boolean isRunning() { return running; } protected void handleRequest(HttpRequest req) { try { handler.handleRequest(req); } catch (Exception e) { if (req.getResponse() == null) { req.setResponse(500, \"Internal Server Error\"); } } } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class NormalHttpServer extends HttpServer { private int port; private ServerSocket serverSocket; public NormalHttpServer(int port, RequestHandler handler) throws IOException { super(handler); this.port = port; this.serverSocket = new ServerSocket(port); } public int getPort() { return port; } public ServerSocket getServerSocket() { return serverSocket; } @Override public void pollOnce() throws IOException { Socket conn = serverSocket.accept(); try { singleRequest(conn); } catch (IOException ioe) { complain(ioe.toString(), ioe); } } protected void singleRequest(Socket conn) throws IOException { HttpRequest req = new HttpRequest(); req.setClientHost(conn.getInetAddress().getHostAddress()); req.setClientPort(conn.getPort()); if (!req.readFrom(conn.getInputStream())) { req.setResponse(400, \"Bad syntax\"); } else { req.setHttpVersion(\"1.0\"); handleRequest(req); } HttpResponse resp = req.getResponse(); if (resp != null) { resp.writeOn(conn.getOutputStream()); } conn.close(); } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; public interface RequestHandler { void handleRequest(HttpRequest req); }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp; import java.beans.PropertyChangeListener; import java.beans.PropertyChangeSupport; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.logging.Logger; public class ReverseHttpServer extends HttpServer { private String label; private URL nextReq; private URL location; private URL serverAddress; private String token; private int leaseSeconds; private int failureDelay; private PropertyChangeSupport support; public ReverseHttpServer(String label, URL serverAddress, RequestHandler handler) { super(handler); this.label = label; this.nextReq = null; this.location = null; this.serverAddress = serverAddress; this.handler = handler; this.token = \"-\"; this.leaseSeconds = 30; this.support = new PropertyChangeSupport(this); } public int getFailureDelay() { return failureDelay; } public void setFailureDelay(int failureDelay) { this.failureDelay = failureDelay; } protected URL getNextReq() { return nextReq; } public String getToken() { return token; } public void setToken(String token) { this.token = token; } public int getLeaseSeconds() { return leaseSeconds; } public void setLeaseSeconds(int leaseSeconds) { this.leaseSeconds = leaseSeconds; } @Override public void pollOnce() throws IOException { this.failureDelay = 2000; while (true) { try { pollOnceNoRetry(); break; } catch (IOException ioe) { debugLog(\"IOException from pollOnceNoRetry: \" + ioe); if (!shouldRetry(ioe)) { break; } else { try { Thread.sleep(this.failureDelay); } catch (InterruptedException e) { break; } incrementFailureDelay(); } } } } protected void incrementFailureDelay() { if (this.failureDelay < 30000) { this.failureDelay = this.failureDelay * 2; } } protected boolean shouldRetry(IOException ioe) { return isRunning(); } public void pollOnceNoRetry() throws IOException { boolean declareMode = (this.nextReq == null); HttpURLConnection conn; if (declareMode) { String params = \"name=\" + this.label + \"&token=\" + this.token; conn = openServerConnection(this.serverAddress); conn.setRequestMethod(\"POST\"); conn.setRequestProperty(\"content-type\", \"application/x-www-form-urlencoded\"); conn.setDoOutput(true); OutputStream os = conn.getOutputStream(); os.write(params.getBytes(\"ASCII\")); os.flush(); os.close(); debugLog(\"Registering \" + this.label + \" at \" + this.serverAddress); } else { conn = openServerConnection(this.nextReq); debugLog(\"Polling \" + this.nextReq); } conn.connect(); int pollResponseCode = conn.getResponseCode(); if (pollResponseCode < 200 || pollResponseCode >= 300) { throw new IOException(\"Unexpected response code: \" + pollResponseCode); } if (declareMode) { Map<String, URL> linkHeaders = parseLinkHeaders(conn); setNextReq(linkHeaders.get(\"first\")); if (linkHeaders.containsKey(\"related\")) { setLocation(linkHeaders.get(\"related\")); } return; } if (pollResponseCode == 204) { "}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.examples; import net.reversehttp.HttpServer; import net.reversehttp.NormalHttpServer; import net.reversehttp.messaging.Address; import net.reversehttp.messaging.ServiceContainer; public class NormalSub { public static void main(String[] args) { try { String sourceStr = (args.length > 0) ? args[0] : \"relay@relay.localhost.lshift.net:8000\"; String ownAddressStr = (args.length > 1) ? args[1] : \"queue@localhost.lshift.net:8001\"; int port = (args.length > 2) ? Integer.parseInt(args[2]) : 8001; Address ownAddress = Address.parse(ownAddressStr); ServiceContainer container = new ServiceContainer(ownAddress .getDomain()); container.bindName(ownAddress, new Sub(ownAddress, Address .parse(sourceStr))); HttpServer httpd = new NormalHttpServer(port, container); httpd.serve(); } catch (Exception e) { e.printStackTrace(); } } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.examples; import java.util.Date; import net.reversehttp.messaging.Address; import net.reversehttp.messaging.Message; public class Pub { public static void main(String[] args) { int count = (args.length > 2) ? Integer.parseInt(args[2]) : 1; for (int i = 0; i < count; i++) { String targetStr = (args.length > 0) ? args[0] : \"relay@relay.localhost.lshift.net:8000\"; String body = (args.length > 1 && !args[1].equals(\"\")) ? args[1] : new Date().toString(); Message msg = new Message(null, Address.parse(targetStr), body .getBytes()); msg.deliver(); } } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.examples; import java.net.URL; import java.util.Random; import net.reversehttp.HttpServer; import net.reversehttp.ReverseHttpServer; import net.reversehttp.messaging.Address; import net.reversehttp.messaging.ServiceContainer; public class ReverseSub { public static void main(String[] args) { try { String sourceStr = (args.length > 0) ? args[0] : \"relay@relay.localhost.lshift.net:8000\"; String hostAndPort = (args.length > 1) ? args[1] : \"localhost.lshift.net:8000\"; URL serverUrl = new URL(\"http:"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.examples; import java.io.UnsupportedEncodingException; import net.reversehttp.messaging.Address; import net.reversehttp.messaging.Message; import net.reversehttp.messaging.MessageHandler; public class Sub implements MessageHandler { public Sub(Address ownAddress, Address source) { boolean subscribedOk = new Message(ownAddress, source, (\"{\\\"name\\\":\\\"\" + ownAddress + \"\\\"}\").getBytes(), \"application/json\", \"subscribe\").deliver(); if (subscribedOk) { System.out.println(\"Subscribed \" + source + \" -> \" + ownAddress); } else { throw new RuntimeException(\"Couldn't subscribe to \" + source); } } public int handleMessage(Message msg) { try { System.out .println(msg.getSender() + \" -> \" + msg.getTarget() + \", \" + msg.getContentType() + \": \" + msg.getBody(\"ASCII\")); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return 200; } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.messaging; public class Address { private String localName; private String domain; public Address(String localName, String domain) { this.localName = localName; this.domain = domain; } public static Address parse(String str) throws IllegalArgumentException { int atPos = str.indexOf('@'); if (atPos == -1) { return new Address(null, str); } else { return new Address(str.substring(0, atPos), str .substring(atPos + 1)); } } public String getDomain() { return domain; } public String getLocalName() { return localName == null ? \"\" : localName; } public String toString() { return localName == null ? domain : localName + \"@\" + domain; } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.messaging; import java.io.IOException; import java.io.OutputStream; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.URL; import java.util.ArrayList; import java.util.List; public class Message { private static final byte[] EMPTY_BODY = new byte[0]; private Address sender; private Address target; private byte[] body; private String contentType; private String method; private List<Integer> errorCodes; private List<Exception> exceptions; public Message() { } public Message(Address sender, Address target, byte[] body) { this(sender, target, body, \"text/plain\"); } public Message(Address sender, Address target, byte[] body, String contentType) { this(sender, target, body, contentType, \"send\"); } public Message(Address sender, Address target, byte[] body, String contentType, String method) { this.sender = sender; this.target = target; this.setBody(body); this.contentType = contentType; this.method = method; this.errorCodes = null; this.exceptions = null; } public Message retarget(Address newSender, Address newTarget) { return new Message(newSender, newTarget, body, contentType, method); } public boolean deliver() { return deliver(3, 2000, 30000, 2); } public boolean deliver(int maxAttemptCount, int initialFailureDelay, int failureDelayLimit, double failureDelayMultiplier) { int failureDelay = initialFailureDelay; errorCodes = null; exceptions = null; URL targetUrl; try { targetUrl = new URL(\"http:"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.messaging; public interface MessageHandler { int handleMessage(Message msg); }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.messaging; import java.util.HashMap; import java.util.Map; import java.util.logging.Level; import java.util.logging.LogRecord; import java.util.logging.Logger; import net.reversehttp.HttpRequest; import net.reversehttp.RequestHandler; public class ServiceContainer implements RequestHandler { private String domain; private Map<String, MessageHandler> pathMap; public ServiceContainer(String domain) { this.domain = domain; this.pathMap = new HashMap<String, MessageHandler>(); } public String getDomain() { return domain; } public void bindName(Address name, MessageHandler receiver) { pathMap.put(extractLocalname(name), receiver); } private String extractLocalname(Address name) { if (name.getDomain().equals(domain)) { return name.getLocalName(); } else { throw new IllegalArgumentException(\"Domain mismatch: \" + name + \", \" + domain); } } public void handleRequest(HttpRequest req) { String targetLocalname = req.getRawPath().substring(1); Address target = new Address(targetLocalname, domain); String senderStr = req.getHeader(\"X-SMQP-Sender\"); Address sender = senderStr == null ? null : Address.parse(senderStr); String contentType = req.getHeader(\"Content-type\"); String method = req.getHeader(\"X-SMQP-Method\", \"send\"); Message msg = new Message(sender, target, req.getBody(), contentType, method); try { if (pathMap.containsKey(targetLocalname)) { MessageHandler handler = pathMap.get(targetLocalname); int responseCode = handler.handleMessage(msg); req.setResponse(responseCode, \"\"); } else { req.setResponse(404, \"Destination not found\"); } } catch (Exception e) { LogRecord r = new LogRecord(Level.SEVERE, \"Exception at \" + target); r.setThrown(e); Logger.getLogger(this.getClass().getName()).log(r); req.setResponse(500, \"Internal error\"); } } }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.pubsub; public interface Endpoint { boolean acceptSubscriptionChange(String mode, String topic, String token, int leaseSeconds); void handleDelivery(String topic, byte[] body); }"}
{"name": "tonyg/reversehttp", "content": "package net.reversehttp.pubsub; import java.net.URI; import java.net.URISyntaxException; import java.util.Map; import java.util.logging.ConsoleHandler; import java.util.logging.Level; import java.util.logging.Logger; import net.reversehttp.HttpQuery; import net.reversehttp.HttpRequest; import net.reversehttp.HttpServer; import net.reversehttp.NormalHttpServer; import net.reversehttp.RequestHandler; public class EndpointService implements RequestHandler { public static void main(String[] args) { configureLogging(); try { int port = (args.length > 0) ? Integer.parseInt(args[0]) : 8888; final Logger logger = Logger.getLogger(EndpointService.class.getName()); logger.log(Level.FINE, \"Starting on port \" + port); HttpServer httpd = new NormalHttpServer(port, new EndpointService(new Endpoint() { public boolean acceptSubscriptionChange(String mode, String topic, String token, int leaseSeconds) { System.out.println(\"Subscription change: \"+mode+\", \"+topic+\", \"+token+\", \"+leaseSeconds); return true; } public void handleDelivery(String topic, byte[] body) { System.out.println(\"Received message:\\n\\\"\" + new String(body) + \"\\\"\"); } })); httpd.serve(); } catch (Exception e) { e.printStackTrace(); } } private static void configureLogging() { ConsoleHandler handler = new ConsoleHandler(); Logger root = Logger.getLogger(\"\"); root.addHandler(handler); handler.setLevel(Level.FINER); root.setLevel(Level.FINER); } private Endpoint handler; public EndpointService(Endpoint handler) { this.handler = handler; } public void handleRequest(HttpRequest req) { URI u; try { u = new URI(req.getRawPath()); } catch (URISyntaxException ue) { req.setResponse(400, \"Invalid path\"); return; } Map<String, String> params = HttpQuery.parse(u.getQuery()); if (\"GET\".equals(req.getMethod())) { String challenge = params.get(\"hub.challenge\"); if (challenge == null) challenge = \"\"; int leaseSeconds; try { leaseSeconds = Integer.parseInt(params.get(\"hub.lease_seconds\")); } catch (NumberFormatException nfe) { leaseSeconds = -1; } if (handler.acceptSubscriptionChange(params.get(\"hub.mode\"), params.get(\"hub.topic\"), params.get(\"hub.verify_token\"), leaseSeconds)) { req.setResponse(200, \"OK\"); req.getResponse().setHeader(\"Content-type\", \"text/plain; charset=utf-8\"); req.getResponse().setBody(challenge); } else { req.setResponse(403, \"Forbidden\"); } } else if (\"POST\".equals(req.getMethod())) { String topic = params.get(\"hub.topic\"); this.handler.handleDelivery(topic, req.getBody()); req.setResponse(204, \"OK\"); } else { req.setResponse(405, \"Invalid HTTP method\"); } } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.transport; import java.io.IOException;  public class AndroidHttpTransport extends HttpTransportSE {  public AndroidHttpTransport(String url) { super(url); }  @Override protected ServiceConnection getServiceConnection() throws IOException { return new AndroidServiceConnection(super.url); } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.transport; import java.io.IOException;  public class AndroidServiceConnection extends ServiceConnectionSE {  public AndroidServiceConnection(String url) throws IOException { super(url); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2; import java.io.*; import org.kxml2.kdom.*; import org.xmlpull.v1.*;  public class SoapEnvelope {  public static final int VER10 = 100;  public static final int VER11 = 110;  public static final int VER12 = 120; public static final String ENV2001 = \"http:"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2; import java.io.IOException; import org.kxml2.kdom.Node; import org.xmlpull.v1.XmlPullParser; import org.xmlpull.v1.XmlPullParserException; import org.xmlpull.v1.XmlSerializer;  public class SoapFault extends IOException {  public String faultcode;  public String faultstring;  public String faultactor;  public Node detail;  public void parse(XmlPullParser parser) throws IOException, XmlPullParserException { parser.require(XmlPullParser.START_TAG, SoapEnvelope.ENV, \"Fault\"); while (parser.nextTag() == XmlPullParser.START_TAG) { String name = parser.getName(); if (name.equals(\"detail\")) { detail = new Node(); detail.parse(parser); continue; } else if (name.equals(\"faultcode\")) faultcode = parser.nextText(); else if (name.equals(\"faultstring\")) faultstring = parser.nextText(); else if (name.equals(\"faultactor\")) faultactor = parser.nextText(); else throw new RuntimeException(\"unexpected tag:\" + name); parser.require(XmlPullParser.END_TAG, null, name); } parser.require(XmlPullParser.END_TAG, SoapEnvelope.ENV, \"Fault\"); parser.nextTag(); }  public void write(XmlSerializer xw) throws IOException { xw.startTag(SoapEnvelope.ENV, \"Fault\"); xw.startTag(null, \"faultcode\"); xw.text(\"\" + faultcode); xw.endTag(null, \"faultcode\"); xw.startTag(null, \"faultstring\"); xw.text(\"\" + faultstring); xw.endTag(null, \"faultstring\"); xw.startTag(null, \"detail\"); if (detail != null) detail.write(xw); xw.endTag(null, \"detail\"); xw.endTag(SoapEnvelope.ENV, \"Fault\"); }  @Override public String getMessage() { return faultstring; }  public String toString() { return \"SoapFault - faultcode: '\" + faultcode + \"' faultstring: '\" + faultstring + \"' faultactor: '\" + faultactor + \"' detail: \" + detail; } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization;  public class AttributeInfo extends PropertyInfo {  public AttributeInfo() { super(); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.io.*; import org.xmlpull.v1.*; import org.ksoap2.*;  class DM implements Marshal { public Object readInstance(XmlPullParser parser, String namespace, String name, PropertyInfo expected) throws IOException, XmlPullParserException { String text = parser.nextText(); switch (name.charAt(0)) { case 's': return text; case 'i': return new Integer(Integer.parseInt(text)); case 'l': return new Long(Long.parseLong(text)); case 'b': return new Boolean(SoapEnvelope.stringToBoolean(text)); default: throw new RuntimeException(); } } public void writeInstance(XmlSerializer writer, Object instance) throws IOException { writer.text(instance.toString()); } public void register(SoapSerializationEnvelope cm) { cm.addMapping(cm.xsd, \"int\", PropertyInfo.INTEGER_CLASS, this); cm.addMapping(cm.xsd, \"long\", PropertyInfo.LONG_CLASS, this); cm.addMapping(cm.xsd, \"string\", PropertyInfo.STRING_CLASS, this); cm.addMapping(cm.xsd, \"boolean\", PropertyInfo.BOOLEAN_CLASS, this); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization;  class FwdRef { FwdRef next; Object obj; int index; }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.util.Hashtable;  public interface KvmSerializable {  Object getProperty(int index);  int getPropertyCount();  void setProperty(int index, Object value);  void getPropertyInfo(int index, Hashtable properties, PropertyInfo info); }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.io.*; import org.xmlpull.v1.*;  public interface Marshal {  public Object readInstance(XmlPullParser parser, String namespace, String name, PropertyInfo expected) throws IOException, XmlPullParserException;  public void writeInstance(XmlSerializer writer, Object instance) throws IOException;  public void register(SoapSerializationEnvelope envelope); }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.io.*; import org.ksoap2.*; import org.kobjects.base64.*; import org.xmlpull.v1.*;  public class MarshalBase64 implements Marshal { public static Class BYTE_ARRAY_CLASS = new byte[0].getClass(); public Object readInstance(XmlPullParser parser, String namespace, String name, PropertyInfo expected) throws IOException, XmlPullParserException { return Base64.decode(parser.nextText()); } public void writeInstance(XmlSerializer writer, Object obj) throws IOException { writer.text(Base64.encode((byte[]) obj)); } public void register(SoapSerializationEnvelope cm) { cm.addMapping(cm.xsd, \"base64Binary\", MarshalBase64.BYTE_ARRAY_CLASS, this); cm.addMapping(SoapEnvelope.ENC, \"base64\", MarshalBase64.BYTE_ARRAY_CLASS, this); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.util.Date; import java.io.*; import org.xmlpull.v1.*; import org.kobjects.isodate.*;  public class MarshalDate implements Marshal { public static Class DATE_CLASS = new Date().getClass(); public Object readInstance(XmlPullParser parser, String namespace, String name, PropertyInfo expected) throws IOException, XmlPullParserException { return IsoDate.stringToDate(parser.nextText(), IsoDate.DATE_TIME); } public void writeInstance(XmlSerializer writer, Object obj) throws IOException { writer.text(IsoDate.dateToString((Date) obj, IsoDate.DATE_TIME)); } public void register(SoapSerializationEnvelope cm) { cm.addMapping(cm.xsd, \"dateTime\", MarshalDate.DATE_CLASS, this); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.io.*; import java.util.*; import org.xmlpull.v1.*; /** * Serializes instances of hashtable to and from xml. This implementation is * based on the xml schema from apache-soap, namely the type 'map' in the * namespace 'http:"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization;  public class PropertyInfo { public static final Class OBJECT_CLASS = new Object().getClass(); public static final Class STRING_CLASS = \"\".getClass(); public static final Class INTEGER_CLASS = new Integer(0).getClass(); public static final Class LONG_CLASS = new Long(0).getClass(); public static final Class BOOLEAN_CLASS = new Boolean(true).getClass(); public static final Class VECTOR_CLASS = new java.util.Vector().getClass(); public static final PropertyInfo OBJECT_TYPE = new PropertyInfo(); public static final int TRANSIENT = 1; public static final int MULTI_REF = 2; public static final int REF_ONLY = 4;  public String name;  public String namespace;  public int flags;  protected Object value;  public Object type = OBJECT_CLASS;  public boolean multiRef;  public PropertyInfo elementType; public PropertyInfo() { } public void clear() { type = OBJECT_CLASS; flags = 0; name = null; namespace = null; }  public PropertyInfo getElementType() { return elementType; }  public void setElementType(PropertyInfo elementType) { this.elementType = elementType; }  public int getFlags() { return flags; }  public void setFlags(int flags) { this.flags = flags; }  public boolean isMultiRef() { return multiRef; }  public void setMultiRef(boolean multiRef) { this.multiRef = multiRef; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getNamespace() { return namespace; }  public void setNamespace(String namespace) { this.namespace = namespace; }  public Object getType() { return type; }  public void setType(Object type) { this.type = type; }  public Object getValue() { return value; }  public void setValue(Object value) { this.value = value; }  public String toString() { StringBuffer sb = new StringBuffer(); sb.append(name); sb.append(\" : \"); if (value != null) { sb.append(value); } else { sb.append(\"(not set)\"); } return sb.toString(); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.util.*;  public class SoapObject implements KvmSerializable {  protected String namespace;  protected String name;  protected Vector properties = new Vector();  protected Vector attributes = new Vector();  public SoapObject(String namespace, String name) { this.namespace = namespace; this.name = name; } public boolean equals(Object obj) { if (!(obj instanceof SoapObject)) return false; SoapObject otherSoapObject = (SoapObject) obj; int numProperties = properties.size(); if (numProperties != otherSoapObject.properties.size()) return false; int numAttributes = attributes.size(); if (numAttributes != otherSoapObject.attributes.size()) return false; try { for (int propIndex = 0; propIndex < numProperties; propIndex++) { PropertyInfo thisProp = (PropertyInfo) this.properties.elementAt(propIndex); Object thisPropValue = thisProp.getValue(); Object otherPropValue = otherSoapObject.getProperty(thisProp.getName()); if (!thisPropValue.equals(otherPropValue)) { return false; } } for (int attribIndex = 0; attribIndex < numAttributes; attribIndex++) { AttributeInfo thisAttrib = (AttributeInfo) this.properties.elementAt(attribIndex); Object thisAttribValue = thisAttrib.getValue(); Object otherAttribValue = otherSoapObject.getProperty(thisAttrib.getName()); if (!thisAttribValue.equals(otherAttribValue)) { return false; } } } catch (Exception e) { return false; } return true; } public String getName() { return name; } public String getNamespace() { return namespace; }  public Object getProperty(int index) { return ((PropertyInfo) properties.elementAt(index)).getValue(); } public Object getProperty(String name) { for (int i = 0; i < properties.size(); i++) { if (name.equals(((PropertyInfo) properties.elementAt(i)).getName())) return getProperty(i); } throw new RuntimeException(\"illegal property: \" + name); }  public int getPropertyCount() { return properties.size(); }  public void getAttributeInfo(int index, AttributeInfo attributeInfo) { AttributeInfo p = (AttributeInfo) attributes.elementAt(index); attributeInfo.name = p.name; attributeInfo.namespace = p.namespace; attributeInfo.flags = p.flags; attributeInfo.type = p.type; attributeInfo.elementType = p.elementType; attributeInfo.value = p.getValue(); }  public Object getAttribute(int index) { return ((AttributeInfo) attributes.elementAt(index)).getValue(); }  public Object getAttribute(String name) { for (int i = 0; i < attributes.size(); i++) { if (name.equals(((AttributeInfo) attributes.elementAt(i)).getName())) return getAttribute(i); } throw new RuntimeException(\"illegal property: \" + name); }  public int getAttributeCount() { return attributes.size(); }  public void getPropertyInfo(int index, Hashtable properties, PropertyInfo propertyInfo) { getPropertyInfo(index, propertyInfo); }  public void getPropertyInfo(int index, PropertyInfo propertyInfo) { PropertyInfo p = (PropertyInfo) properties.elementAt(index); propertyInfo.name = p.name; propertyInfo.namespace = p.namespace; propertyInfo.flags = p.flags; propertyInfo.type = p.type; propertyInfo.elementType = p.elementType; }  public SoapObject newInstance() { SoapObject o = new SoapObject(namespace, name); for (int propIndex = 0; propIndex < properties.size(); propIndex++) { PropertyInfo propertyInfo = (PropertyInfo) properties.elementAt(propIndex); o.addProperty(propertyInfo); } for (int attribIndex = 0; attribIndex < attributes.size(); attribIndex++) { AttributeInfo attributeInfo = (AttributeInfo) attributes.elementAt(attribIndex); o.addAttribute(attributeInfo); } return o; }  public void setProperty(int index, Object value) { ((PropertyInfo) properties.elementAt(index)).setValue(value); }  public SoapObject addProperty(String name, Object value) { PropertyInfo propertyInfo = new PropertyInfo(); propertyInfo.name = name; propertyInfo.type = value == null ? PropertyInfo.OBJECT_CLASS : value.getClass(); propertyInfo.value = value; return addProperty(propertyInfo); }  public SoapObject addProperty(PropertyInfo propertyInfo, Object value) { propertyInfo.setValue(value); addProperty(propertyInfo); return this; }  public SoapObject addProperty(PropertyInfo propertyInfo) { properties.addElement(propertyInfo); return this; }  public SoapObject addAttribute(String name, Object value) { AttributeInfo attributeInfo = new AttributeInfo(); attributeInfo.name = name; attributeInfo.type = value == null ? PropertyInfo.OBJECT_CLASS : value.getClass(); attributeInfo.value = value; return addAttribute(attributeInfo); }  public SoapObject addAttribute(AttributeInfo attributeInfo) { attributes.addElement(attributeInfo); return this; } public String toString() { StringBuffer buf = new StringBuffer(\"\" + name + \"{\"); for (int i = 0; i < getPropertyCount(); i++) { buf.append(\"\" + ((PropertyInfo) properties.elementAt(i)).getName() + \"=\" + getProperty(i) + \"; \"); } buf.append(\"}\"); return buf.toString(); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization;  public class SoapPrimitive { String namespace; String name; String value; public SoapPrimitive(String namespace, String name, String value) { this.namespace = namespace; this.name = name; this.value = value; } public boolean equals(Object o) { if (!(o instanceof SoapPrimitive)) { return false; } SoapPrimitive p = (SoapPrimitive) o; return name.equals(p.name) && (namespace == null ? p.namespace == null:namespace.equals(p.namespace)) && (value == null ? (p.value == null) : value.equals(p.value)); } public int hashCode() { return name.hashCode() ^ (namespace == null ? 0 : namespace.hashCode()); } public String toString() { return value; } public String getNamespace() { return namespace; } public String getName() { return name; } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.io.*; import java.util.*; import org.ksoap2.*; import org.xmlpull.v1.*;  public class SoapSerializationEnvelope extends SoapEnvelope { protected static final int QNAME_TYPE = 1; protected static final int QNAME_NAMESPACE = 0; protected static final int QNAME_MARSHAL = 3; private static final String ANY_TYPE_LABEL = \"anyType\"; private static final String ARRAY_MAPPING_NAME = \"Array\"; private static final String NULL_LABEL = \"null\"; private static final String NIL_LABEL = \"nil\"; private static final String HREF_LABEL = \"href\"; private static final String ID_LABEL = \"id\"; private static final String ROOT_LABEL = \"root\"; private static final String TYPE_LABEL = \"type\"; private static final String ITEM_LABEL = \"item\"; private static final String ARRAY_TYPE_LABEL = \"arrayType\"; static final Marshal DEFAULT_MARSHAL = new DM(); public Hashtable properties = new Hashtable(); Hashtable idMap = new Hashtable(); Vector multiRef; "}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.transport; import java.io.*;  public interface ServiceConnection {  public void connect() throws IOException;  public void disconnect() throws IOException;  public void setRequestProperty(String propertyName, String value) throws IOException;  public void setRequestMethod(String requestMethodType) throws IOException;  public OutputStream openOutputStream() throws IOException;  public InputStream openInputStream() throws IOException;  public InputStream getErrorStream(); }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.transport; import java.io.*; import org.ksoap2.*; import org.kxml2.io.*; import org.xmlpull.v1.*;  abstract public class Transport { protected String url;  public boolean debug;  public String requestDump;  public String responseDump; private String xmlVersionTag = \"\"; public Transport() { } public Transport(String url) { this.url = url; }  protected void parseResponse(SoapEnvelope envelope, InputStream is) throws XmlPullParserException, IOException { XmlPullParser xp = new KXmlParser(); xp.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true); xp.setInput(is, null); envelope.parse(xp); }  protected byte[] createRequestData(SoapEnvelope envelope) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); bos.write(xmlVersionTag.getBytes()); XmlSerializer xw = new KXmlSerializer(); xw.setOutput(bos, null); envelope.write(xw); xw.flush(); bos.write('\\r'); bos.write('\\n'); bos.flush(); return bos.toByteArray(); }  public void setUrl(String url) { this.url = url; }  public void setXmlVersionTag(String tag) { xmlVersionTag = tag; }  public void reset() { }  abstract public void call(String targetNamespace, SoapEnvelope envelope) throws IOException, XmlPullParserException; }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.transport; import java.io.*;  public class HttpTransportBasicAuth extends HttpTransport { private String username; private String password;  public HttpTransportBasicAuth(String url, String username, String password) { super(url); this.username = username; this.password = password; } protected ServiceConnection getServiceConnection() throws IOException { ServiceConnectionMidp midpConnection = new ServiceConnectionMidp(url); addBasicAuthentication(midpConnection); return midpConnection; } protected void addBasicAuthentication(ServiceConnection midpConnection) throws IOException { if (username != null && password != null) { StringBuffer buf = new StringBuffer(username); buf.append(':').append(password); byte[] raw = buf.toString().getBytes(); buf.setLength(0); buf.append(\"Basic \"); org.kobjects.base64.Base64.encode(raw, 0, raw.length, buf); midpConnection.setRequestProperty(\"Authorization\", buf.toString()); } } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.serialization; import java.io.*; import org.xmlpull.v1.*; public class MarshalFloat implements Marshal { public Object readInstance(XmlPullParser parser, String namespace, String name, PropertyInfo propertyInfo) throws IOException, XmlPullParserException { String stringValue = parser.nextText(); Object result; if (name.equals(\"float\")) { result = new Float(stringValue); } else if (name.equals(\"double\")) { result = new Double(stringValue); } else if (name.equals(\"decimal\")) { result = new java.math.BigDecimal(stringValue); } else { throw new RuntimeException(\"float, double, or decimal expected\"); } return result; } public void writeInstance(XmlSerializer writer, Object instance) throws IOException { writer.text(instance.toString()); } public void register(SoapSerializationEnvelope cm) { cm.addMapping(cm.xsd, \"float\", Float.class, this); cm.addMapping(cm.xsd, \"double\", Double.class, this); cm.addMapping(cm.xsd, \"decimal\", java.math.BigDecimal.class, this); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.transport; import java.io.*; import org.ksoap2.*; import org.xmlpull.v1.*;  public class HttpTransportSE extends Transport {  public HttpTransportSE(String url) { super(url); }  public void call(String soapAction, SoapEnvelope envelope) throws IOException, XmlPullParserException { if (soapAction == null) soapAction = \"\\\"\\\"\"; byte[] requestData = createRequestData(envelope); requestDump = debug ? new String(requestData) : null; responseDump = null; ServiceConnection connection = getServiceConnection(); connection.setRequestProperty(\"User-Agent\", \"kSOAP/2.0\"); connection.setRequestProperty(\"SOAPAction\", soapAction); connection.setRequestProperty(\"Content-Type\", \"text/xml\"); connection.setRequestProperty(\"Connection\", \"close\"); connection.setRequestProperty(\"Content-Length\", \"\" + requestData.length); connection.setRequestMethod(\"POST\"); connection.connect(); OutputStream os = connection.openOutputStream(); os.write(requestData, 0, requestData.length); os.flush(); os.close(); requestData = null; InputStream is; try { connection.connect(); is = connection.openInputStream(); } catch (IOException e) { is = connection.getErrorStream(); if (is == null) { connection.disconnect(); throw (e); } } if (debug) { ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buf = new byte[256]; while (true) { int rd = is.read(buf, 0, 256); if (rd == -1) break; bos.write(buf, 0, rd); } bos.flush(); buf = bos.toByteArray(); responseDump = new String(buf); is.close(); is = new ByteArrayInputStream(buf); } parseResponse(envelope, is); } protected ServiceConnection getServiceConnection() throws IOException { return new ServiceConnectionSE(url); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.transport; import java.io.*; import java.net.*;  public class ServiceConnectionSE implements ServiceConnection { private HttpURLConnection connection;  public ServiceConnectionSE(String url) throws IOException { connection = (HttpURLConnection) new URL(url).openConnection(); connection.setUseCaches(false); connection.setDoOutput(true); connection.setDoInput(true); } public void connect() throws IOException { connection.connect(); } public void disconnect() { connection.disconnect(); } public void setRequestProperty(String string, String soapAction) { connection.setRequestProperty(string, soapAction); } public void setRequestMethod(String requestMethod) throws IOException { connection.setRequestMethod(requestMethod); } public OutputStream openOutputStream() throws IOException { return connection.getOutputStream(); } public InputStream openInputStream() throws IOException { return connection.getInputStream(); } public InputStream getErrorStream() { return connection.getErrorStream(); } }"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.transport; import java.io.*; import javax.microedition.io.*; import org.ksoap2.*; import org.xmlpull.v1.*; /** * Methods to facilitate SOAP calls over HTTP using the J2ME generic connection * framework. * <p> * Instances of HttpTransport can be in one of two states: connected and not * connected. When an invocation on call is made the instance is in a connected * state until call returns or throws an IOException. in any case once control * is returned to the caller the instance is again in the not connected state. * HttpTransport is not thread safe and applications should ensure that only one * thread is inside the call method at any given time. It is designed in such a * way that applications can reuse a single instance for all soap calls to one, * or multiple, target endpoints. * <p> * * The underlying HttpConnection is opened with the timeout flag set. In the * MIDP API this flag is only a hint to the underlying protocol handler to throw * an InterrruptIOException, however, there are no guarantees that it will be * handled. So rather than support a timeout mechanism internally the design is * such that applications can manage timeouts in an environment dependent way. * <p> * * For example some environments may allow for a timeout parameter that can be * externally specified in perhaps a system property (which? I don't know. it's * in the api). Others like the emulator (ok, who cares) and the Motorola i85s * can use a simple and effective timeout mechanism that closes the connection * and associated streams in an asynchronous fashion. Calling the close( ) * method inside of a separate thread can provide for this timeout handling by * releasing threads that maybe stuck inside of call( ) performing network io. * <p> * * Here is some sample code to demonstrate how such a timeout mechanism may * look:<br> * * <pre> * private HttpTransport soap; * ... * TimerTask task = * new TimerTask( ) { public void run( ) { soap.close( ); } }; * * try { * new Timer( ).schedule( task, TIMEOUT ); * soap.call( soapobject ); "}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.transport; import java.io.*; import javax.microedition.io.*; public class ServiceConnectionMidp implements ServiceConnection { private HttpConnection connection; public ServiceConnectionMidp(String url) throws IOException { connection = (HttpConnection) Connector.open(url, Connector.READ_WRITE, true); } public void disconnect() throws IOException { connection.close(); } public void setRequestProperty(String string, String soapAction) throws IOException { connection.setRequestProperty(string, soapAction); } public void setRequestMethod(String post) throws IOException { connection.setRequestMethod(post); } public OutputStream openOutputStream() throws IOException { return connection.openOutputStream(); } public InputStream openInputStream() throws IOException { return connection.openInputStream(); } public void connect() throws IOException { throw new RuntimeException(\"ServiceConnectionMidp.connect is not available.\"); } public InputStream getErrorStream() { throw new RuntimeException(\"ServiceConnectionMidp.getErrorStream is not available.\"); } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package net.wessendorf.j2me; import javax.microedition.lcdui.*; import javax.microedition.midlet.*; import org.ksoap2.*; import org.ksoap2.serialization.*; import org.ksoap2.transport.*; public class SoapDemo extends MIDlet implements CommandListener{ private Display display; Form mainForm = new Form (\"Hello World WebService\"); TextField nameField = new TextField (\"Your name\",\"\",456,TextField.ANY); Command getCommand = new Command (\"send\", Command.SCREEN, 1); public SoapDemo () { mainForm.append (nameField); mainForm.addCommand (getCommand); mainForm.setCommandListener (this); } public void startApp() { display = Display.getDisplay (this); display.setCurrent (mainForm); } public void pauseApp() { } public void destroyApp(boolean unconditional) { } public void commandAction(Command c, Displayable s) { if (c == getCommand) { final TextBox t = new TextBox(\"\", \"\", 256, 0); Thread thr = new Thread(){ public void run() { try { SoapObject client = new SoapObject(\"\",\"getObject\"); client.addProperty(\"name\",nameField.getString()); SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); envelope.bodyOut = client; HttpTransport ht = new HttpTransport(\"http:"}
{"name": "karlmdavis/ksoap2-android", "content": "/* * Copyright 2004 The Apache Software Foundation. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "karlmdavis/ksoap2-android", "content": "/* * Copyright 2004 The Apache Software Foundation. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon; import java.util.Vector; import javax.microedition.midlet.*; import javax.microedition.lcdui.*; import org.ksoap2.*; import org.ksoap2.serialization.*; import org.ksoap2.transport.*; /** * @author Stefan Haustein * * To try this demo, you need a developer tag from Amazon.com, see * http:"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search; import org.ksoap2.*; import org.ksoap2.samples.amazon.search.messages.*; import org.ksoap2.serialization.*; import org.ksoap2.transport.*; public class AmazonSearchClient { private static final String NAMESPACE = \"http:"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search.messages; import org.ksoap2.serialization.*; public abstract class BaseObject implements KvmSerializable { protected static final String NAMESPACE = \"http:"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search.messages; import java.util.*; import org.ksoap2.serialization.*; public class Book extends BaseObject { private String asin; private String detailPageUrl; private BookAttributes itemAttributes; public Object getProperty(int index) { throw new RuntimeException(\"Book.getProperty is not implemented yet\"); } public int getPropertyCount() { return 3; } public void getPropertyInfo(int index, Hashtable properties, PropertyInfo info) { info.type = PropertyInfo.STRING_CLASS; switch (index) { case 0: info.name = \"ASIN\"; break; case 1: info.name = \"DetailPageURL\"; break; case 2: info.name = \"ItemAttributes\"; info.type = new BookAttributes().getClass(); default: break; } } public void setProperty(int index, Object value) { switch (index) { case 0: asin = value.toString(); break; case 1: detailPageUrl = value.toString(); break; case 2: itemAttributes = (BookAttributes) value; default: break; } } public String toString() { StringBuffer buffer = new StringBuffer(); buffer.append(\"ASIN: \"); buffer.append(asin); buffer.append(\"\\n\"); buffer.append(\"Detail page URL: \"); buffer.append(detailPageUrl); buffer.append(\"\\n\"); buffer.append(itemAttributes.toString()); return buffer.toString(); } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search.messages; import java.util.*; import org.ksoap2.serialization.*; public class BookAttributes extends BaseObject { private String author = \"\"; private String manufacturer; private String productGroup; private String title; private String creator; public Object getProperty(int index) { throw new RuntimeException(\"BookAttributes.getProperty is not implemented yet\"); } public int getPropertyCount() { return 5; } public void getPropertyInfo(int index, Hashtable properties, PropertyInfo info) { info.type = PropertyInfo.STRING_CLASS; switch (index) { case 0: info.name = \"Author\"; break; case 1: info.name = \"Manufacturer\"; break; case 2: info.name = \"ProductGroup\"; break; case 3: info.name = \"Title\"; break; case 4: info.name = \"Creator\"; break; default: break; } } public void setProperty(int index, Object value) { switch (index) { case 0: author += value.toString() + \";\"; break; case 1: manufacturer = value.toString(); break; case 2: productGroup = value.toString(); break; case 3: title = value.toString(); break; case 4: creator = value.toString(); default: break; } } public void register(SoapSerializationEnvelope envelope) { envelope.addMapping(NAMESPACE, \"ItemAttributes\", this.getClass()); } public String toString() { StringBuffer buffer = new StringBuffer(\"*** Attributes ***\\n\"); buffer.append(\"Author: \"); buffer.append(author); buffer.append(\"\\n\"); buffer.append(\"Manufacturer: \"); buffer.append(manufacturer); buffer.append(\"\\n\"); buffer.append(\"Product Group: \"); buffer.append(productGroup); buffer.append(\"\\n\"); buffer.append(\"Title: \"); buffer.append(title); buffer.append(\"\\n\"); if (creator != null) { buffer.append(\"Creator: \"); buffer.append(creator); buffer.append(\"\\n\"); } return buffer.toString(); } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search.messages; import java.util.*; import org.ksoap2.serialization.*; public class BookItems extends LiteralArrayVector { private String request; protected String getItemDescriptor() { return \"Item\"; } public Object getProperty(int index) { throw new RuntimeException(\"BookItems.getProperty is not implemented yet\"); } public int getPropertyCount() { return 4; } public void getPropertyInfo(int index, Hashtable properties, PropertyInfo info) { info.type = new SoapObject(BaseObject.NAMESPACE, \"\").getClass(); switch (index) { case 0: info.name = \"Request\"; break; case 1: info.name = \"TotalResults\"; break; case 2: info.name = \"TotalPages\"; break; case 3: super.getPropertyInfo(index, properties, info); default: break; } } public void setProperty(int index, Object value) { switch (index) { case 0: request = value.toString(); break; case 3: super.setProperty(index, value); default: break; } } protected Class getElementClass() { return new Book().getClass(); } public void register(SoapSerializationEnvelope envelope) { super.register(envelope, BaseObject.NAMESPACE, \"Items\"); } public synchronized String toString() { StringBuffer buffer = new StringBuffer(); buffer.append(\"Request: \"); buffer.append(request); buffer.append(\"\\n\"); for (int i = 0; i < size(); i++) { buffer.append(\"\\n=== BOOK ===\\n\"); buffer.append(elementAt(i).toString()); } return buffer.toString(); } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search.messages; import java.util.*; import org.ksoap2.serialization.*; public class ItemSearchResponse extends BaseObject { private BookItems bookItems; private String operationRequest; public Object getProperty(int index) { if (index == 0) { return bookItems; } else { return operationRequest; } } public int getPropertyCount() { return 2; } public void getPropertyInfo(int index, Hashtable properties, PropertyInfo info) { switch (index) { case 0: info.name = \"Items\"; info.type = new BookItems().getClass(); break; case 1: info.name = \"OperationRequest\"; info.type = new SoapObject(NAMESPACE, \"OperationRequest\").getClass(); default: break; } } public void setProperty(int index, Object value) { if (index == 0) { bookItems = (BookItems) value; } else { operationRequest = value.toString(); } } public void register(SoapSerializationEnvelope envelope) { envelope.addMapping(NAMESPACE, \"ItemSearchResponse\", this.getClass()); new BookItems().register(envelope); new BookAttributes().register(envelope); } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search.messages; import java.util.*; import org.ksoap2.serialization.*; public abstract class LiteralArrayVector extends Vector implements KvmSerializable { public void register(SoapSerializationEnvelope envelope, String namespace, String name) { "}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.amazon.search.messages; import java.util.*; import org.ksoap2.serialization.*; public class Request extends BaseObject { public String author; public String searchIndex; public Object getProperty(int index) { if(index == 0) { return author; } else { return searchIndex; } } public int getPropertyCount() { return 2; } public void getPropertyInfo(int index, Hashtable properties, PropertyInfo info) { info.type = PropertyInfo.STRING_CLASS; if(index == 0) { info.name = \"Author\"; } else { info.name = \"SearchIndex\"; } } public void setProperty(int index, Object value) { throw new RuntimeException(\"Request.setProperty is not implemented yet\"); } public void register(SoapSerializationEnvelope envelope) { envelope.addMapping(NAMESPACE, \"ItemSearchRequest\", this.getClass()); } }"}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.axis.quotes; import org.ksoap2.*; import org.ksoap2.serialization.*; import org.ksoap2.transport.*;  public class AxisStockQuoteExample { public AxisStockQuoteExample() { "}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.quotes; import javax.microedition.midlet.*; import javax.microedition.lcdui.*; import org.ksoap2.*; import org.ksoap2.serialization.*; import org.ksoap2.transport.*; public class StockQuoteDemo extends MIDlet implements CommandListener, Runnable { Form mainForm = new Form(\"StockQuotes\"); TextField symbolField = new TextField(\"Symbol\", \"IBM\", 5, TextField.ANY); StringItem resultItem = new StringItem(\"\", \"\"); Command getCommand = new Command(\"Get\", Command.SCREEN, 1); public StockQuoteDemo() { mainForm.append(symbolField); mainForm.append(resultItem); mainForm.addCommand(getCommand); mainForm.setCommandListener(this); } public void startApp() { Display.getDisplay(this).setCurrent(mainForm); } public void pauseApp() { } public void destroyApp(boolean unconditional) { } public void run(){ try { "}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.soccer; import java.util.*; import org.ksoap2.serialization.*; public abstract class LiteralArrayVector extends Vector implements KvmSerializable { public void register(SoapSerializationEnvelope envelope, String namespace, String name) { "}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.soccer; import org.ksoap2.serialization.*; public class StadiumNamesResult extends LiteralArrayVector { "}
{"name": "karlmdavis/ksoap2-android", "content": "package org.ksoap2.samples.soccer; import org.ksoap2.*; import org.ksoap2.serialization.*; import org.ksoap2.transport.*; public class WorldCupSoccer2006Client { private static final String SOAP_ACTION = \"\"; private static final String METHOD_NAME = \"StadiumNames\"; private static final String NAMESPACE = \"http:"}
{"name": "karlmdavis/ksoap2-android", "content": " package org.ksoap2.servlet; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.StringWriter; import java.io.Writer; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.Hashtable; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.ksoap2.SoapFault; import org.ksoap2.serialization.PropertyInfo; import org.ksoap2.serialization.SoapObject; import org.ksoap2.serialization.SoapSerializationEnvelope; import org.kxml2.io.KXmlParser; import org.kxml2.io.KXmlSerializer; import org.xmlpull.v1.XmlPullParser; import org.xmlpull.v1.XmlSerializer;  public class SoapServlet extends HttpServlet { SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapSerializationEnvelope.VER12);  Hashtable instanceMap = new Hashtable();  protected Object getInstance(HttpServletRequest request) { if (request.getPathInfo() == null) return this; Object result = instanceMap.get(request.getPathInfo()); return (result != null) ? result : this; }  public void publishClass(Class service, String namespace) { Method[] methods = service.getMethods(); for (int i = 0; i < methods.length; i++) { if (Modifier.isPublic(methods[i].getModifiers())) { Class[] types = methods[i].getParameterTypes(); PropertyInfo[] info = new PropertyInfo[types.length]; for (int j = 0; j < types.length; j++) { info[j] = new PropertyInfo(); info[j].type = types[j]; } publishMethod(service, namespace, methods[i].getName(), info); } } }  public void publishInstance(String path, Object instance) { instanceMap.put(path, instance); }  public void publishMethod(Class service, String namespace, String name, PropertyInfo[] parameters) { SoapObject template = new SoapObject(namespace, name); for (int i = 0; i < parameters.length; i++) template.addProperty(parameters[i], null); envelope.addTemplate(template); }  public void publishMethod(Class service, String namespace, String name, String[] parameterNames) { "}
{"name": "jakewharton/smsbarrage", "content": "package android.provider; import java.util.regex.Matcher; import java.util.regex.Pattern; import android.text.TextUtils; import android.text.util.Regex; public class Telephony { public static final class Mms { public static final Pattern NAME_ADDR_EMAIL_PATTERN = Pattern.compile(\"\\\\s*(\\\"[^\\\"]*\\\"|[^<>\\\"]+)\\\\s*<([^<>]+)>\\\\s*\"); public static boolean isEmailAddress(String address) { if (TextUtils.isEmpty(address)) { return false; } String s = extractAddrSpec(address); Matcher match = Regex.EMAIL_ADDRESS_PATTERN.matcher(s); return match.matches(); } public static String extractAddrSpec(String address) { Matcher match = NAME_ADDR_EMAIL_PATTERN.matcher(address); if (match.matches()) { return match.group(2); } return address; } } }"}
{"name": "jakewharton/smsbarrage", "content": "/* * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jakewharton/smsbarrage", "content": "/* * Copyright (C) 2006 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jakewharton/smsbarrage", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jakewharton/smsbarrage", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jakewharton/smsbarrage", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jakewharton/smsbarrage", "content": "/* * Copyright (C) 2008 Esmertec AG. * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage; import android.app.Application; import android.preference.PreferenceManager; public class SMSBarrage extends Application { private static final String TAG = \"SMSBarrage\"; @Override public void onCreate() { PreferenceManager.setDefaultValues(this, R.xml.preferences, false); } } /*public class SMSBarrage extends Activity { private static final int PROGRESS_OFFSET = 2; private static final String TAG = \"SMSBarrage\"; private static final String AGREED = \"AGREED\"; "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.provider; import com.google.android.mms.util.SqliteWrapper; import android.content.ContentResolver; import android.content.ContentValues; import android.content.Context; import android.database.Cursor; import android.net.Uri; import android.provider.BaseColumns; public class BarrageProvider { private static final String TAG = \"BarrageProvider\"; "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.transaction; import static android.content.Intent.ACTION_BOOT_COMPLETED; import android.app.Service; import android.content.Intent; import android.os.Handler; import android.os.HandlerThread; import android.os.IBinder; import android.os.Looper; import android.os.Message; import android.os.Process; import android.telephony.gsm.SmsManager; public class BarrageService extends Service { private static final String TAG=\"BarrageService\"; private ServiceHandler mServiceHandler; private Looper mServiceLooper; private final Object mLock = new Object(); private SmsManager mSmsManager; @Override public void onCreate() { HandlerThread thread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); mSmsManager = SmsManager.getDefault(); } @Override public IBinder onBind(Intent arg0) { return null; } @Override public void onDestroy() { mServiceLooper.quit(); } private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { final int serviceId = msg.arg1; final Intent intent = (Intent)msg.obj; final String action = intent.getAction(); if (action.equals(ACTION_BOOT_COMPLETED)) { handleBootCompleted(); } EventReceiver.finishStartingService(BarrageService.this, serviceId); } } public void handleBootCompleted() { } protected void enqueueMessages(String[] numbers, String message, int count) { for (int i = 0; i < count; i++) { for (int j = 0; j < numbers.length; j++) { "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.transaction; import com.jakewharton.smsbarrage.R; import android.app.Service; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.SharedPreferences; import android.os.PowerManager; import android.preference.PreferenceManager; public class EventReceiver extends BroadcastReceiver { private static final String TAG = \"EventReceiver\"; "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; import android.app.Activity; public class About extends Activity { }"}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; public class BarrageHeader { private static final String TAG=\"BarrageHeader\"; public static final int STATUS_RUNNING = 0; public static final int STATUS_DRAFT = 1; public static final int STATUS_QUEUED = 2; public static final int STATUS_PAUSED = 3; private int mID; private String mName; private int mStatus; private int mCountTotal; private int mCountCurrent; public BarrageHeader() {} public BarrageHeader(String name, int status, int total, int current) { mName = name; mStatus = status; mCountTotal = total; mCountCurrent = current; } public int getID() { return mID; } public String getName() { return mName; } public void setName(String name) { mName = name; } public int getStatus() { return mStatus; } public void setStatus(int status) { "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; import com.jakewharton.smsbarrage.R; import android.content.Context; import android.graphics.Color; import android.util.AttributeSet; import android.widget.ProgressBar; import android.widget.RelativeLayout; import android.widget.TextView; public class BarrageHeaderView extends RelativeLayout { private static final String TAG=\"BarrageHeaderView\"; private BarrageHeader mBarrageHeader; private TextView mName; private TextView mStatus; private TextView mCounts; private TextView mPercent; private ProgressBar mProgress; public BarrageHeaderView(Context context) { super(context); } public BarrageHeaderView(Context context, AttributeSet attrs) { super(context, attrs); } @Override protected void onFinishInflate() { super.onFinishInflate(); mName = (TextView)findViewById(R.id.name); mStatus = (TextView)findViewById(R.id.status); mCounts = (TextView)findViewById(R.id.counts); mPercent = (TextView)findViewById(R.id.percent); mProgress = (ProgressBar)findViewById(R.id.progress); } public void bind(String name, String counts) { mName.setText(name); mStatus.setVisibility(INVISIBLE); mCounts.setText(counts); mProgress.setVisibility(INVISIBLE); mPercent.setVisibility(INVISIBLE); } public void bind(Context context, BarrageHeader header) { mBarrageHeader = header; mName.setText(header.getName()); switch (header.getStatus()) { case BarrageHeader.STATUS_RUNNING: mStatus.setTextColor(Color.GREEN); mStatus.setText(\"Running\"); updateProgress(header.getCountCurrent(), header.getCountTotal()); break; case BarrageHeader.STATUS_PAUSED: mStatus.setTextColor(Color.YELLOW); mStatus.setText(\"Paused\"); updateProgress(header.getCountCurrent(), header.getCountTotal()); break; case BarrageHeader.STATUS_QUEUED: mStatus.setTextColor(Color.GRAY); mStatus.setText(\"Queued\"); "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; import com.jakewharton.smsbarrage.R; import android.app.AlertDialog; import android.app.ListActivity; import android.content.DialogInterface; import android.content.Intent; import android.content.DialogInterface.OnClickListener; import android.database.Cursor; import android.os.Bundle; import android.view.ContextMenu; import android.view.LayoutInflater; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.view.ContextMenu.ContextMenuInfo; import android.widget.ListView; public class BarrageList extends ListActivity { private static final String TAG=\"BarrageList\"; "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; import android.content.Context; import android.database.Cursor; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.CursorAdapter; public class BarrageListAdapter extends CursorAdapter { private static final String TAG = \"BarrageListAdapter\"; private static final String[] PROJECTION = new String[] { }; private boolean mSimple; private LayoutInflater mFactory; public BarrageListAdapter(Context context, Cursor cursor, boolean simple) { super(context, cursor); mSimple = simple; mFactory = LayoutInflater.from(context); } @Override public void bindView(View view, Context context, Cursor cursor) { if (view instanceof BarrageHeaderView) { "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; import com.android.mms.ui.RecipientsAdapter; import com.android.mms.ui.RecipientsEditor; import com.jakewharton.smsbarrage.R; import android.app.Activity; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.widget.Button; import android.widget.EditText; public class Compose extends Activity { private static final String TAG = \"ComposeBarrage\"; "}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; import com.jakewharton.smsbarrage.R; import android.os.Bundle; import android.preference.PreferenceActivity; import android.preference.PreferenceManager; import android.view.Menu; import android.view.MenuItem; public class Preferences extends PreferenceActivity { private static final int MENU_RESTORE_DEFAULTS = 0; public void onCreate(Bundle icicle) { super.onCreate(icicle); addPreferencesFromResource(R.xml.preferences); } @Override public boolean onCreateOptionsMenu(Menu menu) { super.onCreateOptionsMenu(menu); menu.clear(); menu.add(0, MENU_RESTORE_DEFAULTS, 0, R.string.menu_restore_defaults); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case MENU_RESTORE_DEFAULTS: restoreDefaultPreferences(); return true; } return false; } private void restoreDefaultPreferences() { PreferenceManager.getDefaultSharedPreferences(this).edit().clear().commit(); setPreferenceScreen(null); addPreferencesFromResource(R.xml.preferences); } }"}
{"name": "jakewharton/smsbarrage", "content": "package com.jakewharton.smsbarrage.ui; import android.app.Activity; public class ViewBarrage extends Activity { }"}
{"name": "jabley/rate-limit", "content": " package com.eternus.ratelimit; import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock;  public class CoarseMemoryTokenStore implements TokenStore {  private final Map<Key, StoreEntry> cache;  private final Lock lock;  public CoarseMemoryTokenStore() { this.cache = new HashMap<Key, StoreEntry>(); this.lock = new ReentrantLock(); }  public StoreEntry create(Key key, int timeToLiveInSecs) { try { StoreEntryImpl result = new StoreEntryImpl(timeToLiveInSecs); cache.put(key, result); return result; } finally { lock.unlock(); } }  public StoreEntry get(Key key) { lock.lock(); StoreEntry result = cache.get(key); if (!(result == null || result.isExpired())) {  lock.unlock(); return result; } else {  result = null; cache.put(key, result); } return result; } }"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": " package com.eternus.ratelimit.circuitbreaker;  public interface CircuitBreakerListener {  void attemptReset();  void reset();  void tripped(); }"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "jabley/rate-limit", "content": "/* * Copyright 2009 James Abley * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.*; import io.netty.channel.group.ChannelGroup; import io.netty.channel.group.ChannelGroupFuture; import io.netty.channel.group.DefaultChannelGroup; import io.netty.util.concurrent.GenericFutureListener; import io.netty.util.concurrent.GlobalEventExecutor;  public class AspenServer { private static final ChannelGroup ALL_CHANNELS = new DefaultChannelGroup(\"Aspen\", GlobalEventExecutor.INSTANCE); private Boolean running; private final ServerBootstrap bootstrap; private final ServerBootstrapFactory bootstrapFactory = new ServerBootstrapFactory();  public AspenServer( final String host, final int port, final RackProxy rack ) { running = false; bootstrap = bootstrapFactory.newServerBootstrap(0); bootstrap.localAddress(host, port) .option(ChannelOption.SO_BACKLOG, 1024) .childOption(ChannelOption.TCP_NODELAY, true) .childOption(ChannelOption.SO_KEEPALIVE, true) .childHandler(new RackHttpServerChannelInitializer(rack)); }  public void start() { if( isRunning() ) { System.err.println( \"Unable to start - already running\" ); return; } try { ChannelFuture boundFuture = bootstrap.bind(); running = true; boundFuture.addListener( (GenericFutureListener<ChannelFuture>) future -> ALL_CHANNELS.add(future.channel())); boundFuture.awaitUninterruptibly(); } catch( Exception e ) { System.err.println( \"error starting Netty channel\" ); e.printStackTrace( System.err ); } } public void awaitShutdown() { Runtime.getRuntime().addShutdownHook(new AspenServerShutdownHook(this)); boolean interrupted = false; do { try { Thread.sleep(300); } catch (InterruptedException e) { interrupted = true; } } while (!interrupted); }  @SuppressWarnings({\"ThrowableInstanceNeverThrown\"}) public void stop() { if( isRunning() ) { try { running = false; ChannelGroupFuture allFuture = ALL_CHANNELS.close(); bootstrapFactory.shutdownGracefully(false); allFuture.awaitUninterruptibly(); } catch( Exception e ) { System.err.println( \"error stopping Netty channels\" ); e.printStackTrace( System.err ); } } else { System.err.println( \"stop called when server not running\" ); throw new RuntimeException( \"cannot stop, not running\" ); } }  public boolean isRunning() { return running; } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; public class AspenServerShutdownHook extends Thread { private final AspenServer server; public AspenServerShutdownHook(final AspenServer server) { super(); this.server = server; } @Override public void run() { server.stop(); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import com.github.kevwil.aspen.domain.*; import com.github.kevwil.aspen.exception.InvalidAppException; import com.github.kevwil.aspen.exception.ServiceException; import io.netty.buffer.ByteBuf; import org.jruby.*; import org.jruby.runtime.*; import org.jruby.runtime.builtin.IRubyObject; import java.nio.charset.StandardCharsets;  public class JRubyRackProxy implements RackProxy { private final IRubyObject app; private static final Object LOCK = new Object(); public JRubyRackProxy( final IRubyObject app ) { this.app = app; } public Ruby getRuntime() { synchronized(LOCK) { return app.getRuntime(); } } @Override public Response process( final Request request ) { synchronized(LOCK) { if( ! app.respondsTo( \"call\" ) ) { throw new InvalidAppException(); } RubyHash env = request.getEnv().toRuby(); IRubyObject[] args = { env }; IRubyObject callResult = app.callMethod( request.getRuntime().getCurrentContext(), \"call\", args, Block.NULL_BLOCK ); if( callResult.isNil() ) { Response err = new Response(); err.setException( new ServiceException( \"'nil' was returned from the app\" ) ); return err; } if( callResult.getType().toString().equals( \"Rack::File\" ) ) { System.out.println( callResult.inspect() ); "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import com.github.kevwil.aspen.domain.*; import com.github.kevwil.aspen.exception.ServiceException; import io.netty.channel.*; import io.netty.handler.codec.http.FullHttpRequest; import io.netty.handler.codec.http.HttpResponseStatus; import io.netty.util.AttributeKey;  public class RackChannelInboundHandler extends SimpleChannelInboundHandler<FullHttpRequest> { private static final AttributeKey<MessageContext> CONTEXT_KEY = AttributeKey.valueOf(\"context\"); private final RackProxy rack; private final HttpResponseWriter responseWriter; private final HttpResponseWriter errorWriter; public RackChannelInboundHandler(final RackProxy rackProxy ) { super(); rack = rackProxy; responseWriter = new DefaultResponseWriter(); errorWriter = new ErrorResponseWriter(); } private void writeResponse( final ChannelHandlerContext ctx, final Request request, final Response response ) { responseWriter.write( ctx, request, response ); } private void writeError( final ChannelHandlerContext ctx, final Request request, final Response response ) { errorWriter.write( ctx, request, response ); } "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import org.jruby.RubyHash; import java.io.InputStream;  public interface RackEnvironment { InputStream getInput(); int getContentLength(); RackInput getRackInput(); void setRackInput( RackInput input ); RubyHash toRuby(); }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import org.jruby.runtime.ThreadContext; import org.jruby.runtime.builtin.IRubyObject;  public interface RackErrors {  IRubyObject puts( ThreadContext context, IRubyObject arg );  IRubyObject write( ThreadContext context, IRubyObject string );  IRubyObject flush();  IRubyObject close(); }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import io.netty.channel.*; import io.netty.handler.codec.http.*; import io.netty.handler.stream.ChunkedWriteHandler;  public class RackHttpServerChannelInitializer extends ChannelInitializer<Channel> { private final RackProxy rack; private final boolean compressionEnabled; "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import org.jruby.runtime.Block; import org.jruby.runtime.ThreadContext; import org.jruby.runtime.builtin.IRubyObject;  public interface RackInput {  IRubyObject gets( ThreadContext context );  IRubyObject read( ThreadContext context, IRubyObject[] args );  IRubyObject each( ThreadContext context, Block block );  IRubyObject rewind( ThreadContext context );  void close(); }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import com.github.kevwil.aspen.domain.Request; import com.github.kevwil.aspen.domain.Response; import org.jruby.Ruby;  public interface RackProxy {  Response process( Request request ); "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import io.netty.buffer.ByteBufAllocator; import io.netty.channel.*; import io.netty.channel.socket.ServerSocketChannel; import io.netty.channel.socket.ServerSocketChannelConfig; import io.netty.handler.codec.http.*; import io.netty.util.Attribute; import io.netty.util.AttributeKey; import io.netty.util.concurrent.EventExecutor; import org.jruby.RubyHash; import java.net.*; import java.util.regex.Pattern; import java.util.regex.Matcher;  public final class RackUtil { private RackUtil(){} public static ChannelHandlerContext buildDummyChannelHandlerContext( final String server, final String port ) { int p = 80; if( port != null && !port.isEmpty()) { try { p = Integer.parseInt( port ); } catch( Exception e ) { e.printStackTrace(System.err); "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import org.jruby.*; import org.jruby.runtime.*; import org.jruby.runtime.builtin.IRubyObject; import java.io.ByteArrayInputStream; import java.io.InputStream; import java.nio.channels.Channels; import java.nio.charset.StandardCharsets;  public class RubyUtil { private static final Ruby RUNTIME = Ruby.getGlobalRuntime(); private RubyUtil(){} public static int toInt( final IRubyObject obj ) { return obj.convertToInteger().toJava( Integer.class ); } public static IRubyObject call( final String method, final IRubyObject target ) { return target.callMethod( target.getRuntime().getCurrentContext(), method ); } public static IRubyObject hashGet( final RubyHash hash, final IRubyObject key ) { return hash.op_aref( hash.getRuntime().getCurrentContext(), key ); } public static void hashDelete( final RubyHash hash, final IRubyObject key ) { hash.delete( hash.getRuntime().getCurrentContext(), key, Block.NULL_BLOCK ); } public static RubyIO stringToIO( final String input ) { InputStream dataStream = new ByteArrayInputStream( input.getBytes( StandardCharsets.UTF_8 ) ); return RubyIO.newIO(RUNTIME, Channels.newChannel( dataStream ) ); } public static void trimEmptyValues( RubyHash env ) { for( IRubyObject key : env.keys().toJavaArray() ) { IRubyObject value = hashGet( env, key ); if( value.isNil() || value.toString().isEmpty() ) { hashDelete( env, key ); } } } public static ByteBuf bodyToBuffer(final IRubyObject body ) { return Unpooled.copiedBuffer(body.toString(), StandardCharsets.UTF_8); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.EventLoopGroup; import io.netty.channel.epoll.Epoll; import io.netty.channel.epoll.EpollEventLoopGroup; import io.netty.channel.epoll.EpollServerSocketChannel; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.util.concurrent.Future; public class ServerBootstrapFactory { private EventLoopGroup bossGroup; private EventLoopGroup workerGroup; public ServerBootstrap newServerBootstrap(int ioThreadCount) { if (Epoll.isAvailable()) { return newEpollServerBootstrap(ioThreadCount); } return newNioServerBootstrap(ioThreadCount); } public void shutdownGracefully(boolean shouldWait) { Future<?> workerFuture = workerGroup.shutdownGracefully(); Future<?> bossFuture = bossGroup.shutdownGracefully(); if (shouldWait) { workerFuture.awaitUninterruptibly(); bossFuture.awaitUninterruptibly(); } } private ServerBootstrap newEpollServerBootstrap(int ioThreadCount) { if (ioThreadCount > 0) { bossGroup = new EpollEventLoopGroup(ioThreadCount); workerGroup = new EpollEventLoopGroup(ioThreadCount); } else { bossGroup = new EpollEventLoopGroup(); workerGroup = new EpollEventLoopGroup(); } return new ServerBootstrap() .group(bossGroup, workerGroup) .channel(EpollServerSocketChannel.class); } private ServerBootstrap newNioServerBootstrap(int ioThreadCount) { if (ioThreadCount > 0) { bossGroup = new NioEventLoopGroup(ioThreadCount); workerGroup = new NioEventLoopGroup(ioThreadCount); } else { bossGroup = new NioEventLoopGroup(); workerGroup = new NioEventLoopGroup(); } return new ServerBootstrap() .group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen; import org.jruby.Ruby; import org.jruby.RubyArray; import org.jruby.runtime.builtin.IRubyObject; import java.util.*;  public class Version { public static final int MAJOR = 1; public static final int MINOR = 0; public static final int TINY = 0; public static final String ASPEN = versionString(); public static final RubyArray RACK = createVersionArray(); private Version(){} private static RubyArray createVersionArray() { RubyArray array = RubyArray.newArray( Ruby.getGlobalRuntime() ); array.add( 1 ); array.add( 1 ); return array; } private static String versionString() { return join( Arrays.asList( Integer.toString( MAJOR ), Integer.toString( MINOR ), Integer.toString( TINY ) ), \".\" ); } private static String join( Collection<String> s, String delimiter ) { Iterator<String> iterator = s.iterator(); StringBuffer buffer = new StringBuffer( iterator.next() ); while( iterator.hasNext() ) { buffer.append( delimiter ).append( iterator.next() ); } return buffer.toString(); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import com.github.kevwil.aspen.*; import com.github.kevwil.aspen.io.RubyIORackErrors; import com.github.kevwil.aspen.io.RubyIORackInput; import io.netty.buffer.ByteBufInputStream; import io.netty.handler.codec.http.HttpHeaderNames; import org.jruby.*; import java.io.*; import java.net.*;  @SuppressWarnings(\"unchecked\") public class DefaultRackEnvironment implements RackEnvironment { private final Ruby runtime; private final Request request; private RackInput input; private final InputStream stream; public DefaultRackEnvironment( final Ruby runtime, final Request request ) { this.runtime = runtime; this.request = request; this.stream = new ByteBufInputStream( this.request.getBody() ); RubyIORackInput input = new RubyIORackInput(this.runtime); input.setBuffer( this.request.getBody() ); setRackInput( input ); } private RubyHash createRubyHash( final Request request ) { RubyHash env = request.getRubyHeaders(); assignConnectionRelatedCgiHeaders( env, request ); tweakCgiVariables( env, request.getUri() ); updateEnv( env, request ); return env; } void updateEnv( final RubyHash env, final Request request ) { env.put( \"rack.version\", Version.RACK ); env.put( \"rack.input\", getRackInput() ); env.put( \"rack.errors\", new RubyIORackErrors(runtime) ); env.put( \"rack.multithread\", true ); env.put( \"rack.multiprocess\", false ); env.put( \"rack.run_once\", false ); "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandlerContext; import io.netty.handler.codec.http.*; import java.nio.charset.StandardCharsets;  public class DefaultResponseWriter extends HttpResponseWriterBase { @Override public void write( final ChannelHandlerContext context, final Request request, final Response response ) { FullHttpResponse httpResponse = createHttpResponse( response ); addHeaders( response, httpResponse ); if( response.hasBody() ) { ByteBuf buf = Unpooled.copiedBuffer(response.getBody().toString() + \"\\r\\n\", StandardCharsets.UTF_8); httpResponse.replace(buf); } if( request.isKeepAlive() ) { httpResponse.headers().set( HttpHeaderNames.CONTENT_LENGTH, String.valueOf( httpResponse.content().readableBytes() ) ); context.channel().write( httpResponse ).addListener( ChannelFutureListener.CLOSE_ON_FAILURE ); } else { httpResponse.headers().set( HttpHeaderNames.CONNECTION, \"close\" ); context.channel().write( httpResponse ).addListener( ChannelFutureListener.CLOSE ); } } private void addHeaders( final Response response, final HttpResponse httpResponse ) { for( String name : response.getHeaderNames() ) { for( String value : response.getHeaders( name ) ) { httpResponse.headers().add( name, value ); } } } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandlerContext; import io.netty.handler.codec.http.*; import java.io.PrintWriter; import java.io.StringWriter; import java.nio.charset.StandardCharsets;  public class ErrorResponseWriter extends HttpResponseWriterBase { @SuppressWarnings( { \"ThrowableResultOfMethodCallIgnored\" } ) @Override public void write( final ChannelHandlerContext context, final Request request, final Response response ) { FullHttpResponse httpResponse = createHttpResponse( response ); httpResponse.headers().set( HttpHeaderNames.CONTENT_TYPE, \"text/plain; charset=UTF-8\" ); StringWriter builder =new StringWriter(); response.getException().printStackTrace( new PrintWriter( builder ) ); "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import io.netty.channel.ChannelHandlerContext;  public interface HttpResponseWriter { void write( ChannelHandlerContext context, Request request, Response response ); }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import io.netty.handler.codec.http.*;  public abstract class HttpResponseWriterBase implements HttpResponseWriter { public FullHttpResponse createHttpResponse( Response response ) { return new DefaultFullHttpResponse( HttpVersion.HTTP_1_1, response.getResponseStatus() ); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import io.netty.handler.codec.http.HttpResponseStatus; public class MessageContext { private Request request; private Response response; public MessageContext(Request request, Response response) { super(); this.request = request; this.response = response; } public Request getRequest() { return request; } public Response getResponse() { return response; } public Throwable getException() { return getResponse().getException(); } public void setException(Throwable throwable) { getResponse().setException(throwable); } public void setHttpStatus(HttpResponseStatus httpStatus) { getResponse().setResponseStatus(httpStatus); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import com.github.kevwil.aspen.RackEnvironment; import com.github.kevwil.aspen.RackUtil; import com.github.kevwil.aspen.exception.ServiceException; import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelHandlerContext; import io.netty.handler.codec.http.*; import org.jruby.Ruby; import org.jruby.RubyHash; import java.io.IOException; import java.net.*; import java.nio.charset.StandardCharsets; import java.util.HashMap; import java.util.Map;  public class Request { public static final String METHOD_OVERRIDE_PARAMETER = \"_method\"; public static final String METHOD_OVERRIDE_HEADER = \"X-Http-Method-Override\"; private final ChannelHandlerContext context; private FullHttpRequest request; private HttpMethod realMethod; private URL url; private String uri; private RubyHash rubyHeaders; private final Ruby runtime; private static final Object LOCK = new Object(); public Request(final ChannelHandlerContext context, final FullHttpRequest request, final Ruby runtime ) { this.context = context; this.request = request; this.runtime = runtime; initialize(); } private void initialize() { this.uri = request.uri(); this.realMethod = parseRealMethod( parseQueryStringParams() ); this.url = parseUrl(); this.rubyHeaders = RubyHash.newHash(runtime); RackUtil.parseHeaders(context, request, rubyHeaders); } public Ruby getRuntime() { synchronized(LOCK) { return runtime; } } public URL getUrl() { return url; } public RubyHash getRubyHeaders() { return rubyHeaders; } public FullHttpRequest getHttpRequest() { return request; } public RackEnvironment getEnv() { synchronized(LOCK) { return new DefaultRackEnvironment(runtime, this ); } } public HttpMethod getMethod() { return request.method(); } public HttpMethod getRealMethod() { return realMethod; } public ByteBuf getBody() { return request.content(); } public String getBodyString() { return getBody().toString( StandardCharsets.UTF_8 ); } public void setBody( ByteBuf body ) { request = request.replace(body); } public boolean containsHeader( String name ) { return request.headers().contains( name ); } public String getHeader( String name ) { return request.headers().get( name ); } public String getUri() { return uri; } public SocketAddress getRemoteAddress() { return context.channel().remoteAddress(); } public SocketAddress getLocalAddress() { return context.channel().localAddress(); } public boolean isKeepAlive() { return HttpUtil.isKeepAlive(request); } private URL parseUrl() { try { return new URI(uri).toURL(); } catch (IllegalArgumentException | MalformedURLException | URISyntaxException e) { "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.domain; import com.github.kevwil.aspen.RubyUtil; import io.netty.handler.codec.http.HttpResponseStatus; import org.jruby.RubyHash; import org.jruby.runtime.builtin.IRubyObject; import java.util.*;  public class Response { private HttpResponseStatus statusCode = HttpResponseStatus.OK; private Throwable exception = null; private Object body; private final Map<String,List<String>> headers = new HashMap<>(); public Response() { super(); } public Object getBody() { return body; } public void setBody( Object body ) { this.body = body; } public boolean hasBody() { return ( getBody() != null ); } "}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.exception;  public class InvalidAppException extends RuntimeException { private static final String DEFAULT_MESSAGE = \"Invalid Application Signature\"; public InvalidAppException() { this( DEFAULT_MESSAGE ); } public InvalidAppException( final String s ) { super( s ); } public InvalidAppException( final String s, final Throwable throwable ) { super( s, throwable ); } public InvalidAppException( final Throwable throwable ) { this( DEFAULT_MESSAGE, throwable ); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.exception; import io.netty.handler.codec.http.HttpResponseStatus;  public class ServiceException extends RuntimeException { private static final HttpResponseStatus STATUS = HttpResponseStatus.INTERNAL_SERVER_ERROR; private HttpResponseStatus status; public ServiceException() { super(); setStatus( STATUS ); } public ServiceException( final HttpResponseStatus status ) { super(); setStatus( status ); } public ServiceException( final String message ) { this( message, STATUS ); } protected ServiceException( final String message, final HttpResponseStatus status ) { super( message ); setStatus( status ); } public ServiceException( final String message, final Throwable throwable ) { this( message, throwable, STATUS ); } protected ServiceException( final String message, final Throwable throwable, final HttpResponseStatus status ) { super( message, throwable ); setStatus( status ); } public ServiceException( final Throwable throwable ) { this( throwable, STATUS ); } protected ServiceException( final Throwable throwable, final HttpResponseStatus status ) { super( throwable ); setStatus( status ); } public HttpResponseStatus getStatus() { return status; } public void setStatus( final HttpResponseStatus status ) { this.status = status; } public static boolean isAssignableFrom(Throwable exception) { return ServiceException.class.isAssignableFrom(exception.getClass()); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.io; import com.github.kevwil.aspen.RackErrors; import org.jruby.*; import org.jruby.anno.JRubyClass; import org.jruby.anno.JRubyMethod; import org.jruby.runtime.ThreadContext; import org.jruby.runtime.builtin.IRubyObject;  @JRubyClass(name = \"AspenRackErrors\") public class RubyIORackErrors extends RubyObject implements RackErrors { public static RubyClass createRubyIORackErrors(Ruby runtime) { RubyClass myClass = runtime.defineClass(\"AspenRackErrors\", runtime.getObject(), RubyIORackErrors::new); myClass.setReifiedClass(RubyIORackErrors.class); myClass.defineAnnotatedMethods(RubyIORackErrors.class); return myClass; } public RubyIORackErrors(Ruby runtime) { super(runtime, RubyIORackErrors.createRubyIORackErrors(runtime)); } public RubyIORackErrors( Ruby runtime, RubyClass metaClass ) { super( runtime, metaClass ); } @JRubyMethod( required = 1 ) public IRubyObject puts( final ThreadContext context, final IRubyObject args ) { System.err.println( args.toString() ); return getRuntime().getNil(); } @JRubyMethod() public IRubyObject write( final ThreadContext context, final IRubyObject string ) { System.err.println( string.toString() ); return getRuntime().getNil(); } @JRubyMethod() public IRubyObject flush() { System.err.flush(); return getRuntime().getNil(); } @JRubyMethod() public IRubyObject close() { throw getRuntime().newIOError( \"Rack spec prohibits calling close() on rack.errors stream.\" ); } }"}
{"name": "kevwil/aspen", "content": "package com.github.kevwil.aspen.io; import com.github.kevwil.aspen.RackInput; import io.netty.buffer.ByteBuf; import io.netty.buffer.ByteBufInputStream; import org.jruby.*; import org.jruby.anno.JRubyClass; import org.jruby.anno.JRubyMethod; import org.jruby.javasupport.JavaEmbedUtils; import org.jruby.runtime.*; import org.jruby.runtime.builtin.IRubyObject; import java.io.IOException; import java.util.concurrent.atomic.AtomicReference;  @JRubyClass(name = \"AspenRackInput\") public class RubyIORackInput extends RubyObject implements RackInput { public static RubyClass createRackInputClass(Ruby runtime) { RubyClass myClass = runtime.defineClass(\"AspenRackInput\", runtime.getObject(), RubyIORackInput::new); myClass.setReifiedClass(RubyIORackInput.class); myClass.defineAnnotatedMethods(RubyIORackInput.class); return myClass; } public RubyIORackInput(Ruby runtime) { super(runtime, RubyIORackInput.createRackInputClass(runtime)); } public RubyIORackInput( Ruby runtime, RubyClass metaClass ) { super( runtime, metaClass ); }  private ByteBuf buffer; public ByteBuf getBuffer() { return buffer; } public void setBuffer( final ByteBuf buffer ) { this.buffer = buffer; }  @JRubyMethod() public IRubyObject gets( final ThreadContext context ) { try { String line = readLine( getBuffer() ); if( line.isEmpty() ) { throw getRuntime().newEOFError(); } return JavaEmbedUtils.javaToRuby( getRuntime(), line ); } catch( IOException e ) { throw getRuntime().newIOError( e.getLocalizedMessage() ); } } @JRubyMethod( optional = 2 ) public IRubyObject read( final ThreadContext context, final IRubyObject[] args ) { int len; ByteBuf chunk; switch( args.length ) { case 0: return JavaEmbedUtils.javaToRuby( getRuntime(), bufferToString( getBuffer() ) ); case 1: len = RubyInteger.num2int( args[0] ); if( len > getBuffer().readableBytes() ) { throw getRuntime().newIOError( \"cannot read \" + len + \" bytes from input\" ); } chunk = getBuffer().readBytes( len ); return JavaEmbedUtils.javaToRuby( getRuntime(), bufferToString( chunk ) ); case 2: len = RubyInteger.num2int( args[0] ); chunk = getBuffer().readBytes( len ); RubyString buf = RubyString.stringValue( args[1] ); buf.append( JavaEmbedUtils.javaToRuby( getRuntime(), bufferToString( chunk ) ) ); return getRuntime().getNil(); default: throw getRuntime().newArgumentError( \"wrong number of arguments: \" + args.length ); } } @JRubyMethod() public IRubyObject each( final ThreadContext context, final Block block ) { try (ByteBufInputStream stream = new ByteBufInputStream(getBuffer().slice())) { AtomicReference<String> line = new AtomicReference<>(); if (!isEof().isTrue()) { try { do { line.set(stream.readLine()); block.yield(context, JavaEmbedUtils.javaToRuby(getRuntime(), line.get())); } while (line.get() != null && stream.available() > 0); } catch (IOException e) { throw getRuntime().newIOError(e.getLocalizedMessage()); } } } catch (IOException e) { throw new RuntimeException(e); } return getRuntime().getNil(); } @JRubyMethod() public IRubyObject rewind( final ThreadContext context ) { getBuffer().readerIndex( 0 ); return getRuntime().getNil(); } @JRubyMethod( name = \"eof?\" ) public IRubyObject isEof() { return getRuntime().newBoolean( ! getBuffer().isReadable() ); } @JRubyMethod( name = \"binmode\" ) public IRubyObject getBinmode() { return getRuntime().newBoolean( true ); } @JRubyMethod() public void close() { throw getRuntime().newIOError( \"Rack spec prohibits calling close() on rack.input stream.\" ); } private String readLine( final ByteBuf buf ) throws IOException { int startIndex = buf.readerIndex(); String line; try (ByteBufInputStream stream = new ByteBufInputStream(buf.slice())) { line = stream.readLine(); } int newIndex = startIndex + line.length(); buf.readerIndex( newIndex ); return line; } private String bufferToString( ByteBuf buffer ) { byte[] dest = new byte[buffer.readableBytes()]; buffer.readBytes( dest ); return new String( dest ); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.args; import java.util.Dictionary; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.MultiStatus; import org.eclipse.core.runtime.Status; import org.eclipse.jface.resource.ImageRegistry; import org.eclipse.ui.plugin.AbstractUIPlugin; import org.osgi.framework.BundleContext; import org.osgi.framework.Constants; public class ArgsPlugin extends AbstractUIPlugin { private static ArgsPlugin plugin; public ArgsPlugin() { ArgsPlugin.plugin = this; }  public void start(BundleContext bundleContext) throws Exception { super.start(bundleContext); }  public void stop(BundleContext bundleContext) throws Exception { super.stop(bundleContext); } protected void initializeImageRegistry(ImageRegistry reg) { reg.put(\"over_error\", imageDescriptorFromPlugin(getID(), \"icon/ovr16/error.gif\")); } public static ArgsPlugin getPlugin() { return plugin; } public void logSystemError(Exception ex, Object caller) { IStatus status = createSystemErrorStatus(ex, caller); getLog().log(status); } public IStatus createSystemErrorStatus(Exception ex, Object caller) { int severity = IStatus.ERROR; String message; message = ex.getMessage(); if (message == null) message = \"\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.args; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IConfigurationElement; import org.eclipse.core.runtime.IExtension; import org.eclipse.core.runtime.IExtensionPoint; import org.eclipse.core.runtime.IExtensionRegistry; import org.eclipse.core.runtime.Platform; import org.eclipse.debug.core.DebugPlugin; import org.eclipse.debug.core.ILaunchConfiguration; import org.eclipse.debug.core.ILaunchConfigurationType; import org.eclipse.debug.core.ILaunchConfigurationWorkingCopy; import org.eclipse.debug.core.ILaunchManager; import org.eclipse.debug.ui.ILaunchShortcut; import org.eclipse.jdt.core.IJavaProject; import org.eclipse.jdt.launching.IJavaLaunchConfigurationConstants; public class ExtensionSupport { public static ILaunchConfigurationWorkingCopy createLaunchConfigurationWorkingCopy(IJavaProject project) throws CoreException{ return createWorkingCopy(\"org.eclipse.jdt.junit.launchconfig\",project); } public static ILaunchConfiguration getLaunchConfiguration(IJavaProject project) throws CoreException{ return getWorkingCopy(\"org.eclipse.jdt.junit.launchconfig\",project); } protected static ILaunchShortcut createLaunchShortcut(final String namespace) throws CoreException { final IExtensionRegistry reg = Platform.getExtensionRegistry(); final IExtensionPoint point = reg.getExtensionPoint(\"org.eclipse.debug.ui.launchShortcuts\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.args.prefererence; import junit.extensions.eclipse.quick.args.ArgsPlugin; import junit.extensions.eclipse.quick.args.ExtensionSupport; import org.eclipse.core.runtime.CoreException; import org.eclipse.debug.core.ILaunchConfiguration; import org.eclipse.debug.core.ILaunchConfigurationWorkingCopy; import org.eclipse.debug.ui.EnvironmentTab; import org.eclipse.debug.ui.ILaunchConfigurationTab; import org.eclipse.jdt.core.IJavaProject; import org.eclipse.jdt.debug.ui.launchConfigurations.JavaArgumentsTab; import org.eclipse.jface.resource.ColorRegistry; import org.eclipse.jface.resource.ImageDescriptor; import org.eclipse.jface.resource.ImageRegistry; import org.eclipse.jface.resource.JFaceResources; import org.eclipse.jface.viewers.DecorationOverlayIcon; import org.eclipse.jface.viewers.IDecoration; import org.eclipse.swt.SWT; import org.eclipse.swt.custom.CTabFolder; import org.eclipse.swt.custom.CTabItem; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.graphics.Color; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.ui.IWorkbenchPreferenceConstants; import org.eclipse.ui.IWorkbenchPropertyPage; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.dialogs.PropertyPage;  public class QuickJUnitInfoPage extends PropertyPage implements IWorkbenchPropertyPage { private ILaunchConfigurationTab[] tabs; private CTabFolder fTabFolder; private int fCurrentTabIndex = -1; private boolean fInitializingTabs = false; private boolean fDisposingTabs = false; private ILaunchConfigurationWorkingCopy fWorkingCopy; private ILaunchConfiguration fOriginal; public QuickJUnitInfoPage() { tabs = new ILaunchConfigurationTab[]{ new JavaArgumentsTab(), new EnvironmentTab() }; } protected Control createContents(Composite parent) { load(); createTabFolder(parent); CTabItem tab = null; String name = \"\"; Control control = null; for (int i = 0; i < tabs.length; i++) { tab = new CTabItem(fTabFolder, SWT.BORDER); name = tabs[i].getName(); if (name == null) { name = \"unspecified\"; } tab.setText(name); tab.setImage(tabs[i].getImage()); tabs[i].createControl(tab.getParent()); control = tabs[i].getControl(); if (control != null) { tab.setControl(control); } tabs[i].initializeFrom(fOriginal); } setActiveTab(0); return fTabFolder; } private void load() { IJavaProject project = (IJavaProject) getElement(); try { fOriginal = ExtensionSupport.getLaunchConfiguration(project); if(fOriginal != null){ fWorkingCopy = fOriginal.getWorkingCopy(); }else{ fWorkingCopy = ExtensionSupport.createLaunchConfigurationWorkingCopy(project); fOriginal = fWorkingCopy.doSave(); } } catch (CoreException e) { getPlugin().logSystemError(e, this); } } private void createTabFolder(Composite parent) { if (fTabFolder == null) { ColorRegistry reg = JFaceResources.getColorRegistry(); Color c1 = reg.get(\"org.eclipse.ui.workbench.ACTIVE_TAB_BG_START\"), "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal; import org.eclipse.ui.plugin.AbstractUIPlugin; public class GrowlActivator extends AbstractUIPlugin { private static GrowlActivator plugin; public GrowlActivator(){ GrowlActivator.plugin = this; } public static GrowlActivator getDefault(){ return GrowlActivator.plugin; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.mac.growl.internal.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal; public enum TemplateKey { RESULT_COUNT(\"results\", Messages.TemplateKey_RESULT_DESCRIPTION), "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal; import org.eclipse.jdt.junit.model.ITestRunSession; import static junit.extensions.eclipse.quick.mac.growl.internal.TemplateKey.*; class TemplateParser { private String template; private TestCounter counter = new TestCounter(); public TemplateParser() { } String pickupTestClassAndMethod(String testName){ if(testName == null) return null; if(testName.indexOf('.') != 0){ String[] split = testName.split(\"\\\\.\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal.preferences; import static junit.extensions.eclipse.quick.mac.growl.internal.preferences.Preference.TEMPLATE; import junit.extensions.eclipse.quick.mac.growl.internal.GrowlActivator; import junit.extensions.eclipse.quick.mac.growl.internal.TemplateKey; import org.eclipse.jface.layout.GridDataFactory; import org.eclipse.jface.preference.FieldEditorPreferencePage; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Group; import org.eclipse.swt.widgets.Label; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchPreferencePage; public class GrowlPreferencePage extends FieldEditorPreferencePage implements IWorkbenchPreferencePage { public GrowlPreferencePage() { super(FLAT); setPreferenceStore(GrowlActivator.getDefault().getPreferenceStore()); setDescription(Messages.GrowlPreferencePage_description); noDefaultAndApplyButton(); }  public void createFieldEditors() { createTemplateArea(); } private void createTemplateArea() { Composite comp = getFieldEditorParent(); comp.setLayout(new GridLayout()); Group group = new Group(comp , SWT.NONE); group.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false)); group.setLayout(new GridLayout(1, false)); group.setText(Messages.GrowlPreferencePage_template_group); TemplateFieldEditor templateField = new TemplateFieldEditor(TEMPLATE.name(), \"\", group); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal.preferences; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.mac.growl.internal.preferences.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal.preferences; import junit.extensions.eclipse.quick.mac.growl.internal.GrowlActivator; import org.eclipse.jface.preference.IPreferenceStore;  public enum Preference { TEMPLATE; public String getValue() { IPreferenceStore store = GrowlActivator.getDefault().getPreferenceStore(); return store.getString(name()); } public void setValue(String value){ IPreferenceStore store = GrowlActivator.getDefault().getPreferenceStore(); store.setValue(name(), value); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal.preferences; import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer; import org.eclipse.jface.preference.IPreferenceStore; import junit.extensions.eclipse.quick.mac.growl.internal.GrowlActivator; import static junit.extensions.eclipse.quick.mac.growl.internal.preferences.Preference.*;  public class PreferenceInitializer extends AbstractPreferenceInitializer { public void initializeDefaultPreferences() { IPreferenceStore store = GrowlActivator.getDefault().getPreferenceStore(); store.setDefault(TEMPLATE.name(), \"${name} passed:${ok_counts} failure:${fail_counts} Total:${total_counts}\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mac.growl.internal.preferences; import org.eclipse.jface.preference.FieldEditor; import org.eclipse.jface.resource.JFaceResources; import org.eclipse.core.runtime.Assert; import org.eclipse.swt.SWT; import org.eclipse.swt.events.DisposeEvent; import org.eclipse.swt.events.DisposeListener; import org.eclipse.swt.events.FocusAdapter; import org.eclipse.swt.events.FocusEvent; import org.eclipse.swt.events.KeyAdapter; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.graphics.GC; import org.eclipse.swt.graphics.Point; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Text;  public class TemplateFieldEditor extends FieldEditor {  public static final int VALIDATE_ON_KEY_STROKE = 0;  public static final int VALIDATE_ON_FOCUS_LOST = 1;  public static int UNLIMITED = -1;  private boolean isValid;  protected String oldValue;  Text textField;  @SuppressWarnings(\"unused\") private int widthInChars = UNLIMITED;  private int textLimit = UNLIMITED;  private String errorMessage;  private boolean emptyStringAllowed = true;  private int validateStrategy = VALIDATE_ON_KEY_STROKE;  protected TemplateFieldEditor() { }  public TemplateFieldEditor(String name, String labelText, int width, int strategy, Composite parent) { init(name, labelText); widthInChars = width; setValidateStrategy(strategy); isValid = false; errorMessage = JFaceResources .getString(\"StringFieldEditor.errorMessage\");"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc.ui; import java.util.Dictionary; import junit.extensions.eclipse.quick.javadoc.ui.exception.QuickJUnitJavaDocUIExtensionException; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.MultiStatus; import org.eclipse.core.runtime.Status; import org.eclipse.jface.dialogs.ErrorDialog; import org.eclipse.jface.resource.ImageDescriptor; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.plugin.AbstractUIPlugin; import org.osgi.framework.BundleContext; import org.osgi.framework.Constants; public class JavaDocUIActivator extends AbstractUIPlugin { public static final String PLUGIN_ID = \"junit.extensions.eclipse.quick.javadoc.ui\"; private static JavaDocUIActivator plugin; public JavaDocUIActivator() { } public void start(BundleContext context) throws Exception { super.start(context); plugin = this; } public void stop(BundleContext context) throws Exception { plugin = null; super.stop(context); } public static JavaDocUIActivator getDefault() { return plugin; } public IStatus createSystemErrorStatus(Exception ex, Object caller) { int severity = IStatus.ERROR; String message; message = ex.getMessage(); if (message == null) message = \"\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc.ui.exception; public class QuickJUnitJavaDocUIExtensionException extends RuntimeException { public QuickJUnitJavaDocUIExtensionException(String message) { super(message); } private static final long serialVersionUID = -8971881504636818439L; }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc.ui.handlers; import org.eclipse.core.commands.AbstractHandler; import org.eclipse.core.commands.ExecutionEvent; import org.eclipse.core.commands.ExecutionException; import org.eclipse.jdt.core.ICompilationUnit; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jdt.core.JavaModelException; import org.eclipse.jface.text.ITextSelection; import org.eclipse.jface.viewers.ISelection; import org.eclipse.jface.viewers.ISelectionProvider; import org.eclipse.ui.IEditorInput; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.handlers.HandlerUtil; import org.eclipse.ui.texteditor.ITextEditor; public abstract class AbstractJavaDocHandler extends AbstractHandler { private ITextEditor textEditor; private IWorkbenchWindow window; public final Object execute(ExecutionEvent event) throws ExecutionException { window = HandlerUtil.getActiveWorkbenchWindowChecked(event); textEditor = (ITextEditor)HandlerUtil.getActiveEditor(event); return doExecute(event); } protected abstract Object doExecute(ExecutionEvent event) throws ExecutionException; protected ITextEditor getTextEdtior(){ return textEditor; } protected IWorkbenchWindow getWorkbenchWindow(){ return window; } protected IJavaElement getElementOfJavaEditor() throws JavaModelException { ICompilationUnit unit = getCompilationUnitOfJavaEditor(); if (unit == null) return null; ITextSelection text = getTextSelectionOfJavaEditor(); int offset = text.getOffset(); IJavaElement element = unit.getElementAt(offset); return element; } protected IJavaElement getElementOfCurrentCursor() throws JavaModelException{ ICompilationUnit unit = getCompilationUnitOfJavaEditor(); if (unit == null) return null; ITextSelection text = getTextSelectionOfJavaEditor(); int offset = text.getOffset(); int length = text.getLength(); IJavaElement[] elements = unit.codeSelect(offset, length); if(elements.length == 0) return null; return elements[0]; } private ITextSelection getTextSelectionOfJavaEditor() throws JavaModelException { ISelectionProvider provider = getTextEdtior().getSelectionProvider(); ISelection selection = provider.getSelection(); if (!(selection instanceof ITextSelection)) return null; return (ITextSelection) selection; } protected ICompilationUnit getCompilationUnitOfJavaEditor() throws JavaModelException { ITextEditor textEdtior = getTextEdtior(); if (textEdtior == null) return null; IEditorInput input = textEdtior.getEditorInput(); IJavaElement element = (IJavaElement) input.getAdapter(IJavaElement.class); if (element instanceof ICompilationUnit) return (ICompilationUnit) element; return null; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc.ui.handlers; import java.util.List; import org.eclipse.core.runtime.Platform; import org.eclipse.core.runtime.preferences.IPreferencesService; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jface.bindings.Trigger; import org.eclipse.jface.bindings.TriggerSequence; import org.eclipse.jface.bindings.keys.KeyStroke; import org.eclipse.jface.bindings.keys.SWTKeySupport; import org.eclipse.jface.viewers.ILabelProvider; import org.eclipse.swt.SWT; import org.eclipse.swt.events.FocusEvent; import org.eclipse.swt.events.FocusListener; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.events.KeyListener; import org.eclipse.swt.events.MouseEvent; import org.eclipse.swt.events.MouseListener; import org.eclipse.swt.events.TraverseEvent; import org.eclipse.swt.events.TraverseListener; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Table; import org.eclipse.swt.widgets.TableColumn; import org.eclipse.swt.widgets.TableItem; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.keys.IBindingService; public class PopupTableSelector { private Shell shell; private List<IJavaElement> items; private Object selection; private TriggerSequence[] forwardTriggerSequences = null; private TriggerSequence[] backwardTriggerSequences = null; private String commandForward; private String commandBackward; private ILabelProvider labelProvider; private String title = \"\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc; public enum QuickJUnitDocTagConstants { TestContext; public String toAnnotation(){ return \"@\" + name(); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc; import java.util.regex.Matcher; import java.util.regex.Pattern; import junit.extensions.eclipse.quick.javadoc.internal.JavaDocActivator; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.core.runtime.NullProgressMonitor; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jdt.core.IMethod; import org.eclipse.jdt.core.ISourceRange; import org.eclipse.jdt.core.IType; import org.eclipse.jdt.core.Signature; import org.eclipse.jdt.core.dom.ASTVisitor; import org.eclipse.jdt.core.dom.Javadoc; import org.eclipse.jdt.core.dom.TagElement; import org.eclipse.jdt.core.dom.TypeDeclaration; import org.eclipse.jdt.core.search.IJavaSearchConstants; import org.eclipse.jdt.core.search.IJavaSearchScope; import org.eclipse.jdt.core.search.SearchEngine; import org.eclipse.jdt.core.search.SearchMatch; import org.eclipse.jdt.core.search.SearchParticipant; import org.eclipse.jdt.core.search.SearchPattern; import org.eclipse.jdt.core.search.SearchRequestor; public class SearchJavaClassFromDocTagVisitor extends ASTVisitor { private static final String METHOD_PREFIX = \"#\"; private SearchRequestor requestor; private TypeDeclaration type = null; private IType targetType; private IProgressMonitor monitor = new NullProgressMonitor(); public SearchJavaClassFromDocTagVisitor(IType targetType, SearchRequestor requestor) { super(true); this.targetType = targetType; this.requestor = requestor; } public SearchJavaClassFromDocTagVisitor(IType targetType, SearchRequestor requestor,IProgressMonitor monitor) { this(targetType,requestor); this.monitor = monitor; } @Override public boolean visit(TypeDeclaration node) { if(node.getName().getIdentifier().equals(\"MISSING\")) return true; this.type = node; return super.visit(node); } @Override public boolean visit(Javadoc node) { if(type != null && node.getParent() != type) return false; return super.visit(node); } public boolean visit(TagElement node) { if(QuickJUnitDocTagConstants.TestContext.toAnnotation().equals(node.getTagName())){ for(Object obj:node.fragments()){ String patternString = obj.toString(); if(patternString.trim().equals(\"\")) continue; if(patternString.contains(METHOD_PREFIX)){ if(patternString.startsWith(METHOD_PREFIX)){ acceptMethodInCurrentType(patternString); continue; } acceptMethodPattern(patternString); }else{ acceptClassPattern(patternString); } } } return true; } private void acceptClassPattern(String patternString) { SearchPattern pattern = SearchPattern.createPattern(patternString, IJavaSearchConstants.TYPE, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_EQUIVALENT_MATCH); search(pattern); } private void acceptMethodPattern(String patternString) { SearchPattern pattern = createMethodPattern(patternString); search(pattern); } private void search(SearchPattern pattern) { try { SearchEngine engine = new SearchEngine(); IJavaSearchScope scope = SearchEngine.createWorkspaceScope(); SearchParticipant[] participants = new SearchParticipant[] {SearchEngine.getDefaultSearchParticipant()}; engine.search(pattern, participants, scope, requestor, monitor); } catch (CoreException e) { JavaDocActivator.getDefault().handleSystemError(e, this); } } private SearchPattern createMethodPattern(String patternString) { SearchPattern pattern; patternString = patternString.replace(METHOD_PREFIX, \".\"); pattern= SearchPattern.createPattern(patternString, IJavaSearchConstants.METHOD, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_ERASURE_MATCH); return pattern; } private void acceptMethodInCurrentType(String patternString) { Pattern methodPattern = Pattern.compile(\"#(.*)\\\\((.*)\\\\)\"); Matcher matcher = methodPattern.matcher(patternString); if( matcher.matches() == false) return; String name = matcher.group(1); String paramString = matcher.group(2); String[] params = paramString == null || paramString.equals(\"\") ? null : paramString.split(\",\"); int index = 0; if(params != null && params.length != 0){ for(String param : params){ params[index++] = transParamToSignatureStyle(param); } } IMethod element = targetType.getMethod(name, params); match(element); } private String transParamToSignatureStyle(String param) { String sigStyle = Signature.createTypeSignature(param, true); return sigStyle; } private void match(IJavaElement elem) { if(!(elem instanceof IMethod)) return; try { IMethod element = (IMethod) elem; if(element.exists() == false) return; ISourceRange range = element.getSourceRange(); SearchMatch match = new SearchMatch(element, SearchMatch.A_ACCURATE, range.getOffset(), range.getLength(), null, null); requestor.acceptSearchMatch(match); } catch (CoreException e) { JavaDocActivator.getDefault().handleSystemError(e, this); } } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc.exception; public class QuickJUnitJavaDocExtensionException extends RuntimeException { public QuickJUnitJavaDocExtensionException(String message) { super(message); } private static final long serialVersionUID = 1L; }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.javadoc.internal; import java.util.Dictionary; import junit.extensions.eclipse.quick.javadoc.exception.QuickJUnitJavaDocExtensionException; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.MultiStatus; import org.eclipse.core.runtime.Plugin; import org.eclipse.core.runtime.Status; import org.osgi.framework.BundleContext; import org.osgi.framework.Constants; public class JavaDocActivator extends Plugin { public static final String PLUGIN_ID = \"junit.extensions.eclipse.quick.javadoc\"; private static JavaDocActivator plugin; public JavaDocActivator() { } public void start(BundleContext context) throws Exception { super.start(context); plugin = this; } public void stop(BundleContext context) throws Exception { plugin = null; super.stop(context); } public static JavaDocActivator getDefault() { return plugin; } public IStatus createSystemErrorStatus(Exception ex, Object caller) { int severity = IStatus.ERROR; String message; message = ex.getMessage(); if (message == null) message = \"\"; "}
{"name": "kompiro/quick-junit", "content": "import org.junit.Test; public class Learning { @Test public void testname() throws Exception { ProcessBuilder builder = new ProcessBuilder(\"/usr/local/bin/growlnotify\",\"-n\",\"Quick JUnit\",\"Quick JUnit\"); builder.start(); } @Test public void string() throws Exception { String com = \"growlnotify -n \\\"Quick JUnit\\\" \"; String[] split = com.split(\" \"); for (String string : split) { System.out.println(string); } } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick; import static org.junit.Assert.assertEquals; import java.util.ArrayList; import java.util.List; import org.eclipse.jdt.core.dom.AST; import org.eclipse.jdt.core.dom.ASTNode; import org.eclipse.jdt.core.dom.ASTParser; import org.eclipse.jdt.core.dom.ASTVisitor; import org.eclipse.jdt.core.dom.Javadoc; import org.eclipse.jdt.core.dom.MethodRef; import org.eclipse.jdt.core.dom.SimpleName; import org.eclipse.jdt.core.dom.TagElement; import org.junit.Test; public class LeaningAST { @Test public void learning() throws Exception { String source = \"public class TestClass{\\n\" + \" \\n\" + \" @org.junit.Test\\n\" + \" public void do_test() throws Exception{\\n\" + \" }\\n\" + \"}\\n\"; ASTParser parser = ASTParser.newParser(AST.JLS3); parser.setSource(source.toCharArray()); ASTNode node = parser.createAST(null); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal; import org.eclipse.ui.plugin.AbstractUIPlugin; import org.osgi.framework.BundleContext; public class Activator extends AbstractUIPlugin { private static Activator plugin; public Activator() { plugin = this; } public void start(BundleContext context) throws Exception { super.start(context); } public void stop(BundleContext context) throws Exception { super.stop(context); plugin = null; } public static Activator getDefault(){ return Activator.plugin; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.mock.internal.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IPath; import org.eclipse.core.runtime.Path; import org.eclipse.jdt.core.ClasspathContainerInitializer; import org.eclipse.jdt.core.IClasspathContainer; import org.eclipse.jdt.core.IClasspathEntry; import org.eclipse.jdt.core.IJavaProject; import org.eclipse.jdt.core.JavaCore; public class MockitoClasspathContainerInitializer extends ClasspathContainerInitializer { public MockitoClasspathContainerInitializer() { } @Override public void initialize(IPath containerPath, IJavaProject project) throws CoreException { IClasspathContainer container = new IClasspathContainer() { public IPath getPath() { return new Path(MockitoEntry.CONTAINER_PATH); } public int getKind() { return K_APPLICATION; } public String getDescription() { return \"Mockito\"; } public IClasspathEntry[] getClasspathEntries() { MockitoEntry entry = new MockitoEntry(); IClasspathEntry[] result = new IClasspathEntry[]{ JavaCore.newLibraryEntry(entry.getPath(), null, null) }; return result; } }; JavaCore.setClasspathContainer(containerPath, new IJavaProject[] { project }, new IClasspathContainer[] { container }, null); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal; import java.util.ArrayList; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IPath; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.core.runtime.NullProgressMonitor; import org.eclipse.jdt.core.IClasspathEntry; import org.eclipse.jdt.core.IJavaProject; import org.eclipse.jdt.ui.ISharedImages; import org.eclipse.jdt.ui.JavaUI; import org.eclipse.jdt.ui.text.java.ClasspathFixProcessor; import org.eclipse.ltk.core.refactoring.Change; import org.eclipse.ltk.core.refactoring.NullChange; import org.eclipse.swt.graphics.Image; public class MockitoClasspathFixProcessor extends ClasspathFixProcessor { public MockitoClasspathFixProcessor() { } @Override public ClasspathFixProposal[] getFixImportProposals(final IJavaProject project, String missingType) throws CoreException { if(missingType == null) return null; if(missingType.startsWith(\"org.mockito\")){ "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal; import java.io.IOException; import java.net.URL; import java.net.URLDecoder; import org.eclipse.core.runtime.FileLocator; import org.eclipse.core.runtime.IPath; import org.eclipse.core.runtime.Path; import org.eclipse.core.runtime.Platform; import org.eclipse.jdt.core.IClasspathEntry; import org.eclipse.jdt.core.JavaCore; import org.osgi.framework.Bundle; public class MockitoEntry { public static final String CONTAINER_PATH = \"junit.extensions.eclipse.quick.mock.MOCKITO_CONTAINER\"; public IPath getPath(){ Bundle bundle = Platform.getBundle(\"org.mockito\"); URL entry = bundle.getEntry(\"mockito.jar\"); String fileURL = null; try { fileURL = URLDecoder.decode(FileLocator.toFileURL(entry).getFile(), \"UTF-8\"); } catch (IOException e) { } return new Path(fileURL); } public IClasspathEntry getContainer(){ IPath path = getContainerPath(); IClasspathEntry entry = JavaCore.newContainerEntry(path ); return entry; } public IPath getContainerPath() { IPath path = new Path(CONTAINER_PATH); return path; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal.preference; import java.io.IOException; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.Set; import org.eclipse.jdt.ui.PreferenceConstants; import org.eclipse.jface.preference.IPreferenceStore; import org.eclipse.jface.util.PropertyChangeEvent; import org.eclipse.ui.IStartup; import org.eclipse.ui.preferences.ScopedPreferenceStore;  public class PreferenceInitializer implements IStartup { private static final String EMPTY = \"\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal.wizard; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.mock.internal.wizard.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.mock.internal.wizard; import junit.extensions.eclipse.quick.mock.internal.MockitoEntry; import org.eclipse.jdt.core.IClasspathContainer; import org.eclipse.jdt.core.IClasspathEntry; import org.eclipse.jdt.core.IJavaProject; import org.eclipse.jdt.core.JavaCore; import org.eclipse.jdt.core.JavaModelException; import org.eclipse.jdt.ui.wizards.IClasspathContainerPage; import org.eclipse.jdt.ui.wizards.IClasspathContainerPageExtension; import org.eclipse.jface.wizard.WizardPage; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Label; public class MockitoPage extends WizardPage implements IClasspathContainerPage,IClasspathContainerPageExtension { private MockitoEntry entry; private IJavaProject project; public MockitoPage() { super(\"mockitoPage\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications; import org.eclipse.jface.resource.ImageRegistry; import org.eclipse.jface.resource.JFaceResources; import org.eclipse.swt.graphics.RGB; import org.eclipse.ui.plugin.AbstractUIPlugin; import org.osgi.framework.BundleContext;  public class Activator extends AbstractUIPlugin { "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications; import org.eclipse.jface.resource.ImageDescriptor; import org.eclipse.swt.graphics.Image; public enum ImageDesc { ERROR(\"/icons/tsuiteerror.gif\"), FAILURE(\"/icons/tsuitefail.gif\"), OK(\"/icons/tsuiteok.gif\"), ICON(\"/icons/quickjunit.png\"); private String imageFilePath; ImageDesc(String imageFilePath){ this.imageFilePath = imageFilePath; } public ImageDescriptor getIamgeDescriptor(){ return Activator.imageDescriptorFromPlugin(Activator.PLUGIN_ID, imageFilePath); } public Image getImage() { return Activator.getDefault().getImageRegistry().get(name()); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; import java.util.Date; import junit.extensions.eclipse.quick.notifications.ImageDesc; import junit.extensions.eclipse.quick.notifications.internal.preference.Preference; import org.eclipse.jdt.junit.model.ITestElement.Result; import org.eclipse.jdt.junit.model.ITestRunSession; import org.eclipse.mylyn.commons.notifications.core.AbstractNotification; import org.eclipse.mylyn.commons.notifications.ui.AbstractUiNotification; import org.eclipse.swt.graphics.Image; @SuppressWarnings(\"restriction\") class JUnitNotification extends AbstractUiNotification { private static final TemplateParser parser = new TemplateParser(); private String resultLabel; private Image kind; private Result testResult; private String description; private String label; private static final String TEST_OK = \"Test OK\"; private static final String TEST_FAILURE = \"Test FAILED\"; private static final String TEST_ERROR = \"Test ERROR\"; JUnitNotification(String eventId, Result testResult, ITestRunSession session) { super(eventId); String template = Preference.TEMPLATE.getValue(); parser.setTemplate(template); this.testResult = testResult; if(Result.ERROR.equals(testResult)){ resultLabel = TEST_ERROR; kind = ImageDesc.ERROR.getImage(); }else if(Result.FAILURE.equals(testResult)){ resultLabel = TEST_FAILURE; kind = ImageDesc.FAILURE.getImage(); }else{ resultLabel = TEST_OK; kind = ImageDesc.OK.getImage(); } this.label = pickupTestClassAndMethod(session.getTestRunName()); this.description = parser.parseTemplate(session); } String pickupTestClassAndMethod(String testName){ if(testName == null) return null; if(testName.indexOf('.') != 0){ String[] split = testName.split(\"\\\\.\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; import junit.extensions.eclipse.quick.notifications.ImageDesc; import org.eclipse.jface.layout.GridDataFactory; import org.eclipse.mylyn.commons.ui.CommonUiUtil; import org.eclipse.mylyn.commons.ui.compatibility.CommonColors; import org.eclipse.mylyn.commons.ui.dialogs.AbstractNotificationPopup; import org.eclipse.swt.SWT; import org.eclipse.swt.events.ControlAdapter; import org.eclipse.swt.events.ControlEvent; import org.eclipse.swt.graphics.GC; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.graphics.Point; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.forms.events.HyperlinkAdapter; import org.eclipse.ui.forms.events.HyperlinkEvent; import org.eclipse.ui.forms.widgets.ImageHyperlink; @SuppressWarnings(\"restriction\") public class JUnitNotificationPopup extends AbstractNotificationPopup { private Shell shell; private Image lastUsedBgImage; private JUnitNotification notification; private JUnitNotificationPopupColors color; public JUnitNotificationPopup(Shell parent, JUnitNotification notification) { super(parent.getDisplay()); setDelayClose(3 * 1000); setFadingEnabled(false); color = new JUnitNotificationPopupColors(parent.getDisplay(), resources, notification); this.notification = notification; } @Override protected void configureShell(Shell newShell) { super.configureShell(newShell); shell = newShell; } @Override protected String getPopupShellTitle() { return notification.getResultLabel(); } @Override protected Image getPopupShellImage(int maximumHeight) { return ImageDesc.ICON.getImage(); } @Override protected void createContentArea(Composite parent) { Composite notificationComposite = new Composite(parent, SWT.NO_FOCUS); GridLayout gridLayout = new GridLayout(2, false); GridDataFactory.fillDefaults().grab(true, false).align(SWT.FILL, SWT.TOP).applyTo(notificationComposite); notificationComposite.setLayout(gridLayout); notificationComposite.setBackground(parent.getBackground()); final Label notificationLabelIcon = new Label(notificationComposite, SWT.NO_FOCUS); notificationLabelIcon.setBackground(parent.getBackground()); notificationLabelIcon.setImage(notification.getNotificationKindImage()); final ImageHyperlink itemLink = new ImageHyperlink(notificationComposite, SWT.BEGINNING | SWT.NO_FOCUS|SWT.WRAP); GridDataFactory.fillDefaults().grab(true, false).align(SWT.FILL, SWT.TOP).applyTo(itemLink); itemLink.setForeground(CommonColors.HYPERLINK_WIDGET); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; import org.eclipse.jdt.junit.model.ITestElement.Result; import org.eclipse.jface.resource.DeviceResourceException; import org.eclipse.jface.resource.ResourceManager; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Color; import org.eclipse.swt.graphics.RGB; import org.eclipse.swt.widgets.Display;  public class JUnitNotificationPopupColors { private final Display display; private Color titleText; private Color gradientBegin; private Color gradientEnd; private Color border; private final ResourceManager resourceManager; private JUnitNotification notification; private Color baseColor; public JUnitNotificationPopupColors(Display display, ResourceManager resourceManager, JUnitNotification notification) { this.display = display; this.resourceManager = resourceManager; this.notification = notification; createColors(); } private void createColors() { computeBaseColor(); createBorderColor(); createGradientColors(); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; import java.util.List; import java.util.WeakHashMap; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.Platform; import org.eclipse.core.runtime.Status; import org.eclipse.core.runtime.jobs.Job; import org.eclipse.jface.window.Window; import org.eclipse.mylyn.commons.notifications.core.AbstractNotification; import org.eclipse.mylyn.commons.notifications.core.NotificationSink; import org.eclipse.mylyn.commons.notifications.core.NotificationSinkEvent; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.PlatformUI; @SuppressWarnings(\"restriction\") public class JUnitPopupNotificationSink extends NotificationSink { private static final boolean runSystem = true; private final WeakHashMap<Object, Object> cancelledTokens = new WeakHashMap<Object, Object>(); private JUnitNotification currentlyNotifying; private final Job openJob = new Job(\"JUnit Result popup notifier\") { @Override protected IStatus run(IProgressMonitor monitor) { try { if (Platform.isRunning() && PlatformUI.getWorkbench() != null && PlatformUI.getWorkbench().getDisplay() != null && !PlatformUI.getWorkbench().getDisplay().isDisposed()) { PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() { public void run() { collectNotifications(); if (popup != null && popup.getReturnCode() == Window.CANCEL) { AbstractNotification notification = popup.getNotification(); if (notification.getToken() != null) { cancelledTokens.put(notification.getToken(), null); } } synchronized (JUnitPopupNotificationSink.class) { if (currentlyNotifying != null) { "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.notifications.internal.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; import org.eclipse.jdt.junit.JUnitCore; import org.eclipse.ui.IStartup; public class Startup implements IStartup { public void earlyStartup() { JUnitCore.addTestRunListener(new TestNotificationListener()); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; public enum TemplateKey { RESULT_COUNT(\"results\", Messages.TemplateKey_RESULT_DESCRIPTION), "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal; import org.eclipse.jdt.junit.model.ITestRunSession; import static junit.extensions.eclipse.quick.notifications.internal.TemplateKey.*; class TemplateParser { private String template; private TestCounter counter = new TestCounter(); public TemplateParser() { } public String parseTemplate(ITestRunSession session) { String result = null; result = replaceResult(session,template); result = replaceCount(session,result); return result; } private String replaceCount(ITestRunSession session, String result) { counter.count(session); result = result.replaceAll(key(TOTAL_COUNT), String.valueOf(counter.getTotalTests())); result = result.replaceAll(key(OK_COUNT), String.valueOf(counter.getOKTests())); result = result.replaceAll(key(FAIL_COUNT), String.valueOf(counter.getFailureTests())); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal.preference; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.notifications.internal.preference.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal.preference; import junit.extensions.eclipse.quick.notifications.Activator; import org.eclipse.jface.preference.IPreferenceStore;  public enum Preference { TEMPLATE; public String getValue() { IPreferenceStore store = Activator.getDefault().getPreferenceStore(); return store.getString(name()); } public void setValue(String value){ IPreferenceStore store = Activator.getDefault().getPreferenceStore(); store.setValue(name(), value); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal.preference; import static junit.extensions.eclipse.quick.notifications.internal.preference.Preference.TEMPLATE; import junit.extensions.eclipse.quick.notifications.Activator; import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer; import org.eclipse.jface.preference.IPreferenceStore;  public class PreferenceInitializer extends AbstractPreferenceInitializer { public void initializeDefaultPreferences() { IPreferenceStore store = Activator.getDefault().getPreferenceStore(); store.setDefault(TEMPLATE.name(), \"passed:${ok_counts} failure:${fail_counts} Total:${total_counts}\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal.preference; import static junit.extensions.eclipse.quick.notifications.internal.preference.Preference.TEMPLATE; import junit.extensions.eclipse.quick.notifications.Activator; import junit.extensions.eclipse.quick.notifications.internal.TemplateKey; import org.eclipse.jface.layout.GridDataFactory; import org.eclipse.jface.preference.FieldEditorPreferencePage; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Group; import org.eclipse.swt.widgets.Label; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchPreferencePage; public class QuickJUnitNotificationPreferencePage extends FieldEditorPreferencePage implements IWorkbenchPreferencePage { public QuickJUnitNotificationPreferencePage() { super(FLAT); setPreferenceStore(Activator.getDefault().getPreferenceStore()); setDescription(Messages.QuickJUnitNotificationPreferencePage_description); noDefaultAndApplyButton(); }  public void createFieldEditors() { createTemplateArea(); } private void createTemplateArea() { Composite comp = getFieldEditorParent(); comp.setLayout(new GridLayout()); Group group = new Group(comp , SWT.NONE); group.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false)); group.setLayout(new GridLayout(1, false)); group.setText(Messages.QuickJUnitNotificationPreferencePage_template_group); TemplateFieldEditor templateField = new TemplateFieldEditor(TEMPLATE.name(), \"\", group); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.notifications.internal.preference; import org.eclipse.jface.preference.FieldEditor; import org.eclipse.jface.resource.JFaceResources; import org.eclipse.core.runtime.Assert; import org.eclipse.swt.SWT; import org.eclipse.swt.events.DisposeEvent; import org.eclipse.swt.events.DisposeListener; import org.eclipse.swt.events.FocusAdapter; import org.eclipse.swt.events.FocusEvent; import org.eclipse.swt.events.KeyAdapter; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.graphics.GC; import org.eclipse.swt.graphics.Point; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Text;  public class TemplateFieldEditor extends FieldEditor {  public static final int VALIDATE_ON_KEY_STROKE = 0;  public static final int VALIDATE_ON_FOCUS_LOST = 1;  public static int UNLIMITED = -1;  private boolean isValid;  protected String oldValue;  Text textField;  @SuppressWarnings(\"unused\") private int widthInChars = UNLIMITED;  private int textLimit = UNLIMITED;  private String errorMessage;  private boolean emptyStringAllowed = true;  private int validateStrategy = VALIDATE_ON_KEY_STROKE;  protected TemplateFieldEditor() { }  public TemplateFieldEditor(String name, String labelText, int width, int strategy, Composite parent) { init(name, labelText); widthInChars = width; setValidateStrategy(strategy); isValid = false; errorMessage = JFaceResources .getString(\"StringFieldEditor.errorMessage\");"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.pde; import org.eclipse.core.runtime.CoreException; import org.eclipse.debug.ui.ILaunchShortcut; public class ExtensionSupport extends junit.extensions.eclipse.quick.internal.ExtensionSupport { public static ILaunchShortcut createJUnitWorkbenchShortcut() throws CoreException { return createLaunchShortcut(\"org.eclipse.pde.ui\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.pde; import junit.extensions.eclipse.quick.internal.action.JUnitLaunchAction; import org.eclipse.core.runtime.CoreException; public class PDEJUnitDebugAction extends JUnitLaunchAction { public PDEJUnitDebugAction() throws CoreException { super(ExtensionSupport.createJUnitWorkbenchShortcut(), \"debug\"); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.pde; import junit.extensions.eclipse.quick.internal.action.JUnitLaunchAction; import org.eclipse.core.runtime.CoreException; public class PDEJUnitRunAction extends JUnitLaunchAction { public PDEJUnitRunAction() throws CoreException { super(ExtensionSupport.createJUnitWorkbenchShortcut(), \"run\"); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick; import org.eclipse.jdt.core.Flags; import org.eclipse.jdt.core.ICompilationUnit; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jdt.core.IMember; import org.eclipse.jdt.core.IMethod; import org.eclipse.jdt.core.IType; import org.eclipse.jdt.core.ITypeHierarchy; import org.eclipse.jdt.core.JavaModelException; public class JavaElements { public static boolean isTestMethod(IJavaElement element) throws JavaModelException { if (!(element instanceof IMethod)) return false; IMethod method = (IMethod) element; if (!method.getReturnType().equals(\"V\")) return false; int flags = method.getFlags(); if (!Flags.isPublic(flags) || Flags.isStatic(flags)) return false; if(method.getElementName().startsWith(\"test\")) return true; return hasTestAnnotationOnMethod(method); } public static IType getPrimaryTypeOf(IJavaElement element) { if (element == null) return null; ICompilationUnit cu = null; if (element instanceof ICompilationUnit) { cu = (ICompilationUnit) element; } else if (element instanceof IMember) { cu = ((IMember) element).getCompilationUnit(); } return cu != null ? cu.findPrimaryType() : null; } public static boolean isTestClass(IType type) throws JavaModelException { ITypeHierarchy superTypeHierarchy = type.newSupertypeHierarchy(null); IType superTypes[] = superTypeHierarchy.getAllInterfaces(); for (int i = 0; i < superTypes.length; ++i) { IType superType = superTypes[i]; if (superType.getFullyQualifiedName().equals(JavaTypes.TEST_INTERFACE_NAME)) return true; } return false; } public static IJavaElement getTestMethodOrClass(IJavaElement element) throws JavaModelException { while (element != null) { if (isTestMethod(element)){ IType declaringType = ((IMethod) element).getDeclaringType(); if(hasParameterizedAnnotation(declaringType)){ return declaringType; } return element; } if (isTestRunnerPassibleClass(element)) { IType type = (IType) element; if (isTestClass(type)) return element; if (hasSuiteMethod(type)) return element; if (hasSuiteAnnotation(type)) return element; if (hasTestAnnotation(type)) return element; } element = element.getParent(); } return null; } private static boolean hasParameterizedAnnotation(IType type) throws JavaModelException { String source = type.getSource(); if(source == null) return false; return source.indexOf(\"Parameterized\") != -1; } private static boolean hasSuiteAnnotation(IType type) throws JavaModelException { String source = type.getSource(); if(source == null) return false; return source.indexOf(\"@SuiteClasses\") != -1 && source.indexOf(\"Suite.class\") != -1; } private static boolean isTestRunnerPassibleClass(IJavaElement element) throws JavaModelException { if (!(element instanceof IType)) return false; IType type = (IType) element; if (!type.isClass()) return false; int flags = type.getFlags(); if (Flags.isAbstract(flags) || !Flags.isPublic(flags)) return false; return true; } private static boolean hasSuiteMethod(IType type) throws JavaModelException { IMethod[] methods = type.getMethods(); for (int i = 0; i < methods.length; i++) { if (isStaticSuiteMethod(methods[i])) return true; } return false; } private static boolean hasTestAnnotation(IType type) throws JavaModelException{ IMethod[] methods = type.getMethods(); for (int i = 0; i < methods.length; i++) { if (hasTestAnnotationOnMethod(methods[i])) return true; } return false; } private static boolean hasTestAnnotationOnMethod(IMethod method) throws JavaModelException{ return method.getSource() == null ? false:method.getSource().indexOf(\"@Test\") > -1; } private static boolean isStaticSuiteMethod(IMethod method) throws JavaModelException { return ((method.getElementName().equals(\"suite\")) && method.getSignature().equals(\"()QTest;\") && Flags.isPublic(method.getFlags()) && Flags.isStatic(method.getFlags()) ); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick; import org.eclipse.jdt.core.IAnnotation; import org.eclipse.jdt.core.ICompilationUnit; import org.eclipse.jdt.core.IImportDeclaration; import org.eclipse.jdt.core.IMethod; import org.eclipse.jdt.core.IType; import org.eclipse.jdt.core.ITypeHierarchy; import org.eclipse.jdt.core.JavaModelException; public class JavaTypes { private static final char ENCLOSING_TYPE_SEPARATOR = '.'; public static final String TEST_INTERFACE_NAME= \"junit.framework.Test\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick; public class NamingRule { private String value; private boolean enabled; public NamingRule(String value, boolean enabled) { this.value = value; this.enabled = enabled; } public boolean isEnabled() { return enabled; } public String getValue() { return value; } public void setEnabled(boolean enabled) { this.enabled = enabled; } public void setValue(String value) { this.value = value; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick; import java.util.ArrayList; import java.util.List; import java.util.StringTokenizer; import org.eclipse.jface.preference.IPreferenceStore; public class NamingRules { private IPreferenceStore store; private final String STORE_ID = \"NamingRules\"; public NamingRules(IPreferenceStore store) { this.store = store; } public List get() { String value = store.getString(STORE_ID); if (value == null || value.length() == 0) return getDefault(); return stringToList(value); } public String[] getEnableValues() { List namingRules = get(); List result = new ArrayList(); for (int i = 0; i < namingRules.size(); ++i) { NamingRule rule = (NamingRule) namingRules.get(i); if (rule.isEnabled()) { result.add(rule.getValue()); } } return (String[]) result.toArray(new String[result.size()]); } public void set(List namingRules) { store.setValue(STORE_ID, listToString(namingRules)); } private String listToString(List namingRules) { StringBuffer buf = new StringBuffer(); for (int i = 0; i < namingRules.size(); ++i) { if (i != 0) buf.append(','); NamingRule rule = (NamingRule) namingRules.get(i); buf.append(rule.getValue() + \":\" + rule.isEnabled()); } return buf.toString(); } private List stringToList(String string) { List result = new ArrayList(); StringTokenizer st = new StringTokenizer(string, \",\"); while(st.hasMoreTokens()) { String column = st.nextToken(); int index = column.indexOf(':'); if (index != -1) { String value = column.substring(0, index); Boolean enabled = Boolean.valueOf(column.substring(index + 1)); result.add(new NamingRule(value, enabled.booleanValue())); } } return result; } public List getDefault() { List result = new ArrayList(); result.add(new NamingRule(\"${package}.${type}Test\", true)); result.add(new NamingRule(\"${package}.${type}PDETest\", false)); return result; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal; import junit.extensions.eclipse.quick.internal.launch.QuickJUnitLaunchShortcut; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IConfigurationElement; import org.eclipse.core.runtime.IExtension; import org.eclipse.core.runtime.IExtensionPoint; import org.eclipse.core.runtime.IExtensionRegistry; import org.eclipse.core.runtime.Platform; import org.eclipse.debug.core.DebugPlugin; import org.eclipse.debug.core.ILaunchConfiguration; import org.eclipse.debug.core.ILaunchConfigurationType; import org.eclipse.debug.core.ILaunchConfigurationWorkingCopy; import org.eclipse.debug.ui.ILaunchShortcut; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchWizard; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.wizards.IWizardDescriptor; import org.eclipse.ui.wizards.IWizardRegistry; public class ExtensionSupport { public static final String QUICK_JUNIT_DEFAULT = \"QuickJUnitDefault\"; public static ILaunchShortcut createJUnitLaunchShortcut() throws CoreException { return new QuickJUnitLaunchShortcut(); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.PlatformUI; public class HelpSupport { public static void setHelp(final Shell control, final String contextId) { final IWorkbench workbench = PlatformUI.getWorkbench(); workbench.getHelpSystem().setHelp(control, contextId); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal; import java.text.MessageFormat; import java.util.MissingResourceException; import java.util.ResourceBundle; public class Messages { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.internal.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal; import java.util.List; import org.eclipse.core.runtime.Platform; import org.eclipse.core.runtime.preferences.IPreferencesService; import org.eclipse.jface.bindings.Trigger; import org.eclipse.jface.bindings.TriggerSequence; import org.eclipse.jface.bindings.keys.KeyStroke; import org.eclipse.jface.bindings.keys.SWTKeySupport; import org.eclipse.jface.viewers.ILabelProvider; import org.eclipse.swt.SWT; import org.eclipse.swt.events.FocusEvent; import org.eclipse.swt.events.FocusListener; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.events.KeyListener; import org.eclipse.swt.events.MouseEvent; import org.eclipse.swt.events.MouseListener; import org.eclipse.swt.events.TraverseEvent; import org.eclipse.swt.events.TraverseListener; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Table; import org.eclipse.swt.widgets.TableColumn; import org.eclipse.swt.widgets.TableItem; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.keys.IBindingService; public class PopupTableSelector { private Shell shell; private List items; private Object selection; private TriggerSequence[] forwardTriggerSequences = null; private TriggerSequence[] backwardTriggerSequences = null; private String commandForward; private String commandBackward; private ILabelProvider labelProvider; private String title = \"\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.Status; public class QuickJUnitException extends CoreException { private static final long serialVersionUID = 1L; public QuickJUnitException(Throwable cause) { this(cause.getMessage(), cause); } public QuickJUnitException(IStatus status) { super(status); } public QuickJUnitException(String message) { this(new Status(IStatus.ERROR, QuickJUnitPlugin.getDefault().getID(), 0, message, null)); } public QuickJUnitException(String message, Throwable cause) { this(new Status(IStatus.ERROR, QuickJUnitPlugin.getDefault().getID(), 0, message, cause)); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal; import java.util.Dictionary; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.MultiStatus; import org.eclipse.core.runtime.Status; import org.eclipse.debug.core.DebugPlugin; import org.eclipse.debug.core.ILaunchManager; import org.eclipse.jface.dialogs.ErrorDialog; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.plugin.AbstractUIPlugin; import org.osgi.framework.BundleContext; import org.osgi.framework.Constants; public class QuickJUnitPlugin extends AbstractUIPlugin { private static QuickJUnitPlugin plugin; public QuickJUnitPlugin() { plugin = this; } public void start(BundleContext context) throws Exception { super.start(context); } public void stop(BundleContext context) throws Exception { super.stop(context); plugin = null; } public static QuickJUnitPlugin getDefault() { return plugin; } public IStatus createSystemErrorStatus(Exception ex, Object caller) { int severity = IStatus.ERROR; String message; message = ex.getMessage(); if (message == null) message = \"\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.action; import junit.extensions.eclipse.quick.internal.ExtensionSupport; import org.eclipse.core.runtime.CoreException; public class JUnitDebugAction extends JUnitLaunchAction { public JUnitDebugAction() throws CoreException { super(ExtensionSupport.createJUnitLaunchShortcut(), \"debug\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.action; import junit.extensions.eclipse.quick.JavaElements; import junit.extensions.eclipse.quick.internal.Messages; import junit.extensions.eclipse.quick.internal.QuickJUnitPlugin; import org.eclipse.debug.ui.ILaunchShortcut; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jdt.core.IType; import org.eclipse.jdt.core.JavaModelException; import org.eclipse.jface.action.IAction; import org.eclipse.jface.viewers.ISelection; import org.eclipse.jface.viewers.StructuredSelection; public class JUnitLaunchAction extends QuickJUnitAction { private String mode; private ILaunchShortcut launchShortcut; public JUnitLaunchAction(ILaunchShortcut launchShortcut, String mode) { this.launchShortcut = launchShortcut; this.mode = mode; } private IJavaElement getTargetElement(IAction action) throws JavaModelException { IJavaElement element = getSelectedElement(); if (element == null || element.getElementType() < IJavaElement.COMPILATION_UNIT) return element; IJavaElement testableElement = JavaElements.getTestMethodOrClass(element); if (testableElement != null) return testableElement; IType type = JavaElements.getPrimaryTypeOf(element); if (type == null) return element; openInformation(action, Messages.getString(\"JUnitLaunchAction.notJUnitElement\")); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.action; import junit.extensions.eclipse.quick.internal.ExtensionSupport; import org.eclipse.core.runtime.CoreException; public class JUnitRunAction extends JUnitLaunchAction { public JUnitRunAction() throws CoreException { super(ExtensionSupport.createJUnitLaunchShortcut(), \"run\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.action; import org.eclipse.jdt.core.ICompilationUnit; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jdt.core.JavaModelException; import org.eclipse.jface.action.IAction; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.jface.text.ITextSelection; import org.eclipse.jface.viewers.ISelection; import org.eclipse.jface.viewers.ISelectionProvider; import org.eclipse.jface.viewers.IStructuredSelection; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.IEditorActionDelegate; import org.eclipse.ui.IEditorInput; import org.eclipse.ui.IEditorPart; import org.eclipse.ui.IObjectActionDelegate; import org.eclipse.ui.IWorkbenchPart; import org.eclipse.ui.texteditor.ITextEditor; public abstract class QuickJUnitAction implements IEditorActionDelegate, IObjectActionDelegate { private Shell shell; protected IJavaElement javaElement; protected ITextEditor javaEditor; public void setActiveEditor(IAction action, IEditorPart targetEditor) { if (!(targetEditor instanceof ITextEditor)) { javaEditor = null; return; } javaEditor = (ITextEditor) targetEditor; shell = javaEditor.getSite().getShell(); } public void setActivePart(IAction action, IWorkbenchPart targetPart) { shell = targetPart.getSite().getShell(); } public void selectionChanged(IAction action, ISelection selection) { if (! (selection instanceof IStructuredSelection)) { javaElement = null; return; } Object element = ((IStructuredSelection) selection).getFirstElement(); if (element instanceof IJavaElement) javaElement = (IJavaElement) element; else javaElement = null; } protected void openInformation(IAction action, String message) { MessageDialog.openInformation(shell, action.getText(), message); } protected Shell getShell() { return shell; } protected IJavaElement getElementOfJavaEditor() throws JavaModelException { ICompilationUnit unit = getCompilationUnitOfJavaEditor(); if (unit == null) return null; ISelectionProvider provider = javaEditor.getSelectionProvider(); ISelection selection = provider.getSelection(); if (!(selection instanceof ITextSelection)) return null; int offset = ((ITextSelection) selection).getOffset(); IJavaElement element = unit.getElementAt(offset); return element; } protected ICompilationUnit getCompilationUnitOfJavaEditor() throws JavaModelException { if (javaEditor == null) return null; IEditorInput input = javaEditor.getEditorInput(); IJavaElement element = (IJavaElement) input.getAdapter(IJavaElement.class); if (element instanceof ICompilationUnit) return (ICompilationUnit) element; return null; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.launch; import java.lang.reflect.InvocationTargetException; import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import junit.extensions.eclipse.quick.internal.ExtensionSupport; import junit.extensions.eclipse.quick.internal.QuickJUnitPlugin; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IAdaptable; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.debug.core.ILaunchConfiguration; import org.eclipse.debug.core.ILaunchConfigurationType; import org.eclipse.debug.core.ILaunchConfigurationWorkingCopy; import org.eclipse.debug.core.ILaunchManager; import org.eclipse.debug.ui.DebugUITools; import org.eclipse.debug.ui.IDebugModelPresentation; import org.eclipse.jdt.core.IClassFile; import org.eclipse.jdt.core.ICompilationUnit; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jdt.core.IType; import org.eclipse.jdt.internal.junit.launcher.ITestKind; import org.eclipse.jdt.internal.junit.launcher.JUnitLaunchConfigurationConstants; import org.eclipse.jdt.internal.junit.launcher.TestKindRegistry; import org.eclipse.jdt.internal.junit.ui.JUnitMessages; import org.eclipse.jdt.junit.launcher.JUnitLaunchShortcut; import org.eclipse.jdt.launching.IJavaLaunchConfigurationConstants; import org.eclipse.jdt.ui.JavaElementLabelProvider; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.jface.operation.IRunnableWithProgress; import org.eclipse.jface.viewers.ISelection; import org.eclipse.jface.viewers.IStructuredSelection; import org.eclipse.jface.window.Window; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.dialogs.ElementListSelectionDialog;  public class QuickJUnitLaunchShortcut extends JUnitLaunchShortcut { private static final String EMPTY_STRING= \"\"; public void launch(ISelection selection, String mode) { if (selection instanceof IStructuredSelection) { launch(((IStructuredSelection) selection).toArray(), mode); } else { showNoTestsFoundDialog(); } } private void launch(Object[] elements, String mode) { try { IJavaElement elementToLaunch= null; if (elements.length == 1) { Object selected= elements[0]; if (!(selected instanceof IJavaElement) && selected instanceof IAdaptable) { selected= ((IAdaptable) selected).getAdapter(IJavaElement.class); } if (selected instanceof IJavaElement) { IJavaElement element= (IJavaElement) selected; switch (element.getElementType()) { case IJavaElement.JAVA_PROJECT: case IJavaElement.PACKAGE_FRAGMENT_ROOT: case IJavaElement.PACKAGE_FRAGMENT: case IJavaElement.TYPE: case IJavaElement.METHOD: elementToLaunch= element; break; case IJavaElement.CLASS_FILE: elementToLaunch= ((IClassFile) element).getType(); break; case IJavaElement.COMPILATION_UNIT: elementToLaunch= findTypeToLaunch((ICompilationUnit) element, mode); break; } } } if (elementToLaunch == null) { showNoTestsFoundDialog(); return; } performLaunch(elementToLaunch, mode); } catch (InterruptedException e) { "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.preference; import java.util.Iterator; import java.util.List; import java.util.StringTokenizer; import junit.extensions.eclipse.quick.NamingRule; import junit.extensions.eclipse.quick.internal.Messages; import org.eclipse.jface.dialogs.IInputValidator; import org.eclipse.jface.dialogs.InputDialog; import org.eclipse.jface.viewers.CheckStateChangedEvent; import org.eclipse.jface.viewers.CheckboxTableViewer; import org.eclipse.jface.viewers.ColumnLayoutData; import org.eclipse.jface.viewers.ColumnWeightData; import org.eclipse.jface.viewers.DoubleClickEvent; import org.eclipse.jface.viewers.ICheckStateListener; import org.eclipse.jface.viewers.IDoubleClickListener; import org.eclipse.jface.viewers.ISelectionChangedListener; import org.eclipse.jface.viewers.IStructuredContentProvider; import org.eclipse.jface.viewers.IStructuredSelection; import org.eclipse.jface.viewers.ITableLabelProvider; import org.eclipse.jface.viewers.LabelProvider; import org.eclipse.jface.viewers.SelectionChangedEvent; import org.eclipse.jface.viewers.TableLayout; import org.eclipse.jface.viewers.Viewer; import org.eclipse.jface.window.Window; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Table; import org.eclipse.swt.widgets.TableColumn; public class NamingRulesPreference { private QuickJUnitPreferencePage preferencePage; private Shell shell; private List namingRulesValue; private CheckboxTableViewer tableViewer; private Button removeButton; private Button editButton; private Button moveUpButton; private Button moveDownButton; public NamingRulesPreference(QuickJUnitPreferencePage preferencePage) { this.preferencePage = preferencePage; } public void create(List namingRulesValue, Composite parent) { this.namingRulesValue = namingRulesValue; shell = parent.getShell(); Composite container= new Composite(parent, SWT.NONE); GridLayout layout= new GridLayout(); layout.numColumns= 2; layout.marginHeight= 0; layout.marginWidth= 0; container.setLayout(layout); GridData gd= new GridData(GridData.FILL_BOTH); container.setLayoutData(gd); createTable(container); createButtons(container); update(); } public void setValue(List namingRulesValue) { this.namingRulesValue = namingRulesValue; update(); } public List getValue() { return namingRulesValue; } private void createTable(Composite container) { Label label= new Label(container, SWT.NONE); label.setText(Messages.getString(\"NamingRulesPreference.label\")); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.preference; import java.io.IOException; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.Set; import org.eclipse.jdt.ui.PreferenceConstants; import org.eclipse.jface.preference.IPreferenceStore; import org.eclipse.jface.util.PropertyChangeEvent; import org.eclipse.ui.IStartup; import org.eclipse.ui.preferences.ScopedPreferenceStore;  public class PreferenceInitializer implements IStartup{ private static final String EMPTY = \"\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.internal.preference; import junit.extensions.eclipse.quick.NamingRules; import junit.extensions.eclipse.quick.internal.QuickJUnitPlugin; import org.eclipse.jface.dialogs.Dialog; import org.eclipse.jface.dialogs.IDialogConstants; import org.eclipse.jface.preference.IPreferenceStore; import org.eclipse.jface.preference.PreferencePage; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchPreferencePage; public class QuickJUnitPreferencePage extends PreferencePage implements IWorkbenchPreferencePage { private NamingRules namingRules; private NamingRulesPreference namingRulesPreference; public QuickJUnitPreferencePage() { setPreferenceStore(QuickJUnitPlugin.getDefault().getPreferenceStore()); } public void init(IWorkbench workbench) { IPreferenceStore store = getPreferenceStore(); namingRules = new NamingRules(store); namingRulesPreference = new NamingRulesPreference(this); } protected Control createContents(Composite parent) { "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.process.internal.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal; import org.eclipse.ui.plugin.AbstractUIPlugin; public class ProcessActivator extends AbstractUIPlugin { private static ProcessActivator plugin; public ProcessActivator(){ ProcessActivator.plugin = this; } public static ProcessActivator getDefault(){ return ProcessActivator.plugin; } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal; public enum ProcessKey { DETAIL(\"detail\", Messages.ProcessKey_DETAIL_DESCRIPTION), "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal; import java.util.ArrayList; public class ProcessParser { private static final String START_DOUBLE_QUOTE = \"\\\"\"; private static final String END_DOUBLE_QUOTE = \".*[^\\\\\\\\]\\\"$\"; private static final String SPACE = \" \"; public String[] parse(String command){ String[] parse = parse(command,null,null); return parse; } public String[] parse(String command, String summary, String detail){ if(command == null) return new String[]{}; command = replaceResult(command,summary,detail); String[] splited = command.split(SPACE); ArrayList<String> results = new ArrayList<String>(); StringBuilder builder = null; boolean appendMode = false; for (String item : splited) { if(appendMode){ builder.append(SPACE); builder.append(item); if(item.matches(END_DOUBLE_QUOTE)){ appendMode = false; String string = builder.toString(); results.add(string.substring(0, string.length() - 1)); builder = null; } continue; } if(item.startsWith(START_DOUBLE_QUOTE)){ builder = new StringBuilder(); builder.append(item.substring(1, item.length())); appendMode = true; continue; } results.add(item); } if(appendMode){ results.add(builder.toString()); } return results.toArray(new String[]{}); } private String replaceResult(String command, String summary, String detail) { command = command.replaceAll(key(ProcessKey.SUMMARY), quoted(summary)); command = command.replaceAll(key(ProcessKey.DETAIL), quoted(detail)); return command; } private String quoted(String target) { return \"\\\"\"+ target + \"\\\"\"; } private String key(ProcessKey key){ return key.regexKey(); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal; public enum TemplateKey { RESULT_COUNT(\"results\", Messages.TemplateKey_RESULT_DESCRIPTION), "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal; import org.eclipse.jdt.junit.model.ITestRunSession; import static junit.extensions.eclipse.quick.process.internal.TemplateKey.*; class TemplateParser { private String template; private TestCounter counter = new TestCounter(); public TemplateParser() { } String pickupTestClassAndMethod(String testName){ if(testName == null) return null; if(testName.indexOf('.') != 0){ String[] split = testName.split(\"\\\\.\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal.preferences; import org.eclipse.osgi.util.NLS; public class Messages extends NLS { private static final String BUNDLE_NAME = \"junit.extensions.eclipse.quick.process.internal.preferences.messages\"; "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal.preferences; import junit.extensions.eclipse.quick.process.internal.ProcessActivator; import org.eclipse.jface.preference.IPreferenceStore;  public enum Preference { TEMPLATE, PROCESS; public String getValue() { IPreferenceStore store = ProcessActivator.getDefault().getPreferenceStore(); return store.getString(name()); } public void setValue(String value){ IPreferenceStore store = ProcessActivator.getDefault().getPreferenceStore(); store.setValue(name(), value); } }"}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal.preferences; import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer; import org.eclipse.jface.preference.IPreferenceStore; import junit.extensions.eclipse.quick.process.internal.ProcessActivator; import static junit.extensions.eclipse.quick.process.internal.preferences.Preference.*;  public class PreferenceInitializer extends AbstractPreferenceInitializer { public void initializeDefaultPreferences() { IPreferenceStore store = ProcessActivator.getDefault().getPreferenceStore(); store.setDefault(PROCESS.name(), \"/usr/local/bin/growlnotify -n \\\"Quick JUnit\\\" -m ${detail} ${summary}\"); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal.preferences; import static junit.extensions.eclipse.quick.process.internal.preferences.Preference.TEMPLATE; import static junit.extensions.eclipse.quick.process.internal.preferences.Preference.PROCESS; import junit.extensions.eclipse.quick.process.internal.ProcessActivator; import junit.extensions.eclipse.quick.process.internal.ProcessKey; import junit.extensions.eclipse.quick.process.internal.TemplateKey; import org.eclipse.jface.layout.GridDataFactory; import org.eclipse.jface.preference.FieldEditorPreferencePage; import org.eclipse.jface.preference.StringFieldEditor; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Group; import org.eclipse.swt.widgets.Label; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchPreferencePage; public class ProcessPreferencePage extends FieldEditorPreferencePage implements IWorkbenchPreferencePage { public ProcessPreferencePage() { super(FLAT); setPreferenceStore(ProcessActivator.getDefault().getPreferenceStore()); setDescription(Messages.ProcessPreferencePage_description); noDefaultAndApplyButton(); }  public void createFieldEditors() { createTemplateArea(); createProcessArea(); } private void createProcessArea() { Composite comp = getFieldEditorParent(); comp.setLayout(new GridLayout()); Group group = new Group(comp , SWT.NONE); group.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false)); group.setLayout(new GridLayout(1, false)); group.setText(Messages.ProcessPreferencePage_process_group); StringFieldEditor templateField = new StringFieldEditor(PROCESS.name(), \"\", group); "}
{"name": "kompiro/quick-junit", "content": "package junit.extensions.eclipse.quick.process.internal.preferences; import org.eclipse.jface.preference.FieldEditor; import org.eclipse.jface.resource.JFaceResources; import org.eclipse.core.runtime.Assert; import org.eclipse.swt.SWT; import org.eclipse.swt.events.DisposeEvent; import org.eclipse.swt.events.DisposeListener; import org.eclipse.swt.events.FocusAdapter; import org.eclipse.swt.events.FocusEvent; import org.eclipse.swt.events.KeyAdapter; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.graphics.GC; import org.eclipse.swt.graphics.Point; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Text;  public class TemplateFieldEditor extends FieldEditor {  public static final int VALIDATE_ON_KEY_STROKE = 0;  public static final int VALIDATE_ON_FOCUS_LOST = 1;  public static int UNLIMITED = -1;  private boolean isValid;  protected String oldValue;  Text textField;  @SuppressWarnings(\"unused\") private int widthInChars = UNLIMITED;  private int textLimit = UNLIMITED;  private String errorMessage;  private boolean emptyStringAllowed = true;  private int validateStrategy = VALIDATE_ON_KEY_STROKE;  protected TemplateFieldEditor() { }  public TemplateFieldEditor(String name, String labelText, int width, int strategy, Composite parent) { init(name, labelText); widthInChars = width; setValidateStrategy(strategy); isValid = false; errorMessage = JFaceResources .getString(\"StringFieldEditor.errorMessage\");"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import org.apache.commons.io.FileUtils; import org.apache.commons.io.IOUtils; import java.io.File; import java.io.IOException; import java.io.Reader; import java.io.FileReader;  public abstract class AbstractConverter<T extends AbstractConverter> { private File toFile; private File fromFile; protected String tab; protected Log log; public T targetFile(File toFile) { this.toFile = toFile; return (T) this; } public T fromFile(File fromFile) { this.fromFile = fromFile; return (T) this; } public T indentSpaces(int spaces) { String tab = \"\"; for (int x=0; x<spaces; x++) { tab += \" \"; } this.tab = tab; return (T) this; } public T logWith(Log log) { this.log = log; return (T) this; } public void convert() throws IOException { Reader reader = null; try { reader = new FileReader(fromFile); String text = buildTarget(reader); if (isValidTargetContents(text)) { FileUtils.writeStringToFile(toFile, text); } else { log.error(\"Cannot generate a valid document for \" + toFile); } } finally { IOUtils.closeQuietly(reader); } } protected abstract String buildTarget(Reader fromFile) throws IOException; protected abstract boolean isValidTargetContents(String text); }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import java.io.Reader; import java.io.IOException; import java.io.Writer;  public interface Converter { String convert(Reader from, ConverterOptions options) throws InvalidFormatException, IOException; }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import org.apache.commons.io.IOUtils; import java.io.*;  public class ConverterBuilder { private File toFile; private File fromFile; private Reader fromReader; private Writer toWriter; private final Converter converter; private final ConverterOptions options; private ConverterBuilder(Converter converter) { this.converter = converter; this.options = new ConverterOptions(); } public static ConverterBuilder convertXmlToYaml() { return new ConverterBuilder(new XmlToYamlConverter()); } public static ConverterBuilder convertYamlToXml() { return new ConverterBuilder(new YamlToXmlConverter()); } public ConverterBuilder toFile(File toFile) { this.toFile = toFile; return this; } public ConverterBuilder toWriter(Writer writer) { this.toWriter = writer; return this; } public ConverterBuilder fromFile(File fromFile) { this.fromFile = fromFile; return this; } public ConverterBuilder fromReader(Reader fromReader) { this.fromReader = fromReader; return this; } public ConverterBuilder indentSpaces(int spaces) { String tab = \"\"; for (int x=0; x<spaces; x++) { tab += \" \"; } this.options.indent(tab); return this; } public ConverterBuilder logWith(Log log) { this.options.log(log); return this; } public void convert() throws IOException, InvalidFormatException { Reader reader = fromReader; Writer writer = toWriter; try { if (reader == null) { reader = new FileReader(fromFile); } if (writer == null) { writer = new FileWriter(toFile); } String text = converter.convert(reader, options); if (text != null && text.trim().length() > 0) { IOUtils.write(text, writer); } else { throw new InvalidFormatException(\"No converted text\", null); } } finally { IOUtils.closeQuietly(reader); IOUtils.closeQuietly(writer); } } }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom;  public class ConverterOptions { private String indent = \" \"; private Log log; public String getIndent() { return indent; } public ConverterOptions indent(String indent) { this.indent = indent; return this; } public Log getLog() { return log; } public ConverterOptions log(Log log) { this.log = log; return this; } }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom;  public class InvalidFormatException extends Exception { private final String text; public InvalidFormatException(String message, String text) { super(message); this.text = text; } public InvalidFormatException(String message, String text, Throwable t) { super(message, t); this.text = text; } public String getText() { return text; } }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom;  public interface Log { void info(String msg); void error(String msg); }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom;  import org.apache.commons.io.IOUtils; import java.security.*; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; public class MD5 { private MessageDigest md = null; private static final char[] hexChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};  public MD5() { try { md = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } } public String hashFile(File fileToHash) { FileInputStream fin = null; try { fin = new FileInputStream(fileToHash); byte[] data = IOUtils.toByteArray(fin); return hexStringFromBytes((calculateHash(data))); } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } public String hashData(byte[] dataToHash) { return hexStringFromBytes((calculateHash(dataToHash))); } private byte[] calculateHash(byte[] dataToHash) { md.update(dataToHash, 0, dataToHash.length); return (md.digest()); } public String hexStringFromBytes(byte[] b) { String hex = \"\"; int msb; int lsb = 0; int i; "}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import org.apache.maven.plugin.logging.Log;  public class MavenLog implements org.twdata.maven.yamlpom.Log { private final Log log; public MavenLog(Log log) { this.log = log; } public void info(String msg) { log.info(msg); } public void error(String msg) { log.error(msg); } }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom;  public class SyncFile { private FileInfo xml; private FileInfo yaml; public FileInfo getXml() { return xml; } public void setXml(FileInfo xml) { this.xml = xml; } public FileInfo getYaml() { return yaml; } public void setYaml(FileInfo yaml) { this.yaml = yaml; } public static class FileInfo { private long timestamp; private String md5; private String syncBy; public long getTimestamp() { return timestamp; } public void setTimestamp(long timestamp) { this.timestamp = timestamp; } public String getMd5() { return md5; } public void setMd5(String md5) { this.md5 = md5; } public String getSyncBy() { return syncBy; } public void setSyncBy(String syncBy) { this.syncBy = syncBy; } } }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import org.yaml.snakeyaml.Yaml; import org.yaml.snakeyaml.Loader; import org.yaml.snakeyaml.constructor.Constructor; import org.apache.commons.io.IOUtils; import java.io.*;  public class SyncManager { public enum FormatToTarget { XML, YAML, SYNC_FILE_ONLY, UNKNOWN, NONE } private final File xmlFile; private final File yamlFile; private final File syncFile; private final SyncFile sync; public SyncManager(File xmlFile, File yamlFile, File syncFile) { this.xmlFile = xmlFile; this.yamlFile = yamlFile; this.syncFile = syncFile; Loader loader = new Loader(new Constructor(SyncFile.class)); Yaml yaml = new Yaml(loader); Reader reader = null; SyncFile tmpSync; try { reader = new FileReader(syncFile); tmpSync = (SyncFile) yaml.load(reader); } catch (FileNotFoundException e) { tmpSync = null; } finally { IOUtils.closeQuietly(reader); } sync = tmpSync; } public FormatToTarget determineFormatToTarget() { if (!yamlFile.exists() && xmlFile.exists()) { return FormatToTarget.YAML; } else if (yamlFile.exists() && !xmlFile.exists()) { return FormatToTarget.XML; } else if (sync != null) { if (xmlHasSameTimestamp() && yamlHasSameTimestamp()) { return FormatToTarget.NONE; } else { MD5 md5 = new MD5(); String xmlMd5 = md5.hashFile(xmlFile); String yamlMd5 = md5.hashFile(yamlFile); if (xmlHasSameHash(xmlMd5) && yamlHasSameHash(yamlMd5)) { return FormatToTarget.SYNC_FILE_ONLY; } else if (!xmlHasSameHash(xmlMd5) && yamlHasSameHash(yamlMd5)) { return FormatToTarget.YAML; } else if (xmlHasSameHash(xmlMd5) && !yamlHasSameHash(yamlMd5)) { return FormatToTarget.XML; } } } return FormatToTarget.UNKNOWN; } public void save() { MD5 md5 = new MD5(); SyncFile sync = new SyncFile(); SyncFile.FileInfo xmlInfo = new SyncFile.FileInfo(); xmlInfo.setSyncBy(System.getProperty(\"user.name\")); xmlInfo.setTimestamp(xmlFile.lastModified()); xmlInfo.setMd5(md5.hashFile(xmlFile)); sync.setXml(xmlInfo); SyncFile.FileInfo yamlInfo = new SyncFile.FileInfo(); yamlInfo.setSyncBy(System.getProperty(\"user.name\")); yamlInfo.setTimestamp(yamlFile.lastModified()); yamlInfo.setMd5(md5.hashFile(yamlFile)); sync.setYaml(yamlInfo); Yaml yaml = new Yaml(); Writer writer = null; try { writer = new FileWriter(syncFile); yaml.dump(sync, writer); } catch (IOException e) { throw new RuntimeException(e); } } private boolean xmlHasSameTimestamp() { return sync.getXml().getTimestamp() == xmlFile.lastModified(); } private boolean yamlHasSameTimestamp() { return sync.getYaml().getTimestamp() == yamlFile.lastModified(); } private boolean xmlHasSameHash(String xmlHash) { return sync.getXml().getMd5().equals(xmlHash); } private boolean yamlHasSameHash(String yamlHash) { return sync.getYaml().getMd5().equals(yamlHash); } }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; /* * Copyright 2001-2005 The Apache Software Foundation. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom;  public class SysOutLog implements Log { public void info(String msg) { System.out.println(msg); } public void error(String msg) { System.err.println(msg); } }"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import org.w3c.dom.*; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.yaml.snakeyaml.Yaml; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.*; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map;  public class XmlToYamlConverter implements Converter { private static final int MAX_LINE_LENGTH = 120; private static final char[] INVALID_SCALAR_CHARACTERS = new char[]{':', '#', '[', ']', '{', '}', ',', '*', '\\t'}; private static final DocumentBuilderFactory factory; static { factory = DocumentBuilderFactory.newInstance(); factory.setIgnoringComments(false); factory.setIgnoringElementContentWhitespace(true); factory.setCoalescing(false); factory.setValidating(false); } private void validateTargetContents(String yamlText) throws InvalidFormatException { Yaml yaml = YamlUtils.buildYaml(); Object obj = null; try { obj = yaml.load(yamlText); } catch (RuntimeException ex) { throw new InvalidFormatException(\"Invalid YAML\", yamlText, ex); } if (!(obj instanceof Map)) { throw new InvalidFormatException(\"YAML file not a map\", yamlText); } } public String convert(Reader xmlReader, ConverterOptions options) throws InvalidFormatException, IOException { StringWriter yamlWriter = new StringWriter(); try { Document doc = factory.newDocumentBuilder().parse(new InputSource(xmlReader)); for (Iterator it = elementIterator(doc.getDocumentElement()); it.hasNext();) { Element element = (Element) it.next(); if (!\"modelVersion\".equals(element.getTagName())) { convert(element, \"\", false, yamlWriter, options.getIndent()); } } } catch (SAXException e) { throw new InvalidFormatException(\"POM XML is not valid\", null, e); } catch (ParserConfigurationException e) { throw new InvalidFormatException(\"POM XML is not valid\", null, e); } String text = yamlWriter.toString(); validateTargetContents(text); return text; } private void convert(Element element, String tabs, boolean isInList, Writer yamlWriter, String tab) throws IOException { if (element != null) { String name = element.getTagName(); String prefix = isInList ? \"- \" : \"\"; if (\"configuration\".equals(name)) { if (isConfigurationNotYamlSafe(element, tabs, tab)) { yamlWriter.write(tabs + prefix + \"configuration : |\\n\"); StringWriter blockWriter = new StringWriter(); for (Iterator i = elementIterator(element); i.hasNext();) { blockWriter.append(elementToBlockString((Element) i.next())); } yamlWriter.write(indent(blockWriter.toString(), (isInList ? \" \" : \"\") + tabs + tab, tab)); return; } } "}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import org.apache.commons.io.IOUtils; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.helpers.DefaultHandler; import org.yaml.snakeyaml.Yaml; import javax.xml.parsers.ParserConfigurationException; import javax.xml.parsers.SAXParserFactory; import java.io.*; import java.util.Collection; import java.util.Map;  public class YamlToXmlConverter implements Converter { public String convert(Reader from, ConverterOptions options) throws InvalidFormatException, IOException { StringWriter xmlWriter = null; String tab = options.getIndent(); try { xmlWriter = new StringWriter(); Yaml yaml = YamlUtils.buildYaml(); Object yamlPom = yaml.load(from); xmlWriter.write( \"<project xmlns=\\\"http:"}
{"name": "mrdon/maven-yamlpom-plugin", "content": "package org.twdata.maven.yamlpom; import org.yaml.snakeyaml.Yaml; import org.yaml.snakeyaml.Loader; import org.yaml.snakeyaml.nodes.NodeId; import org.yaml.snakeyaml.resolver.Resolver;  public class YamlUtils { public static Yaml buildYaml() { Loader myLoader = new Loader(); Yaml yaml = new Yaml(myLoader); "}
{"name": "panterch/edu", "content": "package ch.panter.decorator; public class A implements Executable { @Override public void method() { "}
{"name": "panterch/edu", "content": "package ch.panter.decorator; public class B implements Executable { private Executable delegate; public B(Executable delegate) { this.delegate = delegate; } @Override public void method() { this.delegate.method(); "}
{"name": "panterch/edu", "content": "package ch.panter.decorator; public class Demo {  public static void main(String[] args) { Executable a = new A(); Executable b = new B(a); } }"}
{"name": "panterch/edu", "content": "package ch.panter.decorator; public interface Executable { public void method(); }"}
{"name": "panterch/edu", "content": "package ch.panter.decorator.inputstream; import java.io.*; public class LowerCaseInputStream extends FilterInputStream { public LowerCaseInputStream(InputStream in) { super(in); } public int read() throws IOException { int c = super.read(); return (c == -1 ? c : Character.toLowerCase((char) c)); } public int read(byte[] b, int offset, int len) throws IOException { int result = super.read(b, offset, len); for (int i = offset; i < offset + result; i++) { b[i] = (byte) Character.toLowerCase((char) b[i]); } return result; } }"}
{"name": "panterch/edu", "content": "package ch.panter.decorator.reader; import java.io.FilterReader; import java.io.IOException; import java.io.Reader; class DowncaseReader extends FilterReader { public DowncaseReader( Reader in ) { super( in ); } @Override public int read() throws IOException { char[] buf = new char[1]; return read( buf, 0, 1 ) == -1 ? -1 : buf[0]; } @Override public int read( char[] cbuf, int off, int len ) throws IOException { int numchars = 0; while ( numchars == 0 ) { numchars = in.read( cbuf, off, len ); if ( numchars == -1 ) "}
{"name": "panterch/edu", "content": "package ch.panter.decorator.reader; import java.io.FilterReader; import java.io.IOException; import java.io.Reader; class HTMLReader extends FilterReader { private boolean intag = false; public HTMLReader( Reader in ) { super( in ); } @Override public int read() throws IOException { char[] buf = new char[1]; return read( buf, 0, 1 ) == -1 ? -1 : buf[0]; } @Override public int read( char[] cbuf, int off, int len ) throws IOException { int numchars = 0; while ( numchars == 0 ) { numchars = in.read( cbuf, off, len ); if ( numchars == -1 ) "}
{"name": "panterch/edu", "content": "package ch.panter.decorator.reader; import java.io.BufferedReader; import java.io.LineNumberReader; import java.io.Reader; import java.io.StringReader; public class ReaderDemo {  public static void main(String[] args) { try { String s = \"<html>Hallo! <p>Content im Tag.</p>\\n\" + \"Content ausserhalb Tag.</html>\"; Reader reader = new StringReader( s ); BufferedReader in = new BufferedReader( reader ); for ( String line; (line = in.readLine()) != null; ) System.out.println( line ); in.close(); } catch ( Exception e ) { e.printStackTrace(); } } }"}
{"name": "panterch/edu", "content": "package ch.panter.inheritance; import ch.panter.decorator.Executable; public class A implements Executable { public void method() {} }"}
{"name": "panterch/edu", "content": "package ch.panter.inheritance; public class B extends A { public void method() { super.method(); "}
{"name": "panterch/edu", "content": "package ch.panter.inheritance; import ch.panter.decorator.Executable; public class Demo {  public static void main(String[] args) { Executable a = new A(); Executable b = new B(); } }"}
{"name": "panterch/edu", "content": "public class Empty { public boolean isEmpty(String s) { return s.length() == 0; } public void doit(String s) { System.out.println( \"For string [\" + s + \"] empty = \" + isEmpty(s) ); } public static void main(String[] args) { Empty empty = new Empty(); empty.doit(\"foo\"); empty.doit(\"bar\"); empty.doit(\"\"); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.appendix.easymock; public interface Client { boolean onMessage(String nickname, String message); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.appendix.easymock; import java.util.HashMap; import java.util.Map; public class InternetRelayChat { private Map<String, Client> clients = new HashMap<String, Client>(); public Prompt join(final String nickname, Client user) { clients.put(nickname, user); return new Prompt() { @Override public void say(String message) { deliverMessage(nickname, message); } }; } protected void deliverMessage(String from, String message) { for (String nickname : clients.keySet()) { if (!nickname.equals(from)) { clients.get(nickname).onMessage(from, message); } } } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.appendix.easymock; public class Prompt { public void say(String message) { } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.calculator; import java.util.ArrayList; import java.util.List; public class Calculator { private static final int HISTORY_SIZE = 6; private static Calculator instance; public static Calculator getInstance() { if (instance == null) { instance = new Calculator(); } return instance; } private List<Operation> operationHistory = new ArrayList<Operation>(); private void addToHistory(double left, char operator, double right) { Operation operation = new Operation(); operation.left = left; operation.right = right; operation.operator = operator; operation.index = operationHistory.size() + 1; operationHistory.add(operation); if (operationHistory.size() > HISTORY_SIZE) { operationHistory.remove(0); } } public double add(double left, double right) { addToHistory(left, '+', right); return left + right; } public double subtract(double left, double right) { addToHistory(left, '-', right); return left - right; } public double multiply(double left, double right) { addToHistory(left, '*', right); return left * right; } public double divide(double left, double right) { addToHistory(left, '/', right); if (right == 0.0d) { throw new IllegalArgumentException( \"Can't divide with zero\"); } return left / right; } public List<Operation> getOperations() { return operationHistory; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.calculator;  public class CalculatorPresenter { private double display; private double left; private double right; private char operator; private Calculator calculator; public CalculatorPresenter(Calculator calculator) { this.calculator = calculator; } public double display() { return display; } public void inputValue(double input) { left = right; right = input; display = input; } public void evaluate() { switch (operator) { case '+': display = calculator.add(left, right); break; case '-': display = calculator.subtract(left, right); break; case '*': display = calculator.multiply(left, right); break; case '/': display = calculator.divide(left, right); break; default: System.err.println(\"Unknown operator: \" + operator); } } public void plusClicked() { operator = '+'; } public void minusClicked() { operator = '-'; } public void multiplyClicked() { operator = '*'; } public void divideClicked() { operator = '/'; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.calculator; public class Operation { public int index; "}
{"name": "panterch/edu", "content": " package com.tddinaction.concurrency.asynchexecution; public class LongLastingCalculation { private volatile Integer result; public Integer getResult() { return result; } public void start() { new Thread() { @Override public void run() { try { Thread.sleep(1000); result = 42; } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }.start(); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.concurrency.methodblocking; import java.util.concurrent.Semaphore; public class BlackMarket { private Semaphore tickets = new Semaphore(0); public void buyTicket() throws InterruptedException { tickets.acquire(); } public void sellTicket() { tickets.release(); } }"}
{"name": "panterch/edu", "content": " package com.tddinaction.concurrency.threadsafety; public class Counter { private int counter; public synchronized void increment() { counter++; } public int value() { return counter; } }"}
{"name": "panterch/edu", "content": " package com.tddinaction.concurrency.threadsafety; import java.util.concurrent.CyclicBarrier; public class SynchedThread extends Thread { private CyclicBarrier entryBarrier; private final CyclicBarrier exitBarrier; public SynchedThread(Runnable runnable, CyclicBarrier entryBarrier, CyclicBarrier exitBarrier) { super(runnable); this.entryBarrier = entryBarrier; this.exitBarrier = exitBarrier; } @Override public void run() { try { entryBarrier.await(); super.run(); exitBarrier.await(); } catch (Exception e) { throw new RuntimeException(e); } } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.concurrency.threadstartstop; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; public class Server { private Runnable serverDaemon = new Runnable() { public void run() { try { System.out.println(\"The server is now supposedly running...\"); Object obj = new Object(); synchronized (obj) { obj.wait(); } } catch (InterruptedException e) { System.out.println(\"The server thread was interrupted\"); } } }; private ThreadFactory threadFactory = Executors.defaultThreadFactory(); private ExecutorService executor; public void setThreadFactory(ThreadFactory threadFactory) { this.threadFactory = threadFactory; } public void start() { executor = Executors.newSingleThreadExecutor(threadFactory); executor.execute(serverDaemon); } public void stop() { executor.shutdownNow(); } }"}
{"name": "panterch/edu", "content": " package com.tddinaction.concurrency.threadstartstop; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import org.junit.Assert; public class StartStopSynchronizedThread extends Thread { private CountDownLatch threadStarted; private CountDownLatch threadStopped; public StartStopSynchronizedThread(Runnable task) { super(task); threadStarted = new CountDownLatch(1); threadStopped = new CountDownLatch(1); } @Override public void run() { threadStarted.countDown(); super.run(); threadStopped.countDown(); } public void shouldBeStartedWithin(long timeout, TimeUnit unit) throws InterruptedException { Assert.assertTrue(\"Thread not started within timeout.\", threadStarted.await(timeout, unit)); } public void shouldBeStoppedWithin(int timeout, TimeUnit unit) throws InterruptedException { Assert.assertTrue(\"Thread not stopped within timeout.\", threadStopped.await(timeout, unit)); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data; import java.util.List; import com.tddinaction.data.person.Person; public interface PersonDao { List<Person> findAll(); List<Person> findByLastname(String lastname); void save(Person person); Person find(Long id); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.hibernate; import java.util.List; import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.Transient; import org.hibernate.annotations.GenericGenerator; @Entity public class Article { @Id @GenericGenerator(name = \"system-uuid\", strategy = \"uuid\") private Long id; private String title; private String body; private List attachments; @Transient private String renderedHtml; public List getAttachments() { return attachments; } public void setAttachments(List attachments) { this.attachments = attachments; } public String getBody() { return body; } public void setBody(String body) { this.body = body; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getRenderedHtml() { return renderedHtml; } public void setRenderedHtml(String renderedHtml) { this.renderedHtml = renderedHtml; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.hibernate; public class Attachment { private Long id; private String name; private String filepath; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getFilepath() { return filepath; } public void setFilepath(String filepath) { this.filepath = filepath; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.hibernate; import java.util.List; import org.hibernate.HibernateException; import org.hibernate.Query; import org.hibernate.Session; import org.hibernate.SessionFactory; import com.tddinaction.data.PersonDao; import com.tddinaction.data.person.Person; public class HibernatePersonDao implements PersonDao { private SessionFactory sessionFactory; public void setSessionFactory(SessionFactory sessionFactory) { this.sessionFactory = sessionFactory; } @SuppressWarnings(\"unchecked\") public List<Person> findAll() { Session session = sessionFactory.getCurrentSession(); String hql = \"from Person p\"; Query query = session.createQuery(hql); List people = query.list(); return people; } @SuppressWarnings(\"unchecked\") public List<Person> findByLastname(String name) { try { Session session = sessionFactory.getCurrentSession(); String hql = \"from Person p where p.lastname = :lastname\"; Query query = session.createQuery(hql); query.setParameter(\"lastname\", name); return query.list(); } catch (HibernateException e) { throw new RuntimeException(e); } } public void save(Person person) { Session session = sessionFactory.getCurrentSession(); session.save(person); session.flush(); } public Person find(Long id) { Session session = sessionFactory.getCurrentSession(); return (Person) session.get(Person.class, id); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.integration; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; import com.tddinaction.data.person.Person; public class HibernatePersonDao { private SessionFactory sessionFactory; public void setSessionFactory(SessionFactory sessionFactory) { this.sessionFactory = sessionFactory; } public void save(Person person) { Session session = sessionFactory.getCurrentSession(); Transaction tx = session.beginTransaction(); session.save(person); tx.commit(); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.jdbc; import javax.sql.*; import java.sql.*; import java.util.*; import com.tddinaction.data.PersonDao; import com.tddinaction.data.person.Person; public class JdbcPersonDao implements PersonDao { private DataSource datasource; public void setDatasource(DataSource datasource) { this.datasource = datasource; } public List<Person> findByLastname(String lastname) { try { Connection conn = datasource.getConnection(); String sql = \"SELECT * FROM people WHERE last_name = ?\"; PreparedStatement stmt = conn.prepareStatement(sql); stmt.setString(1, lastname); ResultSet rset = stmt.executeQuery(); List<Person> people = new ArrayList<Person>(); while (rset.next()) { String firstName = rset.getString(\"first_name\"); String lastName = rset.getString(\"last_name\"); people.add(new Person(firstName, lastName)); } rset.close(); stmt.close(); conn.close(); return people; } catch (SQLException e) { throw new RuntimeException(e); } } public void save(Person person) { } public Person find(Long id) { return null; } public List<Person> findAll() { return null; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.person; public class Person { private Long id; private String firstName; private String lastName; private String ssn; private Person inLoveWith; private Person engagedWith; public Person() { } public Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public void setId(Long id) { this.id = id; } public Long getId() { return id; } public String getFirstname() { return firstName; } public void setFirstname(String name) { this.firstName = name; } public String getLastname() { return lastName; } public void setLastname(String name) { this.lastName = name; } public String getSsn() { return ssn; } public void setSsn(String ssn) { this.ssn = ssn; } @Override public boolean equals(Object obj) { if (obj == null) { return false; } if (!obj.getClass().equals(getClass())) { return false; } Person other = (Person) obj; return firstName.equals(other.firstName) && lastName.equals(other.lastName); } public String toString() { return \"{\" + firstName + \" \" + lastName + \"}\"; } public void proposeTo(Person beloved) { if (beloved.acceptProposalFrom(this)) { this.engagedWith = beloved; beloved.engagedWith = this; } } private boolean acceptProposalFrom(Person person) { return person.equals(inLoveWith); } public void isInLoveWith(Person beloved) { inLoveWith = beloved; } public boolean isEngagedWith(Person person) { return person.equals(engagedWith); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.spring.hibernate; import java.util.List; import org.springframework.orm.hibernate3.support.HibernateDaoSupport; import com.tddinaction.data.PersonDao; import com.tddinaction.data.person.Person; public class SpringHibernatePersonDao extends HibernateDaoSupport implements PersonDao { public List<Person> findAll() { return null; } @SuppressWarnings(\"unchecked\") public List<Person> findByLastname(String lastname) { return getHibernateTemplate() .find(\"from Person p where p.lastname = ?\", new Object[] { lastname }); } public void save(Person person) { } public Person find(Long id) { return null; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.spring.jdbc; import java.sql.PreparedStatement; import java.sql.SQLException; import java.util.List; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.PreparedStatementCallback; import org.springframework.jdbc.core.RowMapper; import org.springframework.jdbc.core.support.JdbcDaoSupport; import com.tddinaction.data.PersonDao; import com.tddinaction.data.person.Person; public class JdbcTemplatePersonDao extends JdbcDaoSupport implements PersonDao { @SuppressWarnings(\"unchecked\") public List<Person> findAll() { return getJdbcTemplate().query(\"SELECT * FROM employee\", new Object[0], new PersonRowMapper()); } @SuppressWarnings(\"unchecked\") public List<Person> findByLastName(String lastName) { String sql = \"SELECT * FROM employee WHERE last_name = ?\"; Object[] args = { lastName }; RowMapper mapper = new PersonRowMapper(); return getJdbcTemplate().query(sql, args, mapper); } @SuppressWarnings(\"unchecked\") public List<Person> findByLastname(String lastname) { String sql = \"SELECT * FROM employee WHERE last_name = ?\"; String[] args = new String[] { lastname }; RowMapper mapper = new PersonRowMapper(); return getJdbcTemplate().query(sql, args, mapper); } public void save(final Person person) { getJdbcTemplate() .execute( \"INSERT INTO employee (employee_uid, start_date, first_name, last_name, ssn) VALUES (?, NOW, ?, ?, ?)\", new PreparedStatementCallback() { public Object doInPreparedStatement( PreparedStatement ps) throws SQLException, DataAccessException { ps.setInt(1, 4); ps .setString(2, person .getFirstname()); ps.setString(3, person.getLastname()); ps.setString(4, person.getSsn()); ps.executeUpdate(); return null; } }); } public Person find(Long id) { return null; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.data.spring.jdbc; import java.sql.ResultSet; import java.sql.SQLException; import org.springframework.jdbc.core.RowMapper; import com.tddinaction.data.person.Person; public class PersonRowMapper implements RowMapper { public Object mapRow(ResultSet rs, int rowNum) throws SQLException { return new Person(rs.getString(\"first_name\"), rs .getString(\"last_name\")); } }"}
{"name": "panterch/edu", "content": "/* * Copyright 2006 Lasse Koskela. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http:"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb2x; import java.rmi.RemoteException; import javax.annotation.Resource; import javax.ejb.CreateException; import javax.ejb.EJBException; import javax.ejb.EntityBean; import javax.ejb.EntityContext; import javax.ejb.RemoveException; import javax.ejb.TimedObject; import javax.ejb.Timer; import javax.ejb.TimerService; public abstract class EJB2UserBean implements EntityBean, TimedObject { private static final long EXPIRATION_PERIOD = 5000L; private EntityContext ctx; public abstract void setId(Integer id); public abstract Integer getId(); public abstract void setUsername(String username); public abstract String getUsername(); public abstract void setPassword(String password); public abstract String getPassword(); public abstract void setPasswordExpired(boolean expired); public abstract boolean getPasswordExpired(); public void setEntityContext(EntityContext ctx) throws EJBException, RemoteException { this.ctx = ctx; } public Integer ejbCreate(String user, String pass) throws CreateException { setId((int) (System.currentTimeMillis() % Integer.MAX_VALUE)); setUsername(user); setPassword(pass); setPasswordExpired(false); return null; } public void ejbPostCreate(String username, String password) throws CreateException { getTimerService().createTimer(EXPIRATION_PERIOD, \"password expired\"); } @Resource javax.ejb.TimerService timerService; private TimerService getTimerService() { "}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb2x; import javax.annotation.Resource; import javax.ejb.CreateException; import javax.ejb.TimedObject; import javax.ejb.Timer; public class EJB3UserBean implements TimedObject { private static final long EXPIRATION_PERIOD = 5000L; public void setId(Integer id) { } public Integer getId() { return null; } public void setUsername(String username) { } public String getUsername() { return null; } public void setPassword(String password) { } public String getPassword() { return null; } public void setPasswordExpired(boolean expired) { } public boolean getPasswordExpired() { return false; } public Integer ejbCreate(String user, String pass) throws CreateException { setId((int) (System.currentTimeMillis() % Integer.MAX_VALUE)); setUsername(user); setPassword(pass); setPasswordExpired(false); return null; } public void ejbPostCreate(String username, String password) throws CreateException { timerService.createTimer(EXPIRATION_PERIOD, \"password expired\"); } @Resource javax.ejb.TimerService timerService; public void ejbTimeout(Timer timer) { setPasswordExpired(true); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb2x; import javax.ejb.EJBLocalObject; public interface User extends EJBLocalObject { }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb2x; import javax.ejb.CreateException; import javax.ejb.EJBLocalHome; import javax.ejb.FinderException; public interface UserHome extends EJBLocalHome { public User findByPrimaryKey(Integer id) throws FinderException; public User create(String username, String password) throws CreateException; }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb3; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; @Entity public class LineItem implements java.io.Serializable { private int id; private double subtotal; private int quantity; private String product; private Order order; @Id @GeneratedValue(strategy = GenerationType.AUTO) public int getId() { return id; } public void setId(int id) { this.id = id; } public double getSubtotal() { return subtotal; } public void setSubtotal(double subtotal) { this.subtotal = subtotal; } public int getQuantity() { return quantity; } public void setQuantity(int quantity) { this.quantity = quantity; } public String getProduct() { return product; } public void setProduct(String product) { this.product = product; } @ManyToOne @JoinColumn(name = \"order_id\") public Order getOrder() { return order; } public void setOrder(Order order) { this.order = order; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb3; import java.io.Serializable; import java.util.ArrayList; import java.util.Collection; import javax.persistence.CascadeType; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.OneToMany; import javax.persistence.Table; @Entity @Table(name = \"PURCHASE_ORDER\") public class Order implements Serializable { private int id; private double total; private Collection<LineItem> lineItems; @Id @GeneratedValue(strategy = GenerationType.AUTO) public int getId() { return id; } public void setId(int id) { this.id = id; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } public void addPurchase(String product, int quantity, double price) { if (lineItems == null) lineItems = new ArrayList<LineItem>(); LineItem item = new LineItem(); item.setOrder(this); item.setProduct(product); item.setQuantity(quantity); item.setSubtotal(quantity * price); lineItems.add(item); total += quantity * price; } @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy = \"order\") public Collection<LineItem> getLineItems() { return lineItems; } public void setLineItems(Collection<LineItem> lineItems) { this.lineItems = lineItems; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb3; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.NamedQueries; import javax.persistence.NamedQuery; @Entity @NamedQueries( { @NamedQuery(name = \"findUserByUsername\", query = \"SELECT DISTINCT u FROM User AS u WHERE u.username = :username\") }) public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getId() { return id; } public void setPassword(String password) { this.password = password; } public boolean matchesPassword(String password) { return this.password.equals(password); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb3; import javax.ejb.Local; @Local public interface UserManager { User create(String username, String password); User findByUsername(String username); void remove(User user); void update(User user); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.entitybeans.ejb3; import javax.ejb.Stateless; import javax.persistence.EntityManager; import javax.persistence.PersistenceContext; import javax.persistence.Query; @Stateless public class UserManagerBean implements UserManager { @PersistenceContext private EntityManager em; public User create(String username, String password) { User user = new User(); user.setUsername(username); user.setPassword(password); em.persist(user); return user; } public User findByUsername(String username) { Query query = em.createNamedQuery(\"findUserByUsername\"); query.setParameter(\"username\", username); return (User) query.getSingleResult(); } public void remove(User user) { em.remove(user); } public void update(User user) { em.merge(user); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.messagedriven; import javax.annotation.Resource; import javax.ejb.ActivationConfigProperty; import javax.ejb.EJB; import javax.ejb.MessageDriven; import javax.jms.Message; import javax.jms.MessageListener; import javax.jms.ObjectMessage; import javax.jms.Queue; import javax.jms.QueueConnection; import javax.jms.QueueConnectionFactory; import javax.jms.QueueSender; import javax.jms.QueueSession; import javax.jms.Session; @MessageDriven(activationConfig = { @ActivationConfigProperty(propertyName = \"destinationType\", propertyValue = \"javax.jms.Queue\"), @ActivationConfigProperty(propertyName = \"destination\", propertyValue = \"queue/testQueue\") }) public class SearchListenerBean implements MessageListener { @EJB(beanInterface = SearchService.class) public SearchService searchService; @Resource(mappedName = \"QueueConnectionFactory\") public QueueConnectionFactory connectionFactory; @Resource(mappedName = \"queue/testQueue\", type = javax.jms.Queue.class) public Queue resultsQueue; public void onMessage(Message message) { try { ObjectMessage searchRequest = (ObjectMessage) message; String[] keywords = (String[]) searchRequest.getObject(); String[] results = searchService.search(keywords); QueueConnection connection = connectionFactory .createQueueConnection(); QueueSession session = connection.createQueueSession( false, Session.AUTO_ACKNOWLEDGE); QueueSender sender = session.createSender(resultsQueue); Message resultsMessage = session .createObjectMessage(results); sender.send(resultsMessage); connection.close(); } catch (Exception e) { throw new RuntimeException(e); } } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.messagedriven; import javax.ejb.Local; @Local public interface SearchService {  public String[] search(String[] keywords); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.messagedriven; import javax.annotation.PostConstruct; import javax.annotation.Resource; import javax.ejb.ActivationConfigProperty; import javax.ejb.EJB; import javax.ejb.MessageDriven; import javax.ejb.MessageDrivenContext; import javax.ejb.Timeout; import javax.ejb.Timer; import javax.jms.Message; import javax.jms.MessageListener; import javax.jms.Queue; import javax.jms.QueueConnectionFactory; @MessageDriven(activationConfig = { @ActivationConfigProperty(propertyName = \"destinationType\", propertyValue = \"javax.jms.Queue\"), @ActivationConfigProperty(propertyName = \"destination\", propertyValue = \"queue/testQueue\") }) public class TimerListenerBean implements MessageListener { @Resource public MessageDrivenContext ctx; @EJB(beanInterface = SearchService.class) public SearchService searchService; @Resource(mappedName = \"QueueConnectionFactory\") public QueueConnectionFactory connectionFactory; @Resource(mappedName = \"queue/testQueue\", type = javax.jms.Queue.class) public Queue resultsQueue; @PostConstruct public void ejbCreate() { System.out.println(\"MDB \" + toString() + \" created (\" + (ctx != null ? \"has\" : \"doesn't have\") + \" reference to MessageDrivenContext)\"); } public void onMessage(Message message) { try { String id = message.getJMSMessageID(); System.out.println(toString() + \" received JMS message \" + id + \" and started timer\"); ctx.getTimerService().createTimer(5000, id); } catch (Exception e) { e.printStackTrace(); } } @Timeout public void onTimeout(Timer timer) { System.out.println(toString() + \" received timeout callback: \" + timer.getInfo()); } public String toString() { String id = super.toString(); return id.substring(id.lastIndexOf('@')); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.calculator; import javax.ejb.Local; @Local public interface Calculator { public int add(int a, int b); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.calculator; import java.rmi.RemoteException; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import javax.annotation.Resource; import javax.ejb.EJBException; import javax.ejb.PostActivate; import javax.ejb.PrePassivate; import javax.ejb.SessionBean; import javax.ejb.SessionContext; import javax.ejb.Stateless; import javax.jms.Queue; import javax.jms.QueueConnection; import javax.jms.QueueConnectionFactory; import javax.jms.QueueSender; import javax.jms.QueueSession; import javax.jms.TextMessage; @Stateless public class CalculatorBean implements Calculator, SessionBean { @Resource(mappedName = \"QueueConnectionFactory\") private QueueConnectionFactory queueConnectionFactory; @Resource(mappedName = \"queue/testQueue\", type = javax.jms.Queue.class) private Queue salesQueue; public int add(int a, int b) { notifyJmsQueue(a, b); return a + b; } private void notifyJmsQueue(int a, int b) { try { QueueConnection connection = queueConnectionFactory .createQueueConnection(); QueueSession session = connection.createQueueSession( true, 10); QueueSender sender = session.createSender(salesQueue); TextMessage msg = session.createTextMessage(); msg.setText(\"add(\" + a + \", \" + b + \")\"); sender.send(msg); } catch (Throwable e) { } } public void setSessionContext(SessionContext ctx) throws EJBException, RemoteException { System.out.println(\"setSessionContext()\"); } @PreDestroy public void ejbRemove() { System.out.println(\"@PreDestroy / ejbRemove\"); } @PostActivate public void ejbActivate() { System.out.println(\"@PostActivate / ejbActivate\"); } @PrePassivate public void ejbPassivate() { System.out.println(\"@PrePassivate / ejbRemove\"); } @PostConstruct public void ejbCreate() { System.out.println(\"@PostConstruct: \" + toString()); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.mockjndi; public interface Account { }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.mockjndi; import javax.ejb.Local; @Local public interface DiscountService { int getDiscountPercentage(Account account); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.mockjndi; public class Price { private int cents; public Price(int cents) { this.cents = cents; } @Override public int hashCode() { return cents; } @Override public boolean equals(Object obj) { if (!(obj instanceof Price)) { return false; } Price other = (Price) obj; return other.cents == this.cents; } @Override public String toString() { return \"Price[\" + cents + \"]\"; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.mockjndi; import javax.ejb.Local; @Local public interface PricingService { Price discountedPrice(Product product, Account account); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.mockjndi; import javax.annotation.PostConstruct; import javax.ejb.EJB; import javax.ejb.Stateless; import javax.naming.InitialContext; import javax.naming.NamingException; @Stateless public class PricingServiceBean implements PricingService { @EJB(beanInterface = DiscountService.class) private DiscountService discountService; @EJB(beanInterface = DiscountService.class) public void setDiscountService(DiscountService impl) { this.discountService = impl; } @PostConstruct public void ejbCreate() { } public Price discountedPrice(Product product, Account account) { try { DiscountService discounts = getDiscountService(); int discount = discounts.getDiscountPercentage(account); float discountMultiplier = ((100 - discount) / 100.0f); return new Price((int) (product.getPrice() * discountMultiplier)); } catch (Exception e) { throw new RuntimeException(e); } } protected DiscountService getDiscountService() throws NamingException { if (discountService != null) { return discountService; } String jndiName = \"example/DiscountServiceBean/local\"; return (DiscountService) new InitialContext().lookup(jndiName); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.sessionbeans.mockjndi; public class Product { private String name; private int priceInCents; public Product(String name, int priceInCents) { this.name = name; this.priceInCents = priceInCents; } public String getName() { return name; } public int getPrice() { return priceInCents; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.util; import java.io.IOException; import java.sql.Connection; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.Statement; import java.util.ArrayList; import java.util.List; import javax.naming.InitialContext; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.sql.DataSource; public class SqlEditor extends HttpServlet { private DataSource datasource; @Override public void init(ServletConfig config) throws ServletException { lookupDataSource(); } private void lookupDataSource() { try { if (datasource == null) { InitialContext ctx = new InitialContext(); datasource = (DataSource) ctx .lookup(\"java:/DefaultDS\"); } } catch (Exception e) { throw new RuntimeException(e); } } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setAttribute(\"results\", new ArrayList()); render(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String sql = request.getParameter(\"sql\"); request.getSession(true).setAttribute(\"previousSQL\", sql); request.setAttribute(\"results\", executeQuery(sql)); render(request, response); } private List executeQuery(String sql) { List results = new ArrayList(); Connection c = null; try { c = datasource.getConnection(); Statement s = c.createStatement(); boolean success = s.execute(sql); if (success) { ResultSet rs = s.getResultSet(); results = toListOfLists(rs); } } catch (Exception e) { throw new RuntimeException(e); } finally { close(c); } return results; } private void close(Connection c) { try { if (c != null) { c.close(); } } catch (Exception ignored) { } } private List toListOfLists(ResultSet rs) throws Exception { ResultSetMetaData metaData = rs.getMetaData(); List<List<String>> results = new ArrayList<List<String>>(); List<String> headers = new ArrayList<String>(); for (int i = 1; i <= metaData.getColumnCount(); i++) { headers.add(metaData.getColumnLabel(i)); } results.add(headers); while (rs.next()) { List<String> row = new ArrayList<String>(); for (int i = 1; i <= metaData.getColumnCount(); i++) { row.add(rs.getString(i)); } results.add(row); } return results; } private void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { if (request.getSession(true).getAttribute(\"previousSQL\") == null) { request.getSession(true).setAttribute(\"previousSQL\", \"\"); } request.getRequestDispatcher(\"/sql.jsp\").forward(request, response); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.ejb3.util; import java.io.IOException; import java.lang.reflect.Method; import java.util.ArrayList; import javax.annotation.Resource; import javax.naming.InitialContext; import javax.persistence.EntityManager; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.tddinaction.ejb3.entitybeans.ejb3.User; import com.tddinaction.ejb3.entitybeans.ejb3.UserManager; public class UserEditor extends HttpServlet { @Resource(type = EntityManager.class, mappedName = \"java:/EntityManager\") private EntityManager em; private UserManager getUserManager() { try { InitialContext ctx = new InitialContext(); return (UserManager) ctx .lookup(\"calculator/UserManagerBean/local\"); } catch (Exception e) { throw new RuntimeException(e); } } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"UserEditor servlet has entity manager: \" + em); String action = request.getParameter(\"action\"); String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); request.setAttribute(\"message\", dispatch(action, username, password)); request.setAttribute(\"results\", new ArrayList()); request.setAttribute(\"previousSQL\", \"\"); render(request, response); } public String create(String username, String password) { getUserManager().create(username, password); return \"user \" + username + \" created\"; } public String remove(String username, String password) { User user = getUserManager().findByUsername(username); if (user == null) { return \"no such user: \" + username; } if (user.matchesPassword(password)) { getUserManager().remove(user); return \"user \" + username + \" removed\"; } else { return \"wrong password\"; } } public String changePassword(String username, String password) { User user = getUserManager().findByUsername(username); if (user == null) { return \"no such user: \" + username; } user.setPassword(password); getUserManager().update(user); return \"password changed for \" + username; } private String dispatch(String action, String username, String password) { if (action != null) { try { Method actionMethod = getClass().getMethod(action, new Class[] { String.class, String.class }); return (String) actionMethod.invoke(this, new Object[] { username, password }); } catch (NoSuchMethodException e) { return \"No such action: \" + action; } catch (Exception e) { throw new RuntimeException(e); } } return \"No action provided\"; } private void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.getRequestDispatcher(\"/sql.jsp\").forward(request, response); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.fs; import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import com.tddinaction.io.IO; public class DiskFileSystem implements FileSystem { private File mountPoint; public DiskFileSystem(File mountPoint) { this.mountPoint = mountPoint; } public void copy(String from, String to) throws IOException { requireExists(from); writeFile(to, readFileAsBytes(from)); } public void delete(String path) throws IOException { mapToFile(path).delete(); } public boolean exists(String path) { return mapToFile(path).exists(); } public void move(String from, String to) throws IOException { requireExists(from); mapToFile(from).renameTo(mapToFile(to)); } private void requireExists(String path) throws IOException { if (!mapToFile(path).exists()) { throw new IOException(path + \" does not exist.\"); } } public byte[] readFileAsBytes(String path) throws IOException { File target = mapToFile(path); FileInputStream src = new FileInputStream(target); byte[] content = IO.readIntoByteArray(src); src.close(); return content; } public Reader readFileAsReader(String path) throws IOException { return new InputStreamReader(readFileAsStream(path)); } public InputStream readFileAsStream(String path) throws IOException { File target = mapToFile(path); FileInputStream src = new FileInputStream(target); byte[] content = IO.readIntoByteArray(src); src.close(); return new ByteArrayInputStream(content); } public void writeFile(String path, byte[] content) throws IOException { writeFile(path, new ByteArrayInputStream(content)); } public void writeFile(String path, InputStream content) throws IOException { File target = mapToFile(path); target.getParentFile().mkdirs(); FileOutputStream out = new FileOutputStream(target); IO.pipe(content, out); out.close(); } public void writeFile(String path, Reader content) throws IOException { File target = mapToFile(path); target.getParentFile().mkdirs(); FileWriter out = new FileWriter(target); IO.pipe(content, out); out.close(); } private File mapToFile(String path) { return new File(mountPoint, path); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.fs; import java.io.IOException; import java.io.InputStream; import java.io.Reader; public interface FileSystem { void writeFile(String path, byte[] content) throws IOException; void writeFile(String path, InputStream content) throws IOException; void writeFile(String path, Reader content) throws IOException; byte[] readFileAsBytes(String path) throws IOException; InputStream readFileAsStream(String path) throws IOException; boolean exists(String path); void move(String from, String to) throws IOException; void copy(String from, String to) throws IOException; void delete(String path) throws IOException; Reader readFileAsReader(String path) throws IOException; }"}
{"name": "panterch/edu", "content": "package com.tddinaction.fs; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.PrintWriter; import java.io.Reader; import java.io.Writer; import java.util.HashMap; import java.util.Map; import com.tddinaction.io.IO; public class MemoryFileSystem implements FileSystem { private Map<String, byte[]> files = new HashMap<String, byte[]>(); public InputStream readAsStream(String path) { return new ByteArrayInputStream(files.get(path)); } public OutputStream openForWrite(final String path) { return new ByteArrayOutputStream() { public void close() { files.put(path, toByteArray()); } }; } public void writeFile(String path, byte[] content) throws IOException { OutputStream out = openForWrite(path); out.write(content); out.close(); } public void writeFile(String path, InputStream content) throws IOException { OutputStream out = openForWrite(path); IO.pipe(content, out); out.close(); } public void writeFile(String path, Reader content) throws IOException { Writer out = new PrintWriter(openForWrite(path)); IO.pipe(content, out); out.close(); } public byte[] readFileAsBytes(String path) throws IOException { InputStream in = readAsStream(path); byte[] content = IO.readIntoByteArray(in); in.close(); return content; } public InputStream readFileAsStream(String path) throws IOException { return readAsStream(path); } public Reader readFileAsReader(String path) throws IOException { return new InputStreamReader(readAsStream(path)); } public boolean exists(String path) { return files.containsKey(path); } public void move(String from, String to) throws IOException { requireFileToExist(from); files.put(to, files.get(from)); delete(from); } public void copy(String from, String to) throws IOException { requireFileToExist(from); files.put(to, files.get(from)); } public void delete(String path) throws IOException { files.remove(path); } private void requireFileToExist(String path) throws IOException { if (!exists(path)) { throw new IOException(\"File \" + path + \" does not exist.\"); } } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.io; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.Reader; import java.io.StringWriter; import java.io.Writer; public class IO { public static byte[] readIntoByteArray(InputStream in) throws IOException { ByteArrayOutputStream content = new ByteArrayOutputStream(); pipe(in, content); return content.toByteArray(); } public static void pipe(InputStream source, OutputStream destination) throws IOException { int r = -1; byte[] buffer = new byte[8096]; while ((r = source.read(buffer, 0, buffer.length)) != -1) { destination.write(buffer, 0, r); } } public static void pipe(Reader source, Writer destination) throws IOException { int r = -1; char[] buffer = new char[8096]; while ((r = source.read(buffer, 0, buffer.length)) != -1) { destination.write(buffer, 0, r); } } public static String readIntoString(Reader reader) throws IOException { StringWriter writer = new StringWriter(); pipe(reader, writer); return writer.toString(); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.j2ee.jms; import javax.jms.Message; import javax.jms.MessageListener; import javax.jms.ObjectMessage; import javax.jms.Queue; import javax.jms.QueueConnection; import javax.jms.QueueConnectionFactory; import javax.jms.QueueSender; import javax.jms.QueueSession; import javax.jms.Session; public class SearchListenerBean implements MessageListener { public SearchService searchService; public QueueConnectionFactory connectionFactory; public Queue resultsQueue; public void onMessage(Message message) { try { ObjectMessage searchRequest = (ObjectMessage) message; String[] keywords = (String[]) searchRequest.getObject(); String[] results = searchService.search(keywords); QueueConnection connection = connectionFactory .createQueueConnection(); QueueSession session = connection.createQueueSession( false, Session.AUTO_ACKNOWLEDGE); QueueSender sender = session.createSender(resultsQueue); message = session.createObjectMessage(results); sender.send(message); connection.close(); } catch (Exception e) { throw new RuntimeException(e); } } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.j2ee.jms; public interface SearchService { String[] search(String[] keywords); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.j2ee.web.controller.authenticator; public interface Authenticator { boolean isValidLogin(String username, String password); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.j2ee.web.controller.authenticator; public class FileBasedAuthenticator implements Authenticator { public boolean isValidLogin(String username, String password) { return false; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.j2ee.web.controller.servlet; import java.io.IOException; import java.io.PrintWriter; import java.util.Enumeration; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class EchoServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter writer = response.getWriter(); for (Enumeration e = request.getParameterNames(); e.hasMoreElements(); ) { String parameter = String.valueOf(e.nextElement()); String[] values = request.getParameterValues(parameter); for (int i = 0; i < values.length; i++) { writer.write(parameter + \"=\" + values[i]); writer.write(\"\\n\"); } } writer.close(); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.j2ee.web.controller.servlet; import java.io.IOException; import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.tddinaction.j2ee.web.controller.authenticator.Authenticator; public class LoginServlet extends HttpServlet { "}
{"name": "panterch/edu", "content": "package com.tddinaction.j2ee.web.controller.spring; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import com.tddinaction.j2ee.web.controller.authenticator.Authenticator; public class LoginController implements Controller { private Authenticator authenticator; public void setAuthenticator(Authenticator authenticator) { this.authenticator = authenticator; } public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { String user = request.getParameter(\"j_username\"); String pass = request.getParameter(\"j_password\"); if (authenticator.isValidLogin(user, pass)) { return new ModelAndView(\"frontpage\"); } return new ModelAndView(\"wrongpassword\"); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.mockobjects; public class Customer { private float balance; public Customer(float startingBalance) { this.balance = startingBalance; } public float getBalance() { return balance; } public void setBalance(float newBalance) { this.balance = newBalance; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.mockobjects;  public class Order { private Customer customer; private Product product; public Order(Customer customer, Product product) { this.customer = customer; this.product = product; } public Product getProduct() { return product; } public Customer getCustomer() { return customer; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.mockobjects; public class OrderProcessor { private PricingService pricingService; public void setPricingService(PricingService service) { this.pricingService = service; } public void process(Order order) { float discountPercentage = pricingService.getDiscountPercentage(order .getCustomer(), order.getProduct()); float discountedPrice = order.getProduct().getPrice() * (1 - (discountPercentage / 100)); order.getCustomer().setBalance( order.getCustomer().getBalance() - discountedPrice); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.mockobjects; public class PricingService { public float getDiscountPercentage(Customer c, Product p) { return 10.0f; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.mockobjects; public class Product { private float price; private String name; public Product(String name, float price) { this.name = name; this.price = price; } public String getName() { return name; } public float getPrice() { return price; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.common; import java.awt.Color; public abstract class Colors { public static Color getDefault() { return Color.GRAY; } public static Color testsPassed() { return Color.GREEN; } public static Color testsFailed() { return Color.RED; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.common; public interface GreenBarModel { void runTests(); int numberOfTests(); int numberOfFailures(); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.common; public interface GreenBarView { public void addRunButtonListener(RunButtonListener listener); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.common; public interface RunButtonListener { void onRunButtonClick(); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.pv; import java.awt.Color; import com.tddinaction.swing.mvp.common.GreenBarView; public interface GreenBarPassiveView extends GreenBarView { public void setBarColor(Color color); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.pv; import java.awt.Color; import com.tddinaction.swing.mvp.common.Colors; import com.tddinaction.swing.mvp.common.GreenBarModel; import com.tddinaction.swing.mvp.common.RunButtonListener; public class GreenBarPresenter { private final GreenBarPassiveView view; private final GreenBarModel model; public GreenBarPresenter(final GreenBarPassiveView view, final GreenBarModel model) { this.view = view; this.model = model; view.addRunButtonListener(new RunButtonListener() { public void onRunButtonClick() { model.runTests(); updateView(); } }); view.setBarColor(Colors.getDefault()); } private void updateView() { Color newColor = (model.numberOfFailures() == 0 ? Colors .testsPassed() : Colors.testsFailed()); view.setBarColor(newColor); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.pv; import java.awt.Color; import java.awt.Component; import java.awt.Dimension; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.Box; import javax.swing.JButton; import javax.swing.JPanel; import com.tddinaction.swing.mvp.common.RunButtonListener; public class GreenBarViewImpl extends JPanel implements GreenBarPassiveView { private RunButtonListener listener; private JPanel bar; public GreenBarViewImpl() { add(createRunButton()); add(createBar()); } private Component createRunButton() { JButton button = new JButton(\"Run\"); button.setName(\"run_button\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { listener.onRunButtonClick(); } }); return button; } private Component createBar() { bar = new JPanel(); bar.setName(\"bar\"); bar.add(Box.createRigidArea(new Dimension(200, 20))); return bar; } public void setBarColor(Color color) { bar.setBackground(color); bar.setForeground(color); } public void addRunButtonListener(RunButtonListener listener) { this.listener = listener; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.sc; import com.tddinaction.swing.mvp.common.GreenBarModel; import com.tddinaction.swing.mvp.common.GreenBarView; import com.tddinaction.swing.mvp.common.RunButtonListener; public class GreenBarController { private final GreenBarModel model; private final GreenBarObservingView view; public GreenBarController(GreenBarObservingView view, GreenBarModel model) { this.view = view; this.model = model; registerForUserGestures(view); updateView(); } private void registerForUserGestures(GreenBarView view) { view.addRunButtonListener(new RunButtonListener() { public void onRunButtonClick() { model.runTests(); updateView(); } }); } private void updateView() { view.update(model); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.mvp.sc; import com.tddinaction.swing.mvp.common.GreenBarModel; import com.tddinaction.swing.mvp.common.GreenBarView; public interface GreenBarObservingView extends GreenBarView { void update(GreenBarModel model); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.model; import java.awt.Point; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class PlotMapModel { private List<Point> plots = new ArrayList<Point>(); public void add(Point plot) { plots.add(plot); } public void remove(Point plot) { plots.remove(plot); } public List<Point> points() { return Collections.unmodifiableList(plots); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Color; import java.awt.Component; import java.awt.Graphics2D; import java.awt.image.BufferedImage; import java.awt.image.Raster; public class Bitmap { public static Raster of(Component c) throws Exception { BufferedImage image = new BufferedImage(c.getWidth(), c .getHeight(), BufferedImage.TYPE_INT_RGB); Graphics2D graphics = image.createGraphics(); graphics.setColor(Color.WHITE); graphics.fillRect(0, 0, c.getWidth(), c.getHeight()); c.paint(graphics); graphics.dispose(); return image.getRaster(); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Color; import java.awt.image.Raster; import static org.junit.Assert.*; public class Pixel { public interface PixelAssertion { void shouldBe(Color color); boolean is(Color color); } private final Raster raster; public static Pixel in(Raster raster) { return new Pixel(raster); } private Pixel(Raster raster) { this.raster = raster; } public PixelAssertion at(final int x, final int y) { return new PixelAssertion() { public void shouldBe(Color color) { assertPixelColor(x, y, color); } public boolean is(Color color) { return color.equals(getPixelColor(x, y)); } }; } public PixelAssertion around(final int x, final int y) { return new PixelAssertion() { public void shouldBe(Color color) { for (int x2 = x - 1; x2 < x + 1; x2++) { for (int y2 = y - 1; y2 < y + 1; y2++) { if (x2 != x || y2 != y) { assertPixelColor(x2, y2, color); } } } } public boolean is(Color black) { for (int x2 = x - 1; x2 < x + 1; x2++) { for (int y2 = y - 1; y2 < y + 1; y2++) { if (x2 != x || y2 != y) { return false; } } } return true; } }; } private void assertPixelColor(int x, int y, Color expected) { Color actual = getPixelColor(x, y); assertEquals(\"(\" + x + \",\" + y + \").\", expected, actual); } private Color getPixelColor(int x, int y) { int[] pixel = raster.getPixel(x, y, new int[3]); return new Color(pixel[0], pixel[1], pixel[2]); } public static void assertPixelColor(Raster raster, int x, int y, Color expected) { Color actual = getPixelColor(raster, x, y); assertEquals(\"(\" + x + \",\" + y + \").\", expected, actual); } public static Color getPixelColor(Raster raster, int x, int y) { int[] pixel = raster.getPixel(x, y, new int[3]); return new Color(pixel[0], pixel[1], pixel[2]); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Color; import java.awt.Point; import java.awt.image.Raster; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import org.junit.Assert; import com.tddinaction.swing.plotmap.view.Pixel.PixelAssertion; public class Pixels { public static class PixelRangeAssertion { private final Raster raster; private int startX; private int startY; public PixelRangeAssertion(Raster raster) { this.raster = raster; } PixelRangeAssertion between(int x, int y) { this.startX = x; this.startY = y; return this; } PixelAssertion and(final int targetX, final int targetY) { return new PixelAssertion() { class PixelFinder { private final Set<Point> visited; private final Point target; private final Color color; public PixelFinder(Set<Point> visited, Point target, Color color) { this.visited = visited; this.target = target; this.color = color; } public boolean isConnectedTo( List<Point> siblingPoints) { for (Point p : siblingPoints) { if (p.x == targetX && p.y == targetY) { return true; } if (visited.contains(p)) { continue; } visited.add(p); if (Pixel.in(raster).at(p.x, p.y).is( color)) { PixelFinder recursiveFinder = new PixelFinder( visited, target, color); return recursiveFinder .isConnectedTo(Pixels .around(p)); } } return false; } } public void shouldBe(Color color) { Assert.assertTrue(\"No connecting pixels of \" + color + \" between (\" + startX + \",\" + startY + \") and (\" + targetX + \",\" + targetY + \")\", is(color)); } public boolean is(Color color) { Set<Point> visited = new HashSet<Point>(); visited.add(new Point(startX, startY)); List<Point> siblingPoints = Pixels .around(new Point(startX, startY)); return new PixelFinder(visited, new Point( targetX, targetY), color) .isConnectedTo(siblingPoints); } }; }; } public static PixelRangeAssertion in(final Raster raster) { return new PixelRangeAssertion(raster); } public static List<Point> around(Point point) { List<Point> points = new ArrayList<Point>(); for (int x2 = point.x - 1; x2 <= point.x + 1; x2++) { for (int y2 = point.y - 1; y2 <= point.y + 1; y2++) { if (x2 != point.x || y2 != point.y) { points.add(new Point(x2, y2)); } } } return points; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Point; public interface PlotAdditionListener { void plotWasAdded(Point plot); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Point; public interface PlotMapCanvas { void plot(Point point); void clear(); void addRemoveListener(PointEventListener listener); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Canvas; import java.awt.Color; import java.awt.Graphics; import java.awt.Point; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.util.ArrayList; import java.util.List; public class PlotMapCanvasImpl extends Canvas implements PlotMapCanvas { private List<Point> plots = new ArrayList<Point>(); public PlotMapCanvasImpl() { setSize(200, 100); setBackground(Color.WHITE); } public void clear() { } public void plot(Point point) { plots.add(point); } @Override public void paint(Graphics g) { g.setColor(Color.BLACK); Point previous = null; for (Point p : plots) { if (previous == null) { previous = p; } g.drawLine(previous.x, previous.y, p.x, p.y); previous = p; } } public void addRemoveListener(final PointEventListener listener) { addMouseListener(new MouseAdapter() { public void mouseClicked(MouseEvent e) { Point point = e.getPoint(); if (plots.contains(point)) { listener.onPointEvent(point); } } }); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import com.tddinaction.swing.plotmap.model.PlotMapModel; public interface PlotMapView { void registerAdditionListener(PlotAdditionListener listener); void registerRemovalListener(PlotRemovalListener listener); void drawPlotMap(PlotMapModel model); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Point; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JPanel; import javax.swing.JTextField; import com.tddinaction.swing.plotmap.model.PlotMapModel; public class PlotMapViewImpl extends JPanel implements PlotMapView { private PlotAdditionListener additionListener; private JTextField xCoordField, yCoordField; private JButton addButton; private PlotMapCanvas canvas; public PlotMapViewImpl() { createWidgets(); add(xCoordField); add(yCoordField); add(addButton); } private void createWidgets() { xCoordField = createTextField(\"x_coord_textfield\"); yCoordField = createTextField(\"y_coord_textfield\"); addButton = new JButton(); addButton.setName(\"add_button\"); addButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { int x = valueAsInt(xCoordField); int y = valueAsInt(yCoordField); additionListener.plotWasAdded(new Point(x, y)); } }); canvas = createCanvas(); } protected PlotMapCanvas createCanvas() { return new PlotMapCanvasImpl(); } private int valueAsInt(JTextField field) { return Integer.parseInt(field.getText()); } private JTextField createTextField(String name) { JTextField field = new JTextField(); field.setName(name); return field; } public void registerAdditionListener(PlotAdditionListener listener) { this.additionListener = listener; } public void registerRemovalListener(PlotRemovalListener listener) { "}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Point; public interface PlotRemovalListener { void plotWasRemoved(Point plot); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.swing.plotmap.view; import java.awt.Point; public interface PointEventListener { void onPointEvent(Point point); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.template;  public class MissingValueException extends RuntimeException { public MissingValueException() { } public MissingValueException(String message) { super(message); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.template; import java.util.Map; public class PlainText implements Segment { private String text; public PlainText(String text) { this.text = text; } public boolean equals(Object other) { return text.equals(((PlainText) other).text); } public String evaluate(Map<String, String> variables) { return text; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.template; import java.util.Map; public interface Segment { public String evaluate(Map<String, String> variables); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.template; import java.util.HashMap; import java.util.List; import java.util.Map; public class Template { private Map<String, String> variables; private String templateText; public Template(String templateText) { this.variables = new HashMap<String, String>(); this.templateText = templateText; } public void set(String name, String value) { this.variables.put(name, value); } public String evaluate() { TemplateParse p = new TemplateParse(); List<Segment> segments = p.parseSegments(templateText); return concatenate(segments); } private String concatenate(List<Segment> segments) { StringBuffer result = new StringBuffer(); for (Segment segment : segments) { result.append(segment.evaluate(variables)); } return result.toString(); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.template; import java.util.ArrayList; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern; public class TemplateParse { public List<Segment> parseSegments(String template) { List<Segment> segments = new ArrayList<Segment>(); List<String> strings = parse(template); for (String s : strings) { if (isVariable(s)) { String name = s.substring(2, s.length() - 1); segments.add(new Variable(name)); } else { segments.add(new PlainText(s)); } } return segments; } private boolean isVariable(String segment) { return segment.startsWith(\"${\") && segment.endsWith(\"}\"); } public List<String> parse(String template) { List<String> segments = new ArrayList<String>(); int index = collectSegments(template, segments, 0); addTail(segments, template, index); return segments; } private int collectSegments(String src, List<String> segs, int index) { Pattern pattern = Pattern.compile(\"\\\\$\\\\{[^}]*\\\\}\"); Matcher matcher = pattern.matcher(src); while (matcher.find()) { addPrecedingPlainText(segs, src, matcher, index); addVariable(segs, src, matcher); index = matcher.end(); } return index; } private void addTail(List<String> segs, String src, int index) { if (index < src.length()) segs.add(src.substring(index)); } private void addVariable(List<String> segs, String src, Matcher m) { segs.add(src.substring(m.start(), m.end())); } private void addPrecedingPlainText(List<String> segs, String src, Matcher matcher, int index) { if (index != matcher.start()) { segs.add(src.substring(index, matcher.start())); } } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.template; import java.util.Map; public class Variable implements Segment { private String name; public Variable(String name) { this.name = name; } public boolean equals(Object other) { return name.equals(((Variable) other).name); } public String evaluate(Map<String, String> variables) { if (!variables.containsKey(name)) { throw new MissingValueException(\"No value for ${\" + name + \"}\"); } return variables.get(name); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.time.abstraction; import java.util.Calendar; import java.util.Date;  public class SystemTime { private static TimeSource defaultSource = new TimeSource() { public long millis() { return System.currentTimeMillis(); } }; private static TimeSource source = defaultSource; public static long asMillis() { return getTimeSource().millis(); } public static Calendar asCalendar() { Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(getTimeSource().millis()); return cal; } public static Date asDate() { return new Date(getTimeSource().millis()); } public static void reset() { setTimeSource(null); } public static void setTimeSource(TimeSource source) { SystemTime.source = source; } private static TimeSource getTimeSource() { return (source != null ? source : defaultSource); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.time.abstraction; public interface TimeSource {  long millis(); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.time.logging; import java.text.DateFormat; import java.text.SimpleDateFormat; import javax.servlet.http.HttpServletRequest; import com.tddinaction.time.abstraction.SystemTime; public class HttpRequestLogFormatter { public static DateFormat dateFormat = new SimpleDateFormat( \"dd/MMM/yyyy:HH:mm:ss Z\"); public String format(HttpServletRequest request, int httpStatus, int contentLength) { StringBuffer line = new StringBuffer(); line.append(request.getRemoteAddr()); line.append(\" - \"); line.append(request.getRemoteUser()); line.append(\" [\"); line.append(dateFormat.format(SystemTime.asDate())); line.append(\"] \\\"\").append(request.getMethod()); line.append(\" \").append(request.getRequestURI()); line.append(\" \").append(request.getProtocol()); line.append(\"\\\" \").append(httpStatus); line.append(\" \").append(contentLength); return line.toString(); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.auth; public interface Authenticator { boolean authenticate(String username, String password); }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.auth; import java.util.HashMap; import java.util.Map; public class InMemoryAuthenticator implements Authenticator { private Map<String, String> validLogins = new HashMap<String, String>(); public boolean authenticate(String username, String password) { return validLogins.containsKey(username) && validLogins.get(username).equals(password); } public void setValidUsers(Map<String, String> users) { validLogins.putAll(users); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.normal; import org.apache.wicket.markup.html.form.Form; import org.apache.wicket.markup.html.form.PasswordTextField; import org.apache.wicket.markup.html.form.TextField; import org.apache.wicket.model.CompoundPropertyModel; public class LoginForm extends Form { public LoginForm(String name) { super(name, new CompoundPropertyModel(new LoginInfo())); add(new TextField(\"j_username\")); add(new PasswordTextField(\"j_password\")); } @Override protected void onSubmit() { LoginInfo login = (LoginInfo) getModelObject(); "}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.normal; import java.io.Serializable; public class LoginInfo implements Serializable { private String username; private String password; public String getJ_username() { return username; } public void setJ_username(String username) { this.username = username; } public String getJ_password() { return password; } public void setJ_password(String password) { this.password = password; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.normal; import org.apache.wicket.markup.html.WebPage; public class LoginPage extends WebPage { public LoginPage() { add(new LoginForm(\"login_form\")); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.normal; import org.apache.wicket.markup.html.WebPage; import org.apache.wicket.markup.html.basic.Label; import org.apache.wicket.markup.html.link.PageLink; public class MyHomePage extends WebPage { public MyHomePage() { add(new Label(\"welcomeMessage\", \"Welcome to the home page!\")); add(new PageLink(\"linkToLoginPage\", LoginPage.class)); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.normal; import org.apache.wicket.Page; import org.apache.wicket.protocol.http.WebApplication; public class MyWicketApp extends WebApplication { public MyWicketApp() { } @Override public Class<? extends Page> getHomePage() { return MyHomePage.class; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.spring; import org.apache.wicket.injection.web.InjectorHolder; import org.apache.wicket.markup.html.WebPage; public abstract class BasePage extends WebPage { public BasePage() { InjectorHolder.getInjector().inject(this); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.spring; import org.apache.wicket.injection.web.InjectorHolder; import org.apache.wicket.markup.html.form.Form; import org.apache.wicket.markup.html.form.PasswordTextField; import org.apache.wicket.markup.html.form.TextField; import org.apache.wicket.model.CompoundPropertyModel; import org.apache.wicket.spring.injection.annot.SpringBean; import com.tddinaction.wicket.auth.Authenticator; public class LoginForm extends Form { @SpringBean(name = \"authenticator\") private Authenticator auth; public void setSetterAuthenticator(Authenticator authenticator) { System.out.println(\"setter injection happened with an \" + authenticator.getClass().getName()); } public LoginForm(String name) { super(name, new CompoundPropertyModel(new LoginInfo())); InjectorHolder.getInjector().inject(this); add(new TextField(\"j_username\")); add(new PasswordTextField(\"j_password\")); System.out.println(\"LoginForm was created with authenticator \" + auth); } @Override protected void onSubmit() { LoginInfo login = (LoginInfo) getModelObject(); String username = login.getJ_username(); String password = login.getJ_password(); if (auth.authenticate(username, password)) { getPage().setResponsePage(MyHomePage.class); } } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.spring; import java.io.Serializable; public class LoginInfo implements Serializable { private String username; private String password; public String getJ_username() { return username; } public void setJ_username(String username) { this.username = username; } public String getJ_password() { return password; } public void setJ_password(String password) { this.password = password; } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.spring; public class LoginPage extends BasePage { public LoginPage() { add(new LoginForm(\"login_form\")); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.spring; import org.apache.wicket.markup.html.WebPage; import org.apache.wicket.markup.html.basic.Label; import org.apache.wicket.markup.html.link.PageLink; public class MyHomePage extends WebPage { public MyHomePage() { add(new Label(\"welcomeMessage\", \"Welcome!\")); add(new PageLink(\"linkToLoginPage\", LoginPage.class)); } }"}
{"name": "panterch/edu", "content": "package com.tddinaction.wicket.spring; import org.apache.wicket.Page; import org.apache.wicket.spring.SpringWebApplication; import org.apache.wicket.spring.injection.annot.SpringComponentInjector; import com.tddinaction.wicket.auth.Authenticator; public class MyWicketApp extends SpringWebApplication { public MyWicketApp() { } @Override protected void init() { super.init(); SpringComponentInjector i = new SpringComponentInjector(this); addComponentInstantiationListener(i); } @Override public Class<? extends Page> getHomePage() { return MyHomePage.class; } public Authenticator getAuthenticator() { return (Authenticator) internalGetApplicationContext() .getBean(\"authenticator\"); } }"}
{"name": "panterch/edu", "content": "package ch.panter.edu.parser; import java.io.Reader; import java.io.Writer; public interface HtmlParser { public abstract void parse(Reader input, Writer output) throws Exception; public abstract Reader getInput(); public abstract void setInput(Reader input); public abstract Writer getOutput(); public abstract void setOutput(Writer output); }"}
{"name": "panterch/edu", "content": " package ch.panter.edu.parser; import java.io.Reader; import java.io.Writer;  public class HtmlParser00 implements HtmlParser { Reader input; Writer output;  public void parse(Reader input, Writer output) throws Exception { this.input = input; this.output = output; int c; while (-1 != (c = input.read())) { output.write(c); } } "}
{"name": "panterch/edu", "content": " package ch.panter.edu.parser; import java.io.Reader; import java.io.Writer;  public class HtmlParser01 implements HtmlParser { enum STATE { UNKNOWN, IN_BODY } private STATE state = STATE.UNKNOWN; private StringBuilder buf = null; private char c; private int cnt = 0; Reader input; Writer output;  public void parse (Reader input, Writer output) throws Exception { this.input = input; this.output = output; int i; while (-1 != (i = input.read())) { this.c = (char)i; this.cnt++; switch (this.state) { case IN_BODY: this.handleInBody(); break; default: this.handleUnknown(); break; } } } private void handleUnknown() throws Exception { "}
{"name": "panterch/edu", "content": " package ch.panter.edu.parser; import java.io.Reader; import java.io.Writer;  public class HtmlParser02 implements HtmlParser { enum STATE { UNKNOWN, IN_TAG } private STATE state = STATE.UNKNOWN; private StringBuilder buf = null; private char c; private int cnt = 0; private int stack = 0; Reader input; Writer output;  public void parse (Reader input, Writer output) throws Exception { this.input = input; this.output = output; int i; while (-1 != (i = input.read())) { this.c = (char)i; this.cnt++; switch (this.state) { case IN_TAG: this.handleInTag(); break; default: this.handleUnknown(); break; } } } private void handleInTag() throws Exception { "}
{"name": "panterch/edu", "content": "package ch.fhzh.info2.document; import java.io.Serializable; import java.util.Calendar; import java.util.Currency; import java.util.List;  public interface Document extends Serializable {  public static enum Type { INVOICE, ORDER, BASKET,  TEST }  public abstract void addItem(Item item);  public abstract Currency getCur();  public abstract void setCur(Currency cur);  public abstract String getId();  public abstract void setId(String id);  public abstract List<Item> getItems();  public abstract void setItems(List<Item> items);  public abstract String getReference();  public abstract void setReference(String reference);  public abstract long getTotalCent();  public abstract void setTotalCent(long totalCent);  public abstract Type getType();  public abstract void setType(Type type);  public String getPrintRepresentation();  public void setPrintRepresentation(String printRepresentation);  public Calendar getModTime();  public void setModTime(Calendar modTime); }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.document; import java.io.Serializable; import java.util.ArrayList; import java.util.Calendar; import java.util.Currency; import java.util.List;  public class DocumentImpl implements Document, Serializable {  private String printRepresentation;  private Type type;  private String id;  private Calendar modTime;  private String reference;  private List<Item> items;  private Currency cur;  private long totalCent;  public DocumentImpl() { super(); this.items = new ArrayList<Item>(); }  public void addItem(Item item) { this.items.add(item); }  public Currency getCur() { return cur; }  public void setCur(Currency cur) { this.cur = cur; }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public List<Item> getItems() { return items; }  public void setItems(List<Item> items) { this.items = items; }  public String getReference() { return reference; }  public void setReference(String reference) { this.reference = reference; }  public long getTotalCent() { return totalCent; }  public void setTotalCent(long totalCent) { this.totalCent = totalCent; }  public Type getType() { return type; }  public void setType(Type type) { this.type = type; }  public String getPrintRepresentation() { return printRepresentation; }  public void setPrintRepresentation(String printRepresentation) { this.printRepresentation = printRepresentation; }  public Calendar getModTime() { return modTime; }  public void setModTime(Calendar modTime) { this.modTime = modTime; } }"}
{"name": "panterch/edu", "content": "package ch.fhzh.info2.document; import java.io.Serializable; import java.util.Currency;  public interface Item extends Serializable {  public abstract long getCent();  public abstract void setCent(long cent);  public abstract Currency getCur();  public abstract void setCur(Currency cur);  public abstract String getDesc();  public abstract void setDesc(String desc);  public abstract String getId();  public abstract void setId(String id);  public abstract String getOrderNo();  public abstract void setOrderNo(String orderNo); }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.document; import java.io.Serializable; import java.util.Currency;  public class ItemImpl implements Item, Serializable {  private String id;  private String desc;  private String orderNo;  private long cent;  private Currency cur;  public long getCent() { return cent; }  public void setCent(long cent) { this.cent = cent; }  public Currency getCur() { return cur; }  public void setCur(Currency cur) { this.cur = cur; }  public String getDesc() { return desc; }  public void setDesc(String desc) { this.desc = desc; }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getOrderNo() { return orderNo; }  public void setOrderNo(String orderNo) { this.orderNo = orderNo; }  @Override public int hashCode() { final int PRIME = 31; int result = 1; result = PRIME * result + (int) (cent ^ (cent >>> 32)); result = PRIME * result + ((cur == null) ? 0 : cur.hashCode()); result = PRIME * result + ((desc == null) ? 0 : desc.hashCode()); result = PRIME * result + ((id == null) ? 0 : id.hashCode()); result = PRIME * result + ((orderNo == null) ? 0 : orderNo.hashCode()); return result; }  @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; final ItemImpl other = (ItemImpl) obj; if (cent != other.cent) return false; if (cur == null) { if (other.cur != null) return false; } else if (!cur.equals(other.cur)) return false; if (desc == null) { if (other.desc != null) return false; } else if (!desc.equals(other.desc)) return false; if (id == null) { if (other.id != null) return false; } else if (!id.equals(other.id)) return false; if (orderNo == null) { if (other.orderNo != null) return false; } else if (!orderNo.equals(other.orderNo)) return false; return true; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor; import ch.fhzh.info2.document.Document;  public interface DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException; }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor;  public class DocumentProcessorException extends Exception {  public DocumentProcessorException() { super(); "}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.client; import java.util.Currency; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.xml.XmlBeanFactory; import org.springframework.core.io.ClassPathResource; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.document.Item; import ch.fhzh.info2.document.Document.Type; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class Client {  public static void main(String[] args) throws DocumentProcessorException { new Client().run(); } private Currency chf = Currency.getInstance(\"CHF\"); public void run() throws DocumentProcessorException {  ClassPathResource resource = new ClassPathResource(\"spring.xml\"); BeanFactory factory = new XmlBeanFactory(resource);  Document doc = (Document)factory.getBean(\"doc\"); doc.setType(Type.ORDER); doc.setCur(chf); doc.setReference(\"client document\"); doc.setId(\"123\"); Item item = (Item)factory.getBean(\"item\"); item.setCur(chf); item.setCent(1230l); item.setId(\"123\"); item.setDesc(\"ein item\"); doc.addItem(item);  DocumentProcessor proc = (DocumentProcessor)factory.getBean(\"chain\"); doc = proc.processDocument(doc); } }"}
{"name": "panterch/edu", "content": "package ch.fhzh.info2.processor.client; import java.io.IOException; import java.util.Properties; import org.springframework.core.io.ClassPathResource; public class ResourceClient { public static void main(String[] args) throws IOException { ClassPathResource res = new ClassPathResource(\"res.properties\"); Properties properties = new Properties(); properties.load(res.getInputStream()); String mode = properties.getProperty(\"mode\"); System.out.print(\"mode is [\"+mode+\"]\\n\"); } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.calc; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.document.Item; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class DocumentTotalizer implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { long total = 0; for (Item item : doc.getItems()) {  if (!doc.getCur().equals(item.getCur())) { throw new DocumentProcessorException(\"currency does not match\"); } total += item.getCent(); } doc.setTotalCent(total); return doc; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.calc; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class TaxAdder implements DocumentProcessor {  private double taxRate = 0.0d; public Document processDocument(Document doc) throws DocumentProcessorException { double total = doc.getTotalCent(); total += taxRate * doc.getTotalCent(); doc.setTotalCent(Math.round(total)); return doc; }  public double getTaxRate() { return taxRate; }  public void setTaxRate(double taxRate) { this.taxRate = taxRate; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.clean; import java.util.List; import java.util.ArrayList; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.document.Item; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class CurrencyDefense implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { List<Item>valid = new ArrayList<Item>(); for (Item item : doc.getItems()) { if (!doc.getCur().equals(item.getCur())) { continue; } valid.add(item); } doc.setItems(valid); return doc; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.clean; import java.util.ArrayList; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.document.Item; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class DocumentCleaner implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { if (null == doc.getItems()) { doc.setItems(new ArrayList<Item>()); } doc.getItems().clear(); return doc; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.common; import java.util.List; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class ChainDocumentProcessor implements DocumentProcessor {  private List<DocumentProcessor> processors;  public Document processDocument(Document doc) throws DocumentProcessorException { "}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.common; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.document.DocumentImpl; import ch.fhzh.info2.document.Item; import ch.fhzh.info2.document.ItemImpl; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class CopyDocumentProcessor implements DocumentProcessor {  public Document processDocument(Document orig) throws DocumentProcessorException { Document copy = new DocumentImpl(); copy.setId(orig.getId()); "}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.common; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class NoopDocumentProcessor implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { return doc; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.common; import java.util.Calendar; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class TouchDocumentProcessor implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { doc.setModTime(Calendar.getInstance()); return doc; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.common; import java.util.Map; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class TypeAwareDocumentProcessor implements DocumentProcessor {  private DocumentProcessor defaultProcessor;  private Map<String, DocumentProcessor> typeProcessors;  public Document processDocument(Document doc) throws DocumentProcessorException { Document.Type dt = doc.getType(); "}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.email; import org.apache.commons.mail.EmailException; import org.apache.commons.mail.SimpleEmail; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class EmailSendingProcessor implements DocumentProcessor {  private String hostName;  private String to;  private String from; public Document processDocument(Document doc) throws DocumentProcessorException { SimpleEmail email = new SimpleEmail(); email.setHostName(hostName); try { email.addTo(to); email.setFrom(from); email.setSubject(\"Document\"); email.setMsg(doc.getPrintRepresentation()); email.send(); } catch (EmailException e) { throw new DocumentProcessorException(e); } return doc; }  public String getFrom() { return from; }  public void setFrom(String from) { this.from = from; }  public String getHostName() { return hostName; }  public void setHostName(String hostName) { this.hostName = hostName; }  public String getTo() { return to; }  public void setTo(String to) { this.to = to; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.print; import org.apache.commons.lang.builder.ToStringBuilder; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class CommonsLangPrinter implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { String repr = ToStringBuilder.reflectionToString(doc); doc.setPrintRepresentation(repr); return doc; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.print; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.document.Item; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class DocumentPrinter implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { StringBuilder repr = new StringBuilder(); repr.append(doc.getClass().getSimpleName()); repr.append(' '); if (null != doc.getId()) { repr.append(doc.getId()); repr.append(' '); } if (null != doc.getType()) { repr.append(doc.getType()); repr.append(' '); } if (null != doc.getModTime()) { repr.append('\\n'); repr.append(doc.getModTime().getTime()); } repr.append('\\n'); for (Item item : doc.getItems()) { repr.append('\\n'); repr.append(item.getId()); repr.append(' '); repr.append(item.getDesc()); repr.append(' '); repr.append(item.getCent()); repr.append(item.getCur()); } repr.append('\\n'); repr.append('\\n'); repr.append(\"Total:\"); repr.append(doc.getTotalCent()); repr.append(doc.getCur()); doc.setPrintRepresentation(repr.toString()); return doc; } }"}
{"name": "panterch/edu", "content": " package ch.fhzh.info2.processor.impl.print; import org.apache.commons.lang.builder.ToStringBuilder; import org.springframework.core.style.ToStringCreator; import ch.fhzh.info2.document.Document; import ch.fhzh.info2.processor.DocumentProcessor; import ch.fhzh.info2.processor.DocumentProcessorException;  public class SpringPrinter implements DocumentProcessor {  public Document processDocument(Document doc) throws DocumentProcessorException { ToStringCreator creator = new ToStringCreator(doc); creator.append(\"id\", doc.getId()); creator.append(\"type\", doc.getType()); creator.append(\"reference\", doc.getReference()); doc.setPrintRepresentation(creator.toString()); return doc; } }"}
{"name": "panterch/edu", "content": "package ch.fhzh.info2.currencyconverter; import ch.fhzh.info2.currencyconverter.impl.StaticCurrencyConverter; public class Driver { public static void main(String[] args) { ICurrencyConverter converter = new StaticCurrencyConverter(); Money chf = new Money(100, \"CHF\"); Money usd = converter.convert(chf, \"USD\"); System.out.println(\"Converted \" + chf + \" to \" + usd); } }"}
