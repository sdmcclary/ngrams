public class NativeObjectsReader2 { private class FunctionDocumentationPair { private IObject _function ; private FunctionDocumentation _documentation ; private String _typeName ; public FunctionDocumentationPair ( IObject function , FunctionDocumentation documentation ) { this . _function = function ; this . _documentation = documentation ; this . _typeName = this . _documentation . getName ( ) ; } public boolean equals ( Object obj ) { boolean result = false ; if ( obj == this ) { result = true ; } else if ( obj instanceof FunctionDocumentation ) { ( ( FunctionDocumentation ) obj ) . getName ( ) . equals ( this . getTypeName ( ) ) ; } return result ; } public FunctionDocumentation getDocumentation ( ) { return this . _documentation ; } public IObject getFunction ( ) { return this . _function ; } public String [ ] getSuperTypes ( ) { return this . _documentation . getExtends ( ) . getTypes ( ) ; } public String getTypeName ( ) { return this . _typeName ; } public int hashCode ( ) { return this . _typeName . hashCode ( ) ; } } private static final String CONSTRUCTOR = "constructor" ; private static final String CTOR = "#ctor" ; private static final String EMPTY_STRING = "" ; private static final String GLOBAL = "Global" ; private static final String MATH = "Math" ; private static final String OBJECT = "Object" ; private static final String PROTOTYPE = "prototype" ; private static final String WINDOW = "Window" ; private static final int FILE_OFFSET = Range . Empty . getStartingOffset ( ) ; private int _fileIndex ; private Environment _environment ; private ScriptDoc _docs ; private String _userAgent ; private List < Assignment > _assignments ; public NativeObjectsReader2 ( Environment env ) { this . _environment = env ; this . _userAgent = EMPTY_STRING ; this . _fileIndex = FileContextManager . BUILT_IN_FILE_INDEX ; this . _assignments = new ArrayList < Assignment > ( ) ; } private void copyProperties ( IObject source , IObject target ) { if ( source != null && source != ObjectBase . UNDEFINED && target != null && target != ObjectBase . UNDEFINED ) { String [ ] names = source . getPropertyNames ( true ) ; for ( String name : names ) { if ( target . hasLocalProperty ( name ) == false ) { this . putLocalProperty ( target , name , source . getProperty ( name ) ) ; } } } } private IObject createFunction ( ) { return this . _environment . createFunction ( this . _fileIndex , Range . Empty ) ; } private Reference createNamespace ( IObject root , String fullyQualifiedType ) { String [ ] parts = fullyQualifiedType . split ( "\\." ) ; IObject current = root ; for ( int i = 0 ; i < parts . length - 1 ; i ++ ) { String propertyName = parts [ i ] ; if ( current . hasProperty ( propertyName ) ) { current = current . getPropertyValue ( propertyName , this . _fileIndex , FILE_OFFSET ) ; } else { IObject instance = this . _environment . createObject ( this . _fileIndex , Range . Empty ) ; this . putPropertyValue ( current , propertyName , instance , Property . NONE ) ; UserAgent ua = new UserAgent ( ) ; ua . setDescription ( "" ) ; ua . setOs ( "" ) ; ua . setOsVersion ( "" ) ; ua . setPlatform ( this . getUserAgent ( ) ) ; ua . setVersion ( "" ) ; PropertyDocumentation documentation = new PropertyDocumentation ( ) ; documentation . setName ( propertyName ) ; documentation . setUserAgent ( this . getUserAgent ( ) ) ; documentation . addUserAgent ( ua ) ; instance . setDocumentation ( documentation ) ; current = instance ; } } String name = parts [ parts . length - 1 ] ; return new Reference ( current , name ) ; } public Assignment [ ] getAssignments ( ) { return this . _assignments . toArray ( new Assignment [ this . _assignments . size ( ) ] ) ; } public int getFileIndex ( ) { return this . _fileIndex ; } public ScriptDoc getScriptDoc ( ) { return this . _docs ; } public String getUserAgent ( ) { return this . _userAgent ; } public void load ( InputStream stream ) throws IOException { this . load ( stream , true ) ; } public void load ( InputStream stream , boolean autoCreate ) throws IOException { this . _docs = new ScriptDoc ( ) ; TabledInputStream input = new TabledInputStream ( stream ) ; this . _docs . read ( input ) ; this . postProcess ( autoCreate ) ; } public void loadXML ( InputStream stream ) throws ScriptDocInitializationException , ScriptDocException { this . loadXML ( stream , true ) ; } public void loadXML ( InputStream stream , boolean autoCreate ) throws ScriptDocInitializationException , ScriptDocException { try { ScriptDocReader reader = new ScriptDocReader ( ) ; reader . loadXML ( stream ) ; this . _docs = reader . getDocumentation ( ) ; this . postProcess ( autoCreate ) ; } catch ( IllegalStateException e ) { IdeLog . logError ( JSPlugin . getDefault ( ) , Messages . NativeObjectsReader2_ERR_Loading_scriptdoc_file , e ) ; } } public void loadXML ( String filename ) throws ScriptDocInitializationException , ScriptDocException { this . loadXML ( filename , true ) ; } public void loadXML ( String filename , boolean autoCreate ) throws ScriptDocInitializationException , ScriptDocException { FileInputStream istream = null ; try { istream = new FileInputStream ( filename ) ; this . loadXML ( istream , autoCreate ) ; } catch ( IllegalStateException e ) { IdeLog . logError ( JSPlugin . getDefault ( ) , Messages . NativeObjectsReader2_ERR_Loading_scriptdoc_file , e ) ; } catch ( FileNotFoundException e ) { String msg = Messages . NativeObjectsReader_UnalbeToLocateXMLFile + filename ; ScriptDocException de = new ScriptDocException ( msg , e ) ; throw de ; } finally { try { istream . close ( ) ; } catch ( IOException e ) { String msg = Messages . NativeObjectsReader_IOError ; ScriptDocException de = new ScriptDocException ( msg , e ) ; throw de ; } } } private void postProcess ( boolean autoCreate ) { if ( this . _environment != null ) { FunctionDocumentation [ ] functions = this . _docs . getFunctions ( ) ; IObject [ ] functionInstances = new IObject [ functions . length ] ; for ( int i = 0 ; i < functions . length ; i ++ ) { FunctionDocumentation currentFunction = functions [ i ] ; currentFunction . setUserAgent ( this . _userAgent ) ; functionInstances [ i ] = this . processFunction ( currentFunction , autoCreate ) ; } PropertyDocumentation [ ] properties = this . _docs . getProperties ( ) ; for ( int i = 0 ; i < properties . length ; i ++ ) { PropertyDocumentation currentProperty = properties [ i ] ; currentProperty . setUserAgent ( this . _userAgent ) ; this . processProperty ( currentProperty , autoCreate ) ; } this . processMixins ( functions , functionInstances ) ; this . processInheritance ( functions , functionInstances ) ; this . processAliases ( ) ; } } private void processAliases ( ) { IObject global = this . _environment . getGlobal ( ) ; for ( AliasEntry alias : this . _docs . getAliases ( ) ) { Reference aliasProperty = this . createNamespace ( global , alias . name ) ; Reference aliasedProperty = this . createNamespace ( global , alias . type ) ; this . putPropertyValue ( aliasProperty . getObjectBase ( ) , aliasProperty . getPropertyName ( ) , aliasedProperty . getValue ( this . _fileIndex , FILE_OFFSET ) , Property . NONE ) ; } } private IObject processFunction ( FunctionDocumentation documentation , boolean autoCreate ) { IObject [ ] info = processOwningType ( documentation ) ; IObject root = info [ 0 ] ; IObject prototype = info [ 1 ] ; String name = documentation . getName ( ) ; boolean dottedName = ( name . indexOf ( '.' ) != - 1 ) ; IObject targetFunction = null ; if ( name . equals ( CTOR ) ) { name = CONSTRUCTOR ; documentation . setIsConstructor ( true ) ; targetFunction = root ; } if ( targetFunction == null && documentation . getIsInstance ( ) && prototype . hasLocalProperty ( name ) ) { targetFunction = prototype . getPropertyValue ( name , this . _fileIndex , FILE_OFFSET ) ; } if ( ( targetFunction == null || targetFunction == ObjectBase . UNDEFINED ) && dottedName ) { Reference ref = this . createNamespace ( root , name ) ; name = ref . getPropertyName ( ) ; root = ref . getObjectBase ( ) ; prototype = root . getPropertyValue ( PROTOTYPE , this . _fileIndex , FILE_OFFSET ) ; targetFunction = ref . getValue ( this . _fileIndex , FILE_OFFSET ) ; } if ( targetFunction == null || targetFunction == ObjectBase . UNDEFINED ) { if ( root . hasLocalProperty ( name ) ) { targetFunction = root . getPropertyValue ( name , this . _fileIndex , FILE_OFFSET ) ; } } if ( targetFunction == null || targetFunction == ObjectBase . UNDEFINED ) { IObject newFunction = this . createFunction ( ) ; if ( documentation . getIsInstance ( ) == false ) { this . putPropertyValue ( root , name , newFunction , Property . DONT_DELETE | Property . DONT_ENUM ) ; } else { this . putPropertyValue ( prototype , name , newFunction , Property . DONT_DELETE | Property . DONT_ENUM ) ; } targetFunction = newFunction ; } if ( targetFunction instanceof NativeConstructorBase == false ) { targetFunction . setDocumentation ( documentation ) ; } return targetFunction ; } private void processInheritance ( FunctionDocumentation [ ] functions , IObject [ ] functionInstances ) { FunctionDocumentationPair [ ] pairs = this . sortByInheritanceDependency ( functions , functionInstances ) ; for ( FunctionDocumentationPair pair : pairs ) { IObject functionInstance = pair . getFunction ( ) ; FunctionDocumentation documentation = pair . getDocumentation ( ) ; String [ ] types = new String [ 0 ] ; if ( documentation != null ) { TypedDescription typeInfo = documentation . getExtends ( ) ; if ( typeInfo != null ) { types = typeInfo . getTypes ( ) ; } } for ( int i = types . length - 1 ; i >= 0 ; i -- ) { String superTypeName = types [ i ] ; if ( superTypeName . equals ( OBJECT ) == false ) { Reference ref = this . createNamespace ( this . _environment . getGlobal ( ) , superTypeName ) ; IObject superTypeConstructor = ref . getValue ( this . _fileIndex , FILE_OFFSET ) ; if ( superTypeConstructor != null && superTypeConstructor != ObjectBase . UNDEFINED ) { Property parentPrototypeProperty = superTypeConstructor . getProperty ( PROTOTYPE ) ; IObject parentPrototype = parentPrototypeProperty . getAssignment ( 0 ) ; Property childPrototypeProperty = functionInstance . getProperty ( PROTOTYPE ) ; IObject childPrototype = childPrototypeProperty . getAssignment ( 0 ) ; this . copyProperties ( parentPrototype , childPrototype ) ; } } } } } private void processMixins ( FunctionDocumentation [ ] functions , IObject [ ] functionInstances ) { for ( int i = 0 ; i < functions . length ; i ++ ) { IObject functionInstance = functionInstances [ i ] ; FunctionDocumentation documentation = functions [ i ] ; MixinDocumentation [ ] mixins = new MixinDocumentation [ 0 ] ; if ( documentation != null ) { mixins = documentation . getMixins ( ) ; } for ( int j = mixins . length - 1 ; j >= 0 ; j -- ) { MixinDocumentation mixin = mixins [ j ] ; String type = mixin . getType ( ) ; if ( type . equals ( OBJECT ) == false ) { IObject sourceObject = this . _environment . getGlobal ( ) . getPropertyValue ( type , this . _fileIndex , FILE_OFFSET ) ; if ( sourceObject != null && sourceObject != ObjectBase . UNDEFINED ) { IObject targetObject = functionInstance ; if ( mixin . getSourceInstanceProperties ( ) == false ) { sourceObject = sourceObject . getProperty ( PROTOTYPE ) . getAssignment ( 0 ) ; } if ( mixin . getTargetInstanceProperties ( ) == false ) { targetObject = targetObject . getProperty ( PROTOTYPE ) . getAssignment ( 0 ) ; } this . copyProperties ( sourceObject , targetObject ) ; } } } } } private IObject [ ] processOwningType ( FunctionDocumentation documentation ) { IObject root = this . _environment . getGlobal ( ) ; IObject prototype = ObjectBase . UNDEFINED ; String owningType = EMPTY_STRING ; if ( documentation . getMemberOf ( ) . getTypes ( ) . length > 0 ) { owningType = documentation . getMemberOf ( ) . getTypes ( ) [ 0 ] ; } if ( owningType . equals ( EMPTY_STRING ) ) { prototype = root ; documentation . getReturn ( ) . clearTypes ( ) ; documentation . getReturn ( ) . addType ( documentation . getName ( ) ) ; } else if ( owningType . equals ( GLOBAL ) == false && owningType . equals ( WINDOW ) == false ) { IObject ob = root . getPropertyValue ( owningType , this . _fileIndex , FILE_OFFSET ) ; if ( ob == ObjectBase . UNDEFINED && owningType . indexOf ( '.' ) != - 1 ) { Reference ref = this . createNamespace ( root , owningType ) ; owningType = ref . getPropertyName ( ) ; root = ref . getObjectBase ( ) ; ob = ref . getValue ( this . _fileIndex , FILE_OFFSET ) ; } if ( ob == ObjectBase . UNDEFINED ) { this . putPropertyValue ( root , owningType , this . createFunction ( ) , Property . DONT_DELETE | Property . DONT_ENUM ) ; FunctionDocumentation fDoc = new FunctionDocumentation ( ) ; fDoc . setName ( owningType ) ; fDoc . setIsConstructor ( true ) ; ob = root . getPropertyValue ( owningType , this . _fileIndex , FILE_OFFSET ) ; ob . setDocumentation ( fDoc ) ; } root = ob ; prototype = ob . getPropertyValue ( PROTOTYPE , this . _fileIndex , FILE_OFFSET ) ; } else { prototype = root . getPropertyValue ( PROTOTYPE , this . _fileIndex , FILE_OFFSET ) ; if ( prototype == null || prototype == ObjectBase . UNDEFINED ) { prototype = root ; } } return new IObject [ ] { root , prototype } ; } private void processProperty ( PropertyDocumentation documentation , boolean autoCreate ) { IObject [ ] info = this . processPropertyType ( documentation ) ; IObject root = info [ 0 ] ; IObject prototype = info [ 1 ] ; boolean isStatic = ( documentation != null && documentation . getIsInstance ( ) == false ) ; String name = documentation . getName ( ) ; IObject propertyObject = null ; if ( isStatic == false && prototype . hasLocalProperty ( name ) ) { propertyObject = prototype . getPropertyValue ( name , this . _fileIndex , FILE_OFFSET ) ; } if ( ( propertyObject == null || propertyObject == ObjectBase . UNDEFINED ) && isStatic ) { if ( root . hasLocalProperty ( name ) ) { propertyObject = root . getPropertyValue ( name , this . _fileIndex , FILE_OFFSET ) ; } } if ( propertyObject == null || propertyObject == ObjectBase . UNDEFINED ) { String [ ] types = documentation . getReturn ( ) . getTypes ( ) ; IObject type = null ; IObject newobj = null ; if ( types != null && types . length > 0 ) { String typeName = types [ 0 ] ; Reference ref = this . createNamespace ( this . _environment . getGlobal ( ) , typeName ) ; type = ref . getValue ( this . _fileIndex , FILE_OFFSET ) ; } if ( type instanceof IFunction ) { newobj = ( ( IFunction ) type ) . construct ( this . _environment , FunctionBase . EmptyArgs , this . _fileIndex , Range . Empty ) ; } else { newobj = this . _environment . createObject ( this . _fileIndex , Range . Empty ) ; } if ( isStatic ) { this . putPropertyValue ( root , name , newobj , Property . DONT_DELETE | Property . DONT_ENUM ) ; } else { this . putPropertyValue ( prototype , name , newobj , Property . DONT_DELETE | Property . DONT_ENUM ) ; } propertyObject = newobj ; } propertyObject . setDocumentation ( documentation ) ; } private IObject [ ] processPropertyType ( PropertyDocumentation propertyDoc ) { IObject root = this . _environment . getGlobal ( ) ; IObject prototype = ObjectBase . UNDEFINED ; String name = propertyDoc . getName ( ) ; String type = propertyDoc . getMemberOf ( ) . getTypes ( ) [ 0 ] ; if ( name . equals ( MATH ) ) { TypedDescription desc = propertyDoc . getReturn ( ) ; desc . clearTypes ( ) ; desc . addType ( MATH ) ; } if ( type . equals ( GLOBAL ) == false && type . equals ( WINDOW ) == false ) { IObject ob = root . getPropertyValue ( type , this . _fileIndex , FILE_OFFSET ) ; if ( ob == ObjectBase . UNDEFINED && type . indexOf ( '.' ) != - 1 ) { Reference ref = this . createNamespace ( root , type ) ; type = ref . getPropertyName ( ) ; root = ref . getObjectBase ( ) ; ob = ref . getValue ( this . _fileIndex , FILE_OFFSET ) ; } if ( ob == ObjectBase . UNDEFINED ) { this . putPropertyValue ( root , type , this . createFunction ( ) , Property . DONT_DELETE | Property . DONT_ENUM ) ; FunctionDocumentation fDoc = new FunctionDocumentation ( ) ; fDoc . setName ( type ) ; fDoc . setIsConstructor ( true ) ; ob = root . getPropertyValue ( type , this . _fileIndex , FILE_OFFSET ) ; ob . setDocumentation ( fDoc ) ; } root = ob ; prototype = ob . getPropertyValue ( PROTOTYPE , this . _fileIndex , FILE_OFFSET ) ; } else { prototype = root . getPropertyValue ( PROTOTYPE , this . _fileIndex , FILE_OFFSET ) ; } return new IObject [ ] { root , prototype } ; } private void putLocalProperty ( IObject parentObject , String propertyName , Property property ) { parentObject . putLocalProperty ( propertyName , property ) ; Reference reference = new Reference ( parentObject , propertyName ) ; Assignment assignment = new Assignment ( reference , null ) ; this . _assignments . add ( assignment ) ; } private void putPropertyValue ( IObject parentObject , String propertyName , IObject value , int attributes ) { parentObject . putPropertyValue ( propertyName , value , this . _fileIndex , attributes ) ; Reference reference = new Reference ( parentObject , propertyName ) ; Assignment assignment = new Assignment ( reference , value ) ; this . _assignments . add ( assignment ) ; } public void setFileIndex ( int fileIndex ) { this . _fileIndex = fileIndex ; } public void setUserAgent ( String userAgent ) { this . _userAgent = userAgent ; } private FunctionDocumentationPair [ ] sortByInheritanceDependency ( FunctionDocumentation [ ] functions , IObject [ ] functionInstances ) { SimpleDependencyGraph < FunctionDocumentationPair > graph = new SimpleDependencyGraph < FunctionDocumentationPair > ( ) ; for ( int i = 0 ; i < functions . length ; i ++ ) { FunctionDocumentationPair pair = new FunctionDocumentationPair ( functionInstances [ i ] , functions [ i ] ) ; String type = pair . getTypeName ( ) ; if ( CTOR . equals ( type ) == false ) { graph . addMapping ( type , pair ) ; graph . addVertex ( type ) ; } } for ( FunctionDocumentation documentation : functions ) { String type = documentation . getName ( ) ; if ( CTOR . equals ( type ) == false ) { for ( String superType : documentation . getExtends ( ) . getTypes ( ) ) { if ( "Object" . equals ( superType ) == false && CTOR . equals ( superType ) == false ) { graph . addEdge ( type , superType ) ; } } } } String [ ] types = graph . topologicalSort ( ) ; FunctionDocumentationPair [ ] result = new FunctionDocumentationPair [ types . length ] ; for ( int i = 0 ; i < types . length ; i ++ ) { result [ i ] = graph . getItem ( types [ i ] ) ; } return result ; } } 