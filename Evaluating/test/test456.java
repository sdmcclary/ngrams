<<<<<<< HEAD
public class ReentrantReadWriteLock implements ReadWriteLock , java . io . Serializable { private static final long serialVersionUID = - 6992448646407690164L ; private final ReentrantReadWriteLock . ReadLock readerLock ; private final ReentrantReadWriteLock . WriteLock writerLock ; final Sync sync ; public ReentrantReadWriteLock ( ) { this ( false ) ; } public ReentrantReadWriteLock ( boolean fair ) { sync = fair ? new FairSync ( ) : new NonfairSync ( ) ; readerLock = new ReadLock ( this ) ; writerLock = new WriteLock ( this ) ; } public ReentrantReadWriteLock . WriteLock writeLock ( ) { return writerLock ; } public ReentrantReadWriteLock . ReadLock readLock ( ) { return readerLock ; } static abstract class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 6317671515068378041L ; static final int SHARED_SHIFT = 16 ; static final int SHARED_UNIT = ( 1 << SHARED_SHIFT ) ; static final int MAX_COUNT = ( 1 << SHARED_SHIFT ) - 1 ; static final int EXCLUSIVE_MASK = ( 1 << SHARED_SHIFT ) - 1 ; static int sharedCount ( int c ) { return c > > > SHARED_SHIFT ; } static int exclusiveCount ( int c ) { return c & EXCLUSIVE_MASK ; } static final class HoldCounter { int count = 0 ; final long tid = Thread . currentThread ( ) . getId ( ) ; } static final class ThreadLocalHoldCounter extends ThreadLocal < HoldCounter > { public HoldCounter initialValue ( ) { return new HoldCounter ( ) ; } } private transient ThreadLocalHoldCounter readHolds ; private transient HoldCounter cachedHoldCounter ; private transient Thread firstReader = null ; private transient int firstReaderHoldCount ; Sync ( ) { readHolds = new ThreadLocalHoldCounter ( ) ; setState ( getState ( ) ) ; } abstract boolean readerShouldBlock ( ) ; abstract boolean writerShouldBlock ( ) ; protected final boolean tryRelease ( int releases ) { if ( ! isHeldExclusively ( ) ) throw new IllegalMonitorStateException ( ) ; int nextc = getState ( ) - releases ; boolean free = exclusiveCount ( nextc ) == 0 ; if ( free ) setExclusiveOwnerThread ( null ) ; setState ( nextc ) ; return free ; } protected final boolean tryAcquire ( int acquires ) { Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; int w = exclusiveCount ( c ) ; if ( c != 0 ) { if ( w == 0 || current != getExclusiveOwnerThread ( ) ) return false ; if ( w + exclusiveCount ( acquires ) > MAX_COUNT ) throw new Error ( "Maximum lock count exceeded" ) ; setState ( c + acquires ) ; return true ; } if ( writerShouldBlock ( ) || ! compareAndSetState ( c , c + acquires ) ) return false ; setExclusiveOwnerThread ( current ) ; return true ; } protected final boolean tryReleaseShared ( int unused ) { Thread current = Thread . currentThread ( ) ; if ( firstReader == current ) { if ( firstReaderHoldCount == 1 ) firstReader = null ; else firstReaderHoldCount -- ; } else { HoldCounter rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) rh = readHolds . get ( ) ; int count = rh . count ; if ( count <= 1 ) { readHolds . remove ( ) ; if ( count <= 0 ) throw unmatchedUnlockException ( ) ; } -- rh . count ; } for ( ; ; ) { int c = getState ( ) ; int nextc = c - SHARED_UNIT ; if ( compareAndSetState ( c , nextc ) ) return nextc == 0 ; } } private IllegalMonitorStateException unmatchedUnlockException ( ) { return new IllegalMonitorStateException ( "attempt to unlock read lock, not locked by current thread" ) ; } protected final int tryAcquireShared ( int unused ) { Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( exclusiveCount ( c ) != 0 && getExclusiveOwnerThread ( ) != current ) return - 1 ; int r = sharedCount ( c ) ; if ( ! readerShouldBlock ( ) && r < MAX_COUNT && compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( r == 0 ) { firstReader = current ; firstReaderHoldCount = 1 ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { HoldCounter rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) cachedHoldCounter = rh = readHolds . get ( ) ; else if ( rh . count == 0 ) readHolds . set ( rh ) ; rh . count ++ ; } return 1 ; } return fullTryAcquireShared ( current ) ; } final int fullTryAcquireShared ( Thread current ) { HoldCounter rh = null ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != 0 ) { if ( getExclusiveOwnerThread ( ) != current ) return - 1 ; } else if ( readerShouldBlock ( ) ) { if ( firstReader == current ) { } else { if ( rh == null ) { rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) { rh = readHolds . get ( ) ; if ( rh . count == 0 ) readHolds . remove ( ) ; } } if ( rh . count == 0 ) return - 1 ; } } if ( sharedCount ( c ) == MAX_COUNT ) throw new Error ( "Maximum lock count exceeded" ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( sharedCount ( c ) == 0 ) { firstReader = current ; firstReaderHoldCount = 1 ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { if ( rh == null ) rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) rh = readHolds . get ( ) ; else if ( rh . count == 0 ) readHolds . set ( rh ) ; rh . count ++ ; cachedHoldCounter = rh ; } return 1 ; } } } final boolean tryWriteLock ( ) { Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c != 0 ) { int w = exclusiveCount ( c ) ; if ( w == 0 || current != getExclusiveOwnerThread ( ) ) return false ; if ( w == MAX_COUNT ) throw new Error ( "Maximum lock count exceeded" ) ; } if ( ! compareAndSetState ( c , c + 1 ) ) return false ; setExclusiveOwnerThread ( current ) ; return true ; } final boolean tryReadLock ( ) { Thread current = Thread . currentThread ( ) ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != 0 && getExclusiveOwnerThread ( ) != current ) return false ; int r = sharedCount ( c ) ; if ( r == MAX_COUNT ) throw new Error ( "Maximum lock count exceeded" ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( r == 0 ) { firstReader = current ; firstReaderHoldCount = 1 ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { HoldCounter rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) cachedHoldCounter = rh = readHolds . get ( ) ; else if ( rh . count == 0 ) readHolds . set ( rh ) ; rh . count ++ ; } return true ; } } } protected final boolean isHeldExclusively ( ) { return getExclusiveOwnerThread ( ) == Thread . currentThread ( ) ; } final ConditionObject newCondition ( ) { return new ConditionObject ( ) ; } final Thread getOwner ( ) { return ( ( exclusiveCount ( getState ( ) ) == 0 ) ? null : getExclusiveOwnerThread ( ) ) ; } final int getReadLockCount ( ) { return sharedCount ( getState ( ) ) ; } final boolean isWriteLocked ( ) { return exclusiveCount ( getState ( ) ) != 0 ; } final int getWriteHoldCount ( ) { return isHeldExclusively ( ) ? exclusiveCount ( getState ( ) ) : 0 ; } final int getReadHoldCount ( ) { if ( getReadLockCount ( ) == 0 ) return 0 ; Thread current = Thread . currentThread ( ) ; if ( firstReader == current ) return firstReaderHoldCount ; HoldCounter rh = cachedHoldCounter ; if ( rh != null && rh . tid == current . getId ( ) ) return rh . count ; int count = readHolds . get ( ) . count ; if ( count == 0 ) readHolds . remove ( ) ; return count ; } private void readObject ( java . io . ObjectInputStream s ) throws java . io . IOException , ClassNotFoundException { s . defaultReadObject ( ) ; readHolds = new ThreadLocalHoldCounter ( ) ; setState ( 0 ) ; } final int getCount ( ) { return getState ( ) ; } } final static class NonfairSync extends Sync { private static final long serialVersionUID = - 8159625535654395037L ; final boolean writerShouldBlock ( ) { return false ; } final boolean readerShouldBlock ( ) { return apparentlyFirstQueuedIsExclusive ( ) ; } } final static class FairSync extends Sync { private static final long serialVersionUID = - 2274990926593161451L ; final boolean writerShouldBlock ( ) { return hasQueuedPredecessors ( ) ; } final boolean readerShouldBlock ( ) { return hasQueuedPredecessors ( ) ; } } public static class ReadLock implements Lock , java . io . Serializable { private static final long serialVersionUID = - 5992448646407690164L ; private final Sync sync ; protected ReadLock ( ReentrantReadWriteLock lock ) { sync = lock . sync ; } public void lock ( ) { sync . acquireShared ( 1 ) ; } public void lockInterruptibly ( ) throws InterruptedException { sync . acquireSharedInterruptibly ( 1 ) ; } public boolean tryLock ( ) { return sync . tryReadLock ( ) ; } public boolean tryLock ( long timeout , TimeUnit unit ) throws InterruptedException { return sync . tryAcquireSharedNanos ( 1 , unit . toNanos ( timeout ) ) ; } public void unlock ( ) { sync . releaseShared ( 1 ) ; } public Condition newCondition ( ) { throw new UnsupportedOperationException ( ) ; } public String toString ( ) { int r = sync . getReadLockCount ( ) ; return super . toString ( ) + "[Read locks = " + r + "]" ; } } public static class WriteLock implements Lock , java . io . Serializable { private static final long serialVersionUID = - 4992448646407690164L ; private final Sync sync ; protected WriteLock ( ReentrantReadWriteLock lock ) { sync = lock . sync ; } public void lock ( ) { sync . acquire ( 1 ) ; } public void lockInterruptibly ( ) throws InterruptedException { sync . acquireInterruptibly ( 1 ) ; } public boolean tryLock ( ) { return sync . tryWriteLock ( ) ; } public boolean tryLock ( long timeout , TimeUnit unit ) throws InterruptedException { return sync . tryAcquireNanos ( 1 , unit . toNanos ( timeout ) ) ; } public void unlock ( ) { sync . release ( 1 ) ; } public Condition newCondition ( ) { return sync . newCondition ( ) ; } public String toString ( ) { Thread o = sync . getOwner ( ) ; return super . toString ( ) + ( ( o == null ) ? "[Unlocked]" : "[Locked by thread " + o . getName ( ) + "]" ) ; } public boolean isHeldByCurrentThread ( ) { return sync . isHeldExclusively ( ) ; } public int getHoldCount ( ) { return sync . getWriteHoldCount ( ) ; } } public final boolean isFair ( ) { return sync instanceof FairSync ; } protected Thread getOwner ( ) { return sync . getOwner ( ) ; } public int getReadLockCount ( ) { return sync . getReadLockCount ( ) ; } public boolean isWriteLocked ( ) { return sync . isWriteLocked ( ) ; } public boolean isWriteLockedByCurrentThread ( ) { return sync . isHeldExclusively ( ) ; } public int getWriteHoldCount ( ) { return sync . getWriteHoldCount ( ) ; } public int getReadHoldCount ( ) { return sync . getReadHoldCount ( ) ; } protected Collection < Thread > getQueuedWriterThreads ( ) { return sync . getExclusiveQueuedThreads ( ) ; } protected Collection < Thread > getQueuedReaderThreads ( ) { return sync . getSharedQueuedThreads ( ) ; } public final boolean hasQueuedThreads ( ) { return sync . hasQueuedThreads ( ) ; } public final boolean hasQueuedThread ( Thread thread ) { return sync . isQueued ( thread ) ; } public final int getQueueLength ( ) { return sync . getQueueLength ( ) ; } protected Collection < Thread > getQueuedThreads ( ) { return sync . getQueuedThreads ( ) ; } public boolean hasWaiters ( Condition condition ) { if ( condition == null ) throw new NullPointerException ( ) ; if ( ! ( condition instanceof AbstractQueuedSynchronizer . ConditionObject ) ) throw new IllegalArgumentException ( "not owner" ) ; return sync . hasWaiters ( ( AbstractQueuedSynchronizer . ConditionObject ) condition ) ; } public int getWaitQueueLength ( Condition condition ) { if ( condition == null ) throw new NullPointerException ( ) ; if ( ! ( condition instanceof AbstractQueuedSynchronizer . ConditionObject ) ) throw new IllegalArgumentException ( "not owner" ) ; return sync . getWaitQueueLength ( ( AbstractQueuedSynchronizer . ConditionObject ) condition ) ; } protected Collection < Thread > getWaitingThreads ( Condition condition ) { if ( condition == null ) throw new NullPointerException ( ) ; if ( ! ( condition instanceof AbstractQueuedSynchronizer . ConditionObject ) ) throw new IllegalArgumentException ( "not owner" ) ; return sync . getWaitingThreads ( ( AbstractQueuedSynchronizer . ConditionObject ) condition ) ; } public String toString ( ) { int c = sync . getCount ( ) ; int w = Sync . exclusiveCount ( c ) ; int r = Sync . sharedCount ( c ) ; return super . toString ( ) + "[Write locks = " + w + ", Read locks = " + r + "]" ; } } 
=======
public class FloatingPointExponent extends AbstractDatatype { public static final FloatingPointExponent THE_INSTANCE = new FloatingPointExponent ( ) ; private enum State { AT_START , AT_START_MINUS_SEEN , IN_INTEGER_PART_DIGITS_SEEN , DOT_SEEN , E_SEEN , IN_DECIMAL_PART_DIGITS_SEEN , IN_EXPONENT_SIGN_SEEN , IN_EXPONENT_DIGITS_SEEN } private FloatingPointExponent ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { State state = State . AT_START ; for ( int i = 0 ; i < literal . length ( ) ; i ++ ) { char c = literal . charAt ( i ) ; switch ( state ) { case AT_START : if ( c == '-' ) { state = State . AT_START_MINUS_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { state = State . IN_INTEGER_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a minus sign or a digit but saw " , c , " instead." ) ; } case AT_START_MINUS_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_INTEGER_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } case IN_INTEGER_PART_DIGITS_SEEN : if ( c == '.' ) { state = State . DOT_SEEN ; continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a decimal point, “e”, “E” or a digit but saw " , c , " instead." ) ; } case DOT_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_DECIMAL_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit after the decimal point but saw " , c , " instead." ) ; } case IN_DECIMAL_PART_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected “e”, “E” or a digit but saw " , c , " instead." ) ; } case E_SEEN : if ( c == '-' || c == '+' ) { state = State . IN_EXPONENT_SIGN_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a minus sign, a plus sign or a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_SIGN_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } } } switch ( state ) { case IN_INTEGER_PART_DIGITS_SEEN : case IN_DECIMAL_PART_DIGITS_SEEN : case IN_EXPONENT_DIGITS_SEEN : return ; case AT_START : throw newDatatypeException ( "The empty string is not a valid floating point number." ) ; case AT_START_MINUS_SEEN : throw newDatatypeException ( "The minus sign alone is not a valid floating point number." ) ; case DOT_SEEN : throw newDatatypeException ( "A floating point number must not end with the decimal point." ) ; case E_SEEN : throw newDatatypeException ( "A floating point number must not end with the exponent “e”." ) ; case IN_EXPONENT_SIGN_SEEN : throw newDatatypeException ( "A floating point number must not end with only a sign in the exponent." ) ; } } @ Override public String getName ( ) { return "floating point number" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
