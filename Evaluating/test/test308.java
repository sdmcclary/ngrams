<<<<<<< HEAD
public class TasksView extends ViewPart { public static final String ID = "com.netifera.platform.ui.views.Tasks" ; private static String ACTIVE_ICON = "icons/lightbulb.png" ; private static String INACTIVE_ICON = "icons/lightbulb_off.png" ; private StructuredViewer viewer ; private ViewerRefreshAction viewerRefreshAction = new ViewerRefreshAction ( ) ; private TaskCancelAction taskCancelAction ; private MenuManager contextMenu ; private boolean tableMode = false ; private Composite parent ; private SelectionProviderProxy selectionProvider ; private IPartListener partListener ; private ISelection selection ; private TaskFilter viewerFilter ; private TaskRecordFieldComparator viewerComparator ; @ Override public void createPartControl ( Composite parent ) { this . parent = parent ; selectionProvider = new SelectionProviderProxy ( ) ; getSite ( ) . setSelectionProvider ( selectionProvider ) ; viewer = createViewer ( parent , tableMode ) ; initializeToolBar ( ) ; initializeMenu ( ) ; initializeListeners ( ) ; editorChanged ( ) ; } public void dipose ( ) { super . dispose ( ) ; } private StructuredViewer createViewer ( Composite parent , boolean tableMode ) { StructuredViewer viewer = tableMode ? createTableViewer ( parent ) : createItemViewer ( parent ) ; viewer . setLabelProvider ( new TaskLabelProvider ( ) ) ; viewer . setContentProvider ( new TaskContentProvider ( this ) ) ; viewerRefreshAction . setViewer ( viewer ) ; viewerFilter = new TaskFilter ( ) ; viewer . addFilter ( viewerFilter ) ; if ( tableMode ) { contextMenu = createContextMenu ( ) ; setContextMenu ( contextMenu , viewer ) ; } this . tableMode = tableMode ; if ( selection != null && ! selection . isEmpty ( ) ) { viewer . setSelection ( selection , true ) ; } selectionProvider . setSelectionProvider ( viewer ) ; if ( taskCancelAction == null ) { taskCancelAction = new TaskCancelAction ( selectionProvider ) ; } return viewer ; } private MenuManager createContextMenu ( ) { MenuManager menuMgr = new MenuManager ( "#PopupMenu" ) ; menuMgr . setRemoveAllWhenShown ( true ) ; menuMgr . addMenuListener ( new IMenuListener ( ) { public void menuAboutToShow ( IMenuManager m ) { fillContextMenu ( m ) ; } } ) ; return menuMgr ; } private void fillContextMenu ( IMenuManager menuMgr ) { menuMgr . add ( taskCancelAction ) ; menuMgr . add ( new ViewerRefreshAction ( viewer ) ) ; MenuManager filterMgr = new MenuManager ( "Show" , "filter" ) ; filterMgr . setRemoveAllWhenShown ( true ) ; filterMgr . addMenuListener ( new IMenuListener ( ) { public void menuAboutToShow ( IMenuManager m ) { viewerFilter . fillFilterMenu ( m ) ; } } ) ; viewerFilter . fillFilterMenu ( filterMgr ) ; menuMgr . add ( filterMgr ) ; menuMgr . add ( new Separator ( IWorkbenchActionConstants . MB_ADDITIONS ) ) ; } private void setContextMenu ( MenuManager menuMgr , Viewer viewer ) { Control viewerControl = viewer . getControl ( ) ; Menu menu = menuMgr . createContextMenu ( viewerControl ) ; viewerControl . setMenu ( menu ) ; getSite ( ) . registerContextMenu ( menuMgr , viewer ) ; } private void initializeListeners ( ) { final IWorkbenchWindow window = getSite ( ) . getWorkbenchWindow ( ) ; if ( window == null ) { return ; } partListener = createPartListener ( ) ; window . addPageListener ( createPageListener ( ) ) ; final IWorkbenchPage page = window . getActivePage ( ) ; if ( page != null ) { page . addPartListener ( partListener ) ; } } private IPartListener createPartListener ( ) { return new IPartListener ( ) { public void partActivated ( IWorkbenchPart part ) { if ( part instanceof EditorPart ) editorChanged ( ) ; } public void partClosed ( IWorkbenchPart part ) { if ( part instanceof EditorPart ) editorChanged ( ) ; } public void partOpened ( IWorkbenchPart part ) { if ( part instanceof EditorPart ) editorChanged ( ) ; } public void partBroughtToTop ( IWorkbenchPart part ) { } public void partDeactivated ( IWorkbenchPart part ) { } } ; } private IPageListener createPageListener ( ) { return new IPageListener ( ) { public void pageActivated ( IWorkbenchPage page ) { } public void pageClosed ( IWorkbenchPage page ) { page . removePartListener ( partListener ) ; } public void pageOpened ( IWorkbenchPage page ) { page . addPartListener ( partListener ) ; } } ; } private void editorChanged ( ) { final IEditorPart editor = getActiveEditor ( ) ; if ( editor == null || ! ( editor . getEditorInput ( ) instanceof SpaceEditorInput ) ) { return ; } final SpaceEditorInput input = ( SpaceEditorInput ) editor . getEditorInput ( ) ; StructuredViewerUpdater . get ( viewer ) . setInput ( input . getSpace ( ) ) ; } private IEditorPart getActiveEditor ( ) { return getSite ( ) . getPage ( ) . getActiveEditor ( ) ; } private void initializeToolBar ( ) { IToolBarManager toolbarManager = getViewSite ( ) . getActionBars ( ) . getToolBarManager ( ) ; if ( tableMode ) toolbarManager . add ( taskCancelAction ) ; toolbarManager . add ( viewerRefreshAction ) ; } private void initializeMenu ( ) { IMenuManager viewMenuMgr = getViewSite ( ) . getActionBars ( ) . getMenuManager ( ) ; IAction switchMode = new Action ( "Table presentation mode" , Action . AS_CHECK_BOX ) { public void run ( ) { parent . setRedraw ( false ) ; if ( viewer != null ) { selection = viewer . getSelection ( ) ; viewer . getControl ( ) . dispose ( ) ; for ( Control c : parent . getChildren ( ) ) { c . dispose ( ) ; } } viewer = createViewer ( parent , ! tableMode ) ; parent . layout ( ) ; parent . setRedraw ( true ) ; editorChanged ( ) ; } } ; viewMenuMgr . add ( switchMode ) ; MenuManager filterMgr = new MenuManager ( "Show" , "filter" ) ; filterMgr . setRemoveAllWhenShown ( true ) ; filterMgr . addMenuListener ( new IMenuListener ( ) { public void menuAboutToShow ( IMenuManager m ) { viewerFilter . fillFilterMenu ( m ) ; } } ) ; viewerFilter . fillFilterMenu ( filterMgr ) ; viewMenuMgr . add ( filterMgr ) ; MenuManager sortByMgr = new MenuManager ( "Sort by" , "sort" ) ; sortByMgr . setRemoveAllWhenShown ( true ) ; sortByMgr . addMenuListener ( new IMenuListener ( ) { public void menuAboutToShow ( IMenuManager m ) { fillSortByMenu ( m ) ; } } ) ; fillSortByMenu ( sortByMgr ) ; viewMenuMgr . add ( sortByMgr ) ; MenuManager orderMgr = new MenuManager ( "Order" , "order" ) ; orderMgr . setRemoveAllWhenShown ( true ) ; orderMgr . addMenuListener ( new IMenuListener ( ) { public void menuAboutToShow ( IMenuManager m ) { fillOrderMenu ( m ) ; } } ) ; fillOrderMenu ( orderMgr ) ; viewMenuMgr . add ( orderMgr ) ; taskCancelAction = new TaskCancelAction ( selectionProvider ) ; viewMenuMgr . add ( new Separator ( IWorkbenchActionConstants . MB_ADDITIONS ) ) ; } public void fillSortByMenu ( IMenuManager menuMgr ) { menuMgr . add ( createSortAction ( "Status" , TaskRecordFieldComparator . RUNSTATE ) ) ; menuMgr . add ( createSortAction ( "Title" , TaskRecordFieldComparator . NAME ) ) ; menuMgr . add ( createSortAction ( "Start time" , TaskRecordFieldComparator . START_TIME ) ) ; menuMgr . add ( createSortAction ( "Elapsed time" , TaskRecordFieldComparator . ELAPSED_TIME ) ) ; } private Action createSortAction ( final String text , final int sortField ) { Action action = new Action ( text , Action . AS_RADIO_BUTTON ) { @ Override public void run ( ) { viewerComparator . setSortBy ( sortField ) ; if ( viewer != null ) { viewer . refresh ( ) ; } } } ; boolean checked = viewerComparator . getSortBy ( ) . equals ( sortField ) ; action . setChecked ( checked ) ; return action ; } public void fillOrderMenu ( IMenuManager menuMgr ) { Action action = new Action ( "Ascending" , Action . AS_RADIO_BUTTON ) { @ Override public void run ( ) { viewerComparator . setAscending ( true ) ; if ( viewer != null ) { viewer . refresh ( ) ; } } } ; action . setChecked ( viewerComparator . isAscending ( ) ) ; menuMgr . add ( action ) ; action = new Action ( "Descending" , Action . AS_RADIO_BUTTON ) { @ Override public void run ( ) { viewerComparator . setAscending ( false ) ; if ( viewer != null ) { viewer . refresh ( ) ; } } } ; action . setChecked ( ! viewerComparator . isAscending ( ) ) ; menuMgr . add ( action ) ; } @ Override public void setFocus ( ) { if ( viewer != null ) { viewer . getControl ( ) . setFocus ( ) ; } } private ItemViewer createItemViewer ( Composite parent ) { ItemViewer itemViewer = new ItemViewer ( parent , SWT . BORDER ) ; itemViewer . setItemProvider ( new TaskItemProvider ( parent , parent . getStyle ( ) ) ) ; viewerComparator = new TaskRecordFieldComparator ( ) ; itemViewer . setComparator ( new FieldViewerComparator ( itemViewer , viewerComparator ) ) ; return itemViewer ; } private TableViewer createTableViewer ( Composite parent ) { final Composite tableComposite = new Composite ( parent , SWT . NONE ) ; final TableViewer tableViewer = new TableViewer ( tableComposite , SWT . V_SCROLL ) ; final Table table = tableViewer . getTable ( ) ; final TableColumnLayout columnLayout = new TableColumnLayout ( ) ; tableComposite . setLayout ( columnLayout ) ; createTableColumns ( table , columnLayout ) ; table . setHeaderVisible ( true ) ; table . setLinesVisible ( true ) ; viewerComparator = new TaskRecordFieldComparator ( new ColumnViewerFieldComparator ( tableViewer ) ) ; tableViewer . setComparator ( new FieldViewerComparator ( tableViewer , viewerComparator ) ) ; return tableViewer ; } private void createTableColumns ( Table table , TableColumnLayout layout ) { final String [ ] columnNames = new String [ ] { " " , "Task" , "Start" , "Elapsed Time" } ; final ColumnLayoutData [ ] columnLayouts = new ColumnLayoutData [ ] { new ColumnPixelData ( 25 , false , false ) , new ColumnWeightData ( 100 ) , new ColumnPixelData ( 120 , true , false ) , new ColumnPixelData ( 120 , true , false ) } ; final int [ ] columnAlign = new int [ ] { SWT . CENTER , SWT . LEFT , SWT . CENTER , SWT . CENTER } ; for ( int i = 0 ; i < columnNames . length ; i ++ ) { TableColumn column = new TableColumn ( table , columnAlign [ i ] ) ; column . setText ( columnNames [ i ] ) ; column . setData ( i ) ; layout . setColumnData ( column , columnLayouts [ i ] ) ; } } public void setActive ( boolean tasksRunning ) { if ( tasksRunning ) { setTitleImage ( TasksPlugin . getPlugin ( ) . getImageCache ( ) . get ( ACTIVE_ICON ) ) ; } else { setTitleImage ( TasksPlugin . getPlugin ( ) . getImageCache ( ) . get ( INACTIVE_ICON ) ) ; } } } 
=======
class Path { private final boolean root ; private final Vector names ; Path ( boolean root , Vector names ) { this . root = root ; this . names = names ; } boolean isRoot ( ) { return root ; } Vector getNames ( ) { return names ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( root ) buf . append ( '/' ) ; for ( int i = 0 , len = names . size ( ) ; i < len ; i ++ ) { if ( i != 0 ) buf . append ( '/' ) ; buf . append ( ( String ) names . elementAt ( i ) ) ; } return buf . toString ( ) ; } static class ParseException extends Exception { private final String messageKey ; ParseException ( String messageKey ) { super ( messageKey ) ; this . messageKey = messageKey ; } public String getMessageKey ( ) { return messageKey ; } } private static final int START = 0 ; private static final int IN_NAME = 1 ; private static final int AFTER_NAME = 2 ; private static final int AFTER_SLASH = 3 ; static Vector parse ( String str ) throws ParseException { int state = START ; int nameStartIndex = - 1 ; Vector paths = new Vector ( ) ; Vector names = new Vector ( ) ; boolean root = false ; for ( int i = 0 , len = str . length ( ) ; i < len ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case ' ' : case '\r' : case '\n' : case '\t' : if ( state == IN_NAME ) { names . addElement ( makeName ( str , nameStartIndex , i ) ) ; state = AFTER_NAME ; } break ; case '/' : switch ( state ) { case IN_NAME : names . addElement ( makeName ( str , nameStartIndex , i ) ) ; break ; case START : root = true ; break ; case AFTER_SLASH : throw new ParseException ( "unexpected_slash" ) ; } state = AFTER_SLASH ; break ; case '|' : switch ( state ) { case START : throw new ParseException ( "empty_path" ) ; case AFTER_NAME : break ; case AFTER_SLASH : throw new ParseException ( "expected_name" ) ; case IN_NAME : names . addElement ( makeName ( str , nameStartIndex , i ) ) ; break ; } paths . addElement ( new Path ( root , names ) ) ; root = false ; names = new Vector ( ) ; state = START ; break ; default : switch ( state ) { case AFTER_NAME : throw new ParseException ( "expected_slash" ) ; case AFTER_SLASH : case START : nameStartIndex = i ; state = IN_NAME ; break ; case IN_NAME : break ; } break ; } } switch ( state ) { case START : throw new ParseException ( "empty_path" ) ; case AFTER_NAME : break ; case AFTER_SLASH : throw new ParseException ( "expected_name" ) ; case IN_NAME : names . addElement ( makeName ( str , nameStartIndex , str . length ( ) ) ) ; break ; } paths . addElement ( new Path ( root , names ) ) ; return paths ; } private static String makeName ( String str , int start , int end ) throws ParseException { String name = str . substring ( start , end ) ; if ( ! Naming . isNcname ( name ) ) throw new ParseException ( "invalid_name" ) ; return name ; } static public void main ( String [ ] args ) throws ParseException { Vector paths = parse ( args [ 0 ] ) ; for ( int i = 0 ; i < paths . size ( ) ; i ++ ) { if ( i != 0 ) System . out . println ( "---" ) ; Path path = ( Path ) paths . elementAt ( i ) ; if ( path . isRoot ( ) ) System . out . println ( "/" ) ; for ( int j = 0 ; j < path . getNames ( ) . size ( ) ; j ++ ) System . out . println ( path . getNames ( ) . elementAt ( j ) ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
