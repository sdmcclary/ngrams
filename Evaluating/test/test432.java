final class Table { private enum State { IN_TABLE_AT_START , IN_TABLE_AT_POTENTIAL_ROW_GROUP_START , IN_COLGROUP , IN_COL_IN_COLGROUP , IN_COL_IN_IMPLICIT_GROUP , IN_ROW_GROUP , IN_ROW_IN_ROW_GROUP , IN_CELL_IN_ROW_GROUP , IN_ROW_IN_IMPLICIT_ROW_GROUP , IN_IMPLICIT_ROW_GROUP , IN_CELL_IN_IMPLICIT_ROW_GROUP , IN_TABLE_COLS_SEEN } private State state = State . IN_TABLE_AT_START ; private int suppressedStarts = 0 ; private boolean hardWidth = false ; private int columnCount = - 1 ; private int realColumnCount = 0 ; private int pendingColGroupSpan = 0 ; private final Set < String > headerIds = new HashSet < String > ( ) ; private final List < Cell > cellsReferringToHeaders = new LinkedList < Cell > ( ) ; private final TableChecker owner ; private RowGroup current ; private ColumnRange first = null ; private ColumnRange last = null ; private ColumnRange currentColRange = null ; private ColumnRange previousColRange = null ; public Table ( TableChecker owner ) { super ( ) ; this . owner = owner ; } private boolean needSuppressStart ( ) { if ( suppressedStarts > 0 ) { suppressedStarts ++ ; return true ; } else { return false ; } } private boolean needSuppressEnd ( ) { if ( suppressedStarts > 0 ) { suppressedStarts -- ; return true ; } else { return false ; } } void startRowGroup ( String type ) throws SAXException { if ( needSuppressStart ( ) ) { return ; } switch ( state ) { case IN_IMPLICIT_ROW_GROUP : current . end ( ) ; case IN_TABLE_AT_START : case IN_TABLE_COLS_SEEN : case IN_TABLE_AT_POTENTIAL_ROW_GROUP_START : current = new RowGroup ( this , type ) ; state = State . IN_ROW_GROUP ; break ; default : suppressedStarts = 1 ; break ; } } void endRowGroup ( ) throws SAXException { if ( needSuppressEnd ( ) ) { return ; } switch ( state ) { case IN_ROW_GROUP : current . end ( ) ; current = null ; state = State . IN_TABLE_AT_POTENTIAL_ROW_GROUP_START ; break ; default : throw new IllegalStateException ( "Bug!" ) ; } } void startRow ( ) { if ( needSuppressStart ( ) ) { return ; } switch ( state ) { case IN_TABLE_AT_START : case IN_TABLE_COLS_SEEN : case IN_TABLE_AT_POTENTIAL_ROW_GROUP_START : current = new RowGroup ( this , null ) ; case IN_IMPLICIT_ROW_GROUP : state = State . IN_ROW_IN_IMPLICIT_ROW_GROUP ; break ; case IN_ROW_GROUP : state = State . IN_ROW_IN_ROW_GROUP ; break ; default : suppressedStarts = 1 ; return ; } currentColRange = first ; previousColRange = null ; current . startRow ( ) ; } void endRow ( ) throws SAXException { if ( needSuppressEnd ( ) ) { return ; } switch ( state ) { case IN_ROW_IN_ROW_GROUP : state = State . IN_ROW_GROUP ; break ; case IN_ROW_IN_IMPLICIT_ROW_GROUP : state = State . IN_IMPLICIT_ROW_GROUP ; break ; default : throw new IllegalStateException ( "Bug!" ) ; } current . endRow ( ) ; } void startCell ( boolean header , Attributes attributes ) throws SAXException { if ( needSuppressStart ( ) ) { return ; } switch ( state ) { case IN_ROW_IN_ROW_GROUP : state = State . IN_CELL_IN_ROW_GROUP ; break ; case IN_ROW_IN_IMPLICIT_ROW_GROUP : state = State . IN_CELL_IN_IMPLICIT_ROW_GROUP ; break ; default : suppressedStarts = 1 ; return ; } if ( header ) { int len = attributes . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( "ID" . equals ( attributes . getType ( i ) ) ) { String val = attributes . getValue ( i ) ; if ( ! "" . equals ( val ) ) { headerIds . add ( val ) ; } } } } String [ ] headers = AttributeUtil . split ( attributes . getValue ( "" , "headers" ) ) ; Cell cell = new Cell ( Math . abs ( AttributeUtil . parsePositiveInteger ( attributes . getValue ( "" , "colspan" ) ) ) , Math . abs ( AttributeUtil . parseNonNegativeInteger ( attributes . getValue ( "" , "rowspan" ) ) ) , headers , header , owner . getDocumentLocator ( ) , owner . getErrorHandler ( ) ) ; if ( headers . length > 0 ) { cellsReferringToHeaders . add ( cell ) ; } current . cell ( cell ) ; } void endCell ( ) { if ( needSuppressEnd ( ) ) { return ; } switch ( state ) { case IN_CELL_IN_ROW_GROUP : state = State . IN_ROW_IN_ROW_GROUP ; break ; case IN_CELL_IN_IMPLICIT_ROW_GROUP : state = State . IN_ROW_IN_IMPLICIT_ROW_GROUP ; break ; default : throw new IllegalStateException ( "Bug!" ) ; } } void startColGroup ( int span ) { if ( needSuppressStart ( ) ) { return ; } switch ( state ) { case IN_TABLE_AT_START : hardWidth = true ; columnCount = 0 ; case IN_TABLE_COLS_SEEN : pendingColGroupSpan = span ; state = State . IN_COLGROUP ; break ; default : suppressedStarts = 1 ; break ; } } void endColGroup ( ) { if ( needSuppressEnd ( ) ) { return ; } switch ( state ) { case IN_COLGROUP : if ( pendingColGroupSpan != 0 ) { int right = columnCount + Math . abs ( pendingColGroupSpan ) ; Locator locator = new LocatorImpl ( owner . getDocumentLocator ( ) ) ; ColumnRange colRange = new ColumnRange ( "colgroup" , locator , columnCount , right ) ; appendColumnRange ( colRange ) ; columnCount = right ; } realColumnCount = columnCount ; state = State . IN_TABLE_COLS_SEEN ; break ; default : throw new IllegalStateException ( "Bug!" ) ; } } void startCol ( int span ) throws SAXException { if ( needSuppressStart ( ) ) { return ; } switch ( state ) { case IN_TABLE_AT_START : hardWidth = true ; columnCount = 0 ; case IN_TABLE_COLS_SEEN : state = State . IN_COL_IN_IMPLICIT_GROUP ; break ; case IN_COLGROUP : if ( pendingColGroupSpan > 0 ) { warn ( "A col element causes a span attribute with value " + pendingColGroupSpan + " to be ignored on the parent colgroup." ) ; } pendingColGroupSpan = 0 ; state = State . IN_COL_IN_COLGROUP ; break ; default : suppressedStarts = 1 ; return ; } int right = columnCount + Math . abs ( span ) ; Locator locator = new LocatorImpl ( owner . getDocumentLocator ( ) ) ; ColumnRange colRange = new ColumnRange ( "col" , locator , columnCount , right ) ; appendColumnRange ( colRange ) ; columnCount = right ; realColumnCount = columnCount ; } private void appendColumnRange ( ColumnRange colRange ) { if ( last == null ) { first = colRange ; last = colRange ; } else { last . setNext ( colRange ) ; last = colRange ; } } void warn ( String message ) throws SAXException { owner . warn ( message ) ; } void err ( String message ) throws SAXException { owner . err ( message ) ; } void endCol ( ) { if ( needSuppressEnd ( ) ) { return ; } switch ( state ) { case IN_COL_IN_IMPLICIT_GROUP : state = State . IN_TABLE_COLS_SEEN ; break ; case IN_COL_IN_COLGROUP : state = State . IN_COLGROUP ; break ; default : throw new IllegalStateException ( "Bug!" ) ; } } void end ( ) throws SAXException { switch ( state ) { case IN_IMPLICIT_ROW_GROUP : current . end ( ) ; current = null ; break ; case IN_TABLE_AT_START : case IN_TABLE_AT_POTENTIAL_ROW_GROUP_START : case IN_TABLE_COLS_SEEN : break ; default : throw new IllegalStateException ( "Bug!" ) ; } for ( Iterator < Cell > iter = cellsReferringToHeaders . iterator ( ) ; iter . hasNext ( ) ; ) { Cell cell = iter . next ( ) ; String [ ] headings = cell . getHeadings ( ) ; for ( int i = 0 ; i < headings . length ; i ++ ) { String heading = headings [ i ] ; if ( ! headerIds . contains ( heading ) ) { cell . err ( "The “headers” attribute on the element “" + cell . elementName ( ) + "” refers to the ID “" + heading + "”, but there is no “th” element with that ID in the same table." ) ; } } } ColumnRange colRange = first ; while ( colRange != null ) { if ( colRange . isSingleCol ( ) ) { owner . getErrorHandler ( ) . error ( new SAXParseException ( "Table column " + colRange + " established by element “" + colRange . getElement ( ) + "” has no cells beginning in it." , colRange . getLocator ( ) ) ) ; } else { owner . getErrorHandler ( ) . error ( new SAXParseException ( "Table columns in range " + colRange + " established by element “" + colRange . getElement ( ) + "” have no cells beginning in them." , colRange . getLocator ( ) ) ) ; } colRange = colRange . getNext ( ) ; } } int getColumnCount ( ) { return columnCount ; } void setColumnCount ( int columnCount ) { this . columnCount = columnCount ; } boolean isHardWidth ( ) { return hardWidth ; } void cell ( Cell cell ) { int left = cell . getLeft ( ) ; int right = cell . getRight ( ) ; if ( right > realColumnCount ) { if ( left == realColumnCount ) { if ( left + 1 != right ) { appendColumnRange ( new ColumnRange ( cell . elementName ( ) , cell , left + 1 , right ) ) ; } realColumnCount = right ; return ; } else { appendColumnRange ( new ColumnRange ( cell . elementName ( ) , cell , realColumnCount , right ) ) ; realColumnCount = right ; } } while ( currentColRange != null ) { int hit = currentColRange . hits ( left ) ; if ( hit == 0 ) { ColumnRange newRange = currentColRange . removeColumn ( left ) ; if ( newRange == null ) { if ( previousColRange != null ) { previousColRange . setNext ( currentColRange . getNext ( ) ) ; } if ( first == currentColRange ) { first = currentColRange . getNext ( ) ; } if ( last == currentColRange ) { last = previousColRange ; } currentColRange = currentColRange . getNext ( ) ; } else { if ( last == currentColRange ) { last = newRange ; } currentColRange = newRange ; } return ; } else if ( hit == - 1 ) { return ; } else if ( hit == 1 ) { previousColRange = currentColRange ; currentColRange = currentColRange . getNext ( ) ; } } } } 