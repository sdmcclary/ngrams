<<<<<<< HEAD
public final class ScriptDocHelper { private ScriptDocHelper ( ) { } public static final String DEFAULT_DELIMITER = System . getProperty ( "line.separator" , "\r\n" ) + "â€¢\t" ; public static String createMethodDocumentationHTML ( String identifier , FunctionDocumentation fDoc , IObject obj ) { return createMethodDocumentationHTML ( identifier , fDoc , obj , true , false ) ; } public static String createMethodDocumentationHTML ( String identifier , FunctionDocumentation fDoc , IObject obj , boolean addReturnTypes , boolean extended ) { StringBuffer sb = new StringBuffer ( ) ; TypedDescription [ ] pDocs = fDoc . getParams ( ) ; if ( pDocs . length == 0 ) { sb . append ( ScriptDocHelper . createMethodSignatureString ( identifier , fDoc , obj , true , addReturnTypes ) ) ; if ( fDoc . getDescription ( ) . trim ( ) != "" ) { sb . append ( "<br><br>" + fDoc . getDescription ( ) ) ; } } else { sb . append ( ScriptDocHelper . createMethodSignatureString ( identifier , fDoc , obj , true , addReturnTypes ) ) ; sb . append ( "<br><br>" + fDoc . getDescription ( ) ) ; } UserAgent [ ] agents = fDoc . getUserAgents ( ) ; if ( agents . length > 0 ) { sb . append ( Messages . ScriptDocHelper_Supported1 ) ; for ( int i = 0 ; i < agents . length ; i ++ ) { UserAgent ua = agents [ i ] ; sb . append ( ua . getPlatform ( ) + " " + ua . getVersion ( ) ) ; if ( i < agents . length - 1 ) { sb . append ( ", " ) ; } } } if ( extended ) { String [ ] examples = fDoc . getExamples ( ) ; if ( examples . length > 0 ) { for ( int i = 0 ; i < examples . length ; i ++ ) { String example = examples [ i ] ; if ( ! example . startsWith ( "<b>Example:" ) ) { example = "<b>Example:</b><br>" + example ; } sb . append ( "<br><br>" + example ) ; } } if ( fDoc . getRemarks ( ) . trim ( ) != "" ) { sb . append ( "<br><br>" + fDoc . getRemarks ( ) ) ; } if ( fDoc . getAliases ( ) != null && fDoc . getAliases ( ) . getTypes ( ) . length > 0 ) { sb . append ( "<br><br><b>Also known as:</b> " + StringUtils . join ( ", " , fDoc . getAliases ( ) . getTypes ( ) ) ) ; } } return sb . toString ( ) ; } public static String createMethodSignatureString ( String identifier , FunctionDocumentation mDoc , IObject obj , boolean asHTML ) { return createMethodSignatureString ( identifier , mDoc , obj , asHTML , true ) ; } public static String createMethodSignatureString ( String identifier , FunctionDocumentation mDoc , IObject obj , boolean asHTML , boolean addReturnTypes ) { StringBuffer methodSignature = new StringBuffer ( ) ; methodSignature . append ( "<b>" + identifier + "</b>" ) ; TypedDescription [ ] pDocs = mDoc . getParams ( ) ; String [ ] objParams = null ; if ( obj != null && obj instanceof JSFunction ) { objParams = ( ( JSFunction ) obj ) . getParameterNames ( ) ; } int objLen = objParams == null ? 0 : objParams . length ; int docLen = pDocs == null ? 0 : pDocs . length ; int maxLen = Math . max ( objLen , docLen ) ; if ( maxLen > 0 ) { methodSignature . append ( "(" ) ; } for ( int k = 0 ; k < maxLen ; k ++ ) { String docName = ( k < docLen ) ? pDocs [ k ] . getName ( ) : "" ; String docCmpr = docName . replaceAll ( "\\[(.*)\\]" , "$1" ) ; String objName = ( k < objLen ) ? objParams [ k ] : "" ; String name = ( objName . equals ( "" ) ) ? docName : objName ; name = ( docCmpr . equals ( name ) ) ? docName : name ; String types = "" ; if ( k < docLen ) { types = StringUtils . join ( "|" , pDocs [ k ] . getTypes ( ) ) ; } if ( ! types . equals ( "" ) ) { methodSignature . append ( "<b>" + name + "</b>: " + types ) ; } else { methodSignature . append ( "<b>" + name + "</b>: Object" ) ; } if ( k < maxLen - 1 ) { methodSignature . append ( ", " ) ; } } if ( maxLen > 0 ) { methodSignature . append ( ")" ) ; } if ( addReturnTypes ) { if ( mDoc . getReturn ( ) . getTypes ( ) . length > 0 ) { methodSignature . append ( " : " + StringUtils . join ( ", " , mDoc . getReturn ( ) . getTypes ( ) ) ) ; } else { methodSignature . append ( Messages . ScriptDocHelper_None1 ) ; } } if ( ! asHTML ) { return StringUtils . stripHTML ( methodSignature . toString ( ) ) ; } else { return methodSignature . toString ( ) ; } } public static String getInformationForLexeme ( JSOffsetMapper offsetMapper , Lexeme lexeme , boolean extended ) { return getInformationForLexemeSimple ( offsetMapper , lexeme , extended ) ; } private static String getInformationForLexemeSimple ( JSOffsetMapper offsetMapper , Lexeme lexeme , boolean extended ) { String result = "" ; if ( lexeme . getCategoryIndex ( ) == TokenCategories . KEYWORD ) { return Messages . ScriptDocHelper_JSKeyword + lexeme . getText ( ) + "</b>. " ; } if ( lexeme . getCategoryIndex ( ) == TokenCategories . LITERAL ) { return Messages . ScriptDocHelper_JSLiteral + lexeme . getText ( ) + "</b>. " ; } if ( lexeme . getCategoryIndex ( ) != TokenCategories . IDENTIFIER ) { return result ; } IDocumentation doc = null ; int curIndex = offsetMapper . getLexemeIndexFromDocumentOffset ( lexeme . offset + lexeme . length ) ; String fullName = JSOffsetMapper . getIdentName ( curIndex , offsetMapper . getLexemeList ( ) ) ; IScope scope = offsetMapper . getScope ( lexeme , offsetMapper . getGlobal ( ) ) ; IObject obj = offsetMapper . lookupReturnTypeFromNameHash ( fullName , scope , true ) ; if ( obj != null ) { doc = obj . getDocumentation ( ) ; if ( doc != null && doc instanceof FunctionDocumentation ) { return createMethodDocumentationHTML ( lexeme . getText ( ) , ( FunctionDocumentation ) doc , obj , true , extended ) ; } else if ( doc != null && doc instanceof PropertyDocumentation ) { return createPropertyDocumentationHTML ( lexeme . getText ( ) , ( PropertyDocumentation ) doc , true , true , extended ) ; } else if ( obj instanceof JSFunction ) { doc = new FunctionDocumentation ( ) ; doc . setName ( fullName ) ; return createMethodDocumentationHTML ( lexeme . getText ( ) , ( FunctionDocumentation ) doc , obj , true , extended ) ; } } return result ; } public static String createPropertyDocumentationHTML ( String identifier , PropertyDocumentation pDoc , boolean asHTML ) { return createPropertyDocumentationHTML ( identifier , pDoc , asHTML , true , false ) ; } public static String createPropertyDocumentationHTML ( String identifier , PropertyDocumentation pDoc , boolean asHTML , boolean addReturnTypes , boolean extended ) { StringBuffer propertySignature = new StringBuffer ( ) ; propertySignature . append ( "<b>" + identifier + "</b>" ) ; if ( addReturnTypes ) { if ( pDoc . getReturn ( ) . getTypes ( ) . length > 0 ) { propertySignature . append ( " : " + StringUtils . join ( ", " , pDoc . getReturn ( ) . getTypes ( ) ) ) ; } else { propertySignature . append ( Messages . ScriptDocHelper_None2 ) ; } } propertySignature . append ( "<br><br>" + pDoc . getDescription ( ) + "<br>" ) ; UserAgent [ ] agents = pDoc . getUserAgents ( ) ; if ( agents . length > 0 ) { propertySignature . append ( Messages . ScriptDocHelper_Supported2 ) ; for ( int i = 0 ; i < agents . length ; i ++ ) { UserAgent ua = agents [ i ] ; propertySignature . append ( ua . getPlatform ( ) + " " + ua . getVersion ( ) ) ; if ( i < agents . length - 1 ) { propertySignature . append ( ", " ) ; } } } if ( extended ) { String [ ] examples = pDoc . getExamples ( ) ; if ( examples . length > 0 ) { for ( int i = 0 ; i < examples . length ; i ++ ) { String example = examples [ i ] ; if ( ! example . startsWith ( "<b>Example:" ) ) { example = "<b>Example:</b><br>" + example ; } propertySignature . append ( "<br><br>" + example + "<br>" ) ; } } if ( pDoc . getRemarks ( ) . trim ( ) != "" ) { propertySignature . append ( "<br><br>" + pDoc . getRemarks ( ) + "<br>" ) ; } } String propString = propertySignature . toString ( ) ; if ( asHTML ) { return propString ; } else { return StringUtils . stripHTML ( propString ) ; } } public static String createPropertyDocumentationHTMLSimple ( String identifier , PropertyDocumentation pDoc , boolean asHTML ) { StringBuffer propertySignature = new StringBuffer ( ) ; propertySignature . append ( "<b>" + identifier + "</b>" ) ; if ( pDoc . getReturn ( ) . getTypes ( ) . length > 0 ) { propertySignature . append ( " : " + StringUtils . join ( ", " , pDoc . getReturn ( ) . getTypes ( ) ) ) ; } propertySignature . append ( "<br><br>" + pDoc . getDescription ( ) + "<br>" ) ; UserAgent [ ] agents = pDoc . getUserAgents ( ) ; if ( agents . length > 0 ) { propertySignature . append ( Messages . ScriptDocHelper_Supported3 ) ; for ( int i = 0 ; i < agents . length ; i ++ ) { UserAgent ua = agents [ i ] ; propertySignature . append ( ua . getPlatform ( ) + " " + ua . getVersion ( ) ) ; if ( i < agents . length - 1 ) { propertySignature . append ( ", " ) ; } } } String propString = propertySignature . toString ( ) ; if ( asHTML ) { return propString ; } else { return StringUtils . stripHTML ( propString ) ; } } public static String createGenericDocumentationHTML ( String identifier , IDocumentation pDoc , boolean asHTML ) { StringBuffer propertySignature = new StringBuffer ( ) ; propertySignature . append ( "<b>" + identifier + "</b>" ) ; propertySignature . append ( " : " + propertySignature . append ( pDoc . getClass ( ) . getName ( ) ) ) ; String propString = propertySignature . toString ( ) ; if ( asHTML ) { return propString ; } else { return StringUtils . stripHTML ( propString ) ; } } public static String createParameterDocumentationList ( TypedDescription [ ] parameterDocs , IObject obj ) { StringBuffer paramText = new StringBuffer ( ) ; String [ ] parameterNames = null ; if ( obj != null && obj instanceof JSFunction ) { parameterNames = ( ( JSFunction ) obj ) . getParameterNames ( ) ; } if ( containsNonEmptyDescription ( parameterDocs ) == false ) { return null ; } if ( parameterNames != null ) { for ( int i = 0 ; i < parameterNames . length ; i ++ ) { String parameterName = parameterNames [ i ] ; TypedDescription curResult = findMatchingParameterDocumentation ( parameterName , parameterDocs ) ; paramText . append ( createParameterDocumentation ( curResult ) ) ; if ( i < parameterDocs . length - 1 ) { paramText . append ( DEFAULT_DELIMITER ) ; } } } else { for ( int i = 0 ; i < parameterDocs . length ; i ++ ) { TypedDescription parameter = parameterDocs [ i ] ; paramText . append ( createParameterDocumentation ( parameter ) ) ; if ( i < parameterDocs . length - 1 ) { paramText . append ( DEFAULT_DELIMITER ) ; } } } return wrapString ( paramText . toString ( ) , 420 , UnifiedConfiguration . getNewlineString ( ) ) ; } private static String createParameterDocumentation ( TypedDescription parameterDoc ) { String paramInfo = "" ; String name = "" ; if ( parameterDoc != null ) { paramInfo = wrapString ( StringUtils . formatAsPlainText ( parameterDoc . getDescription ( ) ) , 370 , UnifiedConfiguration . getNewlineString ( ) + "\t" ) ; name = parameterDoc . getName ( ) ; } return name + ":" + UnifiedConfiguration . getNewlineString ( ) + "\t" + paramInfo ; } private static TypedDescription findMatchingParameterDocumentation ( String parameterName , TypedDescription [ ] parameterDocs ) { TypedDescription curResult = null ; for ( int j = 0 ; j < parameterDocs . length ; j ++ ) { TypedDescription param = parameterDocs [ j ] ; String name = StringUtils . trimBrackets ( param . getName ( ) . toUpperCase ( ) ) ; if ( name . equals ( parameterName . toUpperCase ( ) ) ) { curResult = param ; break ; } else if ( j == parameterDocs . length - 1 && name . equals ( "..." ) ) { curResult = param ; break ; } } return curResult ; } private static boolean containsNonEmptyDescription ( TypedDescription [ ] params ) { boolean foundDescription = false ; for ( int j = 0 ; j < params . length ; j ++ ) { TypedDescription param = params [ j ] ; if ( param . getDescription ( ) != null && ! "" . equals ( param . getDescription ( ) ) ) { foundDescription = true ; } } return foundDescription ; } private static String wrapString ( String s , int maxWidth , String delimiter ) { StringReader sr = new StringReader ( s ) ; GC gc = new GC ( Display . getCurrent ( ) ) ; String result = "" ; com . aptana . ide . editors . unified . utils . LineBreakingReader r = new LineBreakingReader ( sr , gc , maxWidth ) ; try { String line = r . readLine ( ) ; while ( line != null ) { result += line ; line = r . readLine ( ) ; if ( line != null ) { result += delimiter ; } } } catch ( IOException e ) { } gc . dispose ( ) ; return result ; } } 
=======
public final class Idref extends Id { public static final Idref THE_INSTANCE = new Idref ( ) ; private Idref ( ) { super ( ) ; } @ Override public String getName ( ) { return "id reference" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
