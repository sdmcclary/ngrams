<<<<<<< HEAD
public class AbstractionGrid { private static final boolean DEBUG = false ; private TextGrid grid ; public static AbstractionGrid makeUsingBuffer ( TextGrid internalGrid ) { if ( internalGrid . getWidth ( ) % 3 != 0 || internalGrid . getHeight ( ) % 3 != 0 ) throw new IllegalArgumentException ( "Passed TextGrid must have dimensions that are divisible by 3." ) ; AbstractionGrid result = new AbstractionGrid ( internalGrid . getWidth ( ) / 3 , internalGrid . getHeight ( ) / 3 ) ; result . setInternalBuffer ( internalGrid ) ; return result ; } public AbstractionGrid ( TextGrid textGrid , CellSet cellSet ) { this ( textGrid . getWidth ( ) , textGrid . getHeight ( ) ) ; if ( DEBUG ) { System . out . println ( "Making AbstractionGrid using buffer:" ) ; textGrid . printDebug ( ) ; System . out . println ( "...and the following CellSet:" ) ; cellSet . printAsGrid ( ) ; } Iterator it = cellSet . iterator ( ) ; while ( it . hasNext ( ) ) { TextGrid . Cell cell = ( TextGrid . Cell ) it . next ( ) ; if ( textGrid . isBlank ( cell ) ) continue ; if ( textGrid . isCross ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeCross ( ) ) ; } else if ( textGrid . isT ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeT ( ) ) ; } else if ( textGrid . isK ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeK ( ) ) ; } else if ( textGrid . isInverseT ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeInverseT ( ) ) ; } else if ( textGrid . isInverseK ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeInverseK ( ) ) ; } else if ( textGrid . isCorner1 ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeCorner1 ( ) ) ; } else if ( textGrid . isCorner2 ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeCorner2 ( ) ) ; } else if ( textGrid . isCorner3 ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeCorner3 ( ) ) ; } else if ( textGrid . isCorner4 ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeCorner4 ( ) ) ; } else if ( textGrid . isHorizontalLine ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeHorizontalLine ( ) ) ; } else if ( textGrid . isVerticalLine ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeVerticalLine ( ) ) ; } else if ( textGrid . isCrossOnLine ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeCross ( ) ) ; } else if ( textGrid . isStarOnLine ( cell ) ) { set ( cell . x , cell . y , AbstractCell . makeStar ( ) ) ; } } if ( DEBUG ) { System . out . println ( "...the resulting AbstractionGrid is:" ) ; grid . printDebug ( ) ; } } private AbstractionGrid ( int width , int height ) { grid = new TextGrid ( width * 3 , height * 3 ) ; } public TextGrid getCopyOfInternalBuffer ( ) { return new TextGrid ( grid ) ; } private void setInternalBuffer ( TextGrid grid ) { this . grid = grid ; } public int getWidth ( ) { return grid . getWidth ( ) / 3 ; } public int getHeight ( ) { return grid . getHeight ( ) / 3 ; } public TextGrid getAsTextGrid ( ) { TextGrid result = new TextGrid ( getWidth ( ) , getHeight ( ) ) ; for ( int y = 0 ; y < grid . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < grid . getWidth ( ) ; x ++ ) { TextGrid . Cell cell = grid . new Cell ( x , y ) ; if ( ! grid . isBlank ( cell ) ) result . set ( x / 3 , y / 3 , '*' ) ; } } if ( DEBUG ) { System . out . println ( "Getting AbstractionGrid as textGrid.\nAbstractionGrid:" ) ; grid . printDebug ( ) ; System . out . println ( "...as text grid:" ) ; result . printDebug ( ) ; } return result ; } public ArrayList getDistinctShapes ( ) { ArrayList result = new ArrayList ( ) ; CellSet nonBlank = grid . getAllNonBlank ( ) ; ArrayList distinct = nonBlank . breakIntoDistinctBoundaries ( ) ; Iterator it = distinct . iterator ( ) ; while ( it . hasNext ( ) ) { CellSet set = ( CellSet ) it . next ( ) ; AbstractionGrid temp = new AbstractionGrid ( this . getWidth ( ) , this . getHeight ( ) ) ; temp . fillCells ( set ) ; result . add ( temp . getAsTextGrid ( ) . getAllNonBlank ( ) ) ; } return result ; } protected void fillCells ( CellSet cells ) { grid . fillCellsWith ( cells , '*' ) ; } public void set ( int xPos , int yPos , AbstractCell cell ) { xPos *= 3 ; yPos *= 3 ; for ( int y = 0 ; y < 3 ; y ++ ) { for ( int x = 0 ; x < 3 ; x ++ ) { if ( cell . rows [ x ] [ y ] == 1 ) { grid . set ( xPos + x , yPos + y , '*' ) ; } } } } } 
=======
public class VerifierFactorySchemaReader extends AbstractSchemaReader { private final VerifierFactory vf ; static private class SchemaImpl extends AbstractSchema { final org . iso_relax . verifier . Schema schema ; private SchemaImpl ( org . iso_relax . verifier . Schema schema ) { this . schema = schema ; } public Validator createValidator ( PropertyMap properties ) { try { return new VerifierValidator ( schema . newVerifier ( ) , properties ) ; } catch ( VerifierConfigurationException e ) { Exception cause = e . getCauseException ( ) ; if ( cause instanceof RuntimeException && ( e . getMessage ( ) == null || e . getMessage ( ) . equals ( cause . getMessage ( ) ) ) ) throw ( RuntimeException ) cause ; throw new JarvConfigurationException ( e ) ; } } } public VerifierFactorySchemaReader ( VerifierFactory vf ) { this . vf = vf ; } public Schema createSchema ( SAXSource source , PropertyMap properties ) throws IOException , SAXException , IncorrectSchemaException { try { return new SchemaImpl ( vf . compileSchema ( source . getInputSource ( ) ) ) ; } catch ( SAXException e ) { System . err . println ( "compileSchema threw a SAXException class " + e . getClass ( ) . toString ( ) ) ; if ( e . getException ( ) != null ) System . err . println ( "cause has class " + e . getException ( ) . getClass ( ) . toString ( ) ) ; throw e ; } catch ( VerifierConfigurationException e ) { for ( ; ; ) { Exception cause = e . getCauseException ( ) ; String message = e . getMessage ( ) ; if ( cause != null && message != null && message . equals ( cause . getMessage ( ) ) ) message = null ; if ( message == null ) { if ( cause instanceof RuntimeException ) throw ( RuntimeException ) cause ; if ( cause instanceof SAXException ) throw ( SAXException ) cause ; if ( cause instanceof IOException ) throw ( IOException ) cause ; if ( cause instanceof VerifierConfigurationException ) { e = ( VerifierConfigurationException ) cause ; continue ; } } throw new SAXException ( message , cause ) ; } } } public Option getOption ( String uri ) { return null ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
