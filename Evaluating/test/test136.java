<<<<<<< HEAD
public class Manager { private static final Logger LOG = Logger . getLogger ( Manager . class . getName ( ) ) ; static final String KEY_PLUGINS_PACKAGES = "plugins.packages" ; static final String KEY_PLUGINS_PACKAGES_TS = "plugins.packages.ts" ; private static final String KEY_PLUGINS_UNINSTALL = "plugins.uninstall" ; private static final String PACKAGE_NAME_SEPARATOR = ";" ; private static final String PACKAGE_XML = "package.xml" ; private static final String PACKAGE_FILENAME_PATTERN = ".*\\.(jar|zip)\\s*$" ; private static final String NODE_PACKAGE = "package" ; private static final String ATTR_PACKAGE_NAME = "name" ; private static final String ATTR_PACKAGE_DESCRIPTION = "description" ; private static final String ATTR_PACKAGE_VERSION = "version" ; private static final String ATTR_PACKAGE_AUTHOR = "author" ; private static final String ATTR_PACKAGE_EMAIL = "email" ; private static final String NODE_THEME = "theme" ; private static final String NODE_ACTIONS = "actions" ; private static final String NODE_RESOURCES = "resources" ; private static final String NODE_STRINGS = "strings" ; private static final String NODE_PREFERENCES = "preferences" ; private static final String NODE_SMARTFEED = "smartfeed" ; private static final String NODE_CODE = "code" ; private static final String NODE_TOOLBAR = "toolbar" ; private static final List < Package > INSTALLED_PACKAGES = new ArrayList < Package > ( ) ; private static boolean installedPackagesLoaded ; private static File pluginDirectory ; private static Preferences prefs ; private static List < String > uninstallFilenames ; private static List < Package > enabledPackages ; public static void initialize ( File pluginDirectory , Preferences appPrefs ) { Manager . pluginDirectory = pluginDirectory ; Manager . prefs = appPrefs ; if ( ! pluginDirectory . exists ( ) ) pluginDirectory . mkdirs ( ) ; doAutoDeployment ( ) ; doUninstall ( ) ; uninstallFilenames = new ArrayList < String > ( ) ; } public static void loadPackages ( ) { enabledPackages = new ArrayList < Package > ( ) ; List < File > packages = getPackages ( ) ; for ( File pckg : packages ) { Package p = load ( pckg ) ; if ( p != null ) { try { p . initialize ( ) ; } catch ( Throwable e ) { LOG . log ( Level . SEVERE , "Failed to initailize the action." , e ) ; } enabledPackages . add ( p ) ; } } } public static List < Package > getEnabledPackages ( ) { return Collections . unmodifiableList ( enabledPackages ) ; } public static void setEnabledPackages ( List < Package > enabled ) { enabledPackages = enabled ; List < String > names = new ArrayList < String > ( ) ; if ( enabled != null ) for ( Package pkg : enabled ) names . add ( pkg . getFileName ( ) ) ; prefs . put ( KEY_PLUGINS_PACKAGES , StringUtils . join ( names . iterator ( ) , PACKAGE_NAME_SEPARATOR ) ) ; prefs . putLong ( KEY_PLUGINS_PACKAGES_TS , System . currentTimeMillis ( ) ) ; } public static List < Package > getInstalledPackages ( ) { synchronized ( INSTALLED_PACKAGES ) { if ( ! installedPackagesLoaded ) { installedPackagesLoaded = true ; INSTALLED_PACKAGES . clear ( ) ; File [ ] files = pluginDirectory . listFiles ( ) ; for ( File file : files ) { if ( ( file . isDirectory ( ) || file . getName ( ) . matches ( PACKAGE_FILENAME_PATTERN ) ) && ! uninstallFilenames . contains ( file . getName ( ) ) ) { Package p = load ( file ) ; if ( p != null ) INSTALLED_PACKAGES . add ( p ) ; } } } } return INSTALLED_PACKAGES ; } public static List < Package > reloadInstalledPackages ( ) { synchronized ( INSTALLED_PACKAGES ) { installedPackagesLoaded = false ; return getInstalledPackages ( ) ; } } public static String install ( File packageFile ) { String error = null ; if ( isPackage ( packageFile ) ) { String name = packageFile . getName ( ) ; File dest = new File ( pluginDirectory , name ) ; if ( dest . exists ( ) ) { if ( uninstallFilenames . contains ( name ) ) { error = Strings . message ( "plugin.manager.install.uninstall" ) ; } else { error = Strings . message ( "plugin.manager.install.exists" ) ; } } else { try { FileUtils . copyRec ( packageFile , pluginDirectory ) ; } catch ( IOException e ) { error = Strings . message ( "plugin.manager.install.failed" ) ; LOG . log ( Level . WARNING , error , e ) ; } } } else error = Strings . message ( "plugin.manager.install.invalid" ) ; return error ; } public static void uninstall ( Package ... packages ) { for ( Package pkg : packages ) { String fn = pkg . getFileName ( ) ; if ( ! uninstallFilenames . contains ( fn ) ) uninstallFilenames . add ( fn ) ; } updateUninstallFilenamesProperty ( ) ; } private static void updateUninstallFilenamesProperty ( ) { prefs . put ( KEY_PLUGINS_UNINSTALL , StringUtils . join ( uninstallFilenames . iterator ( ) , PACKAGE_NAME_SEPARATOR ) ) ; } private static void doUninstall ( ) { String [ ] names = getPackageNames ( KEY_PLUGINS_UNINSTALL ) ; prefs . remove ( KEY_PLUGINS_UNINSTALL ) ; for ( String name : names ) { File file = new File ( pluginDirectory , name ) ; if ( ! file . exists ( ) ) continue ; if ( file . isFile ( ) ) file . delete ( ) ; else FileUtils . rmdir ( file ) ; } } private static void doAutoDeployment ( ) { ClassLoader loader = Manager . class . getClassLoader ( ) ; try { FilenameFilter pluginFilter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name != null && name . endsWith ( ".zip" ) ; } } ; String [ ] pluginNames = { "bb-connect.zip" } ; File [ ] deployedFiles = pluginDirectory . listFiles ( pluginFilter ) ; Map < String , Long > ntsExisting = new HashMap < String , Long > ( ) ; for ( File file : deployedFiles ) ntsExisting . put ( file . getName ( ) , file . length ( ) ) ; List < String > enPackNames = null ; for ( String name : pluginNames ) { String resource = "resources/plug-ins/" + name ; long size = getResourceSize ( loader , resource ) ; Long exSize = ntsExisting . get ( name ) ; if ( exSize == null || exSize != size ) { CommonUtils . copyResourceToFile ( resource , new File ( pluginDirectory , name ) . getAbsolutePath ( ) ) ; if ( exSize == null ) { if ( enPackNames == null ) { List < String > list = Arrays . asList ( getPackageNames ( KEY_PLUGINS_PACKAGES ) ) ; enPackNames = new LinkedList < String > ( list ) ; } if ( ! enPackNames . contains ( name ) ) enPackNames . add ( name ) ; } } } if ( enPackNames != null ) { prefs . put ( KEY_PLUGINS_PACKAGES , StringUtils . join ( enPackNames . iterator ( ) , PACKAGE_NAME_SEPARATOR ) ) ; prefs . putLong ( KEY_PLUGINS_PACKAGES_TS , System . currentTimeMillis ( ) ) ; } } catch ( Exception e ) { LOG . log ( Level . SEVERE , "Couldn't perform auto-deployment." , e ) ; } } private static long getResourceSize ( ClassLoader loader , String resource ) throws IOException { URL url = loader . getResource ( resource ) ; URLConnection con = url . openConnection ( ) ; return ( long ) con . getContentLength ( ) ; } public static void storeState ( Map < String , Object > preferences ) { String list = StringUtils . join ( getPackageNames ( KEY_PLUGINS_PACKAGES ) , PACKAGE_NAME_SEPARATOR ) ; if ( StringUtils . isNotEmpty ( list ) ) { preferences . put ( KEY_PLUGINS_PACKAGES , StringUtils . toUTF8 ( list ) ) ; long ts = prefs . getLong ( KEY_PLUGINS_PACKAGES_TS , - 1 ) ; if ( ts != - 1 ) preferences . put ( KEY_PLUGINS_PACKAGES_TS , StringUtils . toUTF8 ( Long . toString ( ts ) ) ) ; } } public static void restoreState ( Map < String , Object > preferences ) { String list = StringUtils . fromUTF8 ( ( byte [ ] ) preferences . get ( KEY_PLUGINS_PACKAGES ) ) ; if ( StringUtils . isNotEmpty ( list ) ) { long ts = - 1 ; String tsS = StringUtils . fromUTF8 ( ( byte [ ] ) preferences . get ( KEY_PLUGINS_PACKAGES_TS ) ) ; if ( StringUtils . isNotEmpty ( tsS ) ) ts = Long . parseLong ( tsS ) ; long localTs = prefs . getLong ( KEY_PLUGINS_PACKAGES_TS , - 1 ) ; if ( localTs < ts || localTs == - 1 ) { prefs . put ( KEY_PLUGINS_PACKAGES , list ) ; prefs . putLong ( KEY_PLUGINS_PACKAGES_TS , ts ) ; } } } private static List < File > getPackages ( ) { List < File > packages = new ArrayList < File > ( ) ; String [ ] names = getPackageNames ( KEY_PLUGINS_PACKAGES ) ; String [ ] names2 = new String [ names . length + 2 ] ; names2 [ 0 ] = "bb-recovery" ; names2 [ 1 ] = "bb-recovery.zip" ; System . arraycopy ( names , 0 , names2 , 2 , names . length ) ; for ( String name : names2 ) { File file = new File ( pluginDirectory , name ) ; if ( file . exists ( ) ) packages . add ( file ) ; } return packages ; } private static String [ ] getPackageNames ( String key ) { String pluginPackageNames = prefs . get ( key , "" ) ; return StringUtils . split ( pluginPackageNames , PACKAGE_NAME_SEPARATOR ) ; } private static boolean isPackage ( File file ) { boolean is = false ; if ( file . exists ( ) ) { try { if ( file . isDirectory ( ) ) { is = new File ( file , PACKAGE_XML ) . exists ( ) ; } else if ( file . getName ( ) . matches ( PACKAGE_FILENAME_PATTERN ) ) { URL fileURL = file . toURL ( ) ; ClassLoader loader = new URLClassLoader ( new URL [ ] { fileURL } , Manager . class . getClassLoader ( ) ) ; is = loader . getResourceAsStream ( PACKAGE_XML ) != null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } return is ; } private static Package load ( File packageFile ) { Package p = null ; InputStream is = null ; try { ClassLoader loader = new URLClassLoader ( new URL [ ] { packageFile . toURL ( ) } , Manager . class . getClassLoader ( ) ) ; is = loader . getResourceAsStream ( PACKAGE_XML ) ; if ( is != null ) { SAXBuilder b = new SAXBuilder ( false ) ; b . setEntityResolver ( EmptyEntityResolver . INSTANCE ) ; Document doc = b . build ( XmlReaderFactory . create ( is ) ) ; p = descriptorToPackage ( doc , packageFile , loader ) ; } } catch ( Exception e ) { LOG . log ( Level . WARNING , "Failed to load plug-in package: " + packageFile , e ) ; } finally { try { if ( is != null ) is . close ( ) ; } catch ( IOException e ) { } } return p ; } private static Package descriptorToPackage ( Document doc , File packageFile , ClassLoader loader ) throws LoaderException { Element elPackage = doc . getRootElement ( ) ; if ( ! NODE_PACKAGE . equals ( elPackage . getName ( ) ) ) throw new LoaderException ( "Wrong root element" ) ; String name = elPackage . getAttributeValue ( ATTR_PACKAGE_NAME ) ; String desc = elPackage . getAttributeValue ( ATTR_PACKAGE_DESCRIPTION ) ; if ( StringUtils . isEmpty ( name ) ) throw new LoaderException ( "Package name isn't specified" ) ; if ( StringUtils . isEmpty ( desc ) ) throw new LoaderException ( "Package description isn't specified" ) ; Package p = new Package ( packageFile . getName ( ) , name , desc , elPackage . getAttributeValue ( ATTR_PACKAGE_VERSION ) , elPackage . getAttributeValue ( ATTR_PACKAGE_AUTHOR ) , elPackage . getAttributeValue ( ATTR_PACKAGE_EMAIL ) ) ; List elements = elPackage . getChildren ( ) ; for ( Object elementO : elements ) { Element element = ( Element ) elementO ; String elName = element . getName ( ) ; IPlugin plugin = null ; if ( NODE_THEME . equals ( elName ) ) { plugin = parseTheme ( element , loader ) ; } else if ( NODE_ACTIONS . equals ( elName ) ) { plugin = parseActions ( element , loader ) ; } else if ( NODE_RESOURCES . equals ( elName ) ) { plugin = parseResources ( element , loader ) ; } else if ( NODE_STRINGS . equals ( elName ) ) { plugin = parseStrings ( element , loader ) ; } else if ( NODE_PREFERENCES . equals ( elName ) ) { plugin = parsePreferences ( element ) ; } else if ( NODE_SMARTFEED . equals ( elName ) ) { plugin = parseSmartFeed ( element , loader ) ; } else if ( NODE_CODE . equals ( elName ) ) { plugin = parseCode ( element , loader ) ; } else if ( NODE_TOOLBAR . equals ( elName ) ) { plugin = parseToolbar ( element ) ; } if ( plugin != null ) p . add ( plugin ) ; } return p ; } private static IPlugin parseTheme ( Element element , ClassLoader loader ) { IPlugin tp = null ; try { tp = ThemePlugin . create ( element , loader ) ; } catch ( LoaderException e ) { LOG . log ( Level . WARNING , "Failed to load a theme" , e ) ; } return tp ; } private static IPlugin parseActions ( Element element , ClassLoader loader ) { ActionsPlugin pl = null ; try { pl = new ActionsPlugin ( element , loader ) ; } catch ( IllegalArgumentException e ) { LOG . log ( Level . WARNING , "Failed to create plug-in." , e ) ; } return pl ; } private static IPlugin parseResources ( Element element , ClassLoader loader ) { ResourcesPlugin pl = null ; try { pl = new ResourcesPlugin ( element , loader ) ; } catch ( IllegalArgumentException e ) { LOG . log ( Level . WARNING , "Failed to create plug-in." , e ) ; } return pl ; } private static IPlugin parseStrings ( Element element , ClassLoader loader ) { StringsPlugin pl = null ; try { pl = new StringsPlugin ( element , loader ) ; } catch ( IllegalArgumentException e ) { LOG . log ( Level . WARNING , "Failed to create plug-in." , e ) ; } return pl ; } private static IPlugin parseSmartFeed ( Element element , ClassLoader loader ) { IPlugin pl = null ; try { pl = SmartFeedPlugin . create ( element , loader ) ; } catch ( LoaderException e ) { LOG . log ( Level . WARNING , "Failed to load a smart feed plug-in" , e ) ; } return pl ; } private static IPlugin parsePreferences ( Element element ) { return new AdvancedPreferencesPlugin ( element ) ; } private static IPlugin parseCode ( Element element , ClassLoader loader ) { IPlugin pl = null ; try { pl = CodePlugin . create ( element , loader ) ; } catch ( LoaderException e ) { LOG . log ( Level . WARNING , "Failed to load a code plug-in" , e ) ; } return pl ; } private static IPlugin parseToolbar ( Element element ) { IPlugin pl = null ; try { pl = new ToolbarPlugin ( element ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , "Failed to load a code plug-in" , e ) ; } return pl ; } } 
=======
class NsNameExceptNameClass implements NameClass { private final NameClass nameClass ; private final String namespaceURI ; NsNameExceptNameClass ( String namespaceURI , NameClass nameClass ) { this . namespaceURI = namespaceURI ; this . nameClass = nameClass ; } public boolean contains ( Name name ) { return ( this . namespaceURI . equals ( name . getNamespaceUri ( ) ) && ! nameClass . contains ( name ) ) ; } public int containsSpecificity ( Name name ) { return contains ( name ) ? SPECIFICITY_NS_NAME : SPECIFICITY_NONE ; } public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof NsNameExceptNameClass ) ) return false ; NsNameExceptNameClass other = ( NsNameExceptNameClass ) obj ; return ( namespaceURI . equals ( other . namespaceURI ) && nameClass . equals ( other . nameClass ) ) ; } public int hashCode ( ) { return namespaceURI . hashCode ( ) ^ nameClass . hashCode ( ) ; } public void accept ( NameClassVisitor visitor ) { visitor . visitNsNameExcept ( namespaceURI , nameClass ) ; } public boolean isOpen ( ) { return true ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
