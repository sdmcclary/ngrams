public class BenchMark extends TestCase { protected Properties setup = new Properties ( System . getProperties ( ) ) ; protected File workDir ; public BenchMark ( String [ ] settings , String name ) { super ( name ) ; try { for ( String f : settings ) { FileInputStream fin = new FileInputStream ( f ) ; setup . load ( fin ) ; fin . close ( ) ; } System . setProperties ( setup ) ; } catch ( IOException ex ) { Log . log ( "Can't load settings" , LogLevels . FATALERROR ) ; } workDir = new File ( setup . getProperty ( "workdir" , "+tmp-test" ) ) ; if ( ! workDir . exists ( ) && ! workDir . mkdir ( ) ) Log . log ( "Can't create workdir " + workDir , LogLevels . FATALERROR ) ; } protected void exec ( final String program , final String [ ] args , final boolean stderr , final String logFile , final long timeout ) throws IOException { if ( program . startsWith ( "!" ) ) { try { Class pc = Class . forName ( program . substring ( 1 ) ) ; final Method main = pc . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; OutputStream lout = System . out ; PrintStream ps = null ; PrintStream old = null ; try { if ( logFile != null ) { lout = new FileOutputStream ( logFile ) ; ps = new PrintStream ( lout ) ; ps . flush ( ) ; if ( stderr ) { old = System . err ; System . setErr ( ps ) ; } else { old = System . out ; System . setOut ( ps ) ; } } final Thread runner = new Thread ( ) { @ Override public void run ( ) { try { main . invoke ( null , new Object [ ] { args } ) ; } catch ( InvocationTargetException ex ) { if ( ex . getCause ( ) instanceof ThreadDeath ) Log . log ( "Killed by timeout" , LogLevels . WARNING ) ; else Log . log ( "Exception executing " + program , LogLevels . ERROR , ex ) ; } catch ( IllegalArgumentException ex ) { Log . log ( "Exception executing " + program , LogLevels . ERROR , ex ) ; } catch ( IllegalAccessException ex ) { Log . log ( "Exception executing " + program , LogLevels . ERROR , ex ) ; } catch ( ThreadDeath ex ) { Log . log ( "Killed by timeout" , LogLevels . WARNING ) ; } catch ( Throwable ex ) { Log . log ( "Exception executing " + program , LogLevels . ERROR , ex ) ; } } } ; runner . start ( ) ; Thread . yield ( ) ; long now = System . currentTimeMillis ( ) ; try { runner . join ( timeout ) ; } catch ( InterruptedException ex1 ) { } if ( runner . isAlive ( ) && ( System . currentTimeMillis ( ) - now ) >= timeout ) { runner . stop ( ) ; } } finally { if ( logFile != null ) { ps . flush ( ) ; lout . close ( ) ; if ( stderr ) { System . setErr ( old ) ; } else { System . setOut ( old ) ; } } } } catch ( SecurityException ex ) { Log . log ( "Exception executing " + program , LogLevels . ERROR , ex ) ; } catch ( NoSuchMethodException ex ) { Log . log ( "Exception executing " + program , LogLevels . ERROR , ex ) ; } catch ( ClassNotFoundException ex ) { Log . log ( "Exception executing " + program , LogLevels . ERROR , ex ) ; } } else { String [ ] args2 = new String [ args . length + 1 ] ; args2 [ 0 ] = program ; List < String > env = new LinkedList < String > ( ) ; for ( Enumeration en = System . getProperties ( ) . propertyNames ( ) ; en . hasMoreElements ( ) ; ) { String key = ( String ) en . nextElement ( ) ; if ( ! key . startsWith ( "java." ) && ! key . startsWith ( "sun." ) ) env . add ( key . replace ( '.' , '_' ) + "=" + System . getProperty ( key ) ) ; } System . arraycopy ( args , 0 , args2 , 1 , args . length ) ; final Process p = Runtime . getRuntime ( ) . exec ( args2 , env . toArray ( new String [ env . size ( ) ] ) ) ; final Thread mainThread = Thread . currentThread ( ) ; Thread watchDog = new Thread ( ) { @ Override public void run ( ) { try { Thread . sleep ( timeout ) ; Log . log ( "Interrupting process." , LogLevels . WARNING ) ; mainThread . interrupt ( ) ; } catch ( InterruptedException ex ) { ; } } } ; watchDog . start ( ) ; ( new Thread ( ) { @ Override public void run ( ) { OutputStream lout = System . out ; try { if ( logFile != null ) lout = new FileOutputStream ( logFile ) ; IOUtil . copyStream ( stderr ? p . getErrorStream ( ) : p . getInputStream ( ) , lout ) ; } catch ( IOException ex ) { Log . log ( "Error copying process out" , LogLevels . ERROR ) ; } finally { if ( logFile != null ) { try { lout . flush ( ) ; lout . close ( ) ; } catch ( IOException ex ) { Log . log ( "Cannot close log-out" , LogLevels . ERROR ) ; } } } } } ) . start ( ) ; try { p . waitFor ( ) ; getSetProperty ( "killed" , 0 ) ; } catch ( InterruptedException ex ) { Log . log ( "Timeout of " + program + ", now I kill it" , LogLevels . WARNING ) ; p . destroy ( ) ; getSetProperty ( "killed" , 1 ) ; } watchDog . interrupt ( ) ; } } protected static String getSetProperty ( String name , String defaultVal ) { String val = System . getProperty ( name , null ) ; if ( val == null && defaultVal != null ) { val = defaultVal ; System . setProperty ( name , val ) ; } return val ; } protected static long getSetProperty ( String name , long defaultVal ) { return Long . parseLong ( getSetProperty ( name , String . valueOf ( defaultVal ) ) ) ; } protected static int getSetProperty ( String name , int defaultVal ) { return Integer . parseInt ( getSetProperty ( name , String . valueOf ( defaultVal ) ) ) ; } protected static boolean getSetProperty ( String name , boolean defaultVal ) { return Boolean . parseBoolean ( getSetProperty ( name , String . valueOf ( defaultVal ) ) ) ; } protected static double getSetProperty ( String name , double defaultVal ) { return Double . parseDouble ( getSetProperty ( name , String . valueOf ( defaultVal ) ) ) ; } } 