<<<<<<< HEAD
class TwitterQueryType extends DefaultQueryType { private static final Logger LOG = Logger . getLogger ( TwitterQueryType . class . getName ( ) ) ; private static final Pattern PTN_LIST = Pattern . compile ( "^@([^\\s/]+)/([^\\s/]+)$" ) ; private static final String PATTERN_QUERY = "http://search.twitter.com/search.atom?q={0}&rpp={1}" ; private static final String PATTERN_FRIENDS = "http://{0}:{1}@twitter.com/statuses/friends_timeline/{0}.rss" ; protected TwitterQueryType ( ) { super ( TYPE_TWITTER , FeedType . TWITTER , Strings . message ( "queryfeed.type.twitter.name" ) , ResourceID . ICON_QUERY_FEED_TWITTER , "" , Strings . message ( "queryfeed.type.twitter.parameter" ) , "" , Strings . message ( "queryfeed.type.twitter.description" ) , IFeedDisplayConstants . MODE_FULL ) ; } @ Override public IArticle beforeInsertArticle ( int index , IArticle article ) { String html = article . getHtmlText ( ) ; html = html . replaceAll ( "<.*?>" , "" ) ; html = html . replaceAll ( "&apos;" , "'" ) ; StandardArticle newArticle = new StandardArticle ( html ) ; newArticle . setAuthor ( article . getAuthor ( ) ) ; newArticle . setFeed ( article . getFeed ( ) ) ; newArticle . setID ( article . getID ( ) ) ; newArticle . setLink ( article . getLink ( ) ) ; newArticle . setPublicationDate ( article . getPublicationDate ( ) ) ; newArticle . setTitle ( article . getTitle ( ) ) ; return newArticle ; } @ Override public Channel fetchFeed ( QueryFeed queryFeed ) throws IOException { Channel res ; String parameter = queryFeed . getParameter ( ) ; if ( parameter . equals ( "~~" ) ) { res = fetchFriendsTimeline ( ) ; } else { res = fetchUserList ( parameter ) ; } return res ; } private static Channel fetchFriendsTimeline ( ) throws IOException { Channel res = null ; String feedXml = null ; try { feedXml = TwitterGateway . friendsTimeline ( ) ; } catch ( OAuthException e ) { LOG . warning ( MessageFormat . format ( Strings . error ( "feed.fetching.errored" ) , e . toString ( ) ) ) ; LOG . log ( Level . FINE , "Details:" , e ) ; } if ( feedXml != null ) { IFeedParser parser = FeedParserConfig . create ( ) ; FeedParserResult result = null ; try { result = parser . parse ( new ByteArrayInputStream ( feedXml . getBytes ( ) ) , null ) ; } catch ( FeedParserException e ) { LOG . warning ( MessageFormat . format ( Strings . error ( "feed.fetching.errored" ) , e . toString ( ) ) ) ; LOG . log ( Level . FINE , "Details:" , e ) ; } if ( result != null ) res = result . getChannel ( ) ; } return res == null ? new Channel ( ) : res ; } private static Channel fetchUserList ( String parameter ) throws IOException { Channel res = null ; Matcher matcher = PTN_LIST . matcher ( parameter ) ; if ( matcher . matches ( ) ) { String json = BBHttpClient . get ( "https://api.twitter.com/1/lists/statuses.json?slug=" + matcher . group ( 2 ) + "&owner_screen_name=" + matcher . group ( 1 ) ) ; try { res = new Channel ( ) ; res . setAuthor ( "Twitter" ) ; res . setDescription ( "" + matcher . group ( 1 ) + "'s list: " + matcher . group ( 2 ) ) ; res . setFormat ( "XML" ) ; res . setLanguage ( "en_US" ) ; res . setUpdatePeriod ( Constants . MILLIS_IN_DAY ) ; JSONArray a = new JSONArray ( json ) ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { JSONObject o = a . getJSONObject ( i ) ; JSONObject u = o . getJSONObject ( "user" ) ; Item item = new Item ( o . getString ( "text" ) ) ; item . setTitle ( o . getString ( "text" ) ) ; item . setAuthor ( u . getString ( "screen_name" ) ) ; item . setLink ( new URL ( "http://twitter.com/" + u . getString ( "screen_name" ) + "/status/" + o . getString ( "id" ) ) ) ; res . addItem ( item ) ; } } catch ( JSONException e ) { throw new RuntimeException ( e ) ; } } return res ; } @ Override protected String formURLString ( String param , int limit ) { String url ; if ( "~~" . equals ( param ) ) { if ( ! TwitterFeature . isConfigured ( ) ) return null ; TwitterPreferences tp = GlobalController . SINGLETON . getModel ( ) . getUserPreferences ( ) . getTwitterPreferences ( ) ; String username = tp . getScreenName ( ) ; String password = "todo" ; url = MessageFormat . format ( PATTERN_FRIENDS , username , password ) ; } else { param = parameterToURLPart ( param ) ; if ( StringUtils . isEmpty ( param ) ) return null ; url = MessageFormat . format ( PATTERN_QUERY , param , limit ) ; } return url ; } @ Override public QueryEditorPanel getEditorPanel ( int labelColWidth ) { return new QueryEditor ( labelColWidth ) ; } private static class QueryEditor extends QueryEditorPanel { private static final int FRIENDS = 0 ; private static final int QUERY = 1 ; private static final int LIST = 2 ; private static final String TYPE_FRIENDS = "Friends Timeline" ; private static final String TYPE_QUERY = "Query" ; private static final String TYPE_LIST = "List" ; private final JComboBox cbType ; private final JPanel pnlQuery ; private final JTextField tfQuery ; private final JPanel pnlList ; private final JTextField tfListUsername ; private final JTextField tfListName ; private final JPanel pnlHolder ; private final JPanel pnlAuthWarning ; private JPanel currentPanel ; private QueryEditor ( int labelColWidth ) { cbType = new JComboBox ( ) ; tfQuery = new JTextField ( ) ; tfListUsername = new JTextField ( ) ; tfListName = new JTextField ( ) ; JLabel lblAuthWarning = new JLabel ( "Enable Twitter support in Preferences to make this feed type work." ) ; UifUtilities . smallerFont ( lblAuthWarning ) ; pnlHolder = new JPanel ( new BorderLayout ( ) ) ; cbType . addItem ( TYPE_FRIENDS ) ; cbType . addItem ( TYPE_QUERY ) ; cbType . addItem ( TYPE_LIST ) ; BBFormBuilder b = new BBFormBuilder ( labelColWidth + "dlu, 4dlu, p:grow" ) ; b . append ( "Query:" , tfQuery ) ; pnlQuery = b . getPanel ( ) ; b = new BBFormBuilder ( labelColWidth + "dlu, 4dlu, 50dlu, 4dlu, p, 4dlu, p:grow" ) ; b . append ( "User:" , tfListUsername ) ; b . append ( "List:" , tfListName ) ; pnlList = b . getPanel ( ) ; b = new BBFormBuilder ( ( labelColWidth + "dlu, 4dlu, p, p:grow" ) ) ; b . append ( "" , lblAuthWarning ) ; pnlAuthWarning = b . getPanel ( ) ; b = new BBFormBuilder ( labelColWidth + "dlu, 4dlu, p, p:grow" , this ) ; b . append ( "Type:" , cbType ) ; b . append ( pnlHolder , 4 ) ; cbType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { updateFieldState ( ) ; } } ) ; updateFieldState ( ) ; } private void updateFieldState ( ) { JPanel newPanel ; switch ( cbType . getSelectedIndex ( ) ) { case QUERY : newPanel = pnlQuery ; break ; case LIST : newPanel = pnlList ; break ; default : newPanel = TwitterFeature . isConfigured ( ) ? null : pnlAuthWarning ; } if ( currentPanel != null && currentPanel != newPanel ) { pnlHolder . remove ( currentPanel ) ; } if ( newPanel != null && newPanel != currentPanel ) { pnlHolder . add ( newPanel , BorderLayout . CENTER ) ; } currentPanel = newPanel ; pnlHolder . revalidate ( ) ; } public void setParameter ( String text ) { int type ; String query = null ; String listUsername = null ; String listName = null ; Matcher matcher = PTN_LIST . matcher ( text ) ; if ( "~~" . equals ( text ) ) { type = FRIENDS ; } else if ( matcher . matches ( ) ) { type = LIST ; listUsername = matcher . group ( 1 ) ; listName = matcher . group ( 2 ) ; } else { type = QUERY ; query = text ; } cbType . setSelectedIndex ( type ) ; tfQuery . setText ( query ) ; tfListUsername . setText ( listUsername ) ; tfListName . setText ( listName ) ; } public String getParameter ( ) { String res ; switch ( cbType . getSelectedIndex ( ) ) { case FRIENDS : res = "~~" ; break ; case LIST : res = "@" + tfListUsername . getText ( ) . replaceFirst ( "^@+" , "" ) + "/" + tfListName . getText ( ) . replaceFirst ( "^/+" , "" ) ; break ; default : res = tfQuery . getText ( ) ; break ; } return res ; } } } 
=======
public abstract class NormalizedNameClass implements com . thaiopensource . relaxng . match . NameClass { private final Set < Name > includedNames ; public NormalizedNameClass ( Set < Name > includedNames ) { this . includedNames = immutable ( includedNames ) ; } public boolean isEmpty ( ) { return includedNames . isEmpty ( ) ; } public boolean contains ( Name name ) { return includedNames . contains ( name ) ; } public boolean isAnyNameIncluded ( ) { return false ; } public Set < String > getExcludedNamespaces ( ) { return null ; } public Set < Name > getIncludedNames ( ) { return includedNames ; } public Set < Name > getExcludedNames ( ) { return null ; } public Set < String > getIncludedNamespaces ( ) { return Collections . emptySet ( ) ; } public Set < String > getExcludedLocalNames ( String ns ) { return null ; } public abstract boolean equals ( Object obj ) ; boolean equal ( NormalizedNameClass nc1 , NormalizedNameClass nc2 ) { return nc1 . includedNames . equals ( nc2 . includedNames ) ; } public int hashCode ( ) { return includedNames . hashCode ( ) ; } < T > Set < T > immutable ( Set < T > set ) { if ( set . isEmpty ( ) ) return Collections . emptySet ( ) ; return Collections . unmodifiableSet ( set ) ; } abstract boolean includesNamespace ( String ns ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
