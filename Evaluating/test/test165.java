public class FeedDisplayModel { private static final Logger LOG = Logger . getLogger ( FeedDisplayModel . class . getName ( ) ) ; private static final ArticleDateComparator COMPARATOR_DESC = new ArticleDateComparator ( true , false ) ; private static final ArticleDateComparator COMPARATOR_ASC = new ArticleDateComparator ( false , false ) ; private static final IArticle [ ] EMPTY_GROUP = new IArticle [ 0 ] ; private boolean hideArticlesWhenRead ; private final ValueModel pageCountModel ; private final IArticleListener listener ; private IFeed feed ; private boolean ascending ; private List < IFeedDisplayModelListener > listeners ; private FeedListener feedListener ; private IArticle [ ] sortedArticles ; private IArticle [ ] [ ] articlesGroups ; private int filter ; private List < IArticle > visibleArticles ; private long maxArticleAge ; private IArticle alwaysVisibleArticle ; private volatile long feedChangeTime ; private int page ; private int pageSize ; private List < IArticle > pageArticles ; public FeedDisplayModel ( ) { this ( new ValueHolder ( 0 ) ) ; } public FeedDisplayModel ( ValueModel pageCountModel ) { this . pageCountModel = pageCountModel ; listener = new ArticleListener ( ) ; ascending = false ; listeners = new CopyOnWriteArrayList < IFeedDisplayModelListener > ( ) ; feedListener = new FeedListener ( ) ; visibleArticles = new IdentityList < IArticle > ( ) ; feed = null ; filter = IFeedDisplayConstants . FILTER_ALL ; maxArticleAge = - 1 ; page = 0 ; pageSize = 10 ; pageArticles = new IdentityList < IArticle > ( ) ; recalcModel ( ) ; } public void prepareToDismiss ( ) { alwaysVisibleArticle = null ; for ( IArticle article : sortedArticles ) article . removeListener ( listener ) ; if ( feed != null ) feed . removeListener ( feedListener ) ; fireArticlesRemoved ( ) ; } public void setFeed ( IFeed aFeed ) { if ( feed != aFeed ) { alwaysVisibleArticle = null ; if ( feed != null ) feed . removeListener ( feedListener ) ; feed = aFeed ; feedChangeTime = System . currentTimeMillis ( ) ; if ( feed != null ) feed . addListener ( feedListener ) ; page = 0 ; recalcModel ( ) ; } } public IFeed getFeed ( ) { return feed ; } private void recalcModel ( ) { if ( sortedArticles != null ) { for ( IArticle article : sortedArticles ) article . removeListener ( listener ) ; } sortedArticles = EMPTY_GROUP ; visibleArticles . clear ( ) ; if ( feed != null ) { IArticle [ ] articles = feed . getArticles ( ) ; for ( IArticle article : articles ) addArticle ( article ) ; updatePageCount ( ) ; loadPage ( ) ; } else { clearPage ( ) ; pageCountModel . setValue ( 0 ) ; } } private void updatePageCount ( ) { int numberOfPages = ( int ) Math . ceil ( visibleArticles == null ? 0 : visibleArticles . size ( ) / ( float ) pageSize ) ; pageCountModel . setValue ( numberOfPages ) ; } private void clearPage ( ) { articlesGroups = new IArticle [ GroupsSetup . getGroupsCount ( ) ] [ ] ; pageArticles . clear ( ) ; fireArticlesRemoved ( ) ; } private void loadPage ( ) { clearPage ( ) ; int pageOffset = page * pageSize ; for ( int i = pageOffset ; i < pageOffset + pageSize && i < visibleArticles . size ( ) ; i ++ ) { IArticle article = visibleArticles . get ( i ) ; addArticleToPage ( article ) ; } } private void updatePage ( ) { int pageOffset = page * pageSize ; IdentityList < IArticle > displayed = new IdentityList < IArticle > ( ) ; for ( int i = pageOffset ; i < pageOffset + pageSize && i < visibleArticles . size ( ) ; i ++ ) { IArticle article = visibleArticles . get ( i ) ; displayed . add ( article ) ; if ( ! pageArticles . contains ( article ) ) { addArticleToPage ( article ) ; } } List < IArticle > toRemove = null ; for ( IArticle article : pageArticles ) { if ( ! displayed . contains ( article ) ) { if ( toRemove == null ) toRemove = new LinkedList < IArticle > ( ) ; toRemove . add ( article ) ; } } if ( toRemove != null ) { for ( IArticle article : toRemove ) { pageArticles . remove ( article ) ; int groupIndex = findGroupIndex ( article ) ; if ( groupIndex == - 1 ) groupIndex = 0 ; IArticle [ ] group = getRawGroup ( groupIndex ) ; int indexWithinGroup = indexOf ( article , group ) ; if ( indexWithinGroup > - 1 ) { articlesGroups [ groupIndex ] = removeArticle ( group , article ) ; fireArticleRemoved ( article , applySorting ( groupIndex ) , indexWithinGroup ) ; } } } } private void addArticleToPage ( IArticle article ) { int groupIndex = findGroupIndex ( article ) ; if ( groupIndex == - 1 ) groupIndex = 0 ; IArticle [ ] group = getRawGroup ( groupIndex ) ; int indexWithinGroup = Arrays . binarySearch ( group , article , getArticlesComparator ( ) ) ; if ( indexWithinGroup < 0 ) { indexWithinGroup = - indexWithinGroup - 1 ; articlesGroups [ groupIndex ] = insertArticle ( group , article , indexWithinGroup ) ; pageArticles . add ( article ) ; fireArticleAdded ( article , applySorting ( groupIndex ) , indexWithinGroup ) ; } } void onArticleAdded ( IArticle aArticle ) { if ( addArticle ( aArticle ) ) { updatePageCount ( ) ; updatePage ( ) ; } } private boolean addArticle ( IArticle aArticle ) { if ( contains ( aArticle ) ) return false ; boolean reviewed = false ; int index = Arrays . binarySearch ( sortedArticles , aArticle , getArticlesComparator ( ) ) ; if ( index < 0 ) { index = - index - 1 ; sortedArticles = insertArticle ( sortedArticles , aArticle , index ) ; reviewed = reviewArticle ( aArticle ) ; aArticle . addListener ( listener ) ; } return reviewed ; } void onArticleRemoved ( IArticle aArticle ) { if ( ! contains ( aArticle ) ) return ; sortedArticles = removeArticle ( sortedArticles , aArticle ) ; if ( isVisible ( aArticle ) ) hideArticle ( aArticle ) ; aArticle . removeListener ( listener ) ; updatePageCount ( ) ; updatePage ( ) ; } public int getArticlesCount ( ) { return pageArticles . size ( ) ; } public IArticle getArticle ( int index ) { return pageArticles . get ( index ) ; } public void setAscending ( boolean asc ) { if ( ascending != asc ) { ascending = asc ; rebuild ( ) ; } } private void rebuild ( ) { IFeed oldFeed = feed ; feed = null ; setFeed ( oldFeed ) ; } public int getGroupsCount ( ) { return GroupsSetup . getGroupsCount ( ) ; } public IArticle [ ] getGroup ( int index ) { return getRawGroup ( applySorting ( index ) ) ; } private IArticle [ ] getRawGroup ( int index ) { IArticle [ ] group = articlesGroups [ index ] ; if ( group == null ) group = EMPTY_GROUP ; return group ; } public String getGroupName ( int group ) { return GroupsSetup . getGroupTitle ( applySorting ( group ) ) ; } private int applySorting ( int group ) { return ascending ? getGroupsCount ( ) - group - 1 : group ; } static IArticle [ ] insertArticle ( IArticle [ ] aArticles , IArticle aArticle , int aIndex ) { IArticle [ ] newArticlesList = new IArticle [ aArticles . length + 1 ] ; copyObjects ( aArticles , 0 , newArticlesList , 0 , aIndex ) ; copyObjects ( aArticles , aIndex , newArticlesList , aIndex + 1 , aArticles . length - aIndex ) ; newArticlesList [ aIndex ] = aArticle ; return newArticlesList ; } static IArticle [ ] removeArticle ( IArticle [ ] aArticles , IArticle aArticle ) { IArticle [ ] newArticlesList = aArticles ; int index = indexOf ( aArticle , aArticles ) ; if ( index > - 1 ) { newArticlesList = new IArticle [ aArticles . length - 1 ] ; copyObjects ( aArticles , 0 , newArticlesList , 0 , index ) ; copyObjects ( aArticles , index + 1 , newArticlesList , index , aArticles . length - index - 1 ) ; } return newArticlesList ; } static void copyObjects ( Object [ ] src , int srcIndex , Object [ ] dest , int destIndex , int len ) { for ( int a = 0 ; srcIndex < src . length && destIndex < dest . length && a < len ; a ++ ) { dest [ destIndex ++ ] = src [ srcIndex ++ ] ; } } private ArticleDateComparator getArticlesComparator ( ) { return ascending ? COMPARATOR_ASC : COMPARATOR_DESC ; } static IArticle [ ] [ ] groupArticles ( IArticle [ ] articles , TimeRange [ ] ranges ) { IArticle [ ] [ ] groups = new IArticle [ ranges . length ] [ ] ; for ( IArticle article : articles ) { int groupIndex = findGroupIndex ( article , ranges ) ; if ( groupIndex > - 1 ) { IArticle [ ] group = groups [ groupIndex ] ; if ( group == null ) group = EMPTY_GROUP ; groups [ groupIndex ] = insertArticle ( group , article , group . length ) ; } } return groups ; } static int findGroupIndex ( IArticle aArticle ) { return findGroupIndex ( aArticle , GroupsSetup . getGroupTimeRanges ( ) ) ; } static int findGroupIndex ( IArticle aArticle , TimeRange [ ] aRanges ) { long time = aArticle . getPublicationDate ( ) . getTime ( ) ; int index = - 1 ; for ( int i = 0 ; index == - 1 && i < aRanges . length ; i ++ ) { TimeRange range = aRanges [ i ] ; if ( range . isInRange ( time ) ) index = i ; } return index ; } private boolean contains ( IArticle aArticle ) { return indexOf ( aArticle ) > - 1 ; } private int indexOf ( IArticle aArticle ) { return indexOf ( aArticle , sortedArticles ) ; } private static int indexOf ( IArticle aArticle , IArticle [ ] aArticles ) { int index = - 1 ; for ( int i = 0 ; index == - 1 && i < aArticles . length ; i ++ ) { if ( aArticles [ i ] == aArticle ) index = i ; } return index ; } public void addListener ( IFeedDisplayModelListener aListener ) { if ( ! listeners . contains ( aListener ) ) listeners . add ( aListener ) ; } private void fireArticlesRemoved ( ) { for ( IFeedDisplayModelListener l : listeners ) l . articlesRemoved ( ) ; } private void fireArticleAdded ( IArticle aArticle , int aGroupIndex , int aIndexWithinGroup ) { for ( IFeedDisplayModelListener l : listeners ) { l . articleAdded ( aArticle , aGroupIndex , aIndexWithinGroup ) ; } } private void fireArticleRemoved ( IArticle aArticle , int aGroupIndex , int aIndexWithinGroup ) { for ( IFeedDisplayModelListener l : listeners ) { l . articleRemoved ( aArticle , aGroupIndex , aIndexWithinGroup ) ; } } public void setFilter ( int aFilter ) { if ( filter != aFilter ) { alwaysVisibleArticle = null ; filter = aFilter ; reviewArticles ( ) ; } } public int ensureArticleVisibility ( IArticle article ) { int newPage = - 1 ; alwaysVisibleArticle = article ; if ( article != null ) { reviewArticle ( article ) ; updatePageCount ( ) ; int articlePage = findPageFor ( article ) ; if ( articlePage != page && articlePage != - 1 ) { setPage ( articlePage ) ; newPage = articlePage ; } else updatePage ( ) ; } return newPage ; } private int findPageFor ( IArticle article ) { int page = - 1 ; int i = visibleArticles . indexOf ( article ) ; if ( i >= 0 && pageSize > 0 ) page = i / pageSize ; return page ; } private void onArticleChanged ( IArticle article ) { if ( ( filter == FILTER_UNREAD && ( hideArticlesWhenRead || ! article . isRead ( ) ) ) || filter == FILTER_NEGATIVE || filter == FILTER_NON_NEGATIVE || filter == FILTER_POSITIVE ) { if ( reviewArticle ( article ) ) { updatePageCount ( ) ; updatePage ( ) ; } } } private void reviewArticles ( ) { boolean updated = false ; for ( IArticle article : sortedArticles ) updated |= reviewArticle ( article ) ; if ( updated ) { updatePageCount ( ) ; updatePage ( ) ; } } private boolean reviewArticle ( IArticle aArticle ) { boolean updated ; if ( shouldBeVisible ( aArticle ) ) { updated = ! isVisible ( aArticle ) && showArticle ( aArticle ) ; } else { updated = isVisible ( aArticle ) && hideArticle ( aArticle ) ; } return updated ; } private boolean hideArticle ( IArticle aArticle ) { boolean hidden = false ; int groupIndex = findGroupIndex ( aArticle ) ; if ( groupIndex == - 1 ) groupIndex = 0 ; visibleArticles . remove ( aArticle ) ; IArticle [ ] group = getRawGroup ( groupIndex ) ; int indexWithinGroup = indexOf ( aArticle , group ) ; if ( indexWithinGroup > - 1 ) { articlesGroups [ groupIndex ] = removeArticle ( group , aArticle ) ; if ( pageArticles . remove ( aArticle ) ) { hidden = true ; fireArticleRemoved ( aArticle , applySorting ( groupIndex ) , indexWithinGroup ) ; } } return hidden ; } private boolean showArticle ( IArticle aArticle ) { boolean shown = false ; int index = Collections . binarySearch ( visibleArticles , aArticle , getArticlesComparator ( ) ) ; if ( index < 0 ) { index = - index - 1 ; visibleArticles . add ( index , aArticle ) ; shown = true ; } return shown ; } public boolean hasVisibleArticles ( ) { return visibleArticles . size ( ) > 0 ; } private boolean isVisible ( IArticle aArticle ) { return visibleArticles . contains ( aArticle ) ; } private boolean shouldBeVisible ( IArticle aArticle ) { if ( alwaysVisibleArticle == aArticle ) return true ; boolean filtered = filter == FILTER_ALL || ( filter == FILTER_PINNED && aArticle . isPinned ( ) ) || ( filter == FILTER_UNREAD && ! aArticle . isRead ( ) ) || ( filter == FILTER_POSITIVE && aArticle . isPositive ( ) ) || ( filter == FILTER_NEGATIVE && aArticle . isNegative ( ) ) || ( filter == FILTER_NON_NEGATIVE && ! aArticle . isNegative ( ) ) ; return filtered && ( maxArticleAge == - 1 || isNotOld ( aArticle ) ) ; } private boolean isNotOld ( IArticle aArticle ) { long age = System . currentTimeMillis ( ) - aArticle . getPublicationDate ( ) . getTime ( ) ; return age < maxArticleAge ; } public void setMaxArticleAge ( long millis ) { if ( maxArticleAge != millis ) { maxArticleAge = millis ; reviewArticles ( ) ; } } public void setPage ( int page ) { if ( this . page != page ) { this . page = page ; loadPage ( ) ; } } public int getPage ( ) { return page ; } public int getPagesCount ( ) { return ( Integer ) pageCountModel . getValue ( ) ; } public void dump ( ) { LOG . warning ( "--- Model Dump ---" ) ; LOG . warning ( "Number of articles: " + getArticlesCount ( ) ) ; LOG . warning ( "Articles:" ) ; for ( IArticle article : sortedArticles ) LOG . warning ( "  " + article . getTitle ( ) ) ; } public void setPageSize ( int size ) { if ( pageSize != size ) { pageSize = size ; recalcModel ( ) ; } } private class FeedListener extends FeedAdapter { public void articleAdded ( IFeed feed , final IArticle article ) { if ( UifUtilities . isEDT ( ) ) { onArticleAdded ( article ) ; } else SwingUtilities . invokeLater ( new UpdateModel ( article , UpdateAction . ADDED ) ) ; } public void articleRemoved ( IFeed feed , final IArticle article ) { if ( UifUtilities . isEDT ( ) ) { onArticleRemoved ( article ) ; } else SwingUtilities . invokeLater ( new UpdateModel ( article , UpdateAction . REMOVED ) ) ; } } private class ArticleListener implements IArticleListener { private List < String > interestingProperties ; private ArticleListener ( ) { interestingProperties = new LinkedList < String > ( ) ; interestingProperties . add ( IArticle . PROP_READ ) ; interestingProperties . add ( IArticle . PROP_POSITIVE ) ; interestingProperties . add ( IArticle . PROP_NEGATIVE ) ; } public void propertyChanged ( final IArticle article , String property , Object oldValue , Object newValue ) { if ( interestingProperties . contains ( property ) ) { if ( UifUtilities . isEDT ( ) ) { onArticleChanged ( article ) ; } else SwingUtilities . invokeLater ( new UpdateModel ( article , UpdateAction . CHANGED ) ) ; } } } enum UpdateAction { ADDED , REMOVED , CHANGED } private class UpdateModel implements Runnable { private final IArticle article ; private final UpdateAction action ; private final long timestamp ; public UpdateModel ( IArticle article , UpdateAction action ) { this . article = article ; this . action = action ; timestamp = System . currentTimeMillis ( ) ; } public void run ( ) { if ( timestamp >= feedChangeTime ) { switch ( action ) { case ADDED : onArticleAdded ( article ) ; break ; case REMOVED : onArticleRemoved ( article ) ; break ; default : onArticleChanged ( article ) ; } } } } } 