public abstract class SchemaReaderImpl extends AbstractSchemaReader { private static final PropertyId < ? > [ ] supportedPropertyIds = { ValidateProperty . XML_READER_CREATOR , ValidateProperty . ERROR_HANDLER , ValidateProperty . ENTITY_RESOLVER , ValidateProperty . URI_RESOLVER , ValidateProperty . RESOLVER , RngProperty . DATATYPE_LIBRARY_FACTORY , RngProperty . CHECK_ID_IDREF , RngProperty . FEASIBLE , WrapProperty . ATTRIBUTE_OWNER , } ; public Schema createSchema ( SAXSource source , PropertyMap properties ) throws IOException , SAXException , IncorrectSchemaException { SchemaPatternBuilder spb = new SchemaPatternBuilder ( ) ; SAXResolver resolver = ResolverFactory . createResolver ( properties ) ; ErrorHandler eh = properties . get ( ValidateProperty . ERROR_HANDLER ) ; DatatypeLibraryFactory dlf = properties . get ( RngProperty . DATATYPE_LIBRARY_FACTORY ) ; if ( dlf == null ) dlf = new DatatypeLibraryLoader ( ) ; try { Pattern start = SchemaBuilderImpl . parse ( createParseable ( source , resolver , eh , properties ) , eh , dlf , spb , properties . contains ( WrapProperty . ATTRIBUTE_OWNER ) ) ; return wrapPattern ( start , spb , properties ) ; } catch ( IllegalSchemaException e ) { throw new IncorrectSchemaException ( ) ; } } public Option getOption ( String uri ) { return RngProperty . getOption ( uri ) ; } static private class SimplifiedSchemaPropertyMap implements PropertyMap { private final PropertyMap base ; private final Pattern start ; SimplifiedSchemaPropertyMap ( PropertyMap base , Pattern start ) { this . base = base ; this . start = start ; } public < T > T get ( PropertyId < T > pid ) { if ( pid == RngProperty . SIMPLIFIED_SCHEMA ) { String simplifiedSchema = PatternDumper . toString ( start ) ; return pid . getValueClass ( ) . cast ( simplifiedSchema ) ; } else return base . get ( pid ) ; } public PropertyId < ? > getKey ( int i ) { return i == base . size ( ) ? RngProperty . SIMPLIFIED_SCHEMA : base . getKey ( i ) ; } public int size ( ) { return base . size ( ) + 1 ; } public boolean contains ( PropertyId < ? > pid ) { return base . contains ( pid ) || pid == RngProperty . SIMPLIFIED_SCHEMA ; } } static Schema wrapPattern ( Pattern start , SchemaPatternBuilder spb , PropertyMap properties ) throws SAXException , IncorrectSchemaException { if ( properties . contains ( RngProperty . FEASIBLE ) ) start = FeasibleTransform . transform ( spb , start ) ; properties = new SimplifiedSchemaPropertyMap ( AbstractSchema . filterProperties ( properties , supportedPropertyIds ) , start ) ; Schema schema = new PatternSchema ( spb , start , properties ) ; if ( spb . hasIdTypes ( ) && properties . contains ( RngProperty . CHECK_ID_IDREF ) ) { ErrorHandler eh = properties . get ( ValidateProperty . ERROR_HANDLER ) ; IdTypeMap idTypeMap = new IdTypeMapBuilder ( eh , start ) . getIdTypeMap ( ) ; if ( idTypeMap == null ) throw new IncorrectSchemaException ( ) ; Schema idSchema ; if ( properties . contains ( RngProperty . FEASIBLE ) ) idSchema = new FeasibleIdTypeMapSchema ( idTypeMap , properties ) ; else idSchema = new IdTypeMapSchema ( idTypeMap , properties ) ; schema = new CombineSchema ( schema , idSchema , properties ) ; } return schema ; } protected abstract Parseable < Pattern , NameClass , Locator , VoidValue , CommentListImpl , AnnotationsImpl > createParseable ( SAXSource source , SAXResolver resolver , ErrorHandler eh , PropertyMap properties ) throws SAXException ; } 