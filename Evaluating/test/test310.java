<<<<<<< HEAD
public class Bigram { public Set < String > samples ; public HashMap < String , HashMap < String , Double > > counts ; public HashMap < String , Double > unigramCounts ; public final String START = ":S" ; public Set < String > wordSet ; public double vocabSize ; public double numTrainingBigrams ; public HashMap < Double , Double > numberOfBigramsWithCount ; public boolean goodTuringCountsAvailable = false ; public static void main ( String [ ] args ) { if ( args . length != 2 ) { System . out . println ( "You must supply 2 arguments:\n(1) Training file\n" + "(2) Test file" ) ; System . exit ( 1 ) ; } NgramParser p = new NgramParser ( args [ 0 ] , true ) ; HashSet < String > set = p . parse ( ) ; Bigram b = new Bigram ( set ) ; b . train ( ) ; System . out . println ( "Done training." ) ; NgramParser test = new NgramParser ( args [ 1 ] , true ) ; HashSet < String > testset = test . parse ( ) ; System . out . println ( "Perplexity of the test set: " + b . perplexity ( testset ) ) ; } public Bigram ( Set < String > samples ) { this . samples = samples ; this . counts = new HashMap < String , HashMap < String , Double > > ( ) ; this . unigramCounts = new HashMap < String , Double > ( ) ; this . wordSet = new HashSet < String > ( ) ; this . numberOfBigramsWithCount = new HashMap < Double , Double > ( ) ; } public void train ( ) { String regexp = "('?\\w+|\\p{Punct})" ; Pattern pattern = Pattern . compile ( regexp ) ; for ( String sample : samples ) { Matcher matcher = pattern . matcher ( sample ) ; String previousWord = START ; while ( matcher . find ( ) ) { double unigramCount = 0.0 ; if ( unigramCounts . containsKey ( previousWord ) ) { unigramCount = unigramCounts . get ( previousWord ) ; } unigramCounts . put ( previousWord , unigramCount + 1.0 ) ; String match = matcher . group ( ) ; wordSet . add ( match ) ; HashMap < String , Double > innerCounts ; if ( counts . containsKey ( previousWord ) ) { innerCounts = counts . get ( previousWord ) ; } else { innerCounts = new HashMap < String , Double > ( ) ; counts . put ( previousWord , innerCounts ) ; } numTrainingBigrams += 1 ; double count = 0.0 ; if ( innerCounts . containsKey ( match ) ) { count = innerCounts . get ( match ) ; numberOfBigramsWithCount . put ( count , numberOfBigramsWithCount . get ( count ) - 1.0 ) ; } innerCounts . put ( match , count + 1.0 ) ; if ( ! numberOfBigramsWithCount . containsKey ( count + 1.0 ) ) { numberOfBigramsWithCount . put ( count + 1.0 , 1.0 ) ; } else { numberOfBigramsWithCount . put ( count + 1.0 , numberOfBigramsWithCount . get ( count + 1.0 ) + 1.0 ) ; } previousWord = match ; } } vocabSize = wordSet . size ( ) ; } public double count ( String word1 , String word2 ) { if ( counts . containsKey ( word1 ) && counts . get ( word1 ) . containsKey ( word2 ) ) { return counts . get ( word1 ) . get ( word2 ) ; } return 0.0 ; } public double unigramCount ( String word ) { if ( unigramCounts . containsKey ( word ) ) { return unigramCounts . get ( word ) ; } return 0.0 ; } public double unsmoothedProbability ( String word1 , String word2 ) { if ( counts . containsKey ( word1 ) ) { if ( counts . get ( word1 ) . containsKey ( word2 ) ) { return counts . get ( word1 ) . get ( word2 ) / unigramCounts . get ( word1 ) ; } else { return 0.0 ; } } else { return 0.0 ; } } public double addOneSmoothedProbability ( String word1 , String word2 ) { return ( count ( word1 , word2 ) + 1.0 ) / ( unigramCount ( word1 ) + vocabSize ) ; } public double goodTuringSmoothedProbability ( String word1 , String word2 ) { if ( ! goodTuringCountsAvailable ) { System . out . println ( "Making good turing counts..." ) ; makeGoodTuringCounts ( ) ; System . out . println ( "Done making good turing counts." ) ; } double gtcount = count ( word1 , word2 ) ; if ( gtcount > 0.0 ) { return gtcount / unigramCount ( word1 ) ; } return numberOfBigramsWithCount . get ( 1.0 ) / numTrainingBigrams ; } public void makeGoodTuringCounts ( ) { for ( String word1 : counts . keySet ( ) ) { HashMap < String , Double > innerMap = counts . get ( word1 ) ; double unigramCount = 0 ; for ( String word2 : innerMap . keySet ( ) ) { double count = innerMap . get ( word2 ) ; if ( ! numberOfBigramsWithCount . containsKey ( count + 1 ) ) { numberOfBigramsWithCount . put ( count + 1 , 0.0 ) ; } double newCount = ( count + 1 ) * ( numberOfBigramsWithCount . get ( count + 1.0 ) ) / ( numberOfBigramsWithCount . get ( count ) ) ; innerMap . put ( word2 , newCount ) ; unigramCount += newCount ; } unigramCounts . put ( word1 , unigramCount ) ; } goodTuringCountsAvailable = true ; } public void showCounts ( ) { for ( String word1 : counts . keySet ( ) ) { for ( String word2 : counts . get ( word1 ) . keySet ( ) ) { System . out . println ( word1 + " " + word2 + ": " + counts . get ( word1 ) . get ( word2 ) ) ; } } } public String getSentence ( ) { String sentence = "" ; String currentWord = START ; String nextWord = START ; while ( ! currentWord . equals ( "." ) && sentence . length ( ) <= 400 ) { Set < String > keySet = counts . get ( currentWord ) . keySet ( ) ; double rand = Math . random ( ) * unigramCounts . get ( currentWord ) ; Iterator < String > i = keySet . iterator ( ) ; while ( i . hasNext ( ) && rand >= 0 ) { nextWord = i . next ( ) ; rand -= ( double ) counts . get ( currentWord ) . get ( nextWord ) ; } currentWord = nextWord ; sentence += nextWord + " " ; } return sentence ; } public double perplexity ( Set < String > testSamples ) { float product = 1 ; int wordCount = 0 ; Stack < Double > products = new Stack < Double > ( ) ; String regexp = "('?\\w+|\\p{Punct})" ; Pattern pattern = Pattern . compile ( regexp ) ; for ( String sample : testSamples ) { Matcher matcher = pattern . matcher ( sample ) ; String previousWord = START ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; products . push ( goodTuringSmoothedProbability ( previousWord , match ) ) ; wordCount ++ ; previousWord = match ; } } double power = 1.0 / wordCount ; while ( ! products . empty ( ) ) { product *= Math . pow ( products . pop ( ) , power ) ; } return 1 / product ; } } 
=======
abstract class ResultAction extends Action { ResultAction ( ModeUsage modeUsage ) { super ( modeUsage ) ; } abstract void perform ( ContentHandler handler , SectionState state ) throws SAXException ; abstract ResultAction changeCurrentMode ( Mode mode ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
