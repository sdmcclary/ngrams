<<<<<<< HEAD
public class SwitchTable { public SwitchTable ( Method method , Instruction ins , Map < Integer , Integer > gotos ) throws IOException { this . method = method ; insIndex = ins . currentPc ; cases = new ArrayList < CaseEntry > ( ) ; if ( ins . opcode == Opcodes . OPCODE_TABLESWITCH ) { createTableSwitch ( ins . args , ins . currentPc , gotos ) ; } else if ( ins . opcode == Opcodes . OPCODE_LOOKUPSWITCH ) { createLookupSwitch ( ins . args , ins . currentPc , gotos ) ; } else { throw new IllegalArgumentException ( "Opcode " + ins . opcode + " Not a switch statement" ) ; } datatype = null ; } public SwitchTable ( Method method , Instruction ins , Expression op1 , Map < Integer , Integer > gotos ) throws IOException { this . datatype = op1 . getType ( ) ; this . varName = op1 . getJLSCode ( ) ; this . method = method ; insIndex = ins . currentPc ; cases = new ArrayList < CaseEntry > ( ) ; if ( ins . opcode == Opcodes . OPCODE_TABLESWITCH ) { createTableSwitch ( ins . args , ins . currentPc , gotos ) ; } else if ( ins . opcode == Opcodes . OPCODE_LOOKUPSWITCH ) { createLookupSwitch ( ins . args , ins . currentPc , gotos ) ; } else { throw new IllegalArgumentException ( "Opcode " + ins . opcode + " Not a switch statement" ) ; } logger . fine ( "switch datatype " + datatype ) ; } public int getDefaultByte ( ) { return defaultByte ; } private void createTableSwitch ( byte [ ] entries , int offset , Map < Integer , Integer > gotos ) throws IOException { DataInputStream dis = null ; try { dis = new DataInputStream ( new ByteArrayInputStream ( entries ) ) ; defaultByte = dis . readInt ( ) + offset ; int lowVal = dis . readInt ( ) ; int highVal = dis . readInt ( ) ; Map < Integer , CaseEntry > mapCases = new HashMap < Integer , CaseEntry > ( ) ; for ( int i = lowVal ; i <= highVal ; i ++ ) { int curTarget = dis . readInt ( ) + offset ; String value = TypeInferrer . getValue ( String . valueOf ( i ) , this . datatype ) ; CaseEntry ent = mapCases . get ( Integer . valueOf ( curTarget ) ) ; if ( ent == null ) { mapCases . put ( Integer . valueOf ( curTarget ) , new CaseEntry ( value , curTarget ) ) ; } else { ent . addValue ( value ) ; } } cases = new ArrayList < CaseEntry > ( mapCases . values ( ) ) ; } finally { IOUtils . closeQuietly ( dis ) ; } processData ( gotos ) ; } private void createLookupSwitch ( byte [ ] entries , int offset , Map < Integer , Integer > gotos ) throws IOException { DataInputStream dis = null ; try { dis = new DataInputStream ( new ByteArrayInputStream ( entries ) ) ; defaultByte = dis . readInt ( ) + offset ; int numVal = dis . readInt ( ) ; Map < Integer , CaseEntry > mapCases = new HashMap < Integer , CaseEntry > ( ) ; for ( int i = 0 ; i < numVal ; i ++ ) { String value = TypeInferrer . getValue ( String . valueOf ( dis . readInt ( ) ) , datatype ) ; int curTarget = dis . readInt ( ) + offset ; CaseEntry ent = mapCases . get ( Integer . valueOf ( curTarget ) ) ; if ( ent == null ) { mapCases . put ( Integer . valueOf ( curTarget ) , new CaseEntry ( value , curTarget ) ) ; } else { ent . addValue ( value ) ; } } cases = new ArrayList < CaseEntry > ( mapCases . values ( ) ) ; } finally { IOUtils . closeQuietly ( dis ) ; } processData ( gotos ) ; } public List < CaseEntry > getCases ( ) { return cases ; } public String disassemble ( ) { StringBuilder sb = new StringBuilder ( "" ) ; for ( int i = 0 ; i < cases . size ( ) ; i ++ ) { sb . append ( "\n\t\t\t" + cases . get ( i ) ) ; } sb . append ( "\n\t\t\tDefault Byte " + defaultByte ) ; return sb . toString ( ) ; } public void setTypeValue ( String rhsType , String rhsValue ) { varName = rhsValue ; datatype = rhsType ; } public void processData ( Map < Integer , Integer > gotos ) { maxTarget = defaultByte ; if ( gotos != null ) { for ( CaseEntry ent : cases ) { Integer obj = gotos . get ( Integer . valueOf ( ent . getTarget ( ) - 3 ) ) ; if ( obj != null ) { int tempVal = obj . intValue ( ) ; maxTarget = ( maxTarget > tempVal ) ? maxTarget : tempVal ; } } if ( maxTarget > defaultByte ) { boolean targetPresent = false ; for ( int i = 0 ; i < cases . size ( ) - 1 ; i ++ ) { CaseEntry ent = cases . get ( i ) ; if ( ent . getTarget ( ) == defaultByte ) { ent . addValue ( JLSConstants . DEFAULT ) ; targetPresent = true ; } } if ( ! targetPresent ) { cases . add ( new CaseEntry ( JLSConstants . DEFAULT , defaultByte ) ) ; } } } Collections . sort ( cases , new CaseComparator ( ) ) ; int i = 0 ; for ( ; i < cases . size ( ) - 1 ; i ++ ) { CaseEntry ent = cases . get ( i ) ; CaseEntry entNext = cases . get ( i + 1 ) ; ent . setEndTarget ( entNext . getTarget ( ) ) ; } CaseEntry entLast = cases . get ( i ) ; entLast . setEndTarget ( maxTarget ) ; } public BranchEntry getBranchEntry ( ) { return new BranchEntry ( method , insIndex , maxTarget , maxTarget , BranchConstants . TYPE_SWITCH , varName , "" , "" ) ; } public void addCaseEntry ( CaseEntry caseEntry ) { cases . add ( caseEntry ) ; } @ Override public String toString ( ) { return cases . toString ( ) ; } int insIndex ; List < CaseEntry > cases ; int defaultByte ; int maxTarget ; String varName ; String datatype ; Method method ; private final Logger logger = CustomLoggerFactory . createLogger ( ) ; } 
=======
public abstract class AnnotationsImpl extends CommentListImpl implements Annotations < Locator , VoidValue , CommentListImpl > { public void addAttribute ( String ns , String localName , String prefix , String value , Locator loc ) throws BuildException { } public void addElement ( VoidValue voidValue ) throws BuildException { } public void addComment ( CommentListImpl comments ) throws BuildException { } public void addLeadingComment ( CommentListImpl comments ) throws BuildException { } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
