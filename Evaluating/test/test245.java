<<<<<<< HEAD
public class SoapServlet extends HttpServlet { SoapSerializationEnvelope envelope = new SoapSerializationEnvelope ( SoapSerializationEnvelope . VER12 ) ; Hashtable instanceMap = new Hashtable ( ) ; protected Object getInstance ( HttpServletRequest request ) { if ( request . getPathInfo ( ) == null ) return this ; Object result = instanceMap . get ( request . getPathInfo ( ) ) ; return ( result != null ) ? result : this ; } public void publishClass ( Class service , String namespace ) { Method [ ] methods = service . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( Modifier . isPublic ( methods [ i ] . getModifiers ( ) ) ) { Class [ ] types = methods [ i ] . getParameterTypes ( ) ; PropertyInfo [ ] info = new PropertyInfo [ types . length ] ; for ( int j = 0 ; j < types . length ; j ++ ) { info [ j ] = new PropertyInfo ( ) ; info [ j ] . type = types [ j ] ; } publishMethod ( service , namespace , methods [ i ] . getName ( ) , info ) ; } } } public void publishInstance ( String path , Object instance ) { instanceMap . put ( path , instance ) ; } public void publishMethod ( Class service , String namespace , String name , PropertyInfo [ ] parameters ) { SoapObject template = new SoapObject ( namespace , name ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) template . addProperty ( parameters [ i ] , null ) ; envelope . addTemplate ( template ) ; } public void publishMethod ( Class service , String namespace , String name , String [ ] parameterNames ) { Method [ ] methods = service . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( name ) && methods [ i ] . getParameterTypes ( ) . length == parameterNames . length ) { Class [ ] types = methods [ i ] . getParameterTypes ( ) ; PropertyInfo [ ] info = new PropertyInfo [ types . length ] ; for ( int j = 0 ; j < types . length ; j ++ ) { info [ j ] = new PropertyInfo ( ) ; info [ j ] . name = parameterNames [ j ] ; info [ j ] . type = types [ j ] ; } publishMethod ( service , namespace , name , info ) ; return ; } } throw new RuntimeException ( "Method not found!" ) ; } public SoapSerializationEnvelope getEnvelope ( ) { return envelope ; } public void setEnvelope ( SoapSerializationEnvelope envelope ) { this . envelope = envelope ; } public void doPost ( HttpServletRequest req , HttpServletResponse res ) throws ServletException , IOException { try { Object service = getInstance ( req ) ; XmlPullParser parser = new KXmlParser ( ) ; if ( false ) { } else { byte [ ] inputRequest = new byte [ req . getInputStream ( ) . available ( ) ] ; req . getInputStream ( ) . read ( inputRequest ) ; System . out . println ( "Request: " + new String ( inputRequest ) ) ; ByteArrayInputStream bas = new ByteArrayInputStream ( inputRequest ) ; parser . setInput ( bas , null ) ; } parser . setFeature ( XmlPullParser . FEATURE_PROCESS_NAMESPACES , true ) ; envelope . parse ( parser ) ; SoapObject soapReq = ( SoapObject ) envelope . bodyIn ; SoapObject result = invoke ( service , soapReq ) ; System . out . println ( "result: " + result ) ; envelope . bodyOut = result ; } catch ( SoapFault f ) { f . printStackTrace ( ) ; envelope . bodyOut = f ; res . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; SoapFault fault = new SoapFault ( ) ; fault . faultcode = "Server" ; fault . faultstring = t . getMessage ( ) ; envelope . bodyOut = fault ; res . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; } finally { res . setContentType ( "text/xml; charset=utf-8" ) ; res . setHeader ( "Connection" , "close" ) ; StringWriter sw = new StringWriter ( ) ; XmlSerializer writer = new KXmlSerializer ( ) ; writer . setOutput ( sw ) ; try { envelope . write ( writer ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } writer . flush ( ) ; System . out . println ( "result xml: " + sw ) ; Writer w = res . getWriter ( ) ; w . write ( sw . toString ( ) ) ; w . close ( ) ; } res . flushBuffer ( ) ; } protected SoapObject invoke ( Object service , SoapObject soapReq ) throws NoSuchMethodException , InvocationTargetException , IllegalAccessException { String name = soapReq . getName ( ) ; Class types [ ] = new Class [ soapReq . getPropertyCount ( ) ] ; Object [ ] args = new Object [ soapReq . getPropertyCount ( ) ] ; PropertyInfo arg = new PropertyInfo ( ) ; Hashtable properties = new Hashtable ( ) ; for ( int i = 0 ; i < types . length ; i ++ ) { soapReq . getPropertyInfo ( i , properties , arg ) ; types [ i ] = ( Class ) arg . type ; args [ i ] = soapReq . getProperty ( i ) ; } Method method = service . getClass ( ) . getMethod ( name , types ) ; Object result = method . invoke ( service , args ) ; System . out . println ( "result:" + result ) ; SoapObject response = new SoapObject ( soapReq . getNamespace ( ) , name + "Response" ) ; if ( result != null ) response . addProperty ( "return" , result ) ; return response ; } } 
=======
public class AutoSchemaReceiver implements SchemaReceiver { private final PropertyMap properties ; private final Rewindable rewindable ; private class Handler extends DefaultHandler implements SchemaFuture { private final XMLReader xr ; private SchemaFuture sf = null ; private Locator locator = null ; private final Vector prefixMappings = new Vector ( ) ; private Handler ( XMLReader xr ) { this . xr = xr ; } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; } public void startPrefixMapping ( String prefix , String uri ) { prefixMappings . addElement ( prefix ) ; prefixMappings . addElement ( uri ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { SchemaReceiverFactory srf = properties . get ( SchemaReceiverFactory . PROPERTY ) ; SchemaReceiver sr = srf . createSchemaReceiver ( uri , properties ) ; if ( sr == null ) { Localizer localizer = new Localizer ( AutoSchemaReceiver . class ) ; String detail = ( "" . equals ( uri ) ? localizer . message ( "no_namespace" ) : localizer . message ( "unknown_namespace" , uri ) ) ; throw new SAXParseException ( detail , locator ) ; } sf = sr . installHandlers ( xr ) ; rewindable . willNotRewind ( ) ; ContentHandler contentHandler = xr . getContentHandler ( ) ; if ( contentHandler == null ) return ; if ( locator != null ) { contentHandler . setDocumentLocator ( locator ) ; contentHandler = xr . getContentHandler ( ) ; } contentHandler . startDocument ( ) ; contentHandler = xr . getContentHandler ( ) ; for ( int i = 0 , len = prefixMappings . size ( ) ; i < len ; i += 2 ) { contentHandler . startPrefixMapping ( ( String ) prefixMappings . elementAt ( i ) , ( String ) prefixMappings . elementAt ( i + 1 ) ) ; contentHandler = xr . getContentHandler ( ) ; } contentHandler . startElement ( uri , localName , qName , attributes ) ; } public Schema getSchema ( ) throws IncorrectSchemaException , SAXException , IOException { if ( sf == null ) throw new IncorrectSchemaException ( ) ; return sf . getSchema ( ) ; } public RuntimeException unwrapException ( RuntimeException e ) throws SAXException , IOException , IncorrectSchemaException { if ( sf == null ) return e ; return sf . unwrapException ( e ) ; } } public AutoSchemaReceiver ( PropertyMap properties , Rewindable rewindable ) { this . properties = properties ; this . rewindable = rewindable ; } public SchemaFuture installHandlers ( XMLReader xr ) { Handler h = new Handler ( xr ) ; xr . setContentHandler ( h ) ; return h ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
