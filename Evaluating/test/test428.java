public final class CountingBloomFilter extends Filter { private long [ ] buckets ; private final static long BUCKET_MAX_VALUE = 15 ; public CountingBloomFilter ( ) { } public CountingBloomFilter ( int vectorSize , int nbHash , int hashType ) { super ( vectorSize , nbHash , hashType ) ; buckets = new long [ buckets2words ( vectorSize ) ] ; } private static int buckets2words ( int vectorSize ) { return ( ( vectorSize - 1 ) > > > 4 ) + 1 ; } @ Override public void add ( Key key ) { if ( key == null ) { throw new NullPointerException ( "key can not be null" ) ; } int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; if ( bucketValue < BUCKET_MAX_VALUE ) { buckets [ wordNum ] = ( buckets [ wordNum ] & ~ bucketMask ) | ( ( bucketValue + 1 ) << bucketShift ) ; } } } public void delete ( Key key ) { if ( key == null ) { throw new NullPointerException ( "Key may not be null" ) ; } if ( ! membershipTest ( key ) ) { throw new IllegalArgumentException ( "Key is not a member" ) ; } int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; if ( bucketValue >= 1 && bucketValue < BUCKET_MAX_VALUE ) { buckets [ wordNum ] = ( buckets [ wordNum ] & ~ bucketMask ) | ( ( bucketValue - 1 ) << bucketShift ) ; } } } @ Override public void and ( Filter filter ) { if ( filter == null || ! ( filter instanceof CountingBloomFilter ) || filter . vectorSize != this . vectorSize || filter . nbHash != this . nbHash ) { throw new IllegalArgumentException ( "filters cannot be and-ed" ) ; } CountingBloomFilter cbf = ( CountingBloomFilter ) filter ; int sizeInWords = buckets2words ( vectorSize ) ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { this . buckets [ i ] &= cbf . buckets [ i ] ; } } @ Override public boolean membershipTest ( Key key ) { if ( key == null ) { throw new NullPointerException ( "Key may not be null" ) ; } int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; if ( ( buckets [ wordNum ] & bucketMask ) == 0 ) { return false ; } } return true ; } public int approximateCount ( Key key ) { int res = Integer . MAX_VALUE ; int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; if ( bucketValue < res ) res = ( int ) bucketValue ; } if ( res != Integer . MAX_VALUE ) { return res ; } else { return 0 ; } } @ Override public void not ( ) { throw new UnsupportedOperationException ( "not() is undefined for " + this . getClass ( ) . getName ( ) ) ; } @ Override public void or ( Filter filter ) { if ( filter == null || ! ( filter instanceof CountingBloomFilter ) || filter . vectorSize != this . vectorSize || filter . nbHash != this . nbHash ) { throw new IllegalArgumentException ( "filters cannot be or-ed" ) ; } CountingBloomFilter cbf = ( CountingBloomFilter ) filter ; int sizeInWords = buckets2words ( vectorSize ) ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { this . buckets [ i ] |= cbf . buckets [ i ] ; } } @ Override public void xor ( Filter filter ) { throw new UnsupportedOperationException ( "xor() is undefined for " + this . getClass ( ) . getName ( ) ) ; } @ Override public String toString ( ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < vectorSize ; i ++ ) { if ( i > 0 ) { res . append ( " " ) ; } int wordNum = i > > 4 ; int bucketShift = ( i & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; res . append ( bucketValue ) ; } return res . toString ( ) ; } @ Override public void write ( DataOutput out ) throws IOException { super . write ( out ) ; int sizeInWords = buckets2words ( vectorSize ) ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { out . writeLong ( buckets [ i ] ) ; } } @ Override public void readFields ( DataInput in ) throws IOException { super . readFields ( in ) ; int sizeInWords = buckets2words ( vectorSize ) ; buckets = new long [ sizeInWords ] ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { buckets [ i ] = in . readLong ( ) ; } } } 