<<<<<<< HEAD
public final class CountingBloomFilter extends Filter { private long [ ] buckets ; private final static long BUCKET_MAX_VALUE = 15 ; public CountingBloomFilter ( ) { } public CountingBloomFilter ( int vectorSize , int nbHash , int hashType ) { super ( vectorSize , nbHash , hashType ) ; buckets = new long [ buckets2words ( vectorSize ) ] ; } private static int buckets2words ( int vectorSize ) { return ( ( vectorSize - 1 ) > > > 4 ) + 1 ; } @ Override public void add ( Key key ) { if ( key == null ) { throw new NullPointerException ( "key can not be null" ) ; } int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; if ( bucketValue < BUCKET_MAX_VALUE ) { buckets [ wordNum ] = ( buckets [ wordNum ] & ~ bucketMask ) | ( ( bucketValue + 1 ) << bucketShift ) ; } } } public void delete ( Key key ) { if ( key == null ) { throw new NullPointerException ( "Key may not be null" ) ; } if ( ! membershipTest ( key ) ) { throw new IllegalArgumentException ( "Key is not a member" ) ; } int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; if ( bucketValue >= 1 && bucketValue < BUCKET_MAX_VALUE ) { buckets [ wordNum ] = ( buckets [ wordNum ] & ~ bucketMask ) | ( ( bucketValue - 1 ) << bucketShift ) ; } } } @ Override public void and ( Filter filter ) { if ( filter == null || ! ( filter instanceof CountingBloomFilter ) || filter . vectorSize != this . vectorSize || filter . nbHash != this . nbHash ) { throw new IllegalArgumentException ( "filters cannot be and-ed" ) ; } CountingBloomFilter cbf = ( CountingBloomFilter ) filter ; int sizeInWords = buckets2words ( vectorSize ) ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { this . buckets [ i ] &= cbf . buckets [ i ] ; } } @ Override public boolean membershipTest ( Key key ) { if ( key == null ) { throw new NullPointerException ( "Key may not be null" ) ; } int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; if ( ( buckets [ wordNum ] & bucketMask ) == 0 ) { return false ; } } return true ; } public int approximateCount ( Key key ) { int res = Integer . MAX_VALUE ; int [ ] h = hash . hash ( key ) ; hash . clear ( ) ; for ( int i = 0 ; i < nbHash ; i ++ ) { int wordNum = h [ i ] > > 4 ; int bucketShift = ( h [ i ] & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; if ( bucketValue < res ) res = ( int ) bucketValue ; } if ( res != Integer . MAX_VALUE ) { return res ; } else { return 0 ; } } @ Override public void not ( ) { throw new UnsupportedOperationException ( "not() is undefined for " + this . getClass ( ) . getName ( ) ) ; } @ Override public void or ( Filter filter ) { if ( filter == null || ! ( filter instanceof CountingBloomFilter ) || filter . vectorSize != this . vectorSize || filter . nbHash != this . nbHash ) { throw new IllegalArgumentException ( "filters cannot be or-ed" ) ; } CountingBloomFilter cbf = ( CountingBloomFilter ) filter ; int sizeInWords = buckets2words ( vectorSize ) ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { this . buckets [ i ] |= cbf . buckets [ i ] ; } } @ Override public void xor ( Filter filter ) { throw new UnsupportedOperationException ( "xor() is undefined for " + this . getClass ( ) . getName ( ) ) ; } @ Override public String toString ( ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < vectorSize ; i ++ ) { if ( i > 0 ) { res . append ( " " ) ; } int wordNum = i > > 4 ; int bucketShift = ( i & 0x0f ) << 2 ; long bucketMask = 15L << bucketShift ; long bucketValue = ( buckets [ wordNum ] & bucketMask ) > > > bucketShift ; res . append ( bucketValue ) ; } return res . toString ( ) ; } @ Override public void write ( DataOutput out ) throws IOException { super . write ( out ) ; int sizeInWords = buckets2words ( vectorSize ) ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { out . writeLong ( buckets [ i ] ) ; } } @ Override public void readFields ( DataInput in ) throws IOException { super . readFields ( in ) ; int sizeInWords = buckets2words ( vectorSize ) ; buckets = new long [ sizeInWords ] ; for ( int i = 0 ; i < sizeInWords ; i ++ ) { buckets [ i ] = in . readLong ( ) ; } } } 
=======
final class Cell implements Locator { private static final int MAX_COLSPAN = 1000 ; private static final int MAX_ROWSPAN = 8190 ; private int left ; private int bottom ; private int right ; private final String [ ] headers ; private final boolean header ; private final int columnNumber ; private final int lineNumber ; private final String publicId ; private final String systemId ; private final ErrorHandler errorHandler ; Cell ( int colspan , int rowspan , String [ ] headers , boolean header , Locator locator , ErrorHandler errorHandler ) throws SAXException { super ( ) ; this . errorHandler = errorHandler ; if ( locator == null ) { this . columnNumber = - 1 ; this . lineNumber = - 1 ; this . publicId = null ; this . systemId = null ; } else { this . columnNumber = locator . getColumnNumber ( ) ; this . lineNumber = locator . getLineNumber ( ) ; this . publicId = locator . getPublicId ( ) ; this . systemId = locator . getSystemId ( ) ; } if ( rowspan > MAX_ROWSPAN ) { warn ( "A rowspan attribute has the value " + rowspan + ", which exceeds the magic Gecko limit of " + MAX_ROWSPAN + "." ) ; } if ( colspan > MAX_COLSPAN ) { warn ( "A colspan attribute has the value " + colspan + ", which exceeds the magic browser limit of " + MAX_COLSPAN + "." ) ; } if ( rowspan == Integer . MAX_VALUE ) { throw new SAXException ( "Implementation limit reached. Table row counter overflowed." ) ; } this . left = 0 ; this . right = colspan ; this . bottom = ( rowspan == 0 ? Integer . MAX_VALUE : rowspan ) ; this . headers = headers ; this . header = header ; } public String [ ] getHeadings ( ) { return headers ; } public boolean isHeader ( ) { return header ; } public void warn ( String message ) throws SAXException { if ( errorHandler != null ) { errorHandler . warning ( new SAXParseException ( message , publicId , systemId , lineNumber , columnNumber ) ) ; } } public void err ( String message ) throws SAXException { if ( errorHandler != null ) { errorHandler . error ( new SAXParseException ( message , publicId , systemId , lineNumber , columnNumber ) ) ; } } public void errOnHorizontalOverlap ( Cell laterCell ) throws SAXException { if ( ! ( ( laterCell . right <= left ) || ( right <= laterCell . left ) ) ) { this . err ( "Table cell is overlapped by later table cell." ) ; laterCell . err ( "Table cell overlaps an earlier table cell." ) ; } } public void setPosition ( int top , int left ) throws SAXException { this . left = left ; this . right += left ; if ( this . right < 1 ) { throw new SAXException ( "Implementation limit reached. Table column counter overflowed." ) ; } if ( this . bottom != Integer . MAX_VALUE ) { this . bottom += top ; if ( this . bottom < 1 ) { throw new SAXException ( "Implementation limit reached. Table row counter overflowed." ) ; } } } public boolean shouldBeCulled ( int row ) { return row >= bottom ; } public int freeSlot ( int potentialSlot ) { if ( potentialSlot < left || potentialSlot >= right ) { return potentialSlot ; } else { return right ; } } public int getBottom ( ) { return bottom ; } int getLeft ( ) { return left ; } int getRight ( ) { return right ; } public void errIfNotRowspanZero ( String rowGroupType ) throws SAXException { if ( this . bottom != Integer . MAX_VALUE ) { err ( "Table cell spans past the end of its " + ( rowGroupType == null ? "implicit row group" : "row group established by a “" + rowGroupType + "” element" ) + "; clipped to the end of the row group." ) ; } } public int getColumnNumber ( ) { return columnNumber ; } public int getLineNumber ( ) { return lineNumber ; } public String getPublicId ( ) { return publicId ; } public String getSystemId ( ) { return systemId ; } public String elementName ( ) { return header ? "th" : "td" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
