<<<<<<< HEAD
public class NSLookup implements ITool { private DNS dns ; private Name domain ; private INameResolver resolver ; private IToolContext context ; private long realm ; public void toolRun ( IToolContext context ) throws ToolException { this . context = context ; IProbe probe = Activator . getInstance ( ) . getProbeManager ( ) . getLocalProbe ( ) ; realm = probe . getEntity ( ) . getId ( ) ; setupToolOptions ( ) ; context . setTitle ( "Lookup NS records for " + domain ) ; try { if ( dns != null ) resolver = dns . createNameResolver ( Activator . getInstance ( ) . getSocketEngine ( ) ) ; else resolver = Activator . getInstance ( ) . getNameResolver ( ) ; getNS ( ) ; } catch ( IOException e ) { context . exception ( "I/O Exception" , e ) ; } finally { context . done ( ) ; } } private boolean getNS ( ) { context . setStatus ( "Querying for authoritative name servers" ) ; Lookup lookup = new Lookup ( domain , Type . NS ) ; lookup . setResolver ( resolver . getExtendedResolver ( ) ) ; lookup . setSearchPath ( ( Name [ ] ) null ) ; Record [ ] records = lookup . run ( ) ; if ( records == null ) { context . info ( "No NS records found for " + domain ) ; return false ; } Activator . getInstance ( ) . getDomainEntityFactory ( ) . createDomain ( realm , context . getSpaceId ( ) , domain . toString ( ) ) ; for ( Record record : records ) processRecord ( record ) ; return true ; } private void processRecord ( Record o ) { context . info ( o . toString ( ) ) ; if ( o instanceof ARecord ) { ARecord a = ( ARecord ) o ; Activator . getInstance ( ) . getDomainEntityFactory ( ) . createARecord ( realm , context . getSpaceId ( ) , a . getName ( ) . toString ( ) , IPv4Address . fromInetAddress ( a . getAddress ( ) ) ) ; } else if ( o instanceof AAAARecord ) { AAAARecord aaaa = ( AAAARecord ) o ; Activator . getInstance ( ) . getDomainEntityFactory ( ) . createAAAARecord ( realm , context . getSpaceId ( ) , aaaa . getName ( ) . toString ( ) , IPv6Address . fromInetAddress ( aaaa . getAddress ( ) ) ) ; } else if ( o instanceof PTRRecord ) { PTRRecord ptr = ( PTRRecord ) o ; context . warning ( "unhandled record: " + ptr ) ; } else if ( o instanceof MXRecord ) { processMXRecord ( ( MXRecord ) o ) ; } else if ( o instanceof NSRecord ) { processNSRecord ( ( NSRecord ) o ) ; } else { context . warning ( "Unhandled DNS record: " + o ) ; } } private void processNSRecord ( NSRecord ns ) { NSRecordEntity entity = Activator . getInstance ( ) . getDomainEntityFactory ( ) . createNSRecord ( realm , context . getSpaceId ( ) , domain . toString ( ) , ns . getTarget ( ) . toString ( ) ) ; try { List < InternetAddress > addresses = resolver . getAddressesByName ( ns . getTarget ( ) . toString ( ) ) ; for ( InternetAddress address : addresses ) { if ( address instanceof IPv4Address ) { Activator . getInstance ( ) . getDomainEntityFactory ( ) . createARecord ( realm , context . getSpaceId ( ) , ns . getTarget ( ) . toString ( ) , ( IPv4Address ) address ) ; } else { Activator . getInstance ( ) . getDomainEntityFactory ( ) . createAAAARecord ( realm , context . getSpaceId ( ) , ns . getTarget ( ) . toString ( ) , ( IPv6Address ) address ) ; } UDPSocketLocator locator = new UDPSocketLocator ( address , 53 ) ; ServiceEntity service = Activator . getInstance ( ) . getNetworkEntityFactory ( ) . createService ( realm , context . getSpaceId ( ) , locator , "DNS" , null ) ; entity . setService ( service ) ; } entity . save ( ) ; } catch ( UnknownHostException e ) { context . warning ( "Could not resolve NS record target " + ns . getTarget ( ) ) ; } catch ( TextParseException e ) { context . warning ( "Malformed host name as NS record target: " + ns . getTarget ( ) ) ; } } private void processMXRecord ( MXRecord mx ) { MXRecordEntity entity = Activator . getInstance ( ) . getDomainEntityFactory ( ) . createMXRecord ( realm , context . getSpaceId ( ) , domain . toString ( ) , mx . getTarget ( ) . toString ( ) , mx . getPriority ( ) ) ; try { List < InternetAddress > addresses = resolver . getAddressesByName ( mx . getTarget ( ) . toString ( ) ) ; for ( InternetAddress address : addresses ) { if ( address instanceof IPv4Address ) { Activator . getInstance ( ) . getDomainEntityFactory ( ) . createARecord ( realm , context . getSpaceId ( ) , mx . getTarget ( ) . toString ( ) , ( IPv4Address ) address ) ; } else { Activator . getInstance ( ) . getDomainEntityFactory ( ) . createAAAARecord ( realm , context . getSpaceId ( ) , mx . getTarget ( ) . toString ( ) , ( IPv6Address ) address ) ; } TCPSocketLocator locator = new TCPSocketLocator ( address , 25 ) ; ServiceEntity service = Activator . getInstance ( ) . getNetworkEntityFactory ( ) . createService ( realm , context . getSpaceId ( ) , locator , "SMTP" , null ) ; entity . setService ( service ) ; } entity . save ( ) ; } catch ( UnknownHostException e ) { context . warning ( "Could not resolve MX record target " + mx . getTarget ( ) ) ; } catch ( TextParseException e ) { context . warning ( "Malformed host name as MX record target: " + mx . getTarget ( ) ) ; } } private void setupToolOptions ( ) throws ToolException { dns = ( DNS ) context . getConfiguration ( ) . get ( "dns" ) ; String domainString = ( String ) context . getConfiguration ( ) . get ( "domain" ) ; if ( domainString == null || domainString . length ( ) == 0 ) { throw new RequiredOptionMissingException ( "domain" ) ; } if ( domainString . endsWith ( "." ) ) { domainString = domainString . substring ( 0 , domainString . length ( ) - 1 ) ; } try { domain = new Name ( domainString ) ; } catch ( TextParseException e ) { throw new ToolException ( "Malformed host name: '" + domainString + "'" ) ; } } } 
=======
class ContextMap { private Object rootValue ; private Object otherValue ; private final Hashtable nameTable = new Hashtable ( ) ; Object get ( Vector context ) { return get ( context , context . size ( ) ) ; } boolean put ( boolean isRoot , Vector names , Object value ) { return put ( isRoot , names , names . size ( ) , value ) ; } private Object get ( Vector context , int len ) { if ( len > 0 ) { ContextMap nestedMap = ( ContextMap ) nameTable . get ( context . elementAt ( len - 1 ) ) ; if ( nestedMap != null ) { Object value = nestedMap . get ( context , len - 1 ) ; if ( value != null ) return value ; } } if ( rootValue != null && len == 0 ) return rootValue ; return otherValue ; } private boolean put ( boolean isRoot , Vector names , int len , Object value ) { if ( len == 0 ) { if ( isRoot ) { if ( rootValue != null ) return false ; rootValue = value ; } else { if ( otherValue != null ) return false ; otherValue = value ; } return true ; } else { Object name = names . elementAt ( len - 1 ) ; ContextMap nestedMap = ( ContextMap ) nameTable . get ( name ) ; if ( nestedMap == null ) { nestedMap = new ContextMap ( ) ; nameTable . put ( name , nestedMap ) ; } return nestedMap . put ( isRoot , names , len - 1 , value ) ; } } public boolean equals ( Object obj ) { if ( ! ( obj instanceof ContextMap ) ) return false ; ContextMap other = ( ContextMap ) obj ; if ( ! Equal . equal ( this . rootValue , other . rootValue ) || ! Equal . equal ( this . otherValue , other . otherValue ) ) return false ; if ( this . nameTable . size ( ) != other . nameTable . size ( ) ) return false ; for ( Enumeration e = nameTable . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; if ( ! nameTable . get ( key ) . equals ( other . nameTable . get ( key ) ) ) return false ; } return true ; } public int hashCode ( ) { int hc = 0 ; if ( rootValue != null ) hc ^= rootValue . hashCode ( ) ; if ( otherValue != null ) hc ^= otherValue . hashCode ( ) ; for ( Enumeration e = nameTable . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; hc ^= key . hashCode ( ) ; hc ^= nameTable . get ( key ) . hashCode ( ) ; } return hc ; } static private class Enumerator implements Enumeration { private Object rootValue ; private Object otherValue ; private Enumeration subMapValues ; private final Enumeration subMaps ; private Enumerator ( ContextMap map ) { rootValue = map . rootValue ; otherValue = map . otherValue ; subMaps = map . nameTable . elements ( ) ; } private void prep ( ) { while ( ( subMapValues == null || ! subMapValues . hasMoreElements ( ) ) && subMaps . hasMoreElements ( ) ) subMapValues = ( ( ContextMap ) subMaps . nextElement ( ) ) . values ( ) ; } public boolean hasMoreElements ( ) { prep ( ) ; return rootValue != null || otherValue != null || ( subMapValues != null && subMapValues . hasMoreElements ( ) ) ; } public Object nextElement ( ) { if ( rootValue != null ) { Object tem = rootValue ; rootValue = null ; return tem ; } if ( otherValue != null ) { Object tem = otherValue ; otherValue = null ; return tem ; } prep ( ) ; if ( subMapValues == null ) throw new NoSuchElementException ( ) ; return subMapValues . nextElement ( ) ; } } Enumeration values ( ) { return new Enumerator ( this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
