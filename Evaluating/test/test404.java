public class Diff implements RefTree { public static final String DIFF_NS_PREFIX = "diff" ; public static final String DIFF_NS = "http://www.hiit.fi/fc/xml/tdm/diff" ; public static final Qname DIFF_COPY_TAG = new Qname ( DIFF_NS , "copy" ) ; public static final Qname DIFF_INS_TAG = new Qname ( DIFF_NS , "insert" ) ; public static final Qname DIFF_ROOT_TAG = new Qname ( DIFF_NS , "diff" ) ; public static final String DIFF_ROOTOP_INS = "insert" ; public static final String ATT_NS = "" ; public static final Qname DIFF_CPYSRC_ATTR = new Qname ( ATT_NS , "src" ) ; public static final Qname DIFF_CPYDST_ATTR = new Qname ( ATT_NS , "dst" ) ; public static final Qname DIFF_CPYRUN_ATTR = new Qname ( ATT_NS , "run" ) ; public static final Qname DIFF_ROOTOP_ATTR = new Qname ( ATT_NS , "op" ) ; protected RefTreeNode root = null ; protected Diff ( ) { } public static Diff encode ( IdAddressableRefTree base , RefTree refTree ) throws IOException { Diff d = new Diff ( ) ; ( d . new RefTreeDiffer ( base , null ) ) . runDiff ( refTree . getRoot ( ) ) ; return d ; } public static Diff encode ( RefTree refTree , SequenceTester st ) throws IOException { Diff d = new Diff ( ) ; ( d . new RefTreeDiffer ( null , st ) ) . runDiff ( refTree . getRoot ( ) ) ; return d ; } public RefTree decode ( IdAddressableRefTree base ) throws IOException { Object c = getRoot ( ) . getContent ( ) ; RefTreeNode rtroot = null ; if ( c instanceof DiffOperation && ( ( DiffOperation ) c ) . getOperation ( ) == DiffOperation . ROOT_INSERT ) { Iterator insTree = getRoot ( ) . getChildIterator ( ) ; if ( ! insTree . hasNext ( ) ) throw new DiffFormatException ( "Diff encodes empty XML document" ) ; RefTreeNode diffRoot = ( RefTreeNode ) insTree . next ( ) ; if ( diffRoot . getContent ( ) instanceof DiffOperation ) { DiffOperation ro = ( DiffOperation ) diffRoot . getContent ( ) ; if ( ro . getOperation ( ) != DiffOperation . COPY || ( ( Number ) ro . getRun ( ) ) . longValue ( ) != 1 ) throw new DiffFormatException ( "Invalid diff operation at XPath /0/0: " ) ; diffRoot = new RefTreeNodeImpl ( null , new TransientKey ( ) , new TreeReference ( ro . getSource ( ) ) ) ; } rtroot = new DelayedRefTreeNode ( diffRoot , base ) ; } else if ( c instanceof DiffOperation && ( ( DiffOperation ) c ) . getOperation ( ) == DiffOperation . ROOT_COPY ) { rtroot = new RefTreeNodeImpl ( null , new TransientKey ( ) , new TreeReference ( ( ( DiffOperation ) c ) . getSource ( ) ) ) ; } else throw new DiffFormatException ( "Invalid diff root tag" ) ; return new RefTreeImpl ( rtroot ) ; } public void writeDiff ( ItemTarget t , TreeModel tm ) throws IOException { fc . xml . xmlr . xas . XasSerialization . writeTree ( this , t , new DiffTreeModel ( tm , this . getRoot ( ) . getId ( ) ) , tm ) ; } public static Diff readDiff ( ItemSource is ) throws IOException { return readDiff ( new TransformSource ( new TransformSource ( is , new ReferenceItemTransform ( ) ) , new RelativeDeweyKeyExpander ( ) ) , TreeModels . xasItemTree ( ) , DeweyKey . ROOT_KEY ) ; } public static Diff readDiff ( ItemSource is , TreeModel tm , Key baseRootId ) throws IOException { Diff d = new Diff ( ) ; TreeModel dtm = new TreeModel ( tm . getKeyModel ( ) , getDiffIdentificationModel ( tm . getIdentificationModel ( ) ) , getDiffCodec ( tm . getCodec ( ) , baseRootId ) , tm . getNodeModel ( ) ) ; RefTree t = fc . xml . xmlr . xas . XasSerialization . readTree ( is , dtm ) ; d . root = t . getRoot ( ) ; return d ; } public XasCodec getDiffCodec ( XasCodec codec ) { return getDiffCodec ( codec , getRoot ( ) . getId ( ) ) ; } public static XasCodec getDiffCodec ( XasCodec codec , Key rootId ) { return new DiffTreeModel ( codec , rootId ) ; } private static IdentificationModel getDiffIdentificationModel ( final IdentificationModel m ) { return new IdentificationModel ( ) { public Key identify ( Item i , KeyModel km ) throws IOException { if ( i . getType ( ) == Item . START_TAG && DIFF_NS . equals ( ( ( StartTag ) i ) . getName ( ) . getNamespace ( ) ) ) return new TransientKey ( ) ; else return m . identify ( i , km ) ; } public Item tag ( Item i , Key k , KeyModel km ) { if ( i . getType ( ) == Item . START_TAG && DIFF_NS . equals ( ( ( StartTag ) i ) . getName ( ) . getNamespace ( ) ) ) return i ; else return m . tag ( i , k , km ) ; } } ; } public RefTreeNode getRoot ( ) { return root ; } protected class RefTreeDiffer extends DiffAlgorithm { private RefTreeNodeImpl currentNode = null ; private IdAddressableRefTree base ; private SequenceTester st ; private Map successors = new HashMap ( ) ; public RefTreeDiffer ( IdAddressableRefTree base , SequenceTester st ) { if ( base != null && st != null ) Log . log ( "Either must be null" , LogLevels . ASSERTFAILED ) ; this . base = base ; this . st = st ; } public void runDiff ( RefTreeNode root ) throws IOException { diff ( root ) ; } @ Override protected List getStopNodes ( Object changeNode ) { RefTreeNode n = ( ( RefTreeNode ) changeNode ) ; List l = null ; if ( n . isTreeRef ( ) ) l = Collections . EMPTY_LIST ; else { l = new ArrayList ( 1 ) ; l . add ( changeNode ) ; } return l ; } @ Override protected Object lookupBase ( Object changeNode ) { RefTreeNode n = ( ( RefTreeNode ) changeNode ) ; if ( n . isTreeRef ( ) ) { Key target = n . getReference ( ) . getTarget ( ) ; return base . getNode ( target ) ; } return null ; } @ Override protected void content ( Object node , boolean start ) { RefTreeNodeImpl n = null ; if ( node instanceof DiffAlgorithm . DiffOperation ) { DiffAlgorithm . DiffOperation op = ( DiffAlgorithm . DiffOperation ) node ; Diff . DiffOperation c = new Diff . DiffOperation ( op . getOperation ( ) , identify ( op . getSource ( ) ) , identify ( op . getDestination ( ) ) , op . getRun ( ) , identify ( op . getSource ( ) ) ) ; n = new RefTreeNodeImpl ( currentNode , new TransientKey ( ) , c ) ; } else n = new RefTreeNodeImpl ( currentNode , ( ( RefTreeNode ) node ) . getId ( ) , ( RefTreeNode ) node ) ; if ( start ) { if ( currentNode != null ) currentNode . addChild ( n ) ; else root = n ; } if ( start ) currentNode = n ; else currentNode = ( RefTreeNodeImpl ) currentNode . getParent ( ) ; } @ Override protected Iterator getChildIterator ( Object changeNode ) { return ( ( RefTreeNode ) changeNode ) . getChildIterator ( ) ; } @ Override protected boolean appends ( Object baseTailO , Object baseNextO ) { RefTreeNode baseTail = ( RefTreeNode ) baseTailO ; RefTreeNode baseNext = ( RefTreeNode ) baseNextO ; if ( st != null ) return st . inSequence ( baseTail , baseNext ) ; Key baseId = baseTail . getId ( ) ; Key succ = ensureSuccessor ( baseId , successors , base ) ; return succ != NO_SUCCESSOR && succ . equals ( baseNext . getId ( ) ) ; } protected Key identify ( Object node ) { if ( node == DiffAlgorithm . DiffOperation . NO_VALUE ) return null ; if ( ! ( node instanceof RefTreeNode ) ) { Log . log ( "Erroneous node class" , LogLevels . ASSERTFAILED ) ; return StringKey . createKey ( "ERROR:" + node . toString ( ) ) ; } return ( ( RefTreeNode ) node ) . getId ( ) ; } } private static final Key NO_SUCCESSOR = StringKey . createUniqueKey ( ) ; protected static Key ensureSuccessor ( Key baseId , Map < Key , Key > succcessors , IdAddressableRefTree base ) { final Key NO_PREDECESSOR = StringKey . createUniqueKey ( ) ; Key succ = succcessors . get ( baseId ) ; try { if ( succ == null ) { Key pid = base . getParent ( baseId ) ; Key prev = NO_PREDECESSOR ; for ( Iterator < Key > i = base . childIterator ( pid ) ; i . hasNext ( ) ; ) { Key nid = i . next ( ) ; if ( prev != NO_PREDECESSOR ) succcessors . put ( prev , nid ) ; prev = nid ; } succcessors . put ( prev , NO_SUCCESSOR ) ; succ = succcessors . get ( baseId ) ; if ( succ == null ) Log . log ( "Broken parent/child relationship" , LogLevels . ASSERTFAILED ) ; } } catch ( NodeNotFoundException x ) { Log . log ( "Broken reftree" , LogLevels . FATALERROR , x ) ; } return succ ; } public static class DiffFormatException extends IOException { public DiffFormatException ( String msg ) { super ( msg ) ; } } public interface SequenceTester { public boolean inSequence ( RefTreeNode a , RefTreeNode b ) ; } protected static class DiffOperation implements RefTrees . IdentifiableContent { public static final int ROOT_COPY = DiffAlgorithm . DiffOperation . ROOT_COPY ; public static final int ROOT_INSERT = DiffAlgorithm . DiffOperation . ROOT_INSERT ; public static final int COPY = DiffAlgorithm . DiffOperation . COPY ; public static final int INSERT = DiffAlgorithm . DiffOperation . INSERT ; private int operation ; private Key source ; private Key destination ; private Key id ; private Long run ; protected DiffOperation ( int aOperation , Key aSource , Key aDestination , Long aRun , Key aid ) { operation = aOperation ; source = aSource ; destination = aDestination ; run = aRun ; id = aid ; } public int getOperation ( ) { return operation ; } public Key getSource ( ) { return source ; } public Key getDestination ( ) { return destination ; } public Long getRun ( ) { return run ; } public Key getId ( ) { return id ; } @ Override public String toString ( ) { return "diff{" + ( operation == COPY ? "cpy" : ( operation == INSERT ? "ins" : ( operation == ROOT_COPY ? "rcpy" : "rins" ) ) ) + ",src=" + source + ",dst=" + destination + ",run=" + run + "}" ; } } protected static class DelayedRefTreeNode implements RefTreeNode { final RefTreeNode node ; final IdAddressableRefTree base ; public DelayedRefTreeNode ( RefTreeNode node , IdAddressableRefTree base ) { this . node = node ; this . base = base ; } protected void trap ( NodeNotFoundException ex ) { Log . fatal ( "Untrapped missing node " + ex . getId ( ) , ex ) ; } public Iterator getChildIterator ( ) { final Iterator baseIterator = node . getChildIterator ( ) ; return new Iterator ( ) { Iterator copySequenceIterator = null ; public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public boolean hasNext ( ) { return ( copySequenceIterator != null && copySequenceIterator . hasNext ( ) ) || baseIterator . hasNext ( ) ; } public Object next ( ) { if ( copySequenceIterator != null ) { if ( copySequenceIterator . hasNext ( ) ) return copySequenceIterator . next ( ) ; else copySequenceIterator = null ; } RefTreeNode next = ( RefTreeNode ) baseIterator . next ( ) ; if ( next . getContent ( ) instanceof DiffOperation ) { if ( next . getChildIterator ( ) . hasNext ( ) ) throw new IllegalStateException ( "diffops may not have children in" + "this version of the algo" ) ; try { copySequenceIterator = new CopySequenceIterator ( ( DiffOperation ) next . getContent ( ) , DelayedRefTreeNode . this , base ) ; } catch ( NodeNotFoundException e ) { trap ( e ) ; } return copySequenceIterator . next ( ) ; } return new DelayedRefTreeNode ( next , base ) ; } } ; } public Object getContent ( ) { return node . getContent ( ) ; } public Key getId ( ) { return node . getId ( ) ; } public RefTreeNode getParent ( ) { RefTreeNode n = node . getParent ( ) ; return n != null ? new DelayedRefTreeNode ( n , base ) : null ; } public boolean isNodeRef ( ) { return node . isNodeRef ( ) ; } public boolean isReference ( ) { return node . isReference ( ) ; } public boolean isTreeRef ( ) { return node . isTreeRef ( ) ; } public Reference getReference ( ) { return node . getReference ( ) ; } } protected static class CopySequenceIterator implements Iterator { protected Map < Key , Key > successors = new HashMap ( ) ; Key id ; long left ; DelayedRefTreeNode parent ; public CopySequenceIterator ( DiffOperation op , DelayedRefTreeNode parent , IdAddressableRefTree baseTree ) throws NodeNotFoundException { if ( op . getOperation ( ) != DiffOperation . ROOT_COPY && op . getOperation ( ) != DiffOperation . COPY ) throw new IllegalStateException ( "No inserts should be seen here" ) ; id = op . getSource ( ) ; if ( ! baseTree . contains ( id ) ) throw new NodeNotFoundException ( id ) ; ensureSuccessor ( id , successors , baseTree ) ; left = op . getRun ( ) != null ? op . getRun ( ) . longValue ( ) : 1 ; if ( left < 1 ) Log . log ( "CS iter should never map to <1 elems." , LogLevels . ASSERTFAILED ) ; this . parent = parent ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public boolean hasNext ( ) { return left > 0 && id != NO_SUCCESSOR ; } public Object next ( ) { if ( left <= 0 || id == NO_SUCCESSOR ) throw new NoSuchElementException ( ) ; Key current = id ; id = successors . get ( id ) ; left -- ; return new RefTreeNodeImpl ( parent , current , new TreeReference ( current ) ) ; } } public static class DiffTreeModel implements XasCodec { private Key rootId ; private XasCodec codec ; public DiffTreeModel ( XasCodec wtm , Key rootId ) { this . codec = wtm ; this . rootId = rootId ; } public Object decode ( PeekableItemSource is , KeyIdentificationModel kim ) throws IOException { Item i = is . peek ( ) ; Object diffTag = null ; do_default : if ( i . getType ( ) == Item . START_TAG ) { StartTag st = ( StartTag ) i ; if ( DIFF_COPY_TAG . equals ( st . getName ( ) ) ) { is . next ( ) ; String src = null , dst = null ; Long run = null ; for ( Iterator < AttributeNode > it = st . attributes ( ) ; it . hasNext ( ) ; ) { AttributeNode an = it . next ( ) ; if ( DIFF_CPYSRC_ATTR . equals ( an . getName ( ) ) ) src = an . getValue ( ) . toString ( ) ; else if ( DIFF_CPYDST_ATTR . equals ( an . getName ( ) ) ) dst = an . getValue ( ) . toString ( ) ; else if ( DIFF_CPYRUN_ATTR . equals ( an . getName ( ) ) ) { try { if ( an . getValue ( ) instanceof Number ) run = ( ( Number ) an . getValue ( ) ) . longValue ( ) ; else run = new Long ( an . getValue ( ) . toString ( ) ) ; } catch ( NumberFormatException x ) { throw new DiffFormatException ( "Non-numeric run: " + an . getValue ( ) ) ; } } else throw new DiffFormatException ( "Unknown attribute: " + an . getName ( ) ) ; } diffTag = new DiffOperation ( DiffOperation . COPY , kim . makeKey ( src ) , kim . makeKey ( dst ) , run , kim . makeKey ( src ) ) ; return diffTag ; } else if ( DIFF_INS_TAG . equals ( st . getName ( ) ) ) { is . next ( ) ; throw new DiffFormatException ( "Diffs with inserts cannot be decoded to reftrees" ) ; } else if ( DIFF_ROOT_TAG . equals ( st . getName ( ) ) ) { is . next ( ) ; boolean rootIsIns = false ; for ( Iterator < AttributeNode > it = st . attributes ( ) ; it . hasNext ( ) ; ) { AttributeNode an = it . next ( ) ; if ( DIFF_ROOTOP_ATTR . equals ( an . getName ( ) ) ) { if ( ! DIFF_ROOTOP_INS . equals ( an . getValue ( ) ) ) throw new DiffFormatException ( "Unknown root operation " + an . getValue ( ) ) ; rootIsIns = true ; } } RefTrees . IdentifiableContent c = new DiffOperation ( rootIsIns ? DiffOperation . ROOT_INSERT : DiffOperation . ROOT_COPY , rootId , null , null , rootId ) ; if ( ! rootIsIns ) { diffTag = c ; } else diffTag = null ; return c ; } else break do_default ; } return codec . decode ( is , kim ) ; } public void encode ( ItemTarget t , RefTreeNode n , StartTag context ) throws IOException { Object o = n . getContent ( ) ; if ( ! ( o instanceof DiffOperation ) ) { codec . encode ( t , n , context ) ; return ; } DiffOperation op = ( DiffOperation ) o ; StartTag rt ; switch ( op . getOperation ( ) ) { case DiffOperation . ROOT_INSERT : case DiffOperation . ROOT_COPY : rt = new StartTag ( DIFF_ROOT_TAG , context ) ; rt . ensurePrefix ( DIFF_NS , DIFF_NS_PREFIX ) ; if ( op . getOperation ( ) == DiffOperation . ROOT_INSERT ) rt . addAttribute ( DIFF_ROOTOP_ATTR , DIFF_ROOTOP_INS ) ; break ; case DiffOperation . COPY : rt = new StartTag ( DIFF_COPY_TAG , context ) ; rt . ensurePrefix ( DIFF_NS , DIFF_NS_PREFIX ) ; addAttributes ( op , rt ) ; break ; case DiffOperation . INSERT : rt = new StartTag ( DIFF_INS_TAG , context ) ; rt . ensurePrefix ( DIFF_NS , DIFF_NS_PREFIX ) ; addAttributes ( op , rt ) ; break ; default : throw new IOException ( "Unknown diffop: " + op . getOperation ( ) ) ; } t . append ( rt ) ; } protected void addAttributes ( DiffOperation op , StartTag t ) throws IOException { if ( op . getDestination ( ) != null ) t . addAttribute ( DIFF_CPYDST_ATTR , op . getDestination ( ) . toString ( ) ) ; if ( op . getSource ( ) != null ) t . addAttribute ( DIFF_CPYSRC_ATTR , op . getSource ( ) . toString ( ) ) ; if ( op . getRun ( ) != null ) t . addAttribute ( DIFF_CPYRUN_ATTR , op . getRun ( ) . toString ( ) ) ; } } public static class RelativeDeweyKeyExpander implements ItemTransform { private Stack < String > parentPaths = new Stack < String > ( ) ; protected Queue < Item > queue = new LinkedList < Item > ( ) ; public RelativeDeweyKeyExpander ( ) { } private String getAbsolutePath ( String parent , String path ) { if ( path . startsWith ( "/" ) ) return path ; assert parent != null ; assert ( path . startsWith ( "." ) ) ; return parent + path . substring ( 1 ) ; } public boolean hasItems ( ) { return ! queue . isEmpty ( ) ; } public Item next ( ) { return queue . poll ( ) ; } public void append ( Item ev ) throws IOException { switch ( ev . getType ( ) ) { case Item . START_DOCUMENT : queue . add ( ev ) ; parentPaths . push ( null ) ; break ; case RefTreeItem . TREE_REFERENCE : RefItem ri = ( RefItem ) ev ; String target = ri . getTarget ( ) . toString ( ) ; if ( target . startsWith ( "." ) ) { ev = RefItem . makeStartItem ( new TreeReference ( StringKey . createKey ( getAbsolutePath ( parentPaths . peek ( ) , target ) ) ) , null ) ; } queue . add ( ev ) ; break ; case Item . START_TAG : StartTag st = ( StartTag ) ev ; if ( DIFF_COPY_TAG . equals ( st . getName ( ) ) ) { StartTag xst = new StartTag ( st . getName ( ) ) ; for ( Iterator < AttributeNode > ai = st . attributes ( ) ; ai . hasNext ( ) ; ) { AttributeNode an = ai . next ( ) ; if ( DIFF_CPYSRC_ATTR . equals ( an . getName ( ) ) ) xst . addAttribute ( an . getName ( ) , getAbsolutePath ( parentPaths . isEmpty ( ) ? null : parentPaths . peek ( ) , an . getValue ( ) . toString ( ) ) ) ; else xst . addAttribute ( an . getName ( ) , an . getValue ( ) ) ; } ev = xst ; } queue . add ( ev ) ; break ; case RefNodeItem . NODE_REFERENCE : RefNodeItem rin = ( RefNodeItem ) ev ; if ( ! rin . isEndTag ( ) ) { target = rin . getTarget ( ) . toString ( ) ; if ( target . startsWith ( "." ) ) { target = getAbsolutePath ( parentPaths . peek ( ) , target ) ; ev = RefItem . makeStartItem ( new NodeReference ( StringKey . createKey ( target ) ) , null ) ; } queue . add ( ev ) ; parentPaths . push ( target ) ; } else { parentPaths . pop ( ) ; queue . add ( ev ) ; } break ; case Item . END_DOCUMENT : queue . add ( ev ) ; parentPaths . pop ( ) ; break ; default : queue . add ( ev ) ; } } } } 