public class ColorizerReader extends ValidatingReader { private static final String SCHEMA = "/com/aptana/ide/editors/resources/ColorizationSchema.xml" ; private static final Pattern PARSE_ERROR_LINE_NUMBER = Pattern . compile ( " line (\\d+)" ) ; private String currentCategory ; private IToken currentToken ; private String mimeType ; private Locator locator ; private IErrorHandler errorHandler ; private ITokenList defaultTokenList ; private LanguageColorizer colorizer ; private Map < String , Map < String , IToken > > categoriesToToken ; private Map < String , ColorizationStyle > styles ; private Map < String , String > ids ; private Map < String , URL > urls ; private Map < Object , String > waitingElements ; private Map < Region , IToken > regionsToToken ; private Map < String , InstanceCreator > instanceCreators = new HashMap < String , InstanceCreator > ( ) ; private List < IColorizerHandler > handlers = new ArrayList < IColorizerHandler > ( ) ; protected boolean registerColorizer ; public ColorizerReader ( ) { this ( null ) ; } public ColorizerReader ( ITokenList tokenList ) { categoriesToToken = new HashMap < String , Map < String , IToken > > ( ) ; styles = new HashMap < String , ColorizationStyle > ( ) ; ids = new HashMap < String , String > ( ) ; urls = new HashMap < String , URL > ( ) ; waitingElements = new HashMap < Object , String > ( ) ; regionsToToken = new HashMap < Region , IToken > ( ) ; this . defaultTokenList = tokenList ; this . _schema = createSchema ( ) ; } public void loadExtensionPointColorizers ( ) { registerColorizer = true ; IExtensionRegistry reg = Platform . getExtensionRegistry ( ) ; IExtensionPoint ep = reg . getExtensionPoint ( UnifiedEditorsPlugin . COLORIZATION_EXTENSION_POINT ) ; if ( ep == null ) { return ; } IExtension [ ] extensions = ep . getExtensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { try { String pluginID = extensions [ i ] . getContributor ( ) . getName ( ) ; IConfigurationElement [ ] elements = extensions [ i ] . getConfigurationElements ( ) ; for ( IConfigurationElement element : elements ) { if ( ! LanguageRegistry . isActivityEnabled ( element ) ) { continue ; } else if ( ColorizationConstants . COLORIZATION_ELEMENT . equals ( element . getName ( ) ) ) { String colorizationFile = element . getAttribute ( ColorizationConstants . FILE_ATTR ) ; final String id = element . getAttribute ( ColorizationConstants . ID_ATTR ) ; if ( colorizationFile != null && id != null && id . length ( ) > 0 ) { Bundle bundle = Platform . getBundle ( pluginID ) ; final URL filePath = bundle . getEntry ( colorizationFile ) ; if ( filePath != null ) { InstanceCreator creator = new InstanceCreator ( null , null ) { public Object createInstance ( ) { return loadColorizationFromURL ( filePath , id , false ) ; } } ; AttributeSniffer sniffer = new AttributeSniffer ( ColorizationConstants . COLORIZER , ColorizationConstants . LANGUAGE ) ; sniffer . read ( filePath . openStream ( ) ) ; if ( sniffer . getMatchedValue ( ) != null ) { String language = sniffer . getMatchedValue ( ) ; instanceCreators . put ( language , creator ) ; } } } } else if ( ColorizationConstants . HANDLER_ELEMENT . equals ( element . getName ( ) ) ) { String handler = element . getAttribute ( ColorizationConstants . CLASS_ATTR ) ; if ( handler != null ) { try { Object obj = element . createExecutableExtension ( ColorizationConstants . CLASS_ATTR ) ; if ( obj instanceof IColorizerHandler ) { IColorizerHandler colorizerHandler = ( IColorizerHandler ) obj ; handlers . add ( colorizerHandler ) ; } } catch ( CoreException e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERR_ErrorCreatingColorizerHandler , e ) ; } } } } } catch ( InvalidRegistryObjectException e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERROR_EXTENSION_POINT ) ; } catch ( Exception e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , e . getMessage ( ) ) ; } } } public LanguageColorizer loadLanguageColorizer ( InputStream stream , boolean register ) { registerColorizer = register ; colorizer = null ; try { this . loadXML ( stream ) ; } catch ( Exception e ) { colorizer = null ; } return colorizer ; } public void importColorization ( File file , String mimeType ) { InputStream stream = null ; try { String id = ids . get ( mimeType ) ; if ( id != null ) { IPreferenceStore store = UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) ; String content = store . getString ( id ) ; stream = file . toURL ( ) . openStream ( ) ; this . loadXML ( stream ) ; if ( mimeType != null ) { store . setValue ( id , content ) ; } } } catch ( Exception e1 ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERROR_IMPORTING ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } public LanguageColorizer importColorization ( File file ) { InputStream stream = null ; try { stream = new FileInputStream ( file ) ; registerColorizer = false ; LanguageColorizer colorizer = this . loadXML ( stream ) ; return colorizer ; } catch ( Exception e1 ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERROR_IMPORTING ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } return null ; } public LanguageColorizer loadColorization ( String id , boolean register ) { registerColorizer = register ; colorizer = null ; mimeType = null ; try { IPreferenceStore store = UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) ; String content = store . getString ( id ) ; InputStream stream = null ; if ( content . length ( ) > 0 ) { stream = new ByteArrayInputStream ( content . getBytes ( ) ) ; this . loadXML ( stream ) ; if ( mimeType != null ) { setPreferenceId ( mimeType , id ) ; store . setValue ( id , content ) ; } } } catch ( Exception e ) { colorizer = null ; } return colorizer ; } public LanguageColorizer loadColorizationFromURL ( URL url , String id , boolean useDefault ) { InputStream stream = null ; colorizer = null ; mimeType = null ; try { IPreferenceStore store = UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) ; String content = store . getString ( id ) ; if ( content . length ( ) > 0 && ! useDefault ) { stream = new ByteArrayInputStream ( content . getBytes ( ) ) ; } else { stream = url . openStream ( ) ; } this . loadXML ( stream ) ; if ( mimeType != null ) { setPreferenceId ( mimeType , id ) ; urls . put ( mimeType , url ) ; store . setValue ( id , content ) ; } } catch ( Exception e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , StringUtils . format ( Messages . ColorizerReader_ERROR_LOADING , id ) ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } return colorizer ; } private LanguageColorizer loadXML ( InputStream stream ) { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; SAXParser saxParser = null ; saxParser = factory . newSAXParser ( ) ; saxParser . parse ( stream , this ) ; return colorizer ; } catch ( Exception e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERR_ErrorParsingColorizationFile , e ) ; } return null ; } public String getPreferenceId ( String mimeType ) { return ids . get ( mimeType ) ; } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; } private void sendWarning ( String message ) { if ( this . errorHandler != null ) { int line = this . locator . getLineNumber ( ) ; int column = this . locator . getColumnNumber ( ) ; if ( line == - 1 ) { Matcher m = PARSE_ERROR_LINE_NUMBER . matcher ( message ) ; if ( m . find ( ) ) { line = Integer . parseInt ( m . group ( 1 ) ) ; } else { line = 0 ; } } this . errorHandler . handleWarning ( line , column , message ) ; } } public void setErrorHandler ( IErrorHandler errorHandler ) { this . errorHandler = errorHandler ; } private void sendError ( String message ) { if ( this . errorHandler != null ) { int line = this . locator . getLineNumber ( ) ; int column = this . locator . getColumnNumber ( ) ; if ( line == - 1 ) { Matcher m = PARSE_ERROR_LINE_NUMBER . matcher ( message ) ; if ( m . find ( ) ) { line = Integer . parseInt ( m . group ( 1 ) ) ; } else { line = 0 ; } } this . errorHandler . handleError ( line , column , message ) ; } } private RGB parseRGB ( String value ) { String original = value ; RGB rgb = new RGB ( 0 , 0 , 0 ) ; try { value = value . trim ( ) ; if ( value . startsWith ( "rgb" ) ) { value = value . substring ( 4 , value . length ( ) ) ; value = value . substring ( 0 , value . length ( ) - 1 ) ; String [ ] rgbs = value . split ( "," ) ; if ( rgbs . length >= 3 ) { try { rgb . red = Integer . parseInt ( rgbs [ 0 ] . trim ( ) ) ; } catch ( NumberFormatException e ) { sendError ( Messages . ColorizerReader_ERR_InvalidRedValueForRGBColor + original + "\"" ) ; IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERROR_PARSING_COLOR , e ) ; } try { rgb . green = Integer . parseInt ( rgbs [ 1 ] . trim ( ) ) ; } catch ( NumberFormatException e ) { sendError ( Messages . ColorizerReader_ERR_InvalidGreenValueForRGBColor + original + "\"" ) ; IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERROR_PARSING_COLOR , e ) ; } try { rgb . blue = Integer . parseInt ( rgbs [ 2 ] . trim ( ) ) ; } catch ( NumberFormatException e ) { sendError ( Messages . ColorizerReader_ERR_InvalidBlueValueForRGBColor + original + "\"" ) ; IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERROR_PARSING_COLOR , e ) ; } } } else if ( value . startsWith ( "COLOR" ) ) { Class < ? > c = SWT . class ; Field f = c . getField ( value ) ; final int result = f . getInt ( c ) ; final Display display = Display . getDefault ( ) ; if ( display != null ) { class ColorResult { Color color = null ; } final ColorResult colorResult = new ColorResult ( ) ; display . syncExec ( new Runnable ( ) { public void run ( ) { colorResult . color = display . getSystemColor ( result ) ; } } ) ; if ( colorResult . color != null ) { rgb = colorResult . color . getRGB ( ) ; } } } else { sendError ( Messages . ColorizerReader_ERR_InvalidRGBValue + original + "\"" ) ; } } catch ( Exception e ) { sendError ( Messages . ColorizerReader_ERR_InvalidRGBValue + original + Messages . ColorizerReader_ERR_InvalidRGBValueSuffix ) ; } return rgb ; } private void groupTokens ( ITokenList tokenList ) { categoriesToToken = new HashMap < String , Map < String , IToken > > ( ) ; if ( tokenList == null ) { return ; } for ( int i = 0 ; i < tokenList . size ( ) ; i ++ ) { IToken curr = tokenList . get ( i ) ; Map < String , IToken > types = null ; if ( categoriesToToken . containsKey ( curr . getCategory ( ) ) ) { types = categoriesToToken . get ( curr . getCategory ( ) ) ; } else { types = new HashMap < String , IToken > ( ) ; categoriesToToken . put ( curr . getCategory ( ) , types ) ; ColorizationStyle originalColorStyle = new ColorizationStyle ( ) ; originalColorStyle . setForegroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( new RGB ( 0 , 0 , 0 ) ) ) ; originalColorStyle . setName ( curr . getCategory ( ) ) ; CategoryColorizer catColorizer = new CategoryColorizer ( ) ; catColorizer . setName ( curr . getCategory ( ) ) ; catColorizer . setStyle ( originalColorStyle ) ; colorizer . addCategoryColorizer ( catColorizer ) ; } types . put ( curr . getType ( ) , curr ) ; } } private IToken getToken ( String category , String type ) { if ( categoriesToToken . containsKey ( category ) ) { Map < String , IToken > tokens = categoriesToToken . get ( category ) ; if ( tokens . containsKey ( type ) ) { return tokens . get ( type ) ; } } return null ; } private boolean containsCategory ( String category ) { return categoriesToToken . containsKey ( category ) ; } private void styleToken ( LanguageColorizer lc , IToken token , String style ) { if ( styles . containsKey ( style ) ) { ColorizationStyle originalColorStyle = styles . get ( style ) ; ColorizationStyle newColorStyle = new ColorizationStyle ( originalColorStyle ) ; newColorStyle . setName ( token . getCategory ( ) + "_" + token . getType ( ) ) ; TokenColorizer tc = lc . getTokenColorizer ( token ) ; if ( tc == null ) { tc = new TokenColorizer ( ) ; tc . setToken ( token ) ; lc . addTokenColorizer ( tc ) ; } tc . setBaseColorization ( newColorStyle ) ; } else { TokenColorizer tc = new TokenColorizer ( ) ; tc . setToken ( token ) ; ColorizationStyle newColorStyle = new ColorizationStyle ( ) ; newColorStyle . setName ( token . getCategory ( ) + "_" + token . getType ( ) ) ; newColorStyle . setForegroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( new RGB ( 0 , 0 , 0 ) ) ) ; tc . setBaseColorization ( newColorStyle ) ; lc . addTokenColorizer ( tc ) ; waitingElements . put ( token , style ) ; } } private void styleCategory ( LanguageColorizer lc , String category , String style ) { if ( styles . containsKey ( style ) ) { ColorizationStyle originalColorStyle = styles . get ( style ) ; ColorizationStyle newColorStyle = new ColorizationStyle ( originalColorStyle ) ; newColorStyle . setName ( category ) ; CategoryColorizer catColorizer = new CategoryColorizer ( ) ; catColorizer . setName ( category ) ; catColorizer . setStyle ( newColorStyle ) ; lc . addCategoryColorizer ( catColorizer ) ; } else { waitingElements . put ( category , style ) ; } } private void styleRegion ( LanguageColorizer lc , IToken token , Region region , String style ) { if ( styles . containsKey ( style ) ) { ColorizationStyle originalColorStyle = styles . get ( style ) ; ColorizationStyle newColorStyle = new ColorizationStyle ( originalColorStyle ) ; newColorStyle . setName ( token . getCategory ( ) + "_" + token . getType ( ) + "_" + region . getName ( ) ) ; region . setStyle ( newColorStyle ) ; TokenColorizer tc = lc . getTokenColorizer ( token ) ; tc . addColorization ( region ) ; } else { waitingElements . put ( region , style ) ; } } public void enterColorizer ( String ns , String name , String qname , Attributes attributes ) { styles . clear ( ) ; waitingElements . clear ( ) ; regionsToToken . clear ( ) ; categoriesToToken . clear ( ) ; mimeType = attributes . getValue ( ColorizationConstants . LANGUAGE_ATTR ) ; colorizer = new LanguageColorizer ( mimeType ) ; for ( int i = 0 ; i < handlers . size ( ) ; i ++ ) { IColorizerHandler handler = handlers . get ( i ) ; if ( handler != null && mimeType . equals ( handler . getLanguage ( ) ) ) { colorizer . addHandler ( handler ) ; } } groupTokens ( getDefaultTokenList ( ) ) ; String backgroundColor = attributes . getValue ( ColorizationConstants . BACKGROUND_ATTR ) ; String selectionFgColor = attributes . getValue ( ColorizationConstants . SELECTIONFOREGROUND_ATTR ) ; String selectionBgColor = attributes . getValue ( ColorizationConstants . SELECTIONBACKGROUND_ATTR ) ; String caretColor = attributes . getValue ( ColorizationConstants . CARETCOLOR_ATTR ) ; String lineHighlightColor = attributes . getValue ( ColorizationConstants . LINEHIGHLIGHT_ATTR ) ; String foldingBgColor = attributes . getValue ( ColorizationConstants . FOLDING_BACKGROUND_ATTR ) ; String foldingFgColor = attributes . getValue ( ColorizationConstants . FOLDING_FOREGROUND_ATTR ) ; if ( backgroundColor != null && selectionFgColor != null && selectionBgColor != null && caretColor != null && lineHighlightColor != null ) { RGB bgColor = parseRGB ( backgroundColor ) ; colorizer . setBackground ( UnifiedColorManager . getInstance ( ) . getColor ( bgColor ) ) ; RGB selectionFg = parseRGB ( selectionFgColor ) ; colorizer . setSelectionForeground ( UnifiedColorManager . getInstance ( ) . getColor ( selectionFg ) ) ; RGB selectionBg = parseRGB ( selectionBgColor ) ; colorizer . setSelectionBackground ( UnifiedColorManager . getInstance ( ) . getColor ( selectionBg ) ) ; RGB cColor = parseRGB ( caretColor ) ; colorizer . setCaretColor ( UnifiedColorManager . getInstance ( ) . getColor ( cColor ) ) ; RGB lineColor = parseRGB ( lineHighlightColor ) ; colorizer . setLineHighlightColor ( UnifiedColorManager . getInstance ( ) . getColor ( lineColor ) ) ; if ( foldingBgColor != null && foldingFgColor != null ) { RGB foldingFg = parseRGB ( foldingFgColor ) ; colorizer . setFoldingFg ( UnifiedColorManager . getInstance ( ) . getColor ( foldingFg ) ) ; RGB foldingBg = parseRGB ( foldingBgColor ) ; colorizer . setFoldingBg ( UnifiedColorManager . getInstance ( ) . getColor ( foldingBg ) ) ; } } } public void exitColorizer ( String ns , String name , String qname ) { styles . clear ( ) ; if ( waitingElements . isEmpty ( ) && registerColorizer ) { LanguageRegistry . registerLanguageColorizer ( mimeType , colorizer ) ; } waitingElements . clear ( ) ; regionsToToken . clear ( ) ; categoriesToToken . clear ( ) ; } public void enterCategory ( String ns , String name , String qname , Attributes attributes ) { currentCategory = attributes . getValue ( ColorizationConstants . NAME_ATTR ) ; String style = attributes . getValue ( ColorizationConstants . STYLE_ATTR ) ; if ( containsCategory ( currentCategory ) ) { styleCategory ( colorizer , currentCategory , style ) ; } else { currentCategory = null ; } } public void exitCategory ( String ns , String name , String qname ) { currentCategory = null ; } public void enterToken ( String ns , String name , String qname , Attributes attributes ) { String type = attributes . getValue ( ColorizationConstants . TYPE_ATTR ) ; String category = currentCategory == null ? attributes . getValue ( ColorizationConstants . CATEGORY_ATTR ) : currentCategory ; if ( category != null ) { String style = attributes . getValue ( ColorizationConstants . STYLE_ATTR ) ; IToken token = getToken ( category , type ) ; if ( token != null ) { currentToken = token ; styleToken ( colorizer , token , style ) ; } } } public void exitToken ( String ns , String name , String qname ) { currentToken = null ; } public void enterStyle ( String ns , String name , String qname , Attributes attributes ) { ColorizationStyle style = new ColorizationStyle ( ) ; String id = attributes . getValue ( ColorizationConstants . ID_ATTR ) ; String fg = attributes . getValue ( ColorizationConstants . FOREGROUND_ATTR ) ; String bg = attributes . getValue ( ColorizationConstants . BACKGROUND_ATTR ) ; String bold = attributes . getValue ( ColorizationConstants . FONTWEIGHT_ATTR ) ; String italic = attributes . getValue ( ColorizationConstants . FONTSTYLE_ATTR ) ; String ul = attributes . getValue ( ColorizationConstants . TEXTDECORATION_ATTR ) ; if ( styles . containsKey ( id ) ) { sendWarning ( Messages . ColorizerReader_WRN_IgnoringDeclarationOfDuplicateStyle + id + "\"" ) ; return ; } style . setName ( id ) ; RGB rgb = parseRGB ( fg ) ; style . setForegroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( rgb ) ) ; if ( bg != null ) { rgb = parseRGB ( bg ) ; style . setBackgroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( rgb ) ) ; } if ( "bold" . equalsIgnoreCase ( bold ) ) { style . setBold ( true ) ; } if ( "italic" . equalsIgnoreCase ( italic ) ) { style . setItalic ( true ) ; } if ( "underline" . equalsIgnoreCase ( ul ) ) { style . setUnderline ( true ) ; } styles . put ( id , style ) ; if ( waitingElements . containsValue ( id ) ) { Iterator < Object > waitingList = waitingElements . keySet ( ) . iterator ( ) ; while ( waitingList . hasNext ( ) ) { Object curr = waitingList . next ( ) ; if ( id . equals ( waitingElements . get ( curr ) ) ) { if ( curr instanceof IToken ) { waitingList . remove ( ) ; styleToken ( colorizer , ( IToken ) curr , id ) ; } else if ( curr instanceof String ) { waitingList . remove ( ) ; styleCategory ( colorizer , ( String ) curr , id ) ; } else if ( curr instanceof Region ) { waitingList . remove ( ) ; IToken token = regionsToToken . get ( curr ) ; styleRegion ( colorizer , token , ( Region ) curr , id ) ; } } } } } public void enterRegion ( String ns , String name , String qname , Attributes attributes ) { String style = attributes . getValue ( ColorizationConstants . STYLE_ATTR ) ; String offset = attributes . getValue ( ColorizationConstants . OFFSET_ATTR ) . trim ( ) ; String length = attributes . getValue ( ColorizationConstants . LENGTH_ATTR ) . trim ( ) ; String id = attributes . getValue ( ColorizationConstants . NAME_ATTR ) ; int offsetInt ; int lengthInt ; boolean offsetRelative = false ; boolean lengthRelative = false ; if ( currentToken != null ) { try { if ( offset . startsWith ( ColorizationConstants . LENGTH_KEYWORD ) ) { offsetInt = Integer . parseInt ( offset . substring ( ColorizationConstants . LENGTH_KEYWORD . length ( ) , offset . length ( ) ) ) ; offsetRelative = true ; } else { offsetInt = Integer . parseInt ( offset ) ; } } catch ( NumberFormatException e ) { this . sendError ( Messages . ColorizerReader_ERR_NFEInLengthRegion + id ) ; return ; } try { if ( length . startsWith ( ColorizationConstants . LENGTH_KEYWORD ) ) { lengthInt = Integer . parseInt ( length . substring ( ColorizationConstants . LENGTH_KEYWORD . length ( ) , length . length ( ) ) ) ; lengthRelative = true ; } else { lengthInt = Integer . parseInt ( length ) ; } Region region = new Region ( offsetInt , offsetRelative , lengthInt , lengthRelative , null ) ; region . setLengthString ( length ) ; region . setOffsetString ( offset ) ; region . setName ( id ) ; regionsToToken . put ( region , currentToken ) ; styleRegion ( colorizer , currentToken , region , style ) ; } catch ( NumberFormatException e ) { this . sendError ( Messages . ColorizerReader_ERR_NFEInOffsetRegion + id ) ; return ; } } } public void exitRegion ( String ns , String name , String qname ) { } public void characters ( char [ ] buffer , int offset , int length ) { } public void restoreDefault ( String language ) { URL url = urls . get ( language ) ; String id = ids . get ( language ) ; if ( url != null && id != null ) { loadColorizationFromURL ( url , id , true ) ; } } public void setPreferenceId ( String language , String preferenceId ) { ids . put ( language , preferenceId ) ; } public InstanceCreator getInstanceCreator ( String language ) { return instanceCreators . get ( language ) ; } protected Schema createSchema ( ) { InputStream schemaStream = ColorizerReader . class . getResourceAsStream ( SCHEMA ) ; try { Schema schema = SchemaBuilder . fromXML ( schemaStream , this ) ; return schema ; } catch ( SchemaInitializationException e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . ColorizerReader_ERROR_LOADING_SCHEMA ) ; } finally { try { schemaStream . close ( ) ; } catch ( IOException e ) { } } return null ; } private ITokenList getDefaultTokenList ( ) { if ( defaultTokenList != null ) { return defaultTokenList ; } return LanguageRegistry . getTokenList ( mimeType ) ; } } 