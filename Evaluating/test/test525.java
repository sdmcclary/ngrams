<<<<<<< HEAD
public class ProxyServer implements Runnable { ServerAuthenticator auth ; ProxyMessage msg = null ; Socket sock = null , remote_sock = null ; ServerSocket ss = null ; UDPRelayServer relayServer = null ; InputStream in , remote_in ; OutputStream out , remote_out ; int mode ; static final int START_MODE = 0 ; static final int ACCEPT_MODE = 1 ; static final int PIPE_MODE = 2 ; static final int ABORT_MODE = 3 ; static final int BUF_SIZE = 8192 ; Thread pipe_thread1 , pipe_thread2 ; long lastReadTime ; static int iddleTimeout = 180000 ; static int acceptTimeout = 180000 ; static PrintStream log = null ; static Proxy proxy ; public ProxyServer ( ServerAuthenticator auth ) { this . auth = auth ; } ProxyServer ( ServerAuthenticator auth , Socket s ) { this . auth = auth ; this . sock = s ; mode = START_MODE ; } public static void setLog ( OutputStream out ) { if ( out == null ) { log = null ; } else { log = new PrintStream ( out , true ) ; } UDPRelayServer . log = log ; } public static void setProxy ( Proxy p ) { proxy = p ; UDPRelayServer . proxy = proxy ; } public static Proxy getProxy ( ) { return proxy ; } public static void setIddleTimeout ( int timeout ) { iddleTimeout = timeout ; } public static void setAcceptTimeout ( int timeout ) { acceptTimeout = timeout ; } public static void setUDPTimeout ( int timeout ) { UDPRelayServer . setTimeout ( timeout ) ; } public static void setDatagramSize ( int size ) { UDPRelayServer . setDatagramSize ( size ) ; } public void start ( int port ) { start ( port , 5 , null ) ; } public void start ( int port , int backlog , InetAddress localIP ) { try { ss = new ServerSocket ( port , backlog , localIP ) ; log ( "Starting SOCKS Proxy on:" + ss . getInetAddress ( ) . getHostAddress ( ) + ":" + ss . getLocalPort ( ) ) ; while ( true ) { Socket s = ss . accept ( ) ; log ( "Accepted from:" + s . getInetAddress ( ) . getHostName ( ) + ":" + s . getPort ( ) ) ; ProxyServer ps = new ProxyServer ( auth , s ) ; ( new Thread ( ps ) ) . start ( ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { } } public void stop ( ) { try { if ( ss != null ) ss . close ( ) ; } catch ( IOException ioe ) { } } public void run ( ) { switch ( mode ) { case START_MODE : try { startSession ( ) ; } catch ( IOException ioe ) { handleException ( ioe ) ; } finally { abort ( ) ; if ( auth != null ) auth . endSession ( ) ; log ( "Main thread(client->remote)stopped." ) ; } break ; case ACCEPT_MODE : try { doAccept ( ) ; mode = PIPE_MODE ; pipe_thread1 . interrupt ( ) ; pipe ( remote_in , out ) ; } catch ( IOException ioe ) { handleException ( ioe ) ; } finally { abort ( ) ; log ( "Accept thread(remote->client) stopped" ) ; } break ; case PIPE_MODE : try { pipe ( remote_in , out ) ; } catch ( IOException ioe ) { } finally { abort ( ) ; log ( "Support thread(remote->client) stopped" ) ; } break ; case ABORT_MODE : break ; default : log ( "Unexpected MODE " + mode ) ; } } private void startSession ( ) throws IOException { sock . setSoTimeout ( iddleTimeout ) ; try { auth = auth . startSession ( sock ) ; } catch ( IOException ioe ) { log ( "Auth throwed exception:" + ioe ) ; auth = null ; return ; } if ( auth == null ) { log ( "Authentication failed" ) ; return ; } in = auth . getInputStream ( ) ; out = auth . getOutputStream ( ) ; msg = readMsg ( in ) ; handleRequest ( msg ) ; } private void handleRequest ( ProxyMessage msg ) throws IOException { if ( ! auth . checkRequest ( msg ) ) throw new SocksException ( Proxy . SOCKS_FAILURE ) ; if ( msg . ip == null ) { if ( msg instanceof Socks5Message ) { msg . ip = InetAddress . getByName ( msg . host ) ; } else throw new SocksException ( Proxy . SOCKS_FAILURE ) ; } log ( msg ) ; switch ( msg . command ) { case Proxy . SOCKS_CMD_CONNECT : onConnect ( msg ) ; break ; case Proxy . SOCKS_CMD_BIND : onBind ( msg ) ; break ; case Proxy . SOCKS_CMD_UDP_ASSOCIATE : onUDP ( msg ) ; break ; default : throw new SocksException ( Proxy . SOCKS_CMD_NOT_SUPPORTED ) ; } } private void handleException ( IOException ioe ) { if ( msg == null ) return ; if ( mode == ABORT_MODE ) return ; if ( mode == PIPE_MODE ) return ; int error_code = Proxy . SOCKS_FAILURE ; if ( ioe instanceof SocksException ) error_code = ( ( SocksException ) ioe ) . errCode ; else if ( ioe instanceof NoRouteToHostException ) error_code = Proxy . SOCKS_HOST_UNREACHABLE ; else if ( ioe instanceof ConnectException ) error_code = Proxy . SOCKS_CONNECTION_REFUSED ; else if ( ioe instanceof InterruptedIOException ) error_code = Proxy . SOCKS_TTL_EXPIRE ; if ( error_code > Proxy . SOCKS_ADDR_NOT_SUPPORTED || error_code < 0 ) { error_code = Proxy . SOCKS_FAILURE ; } sendErrorMessage ( error_code ) ; } private void onConnect ( ProxyMessage msg ) throws IOException { Socket s ; ProxyMessage response = null ; if ( proxy == null ) s = new Socket ( msg . ip , msg . port ) ; else s = new SocksSocket ( proxy , msg . ip , msg . port ) ; log ( "Connected to " + s . getInetAddress ( ) + ":" + s . getPort ( ) ) ; if ( msg instanceof Socks5Message ) { response = new Socks5Message ( Proxy . SOCKS_SUCCESS , s . getLocalAddress ( ) , s . getLocalPort ( ) ) ; } else { response = new Socks4Message ( Socks4Message . REPLY_OK , s . getLocalAddress ( ) , s . getLocalPort ( ) ) ; } response . write ( out ) ; startPipe ( s ) ; } private void onBind ( ProxyMessage msg ) throws IOException { ProxyMessage response = null ; if ( proxy == null ) ss = new ServerSocket ( 0 ) ; else ss = new SocksServerSocket ( proxy , msg . ip , msg . port ) ; ss . setSoTimeout ( acceptTimeout ) ; log ( "Trying accept on " + ss . getInetAddress ( ) + ":" + ss . getLocalPort ( ) ) ; if ( msg . version == 5 ) response = new Socks5Message ( Proxy . SOCKS_SUCCESS , ss . getInetAddress ( ) , ss . getLocalPort ( ) ) ; else response = new Socks4Message ( Socks4Message . REPLY_OK , ss . getInetAddress ( ) , ss . getLocalPort ( ) ) ; response . write ( out ) ; mode = ACCEPT_MODE ; pipe_thread1 = Thread . currentThread ( ) ; pipe_thread2 = new Thread ( this ) ; pipe_thread2 . start ( ) ; sock . setSoTimeout ( 0 ) ; int eof = 0 ; try { while ( ( eof = in . read ( ) ) >= 0 ) { if ( mode != ACCEPT_MODE ) { if ( mode != PIPE_MODE ) return ; remote_out . write ( eof ) ; break ; } } } catch ( EOFException eofe ) { return ; } catch ( InterruptedIOException iioe ) { if ( mode != PIPE_MODE ) return ; } finally { } if ( eof < 0 ) return ; pipe ( in , remote_out ) ; } private void onUDP ( ProxyMessage msg ) throws IOException { if ( msg . ip . getHostAddress ( ) . equals ( "0.0.0.0" ) ) msg . ip = sock . getInetAddress ( ) ; log ( "Creating UDP relay server for " + msg . ip + ":" + msg . port ) ; relayServer = new UDPRelayServer ( msg . ip , msg . port , Thread . currentThread ( ) , sock , auth ) ; ProxyMessage response ; response = new Socks5Message ( Proxy . SOCKS_SUCCESS , relayServer . relayIP , relayServer . relayPort ) ; response . write ( out ) ; relayServer . start ( ) ; sock . setSoTimeout ( 0 ) ; try { while ( in . read ( ) >= 0 ) ; } catch ( EOFException eofe ) { } } private void doAccept ( ) throws IOException { Socket s ; long startTime = System . currentTimeMillis ( ) ; while ( true ) { s = ss . accept ( ) ; if ( s . getInetAddress ( ) . equals ( msg . ip ) ) { ss . close ( ) ; break ; } else if ( ss instanceof SocksServerSocket ) { s . close ( ) ; ss . close ( ) ; throw new SocksException ( Proxy . SOCKS_FAILURE ) ; } else { if ( acceptTimeout != 0 ) { int newTimeout = acceptTimeout - ( int ) ( System . currentTimeMillis ( ) - startTime ) ; if ( newTimeout <= 0 ) throw new InterruptedIOException ( "In doAccept()" ) ; ss . setSoTimeout ( newTimeout ) ; } s . close ( ) ; } } remote_sock = s ; remote_in = s . getInputStream ( ) ; remote_out = s . getOutputStream ( ) ; remote_sock . setSoTimeout ( iddleTimeout ) ; log ( "Accepted from " + s . getInetAddress ( ) + ":" + s . getPort ( ) ) ; ProxyMessage response ; if ( msg . version == 5 ) response = new Socks5Message ( Proxy . SOCKS_SUCCESS , s . getInetAddress ( ) , s . getPort ( ) ) ; else response = new Socks4Message ( Socks4Message . REPLY_OK , s . getInetAddress ( ) , s . getPort ( ) ) ; response . write ( out ) ; } private ProxyMessage readMsg ( InputStream in ) throws IOException { PushbackInputStream push_in ; if ( in instanceof PushbackInputStream ) push_in = ( PushbackInputStream ) in ; else push_in = new PushbackInputStream ( in ) ; int version = push_in . read ( ) ; push_in . unread ( version ) ; ProxyMessage msg ; if ( version == 5 ) { msg = new Socks5Message ( push_in , false ) ; } else if ( version == 4 ) { msg = new Socks4Message ( push_in , false ) ; } else { throw new SocksException ( Proxy . SOCKS_FAILURE ) ; } return msg ; } private void startPipe ( Socket s ) { mode = PIPE_MODE ; remote_sock = s ; try { remote_in = s . getInputStream ( ) ; remote_out = s . getOutputStream ( ) ; pipe_thread1 = Thread . currentThread ( ) ; pipe_thread2 = new Thread ( this ) ; pipe_thread2 . start ( ) ; pipe ( in , remote_out ) ; } catch ( IOException ioe ) { } } private void sendErrorMessage ( int error_code ) { ProxyMessage err_msg ; if ( msg instanceof Socks4Message ) err_msg = new Socks4Message ( Socks4Message . REPLY_REJECTED ) ; else err_msg = new Socks5Message ( error_code ) ; try { err_msg . write ( out ) ; } catch ( IOException ioe ) { } } private synchronized void abort ( ) { if ( mode == ABORT_MODE ) return ; mode = ABORT_MODE ; try { log ( "Aborting operation" ) ; if ( remote_sock != null ) remote_sock . close ( ) ; if ( sock != null ) sock . close ( ) ; if ( relayServer != null ) relayServer . stop ( ) ; if ( ss != null ) ss . close ( ) ; if ( pipe_thread1 != null ) pipe_thread1 . interrupt ( ) ; if ( pipe_thread2 != null ) pipe_thread2 . interrupt ( ) ; } catch ( IOException ioe ) { } } static final void log ( String s ) { if ( log != null ) { log . println ( s ) ; log . flush ( ) ; } } static final void log ( ProxyMessage msg ) { log ( "Request version:" + msg . version + "\tCommand: " + command2String ( msg . command ) ) ; log ( "IP:" + msg . ip + "\tPort:" + msg . port + ( msg . version == 4 ? "\tUser:" + msg . user : "" ) ) ; } private void pipe ( InputStream in , OutputStream out ) throws IOException { lastReadTime = System . currentTimeMillis ( ) ; byte [ ] buf = new byte [ BUF_SIZE ] ; int len = 0 ; while ( len >= 0 ) { try { if ( len != 0 ) { out . write ( buf , 0 , len ) ; out . flush ( ) ; } len = in . read ( buf ) ; lastReadTime = System . currentTimeMillis ( ) ; } catch ( InterruptedIOException iioe ) { if ( iddleTimeout == 0 ) return ; long timeSinceRead = System . currentTimeMillis ( ) - lastReadTime ; if ( timeSinceRead >= iddleTimeout - 1000 ) return ; len = 0 ; } } } static final String command_names [ ] = { "CONNECT" , "BIND" , "UDP_ASSOCIATE" } ; static final String command2String ( int cmd ) { if ( cmd > 0 && cmd < 4 ) return command_names [ cmd - 1 ] ; else return "Unknown Command " + cmd ; } } 
=======
public final class DatetimeTz extends AbstractDatetime { public static final DatetimeTz THE_INSTANCE = new DatetimeTz ( ) ; private static final Pattern THE_PATTERN = Pattern . compile ( "^([0-9]{4,})-([0-9]{2})-([0-9]{2})[T ]([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\.[0-9]{1,3})?)?(?:Z|(?:([+-][0-9]{2}):([0-9]{2})))$" ) ; private DatetimeTz ( ) { super ( ) ; } protected final Pattern getPattern ( ) { return THE_PATTERN ; } @ Override public String getName ( ) { return "datetime with timezone" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
