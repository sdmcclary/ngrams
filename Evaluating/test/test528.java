<<<<<<< HEAD
public class ProxyServer implements Runnable { ServerAuthenticator auth ; ProxyMessage msg = null ; Socket sock = null , remote_sock = null ; ServerSocket ss = null ; UDPRelayServer relayServer = null ; InputStream in , remote_in ; OutputStream out , remote_out ; int mode ; static final int START_MODE = 0 ; static final int ACCEPT_MODE = 1 ; static final int PIPE_MODE = 2 ; static final int ABORT_MODE = 3 ; static final int BUF_SIZE = 8192 ; Thread pipe_thread1 , pipe_thread2 ; long lastReadTime ; static int iddleTimeout = 180000 ; static int acceptTimeout = 180000 ; private static final Logger log = Logger . getLogger ( ProxyServer . class . getName ( ) ) ; static SocksProxyBase proxy ; public ProxyServer ( final ServerAuthenticator auth ) { this . auth = auth ; } ProxyServer ( final ServerAuthenticator auth , final Socket s ) { this . auth = auth ; this . sock = s ; this . mode = START_MODE ; } public static void setProxy ( final SocksProxyBase p ) { proxy = p ; UDPRelayServer . proxy = proxy ; } public static SocksProxyBase getProxy ( ) { return proxy ; } public static void setIddleTimeout ( final int timeout ) { iddleTimeout = timeout ; } public static void setAcceptTimeout ( final int timeout ) { acceptTimeout = timeout ; } public static void setUDPTimeout ( final int timeout ) { UDPRelayServer . setTimeout ( timeout ) ; } public static void setDatagramSize ( final int size ) { UDPRelayServer . setDatagramSize ( size ) ; } public void start ( final int port ) { start ( port , 5 , null ) ; } public void start ( final int port , final int backlog , final InetAddress localIP ) { try { ss = new ServerSocket ( port , backlog , localIP ) ; final String address = ss . getInetAddress ( ) . getHostAddress ( ) ; final int localPort = ss . getLocalPort ( ) ; log . info ( "Starting SOCKS Proxy on: " + address + ":" + localPort ) ; while ( true ) { final Socket s = ss . accept ( ) ; final String hostName = s . getInetAddress ( ) . getHostName ( ) ; final int port2 = s . getPort ( ) ; log . info ( "Accepted from: " + hostName + ":" + port2 ) ; final ProxyServer ps = new ProxyServer ( auth , s ) ; ( new Thread ( ps ) ) . start ( ) ; } } catch ( final IOException ioe ) { ioe . printStackTrace ( ) ; } finally { } } public void stop ( ) { try { if ( ss != null ) { ss . close ( ) ; } } catch ( final IOException ioe ) { } } public void run ( ) { switch ( mode ) { case START_MODE : try { startSession ( ) ; } catch ( final IOException ioe ) { handleException ( ioe ) ; } finally { abort ( ) ; if ( auth != null ) { auth . endSession ( ) ; } log . info ( "Main thread(client->remote)stopped." ) ; } break ; case ACCEPT_MODE : try { doAccept ( ) ; mode = PIPE_MODE ; pipe_thread1 . interrupt ( ) ; pipe ( remote_in , out ) ; } catch ( final IOException ioe ) { handleException ( ioe ) ; } finally { abort ( ) ; log . info ( "Accept thread(remote->client) stopped" ) ; } break ; case PIPE_MODE : try { pipe ( remote_in , out ) ; } catch ( final IOException ioe ) { } finally { abort ( ) ; log . info ( "Support thread(remote->client) stopped" ) ; } break ; case ABORT_MODE : break ; default : log . warning ( "Unexpected MODE " + mode ) ; } } private void startSession ( ) throws IOException { sock . setSoTimeout ( iddleTimeout ) ; try { auth = auth . startSession ( sock ) ; } catch ( final IOException ioe ) { log . log ( Level . WARNING , "Auth threw exception:" , ioe ) ; auth = null ; return ; } if ( auth == null ) { log . info ( "Authentication failed" ) ; return ; } in = auth . getInputStream ( ) ; out = auth . getOutputStream ( ) ; msg = readMsg ( in ) ; handleRequest ( msg ) ; } private void handleRequest ( final ProxyMessage msg ) throws IOException { if ( ! auth . checkRequest ( msg ) ) { throw new SocksException ( SocksProxyBase . SOCKS_FAILURE ) ; } if ( msg . ip == null ) { if ( msg instanceof Socks5Message ) { msg . ip = InetAddress . getByName ( msg . host ) ; } else { throw new SocksException ( SocksProxyBase . SOCKS_FAILURE ) ; } } log ( msg ) ; switch ( msg . command ) { case SocksProxyBase . SOCKS_CMD_CONNECT : onConnect ( msg ) ; break ; case SocksProxyBase . SOCKS_CMD_BIND : onBind ( msg ) ; break ; case SocksProxyBase . SOCKS_CMD_UDP_ASSOCIATE : onUDP ( msg ) ; break ; default : throw new SocksException ( SocksProxyBase . SOCKS_CMD_NOT_SUPPORTED ) ; } } private void handleException ( final IOException ioe ) { if ( msg == null ) { return ; } if ( mode == ABORT_MODE ) { return ; } if ( mode == PIPE_MODE ) { return ; } int error_code = SocksProxyBase . SOCKS_FAILURE ; if ( ioe instanceof SocksException ) { error_code = ( ( SocksException ) ioe ) . errCode ; } else if ( ioe instanceof NoRouteToHostException ) { error_code = SocksProxyBase . SOCKS_HOST_UNREACHABLE ; } else if ( ioe instanceof ConnectException ) { error_code = SocksProxyBase . SOCKS_CONNECTION_REFUSED ; } else if ( ioe instanceof InterruptedIOException ) { error_code = SocksProxyBase . SOCKS_TTL_EXPIRE ; } if ( ( error_code > SocksProxyBase . SOCKS_ADDR_NOT_SUPPORTED ) || ( error_code < 0 ) ) { error_code = SocksProxyBase . SOCKS_FAILURE ; } sendErrorMessage ( error_code ) ; } private void onConnect ( final ProxyMessage msg ) throws IOException { Socket s ; if ( proxy == null ) { s = new Socket ( msg . ip , msg . port ) ; } else { s = new SocksSocket ( proxy , msg . ip , msg . port ) ; } log . info ( "Connected to " + s . getInetAddress ( ) + ":" + s . getPort ( ) ) ; final ProxyMessage response ; final InetAddress localAddress = s . getLocalAddress ( ) ; final int localPort = s . getLocalPort ( ) ; if ( msg instanceof Socks5Message ) { final int cmd = SocksProxyBase . SOCKS_SUCCESS ; response = new Socks5Message ( cmd , localAddress , localPort ) ; } else { final int cmd = Socks4Message . REPLY_OK ; response = new Socks4Message ( cmd , localAddress , localPort ) ; } response . write ( out ) ; startPipe ( s ) ; } private void onBind ( final ProxyMessage msg ) throws IOException { final ProxyMessage response ; if ( proxy == null ) { ss = new ServerSocket ( 0 ) ; } else { ss = new SocksServerSocket ( proxy , msg . ip , msg . port ) ; } ss . setSoTimeout ( acceptTimeout ) ; final InetAddress inetAddress = ss . getInetAddress ( ) ; final int localPort = ss . getLocalPort ( ) ; log . info ( "Trying accept on " + inetAddress + ":" + localPort ) ; if ( msg . version == 5 ) { final int cmd = SocksProxyBase . SOCKS_SUCCESS ; response = new Socks5Message ( cmd , inetAddress , localPort ) ; } else { final int cmd = Socks4Message . REPLY_OK ; response = new Socks4Message ( cmd , inetAddress , localPort ) ; } response . write ( out ) ; mode = ACCEPT_MODE ; pipe_thread1 = Thread . currentThread ( ) ; pipe_thread2 = new Thread ( this ) ; pipe_thread2 . start ( ) ; sock . setSoTimeout ( 0 ) ; int eof = 0 ; try { while ( ( eof = in . read ( ) ) >= 0 ) { if ( mode != ACCEPT_MODE ) { if ( mode != PIPE_MODE ) { return ; } remote_out . write ( eof ) ; break ; } } } catch ( final EOFException e ) { log . log ( Level . FINE , "Connection closed while we were trying to accept" , e ) ; return ; } catch ( final InterruptedIOException e ) { log . log ( Level . FINE , "Interrupted by unsucessful accept thread" , e ) ; if ( mode != PIPE_MODE ) { return ; } } finally { } if ( eof < 0 ) { return ; } pipe ( in , remote_out ) ; } private void onUDP ( final ProxyMessage msg ) throws IOException { if ( msg . ip . getHostAddress ( ) . equals ( "0.0.0.0" ) ) { msg . ip = sock . getInetAddress ( ) ; } log . info ( "Creating UDP relay server for " + msg . ip + ":" + msg . port ) ; relayServer = new UDPRelayServer ( msg . ip , msg . port , Thread . currentThread ( ) , sock , auth ) ; ProxyMessage response ; response = new Socks5Message ( SocksProxyBase . SOCKS_SUCCESS , relayServer . relayIP , relayServer . relayPort ) ; response . write ( out ) ; relayServer . start ( ) ; sock . setSoTimeout ( 0 ) ; try { while ( in . read ( ) >= 0 ) { } } catch ( final EOFException eofe ) { } } private void doAccept ( ) throws IOException { Socket s ; final long startTime = System . currentTimeMillis ( ) ; while ( true ) { s = ss . accept ( ) ; if ( s . getInetAddress ( ) . equals ( msg . ip ) ) { ss . close ( ) ; break ; } else if ( ss instanceof SocksServerSocket ) { s . close ( ) ; ss . close ( ) ; throw new SocksException ( SocksProxyBase . SOCKS_FAILURE ) ; } else { if ( acceptTimeout != 0 ) { final long passed = System . currentTimeMillis ( ) - startTime ; final int newTimeout = acceptTimeout - ( int ) passed ; if ( newTimeout <= 0 ) { throw new InterruptedIOException ( "newTimeout <= 0" ) ; } ss . setSoTimeout ( newTimeout ) ; } s . close ( ) ; } } remote_sock = s ; remote_in = s . getInputStream ( ) ; remote_out = s . getOutputStream ( ) ; remote_sock . setSoTimeout ( iddleTimeout ) ; final InetAddress inetAddress = s . getInetAddress ( ) ; final int port = s . getPort ( ) ; log . info ( "Accepted from " + s . getInetAddress ( ) + ":" + port ) ; ProxyMessage response ; if ( msg . version == 5 ) { final int cmd = SocksProxyBase . SOCKS_SUCCESS ; response = new Socks5Message ( cmd , inetAddress , port ) ; } else { final int cmd = Socks4Message . REPLY_OK ; response = new Socks4Message ( cmd , inetAddress , port ) ; } response . write ( out ) ; } private ProxyMessage readMsg ( final InputStream in ) throws IOException { PushbackInputStream push_in ; if ( in instanceof PushbackInputStream ) { push_in = ( PushbackInputStream ) in ; } else { push_in = new PushbackInputStream ( in ) ; } final int version = push_in . read ( ) ; push_in . unread ( version ) ; ProxyMessage msg ; if ( version == 5 ) { msg = new Socks5Message ( push_in , false ) ; } else if ( version == 4 ) { msg = new Socks4Message ( push_in , false ) ; } else { throw new SocksException ( SocksProxyBase . SOCKS_FAILURE ) ; } return msg ; } private void startPipe ( final Socket s ) { mode = PIPE_MODE ; remote_sock = s ; try { remote_in = s . getInputStream ( ) ; remote_out = s . getOutputStream ( ) ; pipe_thread1 = Thread . currentThread ( ) ; pipe_thread2 = new Thread ( this ) ; pipe_thread2 . start ( ) ; pipe ( in , remote_out ) ; } catch ( final IOException ioe ) { } } private void sendErrorMessage ( final int error_code ) { ProxyMessage err_msg ; if ( msg instanceof Socks4Message ) { err_msg = new Socks4Message ( Socks4Message . REPLY_REJECTED ) ; } else { err_msg = new Socks5Message ( error_code ) ; } try { err_msg . write ( out ) ; } catch ( final IOException ioe ) { } } private synchronized void abort ( ) { if ( mode == ABORT_MODE ) { return ; } mode = ABORT_MODE ; try { log . info ( "Aborting operation" ) ; if ( remote_sock != null ) { remote_sock . close ( ) ; } if ( sock != null ) { sock . close ( ) ; } if ( relayServer != null ) { relayServer . stop ( ) ; } if ( ss != null ) { ss . close ( ) ; } if ( pipe_thread1 != null ) { pipe_thread1 . interrupt ( ) ; } if ( pipe_thread2 != null ) { pipe_thread2 . interrupt ( ) ; } } catch ( final IOException ioe ) { } } static void log ( final ProxyMessage msg ) { log . fine ( "Request version: " + msg . version + ", Command: " + command2String ( msg . command ) ) ; final String user = msg . version == 4 ? ", User:" + msg . user : "" ; log . fine ( String . format ( "IP:%s, Port:%d%s" , msg . ip , msg . port , user ) ) ; } private void pipe ( final InputStream in , final OutputStream out ) throws IOException { lastReadTime = System . currentTimeMillis ( ) ; final byte [ ] buf = new byte [ BUF_SIZE ] ; int len = 0 ; while ( len >= 0 ) { try { if ( len != 0 ) { out . write ( buf , 0 , len ) ; out . flush ( ) ; } len = in . read ( buf ) ; lastReadTime = System . currentTimeMillis ( ) ; } catch ( final InterruptedIOException iioe ) { if ( iddleTimeout == 0 ) { return ; } final long timeSinceRead = System . currentTimeMillis ( ) - lastReadTime ; if ( timeSinceRead >= iddleTimeout - 1000 ) { return ; } len = 0 ; } } } static final String [ ] command_names = { "CONNECT" , "BIND" , "UDP_ASSOCIATE" } ; static String command2String ( int cmd ) { if ( ( cmd > 0 ) && ( cmd < 4 ) ) { return command_names [ cmd - 1 ] ; } else { return "Unknown Command " + cmd ; } } } 
=======
public class FloatingPointExponent extends AbstractDatatype { public static final FloatingPointExponent THE_INSTANCE = new FloatingPointExponent ( ) ; private enum State { AT_START , AT_START_MINUS_SEEN , IN_INTEGER_PART_DIGITS_SEEN , DOT_SEEN , E_SEEN , IN_DECIMAL_PART_DIGITS_SEEN , IN_EXPONENT_SIGN_SEEN , IN_EXPONENT_DIGITS_SEEN } private FloatingPointExponent ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { State state = State . AT_START ; for ( int i = 0 ; i < literal . length ( ) ; i ++ ) { char c = literal . charAt ( i ) ; switch ( state ) { case AT_START : if ( c == '-' ) { state = State . AT_START_MINUS_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { state = State . IN_INTEGER_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a minus sign or a digit but saw " , c , " instead." ) ; } case AT_START_MINUS_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_INTEGER_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } case IN_INTEGER_PART_DIGITS_SEEN : if ( c == '.' ) { state = State . DOT_SEEN ; continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a decimal point, “e”, “E” or a digit but saw " , c , " instead." ) ; } case DOT_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_DECIMAL_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit after the decimal point but saw " , c , " instead." ) ; } case IN_DECIMAL_PART_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected “e”, “E” or a digit but saw " , c , " instead." ) ; } case E_SEEN : if ( c == '-' || c == '+' ) { state = State . IN_EXPONENT_SIGN_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a minus sign, a plus sign or a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_SIGN_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } } } switch ( state ) { case IN_INTEGER_PART_DIGITS_SEEN : case IN_DECIMAL_PART_DIGITS_SEEN : case IN_EXPONENT_DIGITS_SEEN : return ; case AT_START : throw newDatatypeException ( "The empty string is not a valid floating point number." ) ; case AT_START_MINUS_SEEN : throw newDatatypeException ( "The minus sign alone is not a valid floating point number." ) ; case DOT_SEEN : throw newDatatypeException ( "A floating point number must not end with the decimal point." ) ; case E_SEEN : throw newDatatypeException ( "A floating point number must not end with the exponent “e”." ) ; case IN_EXPONENT_SIGN_SEEN : throw newDatatypeException ( "A floating point number must not end with only a sign in the exponent." ) ; } } @ Override public String getName ( ) { return "floating point number" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
