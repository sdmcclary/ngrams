<<<<<<< HEAD
public class SpaceGraphContentProvider implements IGraphContentProvider { private static final boolean DEBUG_CONTENT_PROVIDER = false ; private GraphViewer viewer ; private IEventHandler spaceListener ; private ISpace space ; private List < ILayerProvider > layerProviders = new ArrayList < ILayerProvider > ( ) ; private Graph graph ; private Map < IEntity , Node > nodeMap ; private IGroupLayerProvider colorLayerProvider ; private IGroupLayerProvider shapeLayerProvider ; static private Schema schema ; static public synchronized Schema getNodeSchema ( ) { if ( schema == null ) { schema = new Schema ( ) ; schema . addColumn ( "entity" , IEntity . class , null ) ; schema . addColumn ( "type" , String . class , null ) ; schema . addColumn ( "realm" , Long . class , null ) ; schema . addColumn ( "color" , String . class , null ) ; schema . addColumn ( "shape" , String . class , null ) ; schema . addColumn ( "aggregate" , String . class , null ) ; } return schema ; } public Graph getGraph ( ) { return graph ; } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { if ( ! validInputChange ( viewer , newInput ) ) { return ; } if ( DEBUG_CONTENT_PROVIDER ) { debug ( "inputChanged old = " + oldInput + " new = " + newInput ) ; } this . space = ( ISpace ) newInput ; this . viewer = ( GraphViewer ) viewer ; initializeGraph ( ) ; this . spaceListener = createSpaceListener ( ) ; this . space . addChangeListenerAndPopulate ( spaceListener ) ; } private void initializeGraph ( ) { nodeMap = new HashMap < IEntity , Node > ( ) ; graph = new Graph ( true ) ; graph . getNodeTable ( ) . addColumns ( getNodeSchema ( ) ) ; } private void updateGraph ( ) { for ( IEntity entity : space . getEntities ( ) ) try { addEntity ( entity ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } public void dispose ( ) { space . removeChangeListener ( spaceListener ) ; } private void debug ( String message ) { System . err . println ( "SpaceGraphContentProvider : " + message ) ; } private boolean validInputChange ( Viewer viewer , Object newInput ) { return ( viewer instanceof GraphViewer ) && ( newInput instanceof ISpace ) ; } private IEventHandler createSpaceListener ( ) { return new IEventHandler ( ) { public void handleEvent ( IEvent event ) { if ( event instanceof ISpaceContentChangeEvent ) { handleSpaceChange ( ( ISpaceContentChangeEvent ) event ) ; } } } ; } private synchronized void handleSpaceChange ( final ISpaceContentChangeEvent event ) { try { if ( event . isCreationEvent ( ) ) { addEntity ( event . getEntity ( ) ) ; } else if ( event . isUpdateEvent ( ) ) { addEntity ( event . getEntity ( ) ) ; } else if ( event . isRemovalEvent ( ) ) { removeEntity ( event . getEntity ( ) ) ; } } catch ( Throwable e ) { e . printStackTrace ( ) ; } } private void addEntity ( final IEntity entity ) { for ( ILayerProvider layerProvider : layerProviders ) { if ( layerProvider instanceof IEdgeLayerProvider ) { IEdgeLayerProvider edgeLayerProvider = ( IEdgeLayerProvider ) layerProvider ; for ( IEdge edge : edgeLayerProvider . getEdges ( entity ) ) { addEdge ( edge ) ; viewer . update ( ) ; } } if ( layerProvider instanceof ITreeLayerProvider ) { ITreeLayerProvider treeLayerProvider = ( ITreeLayerProvider ) layerProvider ; for ( final IEntity parent : treeLayerProvider . getParents ( entity ) ) { addEdge ( new IEdge ( ) { public IEntity getSource ( ) { return parent ; } public IEntity getTarget ( ) { return entity ; } } ) ; viewer . update ( ) ; } } if ( layerProvider instanceof IGroupLayerProvider ) { IGroupLayerProvider groupLayerProvider = ( IGroupLayerProvider ) layerProvider ; Node node = null ; for ( String each : groupLayerProvider . getGroups ( entity ) ) { if ( node == null ) node = createNode ( entity ) ; node . set ( "aggregate" , each ) ; break ; } } } Node node = nodeMap . get ( entity ) ; if ( node != null ) { node . set ( "color" , null ) ; if ( colorLayerProvider != null ) { for ( String group : colorLayerProvider . getGroups ( entity ) ) { node . set ( "color" , group ) ; break ; } } node . set ( "shape" , null ) ; if ( shapeLayerProvider != null ) { for ( String group : shapeLayerProvider . getGroups ( entity ) ) { node . set ( "shape" , group ) ; break ; } } } } private void removeEntity ( IEntity entity ) { if ( viewer . getControl ( ) . isDisposed ( ) ) return ; Node node = nodeMap . remove ( entity ) ; if ( node != null ) { graph . removeNode ( node ) ; } viewer . refresh ( ) ; } private void addEdge ( final IEdge edge ) { Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { Node srcNode = createNode ( edge . getSource ( ) ) ; Node dstNode = createNode ( edge . getTarget ( ) ) ; Edge edge = graph . addEdge ( srcNode , dstNode ) ; } } ) ; } private void removeEdge ( final IEntity src , final IEntity dst ) { Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { graph . removeEdge ( graph . getEdge ( nodeMap . get ( src ) , nodeMap . get ( dst ) ) ) ; } } ) ; } private Node createNode ( IEntity entity ) { Node node = nodeMap . get ( entity ) ; if ( node == null ) { node = graph . addNode ( ) ; node . set ( "entity" , entity ) ; node . set ( "type" , entity . getTypeName ( ) ) ; node . set ( "realm" , entity . getRealmId ( ) ) ; nodeMap . put ( entity , node ) ; } return node ; } public List < ILayerProvider > getLayers ( ) { return layerProviders ; } public void addLayer ( ILayerProvider layerProvider ) { layerProviders . add ( layerProvider ) ; updateGraph ( ) ; viewer . update ( ) ; } public void removeLayer ( ILayerProvider layerProvider ) { layerProviders . remove ( layerProvider ) ; initializeGraph ( ) ; updateGraph ( ) ; viewer . refresh ( ) ; } public IGroupLayerProvider getColorLayer ( ) { return colorLayerProvider ; } public void setColorLayer ( IGroupLayerProvider layerProvider ) { colorLayerProvider = layerProvider ; if ( layerProvider == null ) initializeGraph ( ) ; updateGraph ( ) ; viewer . update ( ) ; } public IGroupLayerProvider getShapeLayer ( ) { return shapeLayerProvider ; } public void setShapeLayer ( IGroupLayerProvider layerProvider ) { shapeLayerProvider = layerProvider ; if ( layerProvider == null ) initializeGraph ( ) ; updateGraph ( ) ; viewer . update ( ) ; } } 
=======
class ModeUsage { private final Mode mode ; private final Mode currentMode ; private ContextMap modeMap ; private int attributeProcessing = - 1 ; ModeUsage ( Mode mode , Mode currentMode ) { this ( mode , currentMode , null ) ; } private ModeUsage ( Mode mode , Mode currentMode , ContextMap modeMap ) { this . mode = mode ; this . currentMode = currentMode ; this . modeMap = modeMap ; } ModeUsage changeCurrentMode ( Mode currentMode ) { return new ModeUsage ( mode , currentMode , modeMap ) ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof ModeUsage ) ) return false ; ModeUsage other = ( ModeUsage ) obj ; return this . mode == other . mode && this . currentMode == other . currentMode && Equal . equal ( this . modeMap , other . modeMap ) ; } public int hashCode ( ) { int hc = mode . hashCode ( ) ^ currentMode . hashCode ( ) ; if ( modeMap != null ) hc ^= modeMap . hashCode ( ) ; return hc ; } private Mode resolve ( Mode mode ) { if ( mode == Mode . CURRENT ) { return currentMode ; } if ( mode . isAnonymous ( ) && ! mode . isDefined ( ) ) { return currentMode ; } return mode ; } int getAttributeProcessing ( ) { if ( attributeProcessing == - 1 ) { attributeProcessing = resolve ( mode ) . getAttributeProcessing ( ) ; if ( modeMap != null ) { for ( Enumeration e = modeMap . values ( ) ; e . hasMoreElements ( ) && attributeProcessing != Mode . ATTRIBUTE_PROCESSING_FULL ; ) attributeProcessing = Math . max ( resolve ( ( Mode ) e . nextElement ( ) ) . getAttributeProcessing ( ) , attributeProcessing ) ; } } return attributeProcessing ; } boolean isContextDependent ( ) { return modeMap != null ; } Mode getMode ( Vector context ) { if ( modeMap != null ) { Mode m = ( Mode ) modeMap . get ( context ) ; if ( m != null ) return resolve ( m ) ; } return resolve ( mode ) ; } boolean addContext ( boolean isRoot , Vector names , Mode mode ) { if ( modeMap == null ) modeMap = new ContextMap ( ) ; return modeMap . put ( isRoot , names , mode ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
