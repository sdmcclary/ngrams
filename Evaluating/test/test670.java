<<<<<<< HEAD
public class LexemeList { private static final Lexeme [ ] NO_LEXEMES = new Lexeme [ 0 ] ; private transient Lexeme [ ] _lexemes ; private int _size ; private Range _affectedRegion ; public LexemeList ( ) { this . _lexemes = new Lexeme [ 128 ] ; this . _affectedRegion = new Range ( ) ; } public LexemeList ( Lexeme [ ] lexemes ) { this . setContents ( lexemes ) ; } private void add ( int index , Lexeme lexeme ) { int currentLength = this . _lexemes . length ; int size = this . _size + 1 ; if ( size > currentLength ) { int newLength = ( currentLength * 3 ) / 2 + 1 ; Lexeme [ ] newList = new Lexeme [ newLength ] ; System . arraycopy ( this . _lexemes , 0 , newList , 0 , this . _size ) ; this . _lexemes = newList ; } System . arraycopy ( this . _lexemes , index , this . _lexemes , index + 1 , this . _size - index ) ; this . _lexemes [ index ] = lexeme ; this . _size ++ ; } synchronized public void add ( Lexeme lexeme ) { if ( lexeme == null || lexeme . offset < 0 ) { throw new IllegalArgumentException ( Messages . LexemeList_Lexeme_Must_Be_Defined ) ; } int lexemeIndex = this . getLexemeIndex ( lexeme . offset ) ; if ( lexemeIndex < 0 ) { int insertIndex = - ( lexemeIndex + 1 ) ; this . add ( insertIndex , lexeme ) ; this . _affectedRegion . includeInRange ( lexeme ) ; int followingIndex = insertIndex + 1 ; while ( followingIndex < this . _size ) { if ( this . _lexemes [ followingIndex ] . isOverlapping ( lexeme ) ) { this . _affectedRegion . includeInRange ( this . _lexemes [ followingIndex ] ) ; this . remove ( followingIndex ) ; } else { break ; } } } } synchronized public void clear ( ) { for ( int i = 0 ; i < this . _size ; i ++ ) { this . _lexemes [ i ] = null ; } this . _size = 0 ; this . _affectedRegion . clear ( ) ; } synchronized public Lexeme [ ] cloneRange ( int startingIndex , int endingIndex ) { Lexeme [ ] result = NO_LEXEMES ; if ( 0 <= startingIndex && startingIndex < this . _size && 0 <= endingIndex && endingIndex < this . _size && startingIndex <= endingIndex ) { int size = endingIndex - startingIndex + 1 ; result = new Lexeme [ size ] ; for ( int i = startingIndex ; i <= endingIndex ; i ++ ) { Lexeme lexeme = this . _lexemes [ i ] ; try { result [ i - startingIndex ] = ( Lexeme ) lexeme . clone ( ) ; } catch ( Exception e ) { result [ i - startingIndex ] = lexeme ; } } } return result ; } synchronized public Lexeme [ ] copyRange ( int startingIndex , int endingIndex ) { Lexeme [ ] result = NO_LEXEMES ; if ( 0 <= startingIndex && startingIndex < this . _size && 0 <= endingIndex && endingIndex < this . _size && startingIndex <= endingIndex ) { int size = endingIndex - startingIndex + 1 ; result = new Lexeme [ size ] ; System . arraycopy ( this . _lexemes , startingIndex , result , 0 , size ) ; } return result ; } synchronized public Lexeme get ( int index ) { Lexeme result = null ; if ( 0 <= index && index < this . _size ) { result = this . _lexemes [ index ] ; } return result ; } synchronized public Range getAffectedRegion ( ) { return this . _affectedRegion ; } synchronized public Lexeme getCeilingLexeme ( int offset ) { int index = this . getLexemeCeilingIndex ( offset ) ; Lexeme result = null ; if ( index >= 0 ) { result = this . _lexemes [ index ] ; } return result ; } synchronized public Lexeme getFloorLexeme ( int offset ) { int index = this . getLexemeFloorIndex ( offset ) ; Lexeme result = null ; if ( index >= 0 ) { result = this . _lexemes [ index ] ; } return result ; } synchronized public int getLexemeCeilingIndex ( int offset ) { int length = this . _size ; int result = - 1 ; if ( length > 0 ) { result = this . getLexemeIndex ( offset ) ; if ( result < 0 ) { result = - ( result + 1 ) ; if ( result >= length ) { result = - 1 ; } } } return result ; } synchronized public int getLexemeFloorIndex ( int offset ) { int result = - 1 ; if ( this . _size > 0 ) { result = this . getLexemeIndex ( offset ) ; if ( result < 0 ) { result = - ( result + 1 ) - 1 ; if ( result < 0 ) { result = - 1 ; } } } return result ; } synchronized public Lexeme getLexemeFromOffset ( int offset ) { int index = this . getLexemeIndex ( offset ) ; Lexeme result = null ; if ( 0 <= index && index < this . _size ) { result = this . _lexemes [ index ] ; } return result ; } synchronized public int getLexemeIndex ( int offset ) { int low = 0 ; int high = this . _size - 1 ; while ( low <= high ) { int mid = ( low + high ) > > > 1 ; Lexeme candidate = this . _lexemes [ mid ] ; if ( offset < candidate . offset ) { high = mid - 1 ; } else if ( candidate . offset + candidate . length <= offset ) { low = mid + 1 ; } else { return mid ; } } return - ( low + 1 ) ; } synchronized public int getLexemeIndex ( Lexeme lexeme ) { int result = - 1 ; if ( lexeme != null ) { int candidate = this . getLexemeIndex ( lexeme . offset ) ; if ( candidate >= 0 && this . _lexemes [ candidate ] == lexeme ) { result = candidate ; } } return result ; } synchronized public void remove ( int index ) { if ( 0 <= index && index < this . _size ) { int remainder = this . _size - index - 1 ; if ( remainder > 0 ) { System . arraycopy ( this . _lexemes , index + 1 , this . _lexemes , index , remainder ) ; } this . _size -- ; this . _lexemes [ this . _size ] = null ; } } synchronized public void remove ( int startingIndex , int endingIndex ) { if ( 0 <= startingIndex && startingIndex < this . _size && 0 <= endingIndex && endingIndex < this . _size && startingIndex <= endingIndex ) { for ( int i = startingIndex ; i <= endingIndex ; i ++ ) { this . remove ( startingIndex ) ; } } } synchronized public void remove ( Lexeme lexeme ) { if ( lexeme != null ) { int index = this . getLexemeIndex ( lexeme . offset ) ; if ( index >= 0 && this . _lexemes [ index ] == lexeme ) { this . remove ( index ) ; } } } synchronized public void remove ( Lexeme startingLexeme , Lexeme endingLexeme ) { if ( startingLexeme != null && endingLexeme != null ) { int startingIndex = this . getLexemeIndex ( startingLexeme . offset ) ; int endingIndex = this . getLexemeIndex ( endingLexeme . offset ) ; if ( startingIndex >= 0 && endingIndex >= 0 && startingIndex <= endingIndex && startingLexeme == this . _lexemes [ startingIndex ] && endingLexeme == this . _lexemes [ endingIndex ] ) { for ( int i = startingIndex ; i <= endingIndex ; i ++ ) { this . remove ( startingIndex ) ; } } } } synchronized public void shiftLexemeOffsets ( int startingIndex , int offsetDelta ) { if ( 0 <= startingIndex ) { for ( int i = startingIndex ; i < this . _size ; i ++ ) { this . _lexemes [ i ] . adjustOffset ( offsetDelta ) ; } } } synchronized public int size ( ) { return this . _size ; } synchronized public Lexeme [ ] toArray ( ) { Lexeme [ ] result = NO_LEXEMES ; if ( this . _size > 0 ) { result = this . copyRange ( 0 , this . _size - 1 ) ; } return result ; } synchronized public void setContents ( Lexeme [ ] lexemes ) { if ( lexemes == null ) { throw new IllegalArgumentException ( Messages . LexemeList_Lexeme_Must_Be_Defined ) ; } for ( Lexeme lexeme : lexemes ) { if ( lexeme == null ) { throw new IllegalArgumentException ( Messages . LexemeList_Lexeme_Must_Be_Defined ) ; } } this . _lexemes = lexemes ; this . _size = lexemes . length ; this . _affectedRegion = new Range ( ) ; } } 
=======
public class SoapFault extends IOException { public String faultcode ; public String faultstring ; public String faultactor ; public Node detail ; public void parse ( XmlPullParser parser ) throws IOException , XmlPullParserException { parser . require ( XmlPullParser . START_TAG , SoapEnvelope . ENV , "Fault" ) ; while ( parser . nextTag ( ) == XmlPullParser . START_TAG ) { String name = parser . getName ( ) ; if ( name . equals ( "detail" ) ) { detail = new Node ( ) ; detail . parse ( parser ) ; continue ; } else if ( name . equals ( "faultcode" ) ) faultcode = parser . nextText ( ) ; else if ( name . equals ( "faultstring" ) ) faultstring = parser . nextText ( ) ; else if ( name . equals ( "faultactor" ) ) faultactor = parser . nextText ( ) ; else throw new RuntimeException ( "unexpected tag:" + name ) ; parser . require ( XmlPullParser . END_TAG , null , name ) ; } parser . require ( XmlPullParser . END_TAG , SoapEnvelope . ENV , "Fault" ) ; parser . nextTag ( ) ; } public void write ( XmlSerializer xw ) throws IOException { xw . startTag ( SoapEnvelope . ENV , "Fault" ) ; xw . startTag ( null , "faultcode" ) ; xw . text ( "" + faultcode ) ; xw . endTag ( null , "faultcode" ) ; xw . startTag ( null , "faultstring" ) ; xw . text ( "" + faultstring ) ; xw . endTag ( null , "faultstring" ) ; xw . startTag ( null , "detail" ) ; if ( detail != null ) detail . write ( xw ) ; xw . endTag ( null , "detail" ) ; xw . endTag ( SoapEnvelope . ENV , "Fault" ) ; } @ Override public String getMessage ( ) { return faultstring ; } public String toString ( ) { return "SoapFault - faultcode: '" + faultcode + "' faultstring: '" + faultstring + "' faultactor: '" + faultactor + "' detail: " + detail ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
