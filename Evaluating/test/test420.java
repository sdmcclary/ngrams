<<<<<<< HEAD
public class ClientImpl implements Client { private static final String VERSION = "1.6.0" ; private static final long MAX_PRIORITY = 4294967296L ; private static String DEFAULT_HOST = "localhost" ; private static final int DEFAULT_PORT = 11300 ; private String host ; private int port ; private boolean uniqueConnectionPerThread = true ; private ProtocolHandler aProtocolHandler = null ; private ThreadLocal < ProtocolHandler > tlProtocolHandler = new ThreadLocal < ProtocolHandler > ( ) { @ Override protected ProtocolHandler initialValue ( ) { return new ProtocolHandler ( host , port ) ; } } ; private ProtocolHandler getProtocolHandler ( ) { if ( uniqueConnectionPerThread ) { return tlProtocolHandler . get ( ) ; } else { return aProtocolHandler ; } } public ClientImpl ( ) { this ( DEFAULT_HOST , DEFAULT_PORT ) ; } public ClientImpl ( String host , int port ) { this . host = host ; this . port = port ; aProtocolHandler = new ProtocolHandler ( host , port ) ; } public ClientImpl ( boolean useBlockIO ) { this ( DEFAULT_HOST , DEFAULT_PORT ) ; getProtocolHandler ( ) . setUseBlockIO ( useBlockIO ) ; } public ClientImpl ( String host , int port , boolean useBlockIO ) { this ( host , port ) ; getProtocolHandler ( ) . setUseBlockIO ( useBlockIO ) ; } @ Override public long put ( long priority , int delaySeconds , int timeToRun , byte [ ] data ) { if ( data == null ) { throw new BeanstalkException ( "null data" ) ; } if ( priority > MAX_PRIORITY ) { throw new BeanstalkException ( "invalid priority" ) ; } long jobId = - 1 ; Request request = new Request ( "put " + priority + " " + delaySeconds + " " + timeToRun + " " + data . length , new String [ ] { "INSERTED" , "BURIED" } , new String [ ] { "JOB_TOO_BIG" } , data , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . getStatus ( ) . equals ( "JOB_TOO_BIG" ) ) { BeanstalkException be = new BeanstalkException ( response . getStatus ( ) ) ; throw be ; } if ( response != null && response . isMatchOk ( ) ) { jobId = Long . parseLong ( response . getReponse ( ) ) ; } return jobId ; } @ Override public void useTube ( String tubeName ) { if ( tubeName == null ) { throw new BeanstalkException ( "null tubeName" ) ; } Request request = new Request ( "use " + tubeName , "USING" , null , null , ExpectedResponse . None ) ; getProtocolHandler ( ) . processRequest ( request ) ; } @ Override public Job reserve ( Integer timeoutSeconds ) { Job job = null ; String command = ( timeoutSeconds == null ) ? "reserve" : "reserve-with-timeout " + timeoutSeconds . toString ( ) ; Request request = new Request ( command , new String [ ] { "RESERVED" } , new String [ ] { "DEADLINE_SOON" , "TIMED_OUT" , } , null , ExpectedResponse . ByteArray , 2 ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . getStatus ( ) . equals ( "DEADLINE_SOON" ) ) { BeanstalkException be = new BeanstalkException ( response . getStatus ( ) ) ; throw be ; } if ( response != null && response . isMatchOk ( ) ) { long jobId = Long . parseLong ( response . getReponse ( ) ) ; job = new JobImpl ( jobId ) ; job . setData ( ( byte [ ] ) response . getData ( ) ) ; } return job ; } @ Override public Job reserveJob ( long jobId ) { Job job = null ; Request request = new Request ( "reserve-job " + jobId , new String [ ] { "RESERVED" } , new String [ ] { "NOT_FOUND" , "BAD_FORMAT" } , null , ExpectedResponse . ByteArray ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response == null ) { BeanstalkException be = new BeanstalkException ( "unexpected null response" ) ; throw be ; } if ( response . isMatchError ( ) ) { return null ; } if ( response != null && response . isMatchOk ( ) ) { long newJobId = Long . parseLong ( response . getReponse ( ) ) ; job = new JobImpl ( newJobId ) ; job . setData ( ( byte [ ] ) response . getData ( ) ) ; } return job ; } @ Override public boolean delete ( long jobId ) { Request request = new Request ( "delete " + jobId , "DELETED" , "NOT_FOUND" , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; return response != null && response . isMatchOk ( ) ; } @ Override public boolean release ( long jobId , long priority , int delaySeconds ) { Request request = new Request ( "release " + jobId + " " + priority + " " + delaySeconds , new String [ ] { "RELEASED" } , new String [ ] { "NOT_FOUND" , "BURIED" } , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; return response != null && response . isMatchOk ( ) ; } @ Override public boolean bury ( long jobId , long priority ) { Request request = new Request ( "bury " + jobId + " " + priority , "BURIED" , "NOT_FOUND" , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; return response != null && response . isMatchOk ( ) ; } @ Override public boolean touch ( long jobId ) { Request request = new Request ( "touch " + jobId , "TOUCHED" , "NOT_FOUND" , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; return response != null && response . isMatchOk ( ) ; } @ Override public int watch ( String tubeName ) { if ( tubeName == null ) { throw new BeanstalkException ( "null tubeName" ) ; } Request request = new Request ( "watch " + tubeName , "WATCHING" , null , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; return Integer . parseInt ( response . getReponse ( ) ) ; } @ Override public int ignore ( String tubeName ) { if ( tubeName == null ) { throw new BeanstalkException ( "null tubeName" ) ; } Request request = new Request ( "ignore " + tubeName , new String [ ] { "WATCHING" , "NOT_IGNORED" } , null , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; return ( response . getReponse ( ) == null ) ? - 1 : Integer . parseInt ( response . getReponse ( ) ) ; } @ Override public Job peek ( long jobId ) { Job job = null ; Request request = new Request ( "peek " + jobId , "FOUND" , new String [ ] { "NOT_FOUND" , "BAD_FORMAT" } , null , ExpectedResponse . ByteArray , 2 ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . isMatchOk ( ) ) { jobId = Long . parseLong ( response . getReponse ( ) ) ; job = new JobImpl ( jobId ) ; job . setData ( ( byte [ ] ) response . getData ( ) ) ; } return job ; } @ Override public Job peekBuried ( ) { Job job = null ; Request request = new Request ( "peek-buried" , "FOUND" , "NOT_FOUND" , null , ExpectedResponse . ByteArray , 2 ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . isMatchOk ( ) ) { long jobId = Long . parseLong ( response . getReponse ( ) ) ; job = new JobImpl ( jobId ) ; job . setData ( ( byte [ ] ) response . getData ( ) ) ; } return job ; } @ Override public Job peekDelayed ( ) { Job job = null ; Request request = new Request ( "peek-delayed" , "FOUND" , "NOT_FOUND" , null , ExpectedResponse . ByteArray , 2 ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . isMatchOk ( ) ) { long jobId = Long . parseLong ( response . getReponse ( ) ) ; job = new JobImpl ( jobId ) ; job . setData ( ( byte [ ] ) response . getData ( ) ) ; } return job ; } @ Override public Job peekReady ( ) { Job job = null ; Request request = new Request ( "peek-ready" , "FOUND" , "NOT_FOUND" , null , ExpectedResponse . ByteArray , 2 ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . isMatchOk ( ) ) { long jobId = Long . parseLong ( response . getReponse ( ) ) ; job = new JobImpl ( jobId ) ; job . setData ( ( byte [ ] ) response . getData ( ) ) ; } return job ; } @ Override public int kick ( int count ) { Request request = new Request ( "kick " + count , "KICKED" , null , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . isMatchOk ( ) ) { count = Integer . parseInt ( response . getReponse ( ) ) ; } return count ; } @ Override public boolean kickJob ( long jobId ) { Request request = new Request ( "kick-job " + jobId , "KICKED" , "NOT_FOUND" , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; return response != null && response . isMatchOk ( ) ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map < String , String > statsJob ( long jobId ) { Request request = new Request ( "stats-job " + jobId , "OK" , "NOT_FOUND" , null , ExpectedResponse . Map ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; Map < String , String > map = null ; if ( response != null && response . isMatchOk ( ) ) { map = ( Map < String , String > ) response . getData ( ) ; } return map ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map < String , String > statsTube ( String tubeName ) { if ( tubeName == null ) { return null ; } Request request = new Request ( "stats-tube " + tubeName , "OK" , "NOT_FOUND" , null , ExpectedResponse . Map ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; Map < String , String > map = null ; if ( response != null && response . isMatchOk ( ) ) { map = ( Map < String , String > ) response . getData ( ) ; } return map ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map < String , String > stats ( ) { Request request = new Request ( "stats" , "OK" , null , null , ExpectedResponse . Map ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; Map < String , String > map = null ; if ( response != null && response . isMatchOk ( ) ) { map = ( Map < String , String > ) response . getData ( ) ; } return map ; } @ Override @ SuppressWarnings ( "unchecked" ) public List < String > listTubes ( ) { Request request = new Request ( "list-tubes" , "OK" , null , null , ExpectedResponse . List ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; List < String > list = null ; if ( response != null && response . isMatchOk ( ) ) { list = ( List < String > ) response . getData ( ) ; } else { list = new ArrayList < String > ( 0 ) ; } return list ; } @ Override public String listTubeUsed ( ) { String tubeName = null ; Request request = new Request ( "list-tube-used" , "USING" , null , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . isMatchOk ( ) ) { tubeName = response . getReponse ( ) ; } return tubeName ; } @ Override @ SuppressWarnings ( "unchecked" ) public List < String > listTubesWatched ( ) { Request request = new Request ( "list-tubes-watched" , "OK" , null , null , ExpectedResponse . List ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; List < String > list = null ; if ( response != null && response . isMatchOk ( ) ) { list = ( List < String > ) response . getData ( ) ; } else { return new ArrayList < String > ( 0 ) ; } return list ; } @ Override public String getClientVersion ( ) { return VERSION ; } @ Override public void close ( ) { getProtocolHandler ( ) . close ( ) ; } @ Override public boolean isUniqueConnectionPerThread ( ) { return uniqueConnectionPerThread ; } @ Override public void setUniqueConnectionPerThread ( boolean uniqueConnectionPerThread ) { this . uniqueConnectionPerThread = uniqueConnectionPerThread ; } @ Override public boolean pauseTube ( String tubeName , int pauseSeconds ) { Request request = new Request ( "pause-tube " + tubeName + " " + pauseSeconds , "PAUSED" , null , null , ExpectedResponse . None ) ; Response response = getProtocolHandler ( ) . processRequest ( request ) ; if ( response != null && response . isMatchOk ( ) ) { return true ; } return false ; } @ Override public String getServerVersion ( ) { Map < String , String > stats = stats ( ) ; if ( stats == null ) { throw new BeanstalkException ( "could not get stats" ) ; } return stats . get ( "version" ) . trim ( ) ; } } 
=======
public class UncheckedSubtreeWarner extends Checker { private boolean alreadyWarnedAboutRdf ; private boolean alreadyWarnedAboutOpenMath ; private boolean alreadyWarnedAboutInkscape ; private boolean alreadyWarnedAboutSvgVersion ; public UncheckedSubtreeWarner ( ) { alreadyWarnedAboutRdf = false ; alreadyWarnedAboutOpenMath = false ; alreadyWarnedAboutInkscape = false ; alreadyWarnedAboutSvgVersion = false ; } @ Override public void startDocument ( ) throws SAXException { alreadyWarnedAboutRdf = false ; alreadyWarnedAboutOpenMath = false ; alreadyWarnedAboutInkscape = false ; alreadyWarnedAboutSvgVersion = false ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { if ( ! alreadyWarnedAboutRdf && "http://www.w3.org/1999/02/22-rdf-syntax-ns#" == uri ) { warn ( "This validator does not validate RDF. RDF subtrees go unchecked." ) ; alreadyWarnedAboutRdf = true ; } if ( ! alreadyWarnedAboutOpenMath && "http://www.openmath.org/OpenMath" == uri ) { warn ( "This validator does not validate OpenMath. OpenMath subtrees go unchecked." ) ; alreadyWarnedAboutOpenMath = true ; } if ( ! alreadyWarnedAboutInkscape && ( ( "http://www.w3.org/2000/svg" == uri && attrsContainInkscape ( atts ) ) || "http://www.inkscape.org/namespaces/inkscape" == uri || "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" == uri ) ) { warn ( "This validator does not validate Inkscape extensions properly. Inkscape-specific errors may go unnoticed." ) ; alreadyWarnedAboutInkscape = true ; } if ( ! alreadyWarnedAboutSvgVersion && "http://www.w3.org/2000/svg" == uri && hasUnsupportedVersion ( atts ) ) { warn ( "Unsupported SVG version specified. This validator only supports SVG 1.1. The recommended way to suppress this warning is to remove the “version” attribute altogether." ) ; alreadyWarnedAboutSvgVersion = true ; } } private boolean hasUnsupportedVersion ( Attributes atts ) { String version = atts . getValue ( "" , "version" ) ; return "1.0" . equals ( version ) || "1.2" . equals ( version ) ; } private boolean attrsContainInkscape ( Attributes atts ) { int length = atts . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { String uri = atts . getURI ( i ) ; if ( "http://www.inkscape.org/namespaces/inkscape" == uri || "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" == uri ) { return true ; } } return false ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
