<<<<<<< HEAD
public abstract class Path { protected final static L10N L = new L10N ( Path . class ) ; private static final Integer LOCK = new Integer ( 0 ) ; private static final LruCache < PathKey , Path > _pathLookupCache = new LruCache < PathKey , Path > ( 8192 ) ; private static boolean _isTestWindows ; protected static char _separatorChar = File . separatorChar ; protected static char _pathSeparatorChar = File . pathSeparatorChar ; private static String _newline ; private static final AtomicReference < PathKey > _key = new AtomicReference < PathKey > ( ) ; private static final SchemeMap DEFAULT_SCHEME_MAP = new SchemeMap ( ) ; private static SchemeMap _defaultSchemeMap ; protected SchemeMap _schemeMap = _defaultSchemeMap ; protected Path ( Path root ) { if ( root != null ) _schemeMap = root . _schemeMap ; else if ( _defaultSchemeMap != null ) _schemeMap = _defaultSchemeMap ; else _schemeMap = DEFAULT_SCHEME_MAP ; } public final Path lookup ( String name ) { return lookup ( name , null ) ; } public Path lookup ( String userPath , Map < String , Object > newAttributes ) { if ( newAttributes != null ) return lookupImpl ( userPath , newAttributes ) ; else if ( userPath == null ) return this ; if ( isPathCacheable ( ) ) { PathKey key = _key . getAndSet ( null ) ; if ( key == null ) key = new PathKey ( ) ; key . init ( this , userPath ) ; Path path = _pathLookupCache . get ( key ) ; _key . set ( key ) ; if ( path != null ) { return path . cacheCopy ( ) ; } } Path path = lookupImpl ( userPath , null ) ; if ( _startTime == 0 ) _startTime = System . currentTimeMillis ( ) ; if ( isPathCacheable ( ) ) { synchronized ( _key ) { Path copy = path . cacheCopy ( ) ; if ( copy != null ) { _pathLookupCache . putIfNew ( new PathKey ( this , userPath ) , copy ) ; } } } return path ; } static long _startTime ; protected boolean isPathCacheable ( ) { return false ; } public Path lookupImpl ( String userPath , Map < String , Object > newAttributes ) { if ( userPath == null ) return lookupImpl ( getPath ( ) , newAttributes ) ; String scheme = scanScheme ( userPath ) ; if ( scheme == null ) return schemeWalk ( userPath , newAttributes , userPath , 0 ) ; Path path ; SchemeMap schemeMap = _schemeMap ; if ( isWindows ( ) ) { int length = scheme . length ( ) ; int ch ; if ( length == 1 && ( 'a' <= ( ch = scheme . charAt ( 0 ) ) && ch <= 'z' || 'A' <= ch && ch <= 'Z' ) ) { if ( _isTestWindows ) return schemeWalk ( userPath , newAttributes , "/" + userPath , 0 ) ; path = schemeMap . get ( "file" ) ; if ( path != null ) return path . schemeWalk ( userPath , newAttributes , "/" + userPath , 0 ) ; else return schemeWalk ( userPath , newAttributes , "/" + userPath , 0 ) ; } } path = schemeMap . get ( scheme ) ; if ( path == null ) return schemeWalk ( userPath , newAttributes , userPath , 0 ) ; return path . schemeWalk ( userPath , newAttributes , userPath , scheme . length ( ) + 1 ) ; } public final Path lookupNative ( String name ) { return lookupNative ( name , null ) ; } public Path lookupNative ( String name , Map < String , Object > attributes ) { return lookup ( name , attributes ) ; } public String lookupRelativeNativePath ( Path path ) { String thisNative = getNativePath ( ) ; String pathNative = path . getNativePath ( ) ; if ( pathNative . startsWith ( thisNative ) ) { int i = thisNative . length ( ) ; while ( i < pathNative . length ( ) ) { if ( pathNative . charAt ( i ) != getFileSeparatorChar ( ) ) break ; i ++ ; } return i == pathNative . length ( ) ? "" : pathNative . substring ( i ) ; } else return pathNative ; } public ArrayList < Path > getResources ( String name ) { ArrayList < Path > list = new ArrayList < Path > ( ) ; Path path = lookup ( name ) ; if ( path . exists ( ) ) list . add ( path ) ; return list ; } public ArrayList < Path > getResources ( ) { ArrayList < Path > list = new ArrayList < Path > ( ) ; list . add ( this ) ; return list ; } public Path getParent ( ) { return this ; } protected String scanScheme ( String uri ) { int i = 0 ; if ( uri == null ) return null ; int length = uri . length ( ) ; if ( length == 0 ) return null ; int ch = uri . charAt ( 0 ) ; if ( ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' ) { for ( i = 1 ; i < length ; i ++ ) { ch = uri . charAt ( i ) ; if ( ch == ':' ) return uri . substring ( 0 , i ) . toLowerCase ( ) ; if ( ! ( ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '0' || ch == '+' || ch == '-' || ch == '.' ) ) break ; } } return null ; } abstract protected Path schemeWalk ( String userPath , Map < String , Object > newAttributes , String newPath , int offset ) ; public String getURL ( ) { return escapeURL ( getScheme ( ) + ":" + getFullPath ( ) ) ; } public abstract String getScheme ( ) ; public String getHost ( ) { throw new UnsupportedOperationException ( ) ; } public int getPort ( ) { throw new UnsupportedOperationException ( ) ; } public abstract String getPath ( ) ; public String getTail ( ) { return "" ; } public String getQuery ( ) { throw new UnsupportedOperationException ( ) ; } public String getNativePath ( ) { return getFullPath ( ) ; } public String getUserPath ( ) { return getPath ( ) ; } public void setUserPath ( String userPath ) { } public String getFullPath ( ) { return getPath ( ) ; } public String getRelativePath ( ) { return getPath ( ) ; } public boolean isWindowsInsecure ( ) { String lower = getPath ( ) . toLowerCase ( ) ; int lastCh ; if ( ( lastCh = lower . charAt ( lower . length ( ) - 1 ) ) == '.' || lastCh == ' ' || lastCh == '*' || lastCh == '?' || ( ( lastCh == '/' || lastCh == '\\' ) && ! isDirectory ( ) ) || lower . endsWith ( "::$data" ) || isWindowsSpecial ( lower , "/con" ) || isWindowsSpecial ( lower , "/aux" ) || isWindowsSpecial ( lower , "/prn" ) || isWindowsSpecial ( lower , "/nul" ) || isWindowsSpecial ( lower , "/com1" ) || isWindowsSpecial ( lower , "/com2" ) || isWindowsSpecial ( lower , "/com3" ) || isWindowsSpecial ( lower , "/com4" ) || isWindowsSpecial ( lower , "/lpt1" ) || isWindowsSpecial ( lower , "/lpt2" ) || isWindowsSpecial ( lower , "/lpt3" ) ) { return true ; } return false ; } private boolean isWindowsSpecial ( String lower , String test ) { int p = lower . indexOf ( test ) ; if ( p < 0 ) return false ; int lowerLen = lower . length ( ) ; int testLen = test . length ( ) ; char ch ; if ( lowerLen == p + testLen || ( ch = lower . charAt ( p + testLen ) ) == '/' || ch == '.' ) return true ; else return false ; } public Certificate [ ] getCertificates ( ) { return null ; } public boolean exists ( ) { return false ; } public String getContentType ( ) { return "application/octet-stream" ; } public boolean isDirectory ( ) { return false ; } public boolean isFile ( ) { return false ; } public boolean isLink ( ) { return false ; } public boolean isSocket ( ) { return false ; } public boolean isFIFO ( ) { return false ; } public boolean isBlockDevice ( ) { return false ; } public boolean isCharacterDevice ( ) { return false ; } public boolean isExecutable ( ) { return false ; } public boolean setExecutable ( boolean isExecutable ) { return false ; } public boolean isSymbolicLink ( ) { return false ; } public boolean isHardLink ( ) { return false ; } public boolean isObject ( ) { return false ; } public void clearStatusCache ( ) { } public long getLength ( ) { return 0 ; } public long getLastModified ( ) { return 0 ; } public void setLastModified ( long time ) { } public long getLastAccessTime ( ) { return getLastModified ( ) ; } public long getCreateTime ( ) { return getLastModified ( ) ; } public boolean canRead ( ) { return false ; } public boolean canWrite ( ) { return false ; } public long getDevice ( ) { return 0 ; } public long getInode ( ) { return 0 ; } public int getMode ( ) { return 0 ; } public int getNumberOfLinks ( ) { return 0 ; } public int getUser ( ) { return 0 ; } public int getGroup ( ) { return 0 ; } public long getDeviceId ( ) { return 0 ; } public long getBlockSize ( ) { return 0 ; } public long getBlockCount ( ) { return 0 ; } public long getLastStatusChangeTime ( ) { return 0 ; } public boolean canExecute ( ) { return canRead ( ) ; } public boolean changeGroup ( int gid ) throws IOException { return false ; } public boolean changeGroup ( String groupName ) throws IOException { return false ; } public boolean chmod ( int value ) { return false ; } public int getOwner ( ) { return getUser ( ) ; } public boolean changeOwner ( int uid ) throws IOException { return false ; } public boolean changeOwner ( String ownerName ) throws IOException { return false ; } public long getDiskSpaceFree ( ) { return 0 ; } public long getDiskSpaceTotal ( ) { return 0 ; } public String [ ] list ( ) throws IOException { return new String [ 0 ] ; } public Iterator < String > iterator ( ) throws IOException { String list [ ] = list ( ) ; if ( list == null ) list = new String [ 0 ] ; return new ArrayIterator ( list ) ; } public boolean mkdir ( ) throws IOException { return false ; } public boolean mkdirs ( ) throws IOException { return false ; } public boolean remove ( ) throws IOException { return false ; } public boolean removeAll ( ) throws IOException { if ( isDirectory ( ) ) { String [ ] list = list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { Path subpath = lookup ( list [ i ] ) ; subpath . removeAll ( ) ; } } return remove ( ) ; } public boolean truncate ( ) throws IOException { return truncate ( 0 ) ; } public boolean truncate ( long length ) throws IOException { if ( length == 0 ) { if ( exists ( ) ) { StreamImpl stream = openWriteImpl ( ) ; stream . close ( ) ; return true ; } else return false ; } else throw new UnsupportedOperationException ( getClass ( ) . getName ( ) + ": truncate" ) ; } public boolean renameTo ( Path path ) throws IOException { return false ; } public final boolean renameTo ( String path ) throws IOException { return renameTo ( lookup ( path ) ) ; } public Path createRoot ( ) { return createRoot ( SchemeMap . getNullSchemeMap ( ) ) ; } public Path createRoot ( SchemeMap schemeMap ) { throw new UnsupportedOperationException ( "createRoot" ) ; } public void bind ( Path context ) { throw new UnsupportedOperationException ( "bind" ) ; } public void unbind ( ) { throw new UnsupportedOperationException ( "unbind" ) ; } public Object getValue ( ) throws Exception { throw new UnsupportedOperationException ( "getValue" ) ; } public void setValue ( Object obj ) throws Exception { throw new UnsupportedOperationException ( "setValue" ) ; } public Object getAttribute ( String name ) throws IOException { return null ; } public Iterator getAttributeNames ( ) throws IOException { return null ; } public final ReadStream openRead ( ) throws IOException { clearStatusCache ( ) ; StreamImpl impl = openReadImpl ( ) ; impl . setPath ( this ) ; return new ReadStream ( impl ) ; } public final WriteStream openWrite ( ) throws IOException { clearStatusCache ( ) ; StreamImpl impl = openWriteImpl ( ) ; impl . setPath ( this ) ; return new WriteStream ( impl ) ; } public ReadWritePair openReadWrite ( ) throws IOException { clearStatusCache ( ) ; StreamImpl impl = openReadWriteImpl ( ) ; impl . setPath ( this ) ; WriteStream writeStream = new WriteStream ( impl ) ; ReadStream readStream = new ReadStream ( impl , writeStream ) ; return new ReadWritePair ( readStream , writeStream ) ; } public void openReadWrite ( ReadStream is , WriteStream os ) throws IOException { clearStatusCache ( ) ; StreamImpl impl = openReadWriteImpl ( ) ; impl . setPath ( this ) ; os . init ( impl ) ; is . init ( impl , os ) ; } public WriteStream openAppend ( ) throws IOException { clearStatusCache ( ) ; StreamImpl impl = openAppendImpl ( ) ; return new WriteStream ( impl ) ; } public RandomAccessStream openRandomAccess ( ) throws IOException { clearStatusCache ( ) ; throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public boolean createNewFile ( ) throws IOException { synchronized ( LOCK ) { if ( ! exists ( ) ) { WriteStream s = openWrite ( ) ; s . close ( ) ; return true ; } } return false ; } public PersistentDependency createDepend ( ) { return new Depend ( this ) ; } public Path createTempFile ( String prefix , String suffix ) throws IOException { if ( prefix == null || prefix . length ( ) == 0 ) prefix = "t" ; if ( suffix == null ) suffix = ".tmp" ; synchronized ( LOCK ) { for ( int i = 0 ; i < 32768 ; i ++ ) { int r = Math . abs ( ( int ) RandomUtil . getRandomLong ( ) ) ; Path file = lookup ( prefix + r + suffix ) ; if ( file . createNewFile ( ) ) return file ; } } throw new IOException ( "cannot create temp file" ) ; } public boolean createLink ( Path target , boolean hardLink ) throws IOException { throw new UnsupportedOperationException ( getScheme ( ) + ": doesn't support createLink" ) ; } public String readLink ( ) { return null ; } public String realPath ( ) { return getFullPath ( ) ; } public void writeToStream ( OutputStream os ) throws IOException { StreamImpl is = openReadImpl ( ) ; TempBuffer tempBuffer = TempBuffer . allocate ( ) ; try { byte [ ] buffer = tempBuffer . getBuffer ( ) ; int length = buffer . length ; int len ; while ( ( len = is . read ( buffer , 0 , length ) ) > 0 ) os . write ( buffer , 0 , len ) ; } finally { TempBuffer . free ( tempBuffer ) ; tempBuffer = null ; is . close ( ) ; } } public void writeToStream ( OutputStreamWithBuffer os ) throws IOException { StreamImpl is = openReadImpl ( ) ; try { byte [ ] buffer = os . getBuffer ( ) ; int offset = os . getBufferOffset ( ) ; int length = buffer . length ; while ( true ) { int sublen = length - offset ; if ( sublen <= 0 ) { buffer = os . nextBuffer ( offset ) ; offset = 0 ; sublen = length ; } sublen = is . read ( buffer , offset , sublen ) ; if ( sublen <= 0 ) { os . setBufferOffset ( offset ) ; return ; } offset += sublen ; } } finally { is . close ( ) ; } } public long getCrc64 ( ) { try { if ( isDirectory ( ) ) { String [ ] list = list ( ) ; long digest = 0 ; for ( int i = 0 ; i < list . length ; i ++ ) { digest = Crc64 . generate ( digest , list [ i ] ) ; } return digest ; } else if ( canRead ( ) ) { ReadStream is = openRead ( ) ; try { long digest = 0 ; byte [ ] buffer = is . getBuffer ( ) ; while ( is . fillBuffer ( ) > 0 ) { int length = is . getLength ( ) ; digest = Crc64 . generate ( digest , buffer , 0 , length ) ; } return digest ; } finally { is . close ( ) ; } } else { return - 1 ; } } catch ( IOException e ) { e . printStackTrace ( ) ; return - 1 ; } } public Object getObject ( ) throws IOException { throw new UnsupportedOperationException ( getScheme ( ) + ": doesn't support getObject" ) ; } public void setObject ( Object obj ) throws IOException { throw new UnsupportedOperationException ( getScheme ( ) + ": doesn't support setObject" ) ; } public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } public boolean equals ( Object o ) { if ( this == o ) return true ; else if ( ! ( o instanceof Path ) ) return false ; else return getURL ( ) . equals ( ( ( Path ) o ) . getURL ( ) ) ; } public String toString ( ) { return getFullPath ( ) ; } public StreamImpl openReadImpl ( ) throws IOException { throw new UnsupportedOperationException ( "openRead:" + getClass ( ) . getName ( ) ) ; } public StreamImpl openWriteImpl ( ) throws IOException { throw new UnsupportedOperationException ( "openWrite:" + getClass ( ) . getName ( ) ) ; } public StreamImpl openReadWriteImpl ( ) throws IOException { throw new UnsupportedOperationException ( "openReadWrite:" + getClass ( ) . getName ( ) ) ; } public StreamImpl openAppendImpl ( ) throws IOException { throw new UnsupportedOperationException ( "openAppend:" + getClass ( ) . getName ( ) ) ; } protected static String escapeURL ( String rawURL ) { CharBuffer cb = null ; int length = rawURL . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = rawURL . charAt ( i ) ; switch ( ch ) { case ' ' : if ( cb == null ) { cb = new CharBuffer ( ) ; cb . append ( rawURL , 0 , i ) ; } cb . append ( "%20" ) ; break ; case '#' : if ( cb == null ) { cb = new CharBuffer ( ) ; cb . append ( rawURL , 0 , i ) ; } cb . append ( "%23" ) ; break ; case '%' : if ( cb == null ) { cb = new CharBuffer ( ) ; cb . append ( rawURL , 0 , i ) ; } cb . append ( "%25" ) ; break ; default : if ( cb != null ) cb . append ( ch ) ; break ; } } if ( cb != null ) return cb . toString ( ) ; else return rawURL ; } protected Path copy ( ) { return this ; } protected Path cacheCopy ( ) { return this ; } public static final void setDefaultSchemeMap ( SchemeMap schemeMap ) { _defaultSchemeMap = schemeMap ; _pathLookupCache . clear ( ) ; } public static final boolean isWindows ( ) { return _separatorChar == '\\' || _isTestWindows ; } public static final void setTestWindows ( boolean isTest ) { _isTestWindows = isTest ; } protected static final char getSeparatorChar ( ) { return _separatorChar ; } public static final char getFileSeparatorChar ( ) { return _separatorChar ; } public static final char getPathSeparatorChar ( ) { return _pathSeparatorChar ; } protected static String getUserDir ( ) { return System . getProperty ( "user.dir" ) ; } public static String getNewlineString ( ) { if ( _newline == null ) { _newline = System . getProperty ( "line.separator" ) ; if ( _newline == null ) _newline = "\n" ; } return _newline ; } private class ArrayIterator implements Iterator < String > { String [ ] list ; int index ; public boolean hasNext ( ) { return index < list . length ; } public String next ( ) { return index < list . length ? list [ index ++ ] : null ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } ArrayIterator ( String [ ] list ) { this . list = list ; index = 0 ; } } static class PathKey { private Path _parent ; private String _lookup ; PathKey ( ) { } PathKey ( Path parent , String lookup ) { _parent = parent ; _lookup = lookup ; } void init ( Path parent , String lookup ) { _parent = parent ; _lookup = lookup ; } public int hashCode ( ) { if ( _parent != null ) return _parent . hashCode ( ) * 65521 + _lookup . hashCode ( ) ; else return _lookup . hashCode ( ) ; } public boolean equals ( Object test ) { if ( ! ( test instanceof PathKey ) ) return false ; PathKey key = ( PathKey ) test ; if ( _parent != null ) return ( _parent . equals ( key . _parent ) && _lookup . equals ( key . _lookup ) ) ; else return ( key . _parent == null && _lookup . equals ( key . _lookup ) ) ; } } static { DEFAULT_SCHEME_MAP . put ( "file" , new FilePath ( null ) ) ; DEFAULT_SCHEME_MAP . put ( "http" , new HttpPath ( "127.0.0.1" , 0 ) ) ; DEFAULT_SCHEME_MAP . put ( "https" , new HttpsPath ( "127.0.0.1" , 0 ) ) ; DEFAULT_SCHEME_MAP . put ( "tcp" , new TcpPath ( null , null , null , "127.0.0.1" , 0 ) ) ; DEFAULT_SCHEME_MAP . put ( "tcps" , new TcpsPath ( null , null , null , "127.0.0.1" , 0 ) ) ; StreamImpl stdout = StdoutStream . create ( ) ; StreamImpl stderr = StderrStream . create ( ) ; DEFAULT_SCHEME_MAP . put ( "stdout" , stdout . getPath ( ) ) ; DEFAULT_SCHEME_MAP . put ( "stderr" , stderr . getPath ( ) ) ; VfsStream nullStream = new VfsStream ( null , null ) ; DEFAULT_SCHEME_MAP . put ( "null" , new ConstPath ( null , nullStream ) ) ; DEFAULT_SCHEME_MAP . put ( "jndi" , new JndiPath ( ) ) ; } } 
=======
public class ErrorHandlerImpl implements ErrorHandler { private final PrintWriter err ; private final String bundleName = "com.thaiopensource.xml.sax.resources.Messages" ; private ResourceBundle bundle = null ; public ErrorHandlerImpl ( ) { this ( System . err ) ; } public ErrorHandlerImpl ( OutputStream os ) { this . err = new PrintWriter ( os ) ; } public ErrorHandlerImpl ( Writer w ) { this . err = new PrintWriter ( w ) ; } public void close ( ) { err . close ( ) ; } private String getString ( String key ) { if ( bundle == null ) bundle = ResourceBundle . getBundle ( bundleName ) ; return bundle . getString ( key ) ; } private String format ( String key , Object [ ] args ) { return MessageFormat . format ( getString ( key ) , args ) ; } public void warning ( SAXParseException e ) throws SAXParseException { print ( format ( "warning" , new Object [ ] { formatMessage ( e ) , formatLocation ( e ) } ) ) ; } public void error ( SAXParseException e ) { print ( format ( "error" , new Object [ ] { formatMessage ( e ) , formatLocation ( e ) } ) ) ; } public void fatalError ( SAXParseException e ) throws SAXParseException { throw e ; } public void printException ( Throwable e ) { String loc ; if ( e instanceof SAXParseException ) loc = formatLocation ( ( SAXParseException ) e ) ; else loc = "" ; String message ; if ( e instanceof SAXException ) message = formatMessage ( ( SAXException ) e ) ; else message = formatMessage ( e ) ; print ( format ( "fatal" , new Object [ ] { message , loc } ) ) ; } public void print ( String message ) { if ( message . length ( ) != 0 ) { err . println ( message ) ; err . flush ( ) ; } } private String formatLocation ( SAXParseException e ) { String systemId = e . getSystemId ( ) ; int n = e . getLineNumber ( ) ; Integer lineNumber = n >= 0 ? new Integer ( n ) : null ; n = e . getColumnNumber ( ) ; Integer columnNumber = n >= 0 ? new Integer ( n ) : null ; if ( systemId != null ) { systemId = UriOrFile . uriToUriOrFile ( systemId ) ; if ( lineNumber != null ) { if ( columnNumber != null ) return format ( "locator_system_id_line_number_column_number" , new Object [ ] { systemId , lineNumber , columnNumber } ) ; else return format ( "locator_system_id_line_number" , new Object [ ] { systemId , lineNumber } ) ; } else return format ( "locator_system_id" , new Object [ ] { systemId } ) ; } else if ( lineNumber != null ) { if ( columnNumber != null ) return format ( "locator_line_number_column_number" , new Object [ ] { lineNumber , columnNumber } ) ; else return format ( "locator_line_number" , new Object [ ] { lineNumber } ) ; } else return "" ; } private String formatMessage ( SAXException se ) { Exception e = se . getException ( ) ; String detail = se . getMessage ( ) ; if ( e != null ) { String detail2 = e . getMessage ( ) ; if ( detail2 == detail || e . getClass ( ) . getName ( ) . equals ( detail ) ) return formatMessage ( e ) ; else if ( detail2 == null ) return format ( "exception" , new Object [ ] { e . getClass ( ) . getName ( ) , detail } ) ; else return format ( "tunnel_exception" , new Object [ ] { e . getClass ( ) . getName ( ) , detail , detail2 } ) ; } else { if ( detail == null ) detail = getString ( "no_detail" ) ; return detail ; } } private String formatMessage ( Throwable e ) { String detail = e . getMessage ( ) ; if ( detail == null ) detail = getString ( "no_detail" ) ; if ( e instanceof FileNotFoundException ) return format ( "file_not_found" , new Object [ ] { detail } ) ; return format ( "exception" , new Object [ ] { e . getClass ( ) . getName ( ) , detail } ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
