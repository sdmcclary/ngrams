public class XMLPairTagModifyStrategy implements IAutoEditStrategy , IPreferenceClient { protected SourceViewerConfiguration configuration ; protected ISourceViewer sourceViewer ; protected EditorFileContext context ; public XMLPairTagModifyStrategy ( EditorFileContext context , SourceViewerConfiguration configuration , ISourceViewer sourceViewer ) { this . context = context ; this . configuration = configuration ; this . sourceViewer = sourceViewer ; } public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { IPreferenceStore store = XMLPlugin . getDefault ( ) . getPreferenceStore ( ) ; IParseState parseState = context . getParseState ( ) ; XMLParseState xmlParseState = ( XMLParseState ) parseState . getParseState ( XMLMimeType . MimeType ) ; modifyPairTag ( document , command , xmlParseState , store ) ; } public IPreferenceStore getPreferenceStore ( ) { return XMLPlugin . getDefault ( ) . getPreferenceStore ( ) ; } private void modifyPairTag ( IDocument document , DocumentCommand command , IParseState parseState , IPreferenceStore store ) { if ( store == null || ! store . getBoolean ( IPreferenceConstants . AUTO_MODIFY_PAIR_TAG ) ) { return ; } Lexeme cursorLexeme = getTagLexeme ( parseState , command . offset ) ; if ( cursorLexeme != null ) { XMLPairFinder finder = new XMLPairFinder ( ) ; PairMatch match = finder . findPairMatch ( command . offset , parseState , cursorLexeme , 2 ) ; if ( match != null ) { Lexeme pairLexeme ; if ( match . endStart > command . offset ) { pairLexeme = getTagLexeme ( parseState , match . endStart ) ; } else { pairLexeme = getTagLexeme ( parseState , match . beginStart ) ; } if ( pairLexeme == null ) { return ; } if ( ! checkMatch ( cursorLexeme , pairLexeme ) ) { return ; } if ( checkFullDelete ( command , parseState . getLexemeList ( ) , cursorLexeme , pairLexeme ) ) { return ; } if ( destroysTag ( cursorLexeme , parseState . getLexemeList ( ) , command . offset , command . length ) ) { return ; } int replaceLength = filterReplaceLength ( command , cursorLexeme ) ; if ( replaceLength == - 1 ) { return ; } String replaceText = filterReplaceText ( command . text ) ; if ( replaceLength == 0 && replaceText . length ( ) == 0 ) { return ; } try { int caretPosition = command . offset + command . length ; command . caretOffset = caretPosition ; command . shiftsCaret = true ; int offsetDif = command . offset - cursorLexeme . offset ; if ( match . endStart > command . offset ) { command . addCommand ( match . endStart + offsetDif + 1 , replaceLength , replaceText , command . owner ) ; } else { command . addCommand ( match . beginStart + offsetDif - 1 , replaceLength , replaceText , command . owner ) ; } command . doit = false ; } catch ( BadLocationException e ) { } } } } private boolean checkFullDelete ( DocumentCommand command , LexemeList lexemes , Lexeme cursorLexeme , Lexeme pairLexeme ) { Lexeme cursorEndingLexeme = getTagEndingLexeme ( cursorLexeme , lexemes ) ; Lexeme pairEndingLexeme = getTagEndingLexeme ( pairLexeme , lexemes ) ; if ( cursorEndingLexeme == null || pairEndingLexeme == null ) { return false ; } if ( cursorLexeme . getStartingOffset ( ) == command . offset && cursorEndingLexeme . getEndingOffset ( ) == command . offset + command . length ) { try { int caretPosition = command . offset + command . length ; command . caretOffset = caretPosition ; command . shiftsCaret = true ; command . addCommand ( pairLexeme . getStartingOffset ( ) , pairEndingLexeme . getEndingOffset ( ) - pairLexeme . getStartingOffset ( ) , "" , null ) ; command . doit = false ; return true ; } catch ( BadLocationException e ) { IdeLog . logError ( XMLPlugin . getDefault ( ) , "Unexpected exception while checking for complete tag removal" , e ) ; } } return false ; } private boolean destroysTag ( Lexeme startLexeme , LexemeList lexemes , int offset , int length ) { Lexeme closing = getTagEndingLexeme ( startLexeme , lexemes ) ; if ( closing == null ) { return false ; } return offset + length > closing . getStartingOffset ( ) ; } private Lexeme getTagEndingLexeme ( Lexeme startLexeme , LexemeList lexemes ) { int startIndex = lexemes . getLexemeIndex ( startLexeme ) ; if ( ( startLexeme . typeIndex != XMLTokenTypes . START_TAG && startLexeme . typeIndex != XMLTokenTypes . END_TAG ) || startIndex < 0 ) { throw new IllegalArgumentException ( "Wrong start lexeme" ) ; } Lexeme closing = XMLUtils . getFirstLexemeBreaking ( lexemes , startIndex + 1 , new int [ ] { XMLTokenTypes . GREATER_THAN } , new int [ ] { XMLTokenTypes . START_TAG , XMLTokenTypes . END_TAG , XMLTokenTypes . START_TAG , } ) ; return closing ; } private boolean checkMatch ( Lexeme firstLexeme , Lexeme secondLexeme ) { int firstTagStart = getTagNameStartOffset ( firstLexeme ) ; if ( firstTagStart == - 1 ) { return false ; } int secondTagStart = getTagNameStartOffset ( secondLexeme ) ; if ( secondTagStart == - 1 ) { return false ; } String firstName = firstLexeme . getText ( ) . substring ( firstTagStart - firstLexeme . getStartingOffset ( ) ) ; String secondName = secondLexeme . getText ( ) . substring ( secondTagStart - secondLexeme . getStartingOffset ( ) ) ; return firstName . equalsIgnoreCase ( secondName ) ; } private int filterReplaceLength ( DocumentCommand originalCommand , Lexeme tagLexeme ) { int tagNameStartOffset = getTagNameStartOffset ( tagLexeme ) ; if ( originalCommand . offset < tagNameStartOffset ) { return - 1 ; } if ( originalCommand . offset > tagLexeme . getEndingOffset ( ) ) { return - 1 ; } int maxLength = tagLexeme . getEndingOffset ( ) - originalCommand . offset ; int resultLength = Math . min ( originalCommand . length , maxLength ) ; return resultLength ; } private String filterReplaceText ( String originalText ) { int pos = 0 ; for ( ; pos < originalText . length ( ) ; pos ++ ) { int ch = originalText . charAt ( pos ) ; if ( ! Character . isLetterOrDigit ( ch ) ) { break ; } } return originalText . substring ( 0 , pos ) ; } private int getTagNameStartOffset ( Lexeme tagLexeme ) { if ( tagLexeme . typeIndex == XMLTokenTypes . START_TAG ) { return tagLexeme . getStartingOffset ( ) + 1 ; } else if ( tagLexeme . typeIndex == XMLTokenTypes . END_TAG ) { return tagLexeme . getStartingOffset ( ) + 2 ; } else { throw new IllegalArgumentException ( "Tag starting lexeme is excpected" ) ; } } private Lexeme getTagLexeme ( IParseState state , int offset ) { LexemeList lexemeList = state . getLexemeList ( ) ; Lexeme currentLexeme = lexemeList . getFloorLexeme ( offset ) ; if ( currentLexeme != null && ( currentLexeme . typeIndex == XMLTokenTypes . START_TAG || currentLexeme . typeIndex == XMLTokenTypes . END_TAG ) ) { return currentLexeme ; } currentLexeme = lexemeList . getCeilingLexeme ( offset ) ; if ( currentLexeme == null ) { return null ; } if ( currentLexeme . typeIndex == XMLTokenTypes . START_TAG || currentLexeme . typeIndex == XMLTokenTypes . END_TAG ) { return currentLexeme ; } int currentLexemeIndex = lexemeList . getLexemeIndex ( currentLexeme ) ; if ( currentLexemeIndex <= 0 ) { return null ; } Lexeme previousLexeme = lexemeList . get ( currentLexemeIndex - 1 ) ; if ( ( previousLexeme . typeIndex == XMLTokenTypes . START_TAG || previousLexeme . typeIndex == XMLTokenTypes . END_TAG ) && currentLexeme . typeIndex == XMLTokenTypes . GREATER_THAN ) { return previousLexeme ; } return null ; } } 