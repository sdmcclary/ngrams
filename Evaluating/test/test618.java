<<<<<<< HEAD
public class XMLPairTagModifyStrategy implements IAutoEditStrategy , IPreferenceClient { protected SourceViewerConfiguration configuration ; protected ISourceViewer sourceViewer ; protected EditorFileContext context ; public XMLPairTagModifyStrategy ( EditorFileContext context , SourceViewerConfiguration configuration , ISourceViewer sourceViewer ) { this . context = context ; this . configuration = configuration ; this . sourceViewer = sourceViewer ; } public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { IPreferenceStore store = XMLPlugin . getDefault ( ) . getPreferenceStore ( ) ; IParseState parseState = context . getParseState ( ) ; XMLParseState xmlParseState = ( XMLParseState ) parseState . getParseState ( XMLMimeType . MimeType ) ; modifyPairTag ( document , command , xmlParseState , store ) ; } public IPreferenceStore getPreferenceStore ( ) { return XMLPlugin . getDefault ( ) . getPreferenceStore ( ) ; } private void modifyPairTag ( IDocument document , DocumentCommand command , IParseState parseState , IPreferenceStore store ) { if ( store == null || ! store . getBoolean ( IPreferenceConstants . AUTO_MODIFY_PAIR_TAG ) ) { return ; } Lexeme cursorLexeme = getTagLexeme ( parseState , command . offset ) ; if ( cursorLexeme != null ) { XMLPairFinder finder = new XMLPairFinder ( ) ; PairMatch match = finder . findPairMatch ( command . offset , parseState , cursorLexeme , 2 ) ; if ( match != null ) { Lexeme pairLexeme ; if ( match . endStart > command . offset ) { pairLexeme = getTagLexeme ( parseState , match . endStart ) ; } else { pairLexeme = getTagLexeme ( parseState , match . beginStart ) ; } if ( pairLexeme == null ) { return ; } if ( ! checkMatch ( cursorLexeme , pairLexeme ) ) { return ; } if ( checkFullDelete ( command , parseState . getLexemeList ( ) , cursorLexeme , pairLexeme ) ) { return ; } if ( destroysTag ( cursorLexeme , parseState . getLexemeList ( ) , command . offset , command . length ) ) { return ; } int replaceLength = filterReplaceLength ( command , cursorLexeme ) ; if ( replaceLength == - 1 ) { return ; } String replaceText = filterReplaceText ( command . text ) ; if ( replaceLength == 0 && replaceText . length ( ) == 0 ) { return ; } try { int caretPosition = command . offset + command . length ; command . caretOffset = caretPosition ; command . shiftsCaret = true ; int offsetDif = command . offset - cursorLexeme . offset ; if ( match . endStart > command . offset ) { command . addCommand ( match . endStart + offsetDif + 1 , replaceLength , replaceText , command . owner ) ; } else { command . addCommand ( match . beginStart + offsetDif - 1 , replaceLength , replaceText , command . owner ) ; } command . doit = false ; } catch ( BadLocationException e ) { } } } } private boolean checkFullDelete ( DocumentCommand command , LexemeList lexemes , Lexeme cursorLexeme , Lexeme pairLexeme ) { Lexeme cursorEndingLexeme = getTagEndingLexeme ( cursorLexeme , lexemes ) ; Lexeme pairEndingLexeme = getTagEndingLexeme ( pairLexeme , lexemes ) ; if ( cursorEndingLexeme == null || pairEndingLexeme == null ) { return false ; } if ( cursorLexeme . getStartingOffset ( ) == command . offset && cursorEndingLexeme . getEndingOffset ( ) == command . offset + command . length ) { try { int caretPosition = command . offset + command . length ; command . caretOffset = caretPosition ; command . shiftsCaret = true ; command . addCommand ( pairLexeme . getStartingOffset ( ) , pairEndingLexeme . getEndingOffset ( ) - pairLexeme . getStartingOffset ( ) , "" , null ) ; command . doit = false ; return true ; } catch ( BadLocationException e ) { IdeLog . logError ( XMLPlugin . getDefault ( ) , "Unexpected exception while checking for complete tag removal" , e ) ; } } return false ; } private boolean destroysTag ( Lexeme startLexeme , LexemeList lexemes , int offset , int length ) { Lexeme closing = getTagEndingLexeme ( startLexeme , lexemes ) ; if ( closing == null ) { return false ; } return offset + length > closing . getStartingOffset ( ) ; } private Lexeme getTagEndingLexeme ( Lexeme startLexeme , LexemeList lexemes ) { int startIndex = lexemes . getLexemeIndex ( startLexeme ) ; if ( ( startLexeme . typeIndex != XMLTokenTypes . START_TAG && startLexeme . typeIndex != XMLTokenTypes . END_TAG ) || startIndex < 0 ) { throw new IllegalArgumentException ( "Wrong start lexeme" ) ; } Lexeme closing = XMLUtils . getFirstLexemeBreaking ( lexemes , startIndex + 1 , new int [ ] { XMLTokenTypes . GREATER_THAN } , new int [ ] { XMLTokenTypes . START_TAG , XMLTokenTypes . END_TAG , XMLTokenTypes . START_TAG , } ) ; return closing ; } private boolean checkMatch ( Lexeme firstLexeme , Lexeme secondLexeme ) { int firstTagStart = getTagNameStartOffset ( firstLexeme ) ; if ( firstTagStart == - 1 ) { return false ; } int secondTagStart = getTagNameStartOffset ( secondLexeme ) ; if ( secondTagStart == - 1 ) { return false ; } String firstName = firstLexeme . getText ( ) . substring ( firstTagStart - firstLexeme . getStartingOffset ( ) ) ; String secondName = secondLexeme . getText ( ) . substring ( secondTagStart - secondLexeme . getStartingOffset ( ) ) ; return firstName . equalsIgnoreCase ( secondName ) ; } private int filterReplaceLength ( DocumentCommand originalCommand , Lexeme tagLexeme ) { int tagNameStartOffset = getTagNameStartOffset ( tagLexeme ) ; if ( originalCommand . offset < tagNameStartOffset ) { return - 1 ; } if ( originalCommand . offset > tagLexeme . getEndingOffset ( ) ) { return - 1 ; } int maxLength = tagLexeme . getEndingOffset ( ) - originalCommand . offset ; int resultLength = Math . min ( originalCommand . length , maxLength ) ; return resultLength ; } private String filterReplaceText ( String originalText ) { int pos = 0 ; for ( ; pos < originalText . length ( ) ; pos ++ ) { int ch = originalText . charAt ( pos ) ; if ( ! Character . isLetterOrDigit ( ch ) ) { break ; } } return originalText . substring ( 0 , pos ) ; } private int getTagNameStartOffset ( Lexeme tagLexeme ) { if ( tagLexeme . typeIndex == XMLTokenTypes . START_TAG ) { return tagLexeme . getStartingOffset ( ) + 1 ; } else if ( tagLexeme . typeIndex == XMLTokenTypes . END_TAG ) { return tagLexeme . getStartingOffset ( ) + 2 ; } else { throw new IllegalArgumentException ( "Tag starting lexeme is excpected" ) ; } } private Lexeme getTagLexeme ( IParseState state , int offset ) { LexemeList lexemeList = state . getLexemeList ( ) ; Lexeme currentLexeme = lexemeList . getFloorLexeme ( offset ) ; if ( currentLexeme != null && ( currentLexeme . typeIndex == XMLTokenTypes . START_TAG || currentLexeme . typeIndex == XMLTokenTypes . END_TAG ) ) { return currentLexeme ; } currentLexeme = lexemeList . getCeilingLexeme ( offset ) ; if ( currentLexeme == null ) { return null ; } if ( currentLexeme . typeIndex == XMLTokenTypes . START_TAG || currentLexeme . typeIndex == XMLTokenTypes . END_TAG ) { return currentLexeme ; } int currentLexemeIndex = lexemeList . getLexemeIndex ( currentLexeme ) ; if ( currentLexemeIndex <= 0 ) { return null ; } Lexeme previousLexeme = lexemeList . get ( currentLexemeIndex - 1 ) ; if ( ( previousLexeme . typeIndex == XMLTokenTypes . START_TAG || previousLexeme . typeIndex == XMLTokenTypes . END_TAG ) && currentLexeme . typeIndex == XMLTokenTypes . GREATER_THAN ) { return previousLexeme ; } return null ; } } 
=======
public class MediaQuery extends AbstractDatatype { public static final MediaQuery THE_INSTANCE = new MediaQuery ( ) ; private static final boolean WARN = System . getProperty ( "org.whattf.datatype.warn" , "" ) . equals ( "true" ) ? true : false ; private enum State { INITIAL_WS , OPEN_PAREN_SEEN , IN_ONLY_OR_NOT , IN_MEDIA_TYPE , IN_MEDIA_FEATURE , WS_BEFORE_MEDIA_TYPE , WS_BEFORE_AND , IN_AND , WS_BEFORE_EXPRESSION , WS_BEFORE_COLON , WS_BEFORE_VALUE , IN_VALUE_DIGITS , IN_VALUE_SCAN , IN_VALUE_ORIENTATION , WS_BEFORE_CLOSE_PAREN , IN_VALUE_UNIT , IN_VALUE_DIGITS_AFTER_DOT , RATIO_SECOND_INTEGER_START , IN_VALUE_BEFORE_DIGITS , IN_VALUE_DIGITS_AFTER_DOT_TRAIL , AFTER_CLOSE_PAREN , IN_VALUE_ONEORZERO } private enum ValueType { LENGTH , RATIO , INTEGER , RESOLUTION , SCAN , ORIENTATION , NONZEROINTEGER , ONEORZERO } private static final Set < String > LENGTH_UNITS = new HashSet < String > ( ) ; static { LENGTH_UNITS . add ( "em" ) ; LENGTH_UNITS . add ( "ex" ) ; LENGTH_UNITS . add ( "px" ) ; LENGTH_UNITS . add ( "gd" ) ; LENGTH_UNITS . add ( "rem" ) ; LENGTH_UNITS . add ( "vw" ) ; LENGTH_UNITS . add ( "vh" ) ; LENGTH_UNITS . add ( "vm" ) ; LENGTH_UNITS . add ( "ch" ) ; LENGTH_UNITS . add ( "in" ) ; LENGTH_UNITS . add ( "cm" ) ; LENGTH_UNITS . add ( "mm" ) ; LENGTH_UNITS . add ( "pt" ) ; LENGTH_UNITS . add ( "pc" ) ; } private static final Set < String > MEDIA_TYPES = new HashSet < String > ( ) ; static { MEDIA_TYPES . add ( "all" ) ; MEDIA_TYPES . add ( "aural" ) ; MEDIA_TYPES . add ( "braille" ) ; MEDIA_TYPES . add ( "handheld" ) ; MEDIA_TYPES . add ( "print" ) ; MEDIA_TYPES . add ( "projection" ) ; MEDIA_TYPES . add ( "screen" ) ; MEDIA_TYPES . add ( "tty" ) ; MEDIA_TYPES . add ( "tv" ) ; MEDIA_TYPES . add ( "embossed" ) ; MEDIA_TYPES . add ( "speech" ) ; } private enum MediaType { ALL , AURAL , BRAILLE , HANDHELD , PRINT , PROJECTION , SCREEN , TTY , TV , EMBOSSED , SPEECH , INVALID ; private static MediaType toCaps ( String str ) { try { return valueOf ( toAsciiUpperCase ( str ) ) ; } catch ( Exception ex ) { return INVALID ; } } } private static final Map < String , ValueType > FEATURES_TO_VALUE_TYPES = new HashMap < String , ValueType > ( ) ; static { FEATURES_TO_VALUE_TYPES . put ( "width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "device-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-device-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-device-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "device-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-device-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-device-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "device-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "min-device-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "max-device-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "min-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "max-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "color" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "min-color" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "max-color" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "color-index" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "min-color-index" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "max-color-index" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "monochrome" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "min-monochrome" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "max-monochrome" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "resolution" , ValueType . RESOLUTION ) ; FEATURES_TO_VALUE_TYPES . put ( "min-resolution" , ValueType . RESOLUTION ) ; FEATURES_TO_VALUE_TYPES . put ( "max-resolution" , ValueType . RESOLUTION ) ; FEATURES_TO_VALUE_TYPES . put ( "scan" , ValueType . SCAN ) ; FEATURES_TO_VALUE_TYPES . put ( "orientation" , ValueType . ORIENTATION ) ; FEATURES_TO_VALUE_TYPES . put ( "grid" , ValueType . ONEORZERO ) ; } private static final String [ ] visualFeatures = { "aspect-ratio" , "color" , "color-index" , "device-aspect-ratio" , "max-aspect-ratio" , "max-color" , "max-color-index" , "max-device-aspect-ratio" , "max-monochrome" , "max-resolution" , "min-aspect-ratio" , "min-color" , "min-color-index" , "min-device-aspect-ratio" , "min-monochrome" , "min-resolution" , "monochrome" , "orientation" , "resolution" , } ; private static final String [ ] bitmapFeatures = { "aspect-ratio" , "device-aspect-ratio" , "max-aspect-ratio" , "max-device-aspect-ratio" , "max-resolution" , "min-aspect-ratio" , "min-device-aspect-ratio" , "min-resolution" , "orientation" , "resolution" , } ; private static final String scanWarning = "The media feature “scan” is applicable only to the media type “tv”. " ; private MediaQuery ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { List < String > warnings = new ArrayList < String > ( ) ; List < CharSequenceWithOffset > queries = split ( literal , ',' ) ; for ( CharSequenceWithOffset query : queries ) { warnings = checkQuery ( query . getSequence ( ) , query . getOffset ( ) , warnings ) ; } if ( ! warnings . isEmpty ( ) && WARN ) { StringBuilder sb = new StringBuilder ( ) ; for ( String s : warnings ) { sb . append ( s + " " ) ; } throw newDatatypeException ( sb . toString ( ) . trim ( ) , WARN ) ; } } private List < String > checkQuery ( CharSequence query , int offset , List < String > warnings ) throws DatatypeException { boolean containsAural = false ; boolean zero = true ; String type = null ; String feature = null ; ValueType valueExpectation = null ; query = toAsciiLowerCase ( query ) ; StringBuilder sb = new StringBuilder ( ) ; State state = State . INITIAL_WS ; for ( int i = 0 ; i < query . length ( ) ; i ++ ) { char c = query . charAt ( i ) ; switch ( state ) { case INITIAL_WS : if ( isWhitespace ( c ) ) { continue ; } else if ( '(' == c ) { state = State . OPEN_PAREN_SEEN ; continue ; } else if ( 'o' == c || 'n' == c ) { sb . append ( c ) ; state = State . IN_ONLY_OR_NOT ; continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_MEDIA_TYPE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “(” or letter at start of a media query part but saw " , c , " instead." ) ; } case IN_ONLY_OR_NOT : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( "only" . equals ( kw ) || "not" . equals ( kw ) ) { state = State . WS_BEFORE_MEDIA_TYPE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “only” or “not” but saw “" + kw + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_MEDIA_TYPE : if ( isWhitespace ( c ) ) { continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_MEDIA_TYPE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter or whitespace but saw “" + c + "” instead." ) ; } case IN_MEDIA_TYPE : if ( ( 'a' <= c && 'z' >= c ) || c == '-' ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) ) { type = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( isMediaType ( type ) ) { if ( "aural" . equals ( type ) ) { containsAural = true ; } state = State . WS_BEFORE_AND ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a CSS media type but saw “" + type + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, hyphen or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_AND : if ( isWhitespace ( c ) ) { continue ; } else if ( 'a' == c ) { sb . append ( c ) ; state = State . IN_AND ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace or “and” but saw" + " “" + c + "” instead." ) ; } case IN_AND : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( "and" . equals ( kw ) ) { state = State . WS_BEFORE_EXPRESSION ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “and” but saw “" + kw + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_EXPRESSION : if ( isWhitespace ( c ) ) { continue ; } else if ( '(' == c ) { state = State . OPEN_PAREN_SEEN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “(” or whitespace but saw “" + c + "” instead." ) ; } case OPEN_PAREN_SEEN : if ( isWhitespace ( c ) ) { continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_MEDIA_FEATURE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter at start of a media feature part but saw “" + c + "” instead." ) ; } case IN_MEDIA_FEATURE : if ( ( 'a' <= c && 'z' >= c ) || c == '-' ) { sb . append ( c ) ; continue ; } else if ( c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; checkApplicability ( offset + i , kw , type , warnings ) ; checkIfValueRequired ( offset + i , kw ) ; state = State . AFTER_CLOSE_PAREN ; continue ; } else if ( isWhitespace ( c ) || c == ':' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; checkApplicability ( offset + i , kw , type , warnings ) ; feature = kw ; valueExpectation = valueExpectationFor ( kw ) ; if ( valueExpectation != null ) { if ( c == ':' ) { state = State . WS_BEFORE_VALUE ; continue ; } else { state = State . WS_BEFORE_COLON ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a CSS media feature but saw “" + kw + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, hyphen, colon or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_COLON : if ( isWhitespace ( c ) ) { continue ; } else if ( ':' == c ) { state = State . WS_BEFORE_VALUE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace or colon but saw “" + c + "” instead." ) ; } case WS_BEFORE_VALUE : if ( isWhitespace ( c ) ) { continue ; } else { zero = true ; switch ( valueExpectation ) { case SCAN : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_SCAN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter but saw “" + c + "” instead." ) ; } case ORIENTATION : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_ORIENTATION ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter but saw “" + c + "” instead." ) ; } case ONEORZERO : if ( c == '0' || c == '1' ) { sb . append ( c ) ; state = State . IN_VALUE_ONEORZERO ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “0” or “1” as “" + feature + "” value but found “" + c + "” instead." ) ; } default : if ( '1' <= c && '9' >= c ) { zero = false ; state = State . IN_VALUE_DIGITS ; continue ; } else if ( '0' == c ) { state = State . IN_VALUE_DIGITS ; continue ; } else if ( '+' == c ) { state = State . IN_VALUE_BEFORE_DIGITS ; continue ; } else if ( '.' == c && valueExpectation == ValueType . LENGTH ) { state = State . IN_VALUE_DIGITS_AFTER_DOT ; continue ; } else if ( valueExpectation == ValueType . LENGTH ) { throw newDatatypeException ( offset + i , "Expected a digit, a dot or a plus sign but saw “" + c + "” instead." ) ; } else { throw newDatatypeException ( offset + i , "Expected a digit or a plus sign but saw “" + c + "” instead." ) ; } } } case IN_VALUE_SCAN : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( ! ( "progressive" . equals ( kw ) || "interlace" . equals ( kw ) ) ) { throw newDatatypeException ( offset + i , "Expected “progressive” or “interlace” as the scan mode value but saw “" + kw + "” instead." ) ; } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, whitespace or “)” but saw “" + c + "” instead." ) ; } case IN_VALUE_ORIENTATION : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( ! ( "portrait" . equals ( kw ) || "landscape" . equals ( kw ) ) ) { throw newDatatypeException ( offset + i , "Expected “portrait” or “landscape” as the “orientation” value but saw “" + kw + "” instead." ) ; } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, whitespace or “)” but saw “" + c + "” instead." ) ; } case IN_VALUE_ONEORZERO : if ( isWhitespace ( c ) || c == ')' ) { sb . setLength ( 0 ) ; if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { sb . append ( c ) ; String kw = sb . toString ( ) ; throw newDatatypeException ( offset + i , "Expected “0” or “1” as “" + feature + "” value but saw “" + kw + "” instead." ) ; } case IN_VALUE_BEFORE_DIGITS : if ( '0' == c ) { state = State . IN_VALUE_DIGITS ; continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; state = State . IN_VALUE_DIGITS ; continue ; } else { switch ( valueExpectation ) { case LENGTH : case RESOLUTION : if ( '.' == c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a dot or a digit but saw “" + c + "” instead." ) ; } case INTEGER : case RATIO : throw newDatatypeException ( offset + i , "Expected a digit but saw “" + c + "” instead." ) ; default : throw new RuntimeException ( "Impossible state." ) ; } } case IN_VALUE_DIGITS : if ( '0' == c ) { continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; continue ; } else { switch ( valueExpectation ) { case LENGTH : case RESOLUTION : if ( '.' == c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT ; continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_UNIT ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { if ( ! zero ) { if ( valueExpectation == ValueType . LENGTH ) { throw newDatatypeException ( offset + i , "Non-zero lengths require a unit." ) ; } else { throw newDatatypeException ( offset + i , "Non-zero resolutions require a unit." ) ; } } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, a dot or a digit but saw “" + c + "” instead." ) ; } case INTEGER : if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or “)” but saw “" + c + "” instead." ) ; } case NONZEROINTEGER : if ( c == ')' ) { if ( zero ) { throw newDatatypeException ( offset + i , "Expected a non-zero positive integer." ) ; } state = State . AFTER_CLOSE_PAREN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or “)” but saw “" + c + "” instead." ) ; } case RATIO : if ( isWhitespace ( c ) ) { continue ; } else if ( c == '/' ) { if ( zero ) { throw newDatatypeException ( offset + i , "Expected non-zero positive integer in ratio value." ) ; } valueExpectation = ValueType . NONZEROINTEGER ; state = State . RATIO_SECOND_INTEGER_START ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or" + " “/” for " + feature + " value but saw “" + c + "” instead." ) ; } default : throw new RuntimeException ( "Impossible state." ) ; } } case IN_VALUE_DIGITS_AFTER_DOT : if ( '0' == c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT_TRAIL ; continue ; } else if ( '1' <= c && '9' >= c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT_TRAIL ; zero = false ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit but saw “" + c + "” instead." ) ; } case IN_VALUE_DIGITS_AFTER_DOT_TRAIL : if ( '0' == c ) { continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; continue ; } else { switch ( valueExpectation ) { case LENGTH : case RESOLUTION : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_UNIT ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { if ( ! zero ) { if ( valueExpectation == ValueType . LENGTH ) { throw newDatatypeException ( offset + i , "Non-zero lengths require a unit." ) ; } else { throw newDatatypeException ( offset + i , "Non-zero resolutions require a unit." ) ; } } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, a digit, whitespace or “)” but saw “" + c + "” instead." ) ; } default : throw new RuntimeException ( "Impossible state." ) ; } } case IN_VALUE_UNIT : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( valueExpectation == ValueType . LENGTH ) { if ( ! isLengthUnit ( kw ) ) { throw newDatatypeException ( offset + i , "Expected a length unit but saw “" + c + "” instead." ) ; } } else { if ( ! ( "dpi" . equals ( kw ) || "dpcm" . equals ( kw ) ) ) { throw newDatatypeException ( offset + i , "Expected a resolution unit but saw “" + c + "” instead." ) ; } } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, a dot or a digit but saw “" + c + "” instead." ) ; } case RATIO_SECOND_INTEGER_START : valueExpectation = ValueType . NONZEROINTEGER ; if ( isWhitespace ( c ) ) { continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; state = State . IN_VALUE_DIGITS ; continue ; } else if ( '0' == c ) { zero = true ; state = State . IN_VALUE_DIGITS ; continue ; } else if ( '+' == c ) { state = State . IN_VALUE_BEFORE_DIGITS ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or a plus sign" + " for " + feature + " value but saw “" + c + "” instead." ) ; } case AFTER_CLOSE_PAREN : if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_AND ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_CLOSE_PAREN : if ( isWhitespace ( c ) ) { continue ; } else if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace or “)” but saw “" + c + "” instead." ) ; } } } switch ( state ) { case AFTER_CLOSE_PAREN : case WS_BEFORE_AND : if ( containsAural && WARN ) { warnings . add ( "The media type “aural” is deprecated. Use “speech” instead. " ) ; } return warnings ; case IN_MEDIA_TYPE : String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( isMediaType ( kw ) ) { if ( "aural" . equals ( kw ) && WARN ) { warnings . add ( "The media type “aural” is deprecated. Use “speech” instead. " ) ; } return warnings ; } else { throw newDatatypeException ( "Expected a CSS media type but the query ended." ) ; } default : throw newDatatypeException ( "Media query ended prematurely." ) ; } } private boolean isMediaFeature ( String feature ) { return FEATURES_TO_VALUE_TYPES . containsKey ( feature ) ; } private ValueType valueExpectationFor ( String feature ) { return FEATURES_TO_VALUE_TYPES . get ( feature ) ; } private boolean isMediaType ( String type ) { return MEDIA_TYPES . contains ( type ) ; } private boolean isLengthUnit ( String unit ) { return LENGTH_UNITS . contains ( unit ) ; } private List < String > checkApplicability ( int index , String feature , String type , List < String > warnings ) throws DatatypeException { if ( ! isMediaType ( type ) ) { return warnings ; } if ( ! isMediaFeature ( feature ) ) { throw newDatatypeException ( index , "Expected a CSS media feature but saw “" + feature + "” instead." ) ; } if ( "scan" . equals ( feature ) && ! "tv" . equals ( type ) ) { warnings . add ( scanWarning ) ; return warnings ; } switch ( MediaType . toCaps ( type ) ) { case SPEECH : warnings . add ( "The media feature “" + feature + "” is not applicable to the media type “speech”. " ) ; return warnings ; case BRAILLE : case EMBOSSED : if ( Arrays . binarySearch ( visualFeatures , feature ) > - 1 ) { warnings . add ( "The visual media feature “" + feature + "” is not applicable to the tactile media type “" + type + "”. " ) ; } return warnings ; case TTY : if ( Arrays . binarySearch ( bitmapFeatures , feature ) > - 1 ) { warnings . add ( "The bitmap media feature “" + feature + "” is not applicable to the media type “tty”. " ) ; } return warnings ; default : return warnings ; } } private void checkIfValueRequired ( int index , String feature ) throws DatatypeException { if ( feature . startsWith ( "min-" ) || feature . startsWith ( "max-" ) ) { throw newDatatypeException ( index , "Expected a value for the media feature “" + feature + "”." ) ; } } @ Override public String getName ( ) { return "media query" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
