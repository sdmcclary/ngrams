<<<<<<< HEAD
public class LocalLogWatcher extends AbstractLogWatcher { private class RandomAccessReader extends Reader { private Reader reader ; public RandomAccessReader ( final RandomAccessFile file , long startPos , Charset encoding ) throws IOException { final InputStream stream = new InputStream ( ) { @ Override public int read ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { return file . read ( b , off , len ) ; } @ Override public int read ( byte [ ] b ) throws IOException { return file . read ( b ) ; } } ; file . seek ( startPos ) ; this . reader = new InputStreamReader ( stream , encoding ) ; } @ Override public void close ( ) throws IOException { reader . close ( ) ; } @ Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { return reader . read ( cbuf , off , len ) ; } } private static final int INCREASE_K = 2 ; private final int MEAN_CHARS_PER_STRING = 80 ; private final int MAX_BUFFER = 1024 * 1024 ; private final int LINEAR_BORDER = 64 * 1024 ; private final int estimatedBufferSize ; private char [ ] buffer ; private long lastFileLength ; private boolean wholeFileRead = false ; public LocalLogWatcher ( AbstractLogResource resource , LogWatcherConfiguration config ) { super ( config , resource ) ; estimatedBufferSize = estimateSize ( config . getBacklogRows ( ) , config . getEncoding ( ) ) ; buffer = new char [ estimatedBufferSize ] ; } protected DataChange getData ( ) { RandomAccessFile raFile = null ; try { raFile = new RandomAccessFile ( getLocalResource ( ) . getFile ( ) , "r" ) ; boolean wholeView = false ; if ( raFile . length ( ) == lastFileLength ) { return null ; } else { lastFileLength = raFile . length ( ) ; } int bufLength = readBuffer ( raFile ) ; if ( wholeFileRead ) { return buildChange ( bufLength , 0 , wholeView ) ; } int upperLineOffset ; while ( ( upperLineOffset = checkLinesNumber ( bufLength ) ) == - 1 ) { if ( ! increaseBuffer ( ) ) { return buildChange ( bufLength , 0 , wholeView ) ; } bufLength = readBuffer ( raFile ) ; if ( wholeFileRead ) { return buildChange ( bufLength , 0 , wholeView ) ; } } return buildChange ( bufLength , upperLineOffset , wholeView ) ; } catch ( IOException e ) { notifyListenersResourceAvailable ( false ) ; return null ; } finally { try { if ( raFile != null ) { raFile . close ( ) ; } } catch ( IOException e ) { IdeLog . logError ( LoggingPlugin . getDefault ( ) , Messages . LocalLogWatcher_ERR_Exception , e ) ; } } } private DataChange buildChange ( int bufLength , int upperLineOffset , boolean wholeView ) { int dataLength = bufLength - upperLineOffset ; String data = new String ( buffer , upperLineOffset , dataLength ) ; DataChange change = null ; if ( wholeView ) { change = new DataChange ( data , ( int ) ( lastFileLength - dataLength ) , Integer . MAX_VALUE ) ; } else { change = new DataChange ( data , ( int ) ( lastFileLength - dataLength ) , dataLength ) ; } return change ; } private boolean increaseBuffer ( ) { int currentSize = buffer . length ; if ( currentSize < LINEAR_BORDER ) { currentSize *= INCREASE_K ; } else { currentSize += LINEAR_BORDER ; } if ( currentSize >= MAX_BUFFER ) { return false ; } try { char [ ] newBuffer = new char [ currentSize ] ; buffer = newBuffer ; } catch ( OutOfMemoryError e ) { return false ; } return true ; } private int checkLinesNumber ( int length ) { int okNumberOfLines = getConfiguration ( ) . getBacklogRows ( ) ; int linesNumber = 0 ; List < Integer > linesInfo = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int ch = buffer [ i ] ; switch ( ch ) { case '\r' : if ( i < length - 1 ) { int nextChar = buffer [ i + 1 ] ; if ( nextChar == '\n' ) { i ++ ; } } linesInfo . add ( i ) ; linesNumber ++ ; break ; case '\n' : linesInfo . add ( i ) ; linesNumber ++ ; break ; default : break ; } } if ( linesNumber > okNumberOfLines ) { int diff = linesNumber - okNumberOfLines ; return linesInfo . get ( diff ) + 1 ; } else if ( linesNumber == okNumberOfLines ) { return 0 ; } return - 1 ; } private int readBuffer ( RandomAccessFile raFile ) throws IOException { long startPos = lastFileLength - buffer . length ; if ( startPos < 0 ) { startPos = 0 ; wholeFileRead = true ; } else { wholeFileRead = false ; } Reader reader = new RandomAccessReader ( raFile , startPos , getResource ( ) . getEncoding ( ) ) ; int read = 0 ; int bufPos = 0 ; while ( read != - 1 && bufPos != buffer . length ) { bufPos += read ; read = reader . read ( buffer , bufPos , buffer . length - bufPos ) ; } return bufPos ; } public void resetWatching ( ) { stopWatching ( ) ; lastFileLength = 0 ; wholeFileRead = false ; } protected LocalLogResource getLocalResource ( ) { return ( LocalLogResource ) getResource ( ) ; } private int estimateSize ( int backlogRows , Charset encoding ) { float averageCharsPerByte = encoding . newDecoder ( ) . averageCharsPerByte ( ) ; if ( averageCharsPerByte == 0 ) { return 0 ; } return ( int ) ( ( ( float ) backlogRows ) * ( ( float ) MEAN_CHARS_PER_STRING ) * ( 1f / averageCharsPerByte ) ) ; } } 
=======
public interface Endpoint { boolean acceptSubscriptionChange ( String mode , String topic , String token , int leaseSeconds ) ; void handleDelivery ( String topic , byte [ ] body ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
