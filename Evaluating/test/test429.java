<<<<<<< HEAD
public class JenkinsHash extends Hash { private static long INT_MASK = 0x00000000ffffffffL ; private static long BYTE_MASK = 0x00000000000000ffL ; private static JenkinsHash _instance = new JenkinsHash ( ) ; public static Hash getInstance ( ) { return _instance ; } private static long rot ( long val , int pos ) { return ( ( Integer . rotateLeft ( ( int ) ( val & INT_MASK ) , pos ) ) & INT_MASK ) ; } @ SuppressWarnings ( "fallthrough" ) public int hash ( byte [ ] key , int nbytes , int initval ) { int length = nbytes ; long a , b , c ; a = b = c = ( 0x00000000deadbeefL + length + initval ) & INT_MASK ; int offset = 0 ; for ( ; length > 12 ; offset += 12 , length -= 12 ) { a = ( a + ( key [ offset + 0 ] & BYTE_MASK ) ) & INT_MASK ; a = ( a + ( ( ( key [ offset + 1 ] & BYTE_MASK ) << 8 ) & INT_MASK ) ) & INT_MASK ; a = ( a + ( ( ( key [ offset + 2 ] & BYTE_MASK ) << 16 ) & INT_MASK ) ) & INT_MASK ; a = ( a + ( ( ( key [ offset + 3 ] & BYTE_MASK ) << 24 ) & INT_MASK ) ) & INT_MASK ; b = ( b + ( key [ offset + 4 ] & BYTE_MASK ) ) & INT_MASK ; b = ( b + ( ( ( key [ offset + 5 ] & BYTE_MASK ) << 8 ) & INT_MASK ) ) & INT_MASK ; b = ( b + ( ( ( key [ offset + 6 ] & BYTE_MASK ) << 16 ) & INT_MASK ) ) & INT_MASK ; b = ( b + ( ( ( key [ offset + 7 ] & BYTE_MASK ) << 24 ) & INT_MASK ) ) & INT_MASK ; c = ( c + ( key [ offset + 8 ] & BYTE_MASK ) ) & INT_MASK ; c = ( c + ( ( ( key [ offset + 9 ] & BYTE_MASK ) << 8 ) & INT_MASK ) ) & INT_MASK ; c = ( c + ( ( ( key [ offset + 10 ] & BYTE_MASK ) << 16 ) & INT_MASK ) ) & INT_MASK ; c = ( c + ( ( ( key [ offset + 11 ] & BYTE_MASK ) << 24 ) & INT_MASK ) ) & INT_MASK ; a = ( a - c ) & INT_MASK ; a ^= rot ( c , 4 ) ; c = ( c + b ) & INT_MASK ; b = ( b - a ) & INT_MASK ; b ^= rot ( a , 6 ) ; a = ( a + c ) & INT_MASK ; c = ( c - b ) & INT_MASK ; c ^= rot ( b , 8 ) ; b = ( b + a ) & INT_MASK ; a = ( a - c ) & INT_MASK ; a ^= rot ( c , 16 ) ; c = ( c + b ) & INT_MASK ; b = ( b - a ) & INT_MASK ; b ^= rot ( a , 19 ) ; a = ( a + c ) & INT_MASK ; c = ( c - b ) & INT_MASK ; c ^= rot ( b , 4 ) ; b = ( b + a ) & INT_MASK ; } switch ( length ) { case 12 : c = ( c + ( ( ( key [ offset + 11 ] & BYTE_MASK ) << 24 ) & INT_MASK ) ) & INT_MASK ; case 11 : c = ( c + ( ( ( key [ offset + 10 ] & BYTE_MASK ) << 16 ) & INT_MASK ) ) & INT_MASK ; case 10 : c = ( c + ( ( ( key [ offset + 9 ] & BYTE_MASK ) << 8 ) & INT_MASK ) ) & INT_MASK ; case 9 : c = ( c + ( key [ offset + 8 ] & BYTE_MASK ) ) & INT_MASK ; case 8 : b = ( b + ( ( ( key [ offset + 7 ] & BYTE_MASK ) << 24 ) & INT_MASK ) ) & INT_MASK ; case 7 : b = ( b + ( ( ( key [ offset + 6 ] & BYTE_MASK ) << 16 ) & INT_MASK ) ) & INT_MASK ; case 6 : b = ( b + ( ( ( key [ offset + 5 ] & BYTE_MASK ) << 8 ) & INT_MASK ) ) & INT_MASK ; case 5 : b = ( b + ( key [ offset + 4 ] & BYTE_MASK ) ) & INT_MASK ; case 4 : a = ( a + ( ( ( key [ offset + 3 ] & BYTE_MASK ) << 24 ) & INT_MASK ) ) & INT_MASK ; case 3 : a = ( a + ( ( ( key [ offset + 2 ] & BYTE_MASK ) << 16 ) & INT_MASK ) ) & INT_MASK ; case 2 : a = ( a + ( ( ( key [ offset + 1 ] & BYTE_MASK ) << 8 ) & INT_MASK ) ) & INT_MASK ; case 1 : a = ( a + ( key [ offset + 0 ] & BYTE_MASK ) ) & INT_MASK ; break ; case 0 : return ( int ) ( c & INT_MASK ) ; } c ^= b ; c = ( c - rot ( b , 14 ) ) & INT_MASK ; a ^= c ; a = ( a - rot ( c , 11 ) ) & INT_MASK ; b ^= a ; b = ( b - rot ( a , 25 ) ) & INT_MASK ; c ^= b ; c = ( c - rot ( b , 16 ) ) & INT_MASK ; a ^= c ; a = ( a - rot ( c , 4 ) ) & INT_MASK ; b ^= a ; b = ( b - rot ( a , 14 ) ) & INT_MASK ; c ^= b ; c = ( c - rot ( b , 24 ) ) & INT_MASK ; return ( int ) ( c & INT_MASK ) ; } public static void main ( String [ ] args ) throws IOException { if ( args . length != 1 ) { System . err . println ( "Usage: JenkinsHash filename" ) ; System . exit ( - 1 ) ; } FileInputStream in = new FileInputStream ( args [ 0 ] ) ; byte [ ] bytes = new byte [ 512 ] ; int value = 0 ; JenkinsHash hash = new JenkinsHash ( ) ; for ( int length = in . read ( bytes ) ; length > 0 ; length = in . read ( bytes ) ) { value = hash . hash ( bytes , length , value ) ; } System . out . println ( Math . abs ( value ) ) ; } } 
=======
final class ColumnRange { private final Locator locator ; private final String element ; private int left ; private int right ; private ColumnRange next ; public ColumnRange ( String element , Locator locator , int left , int right ) { super ( ) ; assert right > left ; this . element = element ; this . locator = locator ; this . left = left ; this . right = right ; this . next = null ; } String getElement ( ) { return element ; } Locator getLocator ( ) { return locator ; } int hits ( int column ) { if ( column < left ) { return - 1 ; } if ( column >= right ) { return 1 ; } else { return 0 ; } } ColumnRange removeColumn ( int column ) { if ( isSingleCol ( ) ) { return null ; } else if ( column == left ) { left ++ ; return this ; } else if ( column + 1 == right ) { right -- ; return this ; } else { ColumnRange created = new ColumnRange ( this . element , this . locator , column + 1 , this . right ) ; created . next = this . next ; this . next = created ; this . right = column ; return created ; } } ColumnRange getNext ( ) { return next ; } void setNext ( ColumnRange next ) { this . next = next ; } boolean isSingleCol ( ) { return left + 1 == right ; } public String toString ( ) { if ( isSingleCol ( ) ) { return Integer . toString ( right ) ; } else { return ( left + 1 ) + "â€¦" + ( right ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
