<<<<<<< HEAD
public final class StartTag extends Tag { private Attributes attributes ; private SpecialTag specialTag ; static final StartTag CACHED_NULL = new StartTag ( ) ; private StartTag ( Source source , int begin , int end , String name , SpecialTag specialTag , Attributes attributes ) { super ( source , begin , end , name ) ; this . attributes = attributes ; this . specialTag = specialTag ; } private StartTag ( ) { } private static StartTag constructWithAttributes ( Source source , int begin , String name , SpecialTag specialTag ) { Attributes attributes = Attributes . construct ( source , begin , name ) ; if ( attributes == null ) return null ; String lsource = source . getParseTextLowerCase ( ) ; int end = attributes . end + ( lsource . charAt ( attributes . end ) == '>' ? 1 : 2 ) ; if ( name . equals ( SpecialTag . COMMENT . getName ( ) ) ) name = SpecialTag . COMMENT . getName ( ) ; StartTag startTag = new StartTag ( source , begin , end , name , specialTag , attributes ) ; return startTag ; } public boolean isEndTagForbidden ( ) { return isEmptyElementTag ( ) || ( specialTag != null && ! specialTag . hasEndTag ( ) ) || isEndTagForbidden ( name ) ; } public boolean isEndTagOptional ( ) { return isEndTagOptional ( name ) ; } public boolean isEndTagRequired ( ) { return isEndTagRequired ( name ) ; } public boolean isEmptyElementTag ( ) { return source . getSourceText ( ) . charAt ( end - 2 ) == '/' ; } public boolean isComment ( ) { return specialTag == SpecialTag . COMMENT ; } public boolean isProcessingInstruction ( ) { return name . charAt ( 0 ) == '?' ; } public boolean isXMLDeclaration ( ) { return name == Tag . XML_DECLARATION ; } public boolean isDocTypeDeclaration ( ) { return name == Tag . DOCTYPE_DECLARATION ; } public boolean isServerTag ( ) { return specialTag != null && specialTag . isServerTag ( ) ; } public boolean isPHPTag ( ) { return specialTag == SpecialTag . PHP_TAG ; } public boolean isCommonServerTag ( ) { return specialTag == SpecialTag . COMMON_SERVER_TAG ; } public boolean isMasonTag ( ) { return isCommonServerTag ( ) || isMasonNamedBlock ( ) || isMasonComponentCall ( ) || isMasonComponentCalledWithContent ( ) ; } public boolean isMasonNamedBlock ( ) { return specialTag == SpecialTag . MASON_NAMED_BLOCK ; } public boolean isMasonComponentCall ( ) { return specialTag == SpecialTag . MASON_COMPONENT_CALL ; } public boolean isMasonComponentCalledWithContent ( ) { return specialTag == SpecialTag . MASON_COMPONENT_CALLED_WITH_CONTENT ; } public Attributes getAttributes ( ) { return attributes ; } public Attributes parseAttributes ( ) { return parseAttributes ( Attributes . getDefaultMaxErrorCount ( ) ) ; } public Attributes parseAttributes ( int maxErrorCount ) { if ( attributes != null ) return attributes ; int maxEnd = end - ( specialTag != null ? specialTag . getEndDelimiter ( ) . length ( ) : 1 ) ; int attributesBegin = begin + 1 + name . length ( ) ; while ( ! isIdentifierStart ( source . getSourceText ( ) . charAt ( attributesBegin ) ) ) { attributesBegin ++ ; if ( attributesBegin == maxEnd ) return null ; } return Attributes . construct ( source , begin , attributesBegin , maxEnd , name , maxErrorCount ) ; } public FormControlType getFormControlType ( ) { if ( isComment ( ) || ! FormControlType . isPotentialControl ( name ) ) return null ; if ( name . equals ( TEXTAREA ) ) return FormControlType . TEXTAREA ; Attributes attributes = getAttributes ( ) ; if ( name . equals ( SELECT ) ) { Attribute multiple = attributes . get ( "multiple" ) ; return multiple != null ? FormControlType . SELECT_MULTIPLE : FormControlType . SELECT_SINGLE ; } Attribute type = attributes . get ( "type" ) ; if ( name . equals ( "button" ) ) return ( type == null || type . getValue ( ) . equalsIgnoreCase ( "submit" ) ) ? FormControlType . BUTTON : null ; if ( type == null ) return FormControlType . TEXT ; return FormControlType . get ( type . getValue ( ) . toLowerCase ( ) ) ; } public Segment getFollowingTextSegment ( ) { int endData = source . getParseTextLowerCase ( ) . indexOf ( '<' , end ) ; if ( endData == - 1 ) endData = source . length ( ) ; return new Segment ( source , end , endData ) ; } public EndTag findEndTag ( ) { return getElement ( ) . getEndTag ( ) ; } public Element getElement ( ) { String cacheKey = SearchCache . getElementKey ( this ) ; Element element = source . getSearchCache ( ) . getElement ( cacheKey ) ; if ( element == null ) { element = new Element ( source , this , findEndTagInternal ( ) ) ; source . getSearchCache ( ) . setElement ( cacheKey , element ) ; } return element ; } private EndTag findEndTagInternal ( ) { if ( isEndTagForbidden ( ) ) return null ; TerminatorSets terminatorSets = getOptionalEndTagTerminatorSets ( ) ; if ( terminatorSets != null ) return findOptionalEndTag ( terminatorSets ) ; String endTagName = name == Tag . SERVER_MASON_COMPONENT_CALLED_WITH_CONTENT ? "&" : name ; Segment [ ] findResult = findEndTag ( source . getParseTextLowerCase ( ) , source . findNextEndTag ( end , endTagName ) ) ; if ( findResult == null ) return null ; return ( EndTag ) findResult [ 0 ] ; } public String toString ( ) { if ( this == CACHED_NULL ) return "CACHED_NULL" ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( '"' ) . append ( name ) . append ( "\" " ) ; if ( specialTag != null ) sb . append ( '(' ) . append ( specialTag . getDescription ( ) ) . append ( ") " ) ; sb . append ( super . toString ( ) ) ; return sb . toString ( ) ; } private EndTag findOptionalEndTag ( TerminatorSets terminatorSets ) { Iterator i = source . getNextTagIterator ( end ) ; while ( i . hasNext ( ) ) { Tag tag = ( Tag ) i . next ( ) ; Set terminatorSet ; if ( tag instanceof EndTag ) { if ( tag . name . equals ( name ) ) return ( EndTag ) tag ; terminatorSet = terminatorSets . getEndTagTerminatorSet ( ) ; } else { terminatorSet = terminatorSets . getIgnoredNestedElementSet ( ) ; if ( terminatorSet != null && terminatorSet . contains ( tag . name ) ) { Element ignoredNestedElement = ( ( StartTag ) tag ) . getElement ( ) ; i = source . getNextTagIterator ( ignoredNestedElement . end ) ; continue ; } terminatorSet = terminatorSets . getStartTagTerminatorSet ( ) ; } if ( terminatorSet != null && terminatorSet . contains ( tag . name ) ) return new EndTag ( source , tag . begin , tag . begin , name ) ; } return new EndTag ( source , source . end , source . end , name ) ; } static StartTag findPreviousOrNext ( Source source , int pos , String name , boolean previous ) { String cacheKey = SearchCache . getStartTagKey ( pos , name , previous ) ; StartTag startTag = source . getSearchCache ( ) . getStartTag ( cacheKey ) ; if ( startTag == null ) { Tag tag = ( Tag ) source . getSearchCache ( ) . getTag ( SearchCache . getTagKey ( pos ) ) ; if ( ( tag instanceof StartTag ) && ( name == null || name . equals ( tag . name ) ) ) return ( StartTag ) tag ; startTag = findPreviousOrNextUncached ( source , pos , name , previous ) ; source . getSearchCache ( ) . setStartTag ( cacheKey , startTag ) ; if ( startTag != null && name == null ) { source . getSearchCache ( ) . setStartTag ( SearchCache . getStartTagKey ( pos , startTag . name , previous ) , startTag ) ; } } return startTag == CACHED_NULL ? null : startTag ; } private static StartTag findPreviousOrNextUncached ( Source source , int pos , String searchName , boolean previous ) { if ( searchName == null ) return findPreviousOrNext ( source , pos , previous ) ; String startDelimiter ; boolean namespaceSearch = ( searchName . charAt ( searchName . length ( ) - 1 ) == ':' ) ; SpecialTag searchSpecialTag = namespaceSearch ? null : SpecialTag . get ( searchName ) ; if ( searchSpecialTag != null ) { searchName = searchSpecialTag . getName ( ) ; startDelimiter = searchSpecialTag . getStartDelimiter ( ) ; } else { searchName = searchName . toLowerCase ( ) ; startDelimiter = '<' + searchName ; } try { String lsource = source . getParseTextLowerCase ( ) ; int begin = pos ; int nameEnd ; do { begin = previous ? lsource . lastIndexOf ( startDelimiter , begin ) : lsource . indexOf ( startDelimiter , begin ) ; if ( begin == - 1 ) return null ; Segment enclosingComment = source . findEnclosingComment ( begin - 1 ) ; if ( enclosingComment != null ) { if ( searchSpecialTag == SpecialTag . COMMENT && previous ) return ( StartTag ) enclosingComment ; begin = previous ? enclosingComment . begin - 2 : enclosingComment . end ; continue ; } int searchNameEnd = begin + startDelimiter . length ( ) ; SpecialTag specialTag = searchSpecialTag ; String name = searchName ; if ( searchSpecialTag == SpecialTag . COMMENT ) { nameEnd = searchNameEnd ; } else { nameEnd = source . getIdentifierEnd ( searchNameEnd , false ) ; if ( nameEnd == - 1 ) { nameEnd = searchNameEnd ; } else if ( nameEnd != searchNameEnd ) { if ( namespaceSearch ) { name = lsource . substring ( begin + 1 , nameEnd ) ; } else { if ( specialTag == null || ! specialTag . isIdentifierCharacterAllowedAfterName ( ) ) continue ; name = lsource . substring ( begin + 1 , nameEnd ) ; specialTag = SpecialTag . get ( name ) ; if ( specialTag == null ) specialTag = searchSpecialTag ; else name = specialTag . getName ( ) ; } } } if ( specialTag != null && specialTag != SpecialTag . XML_DECLARATION ) { int end = source . findEnd ( nameEnd , specialTag ) ; if ( specialTag == SpecialTag . COMMON_SERVER_TAG && nameEnd != searchNameEnd ) { int masonNamedBlockEnd = source . findEnd ( nameEnd , SpecialTag . MASON_NAMED_BLOCK ) ; if ( masonNamedBlockEnd != - 1 && ( end == - 1 || masonNamedBlockEnd < end ) ) { EndTag endTag = source . findNextEndTag ( masonNamedBlockEnd , name ) ; if ( endTag != null ) return new StartTag ( source , begin , masonNamedBlockEnd , name , SpecialTag . MASON_NAMED_BLOCK , null ) ; } } if ( end == - 1 ) { source . log ( "StartTag" , name , begin , "rejected because it has no matching end delimiter" , - 1 ) ; if ( ! previous ) return null ; begin = begin - 4 ; continue ; } if ( specialTag == SpecialTag . MASON_NAMED_BLOCK ) { if ( nameEnd == searchNameEnd ) continue ; if ( lsource . charAt ( end - 2 ) == '%' ) continue ; EndTag endTag = source . findNextEndTag ( end , name ) ; if ( endTag == null ) continue ; } else if ( specialTag == SpecialTag . MASON_COMPONENT_CALL && lsource . charAt ( nameEnd ) == '|' ) { specialTag = SpecialTag . MASON_COMPONENT_CALLED_WITH_CONTENT ; name = specialTag . getName ( ) ; } return new StartTag ( source , begin , end , name , specialTag , null ) ; } StartTag startTag = constructWithAttributes ( source , begin , name , specialTag ) ; if ( startTag != null ) return startTag ; } while ( inRange ( source , begin = previous ? begin - 2 : begin + 1 ) ) ; } catch ( IndexOutOfBoundsException ex ) { } return null ; } private static StartTag findPreviousOrNext ( Source source , int pos , boolean previous ) { try { StartTag previousComment = source . findPreviousStartTag ( pos , SpecialTag . COMMENT . getName ( ) ) ; if ( previousComment != null ) { if ( previousComment . end > pos ) { if ( previous ) return previousComment ; pos = previousComment . end ; } if ( ! previous ) previousComment = null ; } String lsource = source . getParseTextLowerCase ( ) ; int begin = pos ; do { begin = previous ? lsource . lastIndexOf ( '<' , begin ) : lsource . indexOf ( '<' , begin ) ; if ( begin == - 1 ) return null ; if ( previousComment != null && previousComment . encloses ( begin ) ) return previousComment ; String tagAtCacheKey = SearchCache . getTagKey ( begin ) ; Tag tag = ( Tag ) source . getSearchCache ( ) . getTag ( tagAtCacheKey ) ; if ( tag instanceof StartTag ) return ( StartTag ) tag ; if ( tag != null || lsource . charAt ( begin + 1 ) == '/' ) continue ; int nameBegin = begin + 1 ; int nameEnd ; String name = null ; StartTag startTag = null ; SpecialTag specialTag = SpecialTag . get ( source , nameBegin ) ; try { if ( specialTag != null ) { startTag = newSpecialStartTag ( source , begin , nameBegin , specialTag ) ; if ( startTag != null ) return startTag ; continue ; } nameEnd = source . getIdentifierEnd ( nameBegin , true ) ; if ( nameEnd == - 1 ) { source . log ( "StartTag" , null , begin , "rejected because it has an invalid first character in its name" , - 1 ) ; continue ; } name = lsource . substring ( nameBegin , nameEnd ) ; startTag = constructWithAttributes ( source , begin , name , null ) ; if ( startTag != null ) return startTag ; } finally { source . getSearchCache ( ) . setTag ( tagAtCacheKey , startTag ) ; } } while ( inRange ( source , begin += ( previous ? - 2 : 2 ) ) ) ; } catch ( IndexOutOfBoundsException ex ) { } return null ; } private static StartTag newSpecialStartTag ( Source source , int begin , int nameBegin , SpecialTag specialTag ) { String name ; int end = - 1 ; String lsource = source . getParseTextLowerCase ( ) ; if ( specialTag == SpecialTag . COMMON_SERVER_TAG ) { int nameEnd = source . getIdentifierEnd ( nameBegin + 1 , true ) ; if ( nameEnd != - 1 ) { name = lsource . substring ( nameBegin , nameEnd ) ; end = source . findEnd ( nameEnd , SpecialTag . MASON_NAMED_BLOCK ) ; if ( end == - 1 ) { source . log ( "StartTag" , specialTag . getName ( ) , begin , "rejected because it has no matching end delimiter" , - 1 ) ; return null ; } EndTag endTag = source . findNextEndTag ( end , name ) ; if ( endTag != null ) return new StartTag ( source , begin , end , name , SpecialTag . MASON_NAMED_BLOCK , null ) ; } } end = source . findEnd ( nameBegin + 1 , specialTag ) ; if ( end == - 1 ) { source . log ( "StartTag" , specialTag . getName ( ) , begin , "rejected because it has no matching end delimiter" , - 1 ) ; return null ; } name = specialTag . getName ( ) ; if ( specialTag == SpecialTag . XML_DECLARATION ) return constructWithAttributes ( source , begin , name , specialTag ) ; return new StartTag ( source , begin , end , name , specialTag , null ) ; } private static boolean inRange ( Source source , int pos ) { return pos >= 0 && pos <= source . length ( ) ; } private Segment [ ] findEndTag ( String lsource , EndTag nextEndTag ) { return findEndTag ( lsource , end , source . findNextStartTag ( end , name ) , nextEndTag ) ; } private Segment [ ] findEndTag ( String lsource , int afterPos , StartTag nextStartTag , EndTag nextEndTag ) { if ( nextEndTag == null ) return null ; Segment [ ] returnArray = { nextEndTag , nextStartTag } ; if ( nextStartTag == null || nextStartTag . begin > nextEndTag . begin ) return returnArray ; Segment [ ] findResult = nextStartTag . findEndTag ( lsource , nextEndTag ) ; if ( findResult == null ) return null ; EndTag nextStartTagsEndTag = ( EndTag ) findResult [ 0 ] ; nextStartTag = ( StartTag ) findResult [ 1 ] ; nextEndTag = source . findNextEndTag ( nextStartTagsEndTag . end , name ) ; return findEndTag ( lsource , nextStartTagsEndTag . end , nextStartTag , nextEndTag ) ; } } 
=======
public interface SchemaReceiverFactory { static final PropertyId < SchemaReceiverFactory > PROPERTY = PropertyId . newInstance ( "SCHEMA_RECEIVER_FACTORY" , SchemaReceiverFactory . class ) ; SchemaReceiver createSchemaReceiver ( String namespaceUri , PropertyMap properties ) ; Option getOption ( String uri ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
