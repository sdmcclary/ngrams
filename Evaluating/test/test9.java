public class GitInterceptor extends VCSInterceptor { private final StatusCache cache ; private ConcurrentHashMap < File , File > dirsToDelete = new ConcurrentHashMap < File , File > ( ) ; private ConcurrentLinkedQueue < File > filesToRefresh = new ConcurrentLinkedQueue < File > ( ) ; private RequestProcessor . Task refreshTask ; private static final RequestProcessor refresh = new RequestProcessor ( "GitRefresh" , 1 , true ) ; public GitInterceptor ( ) { cache = Git . getInstance ( ) . getStatusCache ( ) ; refreshTask = refresh . create ( new RefreshTask ( ) ) ; } @ Override public boolean beforeDelete ( File file ) { if ( file == null ) { return true ; } if ( GitUtils . isPartOfGitMetadata ( file ) ) { return false ; } if ( file . isDirectory ( ) ) { for ( File dir : dirsToDelete . keySet ( ) ) { if ( file . equals ( dir . getParentFile ( ) ) ) { dirsToDelete . remove ( dir ) ; } } if ( Excludes . isSharable ( file ) ) { dirsToDelete . put ( file , file ) ; } } return true ; } @ Override public void doDelete ( File file ) throws IOException { } @ Override public void afterDelete ( final File file ) { Utils . post ( new Runnable ( ) { public void run ( ) { fileDeletedImpl ( file ) ; } } ) ; } private void fileDeletedImpl ( final File file ) { if ( file == null || ! file . exists ( ) ) { return ; } Git git = Git . getInstance ( ) ; final File root = git . getTopmostManagedParent ( file ) ; RequestProcessor rp = null ; if ( root != null ) { rp = git . getRequestProcessor ( root . getAbsolutePath ( ) ) ; } if ( file . isDirectory ( ) ) { file . delete ( ) ; if ( ! dirsToDelete . remove ( file , file ) ) { return ; } if ( root == null ) { return ; } GitProgressSupport support = new GitProgressSupport ( ) { public void perform ( ) { remove ( ) ; Map < File , StatusInfo > interestingFiles = GitCommand . getInterestingStatus ( root , file ) ; if ( ! interestingFiles . isEmpty ( ) ) { Collection < File > files = interestingFiles . keySet ( ) ; Map < File , Map < File , StatusInfo > > interestingDirs = GitUtils . getInterestingDirs ( interestingFiles , files ) ; for ( File tmpFile : files ) { if ( this . isCanceled ( ) ) { return ; } StatusInfo fi = interestingFiles . get ( tmpFile ) ; cache . refreshFileStatus ( tmpFile , fi , interestingDirs . get ( tmpFile . isDirectory ( ) ? tmpFile : tmpFile . getParentFile ( ) ) , true ) ; } } } private void remove ( ) { try { IndexBuilder . create ( root ) . delete ( file ) . write ( ) ; } catch ( Exception ex ) { getLogger ( ) . output ( ex . getMessage ( ) ) ; } } } ; support . start ( rp , root . getAbsolutePath ( ) , org . openide . util . NbBundle . getMessage ( GitInterceptor . class , "MSG_Remove_Progress" ) ) ; } else { file . delete ( ) ; if ( root == null ) { return ; } for ( File dir : dirsToDelete . keySet ( ) ) { File tmpFile = file . getParentFile ( ) ; while ( tmpFile != null ) { if ( tmpFile . equals ( dir ) ) { return ; } tmpFile = tmpFile . getParentFile ( ) ; } } GitProgressSupport support = new GitProgressSupport ( ) { public void perform ( ) { try { IndexBuilder . create ( root ) . delete ( file ) . write ( ) ; cache . refresh ( file , StatusCache . REPOSITORY_STATUS_UNKNOWN ) ; } catch ( Exception ex ) { getLogger ( ) . output ( ex . getMessage ( ) ) ; } } } ; support . start ( rp , root . getAbsolutePath ( ) , org . openide . util . NbBundle . getMessage ( GitInterceptor . class , "MSG_Remove_Progress" ) ) ; } } @ Override public boolean beforeMove ( File from , File to ) { if ( from == null || to == null || to . exists ( ) ) { return true ; } Git git = Git . getInstance ( ) ; if ( git . isManaged ( from ) ) { return git . isManaged ( to ) ; } return super . beforeMove ( from , to ) ; } @ Override public void doMove ( final File from , final File to ) throws IOException { if ( from == null || to == null || to . exists ( ) ) { return ; } if ( SwingUtilities . isEventDispatchThread ( ) ) { Git . LOG . log ( Level . INFO , "Warning: launching external process in AWT" , new Exception ( ) . fillInStackTrace ( ) ) ; final Throwable innerT [ ] = new Throwable [ 1 ] ; Runnable outOfAwt = new Runnable ( ) { public void run ( ) { try { gitMoveImplementation ( from , to ) ; } catch ( Throwable t ) { innerT [ 0 ] = t ; } } } ; Git . getInstance ( ) . getRequestProcessor ( ) . post ( outOfAwt ) . waitFinished ( ) ; if ( innerT [ 0 ] != null ) { if ( innerT [ 0 ] instanceof IOException ) { throw ( IOException ) innerT [ 0 ] ; } else if ( innerT [ 0 ] instanceof RuntimeException ) { throw ( RuntimeException ) innerT [ 0 ] ; } else if ( innerT [ 0 ] instanceof Error ) { throw ( Error ) innerT [ 0 ] ; } else { throw new IllegalStateException ( "Unexpected exception class: " + innerT [ 0 ] ) ; } } } else { gitMoveImplementation ( from , to ) ; } } private void gitMoveImplementation ( final File srcFile , final File dstFile ) throws IOException { final Git git = Git . getInstance ( ) ; final File root = git . getTopmostManagedParent ( srcFile ) ; if ( root == null ) { return ; } RequestProcessor rp = git . getRequestProcessor ( root . getAbsolutePath ( ) ) ; Git . LOG . log ( Level . FINE , "gitMoveImplementation(): File: {0} {1}" , new Object [ ] { srcFile , dstFile } ) ; srcFile . renameTo ( dstFile ) ; Runnable moveImpl = new Runnable ( ) { public void run ( ) { OutputLogger logger = OutputLogger . getLogger ( root . getAbsolutePath ( ) ) ; try { if ( dstFile . isDirectory ( ) ) throw new IllegalStateException ( "Rename of directory " + dstFile ) ; int status = GitCommand . getSingleStatus ( root , srcFile ) . getStatus ( ) ; Git . LOG . log ( Level . FINE , "gitMoveImplementation(): Status: {0} {1}" , new Object [ ] { srcFile , status } ) ; if ( status == StatusInfo . STATUS_NOTVERSIONED_NEWLOCALLY || status == StatusInfo . STATUS_NOTVERSIONED_EXCLUDED ) { } else if ( status == StatusInfo . STATUS_VERSIONED_ADDEDLOCALLY ) { IndexBuilder . create ( root ) . move ( srcFile , dstFile ) . write ( ) ; } else { throw new IllegalStateException ( "Rename with status " + status ) ; } } catch ( Exception e ) { logger . output ( e . getMessage ( ) ) ; Git . LOG . log ( Level . FINE , "Git failed to rename: File: {0} {1}" , new Object [ ] { srcFile . getAbsolutePath ( ) , dstFile . getAbsolutePath ( ) } ) ; } finally { logger . closeLog ( ) ; } } } ; rp . post ( moveImpl ) ; } @ Override public void afterMove ( final File from , final File to ) { Utils . post ( new Runnable ( ) { public void run ( ) { fileMovedImpl ( from , to ) ; } } ) ; } private void fileMovedImpl ( final File from , final File to ) { if ( from == null || to == null || ! to . exists ( ) ) { return ; } if ( to . isDirectory ( ) ) { return ; } Git git = Git . getInstance ( ) ; final File root = git . getTopmostManagedParent ( from ) ; if ( root == null ) { return ; } RequestProcessor rp = git . getRequestProcessor ( root . getAbsolutePath ( ) ) ; GitProgressSupport supportCreate = new GitProgressSupport ( ) { public void perform ( ) { cache . refresh ( from , StatusCache . REPOSITORY_STATUS_UNKNOWN ) ; cache . refresh ( to , StatusCache . REPOSITORY_STATUS_UNKNOWN ) ; } } ; supportCreate . start ( rp , root . getAbsolutePath ( ) , org . openide . util . NbBundle . getMessage ( GitInterceptor . class , "MSG_Move_Progress" ) ) ; } @ Override public boolean beforeCreate ( File file , boolean isDirectory ) { return super . beforeCreate ( file , isDirectory ) ; } @ Override public void doCreate ( File file , boolean isDirectory ) throws IOException { super . doCreate ( file , isDirectory ) ; } @ Override public void afterCreate ( final File file ) { Utils . post ( new Runnable ( ) { public void run ( ) { fileCreatedImpl ( file ) ; } } ) ; } private void fileCreatedImpl ( final File file ) { if ( file . isDirectory ( ) ) { return ; } Git git = Git . getInstance ( ) ; final File root = git . getTopmostManagedParent ( file ) ; if ( root == null ) { return ; } RequestProcessor rp = git . getRequestProcessor ( root . getAbsolutePath ( ) ) ; GitProgressSupport supportCreate = new GitProgressSupport ( ) { public void perform ( ) { reScheduleRefresh ( file ) ; } } ; supportCreate . start ( rp , root . getAbsolutePath ( ) , org . openide . util . NbBundle . getMessage ( GitInterceptor . class , "MSG_Create_Progress" ) ) ; } @ Override public void afterChange ( final File file ) { Utils . post ( new Runnable ( ) { public void run ( ) { fileChangedImpl ( file ) ; } } ) ; } private void fileChangedImpl ( final File file ) { if ( file . isDirectory ( ) ) { return ; } Git git = Git . getInstance ( ) ; final File root = git . getTopmostManagedParent ( file ) ; if ( root == null ) { return ; } RequestProcessor rp = git . getRequestProcessor ( root . getAbsolutePath ( ) ) ; GitProgressSupport supportCreate = new GitProgressSupport ( ) { public void perform ( ) { Git . LOG . log ( Level . FINE , "fileChangedImpl(): File: {0}" , file ) ; reScheduleRefresh ( file ) ; } } ; supportCreate . start ( rp , root . getAbsolutePath ( ) , org . openide . util . NbBundle . getMessage ( GitInterceptor . class , "MSG_Change_Progress" ) ) ; } private void reScheduleRefresh ( File fileToRefresh ) { if ( Excludes . isIgnored ( fileToRefresh , false ) ) { return ; } if ( ! filesToRefresh . contains ( fileToRefresh ) ) { if ( ! filesToRefresh . offer ( fileToRefresh ) ) { Git . LOG . log ( Level . FINE , "reScheduleRefresh failed to add to filesToRefresh queue {0}" , fileToRefresh ) ; } } refreshTask . schedule ( 1000 ) ; } private class RefreshTask implements Runnable { public void run ( ) { Thread . interrupted ( ) ; File fileToRefresh = filesToRefresh . poll ( ) ; if ( fileToRefresh != null ) { cache . refresh ( fileToRefresh , StatusCache . REPOSITORY_STATUS_UNKNOWN ) ; fileToRefresh = filesToRefresh . peek ( ) ; if ( fileToRefresh != null ) { refreshTask . schedule ( 0 ) ; } } } } } 