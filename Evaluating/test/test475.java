<<<<<<< HEAD
public final class MiniLZO implements LZOConstants { public static final int c_top_loop = 1 ; public static final int c_first_literal_run = 2 ; public static final int c_match = 3 ; public static final int c_copy_match = 4 ; public static final int c_match_done = 5 ; public static final int c_match_next = 6 ; public static final int c_eof_found = 7 ; public static final int c_input_overrun = 8 ; public static final int c_output_overrun = 9 ; public static final int c_lookbehind_overrun = 10 ; public static final int c0_top = 1 ; public static final int c0_try_match = 2 ; public static final int c0_literal = 3 ; public static final int c0_match = 4 ; public static final int c0_m3_m4_len = 5 ; public static final int c0_m3_m4_offset = 6 ; public static final int c0_last = 7 ; private static final boolean debug = false ; private static final int U ( byte b ) { return b & 0xff ; } public static void main ( String [ ] args ) { final int ZERO_FILL = Integer . getInteger ( "ZERO_FILL" , 0 ) ; final String IFILE = System . getProperty ( "IFILE" , "IFILE" ) ; final String OFILE = System . getProperty ( "OFILE" , "IFILE" ) ; try { File fComp_ = new File ( OFILE ) ; long len = fComp_ . length ( ) ; byte [ ] buf = new byte [ ( int ) len ] ; File fUnComp_ = new File ( IFILE ) ; byte [ ] out = new byte [ ( int ) fUnComp_ . length ( ) ] ; byte [ ] out_ori = new byte [ ( int ) fUnComp_ . length ( ) ] ; FileInputStream fComp = new FileInputStream ( fComp_ ) ; FileInputStream fUnComp = new FileInputStream ( IFILE ) ; int ret = fComp . read ( buf ) ; if ( ret > 0 ) { MInt out_len = new MInt ( ) ; System . out . println ( "Decompressing byte.length=" + len ) ; int r = lzo1x_decompress ( buf , ( int ) len , out , out_len ) ; System . out . println ( "Got decompressed length:" + out_len . v ) ; if ( ZERO_FILL > 0 ) { System . out . println ( "Doing zero fill check" ) ; for ( int i = 0 ; i < out_len . v ; i ++ ) { if ( out [ i ] != 0 ) { throw new AssertionError ( "Decompreesed values not matching to Zero @:" + i ) ; } } } else { ret = fUnComp . read ( out_ori ) ; for ( int i = 0 ; i < out_len . v ; i ++ ) { if ( out [ i ] != out_ori [ i ] ) { throw new AssertionError ( "Decompreesed values not matching to Zero @:" + i ) ; } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private final static int _lzo1x_1_do_compress ( final byte [ ] in , final int in_len , final byte [ ] out , MInt out_len , int [ ] dict ) { int ip = 0 ; int in_base = 0 ; int out_base = 0 ; int op ; int in_end = in_base + in_len ; int ip_end = in_base + in_len - 8 - 5 ; int ii = 0 ; int state = c0_top ; op = out_base ; ip = in_base ; ii = ip ; ip += 4 ; int m_pos = in_base ; int m_off = in_base ; int m_len = 0 ; int dindex = 0 ; loop0 : for ( ; ; ) { switch ( state ) { case c0_top : dindex = ( ( ( ( ( int ) ( ( 0x21 ) * ( ( ( ( ( ( ( ( int ) ( ( in [ ip + 1 + 2 + 1 ] & 0xff ) << ( 6 ) ) ^ ( in [ ip + 1 + 1 + 1 ] & 0xff ) << ( 5 ) ) ^ ( in [ ip + 1 + 0 ] & 0xff ) << ( 5 ) ) ^ ( in [ ip + 0 ] & 0xff ) ) ) ) ) > > 5 ) & ( ( ( 1 << ( 14 ) ) - 1 ) > > ( 0 ) ) ) << ( 0 ) ) ) ) ) ; m_pos = dict [ dindex ] ; m_pos = ip - ( ip - m_pos ) ; if ( ( m_pos <= in_base ) || ( ( m_off = ( ip - m_pos ) ) <= 0 ) || ( m_off > 0xbfff ) ) { if ( debug ) System . out . println ( "1:m_pos:" + m_pos + ", ip:" + ip + ", m_off:" + m_off ) ; state = c0_literal ; continue loop0 ; } if ( m_off <= 0x0800 || in [ m_pos + 3 ] == in [ ip + 3 ] ) { state = c0_try_match ; continue loop0 ; } dindex = ( dindex & ( ( ( 1 << ( 14 ) ) - 1 ) & 0x7ff ) ) ^ ( ( ( ( ( 1 << ( 14 ) ) - 1 ) > > 1 ) + 1 ) | 0x1f ) ; m_pos = dict [ dindex ] ; if ( ( m_pos < in_base ) || ( m_off = ( ip - m_pos ) ) <= 0 || m_off > 0xbfff ) { state = c0_literal ; continue loop0 ; } if ( m_off <= 0x0800 || in [ m_pos + 3 ] == in [ ip + 3 ] ) { state = c0_try_match ; continue loop0 ; } state = c0_literal ; continue loop0 ; case c0_try_match : if ( in [ m_pos ] != in [ ip ] || in [ m_pos + 1 ] != in [ ip + 1 ] ) { } else { if ( in [ m_pos + 2 ] == in [ ip + 2 ] ) { state = c0_match ; continue loop0 ; } } case c0_literal : dict [ dindex ] = ( ip ) ; ip ++ ; if ( ip >= ip_end ) break loop0 ; state = c0_top ; continue loop0 ; case c0_match : dict [ dindex ] = ( ip ) ; if ( ( ip - ii ) > 0 ) { int t = ip - ii ; if ( t <= 3 ) { out [ op - 2 ] |= ( byte ) t ; } else if ( t <= 18 ) { out [ op ++ ] = ( byte ) ( t - 3 ) ; } else { int tt = t - 18 ; out [ op ++ ] = 0 ; while ( tt > 255 ) { tt -= 255 ; out [ op ++ ] = 0 ; } out [ op ++ ] = ( byte ) tt ; } do out [ op ++ ] = in [ ii ++ ] ; while ( -- t > 0 ) ; } ip += 3 ; if ( in [ m_pos + 3 ] != in [ ip ++ ] || in [ m_pos + 4 ] != in [ ip ++ ] || in [ m_pos + 5 ] != in [ ip ++ ] || in [ m_pos + 6 ] != in [ ip ++ ] || in [ m_pos + 7 ] != in [ ip ++ ] || in [ m_pos + 8 ] != in [ ip ++ ] ) { -- ip ; m_len = ip - ii ; if ( m_off <= 0x0800 ) { m_off -= 1 ; out [ op ++ ] = ( byte ) ( ( ( m_len - 1 ) << 5 ) | ( ( m_off & 7 ) << 2 ) ) ; out [ op ++ ] = ( byte ) ( m_off > > 3 ) ; } else if ( m_off <= 0x4000 ) { m_off -= 1 ; out [ op ++ ] = ( byte ) ( 32 | ( m_len - 2 ) ) ; state = c0_m3_m4_offset ; continue loop0 ; } else { m_off -= 0x4000 ; out [ op ++ ] = ( byte ) ( 16 | ( ( m_off & 0x4000 ) > > 11 ) | ( m_len - 2 ) ) ; state = c0_m3_m4_offset ; continue loop0 ; } state = c0_last ; continue loop0 ; } else { int end = in_end ; int m = m_pos + 8 + 1 ; while ( ip < end && in [ m ] == in [ ip ] ) { m ++ ; ip ++ ; } m_len = ip - ii ; if ( m_off <= 0x4000 ) { m_off -= 1 ; if ( m_len <= 33 ) { out [ op ++ ] = ( byte ) ( 32 | ( m_len - 2 ) ) ; } else { m_len -= 33 ; out [ op ++ ] = 32 | 0 ; state = c0_m3_m4_len ; continue loop0 ; } } else { m_off -= 0x4000 ; if ( m_len <= 9 ) { out [ op ++ ] = ( byte ) ( 16 | ( ( m_off & 0x4000 ) > > 11 ) | ( m_len - 2 ) ) ; } else { m_len -= 9 ; out [ op ++ ] = ( byte ) ( 16 | ( ( m_off & 0x4000 ) > > 11 ) ) ; while ( m_len > 255 ) { m_len -= 255 ; out [ op ++ ] = 0 ; } out [ op ++ ] = ( byte ) m_len ; } } out [ op ++ ] = ( byte ) ( ( m_off & 63 ) << 2 ) ; out [ op ++ ] = ( byte ) ( m_off > > 6 ) ; state = c0_last ; continue loop0 ; } case c0_m3_m4_len : while ( m_len > 255 ) { m_len -= 255 ; out [ op ++ ] = 0 ; } out [ op ++ ] = ( byte ) m_len ; case c0_m3_m4_offset : out [ op ++ ] = ( byte ) ( ( m_off & 63 ) << 2 ) ; out [ op ++ ] = ( byte ) ( m_off > > 6 ) ; case c0_last : ii = ip ; if ( ip >= ip_end ) break loop0 ; state = c0_top ; } } out_len . v = op - out_base ; return ( in_end - ii ) ; } public final static int lzo1x_1_compress ( final byte [ ] in , final int in_len , final byte [ ] out , MInt out_len , int [ ] dict ) { int in_base = 0 ; int out_base = 0 ; int op = 0 ; int t = 0 ; if ( ( in_len <= 8 + 5 ) ) { t = in_len ; } else { t = _lzo1x_1_do_compress ( in , in_len , out , out_len , dict ) ; op += out_len . v ; } if ( t > 0 ) { int ii = in_base + in_len - t ; if ( op == out_base && t <= 238 ) out [ op ++ ] = ( byte ) ( 17 + t ) ; else if ( t <= 3 ) out [ op - 2 ] |= ( byte ) t ; else if ( t <= 18 ) out [ op ++ ] = ( byte ) ( t - 3 ) ; else { int tt = t - 18 ; out [ op ++ ] = 0 ; while ( tt > 255 ) { tt -= 255 ; out [ op ++ ] = 0 ; } out [ op ++ ] = ( byte ) tt ; } do out [ op ++ ] = in [ ii ++ ] ; while ( -- t > 0 ) ; } out [ op ++ ] = ( byte ) ( 16 | 1 ) ; out [ op ++ ] = 0 ; out [ op ++ ] = 0 ; out_len . v = ( op - out_base ) ; return 0 ; } public final static int lzo1x_decompress ( final byte [ ] in , final int in_len , final byte [ ] out , MInt out_len ) { int op = 0 ; int ip = 0 ; int t ; int state = c_top_loop ; int max = 0 , diff = 0 , min = 0 ; int m_pos = 0 ; int ip_end = in_len ; out_len . v = 0 ; t = ( in [ ip ] & 0xff ) ; if ( t > 17 ) { ip ++ ; t -= 17 ; if ( t < 4 ) { state = c_match_next ; } else { do out [ op ++ ] = in [ ip ++ ] ; while ( -- t > 0 ) ; state = c_first_literal_run ; } } top_loop_ori : do { boolean if_block = false ; switch ( state ) { case c_top_loop : t = ( in [ ip ++ ] & 0xff ) ; if ( t >= 16 ) { state = c_match ; continue top_loop_ori ; } if ( t == 0 ) { while ( in [ ip ] == 0 ) { t += 255 ; ip ++ ; } t += 15 + ( in [ ip ++ ] & 0xff ) ; } out [ op ] = in [ ip ] ; out [ op + 1 ] = in [ ip + 1 ] ; out [ op + 2 ] = in [ ip + 2 ] ; out [ op + 3 ] = in [ ip + 3 ] ; op += 4 ; ip += 4 ; if ( -- t > 0 ) { if ( t >= 4 ) { do { out [ op ] = in [ ip ] ; out [ op + 1 ] = in [ ip + 1 ] ; out [ op + 2 ] = in [ ip + 2 ] ; out [ op + 3 ] = in [ ip + 3 ] ; op += 4 ; ip += 4 ; t -= 4 ; } while ( t >= 4 ) ; if ( t > 0 ) do out [ op ++ ] = in [ ip ++ ] ; while ( -- t > 0 ) ; } else do out [ op ++ ] = in [ ip ++ ] ; while ( -- t > 0 ) ; } case c_first_literal_run : t = ( in [ ip ++ ] & 0xff ) ; if ( t >= 16 ) { state = c_match ; continue top_loop_ori ; } m_pos = op - 0x801 - ( t > > 2 ) - ( ( in [ ip ++ ] & 0xff ) << 2 ) ; diff = Math . abs ( m_pos - op ) ; if ( diff > max ) max = diff ; diff = ( m_pos - op ) ; if ( diff < min ) min = diff ; out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ] ; state = c_match_done ; continue top_loop_ori ; case c_match : if ( t >= 64 ) { m_pos = op - 1 ; m_pos -= ( t > > 2 ) & 7 ; m_pos -= ( in [ ip ++ ] & 0xff ) << 3 ; diff = Math . abs ( m_pos - op ) ; if ( diff > max ) max = diff ; diff = ( m_pos - op ) ; if ( diff < min ) min = diff ; t = ( t > > 5 ) - 1 ; state = c_copy_match ; continue top_loop_ori ; } else if ( t >= 32 ) { t &= 31 ; if ( t == 0 ) { while ( in [ ip ] == 0 ) { t += 255 ; ip ++ ; } t += 31 + ( in [ ip ++ ] & 0xff ) ; } m_pos = op - 1 ; m_pos -= ( ( ( in [ ip ] & 0xff ) + ( ( in [ ip + 1 ] & 0xff ) << 8 ) ) > > 2 ) ; diff = Math . abs ( m_pos - op ) ; if ( diff > max ) max = diff ; diff = ( m_pos - op ) ; if ( diff < min ) min = diff ; ip += 2 ; } else if ( t >= 16 ) { m_pos = op ; m_pos -= ( t & 8 ) << 11 ; diff = Math . abs ( m_pos - op ) ; if ( diff > max ) max = diff ; diff = ( m_pos - op ) ; if ( diff < min ) min = diff ; t &= 7 ; if ( t == 0 ) { while ( in [ ip ] == 0 ) { t += 255 ; ip ++ ; } t += 7 + ( in [ ip ++ ] & 0xff ) ; } m_pos -= ( ( ( in [ ip ] & 0xff ) + ( ( in [ ip + 1 ] & 0xff ) << 8 ) ) > > 2 ) ; diff = Math . abs ( m_pos - op ) ; if ( diff > max ) max = diff ; diff = ( m_pos - op ) ; if ( diff < min ) min = diff ; ip += 2 ; if ( m_pos == op ) { break top_loop_ori ; } m_pos -= 0x4000 ; } else { m_pos = op - 1 ; m_pos -= t > > 2 ; m_pos -= ( in [ ip ++ ] & 0xff ) << 2 ; diff = Math . abs ( m_pos - op ) ; if ( diff > max ) max = diff ; diff = ( m_pos - op ) ; if ( diff < min ) min = diff ; out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ] ; state = c_match_done ; continue top_loop_ori ; } if ( t >= 2 * 4 - ( 3 - 1 ) && ( op - m_pos ) >= 4 ) { if_block = true ; out [ op ] = out [ m_pos ] ; out [ op + 1 ] = out [ m_pos + 1 ] ; out [ op + 2 ] = out [ m_pos + 2 ] ; out [ op + 3 ] = out [ m_pos + 3 ] ; op += 4 ; m_pos += 4 ; t -= 2 ; do { out [ op ] = out [ m_pos ] ; out [ op + 1 ] = out [ m_pos + 1 ] ; out [ op + 2 ] = out [ m_pos + 2 ] ; out [ op + 3 ] = out [ m_pos + 3 ] ; op += 4 ; m_pos += 4 ; t -= 4 ; } while ( t >= 4 ) ; if ( t > 0 ) do out [ op ++ ] = out [ m_pos ++ ] ; while ( -- t > 0 ) ; } case c_copy_match : if ( ! if_block ) { out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ++ ] ; do out [ op ++ ] = out [ m_pos ++ ] ; while ( -- t > 0 ) ; } case c_match_done : t = ( in [ ip - 2 ] & 0xff ) & 3 ; if ( t == 0 ) { state = c_top_loop ; continue top_loop_ori ; } case c_match_next : out [ op ++ ] = in [ ip ++ ] ; if ( t > 1 ) { out [ op ++ ] = in [ ip ++ ] ; if ( t > 2 ) { out [ op ++ ] = in [ ip ++ ] ; } } t = ( in [ ip ++ ] & 0xff ) ; state = c_match ; continue top_loop_ori ; } } while ( true ) ; out_len . v = op ; if ( debug ) System . err . println ( "\n@@@@@@@@@@@@ diff:" + max + ": min:" + min + "\n" ) ; return ( ip == in . length ? 0 : ( ip < in . length ? ( - 8 ) : ( - 4 ) ) ) ; } public final static int lzo1x_decompress_safe ( final byte [ ] in , int in_len , byte [ ] out , MInt out_len ) { int op = 0 ; int ip = 0 ; int t = 0 ; int m_pos = 0 ; int state = c_top_loop ; out_len . v = 0 ; t = ( in [ ip ] & 0xff ) ; if ( t > 17 ) { ip ++ ; t -= 17 ; if ( t < 4 ) { state = c_match_next ; } else if ( out . length < t ) { state = c_output_overrun ; } else if ( in . length < ( t + 1 ) ) { state = c_input_overrun ; } else { do out [ op ++ ] = in [ ip ++ ] ; while ( -- t > 0 ) ; state = c_first_literal_run ; } } final int out_base = 0 ; final int ip_end = in . length ; final int op_end = out . length ; top_loop_ori : while ( ip < ip_end ) { boolean if_block = false ; switch ( state ) { default : break top_loop_ori ; case c_top_loop : t = ( in [ ip ++ ] & 0xff ) ; if ( t >= 16 ) { state = c_match ; continue top_loop_ori ; } if ( t == 0 ) { if ( ( ip_end - ip ) < 1 ) { state = c_input_overrun ; continue top_loop_ori ; } while ( in [ ip ] == 0 ) { t += 255 ; ip ++ ; if ( ( ip_end - ip ) < 1 ) { state = c_input_overrun ; continue top_loop_ori ; } } t += 15 + ( in [ ip ++ ] & 0xff ) ; } if ( ( op_end - op ) < ( t + 3 ) ) { state = c_output_overrun ; continue top_loop_ori ; } if ( ( ip_end - ip ) < ( t + 4 ) ) { state = c_input_overrun ; continue top_loop_ori ; } out [ op ] = in [ ip ] ; out [ op + 1 ] = in [ ip + 1 ] ; out [ op + 2 ] = in [ ip + 2 ] ; out [ op + 3 ] = in [ ip + 3 ] ; op += 4 ; ip += 4 ; if ( -- t > 0 ) { if ( t >= 4 ) { do { out [ op ] = in [ ip ] ; out [ op + 1 ] = in [ ip + 1 ] ; out [ op + 2 ] = in [ ip + 2 ] ; out [ op + 3 ] = in [ ip + 3 ] ; op += 4 ; ip += 4 ; } while ( t >= 4 ) ; if ( t > 0 ) do out [ op ++ ] = in [ ip ++ ] ; while ( -- t > 0 ) ; } else { do out [ op ++ ] = in [ ip ++ ] ; while ( -- t > 0 ) ; } } case c_first_literal_run : t = ( in [ ip ++ ] & 0xff ) ; if ( t >= 16 ) { state = c_match ; continue top_loop_ori ; } m_pos = op - 0x801 - ( t > > 2 ) - ( ( in [ ip ++ ] & 0xff ) << 2 ) ; if ( m_pos < out_base || m_pos >= op ) { state = c_lookbehind_overrun ; continue top_loop_ori ; } if ( ( op_end - op ) < ( 3 ) ) { state = c_output_overrun ; continue top_loop_ori ; } out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ] ; state = c_match_done ; continue top_loop_ori ; case c_match : if ( t >= 64 ) { m_pos = op - 1 ; m_pos -= ( t > > 2 ) & 7 ; m_pos -= ( in [ ip ++ ] & 0xff ) << 3 ; t = ( t > > 5 ) - 1 ; if ( m_pos < out_base || m_pos >= op ) { state = c_lookbehind_overrun ; continue top_loop_ori ; } if ( ( op_end - op ) < ( t + 3 - 1 ) ) { state = c_output_overrun ; continue top_loop_ori ; } state = c_match_done ; continue top_loop_ori ; } else if ( t >= 32 ) { t &= 31 ; if ( t == 0 ) { if ( ( ip_end - ip ) < 1 ) { state = c_input_overrun ; continue top_loop_ori ; } while ( in [ ip ] == 0 ) { t += 255 ; ip ++ ; if ( ( ip_end - ip ) < 1 ) { state = c_input_overrun ; continue top_loop_ori ; } } t += 31 + ( in [ ip ++ ] & 0xff ) ; } m_pos = op - 1 ; m_pos -= ( ( ( in [ ip ] & 0xff ) + ( ( in [ ip + 1 ] & 0xff ) << 8 ) ) > > 2 ) ; ip += 2 ; } else if ( t >= 16 ) { m_pos = op ; m_pos -= ( t & 8 ) << 11 ; t &= 7 ; if ( t == 0 ) { if ( ( ip_end - ip ) < 1 ) { state = c_input_overrun ; continue top_loop_ori ; } while ( in [ ip ] == 0 ) { t += 255 ; ip ++ ; if ( ( ip_end - ip ) < 1 ) { state = c_input_overrun ; continue top_loop_ori ; } } t += 7 + ( in [ ip ++ ] & 0xff ) ; } m_pos -= ( ( ( in [ ip ] & 0xff ) + ( ( in [ ip + 1 ] & 0xff ) << 8 ) ) > > 2 ) ; ip += 2 ; if ( m_pos == op ) { state = c_eof_found ; break top_loop_ori ; } m_pos -= 0x4000 ; } else { m_pos = op - 1 ; m_pos -= t > > 2 ; m_pos -= ( in [ ip ++ ] & 0xff ) << 2 ; if ( m_pos < out_base || m_pos >= op ) { state = c_lookbehind_overrun ; continue top_loop_ori ; } if ( ( op_end - op ) < 2 ) { state = c_output_overrun ; continue top_loop_ori ; } out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ] ; state = c_match_done ; continue top_loop_ori ; } if ( m_pos < out_base || m_pos >= op ) { state = c_lookbehind_overrun ; continue top_loop_ori ; } if ( ( op_end - op ) < ( t + 3 - 1 ) ) { state = c_output_overrun ; continue top_loop_ori ; } if ( t >= 2 * 4 - ( 3 - 1 ) && ( op - m_pos ) >= 4 ) { if_block = true ; out [ op ] = out [ m_pos ] ; out [ op + 1 ] = out [ m_pos + 1 ] ; out [ op + 2 ] = out [ m_pos + 2 ] ; out [ op + 3 ] = out [ m_pos + 3 ] ; op += 4 ; m_pos += 4 ; t -= 4 - ( 3 - 1 ) ; do { out [ op ] = out [ m_pos ] ; out [ op + 1 ] = out [ m_pos + 1 ] ; out [ op + 2 ] = out [ m_pos + 2 ] ; out [ op + 3 ] = out [ m_pos + 3 ] ; op += 4 ; m_pos += 4 ; t -= 4 ; } while ( t >= 4 ) ; if ( t > 0 ) do out [ op ++ ] = out [ m_pos ++ ] ; while ( -- t > 0 ) ; } case c_copy_match : if ( ! if_block ) { out [ op ++ ] = out [ m_pos ++ ] ; out [ op ++ ] = out [ m_pos ++ ] ; do out [ op ++ ] = out [ m_pos ++ ] ; while ( -- t > 0 ) ; } case c_match_done : t = in [ ip - 2 ] & 3 ; if ( t == 0 ) { state = c_top_loop ; continue top_loop_ori ; } case c_match_next : if ( ( op_end - op ) < t ) { state = c_output_overrun ; continue top_loop_ori ; } if ( ( ip_end - ip ) < ( t + 1 ) ) { state = c_input_overrun ; continue top_loop_ori ; } out [ op ++ ] = in [ ip ++ ] ; if ( t > 1 ) { out [ op ++ ] = in [ ip ++ ] ; if ( t > 2 ) { out [ op ++ ] = in [ ip ++ ] ; } } t = ( in [ ip ++ ] & 0xff ) ; if ( ip < ip_end ) { state = c_match ; continue top_loop_ori ; } else { state = c_top_loop ; continue top_loop_ori ; } } } out_len . v = op - out_base ; switch ( state ) { case c_eof_found : return ( ip == ip_end ? LZO_E_OK : ( ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ) ; case c_input_overrun : return LZO_E_INPUT_OVERRUN ; case c_output_overrun : return LZO_E_OUTPUT_OVERRUN ; case c_lookbehind_overrun : return LZO_E_LOOKBEHIND_OVERRUN ; default : return LZO_E_EOF_NOT_FOUND ; } } } 
=======
public class MediaQuery extends AbstractDatatype { public static final MediaQuery THE_INSTANCE = new MediaQuery ( ) ; private static final boolean WARN = System . getProperty ( "org.whattf.datatype.warn" , "" ) . equals ( "true" ) ? true : false ; private enum State { INITIAL_WS , OPEN_PAREN_SEEN , IN_ONLY_OR_NOT , IN_MEDIA_TYPE , IN_MEDIA_FEATURE , WS_BEFORE_MEDIA_TYPE , WS_BEFORE_AND , IN_AND , WS_BEFORE_EXPRESSION , WS_BEFORE_COLON , WS_BEFORE_VALUE , IN_VALUE_DIGITS , IN_VALUE_SCAN , IN_VALUE_ORIENTATION , WS_BEFORE_CLOSE_PAREN , IN_VALUE_UNIT , IN_VALUE_DIGITS_AFTER_DOT , RATIO_SECOND_INTEGER_START , IN_VALUE_BEFORE_DIGITS , IN_VALUE_DIGITS_AFTER_DOT_TRAIL , AFTER_CLOSE_PAREN , IN_VALUE_ONEORZERO } private enum ValueType { LENGTH , RATIO , INTEGER , RESOLUTION , SCAN , ORIENTATION , NONZEROINTEGER , ONEORZERO } private static final Set < String > LENGTH_UNITS = new HashSet < String > ( ) ; static { LENGTH_UNITS . add ( "em" ) ; LENGTH_UNITS . add ( "ex" ) ; LENGTH_UNITS . add ( "px" ) ; LENGTH_UNITS . add ( "gd" ) ; LENGTH_UNITS . add ( "rem" ) ; LENGTH_UNITS . add ( "vw" ) ; LENGTH_UNITS . add ( "vh" ) ; LENGTH_UNITS . add ( "vm" ) ; LENGTH_UNITS . add ( "ch" ) ; LENGTH_UNITS . add ( "in" ) ; LENGTH_UNITS . add ( "cm" ) ; LENGTH_UNITS . add ( "mm" ) ; LENGTH_UNITS . add ( "pt" ) ; LENGTH_UNITS . add ( "pc" ) ; } private static final Set < String > MEDIA_TYPES = new HashSet < String > ( ) ; static { MEDIA_TYPES . add ( "all" ) ; MEDIA_TYPES . add ( "aural" ) ; MEDIA_TYPES . add ( "braille" ) ; MEDIA_TYPES . add ( "handheld" ) ; MEDIA_TYPES . add ( "print" ) ; MEDIA_TYPES . add ( "projection" ) ; MEDIA_TYPES . add ( "screen" ) ; MEDIA_TYPES . add ( "tty" ) ; MEDIA_TYPES . add ( "tv" ) ; MEDIA_TYPES . add ( "embossed" ) ; MEDIA_TYPES . add ( "speech" ) ; } private enum MediaType { ALL , AURAL , BRAILLE , HANDHELD , PRINT , PROJECTION , SCREEN , TTY , TV , EMBOSSED , SPEECH , INVALID ; private static MediaType toCaps ( String str ) { try { return valueOf ( toAsciiUpperCase ( str ) ) ; } catch ( Exception ex ) { return INVALID ; } } } private static final Map < String , ValueType > FEATURES_TO_VALUE_TYPES = new HashMap < String , ValueType > ( ) ; static { FEATURES_TO_VALUE_TYPES . put ( "width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "device-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-device-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-device-width" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "device-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "min-device-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "max-device-height" , ValueType . LENGTH ) ; FEATURES_TO_VALUE_TYPES . put ( "device-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "min-device-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "max-device-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "min-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "max-aspect-ratio" , ValueType . RATIO ) ; FEATURES_TO_VALUE_TYPES . put ( "color" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "min-color" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "max-color" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "color-index" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "min-color-index" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "max-color-index" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "monochrome" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "min-monochrome" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "max-monochrome" , ValueType . INTEGER ) ; FEATURES_TO_VALUE_TYPES . put ( "resolution" , ValueType . RESOLUTION ) ; FEATURES_TO_VALUE_TYPES . put ( "min-resolution" , ValueType . RESOLUTION ) ; FEATURES_TO_VALUE_TYPES . put ( "max-resolution" , ValueType . RESOLUTION ) ; FEATURES_TO_VALUE_TYPES . put ( "scan" , ValueType . SCAN ) ; FEATURES_TO_VALUE_TYPES . put ( "orientation" , ValueType . ORIENTATION ) ; FEATURES_TO_VALUE_TYPES . put ( "grid" , ValueType . ONEORZERO ) ; } private static final String [ ] visualFeatures = { "aspect-ratio" , "color" , "color-index" , "device-aspect-ratio" , "max-aspect-ratio" , "max-color" , "max-color-index" , "max-device-aspect-ratio" , "max-monochrome" , "max-resolution" , "min-aspect-ratio" , "min-color" , "min-color-index" , "min-device-aspect-ratio" , "min-monochrome" , "min-resolution" , "monochrome" , "orientation" , "resolution" , } ; private static final String [ ] bitmapFeatures = { "aspect-ratio" , "device-aspect-ratio" , "max-aspect-ratio" , "max-device-aspect-ratio" , "max-resolution" , "min-aspect-ratio" , "min-device-aspect-ratio" , "min-resolution" , "orientation" , "resolution" , } ; private static final String scanWarning = "The media feature “scan” is applicable only to the media type “tv”. " ; private MediaQuery ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { List < String > warnings = new ArrayList < String > ( ) ; List < CharSequenceWithOffset > queries = split ( literal , ',' ) ; for ( CharSequenceWithOffset query : queries ) { warnings = checkQuery ( query . getSequence ( ) , query . getOffset ( ) , warnings ) ; } if ( ! warnings . isEmpty ( ) && WARN ) { StringBuilder sb = new StringBuilder ( ) ; for ( String s : warnings ) { sb . append ( s + " " ) ; } throw newDatatypeException ( sb . toString ( ) . trim ( ) , WARN ) ; } } private List < String > checkQuery ( CharSequence query , int offset , List < String > warnings ) throws DatatypeException { boolean containsAural = false ; boolean zero = true ; String type = null ; String feature = null ; ValueType valueExpectation = null ; query = toAsciiLowerCase ( query ) ; StringBuilder sb = new StringBuilder ( ) ; State state = State . INITIAL_WS ; for ( int i = 0 ; i < query . length ( ) ; i ++ ) { char c = query . charAt ( i ) ; switch ( state ) { case INITIAL_WS : if ( isWhitespace ( c ) ) { continue ; } else if ( '(' == c ) { state = State . OPEN_PAREN_SEEN ; continue ; } else if ( 'o' == c || 'n' == c ) { sb . append ( c ) ; state = State . IN_ONLY_OR_NOT ; continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_MEDIA_TYPE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “(” or letter at start of a media query part but saw " , c , " instead." ) ; } case IN_ONLY_OR_NOT : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( "only" . equals ( kw ) || "not" . equals ( kw ) ) { state = State . WS_BEFORE_MEDIA_TYPE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “only” or “not” but saw “" + kw + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_MEDIA_TYPE : if ( isWhitespace ( c ) ) { continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_MEDIA_TYPE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter or whitespace but saw “" + c + "” instead." ) ; } case IN_MEDIA_TYPE : if ( ( 'a' <= c && 'z' >= c ) || c == '-' ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) ) { type = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( isMediaType ( type ) ) { if ( "aural" . equals ( type ) ) { containsAural = true ; } state = State . WS_BEFORE_AND ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a CSS media type but saw “" + type + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, hyphen or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_AND : if ( isWhitespace ( c ) ) { continue ; } else if ( 'a' == c ) { sb . append ( c ) ; state = State . IN_AND ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace or “and” but saw" + " “" + c + "” instead." ) ; } case IN_AND : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( "and" . equals ( kw ) ) { state = State . WS_BEFORE_EXPRESSION ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “and” but saw “" + kw + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_EXPRESSION : if ( isWhitespace ( c ) ) { continue ; } else if ( '(' == c ) { state = State . OPEN_PAREN_SEEN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “(” or whitespace but saw “" + c + "” instead." ) ; } case OPEN_PAREN_SEEN : if ( isWhitespace ( c ) ) { continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_MEDIA_FEATURE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter at start of a media feature part but saw “" + c + "” instead." ) ; } case IN_MEDIA_FEATURE : if ( ( 'a' <= c && 'z' >= c ) || c == '-' ) { sb . append ( c ) ; continue ; } else if ( c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; checkApplicability ( offset + i , kw , type , warnings ) ; checkIfValueRequired ( offset + i , kw ) ; state = State . AFTER_CLOSE_PAREN ; continue ; } else if ( isWhitespace ( c ) || c == ':' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; checkApplicability ( offset + i , kw , type , warnings ) ; feature = kw ; valueExpectation = valueExpectationFor ( kw ) ; if ( valueExpectation != null ) { if ( c == ':' ) { state = State . WS_BEFORE_VALUE ; continue ; } else { state = State . WS_BEFORE_COLON ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a CSS media feature but saw “" + kw + "” instead." ) ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, hyphen, colon or whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_COLON : if ( isWhitespace ( c ) ) { continue ; } else if ( ':' == c ) { state = State . WS_BEFORE_VALUE ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace or colon but saw “" + c + "” instead." ) ; } case WS_BEFORE_VALUE : if ( isWhitespace ( c ) ) { continue ; } else { zero = true ; switch ( valueExpectation ) { case SCAN : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_SCAN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter but saw “" + c + "” instead." ) ; } case ORIENTATION : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_ORIENTATION ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a letter but saw “" + c + "” instead." ) ; } case ONEORZERO : if ( c == '0' || c == '1' ) { sb . append ( c ) ; state = State . IN_VALUE_ONEORZERO ; continue ; } else { throw newDatatypeException ( offset + i , "Expected “0” or “1” as “" + feature + "” value but found “" + c + "” instead." ) ; } default : if ( '1' <= c && '9' >= c ) { zero = false ; state = State . IN_VALUE_DIGITS ; continue ; } else if ( '0' == c ) { state = State . IN_VALUE_DIGITS ; continue ; } else if ( '+' == c ) { state = State . IN_VALUE_BEFORE_DIGITS ; continue ; } else if ( '.' == c && valueExpectation == ValueType . LENGTH ) { state = State . IN_VALUE_DIGITS_AFTER_DOT ; continue ; } else if ( valueExpectation == ValueType . LENGTH ) { throw newDatatypeException ( offset + i , "Expected a digit, a dot or a plus sign but saw “" + c + "” instead." ) ; } else { throw newDatatypeException ( offset + i , "Expected a digit or a plus sign but saw “" + c + "” instead." ) ; } } } case IN_VALUE_SCAN : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( ! ( "progressive" . equals ( kw ) || "interlace" . equals ( kw ) ) ) { throw newDatatypeException ( offset + i , "Expected “progressive” or “interlace” as the scan mode value but saw “" + kw + "” instead." ) ; } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, whitespace or “)” but saw “" + c + "” instead." ) ; } case IN_VALUE_ORIENTATION : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( ! ( "portrait" . equals ( kw ) || "landscape" . equals ( kw ) ) ) { throw newDatatypeException ( offset + i , "Expected “portrait” or “landscape” as the “orientation” value but saw “" + kw + "” instead." ) ; } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, whitespace or “)” but saw “" + c + "” instead." ) ; } case IN_VALUE_ONEORZERO : if ( isWhitespace ( c ) || c == ')' ) { sb . setLength ( 0 ) ; if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { sb . append ( c ) ; String kw = sb . toString ( ) ; throw newDatatypeException ( offset + i , "Expected “0” or “1” as “" + feature + "” value but saw “" + kw + "” instead." ) ; } case IN_VALUE_BEFORE_DIGITS : if ( '0' == c ) { state = State . IN_VALUE_DIGITS ; continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; state = State . IN_VALUE_DIGITS ; continue ; } else { switch ( valueExpectation ) { case LENGTH : case RESOLUTION : if ( '.' == c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a dot or a digit but saw “" + c + "” instead." ) ; } case INTEGER : case RATIO : throw newDatatypeException ( offset + i , "Expected a digit but saw “" + c + "” instead." ) ; default : throw new RuntimeException ( "Impossible state." ) ; } } case IN_VALUE_DIGITS : if ( '0' == c ) { continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; continue ; } else { switch ( valueExpectation ) { case LENGTH : case RESOLUTION : if ( '.' == c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT ; continue ; } else if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_UNIT ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { if ( ! zero ) { if ( valueExpectation == ValueType . LENGTH ) { throw newDatatypeException ( offset + i , "Non-zero lengths require a unit." ) ; } else { throw newDatatypeException ( offset + i , "Non-zero resolutions require a unit." ) ; } } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, a dot or a digit but saw “" + c + "” instead." ) ; } case INTEGER : if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or “)” but saw “" + c + "” instead." ) ; } case NONZEROINTEGER : if ( c == ')' ) { if ( zero ) { throw newDatatypeException ( offset + i , "Expected a non-zero positive integer." ) ; } state = State . AFTER_CLOSE_PAREN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or “)” but saw “" + c + "” instead." ) ; } case RATIO : if ( isWhitespace ( c ) ) { continue ; } else if ( c == '/' ) { if ( zero ) { throw newDatatypeException ( offset + i , "Expected non-zero positive integer in ratio value." ) ; } valueExpectation = ValueType . NONZEROINTEGER ; state = State . RATIO_SECOND_INTEGER_START ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or" + " “/” for " + feature + " value but saw “" + c + "” instead." ) ; } default : throw new RuntimeException ( "Impossible state." ) ; } } case IN_VALUE_DIGITS_AFTER_DOT : if ( '0' == c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT_TRAIL ; continue ; } else if ( '1' <= c && '9' >= c ) { state = State . IN_VALUE_DIGITS_AFTER_DOT_TRAIL ; zero = false ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit but saw “" + c + "” instead." ) ; } case IN_VALUE_DIGITS_AFTER_DOT_TRAIL : if ( '0' == c ) { continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; continue ; } else { switch ( valueExpectation ) { case LENGTH : case RESOLUTION : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; state = State . IN_VALUE_UNIT ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { if ( ! zero ) { if ( valueExpectation == ValueType . LENGTH ) { throw newDatatypeException ( offset + i , "Non-zero lengths require a unit." ) ; } else { throw newDatatypeException ( offset + i , "Non-zero resolutions require a unit." ) ; } } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, a digit, whitespace or “)” but saw “" + c + "” instead." ) ; } default : throw new RuntimeException ( "Impossible state." ) ; } } case IN_VALUE_UNIT : if ( 'a' <= c && 'z' >= c ) { sb . append ( c ) ; continue ; } else if ( isWhitespace ( c ) || c == ')' ) { String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( valueExpectation == ValueType . LENGTH ) { if ( ! isLengthUnit ( kw ) ) { throw newDatatypeException ( offset + i , "Expected a length unit but saw “" + c + "” instead." ) ; } } else { if ( ! ( "dpi" . equals ( kw ) || "dpcm" . equals ( kw ) ) ) { throw newDatatypeException ( offset + i , "Expected a resolution unit but saw “" + c + "” instead." ) ; } } if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { state = State . WS_BEFORE_CLOSE_PAREN ; continue ; } } else { throw newDatatypeException ( offset + i , "Expected a letter, a dot or a digit but saw “" + c + "” instead." ) ; } case RATIO_SECOND_INTEGER_START : valueExpectation = ValueType . NONZEROINTEGER ; if ( isWhitespace ( c ) ) { continue ; } else if ( '1' <= c && '9' >= c ) { zero = false ; state = State . IN_VALUE_DIGITS ; continue ; } else if ( '0' == c ) { zero = true ; state = State . IN_VALUE_DIGITS ; continue ; } else if ( '+' == c ) { state = State . IN_VALUE_BEFORE_DIGITS ; continue ; } else { throw newDatatypeException ( offset + i , "Expected a digit, whitespace or a plus sign" + " for " + feature + " value but saw “" + c + "” instead." ) ; } case AFTER_CLOSE_PAREN : if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_AND ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace but saw “" + c + "” instead." ) ; } case WS_BEFORE_CLOSE_PAREN : if ( isWhitespace ( c ) ) { continue ; } else if ( c == ')' ) { state = State . AFTER_CLOSE_PAREN ; continue ; } else { throw newDatatypeException ( offset + i , "Expected whitespace or “)” but saw “" + c + "” instead." ) ; } } } switch ( state ) { case AFTER_CLOSE_PAREN : case WS_BEFORE_AND : if ( containsAural && WARN ) { warnings . add ( "The media type “aural” is deprecated. Use “speech” instead. " ) ; } return warnings ; case IN_MEDIA_TYPE : String kw = sb . toString ( ) ; sb . setLength ( 0 ) ; if ( isMediaType ( kw ) ) { if ( "aural" . equals ( kw ) && WARN ) { warnings . add ( "The media type “aural” is deprecated. Use “speech” instead. " ) ; } return warnings ; } else { throw newDatatypeException ( "Expected a CSS media type but the query ended." ) ; } default : throw newDatatypeException ( "Media query ended prematurely." ) ; } } private boolean isMediaFeature ( String feature ) { return FEATURES_TO_VALUE_TYPES . containsKey ( feature ) ; } private ValueType valueExpectationFor ( String feature ) { return FEATURES_TO_VALUE_TYPES . get ( feature ) ; } private boolean isMediaType ( String type ) { return MEDIA_TYPES . contains ( type ) ; } private boolean isLengthUnit ( String unit ) { return LENGTH_UNITS . contains ( unit ) ; } private List < String > checkApplicability ( int index , String feature , String type , List < String > warnings ) throws DatatypeException { if ( ! isMediaType ( type ) ) { return warnings ; } if ( ! isMediaFeature ( feature ) ) { throw newDatatypeException ( index , "Expected a CSS media feature but saw “" + feature + "” instead." ) ; } if ( "scan" . equals ( feature ) && ! "tv" . equals ( type ) ) { warnings . add ( scanWarning ) ; return warnings ; } switch ( MediaType . toCaps ( type ) ) { case SPEECH : warnings . add ( "The media feature “" + feature + "” is not applicable to the media type “speech”. " ) ; return warnings ; case BRAILLE : case EMBOSSED : if ( Arrays . binarySearch ( visualFeatures , feature ) > - 1 ) { warnings . add ( "The visual media feature “" + feature + "” is not applicable to the tactile media type “" + type + "”. " ) ; } return warnings ; case TTY : if ( Arrays . binarySearch ( bitmapFeatures , feature ) > - 1 ) { warnings . add ( "The bitmap media feature “" + feature + "” is not applicable to the media type “tty”. " ) ; } return warnings ; default : return warnings ; } } private void checkIfValueRequired ( int index , String feature ) throws DatatypeException { if ( feature . startsWith ( "min-" ) || feature . startsWith ( "max-" ) ) { throw newDatatypeException ( index , "Expected a value for the media feature “" + feature + "”." ) ; } } @ Override public String getName ( ) { return "media query" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
