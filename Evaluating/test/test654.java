public class ToggleCommentAction extends TextEditorAction implements IAction { private ITextOperationTarget fOperationTarget ; private String fDocumentPartitioning ; private Map < String , String [ ] > fPrefixesMap ; public ToggleCommentAction ( ITextEditor editor ) { super ( EditorMessages . getBundleForConstructedKeys ( ) , "Editor.ToggleComment." , editor ) ; } public void run ( ) { if ( fOperationTarget == null || fDocumentPartitioning == null || fPrefixesMap == null ) return ; ITextEditor editor = getTextEditor ( ) ; if ( editor == null ) return ; if ( ! validateEditorInputState ( ) ) return ; final int operationCode ; if ( isSelectionCommented ( editor . getSelectionProvider ( ) . getSelection ( ) ) ) operationCode = ITextOperationTarget . STRIP_PREFIX ; else operationCode = ITextOperationTarget . PREFIX ; Shell shell = editor . getSite ( ) . getShell ( ) ; if ( ! fOperationTarget . canDoOperation ( operationCode ) ) { if ( shell != null ) MessageDialog . openError ( shell , "Toggle Comment" , "An error occurred while toggling comments" ) ; return ; } Display display = null ; if ( shell != null && ! shell . isDisposed ( ) ) display = shell . getDisplay ( ) ; BusyIndicator . showWhile ( display , new Runnable ( ) { public void run ( ) { fOperationTarget . doOperation ( operationCode ) ; } } ) ; } private boolean isSelectionCommented ( ISelection selection ) { if ( ! ( selection instanceof ITextSelection ) ) return false ; ITextSelection textSelection = ( ITextSelection ) selection ; if ( textSelection . getStartLine ( ) < 0 || textSelection . getEndLine ( ) < 0 ) return false ; IDocument document = getTextEditor ( ) . getDocumentProvider ( ) . getDocument ( getTextEditor ( ) . getEditorInput ( ) ) ; try { IRegion block = getTextBlockFromSelection ( textSelection , document ) ; ITypedRegion [ ] regions = TextUtilities . computePartitioning ( document , fDocumentPartitioning , block . getOffset ( ) , block . getLength ( ) , false ) ; int lineCount = 0 ; int [ ] lines = new int [ regions . length * 2 ] ; for ( int i = 0 , j = 0 ; i < regions . length ; i ++ , j += 2 ) { lines [ j ] = getFirstCompleteLineOfRegion ( regions [ i ] , document ) ; int length = regions [ i ] . getLength ( ) ; int offset = regions [ i ] . getOffset ( ) + length ; if ( length > 0 ) offset -- ; lines [ j + 1 ] = ( lines [ j ] == - 1 ? - 1 : document . getLineOfOffset ( offset ) ) ; lineCount += lines [ j + 1 ] - lines [ j ] + 1 ; } for ( int i = 0 , j = 0 ; i < regions . length ; i ++ , j += 2 ) { String [ ] prefixes = ( String [ ] ) fPrefixesMap . get ( regions [ i ] . getType ( ) ) ; if ( prefixes != null && prefixes . length > 0 && lines [ j ] >= 0 && lines [ j + 1 ] >= 0 ) if ( ! isBlockCommented ( lines [ j ] , lines [ j + 1 ] , prefixes , document ) ) return false ; } return true ; } catch ( BadLocationException x ) { IdeLog . logError ( Activator . getDefault ( ) , x . getMessage ( ) , x ) ; } return false ; } private IRegion getTextBlockFromSelection ( ITextSelection selection , IDocument document ) { try { IRegion line = document . getLineInformationOfOffset ( selection . getOffset ( ) ) ; int length = selection . getLength ( ) == 0 ? line . getLength ( ) : selection . getLength ( ) + ( selection . getOffset ( ) - line . getOffset ( ) ) ; return new Region ( line . getOffset ( ) , length ) ; } catch ( BadLocationException x ) { IdeLog . logError ( Activator . getDefault ( ) , x . getMessage ( ) , x ) ; } return null ; } private int getFirstCompleteLineOfRegion ( IRegion region , IDocument document ) { try { int startLine = document . getLineOfOffset ( region . getOffset ( ) ) ; int offset = document . getLineOffset ( startLine ) ; if ( offset >= region . getOffset ( ) ) return startLine ; offset = document . getLineOffset ( startLine + 1 ) ; return ( offset > region . getOffset ( ) + region . getLength ( ) ? - 1 : startLine + 1 ) ; } catch ( BadLocationException x ) { IdeLog . logError ( Activator . getDefault ( ) , x . getMessage ( ) , x ) ; } return - 1 ; } private boolean isBlockCommented ( int startLine , int endLine , String [ ] prefixes , IDocument document ) { try { for ( int i = startLine ; i <= endLine ; i ++ ) { IRegion line = document . getLineInformation ( i ) ; String text = document . get ( line . getOffset ( ) , line . getLength ( ) ) ; int [ ] found = TextUtilities . indexOf ( prefixes , text , 0 ) ; if ( found [ 0 ] == - 1 ) return false ; String s = document . get ( line . getOffset ( ) , found [ 0 ] ) ; s = s . trim ( ) ; if ( s . length ( ) != 0 ) return false ; } return true ; } catch ( BadLocationException x ) { IdeLog . logError ( Activator . getDefault ( ) , x . getMessage ( ) , x ) ; } return false ; } public void update ( ) { super . update ( ) ; if ( ! canModifyEditor ( ) ) { setEnabled ( false ) ; return ; } ITextEditor editor = getTextEditor ( ) ; if ( fOperationTarget == null && editor != null ) fOperationTarget = ( ITextOperationTarget ) editor . getAdapter ( ITextOperationTarget . class ) ; boolean isEnabled = ( fOperationTarget != null && fOperationTarget . canDoOperation ( ITextOperationTarget . PREFIX ) && fOperationTarget . canDoOperation ( ITextOperationTarget . STRIP_PREFIX ) ) ; setEnabled ( isEnabled ) ; } public void setEditor ( ITextEditor editor ) { super . setEditor ( editor ) ; fOperationTarget = null ; } public void configure ( ISourceViewer sourceViewer , SourceViewerConfiguration configuration ) { fPrefixesMap = null ; String [ ] types = configuration . getConfiguredContentTypes ( sourceViewer ) ; Map < String , String [ ] > prefixesMap = new HashMap < String , String [ ] > ( types . length ) ; for ( int i = 0 ; i < types . length ; i ++ ) { String type = types [ i ] ; String [ ] prefixes = getDefaultPrefixes ( configuration , sourceViewer , type ) ; if ( prefixes != null && prefixes . length > 0 ) { int emptyPrefixes = 0 ; for ( int j = 0 ; j < prefixes . length ; j ++ ) if ( prefixes [ j ] . length ( ) == 0 ) emptyPrefixes ++ ; if ( emptyPrefixes > 0 ) { String [ ] nonemptyPrefixes = new String [ prefixes . length - emptyPrefixes ] ; for ( int j = 0 , k = 0 ; j < prefixes . length ; j ++ ) { String prefix = prefixes [ j ] ; if ( prefix . length ( ) != 0 ) { nonemptyPrefixes [ k ] = prefix ; k ++ ; } } prefixes = nonemptyPrefixes ; } prefixesMap . put ( type , prefixes ) ; } } fDocumentPartitioning = configuration . getConfiguredDocumentPartitioning ( sourceViewer ) ; fPrefixesMap = prefixesMap ; } protected String [ ] getDefaultPrefixes ( SourceViewerConfiguration configuration , ISourceViewer sourceViewer , String type ) { return configuration . getDefaultPrefixes ( sourceViewer , type ) ; } } 