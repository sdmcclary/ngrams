<<<<<<< HEAD
public final class IdeLog { private static Map < Plugin , List < Status > > earlyMessageCache = new HashMap < Plugin , List < Status > > ( ) ; private static boolean caching = true ; public static int OFF = 0 ; public static int ERROR = 1 ; public static int WARNING = 2 ; public static int INFO = 3 ; public static void flushCache ( ) { caching = false ; Iterator < Plugin > iter = earlyMessageCache . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Plugin plugin = iter . next ( ) ; List < Status > messages = earlyMessageCache . get ( plugin ) ; for ( int i = 0 ; i < messages . size ( ) ; i ++ ) { Status status = ( Status ) messages . get ( i ) ; if ( status . getSeverity ( ) == IStatus . ERROR || ( isAptanaDebugging ( status . getSeverity ( ) ) || plugin . isDebugging ( ) ) ) { log ( plugin , status . getSeverity ( ) , status . getMessage ( ) , status . getException ( ) ) ; } } } earlyMessageCache . clear ( ) ; } private IdeLog ( ) { } public static void logError ( Plugin plugin , String message ) { log ( plugin , IStatus . ERROR , message , null ) ; } public static boolean isAptanaDebugging ( int debugLevel ) { if ( caching ) { return true ; } else if ( Platform . inDebugMode ( ) ) { return true ; } else if ( AptanaCorePlugin . getDefault ( ) != null ) { int statusPreference = Platform . getPreferencesService ( ) . getInt ( AptanaCorePlugin . ID , IPreferenceConstants . PREF_DEBUG_LEVEL , OFF , null ) ; if ( statusPreference == OFF ) { return false ; } return statusPreference >= getStatusLevel ( debugLevel ) ; } else { return false ; } } private static int getStatusLevel ( int status ) { switch ( status ) { case IStatus . INFO : { return INFO ; } case IStatus . WARNING : { return WARNING ; } case IStatus . ERROR : { return ERROR ; } default : { return OFF ; } } } public static void logError ( Plugin plugin , String message , Throwable th ) { log ( plugin , IStatus . ERROR , message , th ) ; } public static void logWarning ( Plugin plugin , String message , Throwable th ) { if ( isAptanaDebugging ( IStatus . WARNING ) || ( plugin != null && plugin . isDebugging ( ) ) ) { log ( plugin , IStatus . WARNING , message , th ) ; } } public static void logWarning ( Plugin plugin , String message ) { if ( isAptanaDebugging ( IStatus . WARNING ) || ( plugin != null && plugin . isDebugging ( ) ) ) { log ( plugin , IStatus . WARNING , message , null ) ; } } public static void logImportant ( Plugin plugin , String message , Throwable th ) { if ( isAptanaDebugging ( IStatus . WARNING ) || ( plugin != null && plugin . isDebugging ( ) ) ) { log ( plugin , IStatus . WARNING , message , th ) ; } } public static void logImportant ( Plugin plugin , String message ) { if ( isAptanaDebugging ( IStatus . WARNING ) || ( plugin != null && plugin . isDebugging ( ) ) ) { log ( plugin , IStatus . WARNING , message , null ) ; } } public static void logInfo ( Plugin plugin , String message ) { if ( isAptanaDebugging ( IStatus . INFO ) || ( plugin != null && plugin . isDebugging ( ) ) ) { log ( plugin , IStatus . INFO , message , null ) ; } } public static void logInfo ( Plugin plugin , String message , Throwable th ) { if ( isAptanaDebugging ( IStatus . INFO ) || ( plugin != null && plugin . isDebugging ( ) ) ) { log ( plugin , IStatus . INFO , message , th ) ; } } public static void logInfoToFile ( Plugin plugin , String message , String name , String suffix , String fileContent ) { if ( isAptanaDebugging ( IStatus . WARNING ) || plugin . isDebugging ( ) ) { File f = null ; try { f = File . createTempFile ( name , suffix ) ; FileUtils . writeStringToFile ( fileContent , f ) ; log ( plugin , IStatus . WARNING , message + Messages . IdeLog_File_Written_To + f . getAbsolutePath ( ) , null ) ; } catch ( IOException e ) { log ( plugin , IStatus . WARNING , message + Messages . IdeLog_Unable_To_Write_Temporary_File , null ) ; } } } public static void log ( Plugin plugin , int status , String message , Throwable th ) { if ( plugin == null ) { System . err . println ( message ) ; if ( th != null ) { th . printStackTrace ( ) ; } return ; } String tempMessage = StringUtils . format ( "(Build {0}) {1} {2}" , new String [ ] { PluginUtils . getPluginVersion ( plugin ) , getLabel ( status ) , message } ) ; if ( ! PluginUtils . isPluginLoaded ( plugin ) ) { System . err . println ( tempMessage ) ; return ; } Status logStatus = new Status ( status , plugin . getBundle ( ) . getSymbolicName ( ) , IStatus . OK , tempMessage , th ) ; if ( caching ) { List < Status > statusMessages = null ; if ( earlyMessageCache . containsKey ( plugin ) ) { statusMessages = earlyMessageCache . get ( plugin ) ; } else { statusMessages = new ArrayList < Status > ( ) ; earlyMessageCache . put ( plugin , statusMessages ) ; } statusMessages . add ( logStatus ) ; } else { plugin . getLog ( ) . log ( logStatus ) ; } if ( status == IStatus . ERROR && isAptanaDebugging ( IStatus . ERROR ) ) { System . err . println ( tempMessage ) ; if ( th != null ) { th . printStackTrace ( ) ; } } } private static String getLabel ( int status ) { switch ( status ) { case IStatus . INFO : { return Messages . IdeLog_INFO ; } case IStatus . WARNING : { return Messages . IdeLog_IMPORTANT ; } case IStatus . ERROR : { return Messages . IdeLog_ERROR ; } default : { return Messages . IdeLog_UNKNOWN ; } } } } 
=======
public final class Pattern extends AbstractDatatype { public static final Pattern THE_INSTANCE = new Pattern ( ) ; private Pattern ( ) { super ( ) ; } public void checkValid ( CharSequence literal ) throws DatatypeException { ContextFactory cf = new ContextFactory ( ) ; Context cx = cf . enterContext ( ) ; RegExpImpl rei = new RegExpImpl ( ) ; String anchoredRegex = "^(?:" + literal + ")$" ; try { rei . compileRegExp ( cx , anchoredRegex , "" ) ; } catch ( EcmaError ee ) { throw newDatatypeException ( ee . getErrorMessage ( ) ) ; } finally { Context . exit ( ) ; } } @ Override public String getName ( ) { return "pattern" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
