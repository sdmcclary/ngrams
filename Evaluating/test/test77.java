<<<<<<< HEAD
public class Vt100TerminalModel extends AbstractTerminalModel { private class Vt100Listener implements AnsiControlSequenceListener { private int savedCursorRow = - 1 ; private int savedCursorColumn = - 1 ; @ Override public void parsedControlSequence ( AnsiControlSequence seq ) { char command = seq . getCommand ( ) ; String [ ] parameters = seq . getParameters ( ) ; switch ( command ) { case 'A' : case 'B' : case 'C' : case 'D' : int n = 1 ; if ( parameters . length == 1 ) { n = Integer . parseInt ( parameters [ 0 ] ) ; } if ( command == 'A' ) { moveCursorUp ( n ) ; } else if ( command == 'B' ) { moveCursorDown ( n ) ; } else if ( command == 'C' ) { moveCursorForward ( n ) ; } else if ( command == 'D' ) { moveCursorBack ( n ) ; } break ; case 'E' : case 'F' : n = 1 ; if ( parameters . length == 1 ) { n = Integer . parseInt ( parameters [ 0 ] ) ; } if ( command == 'E' ) { moveCursorDown ( n ) ; } else if ( command == 'F' ) { moveCursorUp ( n ) ; } setCursorColumn ( 0 ) ; break ; case 'G' : if ( parameters . length == 1 ) { n = Integer . parseInt ( parameters [ 0 ] ) ; setCursorColumn ( n - 1 ) ; } break ; case 'H' : case 'f' : if ( parameters . length == 2 ) { n = 1 ; int m = 1 ; if ( parameters [ 0 ] . length ( ) > 0 ) { n = Integer . parseInt ( parameters [ 0 ] ) ; } if ( parameters [ 1 ] . length ( ) > 0 ) { m = Integer . parseInt ( parameters [ 1 ] ) ; } setCursorRow ( n - 1 ) ; setCursorColumn ( m - 1 ) ; } break ; case 'J' : n = 0 ; if ( parameters . length == 1 ) { n = Integer . parseInt ( parameters [ 0 ] ) ; } if ( n == 0 ) { int row = cursorRow ; int column = cursorColumn ; while ( row < rows ) { while ( column < columns ) { cells [ row ] [ column ] = null ; column ++ ; } column = 0 ; row ++ ; } } else if ( n == 1 ) { int row = cursorRow ; int column = cursorColumn ; while ( row >= 0 ) { while ( column >= 0 ) { cells [ row ] [ column ] = null ; column -- ; } column = columns - 1 ; row -- ; } } else if ( n == 2 ) { clear ( ) ; } break ; case 'K' : n = 0 ; if ( parameters . length == 1 ) { n = Integer . parseInt ( parameters [ 0 ] ) ; } if ( n == 0 ) { for ( int row = cursorRow ; row < rows ; row ++ ) { cells [ row ] [ cursorColumn ] = null ; } } else if ( n == 1 ) { for ( int row = cursorRow ; row >= 0 ; row -- ) { cells [ row ] [ cursorColumn ] = null ; } } else if ( n == 2 ) { for ( int column = 0 ; column < columns ; column ++ ) { cells [ cursorRow ] [ column ] = null ; } } break ; case 'm' : if ( parameters . length == 0 ) { parameters = new String [ ] { "0" } ; } for ( String parameter : parameters ) { if ( parameter . equals ( "0" ) ) { foregroundColor = DEFAULT_FOREGROUND_COLOR ; backgroundColor = DEFAULT_BACKGROUND_COLOR ; backgroundBold = DEFAULT_BACKGROUND_BOLD ; foregroundBold = DEFAULT_FOREGROUND_BOLD ; } else if ( parameter . equals ( "2" ) ) { backgroundBold = true ; foregroundBold = true ; } else if ( parameter . equals ( "22" ) ) { backgroundBold = false ; foregroundBold = false ; } else if ( ( parameter . startsWith ( "3" ) || parameter . startsWith ( "4" ) ) && parameter . length ( ) == 2 ) { int color = Integer . parseInt ( parameter . substring ( 1 ) ) ; if ( parameter . startsWith ( "3" ) ) { foregroundColor = color ; } else if ( parameter . startsWith ( "4" ) ) { backgroundColor = color ; } } } break ; case 'u' : if ( savedCursorColumn != - 1 && savedCursorRow != - 1 ) { cursorColumn = savedCursorColumn ; cursorRow = savedCursorRow ; } break ; case 's' : savedCursorColumn = cursorColumn ; savedCursorRow = cursorRow ; break ; } } @ Override public void parsedString ( String str ) { for ( char ch : str . toCharArray ( ) ) { switch ( ch ) { case '\0' : continue ; case '\r' : cursorColumn = 0 ; continue ; case '\n' : cursorRow ++ ; break ; case '\t' : while ( ( ++ cursorColumn % TAB_WIDTH ) != 0 ) ; continue ; case 8 : case 127 : if ( cursorColumn > 0 ) { cells [ cursorRow ] [ -- cursorColumn ] = null ; } continue ; case 7 : bellStrategy . soundBell ( ) ; continue ; } if ( cursorColumn >= columns ) { cursorColumn = 0 ; cursorRow ++ ; } if ( cursorRow >= bufferSize ) { for ( int i = 1 ; i < bufferSize ; i ++ ) { System . arraycopy ( cells [ i ] , 0 , cells [ i - 1 ] , 0 , columns ) ; } for ( int i = 0 ; i < columns ; i ++ ) { cells [ bufferSize - 1 ] [ i ] = null ; } cursorRow -- ; } Color back = backgroundBold ? SgrColor . COLOR_BRIGHT [ backgroundColor ] : SgrColor . COLOR_NORMAL [ backgroundColor ] ; Color fore = foregroundBold ? SgrColor . COLOR_BRIGHT [ foregroundColor ] : SgrColor . COLOR_NORMAL [ foregroundColor ] ; if ( ch != '\n' ) { cells [ cursorRow ] [ cursorColumn ++ ] = new TerminalCell ( ch , back , fore ) ; } } } } private static final int DEFAULT_COLUMNS = 80 ; private static final int DEFAULT_ROWS = 25 ; private static final int TAB_WIDTH = 8 ; private static final boolean DEFAULT_FOREGROUND_BOLD = false ; private static final boolean DEFAULT_BACKGROUND_BOLD = false ; private static final int DEFAULT_FOREGROUND_COLOR = 7 ; private static final int DEFAULT_BACKGROUND_COLOR = 0 ; private final AnsiControlSequenceListener listener = this . new Vt100Listener ( ) ; private final AnsiControlSequenceParser parser = new AnsiControlSequenceParser ( listener ) ; private BellStrategy bellStrategy = new NopBellStrategy ( ) ; private TerminalCell [ ] [ ] cells ; private int columns ; private int rows ; private int bufferSize ; private int cursorRow = 0 ; private int cursorColumn = 0 ; private boolean foregroundBold = DEFAULT_FOREGROUND_BOLD ; private boolean backgroundBold = DEFAULT_BACKGROUND_BOLD ; private int foregroundColor = DEFAULT_FOREGROUND_COLOR ; private int backgroundColor = DEFAULT_BACKGROUND_COLOR ; public Vt100TerminalModel ( ) { this ( DEFAULT_COLUMNS , DEFAULT_ROWS ) ; } public Vt100TerminalModel ( int columns , int rows ) { this ( columns , rows , rows ) ; } public Vt100TerminalModel ( int columns , int rows , int bufferSize ) { if ( columns < 0 || rows < 0 || bufferSize < 0 ) { throw new IllegalArgumentException ( "Zero or positive values only allowed for columns, rows and buffer size." ) ; } if ( bufferSize < rows ) { throw new IllegalArgumentException ( "The buffer is too small" ) ; } this . columns = columns ; this . rows = rows ; this . bufferSize = bufferSize ; init ( ) ; } private void init ( ) { cells = new TerminalCell [ bufferSize ] [ columns ] ; } @ Override public int getCursorRow ( ) { return cursorRow ; } @ Override public void setCursorRow ( int row ) { if ( row < 0 || row >= bufferSize ) { throw new IllegalArgumentException ( "row out of range" ) ; } cursorRow = row ; } @ Override public int getCursorColumn ( ) { return cursorColumn ; } @ Override public void setCursorColumn ( int column ) { if ( column < 0 || column >= columns ) { throw new IllegalArgumentException ( "column out of range" ) ; } cursorColumn = column ; } @ Override public TerminalCell getCell ( int column , int row ) { if ( column < 0 || row < 0 || column >= columns || row >= bufferSize ) { throw new IndexOutOfBoundsException ( ) ; } return cells [ row ] [ column ] ; } @ Override public void setCell ( int column , int row , TerminalCell cell ) { if ( column < 0 || row < 0 || column >= columns || row >= bufferSize ) { throw new IndexOutOfBoundsException ( ) ; } cells [ row ] [ column ] = cell ; } @ Override public void print ( String str ) { if ( str == null ) { throw new NullPointerException ( "str" ) ; } parser . parse ( str ) ; } @ Override public int getColumns ( ) { return columns ; } @ Override public int getRows ( ) { return rows ; } @ Override public int getBufferSize ( ) { return bufferSize ; } @ Override public BellStrategy getBellStrategy ( ) { return bellStrategy ; } @ Override public void setBellStrategy ( BellStrategy strategy ) { if ( strategy == null ) { throw new NullPointerException ( "strategy" ) ; } this . bellStrategy = strategy ; } @ Override public Color getDefaultBackgroundColor ( ) { final int bg = DEFAULT_BACKGROUND_COLOR ; return DEFAULT_BACKGROUND_BOLD ? SgrColor . COLOR_BRIGHT [ bg ] : SgrColor . COLOR_NORMAL [ bg ] ; } @ Override public Color getDefaultForegroundColor ( ) { final int fg = DEFAULT_FOREGROUND_COLOR ; return DEFAULT_FOREGROUND_BOLD ? SgrColor . COLOR_BRIGHT [ fg ] : SgrColor . COLOR_NORMAL [ fg ] ; } } 
=======
public class SAXParseable < P , NC , L , EA , CL extends CommentList < L > , A extends Annotations < L , EA , CL > > extends SAXSubParser < P , NC , L , EA , CL , A > implements SubParseable < P , NC , L , EA , CL , A > { private final SAXSource source ; public SAXParseable ( SAXSource source , SAXResolver resolver , ErrorHandler eh ) { super ( resolver , eh ) ; this . source = source ; } public P parse ( SchemaBuilder < P , NC , L , EA , CL , A > schemaBuilder , Scope < P , L , EA , CL , A > scope ) throws BuildException , IllegalSchemaException { try { XMLReader xr = source . getXMLReader ( ) ; SchemaParser < P , NC , L , EA , CL , A > sp = new SchemaParser < P , NC , L , EA , CL , A > ( xr , eh , schemaBuilder , null , scope ) ; xr . parse ( source . getInputSource ( ) ) ; return sp . getParsedPattern ( ) ; } catch ( SAXException e ) { throw BuildException . fromSAXException ( e ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } public P parseAsInclude ( SchemaBuilder < P , NC , L , EA , CL , A > schemaBuilder , IncludedGrammar < P , L , EA , CL , A > g ) throws BuildException , IllegalSchemaException { try { XMLReader xr = source . getXMLReader ( ) ; SchemaParser < P , NC , L , EA , CL , A > sp = new SchemaParser < P , NC , L , EA , CL , A > ( xr , eh , schemaBuilder , g , g ) ; xr . parse ( source . getInputSource ( ) ) ; return sp . getParsedPattern ( ) ; } catch ( SAXException e ) { throw BuildException . fromSAXException ( e ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } public String getUri ( ) { final String uri = source . getInputSource ( ) . getSystemId ( ) ; if ( uri == null ) return null ; return Uri . escapeDisallowedChars ( uri ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
