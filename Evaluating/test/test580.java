public class StylesheetValidator extends ValidatorBase { private static final String APTANA_PROFILE = "AptanaProfile" ; private static final String CONFIG_FILE = "AptanaCSSConfig.properties" ; private static final String PROFILES_CONFIG_FILE = "AptanaCSSProfiles.properties" ; private static final String [ ] CUSTOM_PROPERTIES = new String [ ] { "-moz-binding" , "-moz-border-radius" , "-moz-border-radius-bottomleft" , "-moz-border-radius-bottomright" , "-moz-border-radius-topleft" , "-moz-border-radius-topright" , "-moz-border-top-colors" , "-moz-border-right-colors" , "-moz-border-bottom-colors" , "-moz-border-left-colors" , "-moz-opacity" , "-moz-outline" , "-moz-outline-color" , "-moz-outline-style" , "-moz-outline-width" , "-moz-user-focus" , "-moz-user-input" , "-moz-user-modify" , "-moz-user-select" , "-o-link" , "-o-link-source" } ; private static final Set < String > errorsToIgnore = new HashSet < String > ( ) ; static { errorsToIgnore . add ( "inline-table is not a display value" ) ; } private static Pattern errorPattern = Pattern . compile ( "<(error)>(.*?)</\\1>" , Pattern . MULTILINE | Pattern . DOTALL ) ; private static Pattern propertiesPattern = Pattern . compile ( "<([-A-Za-z0-9_:]+)>(.*?)</\\1>" , Pattern . MULTILINE | Pattern . DOTALL ) ; private static Pattern warningPattern = Pattern . compile ( "<(warning)>(.*?)</\\1>" , Pattern . MULTILINE | Pattern . DOTALL ) ; private static final Set < String > NO_MINUS_CUSTOM_PROPERTIES_SET ; static { NO_MINUS_CUSTOM_PROPERTIES_SET = new HashSet < String > ( ) ; for ( int i = 0 ; i < CUSTOM_PROPERTIES . length ; i ++ ) { if ( CUSTOM_PROPERTIES [ i ] . startsWith ( "-" ) ) { NO_MINUS_CUSTOM_PROPERTIES_SET . add ( CUSTOM_PROPERTIES [ i ] . substring ( 1 , CUSTOM_PROPERTIES [ i ] . length ( ) ) ) ; } } } public StylesheetValidator ( ) throws IOException { loadAptanaCSSProfile ( ) ; } public IFileError [ ] parseForErrors ( String path , String source , IFileSourceProvider sourceProvider , boolean collectErrors , boolean collectWarnings , boolean collectInfos ) { UnifiedErrorReporter reporter = new UnifiedErrorReporter ( sourceProvider ) ; NewLineUtils newLineUtils = new NewLineUtils ( source ) ; String patchedSource = patchCSSProperties ( source , reporter , newLineUtils ) ; if ( patchedSource == null || patchedSource . trim ( ) . length ( ) == 0 ) { return new IFileError [ 0 ] ; } String report = getReport ( path , patchedSource ) ; String uri = CoreUIUtils . getURI ( path ) ; if ( collectErrors ) { this . processErrorsInReport ( report , reporter , uri , false , newLineUtils ) ; } if ( collectWarnings ) { this . processWarningsInReport ( report , reporter , uri , false ) ; } return reporter . getErrors ( ) ; } private String getReport ( String path , String sourceString ) { StyleSheetParser parser = new StyleSheetParser ( ) ; ApplContext ac = new ApplContext ( "en" ) ; ac . setCssVersion ( APTANA_PROFILE ) ; try { ByteArrayInputStream stream = new ByteArrayInputStream ( sourceString . getBytes ( ) ) ; URL url = new URL ( "file://" + path ) ; parser . parseStyleElement ( ac , stream , null , null , url , 0 ) ; } catch ( MalformedURLException e ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , StringUtils . format ( Messages . CSSErrorManager_InvalidUL , path ) , e ) ; } int warningLevel = 2 ; StyleSheet styleSheet = parser . getStyleSheet ( ) ; styleSheet . findConflicts ( ac ) ; StyleReport style = StyleReportFactory . getStyleReport ( ac , "Title" , styleSheet , "soap12" , warningLevel ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; style . print ( new PrintWriter ( bout ) ) ; String report = bout . toString ( ) . replaceAll ( "m:" , "" ) ; return report ; } private void processErrorsInReport ( String report , UnifiedErrorReporter reporter , String baseUri , boolean includeExternal , NewLineUtils utils ) { int offset = 0 ; String elementName = "errorlist" ; String startTag = "<" + elementName + ">" ; String endTag = "</" + elementName + ">" ; while ( offset < report . length ( ) ) { int errorListStart = report . indexOf ( startTag , offset ) ; if ( errorListStart != - 1 ) { errorListStart += startTag . length ( ) ; int uriStart = report . indexOf ( "<uri>" , errorListStart ) + "<uri>" . length ( ) ; int uriEnd = report . indexOf ( "</uri>" , uriStart ) ; String uri = report . substring ( uriStart , uriEnd ) ; int errorListEnd = report . indexOf ( endTag , errorListStart ) ; String tempPath = CoreUIUtils . getURI ( uri ) ; tempPath = StringUtils . urlEncodeFilename ( tempPath . toCharArray ( ) ) ; if ( tempPath . equals ( baseUri ) || includeExternal ) { String listString = report . substring ( errorListStart , errorListEnd ) ; String [ ] errors = getContent ( errorPattern , listString ) ; this . parseCSSErrors ( reporter , errors , uri , utils ) ; } offset = errorListEnd + endTag . length ( ) ; } else { offset = report . length ( ) ; } } } private void processWarningsInReport ( String report , UnifiedErrorReporter reporter , String baseUri , boolean includeExternal ) { int offset = 0 ; String elementName = "warninglist" ; String startTag = "<" + elementName + ">" ; String endTag = "</" + elementName + ">" ; while ( offset < report . length ( ) ) { int errorListStart = report . indexOf ( startTag , offset ) ; if ( errorListStart != - 1 ) { errorListStart += startTag . length ( ) ; int uriStart = report . indexOf ( "<uri>" , errorListStart ) + "<uri>" . length ( ) ; int uriEnd = report . indexOf ( "</uri>" , uriStart ) ; String uri = report . substring ( uriStart , uriEnd ) ; int errorListEnd = report . indexOf ( endTag , errorListStart ) ; String tempPath = CoreUIUtils . getURI ( uri ) ; tempPath = StringUtils . urlEncodeFilename ( tempPath . toCharArray ( ) ) ; if ( tempPath . equals ( baseUri ) || includeExternal ) { String listString = report . substring ( errorListStart , errorListEnd ) ; String [ ] warnings = getContent ( warningPattern , listString ) ; this . parseCSSWarnings ( reporter , warnings , uri ) ; } offset = errorListEnd + endTag . length ( ) ; } else { offset = report . length ( ) ; } } } private void parseCSSErrors ( UnifiedErrorReporter err , String [ ] errors , String filename , NewLineUtils utils ) { Map < String , String > map ; for ( int i = 0 ; i < errors . length ; i ++ ) { map = getProperties ( errors [ i ] ) ; int line = Integer . parseInt ( map . get ( "line" ) ) ; String msg = map . get ( "message" ) ; String context = map . get ( "context" ) ; String property = map . get ( "property" ) ; String skippedstring = map . get ( "skippedstring" ) ; String errorsubtype = map . get ( "errorsubtype" ) ; if ( msg == null ) { if ( property == null ) { property = context ; } if ( skippedstring . equals ( "[empty string]" ) ) { skippedstring = "no properties defined" ; } msg = StringUtils . format ( Messages . CSSErrorManager_ErrorParseMessage , new String [ ] { errorsubtype , skippedstring , property } ) ; } Entities e = Entities . HTML40 ; msg = e . unescape ( msg ) ; if ( msg != null ) { int errorOffset = utils . getFirstNonWhitespaceCharacterOffset ( line - 1 ) ; if ( errorOffset == - 1 ) { errorOffset = 0 ; } if ( ! errorsToIgnore . contains ( msg ) ) err . error ( msg , filename , line , context , errorOffset ) ; } } } private void parseCSSWarnings ( UnifiedErrorReporter err , String [ ] warnings , String filename ) { String last = StringUtils . EMPTY ; Map < String , String > map ; for ( int i = 0 ; i < warnings . length ; i ++ ) { map = getProperties ( warnings [ i ] ) ; int line = Integer . parseInt ( map . get ( "line" ) ) ; int level = Integer . parseInt ( map . get ( "level" ) ) ; String msg = StringUtils . format ( Messages . CSSErrorManager_LevelWarningMessage , new String [ ] { map . get ( "message" ) , String . valueOf ( level ) } ) ; String context = map . get ( "context" ) ; String hash = line + ":" + level + ":" + msg + ":" + context ; if ( last . equals ( hash ) == false ) { if ( msg != null ) { err . warning ( msg , filename , line , context , 1 ) ; } } last = hash ; } } private static Map < String , String > getProperties ( String source ) { Pattern pattern = propertiesPattern ; Matcher matcher = pattern . matcher ( source ) ; Map < String , String > result = new HashMap < String , String > ( ) ; while ( matcher . find ( ) ) { result . put ( matcher . group ( 1 ) , matcher . group ( 2 ) ) ; } return result ; } private static String [ ] getContent ( Pattern pattern , String source ) { Matcher matcher = pattern . matcher ( source ) ; List < String > result = new ArrayList < String > ( ) ; while ( matcher . find ( ) ) { result . add ( matcher . group ( 2 ) ) ; } return result . toArray ( new String [ 0 ] ) ; } private void loadAptanaCSSProfile ( ) throws IOException { InputStream configStream = StylesheetValidator . class . getResourceAsStream ( CONFIG_FILE ) ; InputStream profilesStream = StylesheetValidator . class . getResourceAsStream ( PROFILES_CONFIG_FILE ) ; try { Utf8Properties configProperties = new Utf8Properties ( ) ; configProperties . load ( configStream ) ; Utf8Properties profiles = new Utf8Properties ( ) ; profiles . load ( profilesStream ) ; PropertiesLoader . config = configProperties ; Field field = PropertiesLoader . class . getDeclaredField ( "profiles" ) ; field . setAccessible ( true ) ; field . set ( null , profiles ) ; } catch ( Throwable th ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , "Failed to load Aptana CSS profile" , th ) ; } finally { configStream . close ( ) ; profilesStream . close ( ) ; } } private String patchCSSProperties ( String source , UnifiedErrorReporter reporter , NewLineUtils utils ) { try { CSSParser parser ; parser = new CSSParser ( ) ; CSSParseState state = new CSSParseState ( ) ; state . setEditState ( source , source , 0 , 0 ) ; parser . parse ( state ) ; LexemeList lexemes = state . getLexemeList ( ) ; LexemeList lexemesToReplace = new LexemeList ( ) ; for ( int i = 0 ; i < lexemes . size ( ) ; i ++ ) { Lexeme currentLexeme = lexemes . get ( i ) ; String currentLexemeText = currentLexeme . getText ( ) ; if ( isCustomPropertyWithoutMinus ( currentLexemeText ) ) { int errorLineNumber = utils . getLineOfOffset ( currentLexeme . getStartingOffset ( ) ) ; int errorOffset = utils . getFirstNonWhitespaceCharacterOffset ( errorLineNumber ) ; if ( errorLineNumber == - 1 ) { errorLineNumber = 0 ; } if ( errorOffset == - 1 ) { errorOffset = 0 ; } reporter . error ( Messages . StylesheetValidator_ILLEGAL_PROPERTY_MESSAGE + currentLexemeText , "" , errorLineNumber + 1 , "" , errorOffset ) ; } if ( currentLexeme . typeIndex == CSSTokenTypes . PROPERTY && currentLexemeText . startsWith ( "-" ) ) { lexemesToReplace . add ( currentLexeme ) ; } } StringBuffer result = new StringBuffer ( ) ; if ( lexemesToReplace . size ( ) != 0 ) { int offset = 0 ; for ( int i = 0 ; i < lexemesToReplace . size ( ) ; i ++ ) { Lexeme currentLexeme = lexemesToReplace . get ( i ) ; result . append ( source . substring ( offset , currentLexeme . getStartingOffset ( ) ) ) ; offset = currentLexeme . getEndingOffset ( ) ; String currentLexemeText = currentLexeme . getText ( ) ; String patchedText = currentLexemeText . substring ( 1 , currentLexemeText . length ( ) ) ; result . append ( patchedText ) ; } Lexeme lastLexeme = lexemesToReplace . get ( lexemesToReplace . size ( ) - 1 ) ; result . append ( source . substring ( lastLexeme . getEndingOffset ( ) ) ) ; } else { result . append ( source ) ; } return result . toString ( ) ; } catch ( ParserInitializationException e ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , "Failed to patch CSS properties" , e ) ; return source ; } catch ( LexerException e ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , "Failed to patch CSS properties" , e ) ; return source ; } } private boolean isCustomPropertyWithoutMinus ( String propertyName ) { return NO_MINUS_CUSTOM_PROPERTIES_SET . contains ( propertyName ) ; } } 