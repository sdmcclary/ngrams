<<<<<<< HEAD
public class StylesheetValidator extends ValidatorBase { private static final String APTANA_PROFILE = "AptanaProfile" ; private static final String CONFIG_FILE = "AptanaCSSConfig.properties" ; private static final String PROFILES_CONFIG_FILE = "AptanaCSSProfiles.properties" ; private static final String [ ] CUSTOM_PROPERTIES = new String [ ] { "-moz-binding" , "-moz-border-radius" , "-moz-border-radius-bottomleft" , "-moz-border-radius-bottomright" , "-moz-border-radius-topleft" , "-moz-border-radius-topright" , "-moz-border-top-colors" , "-moz-border-right-colors" , "-moz-border-bottom-colors" , "-moz-border-left-colors" , "-moz-opacity" , "-moz-outline" , "-moz-outline-color" , "-moz-outline-style" , "-moz-outline-width" , "-moz-user-focus" , "-moz-user-input" , "-moz-user-modify" , "-moz-user-select" , "-o-link" , "-o-link-source" } ; private static final Set < String > errorsToIgnore = new HashSet < String > ( ) ; static { errorsToIgnore . add ( "inline-table is not a display value" ) ; } private static Pattern errorPattern = Pattern . compile ( "<(error)>(.*?)</\\1>" , Pattern . MULTILINE | Pattern . DOTALL ) ; private static Pattern propertiesPattern = Pattern . compile ( "<([-A-Za-z0-9_:]+)>(.*?)</\\1>" , Pattern . MULTILINE | Pattern . DOTALL ) ; private static Pattern warningPattern = Pattern . compile ( "<(warning)>(.*?)</\\1>" , Pattern . MULTILINE | Pattern . DOTALL ) ; private static final Set < String > NO_MINUS_CUSTOM_PROPERTIES_SET ; static { NO_MINUS_CUSTOM_PROPERTIES_SET = new HashSet < String > ( ) ; for ( int i = 0 ; i < CUSTOM_PROPERTIES . length ; i ++ ) { if ( CUSTOM_PROPERTIES [ i ] . startsWith ( "-" ) ) { NO_MINUS_CUSTOM_PROPERTIES_SET . add ( CUSTOM_PROPERTIES [ i ] . substring ( 1 , CUSTOM_PROPERTIES [ i ] . length ( ) ) ) ; } } } public StylesheetValidator ( ) throws IOException { loadAptanaCSSProfile ( ) ; } public IFileError [ ] parseForErrors ( String path , String source , IFileSourceProvider sourceProvider , boolean collectErrors , boolean collectWarnings , boolean collectInfos ) { UnifiedErrorReporter reporter = new UnifiedErrorReporter ( sourceProvider ) ; NewLineUtils newLineUtils = new NewLineUtils ( source ) ; String patchedSource = patchCSSProperties ( source , reporter , newLineUtils ) ; if ( patchedSource == null || patchedSource . trim ( ) . length ( ) == 0 ) { return new IFileError [ 0 ] ; } String report = getReport ( path , patchedSource ) ; String uri = CoreUIUtils . getURI ( path ) ; if ( collectErrors ) { this . processErrorsInReport ( report , reporter , uri , false , newLineUtils ) ; } if ( collectWarnings ) { this . processWarningsInReport ( report , reporter , uri , false ) ; } return reporter . getErrors ( ) ; } private String getReport ( String path , String sourceString ) { StyleSheetParser parser = new StyleSheetParser ( ) ; ApplContext ac = new ApplContext ( "en" ) ; ac . setCssVersion ( APTANA_PROFILE ) ; try { ByteArrayInputStream stream = new ByteArrayInputStream ( sourceString . getBytes ( ) ) ; URL url = new URL ( "file://" + path ) ; parser . parseStyleElement ( ac , stream , null , null , url , 0 ) ; } catch ( MalformedURLException e ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , StringUtils . format ( Messages . CSSErrorManager_InvalidUL , path ) , e ) ; } int warningLevel = 2 ; StyleSheet styleSheet = parser . getStyleSheet ( ) ; styleSheet . findConflicts ( ac ) ; StyleReport style = StyleReportFactory . getStyleReport ( ac , "Title" , styleSheet , "soap12" , warningLevel ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; style . print ( new PrintWriter ( bout ) ) ; String report = bout . toString ( ) . replaceAll ( "m:" , "" ) ; return report ; } private void processErrorsInReport ( String report , UnifiedErrorReporter reporter , String baseUri , boolean includeExternal , NewLineUtils utils ) { int offset = 0 ; String elementName = "errorlist" ; String startTag = "<" + elementName + ">" ; String endTag = "</" + elementName + ">" ; while ( offset < report . length ( ) ) { int errorListStart = report . indexOf ( startTag , offset ) ; if ( errorListStart != - 1 ) { errorListStart += startTag . length ( ) ; int uriStart = report . indexOf ( "<uri>" , errorListStart ) + "<uri>" . length ( ) ; int uriEnd = report . indexOf ( "</uri>" , uriStart ) ; String uri = report . substring ( uriStart , uriEnd ) ; int errorListEnd = report . indexOf ( endTag , errorListStart ) ; String tempPath = CoreUIUtils . getURI ( uri ) ; tempPath = StringUtils . urlEncodeFilename ( tempPath . toCharArray ( ) ) ; if ( tempPath . equals ( baseUri ) || includeExternal ) { String listString = report . substring ( errorListStart , errorListEnd ) ; String [ ] errors = getContent ( errorPattern , listString ) ; this . parseCSSErrors ( reporter , errors , uri , utils ) ; } offset = errorListEnd + endTag . length ( ) ; } else { offset = report . length ( ) ; } } } private void processWarningsInReport ( String report , UnifiedErrorReporter reporter , String baseUri , boolean includeExternal ) { int offset = 0 ; String elementName = "warninglist" ; String startTag = "<" + elementName + ">" ; String endTag = "</" + elementName + ">" ; while ( offset < report . length ( ) ) { int errorListStart = report . indexOf ( startTag , offset ) ; if ( errorListStart != - 1 ) { errorListStart += startTag . length ( ) ; int uriStart = report . indexOf ( "<uri>" , errorListStart ) + "<uri>" . length ( ) ; int uriEnd = report . indexOf ( "</uri>" , uriStart ) ; String uri = report . substring ( uriStart , uriEnd ) ; int errorListEnd = report . indexOf ( endTag , errorListStart ) ; String tempPath = CoreUIUtils . getURI ( uri ) ; tempPath = StringUtils . urlEncodeFilename ( tempPath . toCharArray ( ) ) ; if ( tempPath . equals ( baseUri ) || includeExternal ) { String listString = report . substring ( errorListStart , errorListEnd ) ; String [ ] warnings = getContent ( warningPattern , listString ) ; this . parseCSSWarnings ( reporter , warnings , uri ) ; } offset = errorListEnd + endTag . length ( ) ; } else { offset = report . length ( ) ; } } } private void parseCSSErrors ( UnifiedErrorReporter err , String [ ] errors , String filename , NewLineUtils utils ) { Map < String , String > map ; for ( int i = 0 ; i < errors . length ; i ++ ) { map = getProperties ( errors [ i ] ) ; int line = Integer . parseInt ( map . get ( "line" ) ) ; String msg = map . get ( "message" ) ; String context = map . get ( "context" ) ; String property = map . get ( "property" ) ; String skippedstring = map . get ( "skippedstring" ) ; String errorsubtype = map . get ( "errorsubtype" ) ; if ( msg == null ) { if ( property == null ) { property = context ; } if ( skippedstring . equals ( "[empty string]" ) ) { skippedstring = "no properties defined" ; } msg = StringUtils . format ( Messages . CSSErrorManager_ErrorParseMessage , new String [ ] { errorsubtype , skippedstring , property } ) ; } Entities e = Entities . HTML40 ; msg = e . unescape ( msg ) ; if ( msg != null ) { int errorOffset = utils . getFirstNonWhitespaceCharacterOffset ( line - 1 ) ; if ( errorOffset == - 1 ) { errorOffset = 0 ; } if ( ! errorsToIgnore . contains ( msg ) ) err . error ( msg , filename , line , context , errorOffset ) ; } } } private void parseCSSWarnings ( UnifiedErrorReporter err , String [ ] warnings , String filename ) { String last = StringUtils . EMPTY ; Map < String , String > map ; for ( int i = 0 ; i < warnings . length ; i ++ ) { map = getProperties ( warnings [ i ] ) ; int line = Integer . parseInt ( map . get ( "line" ) ) ; int level = Integer . parseInt ( map . get ( "level" ) ) ; String msg = StringUtils . format ( Messages . CSSErrorManager_LevelWarningMessage , new String [ ] { map . get ( "message" ) , String . valueOf ( level ) } ) ; String context = map . get ( "context" ) ; String hash = line + ":" + level + ":" + msg + ":" + context ; if ( last . equals ( hash ) == false ) { if ( msg != null ) { err . warning ( msg , filename , line , context , 1 ) ; } } last = hash ; } } private static Map < String , String > getProperties ( String source ) { Pattern pattern = propertiesPattern ; Matcher matcher = pattern . matcher ( source ) ; Map < String , String > result = new HashMap < String , String > ( ) ; while ( matcher . find ( ) ) { result . put ( matcher . group ( 1 ) , matcher . group ( 2 ) ) ; } return result ; } private static String [ ] getContent ( Pattern pattern , String source ) { Matcher matcher = pattern . matcher ( source ) ; List < String > result = new ArrayList < String > ( ) ; while ( matcher . find ( ) ) { result . add ( matcher . group ( 2 ) ) ; } return result . toArray ( new String [ 0 ] ) ; } private void loadAptanaCSSProfile ( ) throws IOException { InputStream configStream = StylesheetValidator . class . getResourceAsStream ( CONFIG_FILE ) ; InputStream profilesStream = StylesheetValidator . class . getResourceAsStream ( PROFILES_CONFIG_FILE ) ; try { Utf8Properties configProperties = new Utf8Properties ( ) ; configProperties . load ( configStream ) ; Utf8Properties profiles = new Utf8Properties ( ) ; profiles . load ( profilesStream ) ; PropertiesLoader . config = configProperties ; Field field = PropertiesLoader . class . getDeclaredField ( "profiles" ) ; field . setAccessible ( true ) ; field . set ( null , profiles ) ; } catch ( Throwable th ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , "Failed to load Aptana CSS profile" , th ) ; } finally { configStream . close ( ) ; profilesStream . close ( ) ; } } private String patchCSSProperties ( String source , UnifiedErrorReporter reporter , NewLineUtils utils ) { try { CSSParser parser ; parser = new CSSParser ( ) ; CSSParseState state = new CSSParseState ( ) ; state . setEditState ( source , source , 0 , 0 ) ; parser . parse ( state ) ; LexemeList lexemes = state . getLexemeList ( ) ; LexemeList lexemesToReplace = new LexemeList ( ) ; for ( int i = 0 ; i < lexemes . size ( ) ; i ++ ) { Lexeme currentLexeme = lexemes . get ( i ) ; String currentLexemeText = currentLexeme . getText ( ) ; if ( isCustomPropertyWithoutMinus ( currentLexemeText ) ) { int errorLineNumber = utils . getLineOfOffset ( currentLexeme . getStartingOffset ( ) ) ; int errorOffset = utils . getFirstNonWhitespaceCharacterOffset ( errorLineNumber ) ; if ( errorLineNumber == - 1 ) { errorLineNumber = 0 ; } if ( errorOffset == - 1 ) { errorOffset = 0 ; } reporter . error ( Messages . StylesheetValidator_ILLEGAL_PROPERTY_MESSAGE + currentLexemeText , "" , errorLineNumber + 1 , "" , errorOffset ) ; } if ( currentLexeme . typeIndex == CSSTokenTypes . PROPERTY && currentLexemeText . startsWith ( "-" ) ) { lexemesToReplace . add ( currentLexeme ) ; } } StringBuffer result = new StringBuffer ( ) ; if ( lexemesToReplace . size ( ) != 0 ) { int offset = 0 ; for ( int i = 0 ; i < lexemesToReplace . size ( ) ; i ++ ) { Lexeme currentLexeme = lexemesToReplace . get ( i ) ; result . append ( source . substring ( offset , currentLexeme . getStartingOffset ( ) ) ) ; offset = currentLexeme . getEndingOffset ( ) ; String currentLexemeText = currentLexeme . getText ( ) ; String patchedText = currentLexemeText . substring ( 1 , currentLexemeText . length ( ) ) ; result . append ( patchedText ) ; } Lexeme lastLexeme = lexemesToReplace . get ( lexemesToReplace . size ( ) - 1 ) ; result . append ( source . substring ( lastLexeme . getEndingOffset ( ) ) ) ; } else { result . append ( source ) ; } return result . toString ( ) ; } catch ( ParserInitializationException e ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , "Failed to patch CSS properties" , e ) ; return source ; } catch ( LexerException e ) { IdeLog . logError ( CSSPlugin . getDefault ( ) , "Failed to patch CSS properties" , e ) ; return source ; } } private boolean isCustomPropertyWithoutMinus ( String propertyName ) { return NO_MINUS_CUSTOM_PROPERTIES_SET . contains ( propertyName ) ; } } 
=======
abstract class AbstractDatetime extends AbstractDatatype { private static int [ ] DAYS_IN_MONTHS = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; AbstractDatetime ( ) { super ( ) ; } private void checkMonth ( String year , String month ) throws DatatypeException { checkMonth ( Integer . parseInt ( year ) , Integer . parseInt ( month ) ) ; } private void checkMonth ( int year , int month ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } } private void checkDate ( String year , String month , String day ) throws DatatypeException { checkDate ( Integer . parseInt ( year ) , Integer . parseInt ( month ) , Integer . parseInt ( day ) ) ; } private void checkDate ( int year , int month , int day ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } if ( day < 1 ) { throw newDatatypeException ( "Day cannot be less than 1." ) ; } if ( day > DAYS_IN_MONTHS [ month - 1 ] ) { if ( ! ( day == 29 && month == 2 && isLeapYear ( year ) ) ) { throw newDatatypeException ( "Day out of range." ) ; } } } private boolean isLeapYear ( int year ) { return ( year % 400 == 0 ) || ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) ; } private void checkYearlessDate ( String month , String day ) throws DatatypeException { checkYearlessDate ( Integer . parseInt ( month ) , Integer . parseInt ( day ) ) ; } private void checkYearlessDate ( int month , int day ) throws DatatypeException { if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } if ( day < 1 ) { throw newDatatypeException ( "Day cannot be less than 1." ) ; } } private void checkWeek ( String year , String week ) throws DatatypeException { checkWeek ( Integer . parseInt ( year ) , Integer . parseInt ( week ) ) ; } private void checkWeek ( int year , int week ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( week < 1 ) { throw newDatatypeException ( "Week cannot be less than 1." ) ; } if ( week > 53 ) { throw newDatatypeException ( "Week cannot be greater than 53." ) ; } } protected final void checkHour ( String hour ) throws DatatypeException { checkHour ( Integer . parseInt ( hour ) ) ; } private void checkHour ( int hour ) throws DatatypeException { if ( hour > 23 ) { throw newDatatypeException ( "Hour cannot be greater than 23." ) ; } } protected final void checkMinute ( String minute ) throws DatatypeException { checkMinute ( Integer . parseInt ( minute ) ) ; } private void checkMinute ( int minute ) throws DatatypeException { if ( minute > 59 ) { throw newDatatypeException ( "Minute cannot be greater than 59." ) ; } } protected final void checkSecond ( String second ) throws DatatypeException { checkSecond ( Integer . parseInt ( second ) ) ; } private void checkSecond ( int second ) throws DatatypeException { if ( second > 59 ) { throw newDatatypeException ( "Second cannot be greater than 59." ) ; } } protected final void checkMilliSecond ( String millisecond ) throws DatatypeException { if ( millisecond . length ( ) > 3 ) { throw newDatatypeException ( "A fraction of a second must be one, two, or three digits." ) ; } } private void checkTzd ( String hours , String minutes ) throws DatatypeException { if ( hours . charAt ( 0 ) == '+' ) { hours = hours . substring ( 1 ) ; } checkTzd ( Integer . parseInt ( hours ) , Integer . parseInt ( minutes ) ) ; } private void checkTzd ( int hours , int minutes ) throws DatatypeException { if ( hours < - 23 || hours > 23 ) { throw newDatatypeException ( "Hours out of range in time zone designator." ) ; } if ( minutes > 59 ) { throw newDatatypeException ( "Minutes out of range in time zone designator." ) ; } } protected abstract Pattern getPattern ( ) ; public void checkValid ( CharSequence literal ) throws DatatypeException { String year ; String month ; String day ; String hour ; String minute ; String seconds ; String milliseconds ; String tzdHours ; String tzdMinutes ; Matcher m = getPattern ( ) . matcher ( literal ) ; if ( m . matches ( ) ) { year = m . group ( 1 ) ; month = m . group ( 2 ) ; if ( year != null ) { checkMonth ( year , month ) ; return ; } year = m . group ( 3 ) ; month = m . group ( 4 ) ; day = m . group ( 5 ) ; if ( year != null ) { checkDate ( year , month , day ) ; return ; } month = m . group ( 6 ) ; day = m . group ( 7 ) ; if ( year != null ) { checkYearlessDate ( month , day ) ; return ; } hour = m . group ( 8 ) ; minute = m . group ( 9 ) ; seconds = m . group ( 10 ) ; milliseconds = m . group ( 11 ) ; if ( hour != null ) { checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } return ; } year = m . group ( 12 ) ; month = m . group ( 13 ) ; day = m . group ( 14 ) ; hour = m . group ( 15 ) ; minute = m . group ( 16 ) ; seconds = m . group ( 17 ) ; milliseconds = m . group ( 18 ) ; if ( year != null ) { checkDate ( year , month , day ) ; checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } return ; } tzdHours = m . group ( 19 ) ; tzdMinutes = m . group ( 20 ) ; if ( tzdHours != null ) { checkTzd ( tzdHours , tzdMinutes ) ; return ; } year = m . group ( 21 ) ; month = m . group ( 22 ) ; day = m . group ( 23 ) ; hour = m . group ( 24 ) ; minute = m . group ( 25 ) ; seconds = m . group ( 26 ) ; milliseconds = m . group ( 27 ) ; tzdHours = m . group ( 28 ) ; tzdMinutes = m . group ( 29 ) ; if ( year != null ) { checkDate ( year , month , day ) ; checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } if ( tzdHours != null ) { checkTzd ( tzdHours , tzdMinutes ) ; } return ; } year = m . group ( 30 ) ; String week = m . group ( 31 ) ; if ( year != null ) { checkWeek ( year , week ) ; } year = m . group ( 32 ) ; if ( year != null && Integer . parseInt ( year ) < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } milliseconds = m . group ( 33 ) ; if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; return ; } milliseconds = m . group ( 34 ) ; if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; return ; } } else { throw newDatatypeException ( "The literal did not satisfy the " + getName ( ) + " format." ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
