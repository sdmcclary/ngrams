<<<<<<< HEAD
public final class BrowserExtensionLoader { private static List < IConfigurationElement > browserList = null ; private static List < String > allBrowsers = null ; private static List < IConfigurationElement > showList = new ArrayList < IConfigurationElement > ( ) ; private static IPropertyChangeListener propertyChangeListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { if ( IPreferenceConstants . CSSEDITOR_BROWSER_PREVIEW_PREFERENCE . equals ( event . getProperty ( ) ) ) { computeShowList ( ) ; } } } ; private static String OS = Platform . getOS ( ) ; private BrowserExtensionLoader ( ) { } public static String getBrowserLabel ( IConfigurationElement browserElement ) { String label = null ; boolean found = false ; IConfigurationElement [ ] ce = browserElement . getChildren ( UnifiedEditorsPlugin . LABEL_NODE ) ; for ( int k = 0 ; k < ce . length && ! found ; k ++ ) { if ( ce [ k ] . getAttribute ( UnifiedEditorsPlugin . OS_ATTR ) != null && ce [ k ] . getAttribute ( UnifiedEditorsPlugin . VALUE_ATTR ) != null ) { if ( OS . equals ( ce [ k ] . getAttribute ( UnifiedEditorsPlugin . OS_ATTR ) ) ) { label = ce [ k ] . getAttribute ( UnifiedEditorsPlugin . VALUE_ATTR ) ; found = true ; } } } return label ; } private static void computeShowList ( ) { showList . clear ( ) ; String browserString = CSSPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IPreferenceConstants . CSSEDITOR_BROWSER_PREVIEW_PREFERENCE ) ; String [ ] browsers_names = browserString . split ( "," ) ; IConfigurationElement safari = null ; IConfigurationElement element ; int size = browserList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { element = browserList . get ( i ) ; String name = getBrowserLabel ( element ) ; if ( safari == null && "Safari" . equals ( name ) ) { safari = element ; } if ( name != null ) { boolean show = false ; for ( int k = 0 ; k < browsers_names . length && ! show ; k ++ ) { if ( name . equals ( browsers_names [ k ] ) ) { show = true ; } } if ( show ) { showList . add ( element ) ; } } } if ( OS . equals ( Platform . OS_MACOSX ) ) { if ( showList . size ( ) == 1 ) { element = showList . get ( 0 ) ; IPreferenceStore store = CSSPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . removePropertyChangeListener ( propertyChangeListener ) ; if ( getBrowserLabel ( element ) . equals ( "Firefox" ) ) { if ( safari != null ) { showList . add ( 0 , safari ) ; store . setValue ( IPreferenceConstants . CSSEDITOR_BROWSER_PREVIEW_PREFERENCE , browserString + ",Safari" ) ; } else { showList . clear ( ) ; store . setValue ( IPreferenceConstants . CSSEDITOR_BROWSER_PREVIEW_PREFERENCE , "" ) ; } } store . addPropertyChangeListener ( propertyChangeListener ) ; } } } public static List < IConfigurationElement > loadBrowsers ( ) { if ( browserList == null ) { browserList = new ArrayList < IConfigurationElement > ( ) ; IExtensionRegistry reg = Platform . getExtensionRegistry ( ) ; IExtensionPoint ep = reg . getExtensionPoint ( UnifiedEditorsPlugin . BROWSER_EXTENSION_POINT ) ; IExtension [ ] extensions = ep . getExtensions ( ) ; CSSPlugin . getDefault ( ) . getPreferenceStore ( ) . addPropertyChangeListener ( propertyChangeListener ) ; IConfigurationElement [ ] ce ; String browserClass ; String browserName ; for ( int i = 0 ; i < extensions . length ; i ++ ) { ce = extensions [ i ] . getConfigurationElements ( ) ; for ( int j = 0 ; j < ce . length ; j ++ ) { browserClass = ce [ j ] . getAttribute ( UnifiedEditorsPlugin . CLASS_ATTR ) ; browserName = getBrowserLabel ( ce [ j ] ) ; if ( browserClass != null && browserName != null ) { browserList . add ( ce [ j ] ) ; } } } Collections . sort ( browserList , new Comparator < IConfigurationElement > ( ) { public int compare ( IConfigurationElement o1 , IConfigurationElement o2 ) { String name1 = getBrowserLabel ( o1 ) ; String name2 = getBrowserLabel ( o2 ) ; if ( name1 != null && name2 != null ) { if ( Platform . getOS ( ) . equals ( Platform . OS_MACOSX ) ) { return name2 . compareTo ( name1 ) ; } return name1 . compareTo ( name2 ) ; } return 0 ; } } ) ; computeShowList ( ) ; } return showList ; } public static List < String > getAllBrowserLabels ( ) { if ( allBrowsers == null ) { allBrowsers = new ArrayList < String > ( ) ; IExtensionRegistry reg = Platform . getExtensionRegistry ( ) ; IExtensionPoint ep = reg . getExtensionPoint ( UnifiedEditorsPlugin . BROWSER_EXTENSION_POINT ) ; IExtension [ ] extensions = ep . getExtensions ( ) ; IConfigurationElement [ ] ce ; String browserClass ; String browserName ; for ( int i = 0 ; i < extensions . length ; i ++ ) { ce = extensions [ i ] . getConfigurationElements ( ) ; for ( int j = 0 ; j < ce . length ; j ++ ) { browserClass = ce [ j ] . getAttribute ( UnifiedEditorsPlugin . CLASS_ATTR ) ; browserName = BrowserExtensionLoader . getBrowserLabel ( ce [ j ] ) ; if ( browserClass != null && browserName != null ) { allBrowsers . add ( browserName ) ; } } } Collections . sort ( allBrowsers , new Comparator < String > ( ) { public int compare ( String name1 , String name2 ) { if ( name1 != null && name2 != null ) { return name1 . compareTo ( name2 ) ; } return 0 ; } } ) ; } return allBrowsers ; } } 
=======
public class DataUri { public static boolean startsWithData ( String uri ) { return uri != null && uri . length ( ) >= 5 && ( uri . charAt ( 0 ) == 'd' || uri . charAt ( 0 ) == 'D' ) && ( uri . charAt ( 1 ) == 'a' || uri . charAt ( 1 ) == 'A' ) && ( uri . charAt ( 2 ) == 't' || uri . charAt ( 2 ) == 'T' ) && ( uri . charAt ( 3 ) == 'a' || uri . charAt ( 3 ) == 'A' ) && ( uri . charAt ( 4 ) == ':' ) ; } private enum State { AT_START , IN_SUPERTYPE , AT_SUBTYPE_START , IN_SUBTYPE , SEMICOLON_SEEN , WS_BEFORE_SEMICOLON , IN_PARAM_NAME , EQUALS_SEEN , IN_QUOTED_STRING , IN_UNQUOTED_STRING , IN_QUOTED_PAIR , CLOSE_QUOTE_SEEN } private String contentType ; private InputStream inputStream ; protected void init ( IRI uri ) throws IOException , MalformedURLException { if ( ! uri . getScheme ( ) . equals ( "data" ) ) { throw new IllegalArgumentException ( "The input did not start with data:." ) ; } if ( uri . getRawFragment ( ) != null ) { throw new MalformedURLException ( "Fragment is not allowed for data: URIs according to RFC 2397. But if strictly comply with RFC 3986, ignore this error." ) ; } InputStream is = new PercentDecodingReaderInputStream ( new StringReader ( uri . getRawPath ( ) ) ) ; StringBuilder sb = new StringBuilder ( ) ; State state = State . AT_START ; int i = 0 ; for ( ; ; i ++ ) { int b = is . read ( ) ; if ( b == - 1 ) { throw new MalformedURLException ( "Premature end of URI." ) ; } if ( b >= 0x80 ) { throw new MalformedURLException ( "Non-ASCII character in MIME type part of the data URI." ) ; } char c = ( char ) b ; sb . append ( c ) ; switch ( state ) { case AT_START : if ( isTokenChar ( c ) ) { state = State . IN_SUPERTYPE ; continue ; } else if ( c == ';' ) { sb . setLength ( 0 ) ; sb . append ( "text/plain;" ) ; state = State . SEMICOLON_SEEN ; continue ; } else if ( c == ',' ) { contentType = "text/plain;charset=US-ASCII" ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected a token character or a semicolon but saw " , c , " instead." ) ; } case IN_SUPERTYPE : if ( isTokenChar ( c ) ) { continue ; } else if ( c == '/' ) { state = State . AT_SUBTYPE_START ; continue ; } else { throw newDatatypeException ( i , "Expected a token character or “/” but saw " , c , " instead." ) ; } case AT_SUBTYPE_START : if ( isTokenChar ( c ) ) { state = State . IN_SUBTYPE ; continue ; } else { throw newDatatypeException ( i , "Expected a token character but saw " , c , " instead." ) ; } case IN_SUBTYPE : if ( isTokenChar ( c ) ) { continue ; } else if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_SEMICOLON ; continue ; } else if ( c == ',' ) { contentType = sb . substring ( 0 , sb . length ( ) - 1 ) ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected a token character, whitespace, a semicolon or a comma but saw " , c , " instead." ) ; } case WS_BEFORE_SEMICOLON : if ( isWhitespace ( c ) ) { continue ; } else if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected whitespace or a semicolon but saw " , c , " instead." ) ; } case SEMICOLON_SEEN : if ( isWhitespace ( c ) ) { continue ; } else if ( isTokenChar ( c ) ) { state = State . IN_PARAM_NAME ; continue ; } else { throw newDatatypeException ( i , "Expected whitespace or a token character but saw " , c , " instead." ) ; } case IN_PARAM_NAME : if ( isTokenChar ( c ) ) { continue ; } else if ( c == '=' ) { state = State . EQUALS_SEEN ; continue ; } else if ( c == ',' ) { int baseFirst = sb . length ( ) - 8 ; if ( baseFirst >= 0 && ";base64," . equals ( sb . substring ( baseFirst , sb . length ( ) ) ) ) { contentType = sb . substring ( 0 , baseFirst ) ; inputStream = new Base64InputStream ( is ) ; return ; } } else { throw newDatatypeException ( i , "Expected an equals sign, a comma or a token character but saw " , c , " instead." ) ; } case EQUALS_SEEN : if ( c == '\"' ) { state = State . IN_QUOTED_STRING ; continue ; } else if ( isTokenChar ( c ) ) { state = State . IN_UNQUOTED_STRING ; continue ; } else { throw newDatatypeException ( i , "Expected a double quote or a token character but saw " , c , " instead." ) ; } case IN_QUOTED_STRING : if ( c == '\\' ) { state = State . IN_QUOTED_PAIR ; continue ; } else if ( c == '\"' ) { state = State . CLOSE_QUOTE_SEEN ; continue ; } else if ( isQDTextChar ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a non-control ASCII character but saw " , c , " instead." ) ; } case IN_QUOTED_PAIR : if ( c <= 127 ) { state = State . IN_QUOTED_STRING ; continue ; } else { throw newDatatypeException ( i , "Expected an ASCII character but saw " , c , " instead." ) ; } case CLOSE_QUOTE_SEEN : if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_SEMICOLON ; continue ; } else if ( c == ',' ) { contentType = sb . substring ( 0 , sb . length ( ) - 1 ) ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected an ASCII character but saw " , c , " instead." ) ; } case IN_UNQUOTED_STRING : if ( isTokenChar ( c ) ) { continue ; } else if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_SEMICOLON ; continue ; } else if ( c == ',' ) { contentType = sb . substring ( 0 , sb . length ( ) - 1 ) ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected a token character, whitespace, a semicolon, or a comma but saw " , c , " instead." ) ; } } } } public DataUri ( String uri ) throws IOException , MalformedURLException { IRIFactory fac = new IRIFactory ( ) ; fac . shouldViolation ( true , false ) ; fac . securityViolation ( true , false ) ; fac . dnsViolation ( true , false ) ; fac . mintingViolation ( false , false ) ; fac . useSpecificationIRI ( true ) ; init ( fac . construct ( uri ) ) ; } public DataUri ( IRI uri ) throws IOException , MalformedURLException { init ( uri ) ; } private IOException newDatatypeException ( int i , String head , char c , String tail ) { return new DataUriException ( i , head , c , tail ) ; } private boolean isQDTextChar ( char c ) { return ( c >= ' ' && c <= 126 ) || ( c == '\n' ) || ( c == '\r' ) || ( c == '\t' ) ; } private boolean isTokenChar ( char c ) { return ( c >= 33 && c <= 126 ) && ! ( c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\' || c == '\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}' ) ; } private boolean isWhitespace ( char c ) { return c == ' ' || c == '\t' || c == '\n' || c == '\r' ; } public String getContentType ( ) { return contentType ; } public InputStream getInputStream ( ) { return inputStream ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
