<<<<<<< HEAD
public class XMLParser extends XMLParserBase { private static final int [ ] elementEndSet = new int [ ] { XMLTokenTypes . GREATER_THAN , XMLTokenTypes . SLASH_GREATER_THAN } ; private Stack < IParseNode > _elementStack ; static { Arrays . sort ( elementEndSet ) ; } public XMLParser ( ) throws ParserInitializationException { this ( XMLMimeType . MimeType ) ; } public XMLParser ( String mimeType ) throws ParserInitializationException { super ( mimeType ) ; this . _elementStack = new Stack < IParseNode > ( ) ; } private void closeElement ( ) { if ( this . _currentElement != null ) { this . _currentElement . includeLexemeInRange ( this . currentLexeme ) ; } if ( this . _elementStack . size ( ) > 0 ) { this . _currentElement = this . _elementStack . pop ( ) ; } else { this . _currentElement = null ; } } private XMLParseNode createNode ( int type , Lexeme startingLexeme ) { return ( XMLParseNode ) this . getParseNodeFactory ( ) . createParseNode ( type , startingLexeme ) ; } private void openElement ( XMLElementNode element ) { if ( this . _currentElement != null ) { this . _currentElement . appendChild ( element ) ; } this . _elementStack . push ( this . _currentElement ) ; this . _currentElement = element ; } public synchronized void parseAll ( IParseNode parentNode ) throws LexerException { this . _elementStack . clear ( ) ; this . _currentElement = parentNode ; ILexer lexer = this . getLexer ( ) ; lexer . setLanguageAndGroup ( this . getLanguage ( ) , DEFAULT_GROUP ) ; try { this . parseText ( false ) ; } catch ( ParseException e ) { lexer . setGroup ( DEFAULT_GROUP ) ; } while ( this . isEOS ( ) == false ) { try { switch ( this . currentLexeme . typeIndex ) { case XMLTokenTypes . CDATA_START : this . parseCDATASection ( ) ; break ; case XMLTokenTypes . COMMENT : this . parseText ( false ) ; break ; case XMLTokenTypes . DOCTYPE_DECL : this . parseDocTypeDeclaration ( ) ; break ; case XMLTokenTypes . END_TAG : this . parseEndTag ( ) ; break ; case XMLTokenTypes . PI_OPEN : this . parsePI ( ) ; this . parseText ( false ) ; break ; case XMLTokenTypes . START_TAG : this . parseStartTag ( ) ; break ; case XMLTokenTypes . XML_DECL : this . parseXMLDeclaration ( ) ; break ; default : this . advance ( ) ; } } catch ( ParseException e ) { lexer . setGroup ( DEFAULT_GROUP ) ; } } } private void parseAttribute ( ) throws ParseException , LexerException { String name = this . currentLexeme . getText ( ) ; this . assertAndAdvance ( XMLTokenTypes . NAME , "error.attribute" ) ; this . assertAndAdvance ( XMLTokenTypes . EQUAL , "error.attribute.equal" ) ; this . assertType ( XMLTokenTypes . STRING , "error.attribute.value" ) ; if ( this . currentLexeme . getCategoryIndex ( ) != TokenCategories . ERROR ) { String value = this . currentLexeme . getText ( ) ; char firstChar = value . charAt ( 0 ) ; int quoteType = QuoteType . NONE ; if ( firstChar == '"' ) { value = value . substring ( 1 , value . length ( ) - 1 ) ; quoteType = QuoteType . DOUBLE_QUOTE ; } else if ( firstChar == '\'' ) { value = value . substring ( 1 , value . length ( ) - 1 ) ; quoteType = QuoteType . SINGLE_QUOTE ; } this . _currentElement . setAttribute ( name , value ) ; IParseNodeAttribute attr = this . _currentElement . getAttributeNode ( name ) ; attr . setQuoteType ( quoteType ) ; } this . advance ( ) ; } private void parseCDATASection ( ) throws LexerException , ParseException { ILexer lexer = this . getLexer ( ) ; lexer . setGroup ( CDATA_SECTION_GROUP ) ; this . assertAndAdvance ( XMLTokenTypes . CDATA_START , "error.cdata" ) ; this . assertAndAdvance ( XMLTokenTypes . CDATA_END , "error.cdata.close" ) ; } private void parseEndTag ( ) throws LexerException , ParseException { this . assertAndAdvance ( XMLTokenTypes . END_TAG , "error.tag.end" ) ; this . closeElement ( ) ; this . parseText ( true ) ; } private void parsePI ( ) throws LexerException , ParseException { ILexer lexer = this . getLexer ( ) ; lexer . setGroup ( PROCESSING_INSTRUCTION_GROUP ) ; this . assertAndAdvance ( XMLTokenTypes . PI_OPEN , "error.pi" ) ; this . assertAndAdvance ( XMLTokenTypes . CDATA_END , "error.pi.close" ) ; } private void parseStartTag ( ) throws ParseException , LexerException { this . assertType ( XMLTokenTypes . START_TAG , "error.tag.start" ) ; XMLElementNode element = ( XMLElementNode ) this . createNode ( XMLParseNodeTypes . ELEMENT , this . currentLexeme ) ; this . openElement ( element ) ; this . advance ( ) ; while ( this . isEOS ( ) == false && this . inSet ( elementEndSet ) == false ) { this . parseAttribute ( ) ; } switch ( this . currentLexeme . typeIndex ) { case XMLTokenTypes . GREATER_THAN : break ; case XMLTokenTypes . SLASH_GREATER_THAN : this . closeElement ( ) ; break ; default : throwParseError ( "error.tag.start.unclosed" ) ; } parseText ( false ) ; } private XMLDeclarationNode parseXMLDeclaration ( ) throws LexerException , ParseException { this . getLexer ( ) . setGroup ( XML_DECLARATION_GROUP ) ; XMLDeclarationNode decl = ( XMLDeclarationNode ) this . createNode ( XMLParseNodeTypes . DECLARATION , this . currentLexeme ) ; this . assertAndAdvance ( XMLTokenTypes . XML_DECL , "error.xml.declaration" ) ; decl . setVersion ( this . currentLexeme . getText ( ) ) ; if ( this . _currentElement instanceof ParseRootNode ) { this . _currentElement . appendChild ( decl ) ; } this . assertAndAdvance ( XMLTokenTypes . VERSION , "error.xml.declaration.version" ) ; if ( this . isType ( XMLTokenTypes . ENCODING ) ) { decl . setEncoding ( this . currentLexeme . getText ( ) ) ; this . advance ( ) ; } if ( this . isType ( XMLTokenTypes . STANDALONE ) ) { decl . setStandalone ( this . currentLexeme . getText ( ) ) ; this . advance ( ) ; } this . getLexer ( ) . setGroup ( DEFAULT_GROUP ) ; this . assertAndAdvance ( XMLTokenTypes . QUESTION_GREATER_THAN , "error.xml.declaration.close" ) ; return decl ; } } 
=======
public class MetaCharset extends AbstractDatatype { public static final MetaCharset THE_INSTANCE = new MetaCharset ( ) ; public MetaCharset ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { String lower = toAsciiLowerCase ( literal ) ; if ( ! lower . startsWith ( "text/html;" ) ) { throw newDatatypeException ( "The legacy encoding declaration did not start with " , "text/html;" , "." ) ; } if ( lower . length ( ) == 10 ) { throw newDatatypeException ( "The legacy encoding declaration ended prematurely." ) ; } int offset = 10 ; paramloop : for ( int i = 10 ; i < lower . length ( ) ; i ++ ) { char c = lower . charAt ( i ) ; switch ( c ) { case ' ' : case '\t' : case '\n' : case '' : case '\r' : offset ++ ; continue ; case 'c' : break paramloop ; default : throw newDatatypeException ( "The legacy encoding declaration" + " did not start with space characters or " , "charset=" , " after the semicolon. " + " Found “" + c + "” instead." ) ; } } if ( ! lower . startsWith ( "charset=" , offset ) ) { throw newDatatypeException ( "The legacy encoding declaration" + "did not contain " , "charset=" , " after the semicolon." ) ; } offset += 8 ; if ( lower . length ( ) == offset ) { throw newDatatypeException ( "The empty string is not a valid character encoding name." ) ; } for ( int i = offset ; i < lower . length ( ) ; i ++ ) { char c = lower . charAt ( i ) ; if ( ! ( ( c >= '0' && c <= '9' ) || ( c >= 'a' && c <= 'z' ) || c == '-' || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\'' || c == '+' || c == '_' || c == '`' || c == '{' || c == '}' || c == '~' || c == '^' ) ) { throw newDatatypeException ( "The legacy encoding contained " , c , ", which is not a valid character in an encoding name." ) ; } } String encodingName = lower . substring ( offset ) ; if ( "replacement" . equals ( encodingName ) || ! CharsetData . isPreferred ( encodingName ) ) { String preferred = CharsetData . preferredForLabel ( encodingName ) ; if ( preferred == null || "replacement" . equals ( preferred ) ) { throw newDatatypeException ( "“" + encodingName + "” is not a valid character encoding name." ) ; } throw newDatatypeException ( "“" + encodingName + "” is not a preferred encoding name." + " The preferred label for this encoding is “" + preferred + "”." ) ; } } @ Override public String getName ( ) { return "legacy character encoding declaration" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
