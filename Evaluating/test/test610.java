<<<<<<< HEAD
public class ScriptDocParser extends ScriptDocParserBase { public static final String INDENT_GROUP = "indent" ; private IDocumentation _rootNode ; private FunctionDocumentation _parsedObject ; private IParseNode _curParent ; private String _curScriptNamespace ; public ScriptDocParser ( ) throws ParserInitializationException { this ( ScriptDocMimeType . MimeType ) ; } public ScriptDocParser ( String mimeType ) throws ParserInitializationException { super ( mimeType ) ; this . _curScriptNamespace = "" ; } public synchronized void parseAll ( IParseNode parentNode ) throws LexerException { this . _curParent = parentNode ; this . startingIndex = - 1 ; this . endingIndex = - 1 ; ILexer lexer = this . getLexer ( ) ; lexer . setLanguageAndGroup ( this . getLanguage ( ) , "default" ) ; try { this . _parsedObject = this . parseDocumentation ( ) ; } catch ( ParseException e ) { lexer . setCurrentOffset ( lexer . getEOFOffset ( ) ) ; } IParseState parseState = this . getParseState ( ) ; if ( parseState instanceof ScriptDocParseState ) { ScriptDocParseState scriptDocParseState = ( ScriptDocParseState ) parseState ; LexemeList lexemes = this . getLexemeList ( ) ; Lexeme lastLexeme = lexemes . get ( lexemes . size ( ) - 1 ) ; IDocumentationStore documentationStore = scriptDocParseState . getDocumentationStore ( ) ; documentationStore . addScriptDocObject ( lexer . getCurrentOffset ( ) , lastLexeme , this . _parsedObject ) ; } else { throw new IllegalStateException ( Messages . ScriptDocParser_MustHaveScriptDocParseState ) ; } if ( endingIndex != - 1 && startingIndex != - 1 ) { GenericCommentNode node = new GenericCommentNode ( startingIndex , endingIndex , "SDCOMMENT" , JSMimeType . MimeType ) ; this . getParseState ( ) . addCommentRegion ( node ) ; } } public FunctionDocumentation getParsedObject ( ) { return this . _parsedObject ; } private FunctionDocumentation parseDocumentation ( ) throws ParseException , LexerException { FunctionDocumentation fd = new FunctionDocumentation ( ) ; this . _rootNode = fd ; boolean wasNull = false ; if ( this . currentLexeme == null ) { advance ( ) ; wasNull = true ; } if ( this . currentLexeme == EOS ) { advance ( ) ; if ( this . currentLexeme != null && this . currentLexeme != EOS ) { this . _curNode = new ScriptDocParseNode ( this . currentLexeme ) ; this . _curNode . includeLexemeInRange ( this . currentLexeme ) ; } else { return fd ; } } else { this . _curNode = new ScriptDocParseNode ( this . currentLexeme ) ; if ( ! wasNull ) { advance ( ) ; } } if ( this . currentLexeme != EOS ) { if ( this . _curParent != null ) { this . _curParent . appendChild ( this . _curNode ) ; } this . _curNode . setDocument ( this . _parsedObject ) ; assertAndAdvance ( ScriptDocTokenTypes . START_DOCUMENTATION ) ; fd . setDescription ( parseText ( ) ) ; while ( this . _holderLexeme != EOS ) { this . parseFunctionDocumentationSection ( fd ) ; } } return fd ; } public void setSource ( String source ) { this . getLexer ( ) . setSource ( source ) ; } private boolean parseBaseTags ( DocumentationBase bd ) throws LexerException { boolean result = false ; if ( this . _holderLexeme . getCategoryIndex ( ) == TokenCategories . KEYWORD ) { try { switch ( this . _holderLexeme . typeIndex ) { case ScriptDocTokenTypes . ADVANCED : advance ( ) ; result = true ; break ; case ScriptDocTokenTypes . AUTHOR : advance ( ) ; bd . setAuthor ( parseText ( ) ) ; result = true ; break ; case ScriptDocTokenTypes . VERSION : advance ( ) ; bd . setVersion ( parseText ( ) ) ; result = true ; break ; case ScriptDocTokenTypes . SEE : advance ( ) ; bd . addSee ( parseText ( ) ) ; result = true ; break ; case ScriptDocTokenTypes . SDOC : advance ( ) ; bd . addSDocLocation ( parseText ( ) ) ; result = true ; break ; case ScriptDocTokenTypes . NAMESPACE : advance ( ) ; parseNamespace ( ) ; result = true ; break ; case ScriptDocTokenTypes . COPYRIGHT : advance ( ) ; parseText ( ) ; result = true ; break ; case ScriptDocTokenTypes . LICENSE : advance ( ) ; parseText ( ) ; result = true ; break ; case ScriptDocTokenTypes . EXAMPLE : advance ( ) ; bd . addExample ( parseText ( ) ) ; result = true ; break ; case ScriptDocTokenTypes . OVERVIEW : advance ( ) ; this . parseText ( ) ; result = true ; break ; case ScriptDocTokenTypes . PROJECT_DESCRIPTION : advance ( ) ; bd . setDescription ( parseText ( ) ) ; bd . setDocumentType ( IDocumentation . TYPE_PROJECT ) ; result = true ; default : break ; } } catch ( ParseException e ) { skipTag ( e ) ; } } else { try { String desc = parseText ( ) ; if ( ! StringUtils . EMPTY . equals ( desc ) ) { bd . setDescription ( desc ) ; } } catch ( ParseException e ) { skipTag ( e ) ; } } return result ; } private boolean parsePropertyTags ( PropertyDocumentation pd ) throws LexerException { boolean found = parseBaseTags ( pd ) ; if ( found ) { return true ; } boolean result = false ; if ( found == false && this . _holderLexeme . getCategoryIndex ( ) == TokenCategories . KEYWORD ) { try { switch ( this . _holderLexeme . typeIndex ) { case ScriptDocTokenTypes . MEMBER_OF : advance ( ) ; parseMemberOf ( pd ) ; result = true ; break ; case ScriptDocTokenTypes . IGNORE : advance ( ) ; pd . setIsIgnored ( true ) ; result = true ; break ; case ScriptDocTokenTypes . TYPE : advance ( ) ; parseTypeValue ( pd ) ; pd . setDocumentType ( IDocumentation . TYPE_PROPERTY ) ; result = true ; break ; case ScriptDocTokenTypes . SINCE : advance ( ) ; pd . setSince ( parseText ( ) ) ; result = true ; break ; case ScriptDocTokenTypes . DEPRECATED : advance ( ) ; pd . setIsDeprecated ( true ) ; pd . setDeprecatedDescription ( parseText ( ) ) ; result = true ; break ; case ScriptDocTokenTypes . PRIVATE : advance ( ) ; pd . setIsPrivate ( true ) ; result = true ; break ; case ScriptDocTokenTypes . PROPERTY : advance ( ) ; pd . setDocumentType ( IDocumentation . TYPE_PROPERTY ) ; break ; case ScriptDocTokenTypes . INTERNAL : advance ( ) ; pd . setIsInternal ( true ) ; result = true ; break ; case ScriptDocTokenTypes . NATIVE : advance ( ) ; pd . setIsNative ( true ) ; result = true ; break ; case ScriptDocTokenTypes . ALIAS : advance ( ) ; parseAlias ( pd ) ; result = true ; break ; case ScriptDocTokenTypes . ID : advance ( ) ; parseID ( pd ) ; result = true ; break ; default : break ; } } catch ( ParseException e ) { skipTag ( e ) ; } } return result ; } private void parseFunctionDocumentationSection ( FunctionDocumentation fd ) throws LexerException { boolean found = parsePropertyTags ( fd ) ; if ( found ) { return ; } if ( this . _holderLexeme . getCategoryIndex ( ) == TokenCategories . KEYWORD ) { try { switch ( this . _holderLexeme . typeIndex ) { case ScriptDocTokenTypes . PARAM : advance ( ) ; parseParams ( fd ) ; fd . setDocumentType ( IDocumentation . TYPE_FUNCTION ) ; break ; case ScriptDocTokenTypes . RETURN : advance ( ) ; parseReturnValue ( fd ) ; fd . setDocumentType ( IDocumentation . TYPE_FUNCTION ) ; break ; case ScriptDocTokenTypes . EXCEPTION : advance ( ) ; parseException ( fd ) ; break ; case ScriptDocTokenTypes . CLASS_DESCRIPTION : advance ( ) ; fd . setClassDescription ( parseText ( ) ) ; break ; case ScriptDocTokenTypes . CONSTRUCTOR : advance ( ) ; fd . setIsConstructor ( true ) ; fd . setDocumentType ( IDocumentation . TYPE_FUNCTION ) ; break ; case ScriptDocTokenTypes . METHOD : advance ( ) ; fd . setIsMethod ( true ) ; fd . setDocumentType ( IDocumentation . TYPE_FUNCTION ) ; fd . setMethodName ( parseText ( ) ) ; break ; case ScriptDocTokenTypes . EXTENDS : advance ( ) ; parseExtends ( fd ) ; fd . setDocumentType ( IDocumentation . TYPE_FUNCTION ) ; break ; case ScriptDocTokenTypes . IGNORE : advance ( ) ; fd . setIsIgnored ( true ) ; break ; default : skipTag ( new ParseException ( Messages . ScriptDocParser_InvalidSyntax + this . _holderLexeme . getType ( ) , 0 ) ) ; break ; } } catch ( ParseException e ) { skipTag ( e ) ; } } else if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . END_DOCUMENTATION ) { this . _curNode . includeLexemeInRange ( this . currentLexeme ) ; advance ( ) ; } else { skipTag ( new ParseException ( Messages . ScriptDocParser_InvalidSyntaxForStatement + this . _holderLexeme . getType ( ) , 0 ) ) ; } } private void parseAlias ( PropertyDocumentation pd ) throws ParseException , LexerException { pd . getAliases ( ) . addType ( getIdentifier ( ) ) ; } private void parseID ( PropertyDocumentation pd ) throws ParseException , LexerException { LexemeList lexemes = this . getLexemeList ( ) ; Lexeme start = this . currentLexeme ; String id = getIdentifier ( ) ; Lexeme end = lexemes . get ( lexemes . size ( ) - 1 ) ; String dot = this . _curScriptNamespace . equals ( "" ) ? "" : "." ; String fullname = this . _curScriptNamespace + dot + id ; String uri = FileContextManager . getURIFromFileIndex ( this . getParseState ( ) . getFileIndex ( ) ) ; pd . setID ( fullname , new CodeLocation ( uri , start , end ) ) ; } private void parseNamespace ( ) throws ParseException , LexerException { this . _curScriptNamespace = getIdentifier ( ) ; this . parseText ( ) ; } private void parseReturnValue ( PropertyDocumentation pd ) throws ParseException , LexerException { parseIntoTypedDescription ( pd . getReturn ( ) , false ) ; } private void parseTypeValue ( PropertyDocumentation pd ) throws ParseException , LexerException { boolean hasType = this . _holderLexeme . typeIndex == ScriptDocTokenTypes . LCURLY ; boolean isIdent = ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . IDENTIFIER ) || ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . TEXT ) || ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . ELLIPSIS ) ; if ( hasType || ! isIdent ) { parseIntoTypedDescription ( pd . getReturn ( ) , false ) ; } else { String type = getIdentifier ( ) ; boolean hasFollowText = ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . IDENTIFIER ) || ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . TEXT ) ; if ( hasFollowText ) { String text = type + parseText ( ) ; pd . getReturn ( ) . setDescription ( text ) ; } else { pd . getReturn ( ) . addType ( type ) ; } } } private void parseParams ( FunctionDocumentation fd ) throws ParseException , LexerException { TypedDescription td = new TypedDescription ( ) ; parseIntoTypedDescription ( td , true ) ; fd . addParam ( td ) ; } private void parseExtends ( FunctionDocumentation fd ) throws ParseException , LexerException { parseIntoTypedDescription ( fd . getExtends ( ) , false ) ; } private void parseException ( FunctionDocumentation fd ) throws ParseException , LexerException { TypedDescription td = new TypedDescription ( ) ; parseIntoTypedDescription ( td , false ) ; fd . addException ( td ) ; } private void parseMemberOf ( PropertyDocumentation pd ) throws ParseException , LexerException { parseIntoTypedDescription ( pd . getMemberOf ( ) , false ) ; } private void parseIntoTypedDescription ( TypedDescription td , boolean includeName ) throws ParseException , LexerException { boolean hasType = this . _holderLexeme . typeIndex == ScriptDocTokenTypes . LCURLY ; if ( hasType ) { assertAndAdvance ( ScriptDocTokenTypes . LCURLY ) ; if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . IDENTIFIER || this . _holderLexeme . typeIndex == ScriptDocTokenTypes . ELLIPSIS ) { td . addType ( getIdentifier ( ) ) ; } else { throwParseError ( Messages . ScriptDocParser_InvalidID ) ; } while ( this . _holderLexeme != EOS && ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . COMMA || this . _holderLexeme . typeIndex == ScriptDocTokenTypes . PIPE || this . _holderLexeme . typeIndex == ScriptDocTokenTypes . FORWARD_SLASH ) ) { advance ( ) ; td . addType ( getIdentifier ( ) ) ; } assertAndAdvance ( ScriptDocTokenTypes . RCURLY ) ; } if ( includeName ) { td . setName ( getIdentifier ( ) ) ; } td . setDescription ( parseText ( ) ) ; } private String getIdentifier ( ) throws ParseException , LexerException { String result = "" ; boolean isOptional = false ; if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . LBRACKET ) { isOptional = true ; result += "[" ; advance ( ) ; } if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . IDENTIFIER || this . _holderLexeme . typeIndex == ScriptDocTokenTypes . TEXT ) { result += this . _holderLexeme . getText ( ) ; advance ( ) ; } else if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . ELLIPSIS ) { result = this . _holderLexeme . getText ( ) ; advance ( ) ; } else { throwParseError ( Messages . ScriptDocParser_InvalidIdInComment ) ; } if ( isOptional ) { result += "]" ; assertAndAdvance ( ScriptDocTokenTypes . RBRACKET ) ; } return result ; } private String parseText ( ) throws ParseException , LexerException { StringBuilder text = new StringBuilder ( ) ; loop : while ( this . _holderLexeme != EOS ) { switch ( this . _holderLexeme . getCategoryIndex ( ) ) { case TokenCategories . WHITESPACE : break ; case TokenCategories . LITERAL : String hText = this . _holderLexeme . getText ( ) ; if ( hText . startsWith ( "@" ) ) { break loop ; } text . append ( hText ) ; text . append ( " " ) ; break ; case TokenCategories . KEYWORD : if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . LINK || this . _holderLexeme . typeIndex == ScriptDocTokenTypes . SINCE ) { text . append ( this . _holderLexeme . getText ( ) ) ; } else { break loop ; } break ; case TokenCategories . PUNCTUATOR : if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . END_DOCUMENTATION ) { this . _curNode . includeLexemeInRange ( this . currentLexeme ) ; break loop ; } else { text . append ( this . _holderLexeme . getText ( ) ) ; text . append ( " " ) ; } break ; default : text . append ( this . _holderLexeme . getText ( ) ) ; text . append ( " " ) ; break ; } advance ( ) ; } return text . toString ( ) ; } private String getFollowText ( ) { ILexer lexer = this . getLexer ( ) ; if ( lexer . getSource ( ) . length ( ) > lexer . getCurrentOffset ( ) ) { int len = Math . min ( 6 , lexer . getSource ( ) . length ( ) - lexer . getCurrentOffset ( ) ) ; return "\"" + lexer . getSource ( ) . substring ( lexer . getCurrentOffset ( ) , lexer . getCurrentOffset ( ) + len ) + "\"" ; } else { return "end of document" ; } } private void assertAndAdvance ( int type ) throws ParseException , LexerException { this . assertType ( type ) ; this . advance ( ) ; } private void assertType ( int type ) throws ParseException { if ( this . _holderLexeme . typeIndex != type ) { String targetType = ScriptDocTokenTypes . getName ( type ) ; String actualType = ScriptDocTokenTypes . getName ( this . _holderLexeme . typeIndex ) ; if ( this . _holderLexeme == EOS ) { actualType = getFollowText ( ) ; } this . throwParseError ( Messages . ScriptDocParser_Expected + targetType + Messages . ScriptDocParser_Found + actualType ) ; } } private void skipTag ( ParseException e ) throws LexerException { LexemeList lexemes = this . getLexemeList ( ) ; Lexeme targetLexeme = null ; if ( this . _holderLexeme == EOS && lexemes . size ( ) > 1 ) { targetLexeme = lexemes . get ( lexemes . size ( ) - 2 ) ; } else { advance ( ) ; while ( this . _holderLexeme != EOS ) { targetLexeme = this . _holderLexeme ; if ( this . _holderLexeme . getCategoryIndex ( ) != TokenCategories . KEYWORD ) { advance ( ) ; } else { if ( this . _holderLexeme . typeIndex == ScriptDocTokenTypes . LINK ) { advance ( ) ; } else { break ; } } } } ErrorMessage en = new ErrorMessage ( e . getMessage ( ) , targetLexeme ) ; if ( e != null ) { this . _rootNode . addError ( en ) ; } } protected void throwParseError ( String message ) throws ParseException { LexemeList lexemes = this . getLexemeList ( ) ; int lastValid = ( this . _holderLexeme == EOS ) ? lexemes . size ( ) - 2 : lexemes . size ( ) - 1 ; if ( lastValid < 0 ) { message = Messages . ScriptDocParser_PrematureEndOfDoc ; } else { String position ; if ( this . _holderLexeme != EOS ) { position = " [" + this . _holderLexeme . getText ( ) + "]" ; } else { position = " [" + getFollowText ( ) + "]" ; } message = Messages . ScriptDocParser_ParseError + position + ": " + message ; } throw new ParseException ( message , - 1 ) ; } } 
=======
public class Int extends AbstractInt { public static final Int THE_INSTANCE = new Int ( ) ; private Int ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { checkInt ( literal , 0 ) ; } @ Override public String getName ( ) { return "integer" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
