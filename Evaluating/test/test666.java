public class LoggingStructureProvider implements ITreeContentProvider , ITableLabelProvider { public static final String COLORIZATION_SAVED = "Colorization saved" ; private String hashToken ( IToken token ) { return token . getLanguage ( ) + "::" + token . getCategory ( ) + "::" + token . getType ( ) ; } public class Category { private List < IToken > tokens ; private Map < String , ColorizationStyle > styles ; private String name ; private ColorizationStyle style ; public Category ( String name ) { this . name = name ; tokens = new LinkedList < IToken > ( ) ; styles = new HashMap < String , ColorizationStyle > ( ) ; this . style = null ; } public void setStyle ( ColorizationStyle style ) { this . style = style ; } public ColorizationStyle getStyle ( ) { return this . style ; } public void addTokenStyle ( IToken token , ColorizationStyle style ) { if ( token != null ) { styles . put ( hashToken ( token ) , style ) ; } } public void removeTokenStyle ( IToken token ) { if ( token != null ) { styles . remove ( hashToken ( token ) ) ; } } public ColorizationStyle getTokenStyle ( IToken token ) { ColorizationStyle style = null ; if ( token != null ) { style = ( ColorizationStyle ) styles . get ( hashToken ( token ) ) ; } return style ; } public void addToken ( IToken token ) { if ( ! containsToken ( token ) ) { tokens . add ( token ) ; } } public void addToken ( IToken token , int pos ) { if ( ! containsToken ( token ) ) { tokens . add ( pos , token ) ; } } public int removeToken ( IToken token ) { Iterator < IToken > it = tokens . iterator ( ) ; int i = 0 ; while ( it . hasNext ( ) ) { if ( tokensEqual ( it . next ( ) , token ) ) { it . remove ( ) ; return i ; } i ++ ; } return - 1 ; } public IToken getToken ( String hash ) { for ( IToken currentToken : tokens ) { if ( hashToken ( currentToken ) . equals ( hash ) ) { return currentToken ; } } return null ; } public List < IToken > getTokens ( ) { return tokens ; } public String getName ( ) { return name ; } public String getDisplayName ( ) { String display = name . toLowerCase ( ) ; display = display . substring ( 0 , 1 ) . toUpperCase ( ) + display . substring ( 1 , display . length ( ) ) ; return display ; } public Map getStyles ( ) { return styles ; } public void clear ( ) { tokens . clear ( ) ; styles . clear ( ) ; } private boolean containsToken ( IToken token ) { for ( IToken currentToken : tokens ) { if ( tokensEqual ( currentToken , token ) ) { return true ; } } return false ; } } private Map < String , Category > categories ; private Map < IToken , HashMap > regions ; private Map imageMap ; private Color backgroundColor ; private Color lineHighlightColor ; private Color caretColor ; private Color selectionForegroundColor ; private Color selectionBackgroundColor ; private Color foldingBackgroundColor ; private Color foldingForegroundColor ; private RGB black ; private FontData [ ] font ; private Boolean autobolding = null ; private Boolean wrapping = null ; private RGB cursorLineColor = null ; private RGB textForegroundColor = null ; private Integer backlogLines ; private List < LoggingPreferences . Rule > tempRules = new ArrayList < Rule > ( ) ; private boolean initialWrapping ; private Integer readTimeout ; private Integer readBuffer ; private String defaultEncoding ; public LoggingStructureProvider ( ) { categories = new HashMap ( ) ; imageMap = new HashMap ( ) ; regions = new HashMap ( ) ; backgroundColor = null ; lineHighlightColor = null ; caretColor = null ; selectionForegroundColor = null ; selectionBackgroundColor = null ; black = new RGB ( 0 , 0 , 0 ) ; loadProvider ( ) ; List < LoggingPreferences . Rule > rules = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getRules ( ) ; tempRules . addAll ( rules ) ; } public void loadProvider ( ) { loadProvider ( null , null ) ; } public void loadProvider ( List < IToken > initialTokens , LanguageColorizer colorizer ) { List < IToken > tokens ; if ( initialTokens == null ) { ITokenList tl = TokenTypes . getTokenList ( ) ; tokens = new ArrayList < IToken > ( ) ; if ( tl != null ) { for ( int i = 0 ; i < tl . size ( ) ; i ++ ) { IToken curr = ( IToken ) tl . get ( i ) ; this . addToken ( curr ) ; tokens . add ( curr ) ; } } } else { tokens = initialTokens ; for ( IToken curr : tokens ) { this . addToken ( curr ) ; } } LanguageColorizer lc = colorizer ; if ( lc == null ) { lc = LanguageRegistry . getLanguageColorizer ( TokenTypes . LANGUAGE , new ColorizerReader ( ) ) ; } if ( lc != null ) { initializeColoring ( lc ) ; checkDefaultStyles ( tokens ) ; createInitialWrapping ( ) ; } } private void initializeColoring ( LanguageColorizer lc ) { Iterator colorizers = lc . getTokenColorizers ( ) . iterator ( ) ; while ( colorizers . hasNext ( ) ) { TokenColorizer curr = ( TokenColorizer ) colorizers . next ( ) ; ColorizationStyle currStyle = curr . getBaseColorization ( ) ; ColorizationStyle clone = new ColorizationStyle ( currStyle ) ; this . addStyle ( curr . getToken ( ) , clone ) ; Iterator regions = curr . getRegions ( ) . iterator ( ) ; Map regionMap = new HashMap ( ) ; while ( regions . hasNext ( ) ) { Region region = ( Region ) regions . next ( ) ; Region cloneRegion = new Region ( region ) ; ColorizationStyle regionStyle = region . getStyle ( ) ; ColorizationStyle regionCloneStyle = new ColorizationStyle ( regionStyle ) ; cloneRegion . setStyle ( regionCloneStyle ) ; cloneRegion . setName ( region . getName ( ) ) ; regionMap . put ( cloneRegion . getName ( ) , cloneRegion ) ; this . addRegion ( curr . getToken ( ) , cloneRegion ) ; } } colorizers = lc . getCategoryColorizers ( ) . iterator ( ) ; while ( colorizers . hasNext ( ) ) { CategoryColorizer curr = ( CategoryColorizer ) colorizers . next ( ) ; ColorizationStyle clone = new ColorizationStyle ( curr . getStyle ( ) ) ; Category category = this . getCategory ( curr . getName ( ) ) ; category . setStyle ( clone ) ; } this . setBackgroundColor ( lc . getBackground ( ) ) ; this . setCaretColor ( lc . getCaretColor ( ) ) ; this . setLineHighlightColor ( lc . getLineHighlightColor ( ) ) ; this . setSelectionForegroundColor ( lc . getSelectionForeground ( ) ) ; this . setSelectionBackgroundColor ( lc . getSelectionBackground ( ) ) ; this . setFoldingBackgroundColor ( lc . getFoldingBg ( ) ) ; this . setFoldingForegroundColor ( lc . getFoldingFg ( ) ) ; } public void clear ( ) { clearStyles ( ) ; Iterator cats = categories . values ( ) . iterator ( ) ; while ( cats . hasNext ( ) ) { Category cat = ( Category ) cats . next ( ) ; cat . clear ( ) ; } } public void clearStyles ( ) { Iterator cats = categories . values ( ) . iterator ( ) ; while ( cats . hasNext ( ) ) { Category cat = ( Category ) cats . next ( ) ; cat . setStyle ( null ) ; cat . getStyles ( ) . clear ( ) ; } Iterator regs = regions . values ( ) . iterator ( ) ; while ( regs . hasNext ( ) ) { Map map = ( Map ) regs . next ( ) ; map . clear ( ) ; } } public void addStyle ( IToken token , ColorizationStyle style ) { Category cat = getCategory ( token . getCategory ( ) ) ; cat . addTokenStyle ( token , style ) ; } public void removeStyle ( IToken token ) { Category cat = getCategory ( token . getCategory ( ) ) ; cat . removeTokenStyle ( token ) ; Map regionMap = ( Map ) regions . get ( token ) ; regionMap . clear ( ) ; } public void removeRegion ( IToken token , String name ) { Map regionMap = ( Map ) regions . get ( token ) ; regionMap . remove ( name ) ; } public void addRegion ( IToken token , Region region ) { Map regionMap = ( Map ) regions . get ( token ) ; regionMap . put ( region . getName ( ) , region ) ; } public Map getRegions ( IToken token ) { return ( ( Map ) regions . get ( token ) ) ; } public Map getTokenStyles ( ) { Map all = new HashMap ( ) ; Iterator cats = categories . values ( ) . iterator ( ) ; while ( cats . hasNext ( ) ) { Category cat = ( Category ) cats . next ( ) ; all . putAll ( cat . getStyles ( ) ) ; } return all ; } public Collection < IToken > getTokens ( ) { Collection all = new ArrayList ( ) ; Iterator cats = categories . values ( ) . iterator ( ) ; while ( cats . hasNext ( ) ) { Category cat = ( Category ) cats . next ( ) ; all . addAll ( cat . getTokens ( ) ) ; } return all ; } public Map getCategoryStyles ( ) { Map all = new HashMap ( ) ; Iterator cats = categories . values ( ) . iterator ( ) ; while ( cats . hasNext ( ) ) { Category cat = ( Category ) cats . next ( ) ; all . put ( cat , cat . getStyle ( ) ) ; } return all ; } public ColorizationStyle getStyle ( IToken token ) { Category cat = getCategory ( token . getCategory ( ) ) ; return cat . getTokenStyle ( token ) ; } public Category getCategory ( String category ) { Category cat = null ; if ( categories . containsKey ( category ) ) { cat = ( Category ) categories . get ( category ) ; } return cat ; } public void addToken ( IToken token ) { Category category = null ; if ( ! categories . containsKey ( token . getCategory ( ) ) ) { category = new Category ( token . getCategory ( ) ) ; ColorizationStyle style = new ColorizationStyle ( ) ; style . setForegroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( new RGB ( 0 , 0 , 0 ) ) ) ; style . setName ( category . getName ( ) ) ; category . setStyle ( style ) ; categories . put ( token . getCategory ( ) , category ) ; } else { category = ( Category ) categories . get ( token . getCategory ( ) ) ; } if ( category . getToken ( hashToken ( token ) ) == null ) { category . addToken ( token ) ; } if ( regions . get ( token ) == null ) { regions . put ( token , new HashMap ( ) ) ; } } public void addToken ( IToken token , int pos ) { Category category = null ; if ( ! categories . containsKey ( token . getCategory ( ) ) ) { category = new Category ( token . getCategory ( ) ) ; ColorizationStyle style = new ColorizationStyle ( ) ; style . setForegroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( new RGB ( 0 , 0 , 0 ) ) ) ; style . setName ( category . getName ( ) ) ; category . setStyle ( style ) ; categories . put ( token . getCategory ( ) , category ) ; } else { category = ( Category ) categories . get ( token . getCategory ( ) ) ; } if ( category . getToken ( hashToken ( token ) ) == null ) { category . addToken ( token , pos ) ; } if ( regions . get ( token ) == null ) { regions . put ( token , new HashMap ( ) ) ; } } public Object [ ] getChildren ( Object parentElement ) { if ( parentElement instanceof Category ) { return ( ( Category ) parentElement ) . getTokens ( ) . toArray ( ) ; } else { return new Object [ 0 ] ; } } public Object getParent ( Object element ) { if ( element instanceof IToken ) { IToken token = ( IToken ) element ; return getCategory ( token . getCategory ( ) ) ; } return null ; } public boolean hasChildren ( Object element ) { return element instanceof Category ; } public Object [ ] getElements ( Object inputElement ) { for ( Category category : categories . values ( ) ) { if ( category . getName ( ) . equals ( TokenTypes . DEFAULT_CATEGORY ) ) { return getChildren ( category ) ; } } return new Object [ ] { } ; } public void dispose ( ) { } public void disposeImages ( ) { Iterator iter = imageMap . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( Image ) iter . next ( ) ) . dispose ( ) ; } } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } public void removeListener ( ILabelProviderListener listener ) { } public Image getColumnImage ( Object element , int columnIndex ) { ColorizationStyle style = null ; if ( element instanceof IToken ) { style = getStyle ( ( IToken ) element ) ; } else if ( element instanceof Category ) { style = ( ( Category ) element ) . getStyle ( ) ; } if ( style != null ) { if ( columnIndex == 0 && element instanceof IToken ) { return UnifiedEditorsPlugin . getImage ( "icons/checked.gif" ) ; } else if ( columnIndex == 2 && element instanceof IToken ) { if ( ! getRegions ( ( IToken ) element ) . isEmpty ( ) ) { return UnifiedEditorsPlugin . getImage ( "icons/region.gif" ) ; } } else if ( columnIndex == 3 ) { if ( style != null ) { Color fg = style . getForegroundColor ( ) ; Image img = null ; if ( ! imageMap . containsKey ( fg . getRGB ( ) ) ) { img = new Image ( Display . getCurrent ( ) , 16 , 16 ) ; GC gc = new GC ( img ) ; gc . setBackground ( fg ) ; gc . fillRectangle ( 1 , 1 , 13 , 13 ) ; gc . setForeground ( UnifiedColorManager . getInstance ( ) . getColor ( new RGB ( 0 , 0 , 0 ) ) ) ; gc . drawRectangle ( 1 , 1 , 13 , 13 ) ; gc . dispose ( ) ; imageMap . put ( fg . getRGB ( ) , img ) ; } else { img = ( Image ) imageMap . get ( fg . getRGB ( ) ) ; } return img ; } } else if ( columnIndex == 4 ) { if ( style != null && style . isBold ( ) ) { return UnifiedEditorsPlugin . getImage ( "icons/bold_on.gif" ) ; } else { return UnifiedEditorsPlugin . getImage ( "icons/bold_off.gif" ) ; } } else if ( columnIndex == 5 ) { if ( style != null && style . isItalic ( ) ) { return UnifiedEditorsPlugin . getImage ( "icons/italic_on.gif" ) ; } else { return UnifiedEditorsPlugin . getImage ( "icons/italic_off.gif" ) ; } } else if ( columnIndex == 6 ) { if ( style != null && style . isUnderline ( ) ) { return UnifiedEditorsPlugin . getImage ( "icons/underline_on.gif" ) ; } else { return UnifiedEditorsPlugin . getImage ( "icons/underline_off.gif" ) ; } } } else { if ( columnIndex == 0 && element instanceof IToken ) { return UnifiedEditorsPlugin . getImage ( "icons/unchecked.gif" ) ; } } return null ; } public String getColumnText ( Object element , int columnIndex ) { if ( columnIndex == 1 ) { if ( element instanceof IToken ) { return ( ( IToken ) element ) . getType ( ) ; } } return "" ; } public void addListener ( ILabelProviderListener listener ) { } public boolean isLabelProperty ( Object element , String property ) { return false ; } public void removeAll ( ) { categories . clear ( ) ; imageMap . clear ( ) ; regions . clear ( ) ; backgroundColor = null ; lineHighlightColor = null ; textForegroundColor = null ; caretColor = null ; selectionForegroundColor = null ; selectionBackgroundColor = null ; } public void buildLanguageColorizer ( LanguageColorizer lc , String prefId ) { buildLanguageColorizer ( lc ) ; try { ColorizerWriter writer = new ColorizerWriter ( ) ; writer . buildColorizationPreference ( lc , lc . getLanguage ( ) , prefId ) ; UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) . firePropertyChangeEvent ( COLORIZATION_SAVED , COLORIZATION_SAVED , COLORIZATION_SAVED ) ; } catch ( LexerException e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , e . getMessage ( ) ) ; } } public void buildLanguageColorizer ( LanguageColorizer lc ) { filterRegionsByTokens ( ) ; Map tokenStyles = this . getTokenStyles ( ) ; Iterator tokens = this . getTokens ( ) . iterator ( ) ; while ( tokens . hasNext ( ) ) { IToken curr = ( IToken ) tokens . next ( ) ; ColorizationStyle cloneStyle = ( ColorizationStyle ) tokenStyles . get ( hashToken ( curr ) ) ; if ( cloneStyle != null ) { ColorizationStyle newStyle = new ColorizationStyle ( cloneStyle ) ; TokenColorizer colorizer = lc . getTokenColorizer ( curr ) ; if ( colorizer == null ) { colorizer = new TokenColorizer ( ) ; colorizer . setToken ( curr ) ; lc . addTokenColorizer ( colorizer ) ; } colorizer . setBaseColorization ( newStyle ) ; Map regionMap = ( Map ) this . getRegions ( curr ) ; Iterator regions = regionMap . values ( ) . iterator ( ) ; while ( regions . hasNext ( ) ) { Region region = ( Region ) regions . next ( ) ; Region cloneRegion = new Region ( region ) ; cloneRegion . setName ( region . getName ( ) ) ; ColorizationStyle newRegionStyle = new ColorizationStyle ( region . getStyle ( ) ) ; newRegionStyle . setName ( curr . getCategory ( ) + "_" + curr . getType ( ) + "_" + region . getName ( ) ) ; cloneRegion . setStyle ( newRegionStyle ) ; colorizer . addColorization ( cloneRegion ) ; } Iterator existingRegions = colorizer . getRegions ( ) . iterator ( ) ; while ( existingRegions . hasNext ( ) ) { Region currRegion = ( Region ) existingRegions . next ( ) ; if ( ! regionMap . containsKey ( currRegion . getName ( ) ) ) { existingRegions . remove ( ) ; } } } } Iterator colorizers = lc . getTokenColorizers ( ) . iterator ( ) ; while ( colorizers . hasNext ( ) ) { TokenColorizer curr = ( TokenColorizer ) colorizers . next ( ) ; if ( ! tokenStyles . containsKey ( hashToken ( curr . getToken ( ) ) ) ) { colorizers . remove ( ) ; } } Map categoryStyles = this . getCategoryStyles ( ) ; Iterator styles = categoryStyles . keySet ( ) . iterator ( ) ; while ( styles . hasNext ( ) ) { Category category = ( Category ) styles . next ( ) ; ColorizationStyle curr = ( ColorizationStyle ) categoryStyles . get ( category ) ; ColorizationStyle newStyle = new ColorizationStyle ( curr ) ; CategoryColorizer colorizer = lc . getCategoryColorizer ( category . getName ( ) ) ; if ( colorizer == null ) { colorizer = new CategoryColorizer ( ) ; colorizer . setName ( category . getName ( ) ) ; lc . addCategoryColorizer ( colorizer ) ; } colorizer . setStyle ( newStyle ) ; } colorizers = lc . getCategoryColorizers ( ) . iterator ( ) ; while ( colorizers . hasNext ( ) ) { CategoryColorizer curr = ( CategoryColorizer ) colorizers . next ( ) ; Category cat = this . getCategory ( curr . getName ( ) ) ; if ( ! categoryStyles . containsKey ( cat ) ) { colorizers . remove ( ) ; } } lc . setBackground ( this . getBackgroundColor ( ) ) ; lc . setCaretColor ( this . getCaretColor ( ) ) ; lc . setLineHighlightColor ( this . getLineHighlightColor ( ) ) ; lc . setSelectionBackground ( this . getSelectionBackgroundColor ( ) ) ; lc . setSelectionForeground ( this . getSelectionForegroundColor ( ) ) ; lc . setFoldingBg ( this . getFoldingBackgroundColor ( ) ) ; lc . setFoldingFg ( this . getFoldingForegroundColor ( ) ) ; } public Color getBackgroundColor ( ) { return backgroundColor ; } public void setBackgroundColor ( Color backgroundColor ) { this . backgroundColor = backgroundColor ; } public Color getCaretColor ( ) { return caretColor ; } public void setCaretColor ( Color caretColor ) { this . caretColor = caretColor ; } public Color getLineHighlightColor ( ) { return lineHighlightColor ; } public void setLineHighlightColor ( Color lineHighlightColor ) { this . lineHighlightColor = lineHighlightColor ; } public RGB getTextForegroundColor ( ) { if ( textForegroundColor == null ) { textForegroundColor = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getTextColorRGB ( ) ; } return textForegroundColor ; } public void setTextForegroundColor ( RGB color ) { this . textForegroundColor = color ; } public Color getSelectionBackgroundColor ( ) { return selectionBackgroundColor ; } public void setSelectionBackgroundColor ( Color selectionBackgroundColor ) { this . selectionBackgroundColor = selectionBackgroundColor ; } public Color getSelectionForegroundColor ( ) { return selectionForegroundColor ; } public void setSelectionForegroundColor ( Color selectionForegroundColor ) { this . selectionForegroundColor = selectionForegroundColor ; } public String getLanguage ( ) { return TokenTypes . LANGUAGE ; } public void setLanguage ( String language ) { } public void buildColorizationFile ( File file ) throws LexerException { LanguageColorizer colorizer = new LanguageColorizer ( TokenTypes . LANGUAGE ) ; buildLanguageColorizer ( colorizer ) ; LoggingColorizerWriter writer = new LoggingColorizerWriter ( tempRules ) ; writer . buildColorizationFile ( colorizer , getLanguage ( ) , file ) ; } public void importColorization ( File file ) { AttributeSniffer sniffer = new AttributeSniffer ( "colorizer" , "language" ) ; try { sniffer . read ( new FileInputStream ( file ) ) ; if ( getLanguage ( ) != null && getLanguage ( ) . equals ( sniffer . getMatchedValue ( ) ) ) { TokensReader tokensReader = new TokensReader ( tempRules ) ; InputStream stream = new FileInputStream ( file ) ; try { tokensReader . read ( stream ) ; } finally { stream . close ( ) ; } final List < IToken > newTokens = new ArrayList < IToken > ( ) ; ITokenList tl = TokenTypes . getTokenList ( ) ; for ( LoggingPreferences . Rule rule : tempRules ) { IToken token = tl . createToken ( ) ; token . setCategory ( TokenTypes . DEFAULT_CATEGORY ) ; token . setType ( rule . getName ( ) ) ; newTokens . add ( token ) ; } TokenList newTokenList = tokenListByTokens ( newTokens ) ; LoggingColorizerReader reader = new LoggingColorizerReader ( newTokenList , false ) ; LanguageColorizer colorizer = reader . importColorization ( file ) ; this . clear ( ) ; this . loadProvider ( newTokens , colorizer ) ; } else { IdeLog . logError ( LoggingPlugin . getDefault ( ) , Messages . LoggingStructureProvider_ERR_Loading ) ; } } catch ( Throwable e ) { IdeLog . logError ( LoggingPlugin . getDefault ( ) , Messages . LoggingStructureProvider_ERR_Loading , e ) ; } } public void resetToLanguageDefaults ( ) { if ( getLanguage ( ) != null ) { createInitialWrapping ( ) ; LoggingPreferences preferences = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) ; font = preferences . getDefaultFont ( ) ; autobolding = preferences . getDefaultAutoBolding ( ) ; wrapping = preferences . getDefaultWrapping ( ) ; cursorLineColor = preferences . getDefaultCursorLineColor ( ) ; textForegroundColor = preferences . getDefaultTextColor ( ) ; backlogLines = preferences . getDefaultBacklogLines ( ) ; tempRules . clear ( ) ; readTimeout = preferences . getDefaultReadTimeout ( ) ; readBuffer = preferences . getDefaultReadBuffer ( ) ; defaultEncoding = preferences . getDefaultDefaultEncoding ( ) ; this . clearStyles ( ) ; this . clear ( ) ; preferences . fillDefaultRules ( this ) ; } } public void restoreGeneralDefaults ( ) { if ( getLanguage ( ) != null ) { createInitialWrapping ( ) ; LoggingPreferences preferences = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) ; font = preferences . getDefaultFont ( ) ; autobolding = preferences . getDefaultAutoBolding ( ) ; wrapping = preferences . getDefaultWrapping ( ) ; cursorLineColor = preferences . getDefaultCursorLineColor ( ) ; textForegroundColor = preferences . getDefaultTextColor ( ) ; backlogLines = preferences . getDefaultBacklogLines ( ) ; readTimeout = preferences . getDefaultReadTimeout ( ) ; readBuffer = preferences . getDefaultReadBuffer ( ) ; defaultEncoding = preferences . getDefaultDefaultEncoding ( ) ; } } public void restoreColorizationDefautls ( ) { if ( getLanguage ( ) != null ) { LoggingPreferences preferences = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) ; tempRules . clear ( ) ; this . clearStyles ( ) ; this . clear ( ) ; preferences . fillDefaultRules ( this ) ; } } public void refreshTokens ( ) { ITokenList tl = TokenTypes . getTokenList ( ) ; List < String > original = new ArrayList < String > ( ) ; if ( tl != null ) { for ( int i = 0 ; i < tl . size ( ) ; i ++ ) { IToken curr = ( IToken ) tl . get ( i ) ; original . add ( curr . getType ( ) ) ; Category category = this . getCategory ( curr . getCategory ( ) ) ; if ( category == null || category . getToken ( curr . getType ( ) ) == null ) { this . addToken ( curr ) ; } } List < IToken > toRemove = new ArrayList < IToken > ( ) ; for ( IToken token : getTokens ( ) ) { if ( ! original . contains ( token . getType ( ) ) ) { toRemove . add ( token ) ; } } for ( IToken token : toRemove ) { removeToken ( token ) ; } } checkDefaultStyles ( tl ) ; } public Color getFoldingBackgroundColor ( ) { return foldingBackgroundColor ; } public void setFoldingBackgroundColor ( Color foldingBackgroundColor ) { this . foldingBackgroundColor = foldingBackgroundColor ; } public Color getFoldingForegroundColor ( ) { return foldingForegroundColor ; } public void setFoldingForegroundColor ( Color foldingForegroundColor ) { this . foldingForegroundColor = foldingForegroundColor ; } public void removeRule ( IToken ruletoken ) { LoggingPreferences . Rule rule = new LoggingPreferences . Rule ( ruletoken . getType ( ) , null , true , true ) ; IToken toRemove = null ; for ( IToken token : getTokens ( ) ) { if ( token . getType ( ) . equals ( rule . getName ( ) ) ) { toRemove = token ; break ; } } if ( toRemove != null ) { removeStyle ( toRemove ) ; removeToken ( toRemove ) ; } getCurrentRules ( ) . remove ( rule ) ; } public void addRule ( String name , String content , boolean isRegexp , boolean isCaseSensitive ) { LoggingPreferences . Rule rule = new LoggingPreferences . Rule ( name , content , isRegexp , isCaseSensitive ) ; addRule ( rule , null ) ; } public void addRuleToBeginning ( String name , String content , boolean isRegexp , boolean isCaseSensitive ) { LoggingPreferences . Rule rule = new LoggingPreferences . Rule ( name , content , isRegexp , isCaseSensitive ) ; addRule ( rule , 0 , null ) ; } public void addRule ( String name , String content , boolean isRegexp , boolean isCaseSensitive , RGB color , boolean bold , boolean italic , boolean underline ) { LoggingPreferences . Rule rule = new LoggingPreferences . Rule ( name , content , isRegexp , isCaseSensitive ) ; ColorizationStyle style = createStyle ( name , color , bold , italic , underline ) ; addRule ( rule , style ) ; } public void addRule ( LoggingPreferences . Rule rule , int pos ) { addRule ( rule , pos , null ) ; } public void addRule ( LoggingPreferences . Rule rule , int pos , ColorizationStyle style ) { IToken token = TokenTypes . getTokenList ( ) . createToken ( ) ; token . setCategory ( TokenTypes . DEFAULT_CATEGORY ) ; token . setType ( rule . getName ( ) ) ; addToken ( token , pos ) ; checkDefaultStyle ( token ) ; getCurrentRules ( ) . add ( pos , rule ) ; if ( style != null ) { addStyle ( token , style ) ; } } public void addRule ( LoggingPreferences . Rule rule , ColorizationStyle style ) { IToken token = TokenTypes . getTokenList ( ) . createToken ( ) ; token . setCategory ( TokenTypes . DEFAULT_CATEGORY ) ; token . setType ( rule . getName ( ) ) ; addToken ( token ) ; checkDefaultStyle ( token ) ; getCurrentRules ( ) . add ( rule ) ; if ( style != null ) { addStyle ( token , style ) ; } } public List < LoggingPreferences . Rule > getCurrentRules ( ) { return tempRules ; } public void updateRule ( IToken ruletoken , String newContent , boolean isRegexp , boolean isCaseSensitive ) { LoggingPreferences . Rule rule = new LoggingPreferences . Rule ( ruletoken . getType ( ) , newContent , isRegexp , isCaseSensitive ) ; IToken toRemove = null ; for ( IToken token : getTokens ( ) ) { if ( token . getType ( ) . equals ( rule . getName ( ) ) ) { toRemove = token ; break ; } } if ( toRemove != null ) { ColorizationStyle style = getStyle ( toRemove ) ; int removedIndex = removeToken ( toRemove ) ; getCurrentRules ( ) . remove ( rule ) ; IToken token = TokenTypes . getTokenList ( ) . createToken ( ) ; token . setCategory ( TokenTypes . DEFAULT_CATEGORY ) ; token . setType ( rule . getName ( ) ) ; addToken ( token , removedIndex ) ; addStyle ( token , style ) ; checkDefaultStyle ( token ) ; getCurrentRules ( ) . add ( removedIndex , rule ) ; } } public void moveRuleDown ( IToken token ) { int pos = rulePositionByToken ( token ) ; ColorizationStyle style = getStyleByToken ( token ) ; if ( pos == - 1 || pos == tempRules . size ( ) - 1 ) { return ; } LoggingPreferences . Rule rule = getCurrentRules ( ) . get ( pos ) ; removeRule ( token ) ; addRule ( rule , pos + 1 , style ) ; } public void moveRuleUp ( IToken token ) { int pos = rulePositionByToken ( token ) ; ColorizationStyle style = getStyleByToken ( token ) ; if ( pos == - 1 || pos == 0 ) { return ; } LoggingPreferences . Rule rule = getCurrentRules ( ) . get ( pos ) ; removeRule ( token ) ; addRule ( rule , pos - 1 , style ) ; } public void applyChanges ( ) { applyRuleChanges ( ) ; applyAutoBolding ( ) ; applyCursorLineColor ( ) ; applyTextForegroundColor ( ) ; applyFont ( ) ; applyReadTimeout ( ) ; applyReadBuffer ( ) ; applyDefaultEncoding ( ) ; applyBacklogLines ( ) ; applyWrapping ( ) ; } public boolean getAutoBolding ( ) { if ( autobolding == null ) { autobolding = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getAutoBolding ( ) ; } return autobolding ; } public void setFont ( FontData [ ] font ) { this . font = font ; } public FontData [ ] getFont ( ) { if ( font == null ) { font = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getFontData ( ) ; } return font ; } public void setReadTimeout ( int timeout ) { this . readTimeout = timeout ; } public int getReadTimeot ( ) { if ( readTimeout == null ) { readTimeout = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getReadTimeout ( ) ; } return readTimeout ; } public void setReadBuffer ( int buffer ) { this . readBuffer = buffer ; } public int getReadBuffer ( ) { if ( readBuffer == null ) { readBuffer = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getReadBuffer ( ) ; } return readBuffer ; } public void setAutoBolding ( boolean autobolding ) { this . autobolding = autobolding ; } public boolean getWrapping ( ) { if ( wrapping == null ) { wrapping = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getWrapping ( ) ; } return wrapping ; } public void setWrapping ( boolean wrapping ) { this . wrapping = wrapping ; } public int getBacklogLines ( ) { if ( backlogLines == null ) { backlogLines = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getBacklogLines ( ) ; } return backlogLines ; } public void setBacklogLines ( int lines ) { this . backlogLines = lines ; } public RGB getCursorLineColor ( ) { if ( cursorLineColor == null ) { cursorLineColor = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getCursorLineColor ( ) ; } return cursorLineColor ; } public void setCursorLineColor ( RGB color ) { this . cursorLineColor = color ; } public boolean tokensEqual ( IToken token1 , IToken token2 ) { return token1 == null ? token2 == null : hashToken ( token1 ) . equals ( hashToken ( token2 ) ) ; } public void setDefaultEncoding ( String encoding ) { defaultEncoding = encoding ; } public String getDefaultEncoding ( ) { if ( defaultEncoding == null ) { defaultEncoding = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getDefaultEncoding ( ) ; } return defaultEncoding ; } private void checkDefaultStyles ( ITokenList tokens ) { for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { IToken token = tokens . get ( i ) ; checkDefaultStyle ( token ) ; } } private void checkDefaultStyles ( List < IToken > tokens ) { for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { IToken token = tokens . get ( i ) ; checkDefaultStyle ( token ) ; } } private void checkDefaultStyle ( IToken token ) { if ( getStyle ( token ) == null ) { ColorizationStyle style = new ColorizationStyle ( ) ; style . setForegroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( black ) ) ; style . setName ( token . getCategory ( ) + "_" + token . getType ( ) ) ; addStyle ( token , style ) ; } } private int removeToken ( IToken token ) { Category cat = getCategory ( token . getCategory ( ) ) ; int index = cat . removeToken ( token ) ; Map regionMap = ( Map ) regions . get ( token ) ; regionMap . clear ( ) ; regions . remove ( token ) ; return index ; } private void applyAutoBolding ( ) { if ( autobolding != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setAutoBolding ( autobolding ) ; } } private void applyFont ( ) { if ( font != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setFontData ( font ) ; } } private void applyWrapping ( ) { if ( wrapping != null && ! wrapping . equals ( initialWrapping ) ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setWrapping ( wrapping ) ; } } private void applyBacklogLines ( ) { if ( backlogLines != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setBacklogLines ( backlogLines ) ; } } private void applyReadTimeout ( ) { if ( readTimeout != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setReadTimeout ( readTimeout ) ; } } private void applyReadBuffer ( ) { if ( readBuffer != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setReadBuffer ( readBuffer ) ; } } private void applyDefaultEncoding ( ) { if ( defaultEncoding != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setDefaultEncoding ( defaultEncoding ) ; } } private void applyCursorLineColor ( ) { if ( cursorLineColor != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setCursorLineColor ( cursorLineColor ) ; } } private void applyTextForegroundColor ( ) { if ( textForegroundColor != null ) { LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . setTextColor ( textForegroundColor ) ; } } void applyRuleChanges ( ) { List < LoggingPreferences . Rule > rules = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getRules ( ) ; rules . clear ( ) ; rules . addAll ( tempRules ) ; } void filterRegionsByTokens ( ) { Collection < IToken > tokens = getTokens ( ) ; Map < IToken , HashMap > filteredRegions = new HashMap < IToken , HashMap > ( ) ; for ( IToken token : tokens ) { if ( regions . containsKey ( token ) ) { filteredRegions . put ( token , regions . get ( token ) ) ; } } regions . clear ( ) ; regions . putAll ( filteredRegions ) ; } private void createInitialWrapping ( ) { initialWrapping = LoggingPlugin . getDefault ( ) . getLoggingPreferences ( ) . getWrapping ( ) ; } private TokenList tokenListByTokens ( final List < IToken > tokens ) { TokenList newTokenList = new TokenList ( ) ; newTokenList . setCategoryMap ( new IEnumerationMap ( ) { public int getIntValue ( String name ) { return TokenCategories . getIntValue ( name ) ; } public String getName ( int index ) { return TokenCategories . getName ( index ) ; } public String [ ] getNames ( ) { return TokenCategories . getNames ( ) ; } } ) ; newTokenList . setTypeMap ( new IEnumerationMap ( ) { public int getIntValue ( String name ) { for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { IToken token = tokens . get ( i ) ; if ( token . getType ( ) . equals ( name ) ) { return i ; } } return - 1 ; } public String getName ( int index ) { return tokens . get ( index ) . getType ( ) ; } public String [ ] getNames ( ) { String [ ] names = new String [ tokens . size ( ) ] ; tokens . toArray ( names ) ; return names ; } } ) ; for ( IToken token : tokens ) { newTokenList . add ( token ) ; } return newTokenList ; } private LoggingPreferences . Rule ruleByToken ( IToken token ) { int pos = rulePositionByToken ( token ) ; if ( pos != - 1 ) { return tempRules . get ( pos ) ; } return null ; } private IToken tokenByRule ( LoggingPreferences . Rule rule ) { for ( IToken token : getTokens ( ) ) { if ( token . getType ( ) . equals ( rule . getName ( ) ) ) { return token ; } } return null ; } private int rulePositionByToken ( IToken token ) { for ( int i = 0 ; i < tempRules . size ( ) ; i ++ ) { LoggingPreferences . Rule rule = tempRules . get ( i ) ; if ( rule . getName ( ) . equals ( token . getType ( ) ) ) { return i ; } } return - 1 ; } private ColorizationStyle createStyle ( String tokenName , RGB color , boolean bold , boolean italic , boolean underline ) { ColorizationStyle style ; style = new ColorizationStyle ( ) ; style . setForegroundColor ( UnifiedColorManager . getInstance ( ) . getColor ( color ) ) ; style . setName ( TokenTypes . DEFAULT_CATEGORY + "_" + tokenName ) ; style . setBold ( bold ) ; style . setItalic ( italic ) ; style . setUnderline ( underline ) ; return style ; } private ColorizationStyle getStyleByToken ( IToken token ) { Category cat = getCategory ( token . getCategory ( ) ) ; if ( cat == null ) { return null ; } return cat . getTokenStyle ( token ) ; } } 