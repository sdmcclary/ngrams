public class JSDebugProcess extends PlatformObject implements IProcess , IDebugEventSetListener { private static final int MAX_WAIT_FOR_DEATH_ATTEMPTS = 10 ; private static final int TIME_TO_WAIT_FOR_THREAD_DEATH = 500 ; private ILaunch launch ; private String label ; private Process process ; private boolean killProcessOnTerminate ; private volatile boolean processTerminated ; private ProcessMonitorThread processMonitorThread ; private IStreamsProxy streamsProxy ; private PipedOutputStream out ; private PipedOutputStream err ; private IDebugTarget debugTarget ; private IXHRService xhrService ; private Map < String , String > fAttributes ; public JSDebugProcess ( ILaunch launch , String label , Map attributes ) { this ( launch , null , false , label , attributes ) ; } public JSDebugProcess ( ILaunch launch , Process process , String label , Map attributes ) { this ( launch , process , true , label , attributes ) ; } public JSDebugProcess ( ILaunch launch , Process process , boolean killProcessOnTerminate , String label , Map attributes ) { this . launch = launch ; this . process = process ; this . killProcessOnTerminate = killProcessOnTerminate ; this . label = label ; initializeAttributes ( attributes ) ; out = new PipedOutputStream ( ) ; err = new PipedOutputStream ( ) ; launch . addProcess ( this ) ; fireCreationEvent ( ) ; DebugPlugin . getDefault ( ) . addDebugEventListener ( this ) ; if ( process != null ) { try { process . exitValue ( ) ; processTerminated = true ; } catch ( IllegalThreadStateException e ) { } if ( processTerminated ) { fireTerminateEvent ( ) ; } else { processMonitorThread = new ProcessMonitorThread ( ) ; processMonitorThread . start ( ) ; } } } private void initializeAttributes ( Map attributes ) { setAttribute ( IProcess . ATTR_PROCESS_TYPE , "javascript" ) ; if ( attributes != null ) { Iterator keys = attributes . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { String key = ( String ) keys . next ( ) ; setAttribute ( key , ( String ) attributes . get ( key ) ) ; } } } public String getLabel ( ) { return label ; } public ILaunch getLaunch ( ) { return launch ; } public IStreamsProxy getStreamsProxy ( ) { if ( streamsProxy == null ) { try { streamsProxy = new StreamsProxy ( new PipedInputStream ( out ) , new PipedInputStream ( err ) ) ; } catch ( IOException e ) { JSDebugPlugin . log ( e ) ; } } return streamsProxy ; } public void setAttribute ( String key , String value ) { if ( fAttributes == null ) { fAttributes = new HashMap < String , String > ( 5 ) ; } Object origVal = fAttributes . get ( key ) ; if ( origVal != null && origVal . equals ( value ) ) { return ; } fAttributes . put ( key , value ) ; fireChangeEvent ( ) ; } public String getAttribute ( String key ) { if ( fAttributes == null ) { return null ; } return ( String ) fAttributes . get ( key ) ; } public int getExitValue ( ) throws DebugException { if ( ! isTerminated ( ) ) { throwDebugException ( null ) ; } if ( process != null ) { return process . exitValue ( ) ; } return - 1 ; } public boolean canTerminate ( ) { return ! isTerminated ( ) ; } public boolean isTerminated ( ) { if ( process != null ) { return processTerminated ; } IDebugTarget target = getDebugTarget ( ) ; if ( target != null ) { return target . isTerminated ( ) ; } return false ; } public void terminate ( ) throws DebugException { if ( ! isTerminated ( ) ) { IDebugTarget target = getDebugTarget ( ) ; if ( target != null ) { target . terminate ( ) ; } terminateProcess ( ) ; } } private void terminateProcess ( ) throws DebugException { if ( process != null && ! processTerminated && killProcessOnTerminate ) { process . destroy ( ) ; for ( int attempts = 0 ; attempts < MAX_WAIT_FOR_DEATH_ATTEMPTS ; ++ attempts ) { try { process . exitValue ( ) ; processTerminated = true ; processMonitorThread . interrupt ( ) ; return ; } catch ( IllegalThreadStateException ie ) { } try { Thread . sleep ( TIME_TO_WAIT_FOR_THREAD_DEATH ) ; } catch ( InterruptedException e ) { } } throw new DebugException ( new Status ( IStatus . ERROR , JSDebugPlugin . ID , DebugException . TARGET_REQUEST_FAILED , Messages . JSDebugProcess_Terminate_Failed , null ) ) ; } } public Object getAdapter ( Class adapter ) { if ( adapter == IProcess . class ) { return this ; } else if ( adapter == IDebugTarget . class ) { ILaunch launch = getLaunch ( ) ; IDebugTarget [ ] targets = launch . getDebugTargets ( ) ; for ( int i = 0 ; i < targets . length ; i ++ ) { if ( this . equals ( targets [ i ] . getProcess ( ) ) ) { return targets [ i ] ; } } return null ; } else if ( adapter == IXHRService . class ) { return xhrService ; } return super . getAdapter ( adapter ) ; } protected void fireCreationEvent ( ) { fireEvent ( new DebugEvent ( this , DebugEvent . CREATE ) ) ; } protected void fireTerminateEvent ( ) { if ( DebugPlugin . getDefault ( ) != null ) { fireEvent ( new DebugEvent ( this , DebugEvent . TERMINATE ) ) ; } } protected void fireChangeEvent ( ) { fireEvent ( new DebugEvent ( this , DebugEvent . CHANGE ) ) ; } protected void fireEvent ( DebugEvent event ) { DebugPlugin . getDefault ( ) . fireDebugEventSet ( new DebugEvent [ ] { event } ) ; } protected void throwDebugException ( Exception exception ) throws DebugException { throw new DebugException ( new Status ( IStatus . ERROR , JSDebugPlugin . ID , DebugException . REQUEST_FAILED , StringUtils . EMPTY , exception ) ) ; } private void closeStreams ( ) { try { out . close ( ) ; } catch ( IOException ignore ) { } try { err . close ( ) ; } catch ( IOException ignore ) { } out = null ; err = null ; } public OutputStream getOutputStream ( ) { return out ; } public OutputStream getErrorStream ( ) { return err ; } protected void setDebugTarget ( IDebugTarget debugTarget ) { this . debugTarget = debugTarget ; } private IDebugTarget getDebugTarget ( ) { if ( debugTarget == null ) { debugTarget = launch . getDebugTarget ( ) ; } return debugTarget ; } protected void setXHRService ( IXHRService xhrService ) { this . xhrService = xhrService ; } public void handleDebugEvents ( DebugEvent [ ] events ) { for ( int i = 0 ; i < events . length ; i ++ ) { DebugEvent event = events [ i ] ; switch ( event . getKind ( ) ) { case DebugEvent . TERMINATE : { Object source = event . getSource ( ) ; if ( source . equals ( getDebugTarget ( ) ) ) { closeStreams ( ) ; fireTerminateEvent ( ) ; DebugPlugin . getDefault ( ) . removeDebugEventListener ( this ) ; try { terminateProcess ( ) ; } catch ( DebugException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } break ; } default : } } } private class ProcessMonitorThread extends Thread { public ProcessMonitorThread ( ) { super ( ) ; setDaemon ( true ) ; } @ Override public void run ( ) { while ( ! processTerminated ) { try { process . waitFor ( ) ; } catch ( InterruptedException e ) { Thread . interrupted ( ) ; } finally { processTerminated = true ; fireTerminateEvent ( ) ; } } } } } 