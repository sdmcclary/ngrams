<<<<<<< HEAD
public final class ImageUtils { private static java . awt . Color whiteBackground = null ; private static ImageRegistry imageRegistry = null ; private static Image fIconDrive = null ; private static ISharedImages sharedImages = null ; private static Image iconFolder = null ; private static Image iconFile = null ; private static boolean imageCacheLoaded = false ; public static Map < String , Image > fileIconsHash = new HashMap < String , Image > ( ) ; private ImageUtils ( ) { } public static ImageDescriptor getImageDescriptor ( String imageFilePath ) { ImageDescriptor imageDescriptor = CoreUIPlugin . getImageDescriptor ( imageFilePath ) ; if ( imageDescriptor == null ) { imageDescriptor = ImageDescriptor . getMissingImageDescriptor ( ) ; } return imageDescriptor ; } public static Image getIcon ( File file , Color backgroundColor ) { if ( ! CoreUIUtils . onMacOSX ) { String fileType = null ; String fileDisplayName = null ; try { fileType = FileSystemView . getFileSystemView ( ) . getSystemTypeDescription ( file ) ; fileDisplayName = FileSystemView . getFileSystemView ( ) . getSystemDisplayName ( file ) ; } catch ( Exception ignore ) { } if ( fileDisplayName != null && fileType != null ) { if ( fileDisplayName . equals ( "Desktop" ) ) { fileType = "Desktop" ; } if ( fileIconsHash . containsKey ( fileType ) ) { return fileIconsHash . get ( fileType ) ; } else if ( fileIconsHash . containsKey ( fileType + "#" + fileDisplayName ) ) { return fileIconsHash . get ( fileType + "#" + fileDisplayName ) ; } else { Icon icon = FileSystemView . getFileSystemView ( ) . getSystemIcon ( file ) ; if ( icon instanceof ImageIcon ) { Image image = awtImageIconToSWTImage ( icon , backgroundColor ) ; if ( fileType . equals ( "Application" ) || fileType . equals ( "System Folder" ) || fileDisplayName . equals ( "Desktop" ) || fileType . indexOf ( "Shortcut" ) > - 1 ) { fileIconsHash . put ( fileType + "#" + fileDisplayName , image ) ; } else { fileIconsHash . put ( fileType , image ) ; } return image ; } } } } if ( file . getName ( ) . equals ( "" ) ) { return getDriveIcon ( ) ; } if ( FileUtils . isDirectory ( file ) ) { return getFolderIcon ( ) ; } int lastDotPos = file . getName ( ) . indexOf ( '.' ) ; if ( lastDotPos == - 1 ) { return getFileIcon ( ) ; } Image image = getIcon ( file . getName ( ) . substring ( lastDotPos + 1 ) ) ; return image == null ? getFileIcon ( ) : image ; } public static Image getDriveIcon ( ) { if ( fIconDrive == null ) { fIconDrive = getImageDescriptor ( "icons/drive.gif" ) . createImage ( ) ; } return fIconDrive ; } public static Image getFolderIcon ( ) { checkSharedImages ( ) ; if ( iconFolder == null ) { iconFolder = sharedImages . getImage ( ISharedImages . IMG_OBJ_FOLDER ) ; } return iconFolder ; } public static Image getFileIcon ( ) { checkSharedImages ( ) ; if ( iconFile == null ) { iconFile = sharedImages . getImage ( ISharedImages . IMG_OBJ_FILE ) ; } return iconFile ; } private static void checkSharedImages ( ) { if ( sharedImages == null ) { sharedImages = PlatformUI . getWorkbench ( ) . getSharedImages ( ) ; } } public static Image getIcon ( String extension ) { if ( imageRegistry == null ) { imageRegistry = new ImageRegistry ( ) ; } Image image = imageRegistry . get ( extension ) ; if ( image != null ) { return image ; } if ( extension == null ) { return iconFile ; } Program program = Program . findProgram ( extension ) ; ImageData imageData = ( program == null ? null : program . getImageData ( ) ) ; if ( imageData != null ) { image = new Image ( Display . getCurrent ( ) , imageData ) ; imageRegistry . put ( extension , image ) ; } else { image = iconFile ; } return image ; } public static Image awtImageIconToSWTImage ( Icon icon , Color backgroundColor ) { ImageIcon i = ( ImageIcon ) icon ; java . awt . Color backColor = null ; if ( backgroundColor != null ) { backColor = swtColorToAWTColor ( backgroundColor ) ; } else { if ( whiteBackground == null ) { whiteBackground = swtColorToAWTColor ( new Color ( Display . getCurrent ( ) , 255 , 255 , 255 ) ) ; } backColor = whiteBackground ; } BufferedImage bi = new BufferedImage ( i . getIconWidth ( ) , i . getIconHeight ( ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D imageGraphics = bi . createGraphics ( ) ; imageGraphics . drawImage ( i . getImage ( ) , 0 , 0 , backColor , ( ImageObserver ) null ) ; ImageData data = awtBufferedImageToSWTImageData ( bi ) ; try { return new Image ( Display . getCurrent ( ) , data ) ; } finally { imageGraphics . dispose ( ) ; } } public static java . awt . Color swtColorToAWTColor ( org . eclipse . swt . graphics . Color background ) { return new java . awt . Color ( background . getRed ( ) , background . getGreen ( ) , background . getBlue ( ) ) ; } public static ImageData awtBufferedImageToSWTImageData ( BufferedImage bufferedImage ) { if ( bufferedImage . getColorModel ( ) instanceof DirectColorModel ) { DirectColorModel colorModel = ( DirectColorModel ) bufferedImage . getColorModel ( ) ; PaletteData palette = new PaletteData ( colorModel . getRedMask ( ) , colorModel . getGreenMask ( ) , colorModel . getBlueMask ( ) ) ; ImageData data = new ImageData ( bufferedImage . getWidth ( ) , bufferedImage . getHeight ( ) , colorModel . getPixelSize ( ) , palette ) ; WritableRaster raster = bufferedImage . getRaster ( ) ; int [ ] pixelArray = new int [ 3 ] ; for ( int y = 0 ; y < data . height ; y ++ ) { for ( int x = 0 ; x < data . width ; x ++ ) { raster . getPixel ( x , y , pixelArray ) ; int pixel = palette . getPixel ( new RGB ( pixelArray [ 0 ] , pixelArray [ 1 ] , pixelArray [ 2 ] ) ) ; data . setPixel ( x , y , pixel ) ; } } return data ; } else if ( bufferedImage . getColorModel ( ) instanceof IndexColorModel ) { IndexColorModel colorModel = ( IndexColorModel ) bufferedImage . getColorModel ( ) ; int size = colorModel . getMapSize ( ) ; byte [ ] reds = new byte [ size ] ; byte [ ] greens = new byte [ size ] ; byte [ ] blues = new byte [ size ] ; colorModel . getReds ( reds ) ; colorModel . getGreens ( greens ) ; colorModel . getBlues ( blues ) ; RGB [ ] rgbs = new RGB [ size ] ; for ( int i = 0 ; i < rgbs . length ; i ++ ) { rgbs [ i ] = new RGB ( reds [ i ] & 0xFF , greens [ i ] & 0xFF , blues [ i ] & 0xFF ) ; } PaletteData palette = new PaletteData ( rgbs ) ; ImageData data = new ImageData ( bufferedImage . getWidth ( ) , bufferedImage . getHeight ( ) , colorModel . getPixelSize ( ) , palette ) ; data . transparentPixel = colorModel . getTransparentPixel ( ) ; WritableRaster raster = bufferedImage . getRaster ( ) ; int [ ] pixelArray = new int [ 1 ] ; for ( int y = 0 ; y < data . height ; y ++ ) { for ( int x = 0 ; x < data . width ; x ++ ) { raster . getPixel ( x , y , pixelArray ) ; data . setPixel ( x , y , pixelArray [ 0 ] ) ; } } return data ; } return null ; } private static List < String > getImageCacheNames ( Connection conn ) { AptanaDB db = AptanaDB . getInstance ( ) ; final List < String > list = new ArrayList < String > ( ) ; db . execute ( "select name FROM CACHE" , new IResultSetHandler ( ) { public void processResultSet ( ResultSet resultSet ) throws SQLException { String name = resultSet . getString ( 1 ) ; list . add ( name ) ; } } ) ; return list ; } public static int loadImageCache ( final Display display ) { int result = - 1 ; if ( imageCacheLoaded == false ) { imageCacheLoaded = true ; try { if ( checkTable ( ) == false ) { createTable ( ) ; } } catch ( SQLException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_ErrorInitializingDbConnection , e ) ; if ( e . getNextException ( ) != null ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_ErrorInitializingDbConnection , e . getNextException ( ) ) ; } } final class Handler implements IResultSetHandler { public int count = 0 ; public void processResultSet ( ResultSet resultSet ) throws SQLException { String name = resultSet . getString ( 1 ) ; byte [ ] data = resultSet . getBytes ( 2 ) ; ImageLoader loader = new ImageLoader ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( data ) ; loader . load ( in ) ; ImageUtils . fileIconsHash . put ( name , new Image ( display , loader . data [ 0 ] ) ) ; count ++ ; } } AptanaDB db = AptanaDB . getInstance ( ) ; Handler handler = new Handler ( ) ; db . execute ( "SELECT * FROM CACHE" , handler ) ; result = handler . count ; } return result ; } public static int saveImageCache ( ) { Connection conn = AptanaDB . getInstance ( ) . getConnection ( ) ; int numRows = 0 ; if ( conn != null ) { List < String > currentList = getImageCacheNames ( conn ) ; Iterator < String > keys = fileIconsHash . keySet ( ) . iterator ( ) ; String sql = "insert into CACHE (name, image, filesize) values (?,?,?)" ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; while ( keys . hasNext ( ) ) { String name = keys . next ( ) ; if ( currentList . contains ( name ) == false ) { Image image = ImageUtils . fileIconsHash . get ( name ) ; try { ImageLoader saver = new ImageLoader ( ) ; saver . data = new ImageData [ ] { image . getImageData ( ) } ; saver . save ( out , SWT . IMAGE_BMP ) ; byte [ ] imageBytes = out . toByteArray ( ) ; PreparedStatement prepStmt = conn . prepareStatement ( sql ) ; prepStmt . setString ( 1 , name ) ; prepStmt . setBytes ( 2 , imageBytes ) ; prepStmt . setInt ( 3 , imageBytes . length ) ; numRows += prepStmt . executeUpdate ( ) ; prepStmt . close ( ) ; } catch ( SQLException e ) { IdeLog . logInfo ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_ErrorSavingIconImageCache , e ) ; } } out . reset ( ) ; } } return numRows ; } private static void createTable ( ) { AptanaDB db = AptanaDB . getInstance ( ) ; db . execute ( "CREATE TABLE CACHE (name varchar(255) PRIMARY KEY,image BLOB(25000),filesize int)" ) ; } private static boolean checkTable ( ) throws SQLException { Connection conn = null ; Statement s = null ; boolean result = true ; try { conn = AptanaDB . getInstance ( ) . getConnection ( ) ; if ( conn != null ) { s = conn . createStatement ( ) ; s . execute ( "select name FROM CACHE where name='test'" ) ; } else { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_NoConnection ) ; result = false ; } } catch ( SQLException sqle ) { String theError = ( sqle ) . getSQLState ( ) ; if ( theError . equals ( "42X05" ) ) { result = false ; } else if ( theError . equals ( "42X14" ) || theError . equals ( "42821" ) ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_IncorrectTableDefinition ) ; throw sqle ; } else { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_SQLException ) ; throw sqle ; } } finally { if ( s != null ) { s . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } return result ; } } 
=======
public final class Language extends AbstractDatatype { public static final Language THE_INSTANCE = new Language ( ) ; private static final Pattern HYPHEN = Pattern . compile ( "-" ) ; private static final boolean WARN = System . getProperty ( "org.whattf.datatype.warn" , "" ) . equals ( "true" ) ? true : false ; private static String [ ] languages = null ; private static String [ ] extlangs = null ; private static String [ ] scripts = null ; private static String [ ] regions = null ; private static String [ ] variants = null ; private static String [ ] grandfathered = null ; private static String [ ] redundant = null ; private static String [ ] deprecated = null ; private static String [ ] deprecatedLang = null ; private static int [ ] suppressedScriptByLanguage = null ; private static Map < String , String > preferredValueByLanguageMap = new HashMap < String , String > ( ) ; private static String [ ] [ ] [ ] prefixesByVariant = null ; private static int [ ] prefixByExtlang = null ; static { try { LanguageData data = new LanguageData ( ) ; languages = data . getLanguages ( ) ; extlangs = data . getExtlangs ( ) ; scripts = data . getScripts ( ) ; regions = data . getRegions ( ) ; variants = data . getVariants ( ) ; grandfathered = data . getGrandfathered ( ) ; redundant = data . getRedundant ( ) ; deprecated = data . getDeprecated ( ) ; deprecatedLang = data . getDeprecatedLang ( ) ; suppressedScriptByLanguage = data . getSuppressedScriptByLanguage ( ) ; prefixByExtlang = data . getPrefixByExtlang ( ) ; preferredValueByLanguageMap = data . getPreferredValueByLanguageMap ( ) ; prefixesByVariant = data . getPrefixesByVariant ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } private Language ( ) { super ( ) ; } public void checkValid ( CharSequence lit ) throws DatatypeException { String literal = lit . toString ( ) ; if ( literal . length ( ) == 0 ) { throw newDatatypeException ( "The empty string is not a valid language tag." ) ; } literal = toAsciiLowerCase ( literal ) ; if ( isGrandfathered ( literal ) ) { if ( isDeprecated ( literal ) && WARN ) { throw newDatatypeException ( "The grandfathered language tag " , literal , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } return ; } if ( isRedundant ( literal ) ) { if ( isDeprecated ( literal ) && WARN ) { throw newDatatypeException ( "The language tag " , lit . toString ( ) , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } return ; } if ( literal . startsWith ( "-" ) ) { throw newDatatypeException ( "Language tag must not start with HYPHEN-MINUS." ) ; } if ( literal . endsWith ( "-" ) ) { throw newDatatypeException ( "Language tag must not end with HYPHEN-MINUS." ) ; } String [ ] subtags = HYPHEN . split ( literal ) ; for ( int j = 0 ; j < subtags . length ; j ++ ) { int len = subtags [ j ] . length ( ) ; if ( len == 0 ) { throw newDatatypeException ( "Zero-length subtag." ) ; } else if ( len > 8 ) { throw newDatatypeException ( "Subtags must not exceed 8 characters in length." ) ; } } int i = 0 ; String subtag = subtags [ i ] ; int len = subtag . length ( ) ; if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( ( len == 2 || len == 3 ) && isLowerCaseAlpha ( subtag ) ) { if ( ! isLanguage ( subtag ) ) { throw newDatatypeException ( "The language subtag " , subtag , " is not a valid ISO language part of a language tag." ) ; } if ( isDeprecatedLang ( subtag ) && WARN ) { throw newDatatypeException ( "The language subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } else if ( len == 4 && isLowerCaseAlpha ( subtag ) ) { throw newDatatypeException ( "Found reserved language tag: " , subtag , "." ) ; } else if ( len >= 5 && isLowerCaseAlpha ( subtag ) ) { if ( ! isLanguage ( subtag ) ) { throw newDatatypeException ( "The language subtag " , subtag , " is not a valid IANA language part of a language tag." ) ; } if ( isDeprecatedLang ( subtag ) && WARN ) { throw newDatatypeException ( "The language subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } else { throw newDatatypeException ( "The language subtag " , subtag , " is not a valid language subtag." ) ; } if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( subtag . length ( ) == 3 && isLowerCaseAlpha ( subtag ) ) { if ( ! isExtlang ( subtag ) ) { throw newDatatypeException ( "Bad extlang subtag " , subtag , "." ) ; } if ( ! usesPrefixByExtlang ( subtags [ 0 ] , subtag ) ) { throw newDatatypeException ( "Extlang subtag " , subtag , " has an incorrect prefix." ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( subtag . length ( ) == 4 & isLowerCaseAlpha ( subtag ) ) { if ( ! isScript ( subtag ) ) { throw newDatatypeException ( "Bad script subtag." ) ; } if ( isDeprecated ( subtag ) && WARN ) { throw newDatatypeException ( "The script subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } if ( shouldSuppressScript ( subtags [ 0 ] , subtag ) ) { throw newDatatypeException ( "Language tag should omit the default script for the language." ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } if ( ( len == 3 && isDigit ( subtag ) ) || ( len == 2 && isLowerCaseAlpha ( subtag ) ) ) { if ( ! isRegion ( subtag ) ) { throw newDatatypeException ( "Bad region subtag." ) ; } if ( isDeprecated ( subtag ) && WARN ) { throw newDatatypeException ( "The region subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } for ( ; ; ) { if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( len == 1 && isLowerCaseAlphaNumeric ( subtag ) ) { throw newDatatypeException ( "Unknown extension " , subtag , "." ) ; } else if ( ( len == 4 && isDigit ( subtag . charAt ( 0 ) ) && isLowerCaseAlphaNumeric ( subtag ) ) || ( len >= 5 && isLowerCaseAlphaNumeric ( subtag ) ) ) { if ( ! isVariant ( subtag ) ) { throw newDatatypeException ( "Bad variant subtag " , subtag , "." ) ; } if ( isDeprecated ( subtag ) && WARN ) { throw newDatatypeException ( "The variant subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } checkForValidPrefix ( subtag , subtags , i ) ; } else { throw newDatatypeException ( "The subtag " , subtag , " does not match the format for any permissible subtag type." ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } } private void checkForValidPrefix ( String subtag , String [ ] subtags , int i ) throws DatatypeException { String variant = subtags [ i ] ; int index = Arrays . binarySearch ( variants , variant ) ; assert index >= 0 ; String [ ] [ ] prefixes = prefixesByVariant [ index ] ; if ( prefixes . length == 0 ) { return ; } List < String > recommendedPrefixes = new ArrayList < String > ( ) ; for ( int j = 0 ; j < prefixes . length ; j ++ ) { String [ ] prefix = prefixes [ j ] ; for ( int k = 0 ; k < prefix . length ; k ++ ) { String prefixComponent = prefix [ k ] ; if ( ! subtagsContainPrefixComponent ( prefixComponent , subtags , i ) ) { recommendedPrefixes . add ( prefixComponent ) ; } } if ( prefixMatches ( prefix , subtags , i ) ) { return ; } } if ( recommendedPrefixes . size ( ) == 0 ) { return ; } int count = recommendedPrefixes . size ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( recommendedPrefixes . size ( ) > 1 ) { sb . append ( " one of " ) ; } for ( String prefix : recommendedPrefixes ) { if ( count != recommendedPrefixes . size ( ) ) { sb . append ( ", " ) ; if ( count == 1 ) { sb . append ( " or " ) ; } } sb . append ( "“" ) ; sb . append ( prefix ) ; sb . append ( '”' ) ; count -- ; } throw newDatatypeException ( "Variant " , subtag , " lacks recommended prefix. Use " + sb + " instead." ) ; } private boolean prefixMatches ( String [ ] prefix , String [ ] subtags , int limit ) { for ( int i = 0 ; i < prefix . length ; i ++ ) { String prefixComponent = prefix [ i ] ; if ( ! subtagsContainPrefixComponent ( prefixComponent , subtags , limit ) ) { return false ; } } return true ; } private boolean subtagsContainPrefixComponent ( String prefixComponent , String [ ] subtags , int limit ) { for ( int i = 0 ; i < limit ; i ++ ) { String subtag = subtags [ i ] ; if ( subtag . equals ( prefixComponent ) ) { return true ; } } return false ; } private boolean usesPrefixByExtlang ( String language , String extlang ) { int langIndex = Arrays . binarySearch ( languages , language ) ; int extlangIndex = Arrays . binarySearch ( extlangs , extlang ) ; assert langIndex > - 1 ; int prefixExpected = prefixByExtlang [ extlangIndex ] ; return prefixExpected == langIndex ; } private boolean shouldSuppressScript ( String language , String script ) { int langIndex = Arrays . binarySearch ( languages , language ) ; assert langIndex > - 1 ; int scriptIndex = suppressedScriptByLanguage [ langIndex ] ; if ( scriptIndex < 0 ) { return false ; } else { return scripts [ scriptIndex ] . equals ( script ) ; } } private boolean isVariant ( String subtag ) { return ( Arrays . binarySearch ( variants , subtag ) > - 1 ) ; } private boolean isRegion ( String subtag ) { return ( Arrays . binarySearch ( regions , subtag ) > - 1 ) || "aa" . equals ( subtag ) || ( "qm" . compareTo ( subtag ) <= 0 && "qz" . compareTo ( subtag ) >= 0 ) || ( "xa" . compareTo ( subtag ) <= 0 && "xz" . compareTo ( subtag ) >= 0 ) || "zz" . equals ( subtag ) ; } private boolean isScript ( String subtag ) { return ( Arrays . binarySearch ( scripts , subtag ) > - 1 ) || ( "qaaa" . compareTo ( subtag ) <= 0 && "qabx" . compareTo ( subtag ) >= 0 ) ; } private boolean isExtlang ( String subtag ) { return ( Arrays . binarySearch ( extlangs , subtag ) > - 1 ) ; } private boolean isLanguage ( String subtag ) { return ( Arrays . binarySearch ( languages , subtag ) > - 1 ) || ( "qaa" . compareTo ( subtag ) <= 0 && "qtz" . compareTo ( subtag ) >= 0 ) ; } private void checkPrivateUse ( int i , String [ ] subtags ) throws DatatypeException { int len = subtags . length ; i ++ ; if ( i == len ) { throw newDatatypeException ( "No subtags in private use sequence." ) ; } while ( i < len ) { String subtag = subtags [ i ] ; if ( subtag . length ( ) < 2 ) { throw newDatatypeException ( "Private use subtag " , subtag , " is too short." ) ; } if ( ! isLowerCaseAlphaNumeric ( subtag ) ) { throw newDatatypeException ( "Bad character in private use subtag " , subtag , "." ) ; } i ++ ; } } private final boolean isLowerCaseAlphaNumeric ( char c ) { return isLowerCaseAlpha ( c ) || isDigit ( c ) ; } private final boolean isLowerCaseAlphaNumeric ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isLowerCaseAlphaNumeric ( str . charAt ( i ) ) ) { return false ; } } return true ; } private final boolean isDigit ( char c ) { return ( c >= '0' && c <= '9' ) ; } private final boolean isDigit ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isDigit ( str . charAt ( i ) ) ) { return false ; } } return true ; } private final boolean isLowerCaseAlpha ( char c ) { return ( c >= 'a' && c <= 'z' ) ; } private final boolean isLowerCaseAlpha ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isLowerCaseAlpha ( str . charAt ( i ) ) ) { return false ; } } return true ; } private boolean isGrandfathered ( String literal ) { return Arrays . binarySearch ( grandfathered , literal ) > - 1 ; } private boolean isRedundant ( String literal ) { return Arrays . binarySearch ( redundant , literal ) > - 1 ; } private boolean isDeprecated ( String subtag ) { return Arrays . binarySearch ( deprecated , subtag ) > - 1 ; } private boolean isDeprecatedLang ( String subtag ) { return Arrays . binarySearch ( deprecatedLang , subtag ) > - 1 ; } @ Override public String getName ( ) { return "language tag" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
