public final class ImageUtils { private static java . awt . Color whiteBackground = null ; private static ImageRegistry imageRegistry = null ; private static Image fIconDrive = null ; private static ISharedImages sharedImages = null ; private static Image iconFolder = null ; private static Image iconFile = null ; private static boolean imageCacheLoaded = false ; public static Map < String , Image > fileIconsHash = new HashMap < String , Image > ( ) ; private ImageUtils ( ) { } public static ImageDescriptor getImageDescriptor ( String imageFilePath ) { ImageDescriptor imageDescriptor = CoreUIPlugin . getImageDescriptor ( imageFilePath ) ; if ( imageDescriptor == null ) { imageDescriptor = ImageDescriptor . getMissingImageDescriptor ( ) ; } return imageDescriptor ; } public static Image getIcon ( File file , Color backgroundColor ) { if ( ! CoreUIUtils . onMacOSX ) { String fileType = null ; String fileDisplayName = null ; try { fileType = FileSystemView . getFileSystemView ( ) . getSystemTypeDescription ( file ) ; fileDisplayName = FileSystemView . getFileSystemView ( ) . getSystemDisplayName ( file ) ; } catch ( Exception ignore ) { } if ( fileDisplayName != null && fileType != null ) { if ( fileDisplayName . equals ( "Desktop" ) ) { fileType = "Desktop" ; } if ( fileIconsHash . containsKey ( fileType ) ) { return fileIconsHash . get ( fileType ) ; } else if ( fileIconsHash . containsKey ( fileType + "#" + fileDisplayName ) ) { return fileIconsHash . get ( fileType + "#" + fileDisplayName ) ; } else { Icon icon = FileSystemView . getFileSystemView ( ) . getSystemIcon ( file ) ; if ( icon instanceof ImageIcon ) { Image image = awtImageIconToSWTImage ( icon , backgroundColor ) ; if ( fileType . equals ( "Application" ) || fileType . equals ( "System Folder" ) || fileDisplayName . equals ( "Desktop" ) || fileType . indexOf ( "Shortcut" ) > - 1 ) { fileIconsHash . put ( fileType + "#" + fileDisplayName , image ) ; } else { fileIconsHash . put ( fileType , image ) ; } return image ; } } } } if ( file . getName ( ) . equals ( "" ) ) { return getDriveIcon ( ) ; } if ( FileUtils . isDirectory ( file ) ) { return getFolderIcon ( ) ; } int lastDotPos = file . getName ( ) . indexOf ( '.' ) ; if ( lastDotPos == - 1 ) { return getFileIcon ( ) ; } Image image = getIcon ( file . getName ( ) . substring ( lastDotPos + 1 ) ) ; return image == null ? getFileIcon ( ) : image ; } public static Image getDriveIcon ( ) { if ( fIconDrive == null ) { fIconDrive = getImageDescriptor ( "icons/drive.gif" ) . createImage ( ) ; } return fIconDrive ; } public static Image getFolderIcon ( ) { checkSharedImages ( ) ; if ( iconFolder == null ) { iconFolder = sharedImages . getImage ( ISharedImages . IMG_OBJ_FOLDER ) ; } return iconFolder ; } public static Image getFileIcon ( ) { checkSharedImages ( ) ; if ( iconFile == null ) { iconFile = sharedImages . getImage ( ISharedImages . IMG_OBJ_FILE ) ; } return iconFile ; } private static void checkSharedImages ( ) { if ( sharedImages == null ) { sharedImages = PlatformUI . getWorkbench ( ) . getSharedImages ( ) ; } } public static Image getIcon ( String extension ) { if ( imageRegistry == null ) { imageRegistry = new ImageRegistry ( ) ; } Image image = imageRegistry . get ( extension ) ; if ( image != null ) { return image ; } if ( extension == null ) { return iconFile ; } Program program = Program . findProgram ( extension ) ; ImageData imageData = ( program == null ? null : program . getImageData ( ) ) ; if ( imageData != null ) { image = new Image ( Display . getCurrent ( ) , imageData ) ; imageRegistry . put ( extension , image ) ; } else { image = iconFile ; } return image ; } public static Image awtImageIconToSWTImage ( Icon icon , Color backgroundColor ) { ImageIcon i = ( ImageIcon ) icon ; java . awt . Color backColor = null ; if ( backgroundColor != null ) { backColor = swtColorToAWTColor ( backgroundColor ) ; } else { if ( whiteBackground == null ) { whiteBackground = swtColorToAWTColor ( new Color ( Display . getCurrent ( ) , 255 , 255 , 255 ) ) ; } backColor = whiteBackground ; } BufferedImage bi = new BufferedImage ( i . getIconWidth ( ) , i . getIconHeight ( ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D imageGraphics = bi . createGraphics ( ) ; imageGraphics . drawImage ( i . getImage ( ) , 0 , 0 , backColor , ( ImageObserver ) null ) ; ImageData data = awtBufferedImageToSWTImageData ( bi ) ; try { return new Image ( Display . getCurrent ( ) , data ) ; } finally { imageGraphics . dispose ( ) ; } } public static java . awt . Color swtColorToAWTColor ( org . eclipse . swt . graphics . Color background ) { return new java . awt . Color ( background . getRed ( ) , background . getGreen ( ) , background . getBlue ( ) ) ; } public static ImageData awtBufferedImageToSWTImageData ( BufferedImage bufferedImage ) { if ( bufferedImage . getColorModel ( ) instanceof DirectColorModel ) { DirectColorModel colorModel = ( DirectColorModel ) bufferedImage . getColorModel ( ) ; PaletteData palette = new PaletteData ( colorModel . getRedMask ( ) , colorModel . getGreenMask ( ) , colorModel . getBlueMask ( ) ) ; ImageData data = new ImageData ( bufferedImage . getWidth ( ) , bufferedImage . getHeight ( ) , colorModel . getPixelSize ( ) , palette ) ; WritableRaster raster = bufferedImage . getRaster ( ) ; int [ ] pixelArray = new int [ 3 ] ; for ( int y = 0 ; y < data . height ; y ++ ) { for ( int x = 0 ; x < data . width ; x ++ ) { raster . getPixel ( x , y , pixelArray ) ; int pixel = palette . getPixel ( new RGB ( pixelArray [ 0 ] , pixelArray [ 1 ] , pixelArray [ 2 ] ) ) ; data . setPixel ( x , y , pixel ) ; } } return data ; } else if ( bufferedImage . getColorModel ( ) instanceof IndexColorModel ) { IndexColorModel colorModel = ( IndexColorModel ) bufferedImage . getColorModel ( ) ; int size = colorModel . getMapSize ( ) ; byte [ ] reds = new byte [ size ] ; byte [ ] greens = new byte [ size ] ; byte [ ] blues = new byte [ size ] ; colorModel . getReds ( reds ) ; colorModel . getGreens ( greens ) ; colorModel . getBlues ( blues ) ; RGB [ ] rgbs = new RGB [ size ] ; for ( int i = 0 ; i < rgbs . length ; i ++ ) { rgbs [ i ] = new RGB ( reds [ i ] & 0xFF , greens [ i ] & 0xFF , blues [ i ] & 0xFF ) ; } PaletteData palette = new PaletteData ( rgbs ) ; ImageData data = new ImageData ( bufferedImage . getWidth ( ) , bufferedImage . getHeight ( ) , colorModel . getPixelSize ( ) , palette ) ; data . transparentPixel = colorModel . getTransparentPixel ( ) ; WritableRaster raster = bufferedImage . getRaster ( ) ; int [ ] pixelArray = new int [ 1 ] ; for ( int y = 0 ; y < data . height ; y ++ ) { for ( int x = 0 ; x < data . width ; x ++ ) { raster . getPixel ( x , y , pixelArray ) ; data . setPixel ( x , y , pixelArray [ 0 ] ) ; } } return data ; } return null ; } private static List < String > getImageCacheNames ( Connection conn ) { AptanaDB db = AptanaDB . getInstance ( ) ; final List < String > list = new ArrayList < String > ( ) ; db . execute ( "select name FROM CACHE" , new IResultSetHandler ( ) { public void processResultSet ( ResultSet resultSet ) throws SQLException { String name = resultSet . getString ( 1 ) ; list . add ( name ) ; } } ) ; return list ; } public static int loadImageCache ( final Display display ) { int result = - 1 ; if ( imageCacheLoaded == false ) { imageCacheLoaded = true ; try { if ( checkTable ( ) == false ) { createTable ( ) ; } } catch ( SQLException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_ErrorInitializingDbConnection , e ) ; if ( e . getNextException ( ) != null ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_ErrorInitializingDbConnection , e . getNextException ( ) ) ; } } final class Handler implements IResultSetHandler { public int count = 0 ; public void processResultSet ( ResultSet resultSet ) throws SQLException { String name = resultSet . getString ( 1 ) ; byte [ ] data = resultSet . getBytes ( 2 ) ; ImageLoader loader = new ImageLoader ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( data ) ; loader . load ( in ) ; ImageUtils . fileIconsHash . put ( name , new Image ( display , loader . data [ 0 ] ) ) ; count ++ ; } } AptanaDB db = AptanaDB . getInstance ( ) ; Handler handler = new Handler ( ) ; db . execute ( "SELECT * FROM CACHE" , handler ) ; result = handler . count ; } return result ; } public static int saveImageCache ( ) { Connection conn = AptanaDB . getInstance ( ) . getConnection ( ) ; int numRows = 0 ; if ( conn != null ) { List < String > currentList = getImageCacheNames ( conn ) ; Iterator < String > keys = fileIconsHash . keySet ( ) . iterator ( ) ; String sql = "insert into CACHE (name, image, filesize) values (?,?,?)" ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; while ( keys . hasNext ( ) ) { String name = keys . next ( ) ; if ( currentList . contains ( name ) == false ) { Image image = ImageUtils . fileIconsHash . get ( name ) ; try { ImageLoader saver = new ImageLoader ( ) ; saver . data = new ImageData [ ] { image . getImageData ( ) } ; saver . save ( out , SWT . IMAGE_BMP ) ; byte [ ] imageBytes = out . toByteArray ( ) ; PreparedStatement prepStmt = conn . prepareStatement ( sql ) ; prepStmt . setString ( 1 , name ) ; prepStmt . setBytes ( 2 , imageBytes ) ; prepStmt . setInt ( 3 , imageBytes . length ) ; numRows += prepStmt . executeUpdate ( ) ; prepStmt . close ( ) ; } catch ( SQLException e ) { IdeLog . logInfo ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_ErrorSavingIconImageCache , e ) ; } } out . reset ( ) ; } } return numRows ; } private static void createTable ( ) { AptanaDB db = AptanaDB . getInstance ( ) ; db . execute ( "CREATE TABLE CACHE (name varchar(255) PRIMARY KEY,image BLOB(25000),filesize int)" ) ; } private static boolean checkTable ( ) throws SQLException { Connection conn = null ; Statement s = null ; boolean result = true ; try { conn = AptanaDB . getInstance ( ) . getConnection ( ) ; if ( conn != null ) { s = conn . createStatement ( ) ; s . execute ( "select name FROM CACHE where name='test'" ) ; } else { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_NoConnection ) ; result = false ; } } catch ( SQLException sqle ) { String theError = ( sqle ) . getSQLState ( ) ; if ( theError . equals ( "42X05" ) ) { result = false ; } else if ( theError . equals ( "42X14" ) || theError . equals ( "42821" ) ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_IncorrectTableDefinition ) ; throw sqle ; } else { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . ImageUtils_SQLException ) ; throw sqle ; } } finally { if ( s != null ) { s . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } return result ; } } 