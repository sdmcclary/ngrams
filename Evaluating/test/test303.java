public class GraphControl extends AWTEmbeddedControl { private static final String GRAPH = "graph" ; private static final String NODES = "graph.nodes" ; private static final String EDGES = "graph.edges" ; private static final String AGGREGATES = "aggregates" ; private Graph graph = null ; private Visualization visualization ; private Display overview ; private AggregateTable aggregateTable ; private ForceDirectedLayout forceLayout ; private boolean showLabels ; private boolean showImages ; private boolean enforceBounds ; private ColumnLabelProvider nodeLabelProvider ; private Map < String , AggregateItem > aggregates ; static private int [ ] palette = new int [ ] { ColorLib . rgb ( 255 , 255 , 150 ) , ColorLib . rgb ( 205 , 145 , 63 ) , ColorLib . rgb ( 202 , 62 , 94 ) , ColorLib . rgb ( 255 , 152 , 213 ) , ColorLib . rgb ( 83 , 140 , 208 ) , ColorLib . rgb ( 178 , 220 , 205 ) , ColorLib . rgb ( 146 , 248 , 70 ) , ColorLib . rgb ( 175 , 200 , 74 ) } ; static private int [ ] aggregatesPalette = new int [ ] { ColorLib . rgba ( 0xff , 0xc8 , 0xc8 , 150 ) , ColorLib . rgba ( 0xc8 , 0xff , 0xc8 , 150 ) , ColorLib . rgba ( 0xc8 , 0xc8 , 0xff , 150 ) , ColorLib . rgba ( 0xc8 , 0xff , 0xff , 150 ) , ColorLib . rgba ( 0xff , 0xc8 , 0xff , 150 ) , ColorLib . rgba ( 0xff , 0xff , 0xc8 , 150 ) , } ; public GraphControl ( Composite parent ) { super ( parent ) ; setOverviewEnabled ( true ) ; } public void setGraph ( Graph graph ) { this . graph = graph ; updateVisualization ( ) ; } protected Component createAWTComponent ( ) { visualization = new Visualization ( ) ; updateVisualization ( ) ; TupleSet focusGroup = visualization . getGroup ( Visualization . FOCUS_ITEMS ) ; focusGroup . addTupleSetListener ( new TupleSetListener ( ) { public void tupleSetChanged ( TupleSet ts , Tuple [ ] add , Tuple [ ] rem ) { for ( int i = 0 ; i < rem . length ; ++ i ) { ( ( VisualItem ) rem [ i ] ) . setFixed ( false ) ; } for ( int i = 0 ; i < add . length ; ++ i ) { ( ( VisualItem ) add [ i ] ) . setFixed ( true ) ; } if ( ts . getTupleCount ( ) == 0 ) { ts . addTuple ( rem [ 0 ] ) ; ( ( VisualItem ) rem [ 0 ] ) . setFixed ( false ) ; } visualization . run ( "draw" ) ; } } ) ; setRenderers ( ) ; setLayoutActions ( ) ; setDrawActions ( ) ; Display display = new Display ( visualization ) ; display . setSize ( 700 , 700 ) ; display . pan ( 350 , 350 ) ; display . setHighQuality ( false ) ; display . addControlListener ( new FocusControl ( ) ) ; display . addControlListener ( new AggregateDragControl ( ) ) ; display . addControlListener ( new PanControl ( Control . LEFT_MOUSE_BUTTON , false ) ) ; display . addControlListener ( new ZoomControl ( Control . MIDDLE_MOUSE_BUTTON ) { protected int zoom ( Display display , Point2D p , double zoom , boolean abs ) { zoom = 1.0 / zoom ; return super . zoom ( display , p , zoom , abs ) ; } } ) ; display . addControlListener ( new WheelZoomControl ( ) ) ; display . addControlListener ( new ZoomToFitControl ( Control . MIDDLE_MOUSE_BUTTON ) ) ; display . addControlListener ( new NeighborHighlightControl ( ) ) ; display . setForeground ( Color . DARK_GRAY ) ; display . setBackground ( Color . WHITE ) ; visualization . runAfter ( "draw" , "layout" ) ; visualization . run ( "draw" ) ; return display ; } private void setRenderers ( ) { AbstractShapeRenderer nodeRenderer ; if ( showLabels || showImages ) { nodeRenderer = new LabelRenderer ( ) { public String getText ( VisualItem item ) { if ( showLabels && item . canGet ( "entity" , IEntity . class ) ) return nodeLabelProvider . getText ( item . get ( "entity" ) ) ; return null ; } public Image getImage ( VisualItem item ) { if ( showImages && item . canGet ( "entity" , IEntity . class ) ) return ImageConverter . convert ( nodeLabelProvider . getImage ( item . get ( "entity" ) ) ) ; return null ; } } ; } else { nodeRenderer = new ShapeRenderer ( ) ; } DefaultRendererFactory rendererFactory = new DefaultRendererFactory ( ) ; rendererFactory . setDefaultRenderer ( nodeRenderer ) ; PolygonRenderer polygonRenderer = new PolygonRenderer ( Constants . POLY_TYPE_CURVE ) ; polygonRenderer . setCurveSlack ( 0.15f ) ; rendererFactory . add ( "ingroup('" + AGGREGATES + "')" , polygonRenderer ) ; visualization . setRendererFactory ( rendererFactory ) ; } private void setDrawActions ( ) { ActionList draw = new ActionList ( ) ; ShapeAction shape = new DataShapeAction ( NODES , "shape" ) ; draw . add ( shape ) ; ColorAction fill = new DataColorAction ( NODES , "color" , Constants . NOMINAL , VisualItem . FILLCOLOR , palette ) ; fill . add ( VisualItem . FIXED , ColorLib . rgb ( 255 , 100 , 100 ) ) ; fill . add ( VisualItem . HIGHLIGHT , ColorLib . rgb ( 255 , 200 , 125 ) ) ; draw . add ( fill ) ; ColorAction aStroke = new ColorAction ( AGGREGATES , VisualItem . STROKECOLOR ) ; aStroke . setDefaultColor ( ColorLib . gray ( 200 ) ) ; aStroke . add ( "_hover" , ColorLib . rgb ( 255 , 100 , 100 ) ) ; draw . add ( aStroke ) ; draw . add ( new ColorAction ( NODES , VisualItem . STROKECOLOR , ColorLib . gray ( 100 ) ) ) ; draw . add ( new ColorAction ( NODES , VisualItem . TEXTCOLOR , ColorLib . rgb ( 0 , 0 , 0 ) ) ) ; draw . add ( new ColorAction ( EDGES , VisualItem . FILLCOLOR , ColorLib . gray ( 128 ) ) ) ; draw . add ( new ColorAction ( EDGES , VisualItem . STROKECOLOR , ColorLib . gray ( 128 ) ) ) ; visualization . putAction ( "draw" , draw ) ; } private void setLayoutActions ( ) { ActionList layout = new ActionList ( Activity . INFINITY ) ; ForceSimulator forceSimulator = new ForceSimulator ( ) ; forceSimulator . addForce ( new NBodyForce ( NBodyForce . DEFAULT_GRAV_CONSTANT , 200 , NBodyForce . DEFAULT_THETA ) ) ; forceSimulator . addForce ( new SpringForce ( ) ) ; forceSimulator . addForce ( new DragForce ( ) ) ; forceLayout = new ForceDirectedLayout ( GRAPH , forceSimulator , enforceBounds ) ; layout . add ( forceLayout ) ; layout . add ( new AggregateLayout ( AGGREGATES ) ) ; layout . add ( new RepaintAction ( ) ) ; visualization . removeAction ( "layout" ) ; visualization . putAction ( "layout" , layout ) ; visualization . runAfter ( "draw" , "layout" ) ; visualization . run ( "draw" ) ; } public void setNodeLabelProvider ( ColumnLabelProvider nodeLabelProvider ) { this . nodeLabelProvider = nodeLabelProvider ; } public synchronized void updateVisualization ( ) { if ( graph == null ) return ; System . out . println ( "updateVisualization()" ) ; aggregates = new HashMap < String , AggregateItem > ( ) ; visualization . removeGroup ( AGGREGATES ) ; aggregateTable = visualization . addAggregates ( AGGREGATES ) ; aggregateTable . addColumn ( VisualItem . POLYGON , float [ ] . class ) ; aggregateTable . addColumn ( "id" , String . class ) ; visualization . removeGroup ( GRAPH ) ; final VisualGraph vg = visualization . addGraph ( GRAPH , graph ) ; visualization . setValue ( EDGES , null , VisualItem . INTERACTIVE , Boolean . FALSE ) ; vg . getNodeTable ( ) . addTableListener ( new TableListener ( ) { public void tableChanged ( Table t , int start , int end , int col , int type ) { if ( col == - 1 ) return ; if ( t . getColumnName ( col ) . equals ( "aggregate" ) ) for ( int i = start ; i <= end ; i ++ ) addNodeToAggregate ( ( VisualItem ) vg . getNodeTable ( ) . getTuple ( i ) ) ; } } ) ; if ( vg . getNodeCount ( ) <= 0 ) return ; VisualItem f = ( VisualItem ) vg . getNode ( 0 ) ; visualization . getGroup ( Visualization . FOCUS_ITEMS ) . setTuple ( f ) ; } private void addNodeToAggregate ( VisualItem node ) { if ( ! ( node instanceof NodeItem ) ) return ; String aggregate = node . getString ( "aggregate" ) ; if ( aggregate == null ) return ; AggregateItem aitem = aggregates . get ( aggregate ) ; if ( aitem == null ) { aitem = ( AggregateItem ) aggregateTable . addItem ( ) ; aitem . set ( "id" , aggregate ) ; aggregates . put ( aggregate , aitem ) ; } aitem . addItem ( node ) ; } public void redraw ( ) { visualization . run ( "draw" ) ; embeddee . repaint ( ) ; } public class FitOverviewListener implements ItemBoundsListener { private Rectangle2D m_bounds = new Rectangle2D . Double ( ) ; private Rectangle2D m_temp = new Rectangle2D . Double ( ) ; private double m_d = 15 ; public void itemBoundsChanged ( Display d ) { d . getItemBounds ( m_temp ) ; GraphicsLib . expand ( m_temp , 25 / d . getScale ( ) ) ; double dd = m_d / d . getScale ( ) ; double xd = Math . abs ( m_temp . getMinX ( ) - m_bounds . getMinX ( ) ) ; double yd = Math . abs ( m_temp . getMinY ( ) - m_bounds . getMinY ( ) ) ; double wd = Math . abs ( m_temp . getWidth ( ) - m_bounds . getWidth ( ) ) ; double hd = Math . abs ( m_temp . getHeight ( ) - m_bounds . getHeight ( ) ) ; if ( xd > dd || yd > dd || wd > dd || hd > dd ) { m_bounds . setFrame ( m_temp ) ; DisplayLib . fitViewToBounds ( d , m_bounds , 0 ) ; } } } public void addPrefuseControlListener ( Control control ) { ( ( Display ) embeddee ) . addControlListener ( control ) ; } public void setAnimationEnabled ( boolean enabled ) { if ( forceLayout . isEnabled ( ) == enabled ) return ; forceLayout . setEnabled ( enabled ) ; if ( ! enabled ) redraw ( ) ; } public boolean isAnimationEnabled ( ) { return forceLayout != null && forceLayout . isEnabled ( ) ; } public void setOverviewEnabled ( boolean enabled ) { if ( overview != null ) { overview . setVisible ( enabled ) ; } else if ( enabled ) { overview = new Display ( visualization ) ; overview . setLocation ( 10 , 10 ) ; overview . setSize ( 100 , 100 ) ; overview . addItemBoundsListener ( new FitOverviewListener ( ) ) ; overview . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; ( ( Display ) embeddee ) . add ( overview ) ; } } public boolean isOverviewEnabled ( ) { return overview != null && overview . isVisible ( ) ; } public void setLabelsEnabled ( boolean enabled ) { if ( showLabels == enabled ) return ; showLabels = enabled ; setRenderers ( ) ; redraw ( ) ; } public boolean isLabelsEnabled ( ) { return showLabels ; } public void setImagesEnabled ( boolean enabled ) { if ( showImages == enabled ) return ; showImages = enabled ; setRenderers ( ) ; redraw ( ) ; } public boolean isImagesEnabled ( ) { return showImages ; } public void setEnforceBounds ( boolean enforceBounds ) { if ( this . enforceBounds == enforceBounds ) return ; this . enforceBounds = enforceBounds ; setLayoutActions ( ) ; redraw ( ) ; } public boolean isEnforceBounds ( ) { return enforceBounds ; } public VisualItem getItem ( Point point ) { return ( ( Display ) embeddee ) . findItem ( new java . awt . Point ( point . x , point . y ) ) ; } } 