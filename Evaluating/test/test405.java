<<<<<<< HEAD
public class MutableDeweyRefTree extends AbstractMutableRefTree implements KeyMap , BatchMutable { private DeweyRefNode root ; private DeweyKey rootKey ; private int rootKeyLen ; private boolean forceAutoKey = false ; private Map < DeweyKey , DeweyRefNode > nodeRefTab = new HashMap < DeweyKey , DeweyRefNode > ( ) ; private Map < DeweyKey , DeweyRefNode > treeRefTab = new HashMap < DeweyKey , DeweyRefNode > ( ) ; public void apply ( RefTree t ) throws NodeNotFoundException { Map < DeweyKey , DeweyRefNode > oldNRT = nodeRefTab ; nodeRefTab = new HashMap < DeweyKey , DeweyRefNode > ( ) ; Map < DeweyKey , DeweyRefNode > oldTRT = treeRefTab ; treeRefTab = new HashMap < DeweyKey , DeweyRefNode > ( ) ; try { setRoot ( apply ( t . getRoot ( ) , new DeweyRefNode . PrefixNode ( forceAutoKey ? DeweyKey . ROOT_KEY : ( DeweyKey ) t . getRoot ( ) . getId ( ) ) ) ) ; buildRefTab ( root ) ; } catch ( NodeNotFoundException e ) { Log . error ( "Apply failed, and rollback not coded.  :(" ) ; throw e ; } } @ Override public void delete ( Key id ) throws NodeNotFoundException { DeweyRefNode n = findExist ( ( DeweyKey ) id ) ; removeFromRefTabs ( n ) ; assert n . getParent ( ) != null : "Trying to delete the prefix node?" ; if ( n . getParent ( ) . getParent ( ) == null ) { setRoot ( null ) ; } else ( ( DeweyRefNode ) n . getParent ( ) ) . removeChild ( n ) ; } @ Override public Key insert ( Key parentId , long pos , Key newId , Object content ) throws NodeNotFoundException { if ( newId != AUTO_KEY && find ( ( DeweyKey ) newId ) != null ) throw new IllegalArgumentException ( "key already exists " + newId ) ; DeweyRefNode p = parentId == null ? null : findExist ( ( DeweyKey ) parentId ) ; DeweyRefNode n = null ; if ( p == null ) { DeweyKey rootKey = ( ! forceAutoKey && newId != AUTO_KEY ) ? ( DeweyKey ) newId : DeweyKey . ROOT_KEY ; n = new DeweyRefNode ( new DeweyRefNode . PrefixNode ( rootKey ) , 0 , content ) ; setRoot ( n ) ; } else { n = new DeweyRefNode ( content ) ; if ( pos == DEFAULT_POSITION ) p . addChild ( n ) ; else p . addChild ( ( int ) pos , n ) ; } if ( ! forceAutoKey && newId != AUTO_KEY && ! n . getId ( ) . equals ( newId ) ) { Key realId = n . getId ( ) ; if ( p != null ) p . removeChild ( n ) ; else { setRoot ( null ) ; } throw new NodeNotFoundException ( "The key " + newId + " does not agree with the insert position" , realId ) ; } if ( content instanceof Reference ) { Reference r = ( Reference ) content ; ( r . isTreeReference ( ) ? treeRefTab : nodeRefTab ) . put ( ( DeweyKey ) r . getTarget ( ) , n ) ; } return newId == AUTO_KEY || forceAutoKey ? n . getId ( ) : newId ; } private void setRoot ( DeweyRefNode n ) { if ( n == null ) { rootKey = null ; rootKeyLen = - 1 ; root = null ; nodeRefTab . clear ( ) ; treeRefTab . clear ( ) ; } else { rootKey = ( DeweyKey ) n . getId ( ) ; rootKeyLen = rootKey . length ( ) ; root = n ; } } @ Override public Key move ( Key nodeId , Key parentId , long pos ) throws NodeNotFoundException { DeweyRefNode n = findExist ( ( DeweyKey ) nodeId ) ; DeweyRefNode p = findExist ( ( DeweyKey ) parentId ) ; if ( n . getParent ( ) == null ) throw new IllegalArgumentException ( "Tried to move root" ) ; DeweyRefNode np = ( DeweyRefNode ) n . getParent ( ) ; int origPos = np . getPosition ( ) ; boolean removeOk = np . removeChild ( n ) ; assert removeOk ; if ( pos == DEFAULT_POSITION ) p . addChild ( n ) ; else { try { p . addChild ( ( int ) pos , n ) ; } catch ( RuntimeException e ) { np . addChild ( origPos , n ) ; throw e ; } } return n . getId ( ) ; } @ Override public boolean update ( Key nodeId , Object content ) throws NodeNotFoundException { DeweyRefNode n = findExist ( ( DeweyKey ) nodeId ) ; if ( ! Util . equals ( content , n . getContent ( ) ) ) { if ( n . isTreeRef ( ) && n . childCount ( ) > 0 ) throw new IllegalArgumentException ( "Tried to make inner node a ref-node, key: " + nodeId ) ; if ( n . isReference ( ) ) ( n . isTreeRef ( ) ? treeRefTab : nodeRefTab ) . remove ( n . getReference ( ) . getTarget ( ) ) ; n . setContent ( content ) ; if ( n . isReference ( ) ) ( n . isTreeRef ( ) ? treeRefTab : nodeRefTab ) . put ( ( DeweyKey ) n . getReference ( ) . getTarget ( ) , n ) ; return true ; } return false ; } @ Override public RefTreeNode getNode ( Key id ) { return id instanceof DeweyKey ? find ( ( DeweyKey ) id ) : null ; } @ Override public boolean contains ( Key id ) { return getNode ( id ) != null ; } @ Override public Key getParent ( Key nid ) throws NodeNotFoundException { if ( nid . equals ( rootKey ) ) return null ; return ( ( DeweyKey ) nid ) . up ( ) ; } @ Override public Iterator < Key > childIterator ( Key id ) throws NodeNotFoundException { final DeweyKey root = ( DeweyKey ) id ; DeweyRefNode n = findExist ( root ) ; final int count = n . childCount ( ) ; return new Iterator < Key > ( ) { int pos = 0 ; public boolean hasNext ( ) { return pos < count ; } public Key next ( ) { return root . child ( pos ++ ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public RefTreeNode getRoot ( ) { return root ; } public void dumpDebug ( ) { StringBuilder sb = new StringBuilder ( ) ; Log . debug ( String . valueOf ( treeRefTab . size ( ) ) + " key prefix mappings" , sb ) ; sb . setLength ( 0 ) ; Log . debug ( String . valueOf ( nodeRefTab . size ( ) ) + " exact key mappings" , sb ) ; } protected DeweyRefNode apply ( RefTreeNode n , DeweyRefNode p ) throws NodeNotFoundException { DeweyRefNode m = null ; if ( n . isReference ( ) ) { Reference r = n . getReference ( ) ; DeweyRefNode rt = findExist ( ( DeweyKey ) r . getTarget ( ) ) ; if ( r . isTreeReference ( ) ) { rt . detach ( ) ; m = rt ; } else { m = new DeweyRefNode ( rt . isReference ( ) ? ( rt . isNodeRef ( ) ? rt . getReference ( ) : new NodeReference ( rt . getReference ( ) . getTarget ( ) ) ) : rt . getContent ( ) ) ; } } else m = new DeweyRefNode ( n . getContent ( ) ) ; m . attach ( p ) ; for ( Iterator < RefTreeNode > ci = n . getChildIterator ( ) ; ci . hasNext ( ) ; ) apply ( ci . next ( ) , m ) ; return m ; } protected void buildRefTab ( DeweyRefNode n ) { if ( n . isReference ( ) ) { Reference r = n . getReference ( ) ; ( r . isTreeReference ( ) ? treeRefTab : nodeRefTab ) . put ( ( DeweyKey ) r . getTarget ( ) , n ) ; } for ( Iterator < DeweyRefNode > ci = n . getChildIterator ( ) ; ci . hasNext ( ) ; ) buildRefTab ( ci . next ( ) ) ; } protected void removeFromRefTabs ( RefTreeNode n ) { if ( n . isReference ( ) ) ( n . isTreeRef ( ) ? treeRefTab : nodeRefTab ) . remove ( n . getReference ( ) . getTarget ( ) ) ; for ( Iterator i = n . getChildIterator ( ) ; i . hasNext ( ) ; ) removeFromRefTabs ( ( RefTreeNode ) i . next ( ) ) ; } protected DeweyRefNode find ( DeweyKey k ) { return k == null || rootKey == null ? null : find ( k . getXasDeweyKey ( ) , k . length ( ) - rootKeyLen ) ; } protected DeweyRefNode find ( fc . xml . xas . index . DeweyKey k , int left ) { if ( left < 1 ) { if ( Util . equals ( rootKey . getXasDeweyKey ( ) , k ) ) return root ; else return null ; } else { DeweyRefNode p = find ( k . up ( ) , left - 1 ) ; int step = p == null ? - 1 : k . getLastStep ( ) ; return p == null || step >= p . childCount ( ) ? null : ( DeweyRefNode ) p . get ( step ) ; } } protected DeweyRefNode findExist ( DeweyKey k ) throws NodeNotFoundException { DeweyRefNode n = k == null ? null : find ( k . getXasDeweyKey ( ) , k . length ( ) - rootKeyLen ) ; if ( n == null ) throw new NodeNotFoundException ( k ) ; return n ; } public Key getBackKey ( Key frontKey ) { Key bk = _getBackKey ( frontKey ) ; return bk ; } public Key getFrontKey ( Key backKey ) { Key fk = _getFrontKey ( backKey ) ; return fk ; } public boolean isForceAutoKey ( ) { return forceAutoKey ; } public void setForceAutoKey ( boolean forceAutoKey ) { this . forceAutoKey = forceAutoKey ; } private Key _getBackKey ( Key frontKey ) { DeweyRefNode pos = root ; DeweyKey k = ( DeweyKey ) frontKey ; if ( k == null ) return null ; if ( pos != null && pos . isTreeRef ( ) || ( pos != null && pos . isNodeRef ( ) && rootKey . equals ( k ) ) ) { return k . replaceAncestorSelf ( rootKey , ( ( DeweyKey ) pos . getReference ( ) . getTarget ( ) ) ) ; } k = k . replaceAncestorSelf ( rootKey , DeweyKey . ROOT_KEY ) ; int [ ] path = k . deconstruct ( ) ; for ( int i = 0 ; i < path . length ; i ++ ) { int step = path [ i ] ; if ( pos == null || step >= pos . childCount ( ) ) return null ; pos = ( DeweyRefNode ) pos . get ( path [ i ] ) ; if ( pos . isTreeRef ( ) || ( pos . isNodeRef ( ) && i == path . length - 1 ) ) { return ( ( DeweyKey ) pos . getReference ( ) . getTarget ( ) ) . append ( path , i + 1 ) ; } } return null ; } private Key _getFrontKey ( Key bk ) { DeweyKey backKey = ( DeweyKey ) bk ; if ( backKey == null ) return null ; RefTreeNode mappedNode = nodeRefTab . get ( backKey ) ; DeweyKey mapped = mappedNode == null ? null : ( DeweyKey ) nodeRefTab . get ( backKey ) . getId ( ) ; if ( mapped != null ) { assert nodeRefTab . get ( backKey ) . getReference ( ) . getTarget ( ) . equals ( backKey ) ; return mapped ; } DeweyKey origBackKey = backKey ; do { mappedNode = treeRefTab . get ( backKey ) ; DeweyKey mappedKey = mappedNode == null ? null : ( DeweyKey ) mappedNode . getId ( ) ; if ( mappedKey != null ) { assert treeRefTab . get ( backKey ) . getReference ( ) . getTarget ( ) . equals ( backKey ) ; return origBackKey . replaceAncestorSelf ( backKey , mappedKey ) ; } } while ( ( backKey = backKey . up ( ) ) != null ) ; return null ; } } 
=======
public interface ValidationContext { String resolveNamespacePrefix ( String prefix ) ; String getBaseUri ( ) ; boolean isUnparsedEntity ( String entityName ) ; boolean isNotation ( String notationName ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
