<<<<<<< HEAD
public class HTMLSourceEditor extends UnifiedEditor { protected HTMLContributor contributor ; private boolean _isDisposing = false ; private boolean _isMarkingBothTags = false ; private Action tidyAction ; private class ActivationListener implements IPartListener , IWindowListener { private IWorkbenchPart fActivePart ; private boolean fIsHandlingActivation = false ; private IPartService fPartService ; public ActivationListener ( IPartService partService ) { fPartService = partService ; fPartService . addPartListener ( this ) ; PlatformUI . getWorkbench ( ) . addWindowListener ( this ) ; } public void dispose ( ) { fPartService . removePartListener ( this ) ; PlatformUI . getWorkbench ( ) . removeWindowListener ( this ) ; fPartService = null ; } public void partActivated ( IWorkbenchPart part ) { if ( part instanceof HTMLEditor ) { fActivePart = ( ( HTMLEditor ) part ) . getEditor ( ) ; } else { fActivePart = part ; } handleActivation ( ) ; } public void partBroughtToTop ( IWorkbenchPart part ) { } public void partClosed ( IWorkbenchPart part ) { } public void partDeactivated ( IWorkbenchPart part ) { fActivePart = null ; } public void partOpened ( IWorkbenchPart part ) { } private void handleActivation ( ) { if ( fIsHandlingActivation ) return ; if ( fActivePart == HTMLSourceEditor . this ) { fIsHandlingActivation = true ; try { safelySanityCheckState ( getEditorInput ( ) ) ; } finally { fIsHandlingActivation = false ; } } } public void windowActivated ( IWorkbenchWindow window ) { if ( window == getEditorSite ( ) . getWorkbenchWindow ( ) ) { window . getShell ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { handleActivation ( ) ; } } ) ; } } public void windowDeactivated ( IWorkbenchWindow window ) { } public void windowClosed ( IWorkbenchWindow window ) { } public void windowOpened ( IWorkbenchWindow window ) { } } private ActivationListener fActivationListener ; public HTMLSourceEditor ( ) { super ( ) ; addPluginToPreferenceStore ( HTMLPlugin . getDefault ( ) ) ; _isMarkingBothTags = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . HTMLEDITOR_HIGHLIGHT_START_END_TAGS ) ; } public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { super . init ( site , input ) ; fActivationListener = new ActivationListener ( site . getWorkbenchWindow ( ) . getPartService ( ) ) ; } @ Override protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { "com.aptana.ide.editors.UnifiedEditorsScope" , "com.aptana.ide.editors.HTMLEditorScope" } ) ; } protected void createActions ( ) { tidyAction = new Action ( Messages . HTMLSourceEditor_RunHTMLTidy ) { public void run ( ) { PrettyPrintHTML formatter = new PrettyPrintHTML ( ) ; formatter . setActiveEditor ( null , HTMLSourceEditor . this ) ; formatter . run ( ) ; } } ; super . createActions ( ) ; } protected void editorContextMenuAboutToShow ( IMenuManager menu ) { super . editorContextMenuAboutToShow ( menu ) ; menu . add ( tidyAction ) ; } protected IUnifiedEditorContributor createLocalContributor ( ) { this . contributor = new HTMLContributor ( ) ; return this . contributor ; } public IFileServiceFactory getFileServiceFactory ( ) { return HTMLFileServiceFactory . getInstance ( ) ; } public File getTempFile ( ) { IEditorInput in = this . getEditorInput ( ) ; File outFile = null ; if ( in instanceof FileEditorInput ) { IFile file = ( ( FileEditorInput ) this . getEditorInput ( ) ) . getFile ( ) ; IPath path = CoreUIUtils . getPathOfIFileLocation ( file ) ; if ( path != null ) { File f = path . makeAbsolute ( ) . toFile ( ) ; String location = getTempFileLocation ( f , file . getName ( ) ) ; outFile = new File ( location ) ; } } else if ( in instanceof NonExistingFileEditorInput ) { NonExistingFileEditorInput nin = ( NonExistingFileEditorInput ) in ; IPath path = nin . getPath ( nin ) ; String spath = path . toOSString ( ) ; File f = new File ( spath ) ; String location = getTempFileLocation ( f , path . lastSegment ( ) ) ; outFile = new File ( location ) ; } else if ( in instanceof IPathEditorInput ) { IPathEditorInput pin = ( IPathEditorInput ) in ; File path = pin . getPath ( ) . toFile ( ) ; String location = getTempFileLocation ( path , pin . getName ( ) ) ; outFile = new File ( location ) ; } else if ( in instanceof IURIEditorInput ) { URI uri = ( ( IURIEditorInput ) in ) . getURI ( ) ; String location ; if ( "file" . equals ( uri . getScheme ( ) ) ) { location = getTempFileLocation ( new File ( uri ) , Path . fromPortableString ( uri . getPath ( ) ) . lastSegment ( ) ) ; } else { location = getTempFileLocation ( null , Path . fromPortableString ( uri . getPath ( ) ) . lastSegment ( ) ) ; } outFile = new File ( location ) ; } if ( outFile != null ) { outFile . deleteOnExit ( ) ; } return outFile ; } public String getTempFileLocation ( File file , String name ) { if ( file != null ) { file = file . getParentFile ( ) ; } else { try { return File . createTempFile ( ".tmp_" + name , "~" ) . getAbsolutePath ( ) ; } catch ( IOException e ) { return null ; } } return file + File . separator + ".tmp_" + name + "." + ( ( int ) ( Math . random ( ) * 100000 ) ) + "~" ; } public boolean isFileEditorInput ( ) { if ( getEditorInput ( ) instanceof IFileEditorInput || getEditorInput ( ) instanceof IPathEditorInput || getEditorInput ( ) instanceof IURIEditorInput || getEditorInput ( ) instanceof NonExistingFileEditorInput ) { return true ; } return false ; } public String getDefaultFileExtension ( ) { return "html" ; } public void dispose ( ) { if ( _isDisposing ) { return ; } _isDisposing = true ; if ( fActivationListener != null ) { fActivationListener . dispose ( ) ; fActivationListener = null ; } if ( contributor != null ) { contributor . dispose ( ) ; contributor = null ; } super . dispose ( ) ; } protected String [ ] collectContextMenuPreferencePages ( ) { return new String [ ] { "com.aptana.ide.editor.html.preferences.GeneralPreferencePage" , "com.aptana.ide.editor.html.preferences.ColorPizationreferencePage" , "com.aptana.ide.editor.html.preferences.FoldingPreferencePage" , "com.aptana.ide.editor.html.preferences.FormattingPreferencePage" , "com.aptana.ide.editor.html.preferences.PreviewPreferencePage" , "com.aptana.ide.editor.html.preferences.ProblemsPreferencePage" , "com.aptana.ide.editor.html.preferences.CodeAssistPreferencePage" , "com.aptana.ide.editor.html.preferences.TypingPreferencePage" , "com.aptana.ide.editor.html.preferences.TidyPreferencePage" , "org.eclipse.ui.preferencePages.GeneralTextEditor" , "org.eclipse.ui.editors.preferencePages.Annotations" , "org.eclipse.ui.editors.preferencePages.QuickDiff" , "org.eclipse.ui.editors.preferencePages.Accessibility" , "org.eclipse.ui.editors.preferencePages.Spelling" , "org.eclipse.ui.editors.preferencePages.LinkedModePreferencePage" , } ; } protected boolean isNewInput ( IEditorInput input ) { HTMLFileInfo cuInfo = getHTMLFileInfo ( input ) ; if ( cuInfo == null ) { return false ; } HTMLDocumentProvider dp = ( HTMLDocumentProvider ) getDocumentProvider ( ) ; IDocument document = dp . getDocument ( input ) ; DocumentSourceProvider provider = new DocumentSourceProvider ( document , input ) ; if ( provider == null ) { throw new RuntimeException ( Messages . HTMLSourceEditor_Provider_Null ) ; } return ( cuInfo . sourceProvider == null || cuInfo . sourceProvider . equals ( provider ) == false ) ; } private HTMLFileInfo getHTMLFileInfo ( IEditorInput input ) { HTMLDocumentProvider dp = ( HTMLDocumentProvider ) getDocumentProvider ( ) ; if ( dp == null ) { throw new RuntimeException ( Messages . HTMLSourceEditor_Document_Provider_Null ) ; } return ( HTMLFileInfo ) dp . getFileInfoPublic ( input ) ; } protected void updateFileInfo ( IEditorInput input , DocumentSourceProvider provider , IDocument document ) { super . updateFileInfo ( input , provider , document ) ; if ( isNewInput ( input ) ) { getHTMLFileInfo ( input ) . sourceProvider = provider ; } } public IDocumentProvider createDocumentProvider ( ) { return HTMLDocumentProvider . getInstance ( ) ; } public boolean canMarkOccurrences ( Lexeme lexeme ) { IToken token = lexeme . getToken ( ) ; int typeIndex = token . getTypeIndex ( ) ; if ( typeIndex == HTMLTokenTypes . TEXT ) { return false ; } if ( typeIndex == HTMLTokenTypes . START_TAG || typeIndex == HTMLTokenTypes . END_TAG ) { return true ; } return super . canMarkOccurrences ( lexeme ) ; } protected void markOccurences ( LexemeList lexemeList , Lexeme selectedLexeme ) { boolean deferToParent = true ; if ( this . _isMarkingBothTags && ( selectedLexeme . typeIndex == HTMLTokenTypes . START_TAG || selectedLexeme . typeIndex == HTMLTokenTypes . END_TAG ) ) { deferToParent = false ; String selectedText = selectedLexeme . getText ( ) ; String normalizedSelectedText = selectedText ; if ( selectedLexeme . typeIndex == HTMLTokenTypes . END_TAG ) { if ( selectedLexeme . length >= 3 ) { normalizedSelectedText = selectedText . substring ( 0 , 1 ) + selectedText . substring ( 2 ) ; } } for ( int i = 0 ; i < lexemeList . size ( ) ; i ++ ) { Lexeme lexeme = lexemeList . get ( i ) ; if ( lexeme != null ) { if ( lexeme . isHighlighted ( ) ) { lexeme . setHighlighted ( false ) ; } if ( lexeme . typeIndex == HTMLTokenTypes . START_TAG || lexeme . typeIndex == HTMLTokenTypes . END_TAG ) { if ( lexeme . typeIndex == selectedLexeme . typeIndex && lexeme . length == selectedLexeme . length ) { if ( selectedText . equals ( lexeme . getText ( ) ) ) { lexeme . setHighlighted ( true ) ; } } else if ( ( lexeme . length - selectedLexeme . length ) == 1 ) { if ( lexeme . typeIndex == HTMLTokenTypes . END_TAG ) { if ( lexeme . length >= 3 ) { String normalizedText = lexeme . getText ( ) . substring ( 0 , 1 ) + lexeme . getText ( ) . substring ( 2 ) ; if ( normalizedText . equals ( selectedText ) ) { lexeme . setHighlighted ( true ) ; } } } } else if ( ( selectedLexeme . length - lexeme . length ) == 1 ) { if ( normalizedSelectedText . equals ( lexeme . getText ( ) ) ) { lexeme . setHighlighted ( true ) ; } } } } } } if ( deferToParent ) { super . markOccurences ( lexemeList , selectedLexeme ) ; } } protected FileDialogFilterInfo getFileDialogFilterInformation ( String fileName ) { String fileExtension = getFileExtension ( fileName ) ; if ( Messages . HTMLSourceEditor_ExtensionHTM . equals ( fileExtension ) || Messages . HTMLSourceEditor_ExtensionHTML . equals ( fileExtension ) ) { FileDialogFilterInfo filterInfo = new FileDialogFilterInfo ( ) ; filterInfo . setFilterExtensions ( new String [ ] { "*" + Messages . HTMLSourceEditor_ExtensionHTM , "*" + Messages . HTMLSourceEditor_ExtensionHTML , "*" + Messages . HTMLSourceEditor_ExtensionAll } ) ; filterInfo . setFilterNames ( new String [ ] { Messages . HTMLSourceEditor_DescriptionHTM , Messages . HTMLSourceEditor_DescriptionHTML , Messages . HTMLSourceEditor_DescriptionAll } ) ; return filterInfo ; } else { return super . getFileDialogFilterInformation ( fileName ) ; } } protected void handlePreferenceStoreChanged ( PropertyChangeEvent event ) { String property = event . getProperty ( ) ; if ( IPreferenceConstants . HTMLEDITOR_HIGHLIGHT_START_END_TAGS . equals ( property ) ) { _isMarkingBothTags = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . HTMLEDITOR_HIGHLIGHT_START_END_TAGS ) ; } else { super . handlePreferenceStoreChanged ( event ) ; } } } 
=======
public abstract class AbstractUnicodeClassCharacter extends AbstractDatatype { private static final int SURROGATE_OFFSET = 0x10000 - ( 0xD800 << 10 ) - 0xDC00 ; protected abstract UnicodeSet getUnicodeSet ( ) ; @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { switch ( literal . length ( ) ) { case 0 : throw newDatatypeException ( "The empty string is not a " + getName ( ) + "." ) ; case 1 : char c = literal . charAt ( 0 ) ; if ( ! getUnicodeSet ( ) . contains ( c ) ) { throw newDatatypeException ( 0 , "The character " , c , " is not a " + getName ( ) + "." ) ; } return ; case 2 : char hi = literal . charAt ( 0 ) ; char lo = literal . charAt ( 1 ) ; if ( ( lo & 0xFC00 ) == 0xDC00 && ( hi & 0xFC00 ) == 0xD800 ) { int codepoint = ( hi << 10 ) + lo + SURROGATE_OFFSET ; if ( ! getUnicodeSet ( ) . contains ( codepoint ) ) { throw newDatatypeException ( 0 , "The character " , "" + hi + lo , " is not a " + getName ( ) + "." ) ; } return ; } default : throw newDatatypeException ( "A " + getName ( ) + " must be a single character." ) ; } } @ Override public DatatypeStreamingValidator createStreamingValidator ( ValidationContext context ) { return new DatatypeStreamingValidator ( ) { int codepoint = - 2 ; private void addCharacter ( char c ) { if ( codepoint == - 1 ) { return ; } else if ( ( codepoint & 0xFC00 ) == 0xD800 ) { if ( ( c & 0xFC00 ) == 0xDC00 ) { codepoint = ( codepoint << 10 ) + c + SURROGATE_OFFSET ; } else { codepoint = - 1 ; } } else if ( codepoint == - 2 ) { codepoint = c ; } else { codepoint = - 1 ; } } public void addCharacters ( char [ ] buf , int start , int len ) { if ( codepoint == - 1 ) { return ; } else { for ( int i = start ; i < start + len ; i ++ ) { addCharacter ( buf [ i ] ) ; } } } public void checkValid ( ) throws DatatypeException { if ( codepoint == - 2 ) { throw newDatatypeException ( "The empty string is not a " + getName ( ) + "." ) ; } else if ( codepoint == - 1 ) { throw newDatatypeException ( "A " + getName ( ) + " must be a single character." ) ; } else if ( ! getUnicodeSet ( ) . contains ( codepoint ) ) { throw newDatatypeException ( 0 , "The character " , UCharacter . toString ( codepoint ) , " is not a " + getName ( ) + "." ) ; } } public boolean isValid ( ) { try { checkValid ( ) ; return true ; } catch ( DatatypeException e ) { return false ; } } } ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
