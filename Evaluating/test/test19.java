<<<<<<< HEAD
class RevisionNode extends AbstractNode { static final String COLUMN_NAME_NAME = "name" ; static final String COLUMN_NAME_DATE = "date" ; static final String COLUMN_NAME_USERNAME = "username" ; static final String COLUMN_NAME_MESSAGE = "message" ; private RepositoryRevision . Event event ; private RepositoryRevision container ; private String path ; public RevisionNode ( RepositoryRevision container , SearchHistoryPanel master ) { super ( new RevisionNodeChildren ( container , master ) , Lookups . fixed ( master , container ) ) ; this . container = container ; this . event = null ; this . path = null ; setName ( container . getRevision ( ) + NbBundle . getMessage ( RevisionNode . class , "LBL_NumberOfChangedPaths" , 0 ) ) ; initProperties ( ) ; } public RevisionNode ( RepositoryRevision . Event revision , SearchHistoryPanel master ) { super ( Children . LEAF , Lookups . fixed ( master , revision ) ) ; this . path = revision . getChangedPath ( ) . getPath ( ) ; this . event = revision ; setName ( revision . getName ( ) ) ; initProperties ( ) ; } RepositoryRevision . Event getRevision ( ) { return event ; } RepositoryRevision getContainer ( ) { return container ; } RepositoryRevision . Event getEvent ( ) { return event ; } @ Override public String getShortDescription ( ) { return path ; } @ Override public Action [ ] getActions ( boolean context ) { if ( context ) { return null ; } if ( event == null ) { return new Action [ ] { SystemAction . get ( RevertModificationsAction . class ) } ; } else { return new Action [ ] { new RollbackAction ( ) , SystemAction . get ( RevertModificationsAction . class ) } ; } } private void initProperties ( ) { Sheet sheet = Sheet . createDefault ( ) ; Sheet . Set ps = Sheet . createPropertiesSet ( ) ; ps . put ( new DateProperty ( ) ) ; ps . put ( new UsernameProperty ( ) ) ; ps . put ( new MessageProperty ( ) ) ; sheet . put ( ps ) ; setSheet ( sheet ) ; } private abstract class CommitNodeProperty < T > extends PropertySupport . ReadOnly < T > { protected CommitNodeProperty ( String name , Class < T > type , String displayName , String shortDescription ) { super ( name , type , displayName , shortDescription ) ; } @ Override public String toString ( ) { try { return getValue ( ) . toString ( ) ; } catch ( Exception e ) { ErrorManager . getDefault ( ) . notify ( ErrorManager . INFORMATIONAL , e ) ; return e . getLocalizedMessage ( ) ; } } @ Override public PropertyEditor getPropertyEditor ( ) { try { return new RevisionPropertyEditor ( ( String ) getValue ( ) ) ; } catch ( Exception e ) { return super . getPropertyEditor ( ) ; } } } private class UsernameProperty extends CommitNodeProperty { @ SuppressWarnings ( "unchecked" ) public UsernameProperty ( ) { super ( COLUMN_NAME_USERNAME , String . class , COLUMN_NAME_USERNAME , COLUMN_NAME_USERNAME ) ; } public Object getValue ( ) throws IllegalAccessException , InvocationTargetException { if ( event == null ) { return container . getAuthor ( ) ; } else { return "" ; } } } private class DateProperty extends CommitNodeProperty { @ SuppressWarnings ( "unchecked" ) public DateProperty ( ) { super ( COLUMN_NAME_DATE , String . class , COLUMN_NAME_DATE , COLUMN_NAME_DATE ) ; } public Object getValue ( ) throws IllegalAccessException , InvocationTargetException { if ( event == null ) { return DateFormat . getDateTimeInstance ( ) . format ( container . getDate ( ) ) ; } else { return "" ; } } } private class MessageProperty extends CommitNodeProperty { @ SuppressWarnings ( "unchecked" ) public MessageProperty ( ) { super ( COLUMN_NAME_MESSAGE , String . class , COLUMN_NAME_MESSAGE , COLUMN_NAME_MESSAGE ) ; } public Object getValue ( ) throws IllegalAccessException , InvocationTargetException { if ( event == null ) { return container . getMessage ( ) ; } else { return "" ; } } } private class RollbackAction extends AbstractAction { public RollbackAction ( ) { putValue ( Action . NAME , NbBundle . getMessage ( RevisionNode . class , "CTL_Action_RollbackTo" , event . getLogInfoHeader ( ) . getRevision ( ) ) ) ; } public void actionPerformed ( ActionEvent e ) { SummaryView . rollback ( event ) ; } } private static class RevertModificationsAction extends NodeAction { protected void performAction ( Node [ ] activatedNodes ) { Set < RepositoryRevision . Event > events = new HashSet < RepositoryRevision . Event > ( ) ; Set < RepositoryRevision > revisions = new HashSet < RepositoryRevision > ( ) ; for ( Node n : activatedNodes ) { RevisionNode node = ( RevisionNode ) n ; if ( node . event != null ) { events . add ( node . event ) ; } else { revisions . add ( node . container ) ; } } SearchHistoryPanel master = activatedNodes [ 0 ] . getLookup ( ) . lookup ( SearchHistoryPanel . class ) ; SummaryView . revert ( master , revisions . toArray ( new RepositoryRevision [ revisions . size ( ) ] ) , events . toArray ( new RepositoryRevision . Event [ events . size ( ) ] ) ) ; } protected boolean enable ( Node [ ] activatedNodes ) { return true ; } public String getName ( ) { return NbBundle . getMessage ( RevisionNode . class , "CTL_Action_RollbackChange" ) ; } public HelpCtx getHelpCtx ( ) { return new HelpCtx ( RevertModificationsAction . class ) ; } } private static class RevisionPropertyEditor extends PropertyEditorSupport { private static final JLabel renderer = new JLabel ( ) ; static { renderer . setBorder ( BorderFactory . createEmptyBorder ( 0 , 2 , 0 , 2 ) ) ; } public RevisionPropertyEditor ( String value ) { setValue ( value ) ; } @ Override public void paintValue ( Graphics gfx , Rectangle box ) { renderer . setForeground ( gfx . getColor ( ) ) ; renderer . setText ( ( String ) getValue ( ) ) ; renderer . setBounds ( box ) ; renderer . paint ( gfx ) ; } @ Override public boolean isPaintable ( ) { return true ; } } } 
=======
class RegexDatatype extends TokenDatatype { private final String pattern ; private Regex regex ; RegexDatatype ( String pattern ) { this . pattern = pattern ; } synchronized void compile ( RegexEngine engine ) throws RegexSyntaxException { if ( regex == null ) regex = engine . compile ( pattern ) ; } public boolean lexicallyAllows ( String str ) { return regex . matches ( str ) ; } public boolean alwaysValid ( ) { return false ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
