abstract public class StringValue extends Value implements CharSequence { public static final StringValue EMPTY = new ConstStringValue ( "" ) ; protected static final int MIN_LENGTH = 32 ; protected static final int IS_STRING = 0 ; protected static final int IS_LONG = 1 ; protected static final int IS_DOUBLE = 2 ; abstract public StringValue createStringBuilder ( ) ; abstract public StringValue createStringBuilder ( int length ) ; public static Value create ( String value ) { if ( value == null ) return NullValue . NULL ; else return new ConstStringValue ( value ) ; } public static StringValue create ( char value ) { return ConstStringValue . create ( value ) ; } public static Value create ( Object value ) { if ( value == null ) return NullValue . NULL ; else return new StringBuilderValue ( value . toString ( ) ) ; } public StringValue create ( Env env , StringValue unicodeStr , String charset ) { if ( ! unicodeStr . isUnicode ( ) ) return unicodeStr ; try { StringValue sb = createStringBuilder ( ) ; byte [ ] bytes = unicodeStr . toString ( ) . getBytes ( charset ) ; sb . append ( bytes ) ; return sb ; } catch ( UnsupportedEncodingException e ) { env . warning ( e ) ; return unicodeStr ; } } public String getType ( ) { return "string" ; } @ Override public ValueType getValueType ( ) { return ValueType . STRING ; } public boolean isLongConvertible ( ) { return getValueType ( ) . isLongCmp ( ) ; } public boolean isDoubleConvertible ( ) { return getValueType ( ) . isNumberCmp ( ) ; } public boolean isNumber ( ) { return false ; } @ Override public boolean isNumeric ( ) { return getValueType ( ) . isNumberCmp ( ) ; } public boolean isScalar ( ) { return true ; } @ Override public boolean isString ( ) { return true ; } public boolean isPHP5String ( ) { return false ; } @ Override public boolean isEmpty ( ) { return length ( ) == 0 || length ( ) == 1 && charAt ( 0 ) == '0' ; } public int cmp ( Value rValue ) { if ( isNumberConvertible ( ) || rValue . isNumberConvertible ( ) ) { double l = toDouble ( ) ; double r = rValue . toDouble ( ) ; if ( l == r ) return 0 ; else if ( l < r ) return - 1 ; else return 1 ; } else { int result = toString ( ) . compareTo ( rValue . toString ( ) ) ; if ( result == 0 ) return 0 ; else if ( result > 0 ) return 1 ; else return - 1 ; } } @ Override public boolean eq ( Value rValue ) { ValueType typeA = getValueType ( ) ; ValueType typeB = rValue . getValueType ( ) ; if ( typeB . isNumber ( ) ) { double l = toDouble ( ) ; double r = rValue . toDouble ( ) ; return l == r ; } else if ( typeB . isBoolean ( ) ) { return toBoolean ( ) == rValue . toBoolean ( ) ; } else if ( typeA . isNumberCmp ( ) && typeB . isNumberCmp ( ) ) { double l = toDouble ( ) ; double r = rValue . toDouble ( ) ; return l == r ; } else { return toString ( ) . equals ( rValue . toString ( ) ) ; } } public int cmpString ( StringValue rValue ) { return toString ( ) . compareTo ( rValue . toString ( ) ) ; } public StringValue toStringValue ( ) { return this ; } public static long toLong ( String string ) { return parseLong ( string ) ; } static long parseLong ( char [ ] buffer , int offset , int len ) { if ( len == 0 ) return 0 ; long value = 0 ; long sign = 1 ; boolean isResultSet = false ; long result = 0 ; int end = offset + len ; while ( offset < end && Character . isWhitespace ( buffer [ offset ] ) ) { offset ++ ; } int ch ; if ( offset + 1 < end && buffer [ offset ] == '0' && ( ( ch = buffer [ offset + 1 ] ) == 'x' || ch == 'X' ) ) { for ( offset += 2 ; offset < end ; offset ++ ) { ch = buffer [ offset ] & 0xFF ; long oldValue = value ; if ( '0' <= ch && ch <= '9' ) value = value * 16 + ch - '0' ; else if ( 'a' <= ch && ch <= 'z' ) value = value * 16 + ch - 'a' + 10 ; else if ( 'A' <= ch && ch <= 'Z' ) value = value * 16 + ch - 'A' + 10 ; else return value ; if ( value < oldValue ) return Integer . MAX_VALUE ; } return value ; } if ( offset < end && buffer [ offset ] == '-' ) { sign = - 1 ; offset ++ ; } else if ( offset < end && buffer [ offset ] == '+' ) { sign = + 1 ; offset ++ ; } while ( offset < end ) { ch = buffer [ offset ++ ] ; if ( '0' <= ch && ch <= '9' ) { long newValue = 10 * value + ch - '0' ; if ( newValue < value ) { result = Integer . MAX_VALUE ; isResultSet = true ; break ; } value = newValue ; } else { result = sign * value ; isResultSet = true ; break ; } } if ( ! isResultSet ) result = sign * value ; return result ; } static long parseLong ( byte [ ] buffer , int offset , int len ) { if ( len == 0 ) return 0 ; long value = 0 ; long sign = 1 ; boolean isResultSet = false ; long result = 0 ; int end = offset + len ; while ( offset < end && Character . isWhitespace ( buffer [ offset ] ) ) { offset ++ ; } int ch ; if ( offset + 1 < end && buffer [ offset ] == '0' && ( ( ch = buffer [ offset + 1 ] ) == 'x' || ch == 'X' ) ) { for ( offset += 2 ; offset < end ; offset ++ ) { ch = buffer [ offset ] & 0xFF ; long oldValue = value ; if ( '0' <= ch && ch <= '9' ) value = value * 16 + ch - '0' ; else if ( 'a' <= ch && ch <= 'z' ) value = value * 16 + ch - 'a' + 10 ; else if ( 'A' <= ch && ch <= 'Z' ) value = value * 16 + ch - 'A' + 10 ; else return value ; if ( value < oldValue ) return Integer . MAX_VALUE ; } return value ; } if ( offset < end && buffer [ offset ] == '-' ) { sign = - 1 ; offset ++ ; } else if ( offset < end && buffer [ offset ] == '+' ) { sign = + 1 ; offset ++ ; } while ( offset < end ) { ch = buffer [ offset ++ ] ; if ( '0' <= ch && ch <= '9' ) { long newValue = 10 * value + ch - '0' ; if ( newValue < value ) { result = Integer . MAX_VALUE ; isResultSet = true ; break ; } value = newValue ; } else { result = sign * value ; isResultSet = true ; break ; } } if ( ! isResultSet ) result = sign * value ; return result ; } static long parseLong ( CharSequence string ) { final int len = string . length ( ) ; if ( len == 0 ) return 0 ; long value = 0 ; long sign = 1 ; boolean isResultSet = false ; long result = 0 ; int offset = 0 ; int end = offset + len ; while ( offset < end && Character . isWhitespace ( string . charAt ( offset ) ) ) { offset ++ ; } if ( offset < end && string . charAt ( offset ) == '-' ) { sign = - 1 ; offset ++ ; } else if ( offset < end && string . charAt ( offset ) == '+' ) { sign = + 1 ; offset ++ ; } while ( offset < end ) { int ch = string . charAt ( offset ++ ) ; if ( '0' <= ch && ch <= '9' ) { long newValue = 10 * value + ch - '0' ; if ( newValue < value ) { result = Integer . MAX_VALUE ; isResultSet = true ; break ; } value = newValue ; } else { result = sign * value ; isResultSet = true ; break ; } } if ( ! isResultSet ) result = sign * value ; return result ; } public double toDouble ( ) { return toDouble ( toString ( ) ) ; } public static double toDouble ( String s ) { int len = s . length ( ) ; int start = 0 ; int i = 0 ; int ch = 0 ; while ( i < len && Character . isWhitespace ( s . charAt ( i ) ) ) { start ++ ; i ++ ; } if ( i + 1 < len && s . charAt ( i ) == '0' && ( ( ch = s . charAt ( i ) ) == 'x' || ch == 'X' ) ) { double value = 0 ; for ( i += 2 ; i < len ; i ++ ) { ch = s . charAt ( i ) ; if ( '0' <= ch && ch <= '9' ) value = value * 16 + ch - '0' ; else if ( 'a' <= ch && ch <= 'z' ) value = value * 16 + ch - 'a' + 10 ; else if ( 'A' <= ch && ch <= 'Z' ) value = value * 16 + ch - 'A' + 10 ; else return value ; } return value ; } if ( i < len && ( ( ch = s . charAt ( i ) ) == '+' || ch == '-' ) ) { i ++ ; } for ( ; i < len && '0' <= ( ch = s . charAt ( i ) ) && ch <= '9' ; i ++ ) { } if ( ch == '.' ) { for ( i ++ ; i < len && '0' <= ( ch = s . charAt ( i ) ) && ch <= '9' ; i ++ ) { } } if ( ch == 'e' || ch == 'E' ) { int e = i ++ ; if ( i < len && ( ch = s . charAt ( i ) ) == '+' || ch == '-' ) { i ++ ; } for ( ; i < len && '0' <= ( ch = s . charAt ( i ) ) && ch <= '9' ; i ++ ) { } if ( i == e + 1 ) i = e ; } if ( i == 0 ) return 0 ; else if ( i == len && start == 0 ) return Double . parseDouble ( s ) ; else return Double . parseDouble ( s . substring ( start , i ) ) ; } public boolean toBoolean ( ) { int length = length ( ) ; if ( length == 0 ) return false ; else if ( length > 1 ) return true ; else return charAt ( 0 ) != '0' ; } public Value toKey ( ) { int len = length ( ) ; if ( len == 0 ) return this ; int sign = 1 ; long value = 0 ; int i = 0 ; char ch = charAt ( i ) ; if ( ch == '-' ) { sign = - 1 ; i ++ ; } for ( ; i < len ; i ++ ) { ch = charAt ( i ) ; if ( '0' <= ch && ch <= '9' ) value = 10 * value + ch - '0' ; else return this ; } return LongValue . create ( sign * value ) ; } @ Override final public Value toAutoObject ( Env env ) { return env . createObject ( ) ; } public Object toJavaObject ( ) { return toString ( ) ; } @ Override public < T > T [ ] valuesToArray ( Env env , Class < T > elementType ) { if ( char . class . equals ( elementType ) ) { return T [ ] . class . cast ( toUnicodeValue ( env ) . toCharArray ( ) ) ; } else if ( Character . class . equals ( elementType ) ) { char [ ] chars = toUnicodeValue ( env ) . toCharArray ( ) ; int length = chars . length ; Character [ ] charObjects = new Character [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { charObjects [ i ] = Character . valueOf ( chars [ i ] ) ; } return T [ ] . class . cast ( charObjects ) ; } else if ( byte . class . equals ( elementType ) ) { return T [ ] . class . cast ( toBinaryValue ( env ) . toBytes ( ) ) ; } else if ( Byte . class . equals ( elementType ) ) { byte [ ] bytes = toBinaryValue ( env ) . toBytes ( ) ; int length = bytes . length ; Byte [ ] byteObjects = new Byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { byteObjects [ i ] = Byte . valueOf ( bytes [ i ] ) ; } return T [ ] . class . cast ( byteObjects ) ; } else { env . error ( L . l ( "Can't assign {0} with type {1} to {2}" , this , this . getClass ( ) , elementType ) ) ; return null ; } } public Value toAutoArray ( ) { if ( length ( ) == 0 ) return new ArrayValueImpl ( ) ; else return this ; } public Value append ( Value index , Value value ) { if ( length ( ) == 0 ) return new ArrayValueImpl ( ) . append ( index , value ) ; else return this ; } public Value get ( Value key ) { return charValueAt ( key . toLong ( ) ) ; } public Value getArg ( Value key , boolean isTop ) { return charValueAt ( key . toLong ( ) ) ; } @ Override public Value charValueAt ( long index ) { int len = length ( ) ; if ( index < 0 || len <= index ) return UnsetUnicodeValue . UNSET ; else { return StringValue . create ( charAt ( ( int ) index ) ) ; } } @ Override public Value setCharValueAt ( long index , Value value ) { int len = length ( ) ; if ( index < 0 || len <= index ) return this ; else { return ( createStringBuilder ( ) . append ( this , 0 , ( int ) index ) . append ( value ) . append ( this , ( int ) ( index + 1 ) , length ( ) ) ) ; } } @ Override public Value increment ( int incr ) { if ( length ( ) == 0 ) { if ( incr == 1 ) return createStringBuilder ( ) . append ( "1" ) ; else return LongValue . MINUS_ONE ; } if ( incr > 0 ) { StringBuilder tail = new StringBuilder ( ) ; for ( int i = length ( ) - 1 ; i >= 0 ; i -- ) { char ch = charAt ( i ) ; if ( ch == 'z' ) { if ( i == 0 ) return createStringBuilder ( ) . append ( "aa" ) . append ( tail ) ; else tail . insert ( 0 , 'a' ) ; } else if ( 'a' <= ch && ch < 'z' ) { return ( createStringBuilder ( ) . append ( this , 0 , i ) . append ( ( char ) ( ch + 1 ) ) . append ( tail ) ) ; } else if ( ch == 'Z' ) { if ( i == 0 ) return createStringBuilder ( ) . append ( "AA" ) . append ( tail ) ; else tail . insert ( 0 , 'A' ) ; } else if ( 'A' <= ch && ch < 'Z' ) { return ( createStringBuilder ( ) . append ( this , 0 , i ) . append ( ( char ) ( ch + 1 ) ) . append ( tail ) ) ; } else if ( '0' <= ch && ch <= '9' && i == length ( ) - 1 ) { return LongValue . create ( toLong ( ) + incr ) ; } } return createStringBuilder ( ) . append ( tail . toString ( ) ) ; } else if ( getValueType ( ) . isLongAdd ( ) ) { return LongValue . create ( toLong ( ) + incr ) ; } else { return this ; } } public Value add ( long rValue ) { if ( getValueType ( ) . isLongAdd ( ) ) return LongValue . create ( toLong ( ) + rValue ) ; return DoubleValue . create ( toDouble ( ) + rValue ) ; } public Value sub ( long rValue ) { if ( getValueType ( ) . isLongAdd ( ) ) return LongValue . create ( toLong ( ) - rValue ) ; return DoubleValue . create ( toDouble ( ) - rValue ) ; } @ Override public Value bitAnd ( Value rValue ) { if ( rValue . isString ( ) ) { StringValue rStr = ( StringValue ) rValue ; int len = Math . min ( length ( ) , rValue . length ( ) ) ; StringValue sb = createStringBuilder ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char l = charAt ( i ) ; char r = rStr . charAt ( i ) ; sb . appendByte ( l & r ) ; } return sb ; } else return LongValue . create ( toLong ( ) & rValue . toLong ( ) ) ; } @ Override public Value bitOr ( Value rValue ) { if ( rValue . isString ( ) ) { StringValue rStr = ( StringValue ) rValue ; int len = Math . min ( length ( ) , rValue . length ( ) ) ; StringValue sb = createStringBuilder ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char l = charAt ( i ) ; char r = rStr . charAt ( i ) ; sb . appendByte ( l | r ) ; } if ( len != length ( ) ) sb . append ( substring ( len ) ) ; else if ( len != rStr . length ( ) ) sb . append ( rStr . substring ( len ) ) ; return sb ; } else return LongValue . create ( toLong ( ) | rValue . toLong ( ) ) ; } @ Override public Value bitXor ( Value rValue ) { if ( rValue . isString ( ) ) { StringValue rStr = ( StringValue ) rValue ; int len = Math . min ( length ( ) , rValue . length ( ) ) ; StringValue sb = createStringBuilder ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char l = charAt ( i ) ; char r = rStr . charAt ( i ) ; sb . appendByte ( l ^ r ) ; } return sb ; } else return LongValue . create ( toLong ( ) ^ rValue . toLong ( ) ) ; } @ Override public void serialize ( Env env , StringBuilder sb ) { sb . append ( "s:" ) ; sb . append ( length ( ) ) ; sb . append ( ":\"" ) ; sb . append ( toString ( ) ) ; sb . append ( "\";" ) ; } public StringValue append ( String s ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( String s , int start , int end ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( char [ ] buf , int offset , int length ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( char [ ] buf ) { return append ( buf , 0 , buf . length ) ; } public StringValue append ( CharSequence buf , int head , int tail ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( UnicodeBuilderValue sb , int head , int tail ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( Env env , StringValue unicodeStr , String charset ) { if ( ! unicodeStr . isUnicode ( ) ) return append ( unicodeStr ) ; try { byte [ ] bytes = unicodeStr . toString ( ) . getBytes ( charset ) ; append ( bytes ) ; return this ; } catch ( UnsupportedEncodingException e ) { env . warning ( e ) ; return append ( unicodeStr ) ; } } public StringValue append ( char v ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( boolean v ) { return append ( v ? "true" : "false" ) ; } public StringValue append ( long v ) { return append ( String . valueOf ( v ) ) ; } public StringValue append ( double v ) { return append ( String . valueOf ( v ) ) ; } public StringValue append ( Object v ) { return append ( String . valueOf ( v ) ) ; } public StringValue append ( Value v ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public void ensureAppendCapacity ( int size ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( byte [ ] buf , int offset , int length ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue append ( byte [ ] buf ) { return append ( buf , 0 , buf . length ) ; } public StringValue appendUtf8 ( byte [ ] buf , int offset , int length ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue appendUtf8 ( byte [ ] buf ) { return appendUtf8 ( buf , 0 , buf . length ) ; } @ Override public StringValue appendTo ( UnicodeBuilderValue sb ) { int length = length ( ) ; for ( int i = 0 ; i < length ; i ++ ) sb . append ( charAt ( i ) ) ; return this ; } public StringValue appendUnicode ( boolean v ) { return append ( v ? "true" : "false" ) ; } public StringValue appendUnicode ( long v ) { return append ( String . valueOf ( v ) ) ; } public StringValue appendUnicode ( double v ) { return append ( String . valueOf ( v ) ) ; } public StringValue appendUnicode ( Object v ) { return append ( String . valueOf ( v ) ) ; } public StringValue appendUnicode ( char v ) { return append ( v ) ; } public StringValue appendUnicode ( char [ ] buffer , int offset , int length ) { return append ( buffer , offset , length ) ; } public StringValue appendUnicode ( char [ ] buffer ) { return append ( buffer ) ; } public StringValue appendUnicode ( String value ) { return append ( value ) ; } public StringValue appendUnicode ( String value , int offset , int length ) { return append ( value , offset , length ) ; } public StringValue appendUnicode ( Value value ) { return append ( value ) ; } public StringValue appendUnicode ( Value v1 , Value v2 ) { return append ( v1 ) . append ( v2 ) ; } public StringValue appendByte ( int v ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public StringValue appendBytes ( String s ) { StringValue sb = this ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sb = sb . appendByte ( s . charAt ( i ) ) ; } return sb ; } public StringValue appendBytes ( StringValue s ) { StringValue sb = this ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sb = sb . appendByte ( s . charAt ( i ) ) ; } return sb ; } public StringValue appendBytes ( char [ ] buf , int offset , int length ) { StringValue sb = this ; int end = Math . min ( buf . length , offset + length ) ; while ( offset < end ) { sb = sb . appendByte ( buf [ offset ++ ] ) ; } return sb ; } public StringValue appendBytes ( byte [ ] bytes , int offset , int end ) { StringValue sb = this ; while ( offset < end ) { sb = sb . appendByte ( bytes [ offset ++ ] ) ; } return sb ; } public StringValue append ( Reader reader ) throws IOException { int ch ; while ( ( ch = reader . read ( ) ) >= 0 ) { append ( ( char ) ch ) ; } return this ; } public StringValue append ( Reader reader , long length ) throws IOException { int ch ; while ( length -- > 0 && ( ch = reader . read ( ) ) >= 0 ) { append ( ( char ) ch ) ; } return this ; } public int appendRead ( InputStream is , long length ) { TempBuffer tBuf = TempBuffer . allocate ( ) ; try { byte [ ] buffer = tBuf . getBuffer ( ) ; int sublen = buffer . length ; if ( length < sublen ) sublen = ( int ) length ; sublen = is . read ( buffer , 0 , sublen ) ; if ( sublen > 0 ) append ( buffer , 0 , sublen ) ; return sublen ; } catch ( IOException e ) { throw new QuercusModuleException ( e ) ; } finally { TempBuffer . free ( tBuf ) ; } } public int appendReadAll ( InputStream is , long length ) { TempBuffer tBuf = TempBuffer . allocate ( ) ; try { byte [ ] buffer = tBuf . getBuffer ( ) ; int readLength = 0 ; while ( length > 0 ) { int sublen = buffer . length ; if ( length < sublen ) sublen = ( int ) length ; sublen = is . read ( buffer , 0 , sublen ) ; if ( sublen > 0 ) { append ( buffer , 0 , sublen ) ; length -= sublen ; readLength += sublen ; } else return readLength > 0 ? readLength : - 1 ; } return readLength ; } catch ( IOException e ) { throw new QuercusModuleException ( e ) ; } finally { TempBuffer . free ( tBuf ) ; } } public int appendRead ( BinaryInput is , long length ) { TempBuffer tBuf = TempBuffer . allocate ( ) ; try { byte [ ] buffer = tBuf . getBuffer ( ) ; int sublen = buffer . length ; if ( length < sublen ) sublen = ( int ) length ; else if ( length > sublen ) { buffer = new byte [ ( int ) length ] ; sublen = ( int ) length ; } sublen = is . read ( buffer , 0 , sublen ) ; if ( sublen > 0 ) append ( buffer , 0 , sublen ) ; return sublen ; } catch ( IOException e ) { throw new QuercusModuleException ( e ) ; } finally { TempBuffer . free ( tBuf ) ; } } public int appendReadAll ( BinaryInput is , long length ) { TempBuffer tBuf = TempBuffer . allocate ( ) ; try { byte [ ] buffer = tBuf . getBuffer ( ) ; int readLength = 0 ; while ( length > 0 ) { int sublen = buffer . length ; if ( length < sublen ) sublen = ( int ) length ; sublen = is . read ( buffer , 0 , sublen ) ; if ( sublen > 0 ) { append ( buffer , 0 , sublen ) ; length -= sublen ; readLength += sublen ; } else return readLength > 0 ? readLength : - 1 ; } return readLength ; } catch ( IOException e ) { throw new QuercusModuleException ( e ) ; } finally { TempBuffer . free ( tBuf ) ; } } @ Override public void varExport ( StringBuilder sb ) { sb . append ( "'" ) ; String value = toString ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char ch = value . charAt ( i ) ; switch ( ch ) { case '\'' : sb . append ( "\\'" ) ; break ; case '\\' : sb . append ( "\\\\" ) ; break ; default : sb . append ( ch ) ; } } sb . append ( "'" ) ; } public int length ( ) { return toString ( ) . length ( ) ; } public char charAt ( int index ) { return toString ( ) . charAt ( index ) ; } public CharSequence subSequence ( int start , int end ) { return new StringBuilderValue ( toString ( ) . substring ( start , end ) ) ; } public final int indexOf ( CharSequence match ) { return indexOf ( match , 0 ) ; } public int indexOf ( CharSequence match , int head ) { int length = length ( ) ; int matchLength = match . length ( ) ; if ( matchLength <= 0 ) return - 1 ; else if ( head < 0 ) return - 1 ; int end = length - matchLength ; char first = match . charAt ( 0 ) ; loop : for ( ; head <= end ; head ++ ) { if ( charAt ( head ) != first ) continue ; for ( int i = 1 ; i < matchLength ; i ++ ) { if ( charAt ( head + i ) != match . charAt ( i ) ) continue loop ; } return head ; } return - 1 ; } public int indexOf ( char match ) { return indexOf ( match , 0 ) ; } public int indexOf ( char match , int head ) { int length = length ( ) ; for ( ; head < length ; head ++ ) { if ( charAt ( head ) == match ) return head ; } return - 1 ; } public final int lastIndexOf ( char match ) { return lastIndexOf ( match , Integer . MAX_VALUE ) ; } public int lastIndexOf ( char match , int tail ) { int length = length ( ) ; if ( tail >= length ) tail = length - 1 ; for ( ; tail >= 0 ; tail -- ) { if ( charAt ( tail ) == match ) return tail ; } return - 1 ; } public int lastIndexOf ( CharSequence match ) { return lastIndexOf ( match , Integer . MAX_VALUE ) ; } public int lastIndexOf ( CharSequence match , int tail ) { int length = length ( ) ; int matchLength = match . length ( ) ; if ( matchLength <= 0 ) return - 1 ; if ( tail < 0 ) return - 1 ; if ( tail > length - matchLength ) tail = length - matchLength ; char first = match . charAt ( 0 ) ; loop : for ( ; tail >= 0 ; tail -- ) { if ( charAt ( tail ) != first ) continue ; for ( int i = 1 ; i < matchLength ; i ++ ) { if ( charAt ( tail + i ) != match . charAt ( i ) ) continue loop ; } return tail ; } return - 1 ; } public boolean regionMatches ( int offset , char [ ] mBuffer , int mOffset , int mLength ) { int length = length ( ) ; if ( length < offset + mLength ) return false ; for ( int i = 0 ; i < mLength ; i ++ ) { if ( charAt ( offset + i ) != mBuffer [ mOffset + i ] ) return false ; } return true ; } public boolean regionMatches ( int offset , StringValue match , int mOffset , int mLength ) { int length = length ( ) ; if ( length < offset + mLength ) return false ; for ( int i = 0 ; i < mLength ; i ++ ) { if ( charAt ( offset + i ) != match . charAt ( mOffset + i ) ) return false ; } return true ; } public boolean regionMatchesIgnoreCase ( int offset , char [ ] match , int mOffset , int mLength ) { int length = length ( ) ; if ( length < offset + mLength ) return false ; for ( int i = 0 ; i < mLength ; i ++ ) { char a = Character . toLowerCase ( charAt ( offset + i ) ) ; char b = Character . toLowerCase ( match [ mOffset + i ] ) ; if ( a != b ) return false ; } return true ; } public boolean endsWith ( StringValue tail ) { int len = length ( ) ; int tailLen = tail . length ( ) ; int offset = len - tailLen ; if ( offset < 0 ) return false ; for ( int i = 0 ; i < tailLen ; i ++ ) { if ( charAt ( offset + i ) != tail . charAt ( i ) ) return false ; } return true ; } public StringValue substring ( int head ) { return ( StringValue ) subSequence ( head , length ( ) ) ; } public StringValue substring ( int begin , int end ) { return ( StringValue ) subSequence ( begin , end ) ; } public String stringSubstring ( int begin , int end ) { return substring ( begin , end ) . toString ( ) ; } public char [ ] toCharArray ( ) { int length = length ( ) ; char [ ] array = new char [ length ( ) ] ; getChars ( 0 , array , 0 , length ) ; return array ; } public char [ ] getRawCharArray ( ) { return toCharArray ( ) ; } public void getChars ( int stringOffset , char [ ] buffer , int offset , int length ) { for ( int i = 0 ; i < length ; i ++ ) buffer [ offset + i ] = charAt ( stringOffset + i ) ; } public StringValue toLowerCase ( ) { int length = length ( ) ; UnicodeBuilderValue string = new UnicodeBuilderValue ( length ) ; char [ ] buffer = string . getBuffer ( ) ; getChars ( 0 , buffer , 0 , length ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = buffer [ i ] ; if ( 'A' <= ch && ch <= 'Z' ) buffer [ i ] = ( char ) ( ch + 'a' - 'A' ) ; else if ( ch < 0x80 ) { } else if ( Character . isUpperCase ( ch ) ) buffer [ i ] = Character . toLowerCase ( ch ) ; } string . setOffset ( length ) ; return string ; } public StringValue toUpperCase ( ) { int length = length ( ) ; UnicodeBuilderValue string = new UnicodeBuilderValue ( length ) ; char [ ] buffer = string . getBuffer ( ) ; getChars ( 0 , buffer , 0 , length ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = buffer [ i ] ; if ( 'a' <= ch && ch <= 'z' ) buffer [ i ] = ( char ) ( ch + 'A' - 'a' ) ; else if ( ch < 0x80 ) { } else if ( Character . isLowerCase ( ch ) ) buffer [ i ] = Character . toUpperCase ( ch ) ; } string . setOffset ( length ) ; return string ; } public InputStream toInputStream ( ) { try { return toInputStream ( Env . getInstance ( ) . getRuntimeEncoding ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new QuercusRuntimeException ( e ) ; } } public InputStream toInputStream ( String charset ) throws UnsupportedEncodingException { return new ByteArrayInputStream ( toString ( ) . getBytes ( charset ) ) ; } public Reader toReader ( String charset ) throws UnsupportedEncodingException { byte [ ] bytes = toBytes ( ) ; return new InputStreamReader ( new ByteArrayInputStream ( bytes ) , charset ) ; } public byte [ ] toBytes ( ) { throw new UnsupportedOperationException ( ) ; } public StringValue toUnicodeValue ( Env env , String charset ) { StringValue sb = env . createUnicodeBuilder ( ) ; Decoder decoder = Decoder . create ( charset ) ; sb . append ( decoder . decode ( env , this ) ) ; return sb ; } public StringValue convertToUnicode ( Env env , String charset ) { UnicodeBuilderValue sb = new UnicodeBuilderValue ( ) ; Decoder decoder = Decoder . create ( charset ) ; decoder . setAllowMalformedOut ( true ) ; sb . append ( decoder . decode ( env , this ) ) ; return sb ; } @ Override public StringValue toStringBuilder ( Env env ) { return createStringBuilder ( ) . append ( this ) ; } public void writeTo ( OutputStream os ) { try { int len = length ( ) ; for ( int i = 0 ; i < len ; i ++ ) os . write ( charAt ( i ) ) ; } catch ( IOException e ) { throw new QuercusModuleException ( e ) ; } } public int hashCode ( ) { int hash = 37 ; int length = length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { hash = 65521 * hash + charAt ( i ) ; } return hash ; } public boolean equals ( Object o ) { if ( this == o ) return true ; else if ( ! ( o instanceof StringValue ) ) return false ; StringValue s = ( StringValue ) o ; if ( s . isUnicode ( ) != isUnicode ( ) ) return false ; int aLength = length ( ) ; int bLength = s . length ( ) ; if ( aLength != bLength ) return false ; for ( int i = aLength - 1 ; i >= 0 ; i -- ) { if ( charAt ( i ) != s . charAt ( i ) ) return false ; } return true ; } @ Override public void generate ( PrintWriter out ) throws IOException { int maxSublen = 0xFFFE ; int len = length ( ) ; String className = getClass ( ) . getSimpleName ( ) ; if ( len == 1 ) { out . print ( className + ".create('" ) ; printJavaChar ( out , charAt ( 0 ) ) ; out . print ( "')" ) ; } else if ( len < maxSublen ) { out . print ( "new " + className + "(\"" ) ; printJavaString ( out , this ) ; out . print ( "\")" ) ; } else { out . print ( "((" + className + ") (new " + className + "(\"" ) ; for ( int i = 0 ; i < len ; i += maxSublen ) { if ( i != 0 ) out . print ( "\").append(\"" ) ; printJavaString ( out , substring ( i , Math . min ( i + maxSublen , len ) ) ) ; } out . print ( "\")))" ) ; } } @ Override abstract public String toDebugString ( ) ; @ Override abstract public void varDumpImpl ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException ; class StringValueInputStream extends java . io . InputStream { private final int _length ; private int _index ; StringValueInputStream ( ) { _length = length ( ) ; } public int read ( ) { if ( _index < _length ) return charAt ( _index ++ ) ; else return - 1 ; } public int read ( byte [ ] buffer , int offset , int length ) { int sublen = _length - _index ; if ( length < sublen ) sublen = length ; if ( sublen <= 0 ) return - 1 ; int index = _index ; for ( int i = 0 ; i < sublen ; i ++ ) buffer [ offset + i ] = ( byte ) charAt ( index + i ) ; _index += sublen ; return sublen ; } } } 