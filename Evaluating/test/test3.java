<<<<<<< HEAD
public class AuthThread extends SpyThread { public static final int AUTH_ROUNDTRIP_THRESHOLD = 250 ; public static final int AUTH_TOTAL_THRESHOLD = 1000 ; public static final String MECH_SEPARATOR = " " ; private final MemcachedConnection conn ; private final AuthDescriptor authDescriptor ; private final OperationFactory opFact ; private final MemcachedNode node ; public AuthThread ( MemcachedConnection c , OperationFactory o , AuthDescriptor a , MemcachedNode n ) { conn = c ; opFact = o ; authDescriptor = a ; node = n ; start ( ) ; } protected String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( "Received SASL supported mechs: " + status . getMessage ( ) ) ; } else { getLogger ( ) . warn ( "Received non-success response for SASL mechs: " + status ) ; } } @ Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; try { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( true ) ; } } catch ( InterruptedException ex ) { getLogger ( ) . warn ( "Interrupted in Auth while waiting for SASL mechs." ) ; Thread . currentThread ( ) . interrupt ( ) ; if ( listMechsOp != null ) { listMechsOp . cancel ( ) ; } done . set ( true ) ; } String supported = supportedMechs . get ( ) ; if ( supported == null || supported . isEmpty ( ) ) { return null ; } return supported . split ( MECH_SEPARATOR ) ; } @ Override public void run ( ) { final AtomicBoolean done = new AtomicBoolean ( ) ; long totalStart = System . nanoTime ( ) ; String [ ] supportedMechs ; long mechsStart = System . nanoTime ( ) ; if ( authDescriptor . getMechs ( ) == null || authDescriptor . getMechs ( ) . length == 0 ) { supportedMechs = listSupportedSASLMechanisms ( done ) ; } else { supportedMechs = authDescriptor . getMechs ( ) ; } long mechsDiff = TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - mechsStart ) ; String msg = String . format ( "SASL List Mechanisms took %dms on %s" , mechsDiff , node . toString ( ) ) ; Level level = mechsDiff >= AUTH_ROUNDTRIP_THRESHOLD ? Level . WARN : Level . DEBUG ; getLogger ( ) . log ( level , msg ) ; if ( supportedMechs == null || supportedMechs . length == 0 ) { getLogger ( ) . warn ( "Authentication failed to " + node . getSocketAddress ( ) + ", got empty SASL auth mech list." ) ; throw new IllegalStateException ( "Got empty SASL auth mech list." ) ; } OperationStatus priorStatus = null ; while ( ! done . get ( ) ) { long stepStart = System . nanoTime ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < OperationStatus > foundStatus = new AtomicReference < OperationStatus > ( ) ; final OperationCallback cb = new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus val ) { if ( val . getMessage ( ) . length ( ) == 0 ) { done . set ( true ) ; node . authComplete ( ) ; getLogger ( ) . info ( "Authenticated to " + node . getSocketAddress ( ) ) ; } else { foundStatus . set ( val ) ; } } @ Override public void complete ( ) { latch . countDown ( ) ; } } ; final Operation op = buildOperation ( priorStatus , cb , supportedMechs ) ; conn . insertOperation ( node , op ) ; try { if ( ! conn . isShutDown ( ) ) { latch . await ( ) ; } else { done . set ( true ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; if ( op != null ) { op . cancel ( ) ; } done . set ( true ) ; } finally { long stepDiff = TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - stepStart ) ; msg = String . format ( "SASL Step took %dms on %s" , stepDiff , node . toString ( ) ) ; level = mechsDiff >= AUTH_ROUNDTRIP_THRESHOLD ? Level . WARN : Level . DEBUG ; getLogger ( ) . log ( level , msg ) ; } priorStatus = foundStatus . get ( ) ; if ( priorStatus != null ) { if ( ! priorStatus . isSuccess ( ) ) { getLogger ( ) . warn ( "Authentication failed to " + node . getSocketAddress ( ) + ", Status: " + priorStatus ) ; } } } long totalDiff = TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - totalStart ) ; msg = String . format ( "SASL Auth took %dms on %s" , totalDiff , node . toString ( ) ) ; level = mechsDiff >= AUTH_TOTAL_THRESHOLD ? Level . WARN : Level . DEBUG ; getLogger ( ) . log ( level , msg ) ; } private Operation buildOperation ( OperationStatus st , OperationCallback cb , final String [ ] supportedMechs ) { if ( st == null ) { return opFact . saslAuth ( supportedMechs , node . getSocketAddress ( ) . toString ( ) , null , authDescriptor . getCallback ( ) , cb ) ; } else { return opFact . saslStep ( supportedMechs , KeyUtil . getKeyBytes ( st . getMessage ( ) ) , node . getSocketAddress ( ) . toString ( ) , null , authDescriptor . getCallback ( ) , cb ) ; } } } 
=======
class LengthRestrictDatatype extends ValueRestrictDatatype { private final int length ; private final Measure measure ; LengthRestrictDatatype ( DatatypeBase base , int length ) { super ( base ) ; this . measure = base . getMeasure ( ) ; this . length = length ; } void checkRestriction ( Object obj ) throws DatatypeException { int actualLength = measure . getLength ( obj ) ; if ( actualLength != length ) throw new DatatypeException ( localizer ( ) . message ( "length_violation" , new Object [ ] { getDescriptionForRestriction ( ) , length , actualLength } ) ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
