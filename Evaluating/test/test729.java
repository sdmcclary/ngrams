<<<<<<< HEAD
public class StringUtils { public static final String LINE_DELIMITER = System . getProperty ( "line.separator" , "\r\n" ) ; public static final String BULLET = "â€¢ " ; public static final String EMPTY = "" ; public static final String SPACE = " " ; public static final String COLON = ":" ; protected StringUtils ( ) { } public static String join ( String delimiter , String [ ] items ) { if ( items == null ) { return null ; } int length = items . length ; String result = StringUtils . EMPTY ; if ( length > 0 ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < length - 1 ; i ++ ) { sb . append ( items [ i ] ) . append ( delimiter ) ; } sb . append ( items [ length - 1 ] ) ; result = sb . toString ( ) ; } return result ; } public static String stripHTML ( String text ) { if ( text == null ) { return null ; } String tempText = text . replaceAll ( "<p>" , "\n" ) ; return tempText . replaceAll ( "\\<.*?\\>" , StringUtils . EMPTY ) ; } public static String urlEncodeForSpaces ( char [ ] input ) { if ( input == null ) { return null ; } StringBuffer retu = new StringBuffer ( input . length ) ; for ( int i = 0 ; i < input . length ; i ++ ) { if ( input [ i ] == ' ' ) { retu . append ( "%20" ) ; } else { retu . append ( input [ i ] ) ; } } return retu . toString ( ) ; } public static String urlEncodeFilename ( char [ ] input ) { if ( input == null ) { return null ; } StringBuffer retu = new StringBuffer ( input . length ) ; for ( int i = 0 ; i < input . length ; i ++ ) { if ( input [ i ] == ' ' ) { retu . append ( "%20" ) ; } else if ( input [ i ] == '[' ) { retu . append ( "%5B" ) ; } else if ( input [ i ] == ']' ) { retu . append ( "%5D" ) ; } else if ( input [ i ] == '{' ) { retu . append ( "%7B" ) ; } else if ( input [ i ] == '}' ) { retu . append ( "%7D" ) ; } else if ( input [ i ] == '`' ) { retu . append ( "%60" ) ; } else if ( input [ i ] == '+' ) { retu . append ( "%2B" ) ; } else { retu . append ( input [ i ] ) ; } } return retu . toString ( ) ; } public static String stripCarriageReturns ( String text ) { if ( text == null ) { return null ; } return text . replaceAll ( "\n" , StringUtils . EMPTY ) ; } public static String stripWhitespace ( String text ) { if ( text == null ) { return null ; } return text . replaceAll ( "\\s+" , " " ) ; } public static String formatAsPlainText ( String text ) { String tempText = StringUtils . stripCarriageReturns ( text ) ; tempText = StringUtils . stripWhitespace ( tempText ) ; tempText = StringUtils . replace ( tempText , "</li>" , StringUtils . EMPTY ) ; tempText = StringUtils . replace ( tempText , "<li>" , LINE_DELIMITER + "\t" + BULLET ) ; tempText = StringUtils . replace ( tempText , "<p>" , LINE_DELIMITER ) ; tempText = StringUtils . stripHTML ( tempText ) ; return tempText . trim ( ) ; } public static String trimStringQuotes ( String stringToTrim ) { if ( stringToTrim == null ) { return null ; } String trimmed = stringToTrim . trim ( ) ; if ( trimmed . startsWith ( "\"" ) || trimmed . startsWith ( "'" ) ) { trimmed = trimmed . substring ( 1 ) ; } if ( trimmed . endsWith ( "\"" ) || trimmed . endsWith ( "'" ) ) { trimmed = trimmed . substring ( 0 , trimmed . length ( ) - 1 ) ; } return trimmed ; } public static String trimBrackets ( String stringToTrim ) { if ( stringToTrim == null ) { return null ; } String trimmed = stringToTrim . trim ( ) ; if ( trimmed . startsWith ( "[" ) ) { trimmed = trimmed . substring ( 1 ) ; } if ( trimmed . endsWith ( "]" ) ) { trimmed = trimmed . substring ( 0 , trimmed . length ( ) - 1 ) ; } return trimmed ; } public static String replace ( String str , String pattern , String replace ) { int s = 0 ; int e = 0 ; StringBuffer result = new StringBuffer ( ) ; while ( ( e = str . indexOf ( pattern , s ) ) >= 0 ) { result . append ( str . substring ( s , e ) ) ; result . append ( replace ) ; s = e + pattern . length ( ) ; } result . append ( str . substring ( s ) ) ; return result . toString ( ) ; } public static String format ( String str , long replacement ) { return MessageFormat . format ( str , new Object [ ] { new Long ( replacement ) } ) ; } public static String format ( String str , int replacement ) { return MessageFormat . format ( str , new Object [ ] { new Integer ( replacement ) } ) ; } public static String format ( String str , String replacement ) { return MessageFormat . format ( str , new Object [ ] { replacement } ) ; } public static String format ( String str , Object replacement ) { return MessageFormat . format ( str , new Object [ ] { replacement . toString ( ) } ) ; } public static String format ( String str , Object [ ] replacements ) { return MessageFormat . format ( str , replacements ) ; } public static String ellipsify ( String message ) { return message + "..." ; } public static String makeFormLabel ( String message ) { return message + COLON ; } public static String convertWildcardExpressionToRegex ( String wildcardExpression , boolean caseInsensitive ) { if ( wildcardExpression == null ) { return null ; } if ( wildcardExpression . startsWith ( "/" ) && wildcardExpression . endsWith ( "/" ) ) { return wildcardExpression . substring ( 1 , wildcardExpression . length ( ) - 1 ) ; } String string = wildcardExpression . replaceAll ( "\\.(?=[^\\*])" , "\\\\." ) ; string = string . replaceAll ( "\\*" , ".*" ) ; if ( caseInsensitive ) { string = "(?i)" + string ; } return string ; } } 
=======
public class EhcacheTokenStore implements TokenStore { private BlockingCache cache ; public void setCache ( Ehcache cache ) { BlockingCache ref ; if ( ! ( cache instanceof BlockingCache ) ) { ref = new BlockingCache ( cache ) ; cache . getCacheManager ( ) . replaceCacheWithDecoratedCache ( cache , new BlockingCache ( cache ) ) ; } else { ref = ( BlockingCache ) cache ; } this . cache = ref ; } public StoreEntry create ( Key key , int timeToLive ) { StoreEntryImpl result = new StoreEntryImpl ( timeToLive ) ; Element element = new Element ( key , result ) ; element . setTimeToLive ( timeToLive ) ; cache . put ( element ) ; return result ; } public StoreEntry get ( Key key ) { Element entry = null ; try { entry = cache . get ( key ) ; } catch ( LockTimeoutException e ) { throw new RuntimeException ( ) ; } catch ( RuntimeException e ) { cache . put ( new Element ( key , null ) ) ; } StoreEntry result = null ; if ( entry != null ) { result = ( StoreEntry ) entry . getObjectValue ( ) ; } return result ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
