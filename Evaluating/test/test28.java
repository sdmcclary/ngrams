<<<<<<< HEAD
public class HtmlFormatter { private static MessageFormat uptodateFormat = getFormat ( "uptodateFormat" ) ; private static MessageFormat newLocallyFormat = getFormat ( "newLocallyFormat" ) ; private static MessageFormat addedLocallyFormat = getFormat ( "addedLocallyFormat" ) ; private static MessageFormat modifiedLocallyFormat = getFormat ( "modifiedLocallyFormat" ) ; private static MessageFormat removedLocallyFormat = getFormat ( "removedLocallyFormat" ) ; private static MessageFormat deletedLocallyFormat = getFormat ( "deletedLocallyFormat" ) ; private static MessageFormat excludedFormat = getFormat ( "excludedFormat" ) ; private static MessageFormat conflictFormat = getFormat ( "conflictFormat" ) ; private static final int STATUS_TEXT_ANNOTABLE = StatusInfo . STATUS_NOTVERSIONED_EXCLUDED | StatusInfo . STATUS_NOTVERSIONED_NEWLOCALLY | StatusInfo . STATUS_VERSIONED_UPTODATE | StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY | StatusInfo . STATUS_VERSIONED_CONFLICT | StatusInfo . STATUS_VERSIONED_REMOVEDLOCALLY | StatusInfo . STATUS_VERSIONED_DELETEDLOCALLY | StatusInfo . STATUS_VERSIONED_ADDEDLOCALLY ; private static final Pattern lessThan = Pattern . compile ( "<" ) ; private static HtmlFormatter instance ; private String emptyFormat ; private Boolean needRevisionForFormat ; private MessageFormat format ; public static HtmlFormatter getInstance ( ) { if ( instance == null ) { instance = new HtmlFormatter ( ) ; } return instance ; } private HtmlFormatter ( ) { initDefaults ( ) ; } private void initDefaults ( ) { Field [ ] fields = HtmlFormatter . class . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { String name = fields [ i ] . getName ( ) ; if ( name . endsWith ( "Format" ) ) { initDefaultColor ( name . substring ( 0 , name . length ( ) - 6 ) ) ; } } refresh ( ) ; } public void refresh ( ) { String string = GitModuleConfig . getDefault ( ) . getAnnotationFormat ( ) ; if ( string != null && ! string . trim ( ) . equals ( "" ) ) { needRevisionForFormat = isRevisionInAnnotationFormat ( string ) ; string = string . replaceAll ( "\\{revision\\}" , "\\{0\\}" ) ; string = string . replaceAll ( "\\{status\\}" , "\\{1\\}" ) ; string = string . replaceAll ( "\\{folder\\}" , "\\{2\\}" ) ; format = new MessageFormat ( string ) ; emptyFormat = format . format ( new String [ ] { "" , "" , "" } , new StringBuffer ( ) , null ) . toString ( ) . trim ( ) ; } } public static boolean isRevisionInAnnotationFormat ( String str ) { if ( str . indexOf ( "{revision}" ) != - 1 ) { return true ; } else { return false ; } } private void initDefaultColor ( String name ) { String color = System . getProperty ( "git.color." + name ) ; if ( color == null ) { return ; } setAnnotationColor ( name , color ) ; } private void setAnnotationColor ( String name , String colorString ) { try { Field field = HtmlFormatter . class . getDeclaredField ( name + "Format" ) ; MessageFormat msgFormat = new MessageFormat ( "<font color=\"" + colorString + "\">{0}</font><font color=\"#999999\">{1}</font>" ) ; field . set ( null , msgFormat ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid color name" ) ; } } public String annotateNameHtml ( File file , StatusInfo info ) { return annotateNameHtml ( file . getName ( ) , info , file ) ; } public String annotateNameHtml ( String name , StatusInfo mostImportantInfo , File mostImportantFile ) { name = htmlEncode ( name ) ; String textAnnotation ; boolean annotationsVisible = VersioningSupport . getPreferences ( ) . getBoolean ( VersioningSupport . PREF_BOOLEAN_TEXT_ANNOTATIONS_VISIBLE , false ) ; int status = mostImportantInfo . getStatus ( ) ; if ( annotationsVisible && mostImportantFile != null && ( status & STATUS_TEXT_ANNOTABLE ) != 0 ) { if ( format != null ) { textAnnotation = formatAnnotation ( mostImportantInfo , mostImportantFile ) ; } else { String sticky = null ; if ( status == StatusInfo . STATUS_VERSIONED_UPTODATE && sticky == null ) { textAnnotation = "" ; } else if ( status == StatusInfo . STATUS_VERSIONED_UPTODATE ) { textAnnotation = " [" + sticky + "]" ; } else if ( sticky == null ) { String statusText = mostImportantInfo . getShortStatusText ( ) ; if ( ! statusText . equals ( "" ) ) { textAnnotation = " [" + mostImportantInfo . getShortStatusText ( ) + "]" ; } else { textAnnotation = "" ; } } else { textAnnotation = " [" + mostImportantInfo . getShortStatusText ( ) + "; " + sticky + "]" ; } } } else { textAnnotation = "" ; } if ( textAnnotation . length ( ) > 0 ) { textAnnotation = NbBundle . getMessage ( HtmlFormatter . class , "textAnnotation" , textAnnotation ) ; } if ( 0 != ( status & StatusInfo . STATUS_NOTVERSIONED_EXCLUDED ) ) { return excludedFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_VERSIONED_DELETEDLOCALLY ) ) { return deletedLocallyFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_VERSIONED_REMOVEDLOCALLY ) ) { return removedLocallyFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_NOTVERSIONED_NEWLOCALLY ) ) { return newLocallyFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_VERSIONED_ADDEDLOCALLY ) ) { return addedLocallyFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY ) ) { return modifiedLocallyFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_VERSIONED_UPTODATE ) ) { return uptodateFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_VERSIONED_CONFLICT ) ) { return conflictFormat . format ( new Object [ ] { name , textAnnotation } ) ; } else if ( 0 != ( status & StatusInfo . STATUS_NOTVERSIONED_NOTMANAGED ) ) { return name ; } else if ( status == StatusInfo . STATUS_UNKNOWN ) { return name ; } else { throw new IllegalArgumentException ( "Uncomparable status: " + status ) ; } } private static MessageFormat getFormat ( String key ) { String format = NbBundle . getMessage ( HtmlFormatter . class , key ) ; return new MessageFormat ( format ) ; } private String htmlEncode ( String name ) { if ( name . indexOf ( '<' ) == - 1 ) { return name ; } return lessThan . matcher ( name ) . replaceAll ( "&lt;" ) ; } private String formatAnnotation ( StatusInfo info , File file ) { String statusString = "" ; int status = info . getStatus ( ) ; if ( status != StatusInfo . STATUS_VERSIONED_UPTODATE ) { statusString = info . getShortStatusText ( ) ; } String revisionString = "" ; String binaryString = "" ; if ( needRevisionForFormat ) { if ( ( status & StatusInfo . STATUS_NOTVERSIONED_EXCLUDED ) == 0 ) { try { File root = Git . getInstance ( ) . getTopmostManagedParent ( file ) ; Repository repo = Git . getInstance ( ) . getRepository ( root ) ; ObjectId branch = repo . resolve ( repo . getFullBranch ( ) ) ; String absPath = file . getAbsolutePath ( ) ; String relPath = absPath . replace ( root . getAbsolutePath ( ) , "" ) ; RevWalk walk = new RevWalk ( repo ) ; RevCommit start = walk . parseCommit ( branch ) ; TreeFilter filter = PathFilter . create ( relPath ) ; walk . setTreeFilter ( filter ) ; walk . markStart ( start ) ; for ( RevCommit commit : walk ) { revisionString = commit . getId ( ) . name ( ) ; break ; } walk . dispose ( ) ; } catch ( IOException ex ) { NotifyDescriptor notification = new NotifyDescriptor . Message ( ex , NotifyDescriptor . ERROR_MESSAGE ) ; DialogDisplayer . getDefault ( ) . notifyLater ( notification ) ; } } } String stickyString = null ; if ( stickyString == null ) { stickyString = "" ; } Object [ ] arguments = new Object [ ] { revisionString , statusString , stickyString , } ; String annotation = format . format ( arguments , new StringBuffer ( ) , null ) . toString ( ) . trim ( ) ; if ( annotation . equals ( emptyFormat ) ) { return "" ; } else { return " " + annotation ; } } public String annotateFolderNameHtml ( String name , StatusInfo mostImportantInfo , File mostImportantFile ) { String nameHtml = htmlEncode ( name ) ; if ( mostImportantInfo . getStatus ( ) == StatusInfo . STATUS_NOTVERSIONED_EXCLUDED ) { return excludedFormat . format ( new Object [ ] { nameHtml , "" } ) ; } String fileName = mostImportantFile . getName ( ) ; if ( fileName . equals ( name ) ) { return uptodateFormat . format ( new Object [ ] { nameHtml , "" } ) ; } fileName = null ; File repo = Git . getInstance ( ) . getTopmostManagedParent ( mostImportantFile ) ; if ( repo != null && repo . equals ( mostImportantFile ) ) { if ( ! repo . getName ( ) . equals ( name ) ) { fileName = repo . getName ( ) ; } } if ( fileName != null ) { return uptodateFormat . format ( new Object [ ] { nameHtml , " [" + fileName + "]" } ) ; } else { return uptodateFormat . format ( new Object [ ] { nameHtml , "" } ) ; } } } 
=======
class Categories { static final String CATEGORY_NAMES = "NoLoMnCfLlNlLuMcNdSoSmCo" ; static final int [ ] [ ] CATEGORY_RANGES = { { 0x10320 , 0x10323 } , { 0x10300 , 0x1031e , 0x10330 , 0x10349 , 0x20000 , 0x2a6d6 , 0x2f800 , 0x2fa1d } , { 0x1d167 , 0x1d169 , 0x1d17b , 0x1d182 , 0x1d185 , 0x1d18b , 0x1d1aa , 0x1d1ad } , { 0x1d173 , 0x1d17a , 0xe0001 , 0xe0001 , 0xe0020 , 0xe007f } , { 0x10428 , 0x1044d , 0x1d41a , 0x1d433 , 0x1d44e , 0x1d454 , 0x1d456 , 0x1d467 , 0x1d482 , 0x1d49b , 0x1d4b6 , 0x1d4b9 , 0x1d4bb , 0x1d4bb , 0x1d4bd , 0x1d4c0 , 0x1d4c2 , 0x1d4c3 , 0x1d4c5 , 0x1d4cf , 0x1d4ea , 0x1d503 , 0x1d51e , 0x1d537 , 0x1d552 , 0x1d56b , 0x1d586 , 0x1d59f , 0x1d5ba , 0x1d5d3 , 0x1d5ee , 0x1d607 , 0x1d622 , 0x1d63b , 0x1d656 , 0x1d66f , 0x1d68a , 0x1d6a3 , 0x1d6c2 , 0x1d6da , 0x1d6dc , 0x1d6e1 , 0x1d6fc , 0x1d714 , 0x1d716 , 0x1d71b , 0x1d736 , 0x1d74e , 0x1d750 , 0x1d755 , 0x1d770 , 0x1d788 , 0x1d78a , 0x1d78f , 0x1d7aa , 0x1d7c2 , 0x1d7c4 , 0x1d7c9 } , { 0x1034a , 0x1034a } , { 0x10400 , 0x10425 , 0x1d400 , 0x1d419 , 0x1d434 , 0x1d44d , 0x1d468 , 0x1d481 , 0x1d49c , 0x1d49c , 0x1d49e , 0x1d49f , 0x1d4a2 , 0x1d4a2 , 0x1d4a5 , 0x1d4a6 , 0x1d4a9 , 0x1d4ac , 0x1d4ae , 0x1d4b5 , 0x1d4d0 , 0x1d4e9 , 0x1d504 , 0x1d505 , 0x1d507 , 0x1d50a , 0x1d50d , 0x1d514 , 0x1d516 , 0x1d51c , 0x1d538 , 0x1d539 , 0x1d53b , 0x1d53e , 0x1d540 , 0x1d544 , 0x1d546 , 0x1d546 , 0x1d54a , 0x1d550 , 0x1d56c , 0x1d585 , 0x1d5a0 , 0x1d5b9 , 0x1d5d4 , 0x1d5ed , 0x1d608 , 0x1d621 , 0x1d63c , 0x1d655 , 0x1d670 , 0x1d689 , 0x1d6a8 , 0x1d6c0 , 0x1d6e2 , 0x1d6fa , 0x1d71c , 0x1d734 , 0x1d756 , 0x1d76e , 0x1d790 , 0x1d7a8 } , { 0x1d165 , 0x1d166 , 0x1d16d , 0x1d172 } , { 0x1d7ce , 0x1d7ff } , { 0x1d000 , 0x1d0f5 , 0x1d100 , 0x1d126 , 0x1d12a , 0x1d164 , 0x1d16a , 0x1d16c , 0x1d183 , 0x1d184 , 0x1d18c , 0x1d1a9 , 0x1d1ae , 0x1d1dd } , { 0x1d6c1 , 0x1d6c1 , 0x1d6db , 0x1d6db , 0x1d6fb , 0x1d6fb , 0x1d715 , 0x1d715 , 0x1d735 , 0x1d735 , 0x1d74f , 0x1d74f , 0x1d76f , 0x1d76f , 0x1d789 , 0x1d789 , 0x1d7a9 , 0x1d7a9 , 0x1d7c3 , 0x1d7c3 } , { 0xf0000 , 0xffffd , 0x100000 , 0x10fffd } } ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
