<<<<<<< HEAD
public final class MarioState extends SpriteState { public int jumpTime = 0 , invulnerableTime = 0 ; public boolean big = true , dead = false , hurt = false , fire = true , wasOnGround = false , mayJump = true , sliding = false ; public float xJumpSpeed = 0 , yJumpSpeed = 0 ; public static int ACT_SPEED = 1 ; public static int ACT_RIGHT = 2 ; public static int ACT_LEFT = 4 ; public static int ACT_JUMP = 8 ; public static int [ ] jumpstep_table = { 0 , 1 , 2 , 4 , 7 } ; public float g , cost ; public int root_action ; public WorldState ws ; public int action ; public MarioState pred ; public MarioState ( float _x , float _y , float _xa , float _ya ) { x = _x ; y = _y ; xa = _xa ; ya = _ya ; } public float height ( ) { return big ? 24 : 12 ; } public final boolean dead ( ) { return dead ; } public void print ( ) { System . out . printf ( "g=%d a:%d x:(%f,%f) v:(%f,%f) %s%s%s cost=%f\n" , ( int ) g , action , x , y , xa , ya , onGround ? "G" : "g" , mayJump ? "J" : "j" , sliding ? "S" : "s" , cost ) ; } public MarioState clone ( ) { MarioState n = new MarioState ( x , y , xa , ya ) ; n . facing = facing ; n . jumpTime = jumpTime ; n . big = big ; n . fire = fire ; n . dead = dead ; n . hurt = false ; n . onGround = onGround ; n . wasOnGround = onGround ; n . mayJump = mayJump ; n . sliding = sliding ; n . xJumpSpeed = xJumpSpeed ; n . yJumpSpeed = yJumpSpeed ; n . root_action = root_action ; n . invulnerableTime = invulnerableTime ; n . ws = ws ; return n ; } public MarioState next ( int action , WorldState ws ) { MarioState n = clone ( ) ; n . action = action ; n . pred = this ; int jump_steps = action / ACT_JUMP ; if ( jump_steps > 1 ) { action = ( action & 7 ) + 8 ; for ( int i = 0 ; i < jumpstep_table [ jump_steps ] ; i ++ ) { n . g = g + 1 ; n . ws = ws ; n . move ( action ) ; if ( ! hurt ) { n . ws = n . ws . step ( ) ; n . ws = n . ws . interact ( n , false ) ; } } } else { n . g = g + 1 ; n . ws = ws ; n . move ( action ) ; if ( ! hurt ) { n . ws = n . ws . step ( ) ; n . ws = n . ws . interact ( n , false ) ; } } return n ; } public void move ( int action ) { boolean ducking = false ; float sideWaysSpeed = ( action & ACT_SPEED ) != 0 ? 1.2f : 0.6f ; if ( invulnerableTime > 0 ) invulnerableTime -- ; if ( xa > 2 ) facing = 1 ; else if ( xa < - 2 ) facing = - 1 ; if ( ( action & ACT_JUMP ) != 0 || ( jumpTime < 0 && ! onGround && ! sliding ) ) { if ( jumpTime < 0 ) { xa = xJumpSpeed ; ya = - jumpTime * yJumpSpeed ; jumpTime ++ ; } else if ( onGround && mayJump ) { xJumpSpeed = 0 ; yJumpSpeed = - 1.9f ; jumpTime = 7 ; ya = jumpTime * yJumpSpeed ; onGround = false ; sliding = false ; } else if ( sliding && mayJump ) { xJumpSpeed = - facing * 6.0f ; yJumpSpeed = - 2.0f ; jumpTime = - 6 ; xa = xJumpSpeed ; ya = - jumpTime * yJumpSpeed ; onGround = false ; sliding = false ; facing = - facing ; } else if ( jumpTime > 0 ) { xa = xa + xJumpSpeed ; ya = jumpTime * yJumpSpeed ; jumpTime = jumpTime - 1 ; } } else { jumpTime = 0 ; } if ( ( action & ACT_LEFT ) != 0 && ! ducking ) { if ( facing == 1 ) sliding = false ; xa -= sideWaysSpeed ; if ( jumpTime >= 0 ) facing = - 1 ; } if ( ( action & ACT_RIGHT ) != 0 && ! ducking ) { if ( facing == - 1 ) sliding = false ; xa += sideWaysSpeed ; if ( jumpTime >= 0 ) facing = 1 ; } if ( ( ( action & ACT_LEFT ) == 0 && ( action & ACT_RIGHT ) == 0 ) || ducking || ya < 0 || onGround ) { sliding = false ; } mayJump = ( onGround || sliding ) && ( action & ACT_JUMP ) == 0 ; if ( Math . abs ( xa ) < 0.5f ) { xa = 0 ; } if ( sliding ) ya = ya * 0.5f ; onGround = false ; move ( xa , 0 ) ; move ( 0 , ya ) ; if ( y > 15 * 16 + 16 ) { dead = true ; } if ( x < 0 ) { x = 0 ; xa = 0 ; } xa *= DAMPING_X ; ya *= DAMPING_Y ; if ( ! onGround ) ya += 3 ; } private boolean move ( float xa , float ya ) { while ( xa > 8 ) { if ( ! move ( 8 , 0 ) ) return false ; xa -= 8 ; } while ( xa < - 8 ) { if ( ! move ( - 8 , 0 ) ) return false ; xa += 8 ; } while ( ya > 8 ) { if ( ! move ( 0 , 8 ) ) return false ; ya -= 8 ; } while ( ya < - 8 ) { if ( ! move ( 0 , - 8 ) ) return false ; ya += 8 ; } boolean collide = false ; int width = 4 ; int height = big ? 24 : 12 ; if ( ya > 0 ) { if ( isBlocking ( x + xa - width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa - width , y + ya + 1 , xa , ya ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya + 1 , xa , ya ) ) collide = true ; } if ( ya < 0 ) { if ( isBlocking ( x + xa , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; } if ( xa > 0 ) { sliding = true ; if ( isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa + width , y + ya - height / 2 , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa + width , y + ya , xa , ya ) ) collide = true ; else sliding = false ; } if ( xa < 0 ) { sliding = true ; if ( isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa - width , y + ya - height / 2 , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa - width , y + ya , xa , ya ) ) collide = true ; else sliding = false ; } if ( collide ) { if ( xa < 0 ) { x = ( int ) ( ( x - width ) / 16 ) * 16 + width ; this . xa = 0 ; } else if ( xa > 0 ) { x = ( int ) ( ( x + width ) / 16 + 1 ) * 16 - width - 1 ; this . xa = 0 ; } if ( ya < 0 ) { y = ( int ) ( ( y - height ) / 16 ) * 16 + height ; jumpTime = 0 ; this . ya = 0 ; } else if ( ya > 0 ) { y = ( int ) ( ( y - 1 ) / 16 + 1 ) * 16 - 1 ; onGround = true ; } return false ; } else { x += xa ; y += ya ; return true ; } } private boolean isBlocking ( float _x , float _y , float xa , float ya ) { int x = ( int ) ( _x / 16 ) ; int y = ( int ) ( _y / 16 ) ; int Mx = ( int ) ( this . x / 16 ) ; int My = ( int ) ( this . y / 16 ) ; if ( x == Mx && y == My ) return false ; boolean blocking = ws . isBlocking ( x , y , xa , ya ) ; byte block = ws . getBlock ( x , y ) ; if ( block == 34 ) { ws = ws . removeTile ( x , y ) ; return false ; } if ( blocking && ya < 0 ) ws = ws . bump ( x , y , big ) ; return blocking ; } public void stomp ( SpriteState enemy ) { float targetY = enemy . y - enemy . height ( ) / 2 ; move ( 0 , targetY - y ) ; xJumpSpeed = 0 ; yJumpSpeed = - 1.9f ; jumpTime = 8 ; ya = jumpTime * yJumpSpeed ; onGround = false ; sliding = false ; invulnerableTime = 1 ; } public void getHurt ( ) { if ( invulnerableTime > 0 ) return ; if ( big ) { if ( fire ) { fire = false ; } else { big = false ; } invulnerableTime = 32 ; } else { dead = true ; } hurt = true ; } public int marioMode ( ) { return ( ( big ) ? 1 : 0 ) + ( ( fire ) ? 1 : 0 ) ; } } 
=======
public abstract class AbstractInt extends AbstractDatatype { protected AbstractInt ( ) { super ( ) ; } protected void checkInt ( CharSequence literal , int offset ) throws DatatypeException { if ( literal . length ( ) == 0 ) { throw newDatatypeException ( "The empty string is not a valid integer." ) ; } char c = literal . charAt ( 0 ) ; if ( ! ( c == '-' || isAsciiDigit ( c ) ) ) { throw newDatatypeException ( 0 , "Expected a minus sign or a digit but saw " , c , " instead." ) ; } for ( int i = 1 ; i < literal . length ( ) ; i ++ ) { c = literal . charAt ( i ) ; if ( ! isAsciiDigit ( c ) ) { throw newDatatypeException ( offset + i , "Expected a digit but saw " , c , " instead." ) ; } } } protected void checkIntNonNegative ( CharSequence literal , int offset ) throws DatatypeException { if ( literal . length ( ) == 0 ) { throw newDatatypeException ( "The empty string is not a valid non-negative integer." ) ; } for ( int i = 0 ; i < literal . length ( ) ; i ++ ) { char c = literal . charAt ( i ) ; if ( ! isAsciiDigit ( c ) ) { throw newDatatypeException ( offset + i , "Expected a digit but saw " , c , " instead." ) ; } } } protected void checkIntPositive ( CharSequence literal , int offset ) throws DatatypeException { if ( literal . length ( ) == 0 ) { throw newDatatypeException ( "The empty string is not a valid positive integer." ) ; } boolean zero = true ; for ( int i = 0 ; i < literal . length ( ) ; i ++ ) { char c = literal . charAt ( i ) ; if ( ! isAsciiDigit ( c ) ) { throw newDatatypeException ( offset + i , "Expected a digit but saw " , c , " instead." ) ; } if ( c != '0' ) { zero = false ; } } if ( zero ) { throw newDatatypeException ( "Zero is not a positive integer." ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
