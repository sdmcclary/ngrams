public class AddressManager implements Startable { private static Logger LOG = Logger . getLogger ( AddressManager . class ) ; public void start ( ) throws MuleException { EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; List < Address > addrList = db . query ( new Address ( ) ) ; for ( Address addr : addrList ) try { Addresses . getInstance ( ) . replace ( addr . getName ( ) , addr ) ; } catch ( NoSuchElementException e ) { Addresses . getInstance ( ) . register ( addr ) ; } db . commit ( ) ; } public static void updateAddressingMode ( ) { int allocatedCount = 0 ; List < Address > activeList = Addresses . getInstance ( ) . listValues ( ) ; for ( Address allocatedAddr : activeList ) { if ( EucalyptusProperties . NAME . equals ( allocatedAddr . getUserId ( ) ) ) { allocatedCount ++ ; try { if ( EucalyptusProperties . getSystemConfiguration ( ) . isDoDynamicPublicAddresses ( ) && ! allocatedAddr . isAssigned ( ) && ! allocatedAddr . isPending ( ) ) { LOG . debug ( "Deallocating unassigned public address in dynamic public addressing mode: " + allocatedAddr . getName ( ) ) ; EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address dbAddr = db . getUnique ( allocatedAddr ) ; db . delete ( dbAddr ) ; db . commit ( ) ; } catch ( EucalyptusCloudException e ) { db . rollback ( ) ; } allocatedAddr . release ( ) ; Addresses . getInstance ( ) . disable ( allocatedAddr . getName ( ) ) ; } } catch ( EucalyptusCloudException e ) { } } } LOG . debug ( "Found " + allocatedCount + " addresses allocated to eucalyptus" ) ; try { if ( ! EucalyptusProperties . getSystemConfiguration ( ) . isDoDynamicPublicAddresses ( ) ) { int allocCount = EucalyptusProperties . getSystemConfiguration ( ) . getSystemReservedPublicAddresses ( ) - allocatedCount ; LOG . debug ( "Allocating additional " + allocCount + " addresses in static public addresing mode" ) ; ConcurrentNavigableMap < String , Address > unusedAddresses = Addresses . getInstance ( ) . getDisabledMap ( ) ; allocCount = unusedAddresses . size ( ) < allocCount ? unusedAddresses . size ( ) : allocCount ; if ( allocCount > 0 ) { List < Map . Entry < String , Address > > addressList = Lists . newArrayList ( ) ; for ( int i = 0 ; i < allocCount ; i ++ ) { Map . Entry < String , Address > addressEntry = unusedAddresses . pollFirstEntry ( ) ; if ( addressEntry != null ) { addressList . add ( addressEntry ) ; } else { break ; } } NavigableSet < String > ipList = Sets . newTreeSet ( ) ; for ( Map . Entry < String , Address > addressEntry : addressList ) { LOG . debug ( "Allocating address for static public addressing: " + addressEntry . getValue ( ) . getName ( ) ) ; Address address = addressEntry . getValue ( ) ; address . allocate ( EucalyptusProperties . NAME ) ; EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address addr = db . getUnique ( new Address ( address . getName ( ) ) ) ; addr . allocate ( EucalyptusProperties . NAME ) ; } catch ( EucalyptusCloudException e ) { db . merge ( address ) ; } db . commit ( ) ; ipList . add ( address . getName ( ) ) ; try { Addresses . getInstance ( ) . register ( address ) ; } catch ( Exception e ) { } } } else { for ( String ipAddr : Addresses . getInstance ( ) . getActiveMap ( ) . descendingKeySet ( ) ) { Address addr = Addresses . getInstance ( ) . getActiveMap ( ) . get ( ipAddr ) ; if ( EucalyptusProperties . NAME . equals ( addr . getUserId ( ) ) && ! addr . isAssigned ( ) && ! addr . isPending ( ) ) { if ( allocCount ++ >= 0 ) break ; EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address dbAddr = db . getUnique ( new Address ( addr . getName ( ) ) ) ; db . delete ( dbAddr ) ; db . commit ( ) ; } catch ( EucalyptusCloudException e ) { db . rollback ( ) ; } addr . release ( ) ; Addresses . getInstance ( ) . disable ( addr . getName ( ) ) ; } } } } } catch ( EucalyptusCloudException e ) { } } public synchronized static NavigableSet < String > allocateAddresses ( int count ) throws NotEnoughResourcesAvailable { boolean doDynamic = true ; updateAddressingMode ( ) ; try { doDynamic = EucalyptusProperties . getSystemConfiguration ( ) . isDoDynamicPublicAddresses ( ) ; } catch ( EucalyptusCloudException e ) { } NavigableSet < String > ipList = Sets . newTreeSet ( ) ; List < Address > addressList = Lists . newArrayList ( ) ; if ( doDynamic ) { ConcurrentNavigableMap < String , Address > unusedAddresses = Addresses . getInstance ( ) . getDisabledMap ( ) ; if ( unusedAddresses . size ( ) < count ) throw new NotEnoughResourcesAvailable ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Map . Entry < String , Address > addressEntry = unusedAddresses . pollFirstEntry ( ) ; if ( addressEntry != null ) { Address addr = addressEntry . getValue ( ) ; addressList . add ( addr ) ; ipList . add ( addr . getName ( ) ) ; } else { for ( Address a : addressList ) { unusedAddresses . putIfAbsent ( a . getName ( ) , a ) ; } throw new NotEnoughResourcesAvailable ( ) ; } } } else { List < Address > allocatedAddresses = Addresses . getInstance ( ) . listValues ( ) ; for ( Address addr : allocatedAddresses ) { if ( ! addr . isAssigned ( ) && ! addr . isPending ( ) && EucalyptusProperties . NAME . equals ( addr . getUserId ( ) ) ) { Addresses . getInstance ( ) . deregister ( addr . getName ( ) ) ; ipList . add ( addr . getName ( ) ) ; addressList . add ( addr ) ; if ( addressList . size ( ) >= count ) break ; } } if ( addressList . size ( ) < count ) { for ( Address putBackAddr : addressList ) { Addresses . getInstance ( ) . register ( putBackAddr ) ; } throw new NotEnoughResourcesAvailable ( ) ; } } for ( Address address : addressList ) { assignSystemPublicAddress ( address ) ; } return ipList ; } private static void assignSystemPublicAddress ( final Address address ) { address . allocate ( EucalyptusProperties . NAME ) ; address . assign ( Address . PENDING_ASSIGNMENT , Address . PENDING_ASSIGNMENT ) ; EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address addr = db . getUnique ( new Address ( address . getName ( ) ) ) ; addr . allocate ( EucalyptusProperties . NAME ) ; } catch ( EucalyptusCloudException e ) { db . merge ( address ) ; } db . commit ( ) ; try { Addresses . getInstance ( ) . register ( address ) ; } catch ( Exception e ) { } } public AllocateAddressResponseType AllocateAddress ( AllocateAddressType request ) throws EucalyptusCloudException { AddressManager . updateAddressingMode ( ) ; int addrCount = 0 ; for ( Address a : Addresses . getInstance ( ) . listValues ( ) ) { if ( request . getUserId ( ) . equals ( a . getUserId ( ) ) ) addrCount ++ ; } if ( addrCount >= EucalyptusProperties . getSystemConfiguration ( ) . getMaxUserPublicAddresses ( ) && ! request . isAdministrator ( ) ) throw new EucalyptusCloudException ( ExceptionList . ERR_SYS_INSUFFICIENT_ADDRESS_CAPACITY ) ; ConcurrentNavigableMap < String , Address > unusedAddresses = Addresses . getInstance ( ) . getDisabledMap ( ) ; Map . Entry < String , Address > addressEntry = unusedAddresses . pollFirstEntry ( ) ; if ( addressEntry == null ) throw new EucalyptusCloudException ( ExceptionList . ERR_SYS_INSUFFICIENT_ADDRESS_CAPACITY ) ; Address address = addressEntry . getValue ( ) ; address . allocate ( request . getUserId ( ) ) ; EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address addr = db . getUnique ( new Address ( address . getName ( ) ) ) ; addr . allocate ( request . getUserId ( ) ) ; } catch ( EucalyptusCloudException e ) { db . merge ( address ) ; } db . commit ( ) ; try { Addresses . getInstance ( ) . register ( address ) ; } catch ( Exception e ) { } AllocateAddressResponseType reply = ( AllocateAddressResponseType ) request . getReply ( ) ; reply . setPublicIp ( address . getName ( ) ) ; return reply ; } public ReleaseAddressResponseType ReleaseAddress ( ReleaseAddressType request ) throws EucalyptusCloudException { AddressManager . updateAddressingMode ( ) ; ReleaseAddressResponseType reply = ( ReleaseAddressResponseType ) request . getReply ( ) ; reply . set_return ( false ) ; Address address = null ; try { address = Addresses . getInstance ( ) . lookup ( request . getPublicIp ( ) ) ; if ( ! request . isAdministrator ( ) && ! address . getUserId ( ) . equals ( request . getUserId ( ) ) ) return reply ; if ( address . isAssigned ( ) && ! address . isPending ( ) ) { try { VmInstance oldVm = VmInstances . getInstance ( ) . lookup ( address . getInstanceId ( ) ) ; AddressManager . unassignAddressFromVm ( address , oldVm ) ; AddressManager . tryAssignSystemAddress ( oldVm ) ; } catch ( NoSuchElementException e ) { } } if ( EucalyptusProperties . NAME . equals ( address . getUserId ( ) ) && ! EucalyptusProperties . getSystemConfiguration ( ) . isDoDynamicPublicAddresses ( ) ) { LOG . debug ( "Not de-allocating system owned address in static public addressing mode: " + address . getName ( ) ) ; return reply ; } AddressManager . releaseAddress ( address ) ; reply . set_return ( true ) ; } catch ( NoSuchElementException e ) { return reply ; } return reply ; } public DescribeAddressesResponseType DescribeAddresses ( DescribeAddressesType request ) throws EucalyptusCloudException { AddressManager . updateAddressingMode ( ) ; DescribeAddressesResponseType reply = ( DescribeAddressesResponseType ) request . getReply ( ) ; boolean isAdmin = request . isAdministrator ( ) ; for ( Address address : Addresses . getInstance ( ) . listValues ( ) ) { try { VmInstances . getInstance ( ) . lookup ( address . getInstanceId ( ) ) ; } catch ( NoSuchElementException e ) { EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address addr = db . getUnique ( new Address ( address . getName ( ) ) ) ; addr . unassign ( ) ; db . commit ( ) ; } catch ( EucalyptusCloudException ex ) { db . rollback ( ) ; } address . unassign ( ) ; } if ( isAdmin || address . getUserId ( ) . equals ( request . getUserId ( ) ) ) { reply . getAddressesSet ( ) . add ( address . getDescription ( isAdmin ) ) ; } } if ( request . isAdministrator ( ) ) for ( Address address : Addresses . getInstance ( ) . listDisabledValues ( ) ) reply . getAddressesSet ( ) . add ( new DescribeAddressesResponseItemType ( address . getName ( ) , Address . UNALLOCATED_USERID ) ) ; return reply ; } public AssociateAddressResponseType AssociateAddress ( AssociateAddressType request ) throws AxisFault { AddressManager . updateAddressingMode ( ) ; AssociateAddressResponseType reply = ( AssociateAddressResponseType ) request . getReply ( ) ; reply . set_return ( false ) ; LOG . debug ( "Associate: " + request . getPublicIp ( ) + " => " + request . getInstanceId ( ) ) ; Address address = null ; try { address = Addresses . getInstance ( ) . lookup ( request . getPublicIp ( ) ) ; } catch ( NoSuchElementException e ) { return reply ; } LOG . debug ( "Found address: " + address ) ; VmInstance vm = null ; try { vm = VmInstances . getInstance ( ) . lookup ( request . getInstanceId ( ) ) ; } catch ( NoSuchElementException e ) { return reply ; } LOG . debug ( "Found vm: " + vm ) ; if ( ! request . isAdministrator ( ) && ! ( request . getUserId ( ) . equals ( address . getUserId ( ) ) && request . getUserId ( ) . equals ( vm . getOwnerId ( ) ) ) ) return reply ; reply . set_return ( true ) ; if ( ! vm . getNetworkConfig ( ) . getIpAddress ( ) . equals ( vm . getNetworkConfig ( ) . getIgnoredPublicIp ( ) ) && ! VmInstance . DEFAULT_IP . equals ( vm . getNetworkConfig ( ) . getIgnoredPublicIp ( ) ) ) { String currentPublicIp = vm . getNetworkConfig ( ) . getIgnoredPublicIp ( ) ; try { Address currentAddr = Addresses . getInstance ( ) . lookup ( currentPublicIp ) ; boolean release = EucalyptusProperties . NAME . equals ( currentAddr . getUserId ( ) ) && EucalyptusProperties . getSystemConfiguration ( ) . isDoDynamicPublicAddresses ( ) ; LOG . debug ( "Dispatching unassign message for: " + address ) ; AddressManager . unassignAddressFromVm ( currentAddr , vm ) ; if ( release ) { AddressManager . releaseAddress ( currentAddr ) ; } } catch ( NoSuchElementException e ) { return reply ; } } if ( address . isAssigned ( ) && address . getUserId ( ) . equals ( request . getUserId ( ) ) && ! address . isPending ( ) ) { LOG . debug ( "Dispatching unassign message for: " + address ) ; try { VmInstance oldVm = VmInstances . getInstance ( ) . lookup ( address . getInstanceId ( ) ) ; AddressManager . unassignAddressFromVm ( address , oldVm ) ; AddressManager . tryAssignSystemAddress ( oldVm ) ; if ( ! EucalyptusProperties . disableNetworking ) { } } catch ( NoSuchElementException e ) { LOG . error ( e , e ) ; } } AddressManager . assignAddressToVm ( address , vm ) ; return reply ; } private static void releaseAddress ( final Address currentAddr ) { EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address addr = db . getUnique ( new Address ( currentAddr . getName ( ) ) ) ; currentAddr . unassign ( ) ; addr . unassign ( ) ; db . delete ( addr ) ; currentAddr . release ( ) ; Addresses . getInstance ( ) . disable ( currentAddr . getName ( ) ) ; db . commit ( ) ; } catch ( EucalyptusCloudException e ) { db . rollback ( ) ; } } public DisassociateAddressResponseType DisassociateAddress ( DisassociateAddressType request ) throws EucalyptusCloudException { AddressManager . updateAddressingMode ( ) ; DisassociateAddressResponseType reply = ( DisassociateAddressResponseType ) request . getReply ( ) ; reply . set_return ( false ) ; LOG . debug ( "Disassociate: " + request . getPublicIp ( ) ) ; Address address = null ; try { address = Addresses . getInstance ( ) . lookup ( request . getPublicIp ( ) ) ; } catch ( NoSuchElementException e ) { return reply ; } LOG . debug ( "Found address: " + address ) ; VmInstance vm = null ; try { vm = VmInstances . getInstance ( ) . lookup ( address . getInstanceId ( ) ) ; } catch ( NoSuchElementException e ) { return reply ; } LOG . debug ( "Found vm: " + vm ) ; if ( ! request . isAdministrator ( ) && ! ( request . getUserId ( ) . equals ( address . getUserId ( ) ) && request . getUserId ( ) . equals ( vm . getOwnerId ( ) ) ) ) return reply ; if ( VmInstance . DEFAULT_IP . equals ( vm . getInstanceId ( ) ) ) return reply ; reply . set_return ( true ) ; AddressManager . unassignAddressFromVm ( address , vm ) ; AddressManager . tryAssignSystemAddress ( vm ) ; return reply ; } private static void tryAssignSystemAddress ( final VmInstance vm ) { if ( ! EucalyptusProperties . disableNetworking ) { try { String newAddr = allocateAddresses ( 1 ) . pollFirst ( ) ; Address newAddress = Addresses . getInstance ( ) . lookup ( newAddr ) ; AddressManager . assignAddressToVm ( newAddress , vm ) ; } catch ( NotEnoughResourcesAvailable notEnoughResourcesAvailable ) { LOG . error ( "Attempt to assign a system address for " + vm . getInstanceId ( ) + " failed due to lack of addresses." ) ; } catch ( NoSuchElementException e ) { LOG . error ( "Attempt to assign a system address for " + vm . getInstanceId ( ) + " failed due to lack of addresses." ) ; } } } private static void unassignAddressFromVm ( Address address , VmInstance vm ) { EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { UnassignAddressType unassignMsg = Admin . makeMsg ( UnassignAddressType . class , address . getName ( ) , address . getInstanceAddress ( ) ) ; ClusterEnvelope . dispatch ( address . getCluster ( ) , QueuedEvent . make ( new UnassignAddressCallback ( address ) , unassignMsg ) ) ; Address addr = db . getUnique ( new Address ( address . getName ( ) ) ) ; addr . unassign ( ) ; address . unassign ( ) ; db . commit ( ) ; } catch ( EucalyptusCloudException e ) { db . rollback ( ) ; } } private static void assignAddressToVm ( Address address , VmInstance vm ) { EntityWrapper < Address > db = new EntityWrapper < Address > ( ) ; try { Address addr = db . getUnique ( new Address ( address . getName ( ) ) ) ; addr . unassign ( ) ; addr . assign ( vm . getInstanceId ( ) , vm . getNetworkConfig ( ) . getIpAddress ( ) ) ; address . assign ( vm . getInstanceId ( ) , vm . getNetworkConfig ( ) . getIpAddress ( ) ) ; AssignAddressType assignMsg = Admin . makeMsg ( AssignAddressType . class , address . getName ( ) , address . getInstanceAddress ( ) ) ; ClusterEnvelope . dispatch ( address . getCluster ( ) , QueuedEvent . make ( new AssignAddressCallback ( vm ) , assignMsg ) ) ; db . commit ( ) ; } catch ( EucalyptusCloudException e ) { db . rollback ( ) ; } } } 