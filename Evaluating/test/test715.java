<<<<<<< HEAD
@ SuppressWarnings ( "restriction" ) public final class ImageUtils { private static final String USER_HOME = PlatformUtils . expandEnvironmentStrings ( PlatformUtils . HOME_DIRECTORY ) ; private static final String DESKTOP = PlatformUtils . expandEnvironmentStrings ( PlatformUtils . DESKTOP_DIRECTORY ) ; private static final boolean ON_WINDOWS = Platform . OS_WIN32 . equals ( Platform . getOS ( ) ) ; private static javax . swing . JFileChooser jFileChooser ; private static final WeakHashMap < Object , String > iconToKeyMap = new WeakHashMap < Object , String > ( ) ; private ImageUtils ( ) { } public static ImageDescriptor getImageDescriptor ( File file ) { if ( file . isFile ( ) ) { ImageDescriptor imageDescriptor = PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . getImageDescriptor ( file . getName ( ) ) ; if ( imageDescriptor != null ) { return imageDescriptor ; } } if ( file . exists ( ) ) { if ( jFileChooser == null ) { jFileChooser = new javax . swing . JFileChooser ( ) ; } String fileType = jFileChooser . getTypeDescription ( file ) ; if ( fileType == null || fileType . length ( ) == 0 || "Directory" . equals ( fileType ) || "System Folder" . equals ( fileType ) || "Generic File" . equals ( fileType ) ) { String name = file . getName ( ) ; try { name = file . getCanonicalFile ( ) . getName ( ) ; } catch ( IOException e ) { name = file . getName ( ) ; } if ( name . equals ( ( new Path ( DESKTOP ) ) . lastSegment ( ) ) ) { fileType = "Desktop" ; } else if ( ! file . isDirectory ( ) ) { int index = name . lastIndexOf ( '.' ) ; if ( index >= 0 && index < name . length ( ) - 1 ) { fileType = name . substring ( index + 1 ) ; } else { fileType = "unknown" ; } } else if ( "Directory" . equals ( fileType ) || name . length ( ) == 0 ) { fileType = file . getAbsolutePath ( ) ; } else if ( "System Folder" . equals ( fileType ) ) { if ( file . getAbsolutePath ( ) . equals ( USER_HOME ) ) { fileType = "UserHome" ; } } } String imageKey = "os.fileType_" + fileType ; ImageRegistry imageRegistry = JFaceResources . getImageRegistry ( ) ; ImageDescriptor imageDescriptor = imageRegistry . getDescriptor ( imageKey ) ; if ( imageDescriptor != null ) { return imageDescriptor ; } Icon icon ; if ( ON_WINDOWS ) { icon = FileSystemView . getFileSystemView ( ) . getSystemIcon ( file ) ; } else { icon = jFileChooser . getIcon ( file ) ; } if ( icon != null ) { String existingImageKey = iconToKeyMap . get ( icon ) ; if ( existingImageKey != null ) { imageDescriptor = imageRegistry . getDescriptor ( existingImageKey ) ; if ( imageDescriptor != null ) { return imageDescriptor ; } } ImageData imageData = awtImageIconToSWTImageData ( icon , null ) ; if ( imageData != null ) { imageDescriptor = ImageDescriptor . createFromImageData ( imageData ) ; imageRegistry . put ( imageKey , imageDescriptor ) ; iconToKeyMap . put ( icon , imageKey ) ; return imageRegistry . getDescriptor ( imageKey ) ; } } } return getImageDescriptor ( file . getName ( ) ) ; } public static ImageDescriptor getImageDescriptor ( String filename ) { ImageDescriptor imageDescriptor = PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . getImageDescriptor ( filename ) ; if ( imageDescriptor == null ) { imageDescriptor = getExtensionImageDescriptor ( new Path ( filename ) . getFileExtension ( ) ) ; } return imageDescriptor ; } private static ImageDescriptor getExtensionImageDescriptor ( String extension ) { ImageRegistry imageRegistry = JFaceResources . getImageRegistry ( ) ; String imageKey = "extension_" + extension ; ImageDescriptor imageDescriptor = imageRegistry . getDescriptor ( imageKey ) ; if ( imageDescriptor == null ) { Program program = Program . findProgram ( extension ) ; if ( program != null ) { imageDescriptor = new ExternalProgramImageDescriptor ( program ) ; } else { return null ; } imageRegistry . put ( imageKey , imageDescriptor ) ; imageDescriptor = imageRegistry . getDescriptor ( imageKey ) ; } return imageDescriptor ; } private static ImageData awtImageIconToSWTImageData ( javax . swing . Icon icon , Color backgroundColor ) { java . awt . Color bgColor = swtColorToAWTColor ( backgroundColor != null ? backgroundColor : Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ) ; java . awt . image . BufferedImage bi = new java . awt . image . BufferedImage ( icon . getIconWidth ( ) , icon . getIconHeight ( ) , java . awt . image . BufferedImage . TYPE_INT_RGB ) ; java . awt . Graphics2D imageGraphics = bi . createGraphics ( ) ; try { if ( icon instanceof javax . swing . ImageIcon ) { imageGraphics . drawImage ( ( ( javax . swing . ImageIcon ) icon ) . getImage ( ) , 0 , 0 , bgColor , ( java . awt . image . ImageObserver ) null ) ; } else { if ( jFileChooser == null ) { jFileChooser = new javax . swing . JFileChooser ( ) ; } imageGraphics . setBackground ( bgColor ) ; imageGraphics . clearRect ( 0 , 0 , icon . getIconWidth ( ) , icon . getIconHeight ( ) ) ; icon . paintIcon ( jFileChooser , imageGraphics , 0 , 0 ) ; } return awtBufferedImageToSWTImageData ( bi ) ; } finally { imageGraphics . dispose ( ) ; } } private static java . awt . Color swtColorToAWTColor ( Color color ) { return new java . awt . Color ( color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) ) ; } private static ImageData awtBufferedImageToSWTImageData ( java . awt . image . BufferedImage bufferedImage ) { if ( bufferedImage . getColorModel ( ) instanceof java . awt . image . DirectColorModel ) { java . awt . image . DirectColorModel colorModel = ( java . awt . image . DirectColorModel ) bufferedImage . getColorModel ( ) ; PaletteData palette = new PaletteData ( colorModel . getRedMask ( ) , colorModel . getGreenMask ( ) , colorModel . getBlueMask ( ) ) ; ImageData data = new ImageData ( bufferedImage . getWidth ( ) , bufferedImage . getHeight ( ) , colorModel . getPixelSize ( ) , palette ) ; java . awt . image . WritableRaster raster = bufferedImage . getRaster ( ) ; int [ ] pixelArray = new int [ 3 ] ; for ( int y = 0 ; y < data . height ; y ++ ) { for ( int x = 0 ; x < data . width ; x ++ ) { raster . getPixel ( x , y , pixelArray ) ; int pixel = palette . getPixel ( new RGB ( pixelArray [ 0 ] , pixelArray [ 1 ] , pixelArray [ 2 ] ) ) ; data . setPixel ( x , y , pixel ) ; } } return data ; } else if ( bufferedImage . getColorModel ( ) instanceof java . awt . image . IndexColorModel ) { java . awt . image . IndexColorModel colorModel = ( java . awt . image . IndexColorModel ) bufferedImage . getColorModel ( ) ; int size = colorModel . getMapSize ( ) ; byte [ ] reds = new byte [ size ] ; byte [ ] greens = new byte [ size ] ; byte [ ] blues = new byte [ size ] ; colorModel . getReds ( reds ) ; colorModel . getGreens ( greens ) ; colorModel . getBlues ( blues ) ; RGB [ ] rgbs = new RGB [ size ] ; for ( int i = 0 ; i < rgbs . length ; i ++ ) { rgbs [ i ] = new RGB ( reds [ i ] & 0xFF , greens [ i ] & 0xFF , blues [ i ] & 0xFF ) ; } PaletteData palette = new PaletteData ( rgbs ) ; ImageData data = new ImageData ( bufferedImage . getWidth ( ) , bufferedImage . getHeight ( ) , colorModel . getPixelSize ( ) , palette ) ; data . transparentPixel = colorModel . getTransparentPixel ( ) ; java . awt . image . WritableRaster raster = bufferedImage . getRaster ( ) ; int [ ] pixelArray = new int [ 1 ] ; for ( int y = 0 ; y < data . height ; y ++ ) { for ( int x = 0 ; x < data . width ; x ++ ) { raster . getPixel ( x , y , pixelArray ) ; data . setPixel ( x , y , pixelArray [ 0 ] ) ; } } return data ; } return null ; } } 
=======
public final class SqliteWrapper { private static final String TAG = "SqliteWrapper" ; private static final String SQLITE_EXCEPTION_DETAIL_MESSAGE = "unable to open database file" ; private SqliteWrapper ( ) { } private static boolean isLowMemory ( Context context ) { if ( null == context ) { return false ; } ActivityManager am = ( ActivityManager ) context . getSystemService ( Context . ACTIVITY_SERVICE ) ; ActivityManager . MemoryInfo outInfo = new ActivityManager . MemoryInfo ( ) ; am . getMemoryInfo ( outInfo ) ; return outInfo . lowMemory ; } private static boolean isLowMemory ( SQLiteException e ) { return e . getMessage ( ) . equals ( SQLITE_EXCEPTION_DETAIL_MESSAGE ) ; } public static void checkSQLiteException ( Context context , SQLiteException e ) { if ( isLowMemory ( e ) ) { Toast . makeText ( context , "Low Memory" , Toast . LENGTH_SHORT ) . show ( ) ; } else { throw e ; } } public static Cursor query ( Context context , ContentResolver resolver , Uri uri , String [ ] projection , String selection , String [ ] selectionArgs , String sortOrder ) { try { return resolver . query ( uri , projection , selection , selectionArgs , sortOrder ) ; } catch ( SQLiteException e ) { Log . e ( TAG , "Catch a SQLiteException when query: " , e ) ; checkSQLiteException ( context , e ) ; return null ; } } public static boolean requery ( Context context , Cursor cursor ) { try { return cursor . requery ( ) ; } catch ( SQLiteException e ) { Log . e ( TAG , "Catch a SQLiteException when requery: " , e ) ; checkSQLiteException ( context , e ) ; return false ; } } public static int update ( Context context , ContentResolver resolver , Uri uri , ContentValues values , String where , String [ ] selectionArgs ) { try { return resolver . update ( uri , values , where , selectionArgs ) ; } catch ( SQLiteException e ) { Log . e ( TAG , "Catch a SQLiteException when update: " , e ) ; checkSQLiteException ( context , e ) ; return - 1 ; } } public static int delete ( Context context , ContentResolver resolver , Uri uri , String where , String [ ] selectionArgs ) { try { return resolver . delete ( uri , where , selectionArgs ) ; } catch ( SQLiteException e ) { Log . e ( TAG , "Catch a SQLiteException when delete: " , e ) ; checkSQLiteException ( context , e ) ; return - 1 ; } } public static Uri insert ( Context context , ContentResolver resolver , Uri uri , ContentValues values ) { try { return resolver . insert ( uri , values ) ; } catch ( SQLiteException e ) { Log . e ( TAG , "Catch a SQLiteException when insert: " , e ) ; checkSQLiteException ( context , e ) ; return null ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
