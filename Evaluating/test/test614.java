<<<<<<< HEAD
public class ProfilesViewHelper { public static String [ ] addSDocFromJavaScriptSource ( File base , String text ) { URL baseFile = FileUtils . uriToURL ( CoreUIUtils . getURI ( base ) ) ; return addSDocFromJavaScriptSource ( baseFile , text ) ; } public static String [ ] addSDocFromJavaScriptSource ( URL base , String text ) { List < String > fileList = new ArrayList < String > ( ) ; int commentStart = text . indexOf ( "/*" ) ; while ( commentStart != - 1 ) { int commentEnd = text . indexOf ( "*/" , commentStart + 2 ) ; if ( commentEnd != - 1 ) { Pattern p = Pattern . compile ( "@sdoc\\s+([^\r\n]+)" ) ; Matcher matcher = p . matcher ( text ) ; String matchedString = "" ; while ( matcher . find ( ) ) { matchedString = matcher . group ( 1 ) ; } if ( matchedString != "" ) { String filename = matchedString . trim ( ) ; if ( filename . charAt ( 0 ) != '/' || filename . indexOf ( ":" ) == - 1 ) { filename = CoreUIUtils . joinURI ( base , filename ) ; } fileList . add ( CoreUIUtils . getURI ( filename ) ) ; } commentStart = text . indexOf ( "/*" , commentEnd + 2 ) ; } else { break ; } } return fileList . toArray ( new String [ fileList . size ( ) ] ) ; } public static String [ ] addScriptTagsFromHTMLSource ( File base , String text , IParseState parseState ) { URL baseFile = FileUtils . uriToURL ( CoreUIUtils . getURI ( base ) ) ; return addScriptTagsFromHTMLSource ( baseFile , text , parseState ) ; } public static String [ ] addScriptTagsFromHTMLSource ( URL base , String text , IParseState parseState ) { List < String > fileList = new ArrayList < String > ( ) ; IParseNode results = parseState . getParseResults ( ) ; IParseNode [ ] current = results . getChildren ( ) ; IQueue queue = new ArrayQueue ( ) ; List < String > srcs = new ArrayList < String > ( ) ; for ( int i = 0 ; i < current . length ; i ++ ) { queue . enqueue ( current [ i ] ) ; } while ( queue . size ( ) > 0 ) { IParseNode node = ( IParseNode ) queue . dequeue ( ) ; IParseNode [ ] children = node . getChildren ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { IParseNode child = children [ i ] ; if ( "script" . equals ( child . getText ( ) ) ) { boolean hasFile = false ; String filename = child . getAttribute ( "src" ) ; filename = makeHttpUrl ( filename ) ; String aSrc = "" ; for ( int j = 0 ; j < srcs . size ( ) ; j ++ ) { aSrc = srcs . get ( j ) ; if ( aSrc == filename ) { hasFile = true ; break ; } } if ( hasFile == false ) { srcs . add ( filename ) ; } } else { queue . enqueue ( child ) ; } } } for ( int i = 0 ; i < srcs . size ( ) ; i ++ ) { String src = srcs . get ( i ) ; if ( src != null && src . length ( ) > 0 ) { String source = StringUtils . trimStringQuotes ( src ) ; source = stripQuerystring ( source ) ; if ( ! CoreUIUtils . isURI ( source ) && source . charAt ( 0 ) != '/' ) { source = CoreUIUtils . joinURI ( base , source ) ; } String uri = CoreUIUtils . getURI ( source ) ; fileList . add ( uri ) ; String sdocFile = findScriptDocFile ( uri ) ; if ( sdocFile != null ) { fileList . add ( CoreUIUtils . getURI ( sdocFile ) ) ; } URL url = FileUtils . uriToURL ( uri ) ; if ( url != null ) { String [ ] subFiles = addScriptFromJavaScriptSource ( url ) ; fileList . addAll ( Arrays . asList ( subFiles ) ) ; } } } return fileList . toArray ( new String [ fileList . size ( ) ] ) ; } public static String [ ] addSDocFromJavaScriptSource ( URL url ) { URL basePath = getBasePath ( url ) ; try { String text = FileUtils . readContent ( url ) ; if ( text != null ) { return addSDocFromJavaScriptSource ( basePath , text ) ; } else { return new String [ 0 ] ; } } catch ( IOException ex ) { return new String [ 0 ] ; } } public static URL getBasePath ( URL url ) { return CoreUIUtils . trimURLSegments ( url , 1 ) ; } public static URL getBasePath ( String uri ) { URI uri2 ; try { uri2 = new URI ( uri ) ; URL url = uri2 . toURL ( ) ; return getBasePath ( url ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return null ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; return null ; } } public static String [ ] addScriptFromJavaScriptSource ( URL url ) { URL basePath = getBasePath ( url ) ; String text ; try { text = FileUtils . readContent ( url ) ; if ( text != null ) { return addScriptFromJavaScriptSource ( basePath , text ) ; } } catch ( IOException e ) { return new String [ 0 ] ; } return new String [ 0 ] ; } public static String [ ] addScriptFromJavaScriptSource ( File base , String text ) { URL baseFile = FileUtils . uriToURL ( CoreUIUtils . getURI ( base ) ) ; return addScriptFromJavaScriptSource ( baseFile , text ) ; } public static String [ ] addScriptFromJavaScriptSource ( URL base , String text ) { List < String > fileList = new ArrayList < String > ( ) ; Pattern pattern = Pattern . compile ( "^MochiKit\\.MochiKit\\.SUBMODULES\\s*=\\s*\\[[\\r\\n]+([^\\]]+)\\]" , Pattern . MULTILINE ) ; Matcher matcher = pattern . matcher ( text ) ; String names = "" ; while ( matcher . find ( ) ) { names = matcher . group ( 1 ) ; } pattern = Pattern . compile ( "\"([^\"]+)\"" ) ; matcher = pattern . matcher ( names ) ; List < String > mochikitNames = new ArrayList < String > ( ) ; while ( matcher . find ( ) ) { mochikitNames . add ( matcher . group ( 1 ) ) ; } String [ ] sdocs = ProfilesViewHelper . addSDocFromJavaScriptSource ( base , text ) ; fileList . addAll ( Arrays . asList ( sdocs ) ) ; for ( int i = 0 ; i < mochikitNames . size ( ) ; i ++ ) { String source = CoreUIUtils . joinURI ( base , mochikitNames . get ( i ) + ".js" ) ; fileList . add ( CoreUIUtils . getURI ( source ) ) ; URL u = FileUtils . uriToURL ( source ) ; if ( u != null ) { String [ ] subFiles = addSDocFromJavaScriptSource ( u ) ; fileList . addAll ( Arrays . asList ( subFiles ) ) ; } String sdocFile = findScriptDocFile ( source ) ; if ( sdocFile != null ) { fileList . add ( CoreUIUtils . getURI ( sdocFile ) ) ; } } return fileList . toArray ( new String [ fileList . size ( ) ] ) ; } public static String findScriptDocFile ( String fileName ) { String baseName = CoreUIUtils . getURI ( FileUtils . stripExtension ( fileName ) ) ; String sdocName = baseName + ".sdoc" ; URL sdocURL = FileUtils . uriToURL ( sdocName ) ; if ( isValidURL ( sdocURL ) ) { return sdocURL . toString ( ) ; } else { return null ; } } public static String stripQuerystring ( String source ) { int tmp = source . indexOf ( "?" ) ; if ( tmp > - 1 ) { source = source . substring ( 0 , tmp ) ; } return source ; } public static boolean isValidURL ( URL url ) { if ( url == null ) { return false ; } try { if ( FileUtils . isFileURL ( url ) ) { File file = FileUtils . urlToFile ( url ) ; return file . exists ( ) && file . isFile ( ) && file . canRead ( ) ; } else { InputStream is = url . openStream ( ) ; is . close ( ) ; return true ; } } catch ( IOException e ) { return false ; } } public static String makeHttpUrl ( String url ) { if ( url != null && url . startsWith ( "//" ) ) { return "http:" + url ; } else { return url ; } } } 
=======
public class IriRef extends AbstractDatatype { public static final IriRef THE_INSTANCE = new IriRef ( ) ; protected IriRef ( ) { super ( ) ; } private final static boolean WARN = System . getProperty ( "org.whattf.datatype.warn" , "" ) . equals ( "true" ) ? true : false ; private enum KnownViolationCode { COMPATIBILITY_CHARACTER , CONTROL_CHARACTER , DNS_LABEL_DASH_START_OR_END , DOUBLE_WHITESPACE , EMPTY_SCHEME , HAS_PASSWORD , ILLEGAL_CHARACTER , ILLEGAL_PERCENT_ENCODING , IP_V4_HAS_FOUR_COMPONENTS , IP_V4_OCTET_RANGE , IP_V6_OR_FUTURE_ADDRESS_SYNTAX , NON_INITIAL_DOT_SEGMENT , NOT_DNS_NAME , PORT_SHOULD_NOT_BE_WELL_KNOWN , REQUIRED_COMPONENT_MISSING , SCHEME_MUST_START_WITH_LETTER , UNDEFINED_UNICODE_CHARACTER , UNICODE_WHITESPACE , UNREGISTERED_NONIETF_SCHEME_TREE , WHITESPACE , ZZZ_DUMMY_DEFAULT } private final CharSequencePair splitScheme ( CharSequence iri ) { StringBuilder sb = new StringBuilder ( ) ; Boolean atSchemeBeginning = true ; for ( int i = 0 ; i < iri . length ( ) ; i ++ ) { char c = toAsciiLowerCase ( iri . charAt ( i ) ) ; if ( atSchemeBeginning ) { if ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) { continue ; } if ( 'a' <= c && 'z' >= c ) { atSchemeBeginning = false ; sb . append ( c ) ; } else { return null ; } } else { if ( ( 'a' <= c && 'z' >= c ) || ( '0' <= c && '9' >= c ) || c == '+' || c == '.' ) { sb . append ( c ) ; continue ; } else if ( c == ':' ) { return new CharSequencePair ( sb , iri . subSequence ( i + 1 , iri . length ( ) ) ) ; } else { return null ; } } } return null ; } public void checkValid ( CharSequence literal ) throws DatatypeException { IRIFactory fac = new IRIFactory ( ) ; fac . shouldViolation ( true , false ) ; fac . securityViolation ( true , false ) ; fac . dnsViolation ( true , false ) ; fac . mintingViolation ( false , false ) ; fac . useSpecificationIRI ( true ) ; fac . useSchemeSpecificRules ( "http" , true ) ; fac . useSchemeSpecificRules ( "https" , true ) ; fac . useSchemeSpecificRules ( "ftp" , true ) ; fac . useSchemeSpecificRules ( "mailto" , true ) ; fac . useSchemeSpecificRules ( "file" , true ) ; fac . useSchemeSpecificRules ( "data" , true ) ; IRI iri ; boolean data = false ; try { CharSequencePair pair = splitScheme ( literal ) ; if ( pair == null ) { iri = fac . construct ( trimHtmlSpaces ( literal . toString ( ) ) ) ; } else { CharSequence scheme = pair . getHead ( ) ; CharSequence tail = pair . getTail ( ) ; if ( isWellKnown ( scheme ) ) { iri = fac . construct ( trimHtmlSpaces ( literal . toString ( ) ) ) ; } else if ( "javascript" . contentEquals ( scheme ) ) { iri = null ; Reader reader = new BufferedReader ( new Utf8PercentDecodingReader ( new StringReader ( "function(event){" + tail . toString ( ) + "}" ) ) ) ; reader . mark ( 1 ) ; int c = reader . read ( ) ; if ( c != 0xFEFF ) { reader . reset ( ) ; } try { Context context = ContextFactory . getGlobal ( ) . enterContext ( ) ; context . setOptimizationLevel ( 0 ) ; context . setLanguageVersion ( Context . VERSION_1_6 ) ; context . compileReader ( reader , null , - 1 , null ) ; } finally { Context . exit ( ) ; } } else if ( "data" . contentEquals ( scheme ) ) { data = true ; iri = fac . construct ( trimHtmlSpaces ( literal . toString ( ) ) ) ; } else if ( isHttpAlias ( scheme ) ) { StringBuilder sb = new StringBuilder ( 5 + tail . length ( ) ) ; sb . append ( "http:" ) . append ( tail ) ; iri = fac . construct ( trimHtmlTrailingSpaces ( sb . toString ( ) ) ) ; } else { StringBuilder sb = new StringBuilder ( 2 + literal . length ( ) ) ; sb . append ( "x-" ) . append ( literal ) ; iri = fac . construct ( trimHtmlTrailingSpaces ( sb . toString ( ) ) ) ; } } } catch ( IRIException e ) { Violation v = e . getViolation ( ) ; KnownViolationCode vc = KnownViolationCode . valueOf ( "ZZZ_DUMMY_DEFAULT" ) ; try { vc = KnownViolationCode . valueOf ( v . codeName ( ) ) ; } catch ( Exception ex ) { } switch ( vc ) { case HAS_PASSWORD : if ( WARN ) { throw newDatatypeException ( underbarStringToSentence ( v . component ( ) ) + " component contains a password." , WARN ) ; } else { return ; } case NON_INITIAL_DOT_SEGMENT : if ( WARN ) { throw newDatatypeException ( "Path component contains a segment “/../” not at the beginning of a relative reference, or it contains a “/./”. These should be removed." , WARN ) ; } else { return ; } case PORT_SHOULD_NOT_BE_WELL_KNOWN : if ( WARN ) { throw newDatatypeException ( "Ports under 1024 should be accessed using the appropriate scheme name." , WARN ) ; } else { return ; } case COMPATIBILITY_CHARACTER : if ( WARN ) { throw newDatatypeException ( underbarStringToSentence ( v . codeName ( ) ) + " in " + toAsciiLowerCase ( v . component ( ) ) + " component." , WARN ) ; } else { return ; } case DNS_LABEL_DASH_START_OR_END : throw newDatatypeException ( "Host component contains a DNS name with a “-” (dash) character at the beginning or end." ) ; case DOUBLE_WHITESPACE : case WHITESPACE : throw newDatatypeException ( "Whitespace in " + toAsciiLowerCase ( v . component ( ) ) + " component. " + "Use “%20” in place of spaces." ) ; case EMPTY_SCHEME : throw newDatatypeException ( "Scheme component is empty." ) ; case ILLEGAL_PERCENT_ENCODING : throw newDatatypeException ( underbarStringToSentence ( v . component ( ) ) + " component contains a percent sign that is not followed by two hexadecimal digits." ) ; case IP_V4_HAS_FOUR_COMPONENTS : throw newDatatypeException ( "Host component is entirely numeric but does not have four components like an IPv4 address." ) ; case IP_V4_OCTET_RANGE : throw newDatatypeException ( "Host component contains a number not in the range 0-255, or a number with a leading zero." ) ; case IP_V6_OR_FUTURE_ADDRESS_SYNTAX : throw newDatatypeException ( "Host component contains an IPv6 (or IPvFuture) syntax violation." ) ; case NOT_DNS_NAME : throw newDatatypeException ( "Host component did not meet the restrictions on DNS names." ) ; case REQUIRED_COMPONENT_MISSING : throw newDatatypeException ( "A component that is required by the scheme is missing." ) ; case SCHEME_MUST_START_WITH_LETTER : throw newDatatypeException ( "Scheme component must start with a letter." ) ; case UNREGISTERED_NONIETF_SCHEME_TREE : throw newDatatypeException ( "Scheme component has a “-” (dash) character, but does not start with “x-”, and the prefix is not known as the prefix of an alternative tree for URI schemes." ) ; case CONTROL_CHARACTER : case ILLEGAL_CHARACTER : case UNDEFINED_UNICODE_CHARACTER : case UNICODE_WHITESPACE : throw newDatatypeException ( underbarStringToSentence ( v . codeName ( ) ) + " in " + toAsciiLowerCase ( v . component ( ) ) + " component." ) ; default : throw newDatatypeException ( v . codeName ( ) + " in " + toAsciiLowerCase ( v . component ( ) ) + " component." ) ; } } catch ( IOException e ) { throw newDatatypeException ( e . getMessage ( ) ) ; } catch ( RhinoException e ) { throw newDatatypeException ( e . getMessage ( ) ) ; } if ( isAbsolute ( ) ) { if ( iri != null && ! iri . isAbsolute ( ) ) { throw newDatatypeException ( "Not an absolute IRI." ) ; } } if ( iri != null ) { if ( "" . equals ( iri . toString ( ) ) ) { throw newDatatypeException ( "Must be non-empty." ) ; } if ( data ) { try { DataUri dataUri = new DataUri ( iri ) ; InputStream is = dataUri . getInputStream ( ) ; while ( is . read ( ) >= 0 ) { } } catch ( DataUriException e ) { throw newDatatypeException ( e . getIndex ( ) , e . getHead ( ) , e . getLiteral ( ) , e . getTail ( ) ) ; } catch ( IOException e ) { throw newDatatypeException ( e . getMessage ( ) ) ; } } } } private final boolean isHttpAlias ( CharSequence scheme ) { return "feed" . contentEquals ( scheme ) || "webcal" . contentEquals ( scheme ) ; } private final boolean isWellKnown ( CharSequence scheme ) { return "http" . contentEquals ( scheme ) || "https" . contentEquals ( scheme ) || "ftp" . contentEquals ( scheme ) || "mailto" . contentEquals ( scheme ) || "file" . contentEquals ( scheme ) ; } protected boolean isAbsolute ( ) { return false ; } protected static final String underbarStringToSentence ( String str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; buf [ 0 ] = str . charAt ( 0 ) ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' ) { c += 0x20 ; } else if ( c == 0x5f ) { c = 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } protected static final String trimHtmlSpaces ( String str ) { return trimHtmlLeadingSpaces ( trimHtmlTrailingSpaces ( str ) ) ; } protected static final String trimHtmlLeadingSpaces ( String str ) { if ( str == null ) { return null ; } for ( int i = str . length ( ) ; i > 0 ; -- i ) { char c = str . charAt ( str . length ( ) - i ) ; if ( ! ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) ) { return str . substring ( str . length ( ) - i , str . length ( ) ) ; } } return "" ; } protected static final String trimHtmlTrailingSpaces ( String str ) { if ( str == null ) { return null ; } for ( int i = str . length ( ) - 1 ; i >= 0 ; -- i ) { char c = str . charAt ( i ) ; if ( ! ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) ) { return str . substring ( 0 , i + 1 ) ; } } return "" ; } @ Override public String getName ( ) { return "IRI reference" ; } private class CharSequencePair { private final CharSequence head ; private final CharSequence tail ; public CharSequencePair ( final CharSequence head , final CharSequence tail ) { this . head = head ; this . tail = tail ; } public CharSequence getHead ( ) { return head ; } public CharSequence getTail ( ) { return tail ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
