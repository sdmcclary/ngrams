public class MatchablePatternLoader { public static final int COMPACT_SYNTAX_FLAG = 0x1 ; public static final int FEASIBLE_FLAG = 0x2 ; public MatchablePattern load ( Input input , SAXResolver saxResolver , ErrorHandler eh , DatatypeLibraryFactory dlf , int flags ) throws IOException , SAXException , IncorrectSchemaException { SchemaPatternBuilder spb = new SchemaPatternBuilder ( ) ; Parseable < Pattern , com . thaiopensource . relaxng . pattern . NameClass , Locator , VoidValue , CommentListImpl , AnnotationsImpl > parseable ; if ( ( flags & COMPACT_SYNTAX_FLAG ) != 0 ) parseable = new CompactParseable < Pattern , NameClass , Locator , VoidValue , CommentListImpl , AnnotationsImpl > ( input , saxResolver . getResolver ( ) , eh ) ; else parseable = new SAXParseable < Pattern , NameClass , Locator , VoidValue , CommentListImpl , AnnotationsImpl > ( saxResolver . createSAXSource ( input ) , saxResolver , eh ) ; if ( dlf == null ) dlf = new DatatypeLibraryLoader ( ) ; try { Pattern start = SchemaBuilderImpl . parse ( parseable , eh , dlf , spb , false ) ; if ( ( flags & FEASIBLE_FLAG ) != 0 ) start = FeasibleTransform . transform ( spb , start ) ; return new MatchablePatternImpl ( spb , start ) ; } catch ( IllegalSchemaException e ) { throw new IncorrectSchemaException ( ) ; } } } 