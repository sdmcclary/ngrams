public class StubJndiContext extends TestFixture { private static final Logger logger = Logger . getLogger ( StubJndiContext . class . getCanonicalName ( ) ) ; private final Map < String , Object > boundObjects = new HashMap < String , Object > ( ) ; private boolean closed ; private class StubContextFactoryBuilder implements InitialContextFactoryBuilder { @ Override public InitialContextFactory createInitialContextFactory ( final Hashtable < ? , ? > environment ) throws NamingException { return new InitialContextFactory ( ) { @ Override public Context getInitialContext ( final Hashtable < ? , ? > environment ) throws NamingException { return new StubContext ( environment ) ; } } ; } } public final void bind ( final String name , final Object obj ) { boundObjects . put ( name , obj ) ; logger . finest ( "Bound " + obj . getClass ( ) . getCanonicalName ( ) + "@" + System . identityHashCode ( obj ) + " to \"" + name + "\"" ) ; } @ Override protected final void setUp ( ) throws Throwable { logger . info ( "Activating stub JNDI context" ) ; if ( ! NamingManager . hasInitialContextFactoryBuilder ( ) ) { try { NamingManager . setInitialContextFactoryBuilder ( new StubContextFactoryBuilder ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e . getClass ( ) . getCanonicalName ( ) + " attempting to activate StubJndiContextBuilder" , e ) ; } } } public final boolean wasClosed ( ) { return closed ; } private class StubContext implements Context { private final Hashtable < String , Object > environment ; public StubContext ( final Hashtable < ? , ? > environment ) { this . environment = new Hashtable < String , Object > ( ) ; if ( environment != null && ! environment . isEmpty ( ) ) { for ( final Entry < ? , ? > entry : environment . entrySet ( ) ) { this . environment . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } } } @ Override public Object addToEnvironment ( final String propName , final Object propVal ) throws NamingException { return environment . put ( propName , propVal ) ; } @ Override public void bind ( final String name , final Object obj ) throws NamingException { boundObjects . put ( name , obj ) ; logger . finest ( "Bound \"" + name + "\" to " + obj . getClass ( ) . getCanonicalName ( ) + "@" + System . identityHashCode ( obj ) ) ; } @ Override public void close ( ) throws NamingException { closed = true ; } @ Override public String composeName ( final String name , final String prefix ) throws NamingException { return prefix + name ; } @ Override public Context createSubcontext ( final String name ) throws NamingException { throw notSupported ( ) ; } @ Override public void destroySubcontext ( final String name ) throws NamingException { } @ Override public Hashtable < ? , ? > getEnvironment ( ) throws NamingException { return this . environment ; } @ Override public NamingEnumeration < NameClassPair > list ( final String name ) throws NamingException { return null ; } @ Override public NamingEnumeration < Binding > listBindings ( final String name ) throws NamingException { throw notSupported ( ) ; } @ Override public Object lookup ( final String name ) throws NamingException { final Object o = boundObjects . get ( name ) ; if ( o != null ) { logger . finest ( "lookup(\"" + name + "\") returning " + o . getClass ( ) . getCanonicalName ( ) + "@" + System . identityHashCode ( o ) ) ; } else { logger . finest ( "lookup(\"" + name + "\") returning null" ) ; } return o ; } @ Override public Object lookupLink ( final String name ) throws NamingException { throw notSupported ( ) ; } @ Override public void rebind ( final String name , final Object obj ) throws NamingException { boundObjects . put ( name , obj ) ; } @ Override public Object removeFromEnvironment ( final String propName ) throws NamingException { return environment . remove ( propName ) ; } @ Override public void rename ( final String oldName , final String newName ) throws NamingException { if ( ! boundObjects . containsKey ( oldName ) ) { throw new NamingException ( "StubJndiContext namme \"" + oldName + "\" not bound!" ) ; } if ( boundObjects . containsKey ( newName ) ) { throw new NamingException ( "StubJndiContext name \"" + oldName + "\" already bound to object of type: " + boundObjects . get ( newName ) . getClass ( ) . getCanonicalName ( ) ) ; } final Object obj = boundObjects . remove ( oldName ) ; boundObjects . put ( newName , obj ) ; } @ Override public void unbind ( final String name ) throws NamingException { throw notSupported ( ) ; } @ Override public void bind ( final Name name , final Object obj ) throws NamingException { throw notSupported ( ) ; } @ Override public Name composeName ( final Name name , final Name prefix ) throws NamingException { throw notSupported ( ) ; } @ Override public Context createSubcontext ( final Name name ) throws NamingException { throw notSupported ( ) ; } @ Override public void destroySubcontext ( final Name name ) throws NamingException { throw notSupported ( ) ; } @ Override public String getNameInNamespace ( ) throws NamingException { throw notSupported ( ) ; } @ Override public NameParser getNameParser ( final Name name ) throws NamingException { throw notSupported ( ) ; } @ Override public NameParser getNameParser ( final String name ) throws NamingException { throw notSupported ( ) ; } @ Override public NamingEnumeration < NameClassPair > list ( final Name name ) throws NamingException { throw notSupported ( ) ; } @ Override public NamingEnumeration < Binding > listBindings ( final Name name ) throws NamingException { throw notSupported ( ) ; } @ Override public Object lookup ( final Name name ) throws NamingException { throw notSupported ( ) ; } @ Override public Object lookupLink ( final Name name ) throws NamingException { throw notSupported ( ) ; } @ Override public void rebind ( final Name name , final Object obj ) throws NamingException { throw notSupported ( ) ; } @ Override public void rename ( final Name oldName , final Name newName ) throws NamingException { throw notSupported ( ) ; } @ Override public void unbind ( final Name name ) throws NamingException { throw notSupported ( ) ; } } public static UnsupportedOperationException notSupported ( ) { final StackTraceElement [ ] unwound = unwindStackTrace ( Thread . currentThread ( ) . getStackTrace ( ) ) ; final UnsupportedOperationException e = new UnsupportedOperationException ( "StubJndiContext." + unwound [ 0 ] . getMethodName ( ) + " is not supported!" ) ; e . setStackTrace ( unwound ) ; return e ; } private static StackTraceElement [ ] unwindStackTrace ( final StackTraceElement [ ] st ) { final int len = st . length ; int i = 0 ; final String stubJndiContext = StubJndiContext . class . getName ( ) ; while ( i < len && ! st [ i ] . getClassName ( ) . equals ( stubJndiContext ) ) { ++ i ; } i += 2 ; final int rest = len - i ; final StackTraceElement [ ] unwound = new StackTraceElement [ rest ] ; System . arraycopy ( st , i , unwound , 0 , rest ) ; return unwound ; } } 