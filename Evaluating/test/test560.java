public class RESTServiceProvider implements IServiceProvider , ILoggable { public static interface Listener { public void authenticationFailed ( User user ) ; public void correctAuthentication ( ) ; } public static final String DEBUG_HOST ; private static final String PROPERTY_KEY = "SiteManagerSelection" ; static { IEclipsePreferences prefs = ( new DefaultScope ( ) ) . getNode ( ResourcesPlugin . PI_RESOURCES ) ; prefs . putBoolean ( PROPERTY_KEY , true ) ; boolean useProduction = true ; if ( useProduction ) { String debugHost = System . getProperty ( "DEBUG_HOST" ) ; if ( debugHost == null || debugHost . length ( ) == 0 ) { debugHost = "cloudmanager.aptana.com" ; } DEBUG_HOST = debugHost ; } else { DEBUG_HOST = "acotak-staging.aptana.com" ; } } public static final String LOCATION_HEADER = "Location" ; public static final String AUTHORIZATION_HEADER = "Aptana-Authorization" ; public static final String CONTENT_TYPE_HEADER = "Content-Type" ; public static final String ACCEPT_HEADER = "Accept" ; private SSLContext sslContext ; private ILogger logger ; private static List < Listener > listeners = new ArrayList < Listener > ( ) ; public RESTServiceProvider ( ) { this . logger = new LoggerAdapater ( ) { public void logError ( String message ) { AptanaCorePlugin . getDefault ( ) . getLog ( ) . log ( new Status ( IStatus . ERROR , AptanaCorePlugin . ID , 1 , message , null ) ) ; } } ; try { if ( DEBUG_HOST != null ) { TrustManager [ ] trustAllCerts = new TrustManager [ ] { new X509TrustManager ( ) { public java . security . cert . X509Certificate [ ] getAcceptedIssuers ( ) { return null ; } public void checkClientTrusted ( java . security . cert . X509Certificate [ ] certs , String authType ) { } public void checkServerTrusted ( java . security . cert . X509Certificate [ ] certs , String authType ) { for ( int i = 0 ; i < certs . length ; i ++ ) { String issuer = certs [ i ] . getIssuerDN ( ) . getName ( ) ; if ( issuer . trim ( ) . equals ( "EMAILADDRESS=cwilliams@aptana.com, CN=" + DEBUG_HOST + ", OU=Aptana Cloud, O=\"Aptana, Inc.\", L=San Mateo, ST=California, C=US" ) ) { return ; } } } } } ; sslContext = SSLContext . getInstance ( "SSL" ) ; sslContext . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; } } catch ( Exception e ) { logMessage ( e . getMessage ( ) ) ; sslContext = null ; } } public static void addListener ( Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } } public static void removeListener ( Listener listener ) { listeners . remove ( listener ) ; } private void fireAuthenticationFailed ( User user ) { for ( Listener listener : listeners ) { listener . authenticationFailed ( user ) ; } } private void fireCorrectAuthentication ( ) { for ( Listener listener : listeners ) { listener . correctAuthentication ( ) ; } } private IServiceResponse getResponse ( URLConnection rawResponse ) { int status = IServiceResponse . STATUS_UNSET ; IServiceResponse response = null ; try { if ( rawResponse instanceof HttpURLConnection ) { try { status = ( ( HttpURLConnection ) rawResponse ) . getResponseCode ( ) ; URLStatusTracker . getInstance ( ) . setStatus ( rawResponse . getURL ( ) , status ) ; } catch ( IOException e ) { if ( ! ( e instanceof UnknownHostException ) ) { logMessage ( "Error occured reading status from response for location: " + rawResponse . getURL ( ) + " " + e . getMessage ( ) ) ; } throw e ; } } if ( status == IServiceResponse . STATUS_UNAUTHORIZED ) { User signedInUser = AptanaUser . getSignedInUser ( ) ; if ( signedInUser != null && signedInUser . hasCredentials ( ) ) { fireAuthenticationFailed ( signedInUser ) ; IdeLog . logImportant ( AptanaCorePlugin . getDefault ( ) , Messages . getString ( "RESTServiceProvider.AuthenticationFailedSigningOut" ) ) ; AptanaUser . signOut ( ) ; return new SimpleServiceResponse ( "" , "" , "" , IServiceResponse . STATUS_UNAUTHORIZED ) ; } } String location = rawResponse . getHeaderField ( LOCATION_HEADER ) ; if ( location != null ) { try { response = new SimpleServiceResponse ( rawResponse . getContentType ( ) , location , new URL ( location ) , status ) ; logMessage ( "Location found in response: " + location ) ; } catch ( MalformedURLException e ) { logMessage ( "Error creating URL from Location header: " + location ) ; } } else { try { String responseBody = null ; if ( rawResponse instanceof HttpURLConnection ) { responseBody = getResponseBody ( ( HttpURLConnection ) rawResponse ) ; } else { responseBody = getResponseBody ( rawResponse . getInputStream ( ) ) ; } response = new SimpleServiceResponse ( rawResponse . getContentType ( ) , responseBody , responseBody , status ) ; } catch ( IOException e ) { throw e ; } } } catch ( UnknownHostException uhe ) { return new SimpleServiceResponse ( "" , "" , "" , IServiceResponse . STATUS_UNKNOWN_HOST ) ; } catch ( IOException e ) { logMessage ( "IOException on getResponse for location: " + rawResponse . getURL ( ) + " " + e . getMessage ( ) ) ; if ( rawResponse instanceof HttpURLConnection ) { try { InputStream stream = ( ( HttpURLConnection ) rawResponse ) . getErrorStream ( ) ; if ( stream != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; StringBuffer buffer = new StringBuffer ( ) ; String line = reader . readLine ( ) ; while ( line != null ) { buffer . append ( line ) ; buffer . append ( '\n' ) ; line = reader . readLine ( ) ; } response = new SimpleServiceResponse ( rawResponse . getContentType ( ) , buffer . toString ( ) , buffer . toString ( ) , status ) ; } } catch ( Exception e1 ) { logMessage ( "Error reading error stream from response for location: " + rawResponse . getURL ( ) + " " + e . getMessage ( ) ) ; } } } appendResponseLossage ( rawResponse , response ) ; return response ; } private String getResponseBody ( HttpURLConnection rawResponse ) throws IOException { try { return getResponseBody ( rawResponse . getInputStream ( ) ) ; } catch ( IOException e ) { logMessage ( "Error occured reading from response stream for location: " + rawResponse . getURL ( ) + " " + e . getMessage ( ) ) ; } try { return getResponseBody ( rawResponse . getErrorStream ( ) ) ; } catch ( IOException e ) { logMessage ( "Error occured reading from response error stream for location: " + rawResponse . getURL ( ) + " " + e . getMessage ( ) ) ; throw e ; } } private String getResponseBody ( InputStream stream ) throws IOException { if ( stream == null ) { return "" ; } StringBuffer buffer = new StringBuffer ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; String line ; line = reader . readLine ( ) ; while ( line != null ) { buffer . append ( line ) ; buffer . append ( '\n' ) ; line = reader . readLine ( ) ; } } catch ( IOException e ) { throw e ; } finally { try { if ( reader != null ) reader . close ( ) ; } catch ( IOException e ) { } } return buffer . toString ( ) ; } private void logMessage ( String message ) { if ( getLogger ( ) != null ) { getLogger ( ) . logError ( message ) ; } } public int getTimeout ( ) { return 40000 ; } public ILogger getLogger ( ) { return this . logger ; } public void setLogger ( ILogger logger ) { this . logger = logger ; } public IServiceResponse callService ( URL location , IServiceRequest request ) { try { if ( sslContext != null ) { HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ( ) ) ; } } catch ( Exception e ) { logMessage ( e . getMessage ( ) ) ; } if ( request == null ) { return null ; } appendRequestLossage ( location , request ) ; URLConnection connection = null ; IServiceResponse response = null ; try { fireCorrectAuthentication ( ) ; connection = location . openConnection ( ) ; connection . setUseCaches ( false ) ; connection . setConnectTimeout ( getTimeout ( ) ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConn = ( HttpURLConnection ) connection ; connection . setReadTimeout ( getTimeout ( ) ) ; connection . setDoInput ( true ) ; httpConn . addRequestProperty ( "Cache-Control" , "no-cache" ) ; if ( request . getRequestType ( ) != null ) { httpConn . setRequestMethod ( request . getRequestType ( ) ) ; } if ( request . getAuthentication ( ) != null ) { connection . addRequestProperty ( AUTHORIZATION_HEADER , request . getAuthentication ( ) ) ; } if ( request . getContentType ( ) != null ) { connection . addRequestProperty ( CONTENT_TYPE_HEADER , request . getContentType ( ) ) ; } if ( request . getAccept ( ) != null ) { connection . addRequestProperty ( ACCEPT_HEADER , request . getAccept ( ) ) ; } Map < String , String > requestProperties = request . getRequestProperties ( ) ; if ( requestProperties != null ) { for ( String name : requestProperties . keySet ( ) ) { connection . addRequestProperty ( name , requestProperties . get ( name ) ) ; } } if ( request . containsBody ( ) ) { connection . setDoOutput ( true ) ; OutputStream outputStream = connection . getOutputStream ( ) ; OutputStreamWriter writer = null ; if ( "application/xml" . equals ( request . getContentType ( ) ) ) { writer = new OutputStreamWriter ( outputStream , "UTF-8" ) ; } else { writer = new OutputStreamWriter ( outputStream ) ; } writer . write ( request . getContents ( ) + "\n" ) ; writer . flush ( ) ; } } } catch ( Exception e ) { logMessage ( "Error occured streaming request:" + e . getMessage ( ) ) ; } if ( connection != null ) { response = getResponse ( connection ) ; } return response ; } private static int maxLossageSize = Integer . getInteger ( "com.aptana.ide.core.model.maxLossageSize" , 524288 ) ; private static StringBuffer lossage = new StringBuffer ( ) ; public static String getLossage ( ) { return lossage . toString ( ) ; } private void appendRequestLossage ( URL location , IServiceRequest request ) { if ( location != null ) { appendlnLossage ( "Request URL: " + location ) ; } if ( request != null ) { appendlnLossage ( "Request Type: " + request . getRequestType ( ) ) ; appendlnLossage ( "Request Content Type: " + request . getContentType ( ) ) ; appendlnLossage ( "Request Authentication: " + request . getAuthentication ( ) ) ; appendlnLossage ( "Request Accept: " + request . getAccept ( ) ) ; if ( request . containsBody ( ) ) { String contents = request . getContents ( ) ; if ( contents != null ) { appendlnLossage ( "Request Body:" ) ; appendlnLossage ( StringUtils . getPublishableMessage ( request . getContents ( ) ) ) ; } } } } private void appendResponseLossage ( URLConnection rawResponse , IServiceResponse response ) { if ( rawResponse != null ) { appendlnLossage ( "Response Request URL: " + rawResponse . getURL ( ) ) ; appendlnLossage ( "Response Content Type: " + rawResponse . getContentType ( ) ) ; appendlnLossage ( "Response Content Length: " + rawResponse . getContentLength ( ) ) ; appendlnLossage ( "Response Content Encoding: " + rawResponse . getContentEncoding ( ) ) ; appendlnLossage ( "Response Date: " + rawResponse . getDate ( ) ) ; appendlnLossage ( "Response Last Modified: " + rawResponse . getLastModified ( ) ) ; appendlnLossage ( "Response Expiration: " + rawResponse . getExpiration ( ) ) ; appendlnLossage ( "Response If Modified Since: " + rawResponse . getIfModifiedSince ( ) ) ; Map < String , List < String > > headerFields = rawResponse . getHeaderFields ( ) ; for ( String fieldName : headerFields . keySet ( ) ) { appendlnLossage ( "Response Header field '" + fieldName + "'=" + headerFields . get ( fieldName ) ) ; } appendlnLossage ( "Response Connect Timeout: " + rawResponse . getConnectTimeout ( ) ) ; } if ( response != null ) { appendlnLossage ( "Response Status: " + response . getStatus ( ) ) ; appendlnLossage ( "Response Content Type: " + response . getContentType ( ) ) ; String contents = response . getContents ( ) ; if ( contents != null ) { appendlnLossage ( "Response Content:" ) ; appendlnLossage ( StringUtils . getPublishableMessage ( contents ) ) ; } } } private void appendlnLossage ( String appendix ) { appendLossage ( appendix + "\n" ) ; } private void appendLossage ( String appendix ) { int length = appendix . length ( ) ; if ( length > maxLossageSize ) { lossage . setLength ( 0 ) ; lossage . append ( appendix . substring ( length - maxLossageSize ) ) ; } else { int lossageLength = lossage . length ( ) ; int totalLength = lossageLength + length ; if ( totalLength > maxLossageSize ) { lossage . delete ( 0 , totalLength - maxLossageSize ) ; lossage . append ( appendix ) ; } else { lossage . append ( appendix ) ; } } } } 