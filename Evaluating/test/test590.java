<<<<<<< HEAD
public class FoldingPreferencePage extends com . aptana . ide . editors . preferences . FoldingPreferencePage { private Table foldingTable ; private Group nodeGroup ; private Composite buttons ; private Button add ; private Button remove ; protected Control createContents ( Composite parent ) { final Composite displayArea = ( Composite ) super . createContents ( parent ) ; nodeGroup = new Group ( displayArea , SWT . NONE ) ; GridLayout groupLayout = new GridLayout ( 1 , true ) ; nodeGroup . setLayout ( groupLayout ) ; nodeGroup . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; nodeGroup . setText ( Messages . FoldingPreferencePage_FoldableHTMLNodes ) ; buttons = new Composite ( nodeGroup , SWT . NONE ) ; GridLayout buttonsLayout = new GridLayout ( 2 , true ) ; buttonsLayout . marginHeight = 0 ; buttonsLayout . marginWidth = 0 ; buttons . setLayout ( buttonsLayout ) ; add = new Button ( buttons , SWT . PUSH ) ; add . setImage ( HTMLPlugin . getImage ( "icons/add_obj.gif" ) ) ; add . setToolTipText ( Messages . FoldingPreferencePage_Add_One_Or_Mode_Tooltip ) ; add . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { InputDialog dialog = new InputDialog ( getShell ( ) , Messages . FoldingPreferencePage_AddFoldableNodes , Messages . FoldingPreferencePage_AddFoldableNodesDesc , null , null ) ; int rc = dialog . open ( ) ; if ( rc == InputDialog . OK ) { String newNodes = dialog . getValue ( ) ; String [ ] nodes = newNodes . split ( "," ) ; List nodeList = new ArrayList ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { String trimmed = nodes [ i ] . trim ( ) ; if ( trimmed . length ( ) > 0 ) { nodeList . add ( trimmed ) ; } } TableItem [ ] items = foldingTable . getItems ( ) ; for ( int i = 0 ; items != null && i < items . length ; i ++ ) { if ( ! nodeList . contains ( items [ i ] . getText ( ) ) ) { nodeList . add ( items [ i ] . getText ( ) ) ; } } Collections . sort ( nodeList ) ; foldingTable . removeAll ( ) ; for ( int i = 0 ; i < nodeList . size ( ) ; i ++ ) { TableItem item = new TableItem ( foldingTable , SWT . LEFT ) ; item . setText ( ( String ) nodeList . get ( i ) ) ; item . setImage ( HTMLPlugin . getImage ( "icons/element_icon.gif" ) ) ; } } } } ) ; remove = new Button ( buttons , SWT . PUSH ) ; remove . setImage ( HTMLPlugin . getImage ( "icons/delete_obj.gif" ) ) ; remove . setToolTipText ( Messages . FoldingPreferencePage_RemoveSelectedNode ) ; remove . setEnabled ( false ) ; remove . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { TableItem [ ] items = foldingTable . getSelection ( ) ; int [ ] indices = foldingTable . getSelectionIndices ( ) ; if ( items != null ) { for ( int i = 0 ; i < items . length ; i ++ ) { items [ i ] . dispose ( ) ; } if ( indices . length > 1 ) { int last = indices [ indices . length - 1 ] ; if ( foldingTable . getItemCount ( ) - 1 >= last ) { foldingTable . setSelection ( last ) ; } else if ( foldingTable . getItemCount ( ) > 0 ) { foldingTable . setSelection ( foldingTable . getItemCount ( ) - 1 ) ; } } else if ( indices . length == 1 ) { if ( foldingTable . getItemCount ( ) - 1 >= indices [ 0 ] ) { foldingTable . setSelection ( indices [ 0 ] ) ; } else if ( foldingTable . getItemCount ( ) > 0 ) { foldingTable . setSelection ( foldingTable . getItemCount ( ) - 1 ) ; } } } remove . setEnabled ( foldingTable . getSelectionCount ( ) > 0 ) ; } } ) ; buttons . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , false ) ) ; foldingTable = new Table ( nodeGroup , SWT . MULTI | SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER ) ; foldingTable . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; foldingTable . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { remove . setEnabled ( true ) ; } } ) ; String foldedNodeList = HTMLPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IPreferenceConstants . FOLDING_HTML_NODE_LIST ) ; String [ ] nodes = foldedNodeList . split ( "," ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { TableItem item = new TableItem ( foldingTable , SWT . LEFT ) ; item . setText ( nodes [ i ] . trim ( ) ) ; item . setImage ( HTMLPlugin . getImage ( "icons/element_icon.gif" ) ) ; } return displayArea ; } protected void performDefaults ( ) { foldingTable . removeAll ( ) ; String foldedNodeList = HTMLPlugin . getDefault ( ) . getPreferenceStore ( ) . getDefaultString ( IPreferenceConstants . FOLDING_HTML_NODE_LIST ) ; String [ ] nodes = foldedNodeList . split ( "," ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { TableItem item = new TableItem ( foldingTable , SWT . LEFT ) ; item . setText ( nodes [ i ] . trim ( ) ) ; item . setImage ( HTMLPlugin . getImage ( "icons/element_icon.gif" ) ) ; } super . performDefaults ( ) ; } public boolean performOk ( ) { String nodeListPref = "" ; for ( int i = 0 ; i < foldingTable . getItemCount ( ) ; i ++ ) { TableItem item = foldingTable . getItem ( i ) ; nodeListPref += item . getText ( ) + "," ; } HTMLPlugin . getDefault ( ) . getPreferenceStore ( ) . setValue ( IPreferenceConstants . FOLDING_HTML_NODE_LIST , nodeListPref ) ; return super . performOk ( ) ; } public void addInitialFoldingFields ( ) { } public String getLanguage ( ) { return HTMLMimeType . MimeType ; } public IPreferenceStore storeToInitialize ( ) { return HTMLPlugin . getDefault ( ) . getPreferenceStore ( ) ; } } 
=======
public class Circle extends AbstractInt { public static final Circle THE_INSTANCE = new Circle ( ) ; private Circle ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { List < CharSequenceWithOffset > list = split ( literal , ',' ) ; if ( list . size ( ) != 3 ) { throw newDatatypeException ( "A circle must have three comma-separated integers." ) ; } CharSequenceWithOffset withOffset = list . get ( 0 ) ; checkInt ( withOffset . getSequence ( ) , withOffset . getOffset ( ) ) ; withOffset = list . get ( 1 ) ; checkInt ( withOffset . getSequence ( ) , withOffset . getOffset ( ) ) ; withOffset = list . get ( 2 ) ; checkIntNonNegative ( withOffset . getSequence ( ) , withOffset . getOffset ( ) ) ; } @ Override public String getName ( ) { return "circle" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
