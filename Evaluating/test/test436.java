<<<<<<< HEAD
public class ConcurrentLinkedDeque < E > extends AbstractCollection < E > implements Deque < E > , java . io . Serializable { static final class Node < E > extends AtomicReference < Node < E > > { private volatile Node < E > prev ; final E element ; Node ( E element , Node < E > next , Node < E > prev ) { super ( next ) ; this . prev = prev ; this . element = element ; } Node ( Node < E > next ) { super ( next ) ; this . prev = this ; this . element = null ; } private Node < E > getNext ( ) { return get ( ) ; } void setNext ( Node < E > n ) { set ( n ) ; } private boolean casNext ( Node < E > cmp , Node < E > val ) { return compareAndSet ( cmp , val ) ; } private Node < E > getPrev ( ) { return prev ; } void setPrev ( Node < E > b ) { prev = b ; } boolean isSpecial ( ) { return element == null ; } boolean isTrailer ( ) { return getNext ( ) == null ; } boolean isHeader ( ) { return getPrev ( ) == null ; } boolean isMarker ( ) { return getPrev ( ) == this ; } boolean isDeleted ( ) { Node < E > f = getNext ( ) ; return f != null && f . isMarker ( ) ; } private Node < E > nextNonmarker ( ) { Node < E > f = getNext ( ) ; return ( f == null || ! f . isMarker ( ) ) ? f : f . getNext ( ) ; } Node < E > successor ( ) { Node < E > f = nextNonmarker ( ) ; for ( ; ; ) { if ( f == null ) return null ; if ( ! f . isDeleted ( ) ) { if ( f . getPrev ( ) != this && ! isDeleted ( ) ) f . setPrev ( this ) ; return f ; } Node < E > s = f . nextNonmarker ( ) ; if ( f == getNext ( ) ) casNext ( f , s ) ; f = s ; } } private Node < E > findPredecessorOf ( Node < E > target ) { Node < E > n = this ; for ( ; ; ) { Node < E > f = n . successor ( ) ; if ( f == target ) return n ; if ( f == null ) return null ; n = f ; } } Node < E > predecessor ( ) { Node < E > n = this ; for ( ; ; ) { Node < E > b = n . getPrev ( ) ; if ( b == null ) return n . findPredecessorOf ( this ) ; Node < E > s = b . getNext ( ) ; if ( s == this ) return b ; if ( s == null || ! s . isMarker ( ) ) { Node < E > p = b . findPredecessorOf ( this ) ; if ( p != null ) return p ; } n = b ; } } Node < E > forward ( ) { Node < E > f = successor ( ) ; return ( f == null || f . isSpecial ( ) ) ? null : f ; } Node < E > back ( ) { Node < E > f = predecessor ( ) ; return ( f == null || f . isSpecial ( ) ) ? null : f ; } Node < E > append ( E element ) { for ( ; ; ) { Node < E > f = getNext ( ) ; if ( f == null || f . isMarker ( ) ) return null ; Node < E > x = new Node < E > ( element , f , this ) ; if ( casNext ( f , x ) ) { f . setPrev ( x ) ; return x ; } } } Node < E > prepend ( E element ) { for ( ; ; ) { Node < E > b = predecessor ( ) ; if ( b == null ) return null ; Node < E > x = new Node < E > ( element , this , b ) ; if ( b . casNext ( this , x ) ) { setPrev ( x ) ; return x ; } } } boolean delete ( ) { Node < E > b = getPrev ( ) ; Node < E > f = getNext ( ) ; if ( b != null && f != null && ! f . isMarker ( ) && casNext ( f , new Node ( f ) ) ) { if ( b . casNext ( this , f ) ) f . setPrev ( b ) ; return true ; } return false ; } Node < E > replace ( E newElement ) { for ( ; ; ) { Node < E > b = getPrev ( ) ; Node < E > f = getNext ( ) ; if ( b == null || f == null || f . isMarker ( ) ) return null ; Node < E > x = new Node < E > ( newElement , f , b ) ; if ( casNext ( f , new Node ( x ) ) ) { b . successor ( ) ; x . successor ( ) ; return x ; } } } } private static boolean usable ( Node < ? > n ) { return n != null && ! n . isSpecial ( ) ; } private static void checkNullArg ( Object v ) { if ( v == null ) throw new NullPointerException ( ) ; } private E screenNullResult ( E v ) { if ( v == null ) throw new NoSuchElementException ( ) ; return v ; } private ArrayList < E > toArrayList ( ) { ArrayList < E > c = new ArrayList < E > ( ) ; for ( Node < E > n = header . forward ( ) ; n != null ; n = n . forward ( ) ) c . add ( n . element ) ; return c ; } private static final long serialVersionUID = 876323262645176354L ; private final Node < E > header ; private final Node < E > trailer ; public ConcurrentLinkedDeque ( ) { Node h = new Node ( null , null , null ) ; Node t = new Node ( null , null , h ) ; h . setNext ( t ) ; header = h ; trailer = t ; } public ConcurrentLinkedDeque ( Collection < ? extends E > c ) { this ( ) ; addAll ( c ) ; } public void addFirst ( E o ) { checkNullArg ( o ) ; while ( header . append ( o ) == null ) ; } public void addLast ( E o ) { checkNullArg ( o ) ; while ( trailer . prepend ( o ) == null ) ; } public boolean offerFirst ( E o ) { addFirst ( o ) ; return true ; } public boolean offerLast ( E o ) { addLast ( o ) ; return true ; } public E peekFirst ( ) { Node < E > n = header . successor ( ) ; return ( n == null ) ? null : n . element ; } public E peekLast ( ) { Node < E > n = trailer . predecessor ( ) ; return ( n == null ) ? null : n . element ; } public E getFirst ( ) { return screenNullResult ( peekFirst ( ) ) ; } public E getLast ( ) { return screenNullResult ( peekLast ( ) ) ; } public E pollFirst ( ) { for ( ; ; ) { Node < E > n = header . successor ( ) ; if ( ! usable ( n ) ) return null ; if ( n . delete ( ) ) return n . element ; } } public E pollLast ( ) { for ( ; ; ) { Node < E > n = trailer . predecessor ( ) ; if ( ! usable ( n ) ) return null ; if ( n . delete ( ) ) return n . element ; } } public E removeFirst ( ) { return screenNullResult ( pollFirst ( ) ) ; } public E removeLast ( ) { return screenNullResult ( pollLast ( ) ) ; } public boolean offer ( E e ) { return offerLast ( e ) ; } public boolean add ( E e ) { return offerLast ( e ) ; } public E poll ( ) { return pollFirst ( ) ; } public E remove ( ) { return removeFirst ( ) ; } public E peek ( ) { return peekFirst ( ) ; } public E element ( ) { return getFirst ( ) ; } public void push ( E e ) { addFirst ( e ) ; } public E pop ( ) { return removeFirst ( ) ; } public boolean removeFirstOccurrence ( Object o ) { checkNullArg ( o ) ; for ( ; ; ) { Node < E > n = header . forward ( ) ; for ( ; ; ) { if ( n == null ) return false ; if ( o . equals ( n . element ) ) { if ( n . delete ( ) ) return true ; else break ; } n = n . forward ( ) ; } } } public boolean removeLastOccurrence ( Object o ) { checkNullArg ( o ) ; for ( ; ; ) { Node < E > s = trailer ; for ( ; ; ) { Node < E > n = s . back ( ) ; if ( s . isDeleted ( ) || ( n != null && n . successor ( ) != s ) ) break ; if ( n == null ) return false ; if ( o . equals ( n . element ) ) { if ( n . delete ( ) ) return true ; else break ; } s = n ; } } } public boolean contains ( Object o ) { if ( o == null ) return false ; for ( Node < E > n = header . forward ( ) ; n != null ; n = n . forward ( ) ) if ( o . equals ( n . element ) ) return true ; return false ; } public boolean isEmpty ( ) { return ! usable ( header . successor ( ) ) ; } public int size ( ) { long count = 0 ; for ( Node < E > n = header . forward ( ) ; n != null ; n = n . forward ( ) ) ++ count ; return ( count >= Integer . MAX_VALUE ) ? Integer . MAX_VALUE : ( int ) count ; } public boolean remove ( Object o ) { return removeFirstOccurrence ( o ) ; } public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > it = c . iterator ( ) ; if ( ! it . hasNext ( ) ) return false ; do { addLast ( it . next ( ) ) ; } while ( it . hasNext ( ) ) ; return true ; } public void clear ( ) { while ( pollFirst ( ) != null ) ; } public Object [ ] toArray ( ) { return toArrayList ( ) . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] a ) { return toArrayList ( ) . toArray ( a ) ; } public Iterator < E > iterator ( ) { return new CLDIterator ( ) ; } final class CLDIterator implements Iterator < E > { Node < E > last ; Node < E > next = header . forward ( ) ; public boolean hasNext ( ) { return next != null ; } public E next ( ) { Node < E > l = last = next ; if ( l == null ) throw new NoSuchElementException ( ) ; next = next . forward ( ) ; return l . element ; } public void remove ( ) { Node < E > l = last ; if ( l == null ) throw new IllegalStateException ( ) ; while ( ! l . delete ( ) && ! l . isDeleted ( ) ) ; } } } 
=======
public abstract class AbstractDatatype implements Datatype { AbstractDatatype ( ) { super ( ) ; } public final boolean isValid ( String literal , ValidationContext context ) { try { checkValid ( literal ) ; } catch ( DatatypeException e ) { return false ; } return true ; } public void checkValid ( String literal , ValidationContext context ) throws DatatypeException { checkValid ( literal ) ; } public abstract void checkValid ( CharSequence literal ) throws DatatypeException ; public DatatypeStreamingValidator createStreamingValidator ( ValidationContext context ) { return new DatatypeStreamingValidatorImpl ( this ) ; } public Object createValue ( String literal , ValidationContext context ) { return literal ; } public final boolean sameValue ( Object value1 , Object value2 ) { if ( value1 == null ) { return ( value2 == null ) ; } return value1 . equals ( value2 ) ; } public final int valueHashCode ( Object value ) { return value . hashCode ( ) ; } public final int getIdType ( ) { return Datatype . ID_TYPE_NULL ; } public boolean isContextDependent ( ) { return false ; } protected final boolean isWhitespace ( char c ) { return c == ' ' || c == '\t' || c == '\f' || c == '\n' || c == '\r' ; } protected final boolean isAsciiDigit ( char c ) { return c >= '0' && c <= '9' ; } protected static final char toAsciiLowerCase ( char c ) { if ( c >= 'A' && c <= 'Z' ) { c += 0x20 ; } return c ; } protected static final String toAsciiLowerCase ( CharSequence str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' ) { c += 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } protected static final char toAsciiUpperCase ( char c ) { if ( c >= 'a' && c <= 'z' ) { c -= 0x20 ; } return c ; } protected static final String toAsciiUpperCase ( CharSequence str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'a' && c <= 'z' ) { c -= 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } protected DatatypeException newDatatypeException ( String message ) { return new Html5DatatypeException ( this . getClass ( ) , this . getName ( ) , message ) ; } protected DatatypeException newDatatypeException ( String head , String literal , String tail ) { return new Html5DatatypeException ( this . getClass ( ) , this . getName ( ) , head , literal , tail ) ; } protected DatatypeException newDatatypeException ( String head , char literal , String tail ) { return new Html5DatatypeException ( this . getClass ( ) , this . getName ( ) , head , String . valueOf ( literal ) , tail ) ; } protected DatatypeException newDatatypeException ( int position , String message ) { return new Html5DatatypeException ( position , this . getClass ( ) , this . getName ( ) , message ) ; } protected DatatypeException newDatatypeException ( int position , String head , String literal , String tail ) { return new Html5DatatypeException ( position , this . getClass ( ) , this . getName ( ) , head , literal , tail ) ; } protected DatatypeException newDatatypeException ( int position , String head , char literal , String tail ) { return new Html5DatatypeException ( position , this . getClass ( ) , this . getName ( ) , head , String . valueOf ( literal ) , tail ) ; } protected DatatypeException newDatatypeException ( String message , boolean warning ) { return new Html5DatatypeException ( this . getClass ( ) , this . getName ( ) , message , warning ) ; } protected DatatypeException newDatatypeException ( String head , String literal , String tail , boolean warning ) { return new Html5DatatypeException ( this . getClass ( ) , this . getName ( ) , head , literal , tail , warning ) ; } protected DatatypeException newDatatypeException ( String head , char literal , String tail , boolean warning ) { return new Html5DatatypeException ( this . getClass ( ) , this . getName ( ) , head , String . valueOf ( literal ) , tail , warning ) ; } protected DatatypeException newDatatypeException ( int position , String message , boolean warning ) { return new Html5DatatypeException ( position , this . getClass ( ) , this . getName ( ) , message , warning ) ; } protected DatatypeException newDatatypeException ( int position , String head , String literal , String tail , boolean warning ) { return new Html5DatatypeException ( position , this . getClass ( ) , this . getName ( ) , head , literal , tail , warning ) ; } protected DatatypeException newDatatypeException ( int position , String head , char literal , String tail , boolean warning ) { return new Html5DatatypeException ( position , this . getClass ( ) , this . getName ( ) , head , String . valueOf ( literal ) , tail , warning ) ; } public abstract String getName ( ) ; protected List < CharSequenceWithOffset > split ( CharSequence sequence , char delimiter ) { List < CharSequenceWithOffset > rv = new ArrayList < CharSequenceWithOffset > ( ) ; int offset = 0 ; for ( int i = 0 ; i < sequence . length ( ) ; i ++ ) { char c = sequence . charAt ( i ) ; if ( c == delimiter ) { rv . add ( new CharSequenceWithOffset ( sequence . subSequence ( offset , i ) , offset ) ) ; offset = i + 1 ; } } rv . add ( new CharSequenceWithOffset ( sequence . subSequence ( offset , sequence . length ( ) ) , offset ) ) ; return rv ; } protected class CharSequenceWithOffset { private final CharSequence sequence ; private final int offset ; public CharSequenceWithOffset ( final CharSequence sequence , final int offset ) { this . sequence = sequence ; this . offset = offset ; } public int getOffset ( ) { return offset ; } public CharSequence getSequence ( ) { return sequence ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
