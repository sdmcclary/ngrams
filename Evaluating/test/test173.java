<<<<<<< HEAD
public class Engine { private static final double MAX_PERCENTS = 100.0 ; private static final List < IHotLinkCriteria > FILTER_CRITERIA = new LinkedList < IHotLinkCriteria > ( ) ; private final GuidesSet set ; public Engine ( GuidesSet set ) { this . set = set ; } public List < HotLink > scan ( ) { return scan ( null ) ; } public List < HotLink > scan ( IProgressListener listener ) { Result res = new Result ( ) ; FeedsList fl = set . getFeedsList ( ) ; List < IFeed > feeds = fl . getFeeds ( ) ; double perc = MAX_PERCENTS / feeds . size ( ) ; int i = 0 ; for ( IFeed feed : feeds ) { if ( feed instanceof DataFeed ) scan ( feed , res ) ; i ++ ; if ( listener != null ) listener . onProgress ( ( int ) ( perc * i ) ) ; } return filter ( res . getHotLinks ( ) ) ; } private void scan ( IFeed feed , Result result ) { IArticle [ ] articles = feed . getArticles ( ) ; for ( IArticle article : articles ) { Date pubdate = article . getPublicationDate ( ) ; if ( ! DateUtils . olderThan ( pubdate , Constants . MILLIS_IN_DAY * 7 ) ) scan ( article , result ) ; } } private void scan ( IArticle article , Result result ) { Collection < String > links = article . getLinks ( ) ; for ( String link : links ) { result . register ( link , article ) ; } } public static class Result extends HashMap < String , HotLink > { public void register ( String urlS , IArticle article ) { urlS = urlS . trim ( ) . toLowerCase ( ) ; urlS = urlS . replaceAll ( "/+$" , "" ) ; try { URL base = article . getLink ( ) ; URL url = new URL ( base , urlS ) ; urlS = url . toString ( ) ; HotLink hl = get ( urlS ) ; if ( hl == null ) { hl = new HotLink ( url ) ; put ( urlS , hl ) ; } hl . add ( article ) ; } catch ( MalformedURLException e ) { } } public List < HotLink > getHotLinks ( ) { Collection < HotLink > hls = values ( ) ; List < HotLink > hlsl = new ArrayList < HotLink > ( hls ) ; Collections . sort ( hlsl ) ; return hlsl ; } } static void clearFilterCriteria ( ) { FILTER_CRITERIA . clear ( ) ; } public static void addFilterCriteria ( IHotLinkCriteria criteria ) { FILTER_CRITERIA . add ( criteria ) ; } static boolean matchesFilters ( HotLink link ) { for ( IHotLinkCriteria criteria : FILTER_CRITERIA ) { if ( criteria . matches ( link ) ) return true ; } return false ; } private List < HotLink > filter ( List < HotLink > links ) { List < HotLink > toRemove = new LinkedList < HotLink > ( ) ; for ( HotLink link : links ) { if ( matchesFilters ( link ) ) toRemove . add ( link ) ; } links . removeAll ( toRemove ) ; return links ; } public static class HotLink extends ArrayList < IArticle > implements Comparable { private final URL link ; private String pageTitle ; private int cumulativeFeedRating ; private int numberOfFeedRatings ; public HotLink ( URL link ) { this . link = link ; cumulativeFeedRating = 0 ; } public URL getLink ( ) { return link ; } @ Override public boolean add ( IArticle article ) { boolean added = false ; IFeed feed = article . getFeed ( ) ; if ( ! contains ( article ) && feed != null ) { added = super . add ( article ) ; int rating = feed . getRating ( ) ; if ( rating > - 1 ) { cumulativeFeedRating += rating + 1 ; numberOfFeedRatings ++ ; } } return added ; } public void setPageTitle ( String pageTitle ) { this . pageTitle = pageTitle ; } public String getTitle ( ) { return pageTitle == null ? link . toString ( ) : pageTitle ; } private double getAverateRating ( ) { return numberOfFeedRatings == 0 ? 0 : cumulativeFeedRating / numberOfFeedRatings ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; HotLink hotLink = ( HotLink ) o ; return link . toString ( ) . equals ( hotLink . link . toString ( ) ) ; } public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + link . toString ( ) . hashCode ( ) ; return result ; } public int compareTo ( Object o ) { if ( getClass ( ) != o . getClass ( ) ) throw new ClassCastException ( ) ; HotLink that = ( HotLink ) o ; Integer thisCount = size ( ) ; Integer thatCount = that . size ( ) ; int res = thatCount . compareTo ( thisCount ) ; if ( res == 0 ) { Double thisRating = getAverateRating ( ) ; Double thatRating = that . getAverateRating ( ) ; res = thatRating . compareTo ( thisRating ) ; if ( res == 0 ) res = getLink ( ) . toString ( ) . compareToIgnoreCase ( that . getLink ( ) . toString ( ) ) ; } return res ; } } } 
=======
class ValueDataDerivType extends DataDerivType { private final Datatype dt ; private final Name dtName ; private PatternMemo noValue ; private Map < DatatypeValue , PatternMemo > valueMap ; ValueDataDerivType ( Datatype dt , Name dtName ) { this . dt = dt ; this . dtName = dtName ; } DataDerivType copy ( ) { return new ValueDataDerivType ( dt , dtName ) ; } PatternMemo dataDeriv ( ValidatorPatternBuilder builder , Pattern p , String str , ValidationContext vc , List < DataDerivFailure > fail ) { Object value = dt . createValue ( str , vc ) ; if ( value == null ) { if ( noValue == null ) noValue = super . dataDeriv ( builder , p , str , vc , fail ) ; else if ( fail != null && noValue . isNotAllowed ( ) ) { try { dt . checkValid ( str , vc ) ; } catch ( DatatypeException e ) { fail . add ( new DataDerivFailure ( dt , dtName , e ) ) ; } } return noValue ; } else { DatatypeValue dtv = new DatatypeValue ( value , dt ) ; if ( valueMap == null ) valueMap = new HashMap < DatatypeValue , PatternMemo > ( ) ; PatternMemo tem = valueMap . get ( dtv ) ; if ( tem == null ) { tem = super . dataDeriv ( builder , p , str , vc , fail ) ; valueMap . put ( dtv , tem ) ; } else if ( tem . isNotAllowed ( ) && fail != null ) super . dataDeriv ( builder , p , str , vc , fail ) ; return tem ; } } DataDerivType combine ( DataDerivType ddt ) { if ( ddt instanceof ValueDataDerivType ) { if ( ( ( ValueDataDerivType ) ddt ) . dt == this . dt ) return this ; else return InconsistentDataDerivType . getInstance ( ) ; } else return ddt . combine ( this ) ; } Datatype getDatatype ( ) { return dt ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
