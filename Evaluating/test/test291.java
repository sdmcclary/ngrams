<<<<<<< HEAD
public class RSASHA1Verify { private static final Logger log = Logger . getLogger ( RSASHA1Verify . class ) ; public static RSAPublicKey decodeSSHRSAPublicKey ( byte [ ] key ) throws IOException { TypesReader tr = new TypesReader ( key ) ; String key_format = tr . readString ( ) ; if ( key_format . equals ( "ssh-rsa" ) == false ) throw new IllegalArgumentException ( "This is not a ssh-rsa public key" ) ; BigInteger e = tr . readMPINT ( ) ; BigInteger n = tr . readMPINT ( ) ; if ( tr . remain ( ) != 0 ) throw new IOException ( "Padding in RSA public key!" ) ; return new RSAPublicKey ( e , n ) ; } public static byte [ ] encodeSSHRSAPublicKey ( RSAPublicKey pk ) throws IOException { TypesWriter tw = new TypesWriter ( ) ; tw . writeString ( "ssh-rsa" ) ; tw . writeMPInt ( pk . getE ( ) ) ; tw . writeMPInt ( pk . getN ( ) ) ; return tw . getBytes ( ) ; } public static RSASignature decodeSSHRSASignature ( byte [ ] sig ) throws IOException { TypesReader tr = new TypesReader ( sig ) ; String sig_format = tr . readString ( ) ; if ( sig_format . equals ( "ssh-rsa" ) == false ) throw new IOException ( "Peer sent wrong signature format" ) ; byte [ ] s = tr . readByteString ( ) ; if ( s . length == 0 ) throw new IOException ( "Error in RSA signature, S is empty." ) ; if ( log . isEnabled ( ) ) { log . log ( 80 , "Decoding ssh-rsa signature string (length: " + s . length + ")" ) ; } if ( tr . remain ( ) != 0 ) throw new IOException ( "Padding in RSA signature!" ) ; return new RSASignature ( new BigInteger ( 1 , s ) ) ; } public static byte [ ] encodeSSHRSASignature ( RSASignature sig ) throws IOException { TypesWriter tw = new TypesWriter ( ) ; tw . writeString ( "ssh-rsa" ) ; byte [ ] s = sig . getS ( ) . toByteArray ( ) ; if ( ( s . length > 1 ) && ( s [ 0 ] == 0x00 ) ) tw . writeString ( s , 1 , s . length - 1 ) ; else tw . writeString ( s , 0 , s . length ) ; return tw . getBytes ( ) ; } public static RSASignature generateSignature ( byte [ ] message , RSAPrivateKey pk ) throws IOException { SHA1 md = new SHA1 ( ) ; md . update ( message ) ; byte [ ] sha_message = new byte [ md . getDigestLength ( ) ] ; md . digest ( sha_message ) ; byte [ ] der_header = new byte [ ] { 0x30 , 0x21 , 0x30 , 0x09 , 0x06 , 0x05 , 0x2b , 0x0e , 0x03 , 0x02 , 0x1a , 0x05 , 0x00 , 0x04 , 0x14 } ; int rsa_block_len = ( pk . getN ( ) . bitLength ( ) + 7 ) / 8 ; int num_pad = rsa_block_len - ( 2 + der_header . length + sha_message . length ) - 1 ; if ( num_pad < 8 ) throw new IOException ( "Cannot sign with RSA, message too long" ) ; byte [ ] sig = new byte [ der_header . length + sha_message . length + 2 + num_pad ] ; sig [ 0 ] = 0x01 ; for ( int i = 0 ; i < num_pad ; i ++ ) { sig [ i + 1 ] = ( byte ) 0xff ; } sig [ num_pad + 1 ] = 0x00 ; System . arraycopy ( der_header , 0 , sig , 2 + num_pad , der_header . length ) ; System . arraycopy ( sha_message , 0 , sig , 2 + num_pad + der_header . length , sha_message . length ) ; BigInteger m = new BigInteger ( 1 , sig ) ; BigInteger s = m . modPow ( pk . getD ( ) , pk . getN ( ) ) ; return new RSASignature ( s ) ; } public static boolean verifySignature ( byte [ ] message , RSASignature ds , RSAPublicKey dpk ) throws IOException { SHA1 md = new SHA1 ( ) ; md . update ( message ) ; byte [ ] sha_message = new byte [ md . getDigestLength ( ) ] ; md . digest ( sha_message ) ; BigInteger n = dpk . getN ( ) ; BigInteger e = dpk . getE ( ) ; BigInteger s = ds . getS ( ) ; if ( n . compareTo ( s ) <= 0 ) { log . log ( 20 , "ssh-rsa signature: n.compareTo(s) <= 0" ) ; return false ; } int rsa_block_len = ( n . bitLength ( ) + 7 ) / 8 ; if ( rsa_block_len < 1 ) { log . log ( 20 , "ssh-rsa signature: rsa_block_len < 1" ) ; return false ; } byte [ ] v = s . modPow ( e , n ) . toByteArray ( ) ; int startpos = 0 ; if ( ( v . length > 0 ) && ( v [ 0 ] == 0x00 ) ) startpos ++ ; if ( ( v . length - startpos ) != ( rsa_block_len - 1 ) ) { log . log ( 20 , "ssh-rsa signature: (v.length - startpos) != (rsa_block_len - 1)" ) ; return false ; } if ( v [ startpos ] != 0x01 ) { log . log ( 20 , "ssh-rsa signature: v[startpos] != 0x01" ) ; return false ; } int pos = startpos + 1 ; while ( true ) { if ( pos >= v . length ) { log . log ( 20 , "ssh-rsa signature: pos >= v.length" ) ; return false ; } if ( v [ pos ] == 0x00 ) break ; if ( v [ pos ] != ( byte ) 0xff ) { log . log ( 20 , "ssh-rsa signature: v[pos] != (byte) 0xff" ) ; return false ; } pos ++ ; } int num_pad = pos - ( startpos + 1 ) ; if ( num_pad < 8 ) { log . log ( 20 , "ssh-rsa signature: num_pad < 8" ) ; return false ; } pos ++ ; if ( pos >= v . length ) { log . log ( 20 , "ssh-rsa signature: pos >= v.length" ) ; return false ; } SimpleDERReader dr = new SimpleDERReader ( v , pos , v . length - pos ) ; byte [ ] seq = dr . readSequenceAsByteArray ( ) ; if ( dr . available ( ) != 0 ) { log . log ( 20 , "ssh-rsa signature: dr.available() != 0" ) ; return false ; } dr . resetInput ( seq ) ; byte digestAlgorithm [ ] = dr . readSequenceAsByteArray ( ) ; if ( ( digestAlgorithm . length < 8 ) || ( digestAlgorithm . length > 9 ) ) { log . log ( 20 , "ssh-rsa signature: (digestAlgorithm.length < 8) || (digestAlgorithm.length > 9)" ) ; return false ; } byte [ ] digestAlgorithm_sha1 = new byte [ ] { 0x06 , 0x05 , 0x2b , 0x0e , 0x03 , 0x02 , 0x1a , 0x05 , 0x00 } ; for ( int i = 0 ; i < digestAlgorithm . length ; i ++ ) { if ( digestAlgorithm [ i ] != digestAlgorithm_sha1 [ i ] ) { log . log ( 20 , "ssh-rsa signature: digestAlgorithm[i] != digestAlgorithm_sha1[i]" ) ; return false ; } } byte [ ] digest = dr . readOctetString ( ) ; if ( dr . available ( ) != 0 ) { log . log ( 20 , "ssh-rsa signature: dr.available() != 0 (II)" ) ; return false ; } if ( digest . length != sha_message . length ) { log . log ( 20 , "ssh-rsa signature: digest.length != sha_message.length" ) ; return false ; } for ( int i = 0 ; i < sha_message . length ; i ++ ) { if ( sha_message [ i ] != digest [ i ] ) { log . log ( 20 , "ssh-rsa signature: sha_message[i] != digest[i]" ) ; return false ; } } return true ; } } 
=======
class ValidatorImpl extends DefaultHandler implements Validator { static final Name OWNER_NAME = new Name ( "http://www.thaiopensource.com/validate/nrl/instance" , "owner" ) ; private static final String NO_NS = "\0" ; private final ErrorHandler eh ; private final PropertyMap properties ; private Locator locator ; private Section currentSection ; private PrefixMapping prefixMapping = null ; private final Hashtable validatorHandlerCache = new Hashtable ( ) ; private final Localizer localizer = new Localizer ( ValidatorImpl . class ) ; private final Hashset noResultActions = new Hashset ( ) ; private final Hashtable attributeNamespaceIndexSets = new Hashtable ( ) ; private final Vector activeHandlersAttributeIndexSets = new Vector ( ) ; private final Hashset attributeSchemas = new Hashset ( ) ; private boolean attributeNamespaceRejected ; private Attributes filteredAttributes ; private final Mode startMode ; static private class PrefixMapping { final String prefix ; final String uri ; final PrefixMapping parent ; PrefixMapping ( String prefix , String uri , PrefixMapping parent ) { this . prefix = prefix ; this . uri = uri ; this . parent = parent ; } } private class Section implements SectionState { final Section parent ; final String ns ; int depth = 0 ; final Vector validators = new Vector ( ) ; final Vector schemas = new Vector ( ) ; final Vector activeHandlers = new Vector ( ) ; final Vector activeHandlersAttributeModeUsage = new Vector ( ) ; final Vector attributeValidationModeUsages = new Vector ( ) ; final Vector childPrograms = new Vector ( ) ; final Stack context = new Stack ( ) ; boolean contextDependent = false ; int attributeProcessing = Mode . ATTRIBUTE_PROCESSING_NONE ; Section ( String ns , Section parent ) { this . ns = ns ; this . parent = parent ; } public void addChildMode ( ModeUsage modeUsage , ContentHandler handler ) { childPrograms . addElement ( new Program ( modeUsage , handler ) ) ; if ( modeUsage . isContextDependent ( ) ) contextDependent = true ; } public void addValidator ( Schema schema , ModeUsage modeUsage ) { schemas . addElement ( schema ) ; Validator validator = createValidator ( schema ) ; validators . addElement ( validator ) ; activeHandlers . addElement ( validator . getContentHandler ( ) ) ; activeHandlersAttributeModeUsage . addElement ( modeUsage ) ; attributeProcessing = Math . max ( attributeProcessing , modeUsage . getAttributeProcessing ( ) ) ; childPrograms . addElement ( new Program ( modeUsage , validator . getContentHandler ( ) ) ) ; if ( modeUsage . isContextDependent ( ) ) contextDependent = true ; } public void addActiveHandler ( ContentHandler handler , ModeUsage attributeModeUsage ) { activeHandlers . addElement ( handler ) ; activeHandlersAttributeModeUsage . addElement ( attributeModeUsage ) ; attributeProcessing = Math . max ( attributeProcessing , attributeModeUsage . getAttributeProcessing ( ) ) ; if ( attributeModeUsage . isContextDependent ( ) ) contextDependent = true ; } public void addAttributeValidationModeUsage ( ModeUsage modeUsage ) { int ap = modeUsage . getAttributeProcessing ( ) ; if ( ap != Mode . ATTRIBUTE_PROCESSING_NONE ) { attributeValidationModeUsages . addElement ( modeUsage ) ; attributeProcessing = Math . max ( ap , attributeProcessing ) ; if ( modeUsage . isContextDependent ( ) ) contextDependent = true ; } } public void reject ( ) throws SAXException { if ( eh != null ) eh . error ( new SAXParseException ( localizer . message ( "reject_element" , ns ) , locator ) ) ; } } static private class Program { final ModeUsage modeUsage ; final ContentHandler handler ; Program ( ModeUsage modeUsage , ContentHandler handler ) { this . modeUsage = modeUsage ; this . handler = handler ; } } ValidatorImpl ( Mode mode , PropertyMap properties ) { this . properties = properties ; this . eh = properties . get ( ValidateProperty . ERROR_HANDLER ) ; this . startMode = mode ; initCurrentSection ( ) ; } private void initCurrentSection ( ) { currentSection = new Section ( NO_NS , null ) ; currentSection . addChildMode ( new ModeUsage ( startMode , startMode ) , null ) ; } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) ( ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ) . characters ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) ( ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ) . ignorableWhitespace ( ch , start , length ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( ! uri . equals ( currentSection . ns ) ) startSection ( uri ) ; currentSection . depth ++ ; if ( currentSection . contextDependent ) currentSection . context . push ( localName ) ; boolean transformAttributes = processAttributes ( attributes ) ; for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) { ContentHandler handler = ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ; handler . startElement ( uri , localName , qName , transformAttributes ? filterAttributes ( ( IntSet ) activeHandlersAttributeIndexSets . elementAt ( i ) , attributes ) : attributes ) ; } } private static Attributes filterAttributes ( IntSet indexSet , Attributes attributes ) { if ( indexSet . size ( ) == attributes . getLength ( ) ) return attributes ; return new FilteredAttributes ( indexSet , attributes ) ; } private boolean processAttributes ( Attributes attributes ) throws SAXException { if ( currentSection . attributeProcessing == Mode . ATTRIBUTE_PROCESSING_NONE || attributes . getLength ( ) == 0 ) return false ; attributeNamespaceIndexSets . clear ( ) ; for ( int i = 0 , len = attributes . getLength ( ) ; i < len ; i ++ ) { String ns = attributes . getURI ( i ) ; IntSet indexSet = ( IntSet ) attributeNamespaceIndexSets . get ( ns ) ; if ( indexSet == null ) { indexSet = new IntSet ( ) ; attributeNamespaceIndexSets . put ( ns , indexSet ) ; } indexSet . add ( i ) ; } if ( currentSection . attributeProcessing == Mode . ATTRIBUTE_PROCESSING_QUALIFIED && attributeNamespaceIndexSets . size ( ) == 1 && attributeNamespaceIndexSets . get ( "" ) != null ) return false ; Vector handlerModes = currentSection . activeHandlersAttributeModeUsage ; activeHandlersAttributeIndexSets . setSize ( handlerModes . size ( ) ) ; for ( int i = 0 , len = handlerModes . size ( ) ; i < len ; i ++ ) activeHandlersAttributeIndexSets . setElementAt ( new IntSet ( ) , i ) ; boolean transform = false ; Vector validationModes = currentSection . attributeValidationModeUsages ; for ( Enumeration e = attributeNamespaceIndexSets . keys ( ) ; e . hasMoreElements ( ) ; ) { String ns = ( String ) e . nextElement ( ) ; IntSet indexSet = ( IntSet ) attributeNamespaceIndexSets . get ( ns ) ; attributeSchemas . clear ( ) ; filteredAttributes = null ; attributeNamespaceRejected = false ; for ( int i = 0 , len = handlerModes . size ( ) ; i < len ; i ++ ) { ModeUsage modeUsage = ( ModeUsage ) handlerModes . elementAt ( i ) ; AttributeActionSet actions = processAttributeSection ( modeUsage , ns , indexSet , attributes ) ; if ( actions . getAttach ( ) ) ( ( IntSet ) activeHandlersAttributeIndexSets . get ( i ) ) . addAll ( indexSet ) ; else transform = true ; } for ( int i = 0 , len = validationModes . size ( ) ; i < len ; i ++ ) { ModeUsage modeUsage = ( ModeUsage ) validationModes . elementAt ( i ) ; processAttributeSection ( modeUsage , ns , indexSet , attributes ) ; } } return transform ; } private AttributeActionSet processAttributeSection ( ModeUsage modeUsage , String ns , IntSet indexSet , Attributes attributes ) throws SAXException { Mode mode = modeUsage . getMode ( currentSection . context ) ; AttributeActionSet actions = mode . getAttributeActions ( ns ) ; if ( actions . getReject ( ) && ! attributeNamespaceRejected ) { attributeNamespaceRejected = true ; if ( eh != null ) eh . error ( new SAXParseException ( localizer . message ( "reject_attribute" , ns ) , locator ) ) ; } Schema [ ] schemas = actions . getSchemas ( ) ; for ( int j = 0 ; j < schemas . length ; j ++ ) { if ( attributeSchemas . contains ( schemas [ j ] ) ) continue ; attributeSchemas . add ( schemas [ j ] ) ; if ( filteredAttributes == null ) filteredAttributes = filterAttributes ( indexSet , attributes ) ; validateAttributes ( schemas [ j ] , filteredAttributes ) ; } return actions ; } private void validateAttributes ( Schema schema , Attributes attributes ) throws SAXException { Validator validator = createValidator ( schema ) ; ContentHandler ch = validator . getContentHandler ( ) ; initHandler ( ch ) ; ch . startElement ( OWNER_NAME . getNamespaceUri ( ) , OWNER_NAME . getLocalName ( ) , OWNER_NAME . getLocalName ( ) , attributes ) ; ch . endElement ( OWNER_NAME . getNamespaceUri ( ) , OWNER_NAME . getLocalName ( ) , OWNER_NAME . getLocalName ( ) ) ; cleanupHandler ( ch ) ; releaseValidator ( schema , validator ) ; } private void startSection ( String uri ) throws SAXException { Section section = new Section ( uri , currentSection ) ; Vector childPrograms = currentSection . childPrograms ; noResultActions . clear ( ) ; for ( int i = 0 , len = childPrograms . size ( ) ; i < len ; i ++ ) { Program program = ( Program ) childPrograms . elementAt ( i ) ; ActionSet actions = program . modeUsage . getMode ( currentSection . context ) . getElementActions ( uri ) ; ResultAction resultAction = actions . getResultAction ( ) ; if ( resultAction != null ) resultAction . perform ( program . handler , section ) ; NoResultAction [ ] nra = actions . getNoResultActions ( ) ; for ( int j = 0 ; j < nra . length ; j ++ ) { NoResultAction tem = nra [ j ] ; if ( ! noResultActions . contains ( tem ) ) { nra [ j ] . perform ( section ) ; noResultActions . add ( tem ) ; } } } for ( int i = 0 , len = section . validators . size ( ) ; i < len ; i ++ ) initHandler ( ( ( Validator ) section . validators . elementAt ( i ) ) . getContentHandler ( ) ) ; currentSection = section ; } private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) ( ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ) . endElement ( uri , localName , qName ) ; currentSection . depth -- ; if ( currentSection . contextDependent ) currentSection . context . pop ( ) ; if ( currentSection . depth == 0 ) endSection ( ) ; } private void endSection ( ) throws SAXException { for ( int i = 0 , len = currentSection . validators . size ( ) ; i < len ; i ++ ) { Validator validator = ( Validator ) currentSection . validators . elementAt ( i ) ; cleanupHandler ( validator . getContentHandler ( ) ) ; releaseValidator ( ( Schema ) currentSection . schemas . elementAt ( i ) , validator ) ; currentSection . validators . setElementAt ( null , i ) ; } currentSection = currentSection . parent ; } private void cleanupHandler ( ContentHandler vh ) throws SAXException { for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) vh . endPrefixMapping ( pm . prefix ) ; vh . endDocument ( ) ; } public void endDocument ( ) throws SAXException { } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { super . startPrefixMapping ( prefix , uri ) ; prefixMapping = new PrefixMapping ( prefix , uri , prefixMapping ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { super . endPrefixMapping ( prefix ) ; prefixMapping = prefixMapping . parent ; } private Validator createValidator ( Schema schema ) { Stack stack = ( Stack ) validatorHandlerCache . get ( schema ) ; if ( stack == null ) { stack = new Stack ( ) ; validatorHandlerCache . put ( schema , stack ) ; } if ( stack . empty ( ) ) return schema . createValidator ( properties ) ; return ( Validator ) stack . pop ( ) ; } private void releaseValidator ( Schema schema , Validator vh ) { if ( vh == null ) return ; vh . reset ( ) ; ( ( Stack ) validatorHandlerCache . get ( schema ) ) . push ( vh ) ; } public void reset ( ) { for ( ; currentSection != null ; currentSection = currentSection . parent ) { for ( int i = 0 , len = currentSection . validators . size ( ) ; i < len ; i ++ ) releaseValidator ( ( Schema ) currentSection . schemas . elementAt ( i ) , ( Validator ) currentSection . validators . elementAt ( i ) ) ; } initCurrentSection ( ) ; } public ContentHandler getContentHandler ( ) { return this ; } public DTDHandler getDTDHandler ( ) { return this ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
