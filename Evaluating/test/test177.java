<<<<<<< HEAD
public class Item implements Comparable < Item > , Atomizer { public static final String INFINITY = "INF" ; public static final String NEG_INFINITY = "-INF" ; private Atom atom ; private Atom [ ] atoms ; private String rubyCode ; private MaxRubyAdapter ruby ; private boolean infinite = false ; private boolean reeval = true ; private Item ( ) { } public Item ( Atom atom ) { this . atom = atom ; } public Item ( int i ) { this . atom = Atom . newAtom ( i ) ; } public Item ( float f ) { this . atom = Atom . newAtom ( f ) ; } public Item ( String s ) { infinite = INFINITY . equalsIgnoreCase ( s ) || NEG_INFINITY . equalsIgnoreCase ( s ) ; if ( infinite ) { s = s . toUpperCase ( ) ; } this . atom = Atom . newAtom ( s ) ; } public Item ( String rubyCode , MaxRubyAdapter ruby ) { this . rubyCode = rubyCode ; this . atom = Atom . newAtom ( "{" + rubyCode + "}" ) ; this . ruby = ruby ; } public Item ( Atom [ ] atoms ) { this . atoms = atoms ; setAtomFromAtoms ( ) ; } private void setAtomFromAtoms ( ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < atoms . length ; i ++ ) { if ( i > 0 ) { s . append ( " " ) ; } s . append ( atoms [ i ] . toString ( ) ) ; } this . atom = Atom . newAtom ( s . toString ( ) ) ; } public Atom toAtom ( ) { return atom ; } public Atom getAtom ( ) { return atom ; } public Atom [ ] getAtoms ( ) { return atoms ; } public boolean isAtomArray ( ) { return atoms != null ; } public void setReeval ( boolean reeval ) { this . reeval = reeval ; } public Object getValue ( ) { if ( rubyCode != null && ruby != null ) { if ( reeval ) { Object value = ruby . eval ( rubyCode , true ) ; if ( value instanceof Atom [ ] ) { atoms = ( Atom [ ] ) value ; setAtomFromAtoms ( ) ; } else { atoms = null ; atom = ( Atom ) value ; } reeval = false ; } } if ( atoms != null ) { return atoms ; } else { return atom ; } } public boolean isInfinite ( ) { return infinite ; } public Item add ( Atom summand ) { if ( isAtomArray ( ) ) { Atom [ ] sumAtoms = new Atom [ atoms . length ] ; for ( int i = 0 ; i < atoms . length ; i ++ ) { Atom atom = atoms [ i ] ; if ( atom . isFloat ( ) || atom . isInt ( ) ) { sumAtoms [ i ] = add ( atom , summand ) ; } else { sumAtoms [ i ] = atom ; } } return new Item ( sumAtoms ) ; } else { if ( atom . isFloat ( ) || atom . isInt ( ) ) { return new Item ( add ( atom , summand ) ) ; } else { return this ; } } } private Atom add ( Atom a1 , Atom a2 ) { if ( a1 . isFloat ( ) || a2 . isFloat ( ) ) { return Atom . newAtom ( a1 . toFloat ( ) + a2 . toFloat ( ) ) ; } else { return Atom . newAtom ( a1 . toInt ( ) + a2 . toInt ( ) ) ; } } public Item subtractFrom ( Atom operand ) { if ( isAtomArray ( ) ) { Atom [ ] sumAtoms = new Atom [ atoms . length ] ; for ( int i = 0 ; i < atoms . length ; i ++ ) { Atom atom = atoms [ i ] ; if ( atom . isFloat ( ) || atom . isInt ( ) ) { sumAtoms [ i ] = subtract ( operand , atom ) ; } else { sumAtoms [ i ] = atom ; } } return new Item ( sumAtoms ) ; } else { if ( atom . isFloat ( ) || atom . isInt ( ) ) { return new Item ( subtract ( operand , atom ) ) ; } else { return this ; } } } private Atom subtract ( Atom a1 , Atom a2 ) { if ( a1 . isFloat ( ) || a2 . isFloat ( ) ) { return Atom . newAtom ( a1 . toFloat ( ) - a2 . toFloat ( ) ) ; } else { return Atom . newAtom ( a1 . toInt ( ) - a2 . toInt ( ) ) ; } } public Item multiply ( Atom multiplier ) { if ( isAtomArray ( ) ) { Atom [ ] sumAtoms = new Atom [ atoms . length ] ; for ( int i = 0 ; i < atoms . length ; i ++ ) { Atom atom = atoms [ i ] ; if ( atom . isFloat ( ) || atom . isInt ( ) ) { sumAtoms [ i ] = multiply ( atom , multiplier ) ; } else { sumAtoms [ i ] = atom ; } } return new Item ( sumAtoms ) ; } else { if ( atom . isFloat ( ) || atom . isInt ( ) ) { return new Item ( multiply ( atom , multiplier ) ) ; } else { return this ; } } } private Atom multiply ( Atom a1 , Atom a2 ) { if ( a1 . isFloat ( ) || a2 . isFloat ( ) ) { return Atom . newAtom ( a1 . toFloat ( ) * a2 . toFloat ( ) ) ; } else { return Atom . newAtom ( a1 . toInt ( ) * a2 . toInt ( ) ) ; } } public int compareTo ( Item other ) { Atom a1 = getAtom ( ) ; Atom a2 = other . getAtom ( ) ; if ( a1 . isString ( ) || a2 . isString ( ) ) { return a1 . toString ( ) . compareTo ( a2 . toString ( ) ) ; } else if ( a1 . isFloat ( ) || a2 . isFloat ( ) ) { return Float . compare ( a1 . toFloat ( ) , a2 . toFloat ( ) ) ; } else { return a1 . toInt ( ) - a2 . toInt ( ) ; } } public Item clone ( ) { Item i = new Item ( ) ; i . atom = atom ; i . atoms = atoms ; return i ; } public boolean equals ( Object obj ) { if ( obj instanceof Item ) { return this . atom . equals ( ( ( Item ) obj ) . atom ) ; } else { return false ; } } public String toString ( ) { if ( atoms != null ) { return "\"" + atom + "\"" ; } else { return atom + "" ; } } } 
=======
public class PatternValidator extends Context implements ContentHandler , DTDHandler { private Matcher matcher ; private final ErrorHandler eh ; private boolean bufferingCharacters = false ; private final StringBuilder charBuf = new StringBuilder ( ) ; private Locator locator = null ; public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { if ( bufferingCharacters ) { bufferingCharacters = false ; check ( matcher . matchTextBeforeStartTag ( charBuf . toString ( ) , this ) ) ; } Name name = new Name ( namespaceURI , localName ) ; check ( matcher . matchStartTagOpen ( name , qName , this ) ) ; int len = atts . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Name attName = new Name ( atts . getURI ( i ) , atts . getLocalName ( i ) ) ; String attQName = atts . getQName ( i ) ; check ( matcher . matchAttributeName ( attName , attQName , this ) ) ; check ( matcher . matchAttributeValue ( atts . getValue ( i ) , attName , attQName , this ) ) ; } check ( matcher . matchStartTagClose ( name , qName , this ) ) ; if ( matcher . isTextTyped ( ) ) { bufferingCharacters = true ; charBuf . setLength ( 0 ) ; } } public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { if ( bufferingCharacters ) { bufferingCharacters = false ; if ( charBuf . length ( ) > 0 ) check ( matcher . matchTextBeforeEndTag ( charBuf . toString ( ) , new Name ( namespaceURI , localName ) , qName , this ) ) ; } check ( matcher . matchEndTag ( new Name ( namespaceURI , localName ) , qName , this ) ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( bufferingCharacters ) { charBuf . append ( ch , start , length ) ; return ; } for ( int i = 0 ; i < length ; i ++ ) { switch ( ch [ start + i ] ) { case ' ' : case '\r' : case '\t' : case '\n' : break ; default : check ( matcher . matchUntypedText ( this ) ) ; return ; } } } public void endDocument ( ) throws SAXException { check ( matcher . matchEndDocument ( ) ) ; } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; } public void startDocument ( ) throws SAXException { check ( matcher . matchStartDocument ( ) ) ; } public void processingInstruction ( String target , String date ) { } public void skippedEntity ( String name ) { } public void ignorableWhitespace ( char [ ] ch , int start , int len ) { } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( bufferingCharacters ) { bufferingCharacters = false ; check ( matcher . matchTextBeforeStartTag ( charBuf . toString ( ) , this ) ) ; } super . startPrefixMapping ( prefix , uri ) ; } public PatternValidator ( Pattern pattern , ValidatorPatternBuilder builder , ErrorHandler eh ) { this . matcher = new PatternMatcher ( pattern , builder ) ; this . eh = eh ; } public void reset ( ) { super . reset ( ) ; bufferingCharacters = false ; locator = null ; matcher = matcher . start ( ) ; } private void check ( boolean ok ) throws SAXException { if ( ! ok ) eh . error ( new SAXParseException ( matcher . getErrorMessage ( ) , locator ) ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
