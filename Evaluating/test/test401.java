<<<<<<< HEAD
public class ChangeBuffer extends DerefRefTree implements MutableRefTree , BatchMutable { protected Set < Key > delRoots = new HashSet < Key > ( ) ; protected Set < Key > delNodes = new HashSet < Key > ( ) ; protected MutableRefTree changeTree ; protected Key changeTreeRoot = MutableRefTree . AUTO_KEY ; protected Stack < Key > expandStack = new Stack < Key > ( ) ; protected boolean updateLoadsContent = false ; public ChangeBuffer ( IdAddressableRefTree backingTree ) { this ( backingTree , KeyMap . IDENTITY_MAP ) ; } public ChangeBuffer ( IdAddressableRefTree backingTree , KeyMap kmap ) { this ( new MutableRefTreeImpl ( kmap . getFrontKey ( backingTree . getRoot ( ) . getId ( ) ) , MutableRefTreeImpl . ID_AS_STRINGS_BY_LENGTH_ALPHA ) , backingTree , kmap ) ; } public ChangeBuffer ( MutableRefTree changeTree , IdAddressableRefTree backingTree ) { this ( changeTree , backingTree , changeTree instanceof KeyMap ? ( KeyMap ) changeTree : KeyMap . IDENTITY_MAP ) ; } public ChangeBuffer ( MutableRefTree changeTree , IdAddressableRefTree backingTree , KeyMap map ) { this ( changeTree , backingTree , map , MutableRefTree . AUTO_KEY ) ; } public ChangeBuffer ( MutableRefTree changeTree , IdAddressableRefTree backingTree , KeyMap map , Key changeTreeRoot ) { super ( changeTree , backingTree , map ) ; this . changeTree = changeTree ; this . changeTreeRoot = changeTreeRoot ; reset ( ) ; } public IdAddressableRefTree getChangeTree ( ) { return changeTree ; } public void reset ( ) { assert modCount ++ > 0 || true ; try { Key bid = backingTree . getRoot ( ) . getId ( ) ; Key fid = km . getFrontKey ( backingTree . getRoot ( ) . getId ( ) ) ; if ( fid != null && changeTree . contains ( fid ) ) changeTree . delete ( fid ) ; fid = km . getFrontKey ( backingTree . getRoot ( ) . getId ( ) ) ; changeTree . insert ( null , changeTreeRoot != MutableRefTree . AUTO_KEY ? changeTreeRoot : fid , TreeReference . create ( bid ) ) ; } catch ( NodeNotFoundException e ) { throw new Error ( "Can't insert root treeref" , e ) ; } delRoots . clear ( ) ; delNodes . clear ( ) ; assert expandStack . isEmpty ( ) ; } public void delete ( Key id ) throws NodeNotFoundException { expand ( id , false ) ; addToDeletia ( changeTree . getNode ( id ) ) ; changeTree . delete ( id ) ; assert modCount ++ > 0 || true ; } public final Key insert ( Key parentId , Key newId , Object content ) throws NodeNotFoundException { return insert ( parentId , DEFAULT_POSITION , newId , content ) ; } public Key insert ( Key parentId , long pos , Key newId , Object c ) throws NodeNotFoundException { if ( contains ( newId ) ) throw new IllegalArgumentException ( "Node already in tree " + newId ) ; expand ( parentId , true ) ; Key iKey = changeTree . insert ( parentId , pos , newId , c ) ; if ( c instanceof Reference ) removeFromDeletia ( ( Reference ) c ) ; assert modCount ++ > 0 || true ; return iKey ; } public Key move ( Key nodeId , Key parentId ) throws NodeNotFoundException { return move ( nodeId , parentId , DEFAULT_POSITION ) ; } public Key move ( Key nodeId , Key parentId , long pos ) throws NodeNotFoundException { expand ( nodeId , false ) ; expand ( parentId , true ) ; Key k = changeTree . move ( nodeId , parentId , pos ) ; assert modCount ++ > 0 || true ; return k ; } public boolean update ( Key nodeId , Object c ) throws NodeNotFoundException { expand ( nodeId , true ) ; assert ! changeTree . getNode ( nodeId ) . isTreeRef ( ) ; RefTreeNode cn = changeTree . getNode ( nodeId ) ; assert cn != null : "Node should be in tree by expand:" + nodeId ; boolean same = false ; if ( changeTree . getNode ( nodeId ) . isNodeRef ( ) ) { Object cb = getExistingBackNode ( cn ) . getContent ( ) ; same = Util . equals ( c , cb ) ; if ( updateLoadsContent || ! same ) changeTree . update ( nodeId , same ? cb : c ) ; } else same = changeTree . update ( nodeId , c ) ; if ( c instanceof Reference ) removeFromDeletia ( ( Reference ) c ) ; assert same || modCount ++ > 0 || true ; return same ; } public void apply ( RefTree t ) throws NodeNotFoundException { if ( ! ( changeTree instanceof BatchMutable ) ) { RefTrees . apply ( t , this ) ; return ; } RefTree backRef = RefTrees . getRefTree ( backingTree ) ; Set [ ] expandedContentKeys = new Set [ 2 ] ; Set [ ] usedRefs = RefTrees . normalize ( backingTree , new RefTree [ ] { t , backRef } , expandedContentKeys , KeyMap . UNMAPPABLE ) ; Set usedNewTreeRefs = usedRefs [ 0 ] ; Set allowedTreeRefs = usedRefs [ 1 ] ; Set deletedNodeRefs = expandedContentKeys [ 0 ] ; Set newDelNodes = new HashSet ( ) ; { newDelNodes . clear ( ) ; Set stopSet = allowedTreeRefs ; LinkedList < RefTreeNode > queue = new LinkedList < RefTreeNode > ( ) ; for ( queue . add ( backingTree . getRoot ( ) ) ; ! queue . isEmpty ( ) ; ) { RefTreeNode n = queue . removeLast ( ) ; if ( ! stopSet . contains ( n . getId ( ) ) ) { newDelNodes . add ( n . getId ( ) ) ; for ( Iterator i = n . getChildIterator ( ) ; i . hasNext ( ) ; ) queue . add ( ( RefTreeNode ) i . next ( ) ) ; } } assert queue . isEmpty ( ) ; for ( queue . add ( t . getRoot ( ) ) ; ! queue . isEmpty ( ) ; ) { RefTreeNode n = queue . removeLast ( ) ; if ( n . isNodeRef ( ) ) newDelNodes . remove ( n . getReference ( ) . getTarget ( ) ) ; for ( Iterator i = n . getChildIterator ( ) ; i . hasNext ( ) ; ) queue . add ( ( RefTreeNode ) i . next ( ) ) ; } } expandAll ( t . getRoot ( ) , KeyMap . UNMAPPABLE ) ; ( ( BatchMutable ) changeTree ) . apply ( t ) ; delNodes = newDelNodes ; delRoots = allowedTreeRefs ; delRoots . removeAll ( usedNewTreeRefs ) ; } protected void expandAll ( RefTreeNode n , KeyMap km ) throws NodeNotFoundException { for ( Iterator < RefTreeNode > ci = n . getChildIterator ( ) ; ci . hasNext ( ) ; ) expandAll ( ci . next ( ) , km ) ; Key toExpand = n . isReference ( ) ? ( n . getReference ( ) . getTarget ( ) ) : km . getBackKey ( n . getId ( ) ) ; if ( toExpand != null ) { expand ( toExpand , false ) ; } } protected void addToDeletia ( RefTreeNode n ) { if ( n . isReference ( ) ) { Key target = n . getReference ( ) . getTarget ( ) ; if ( n . isNodeRef ( ) ) delNodes . add ( target ) ; else delRoots . add ( target ) ; } else { Key bk = km . getBackKey ( n . getId ( ) ) ; if ( bk != null && backingTree . contains ( bk ) ) delNodes . add ( bk ) ; } for ( Iterator i = n . getChildIterator ( ) ; i . hasNext ( ) ; ) addToDeletia ( ( RefTreeNode ) i . next ( ) ) ; } protected void removeFromDeletia ( Reference ref ) throws NodeNotFoundException { Key target = ref . getTarget ( ) ; if ( ! backingTree . contains ( target ) ) throw new NodeNotFoundException ( target ) ; if ( ! ref . isTreeReference ( ) ) { if ( delNodes . remove ( target ) ) { assert ! delRoots . contains ( target ) ; } else if ( delRoots . contains ( target ) ) { assert ! delNodes . contains ( target ) ; for ( Iterator i = backingTree . childIterator ( target ) ; i . hasNext ( ) ; ) { Key bck = ( Key ) i . next ( ) ; assert ! changeTree . contains ( km . getFrontKey ( bck ) ) ; delRoots . add ( bck ) ; } } else ; } else { assert ref . isTreeReference ( ) ; if ( delRoots . remove ( target ) ) { assert ! delNodes . contains ( target ) ; } else if ( delNodes . remove ( target ) ) { assert ! delRoots . contains ( target ) ; Set < Key > resurrects = new HashSet < Key > ( ) ; for ( Key k : delRoots ) { for ( ; k != null ; k = backingTree . getParent ( k ) ) { if ( k . equals ( target ) ) { resurrects . add ( k ) ; break ; } } } for ( Key k : delNodes ) { for ( ; k != null ; k = backingTree . getParent ( k ) ) { if ( k . equals ( target ) ) { resurrects . add ( k ) ; break ; } } } delRoots . removeAll ( resurrects ) ; delNodes . removeAll ( resurrects ) ; } else ; } } @ Override protected boolean isDeleted ( Key bk ) { assert backkey ( bk ) ; if ( delNodes . contains ( bk ) ) return true ; try { for ( ; bk == null || backingTree . contains ( bk ) ; bk = backingTree . getParent ( bk ) ) { if ( bk == null ) return false ; if ( delRoots . contains ( bk ) ) return true ; } return true ; } catch ( NodeNotFoundException e ) { trap ( e ) ; } assert false : "Unreachable" ; return false ; } protected Key expand ( Key eid , boolean expandChildren ) throws NodeNotFoundException { if ( eid == null ) throw new NodeNotFoundException ( eid ) ; if ( changeTree . contains ( eid ) && ! changeTree . getNode ( eid ) . isTreeRef ( ) ) return eid ; Key id = eid ; assert frontkey ( id ) ; for ( Key backId = km . getBackKey ( id ) ; id != null ; ) { if ( id == eid && ! backingTree . contains ( backId ) ) throw new NodeNotFoundException ( id ) ; assert id != eid || backId != null : "Trying to expand key " + id + ", which is not in tree, and has no backKey" ; if ( changeTree . contains ( id ) ) { assert id == null || changeTree . getNode ( id ) . isTreeRef ( ) ; Key pId = changeTree . getParent ( id ) ; assert pId == null || changeTree . getNode ( pId ) != null : "ChangeTree returned non-existing parent " + pId + " of " + id ; assert pId == null || ! changeTree . getNode ( pId ) . isTreeRef ( ) : "treeref as parent of treeref in expandTree" ; for ( ; id != null && expandChildren ; id = expandStack . isEmpty ( ) ? null : expandStack . pop ( ) ) { assert changeTree . getNode ( id ) . isTreeRef ( ) ; changeTree . update ( id , NodeReference . create ( km . getBackKey ( id ) ) ) ; assert changeTree . getNode ( id ) . isNodeRef ( ) : "Non-std semantic for node-ref was busted" ; insertRefSubtree ( changeTree , backingTree , id ) ; pId = id ; } assert expandStack . isEmpty ( ) ; assert frontkey ( pId ) ; assert changeTree . contains ( eid ) ; return pId ; } else if ( expandChildren ) expandStack . push ( id ) ; else expandChildren = true ; backId = backingTree . getParent ( backId ) ; assert backId != null : "Found null backId->this front-key is now deleted?!: " + eid + "(now at front-key " + id + "). This may happen if the contains() method of your backing " + "tree is inconsistent with what is found on traversal." ; id = km . getFrontKey ( backId ) ; } assert false : "The key " + id + " addressed a deleted part of the tree" ; expandStack . clear ( ) ; return null ; } private void insertRefSubtree ( MutableRefTree ft , IdAddressableRefTree bt , Key froot ) throws NodeNotFoundException { assert backkey ( froot ) ; for ( Iterator i = bt . childIterator ( km . getBackKey ( froot ) ) ; i . hasNext ( ) ; ) { Key bckey = ( Key ) i . next ( ) ; assert backkey ( bckey ) ; ft . insert ( froot , km . getFrontKey ( bckey ) , TreeReference . create ( bckey ) ) ; assert ft . getNode ( km . getFrontKey ( bckey ) ) . isTreeRef ( ) : "TreeRef insert broken" ; } } protected boolean frontkey ( Key id ) { return true ; } protected boolean backkey ( Key id ) { return true ; } } 
=======
public class DatatypeException extends Exception { public DatatypeException ( int index , String msg ) { super ( msg ) ; this . index = index ; } public DatatypeException ( String msg ) { this ( UNKNOWN , msg ) ; } public DatatypeException ( ) { this ( UNKNOWN , null ) ; } private final int index ; public static final int UNKNOWN = - 1 ; public int getIndex ( ) { return index ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
