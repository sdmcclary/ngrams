<<<<<<< HEAD
public class MailModule extends AbstractQuercusModule { private static final Logger log = Logger . getLogger ( MailModule . class . getName ( ) ) ; private static final L10N L = new L10N ( MailModule . class ) ; public static boolean mail ( Env env , String to , String subject , StringValue message , @ Optional String additionalHeaders , @ Optional String additionalParameters ) { Transport smtp = null ; try { HashMap < String , String > headers = splitHeaders ( additionalHeaders ) ; if ( to == null || to . equals ( "" ) ) to = headers . get ( "to" ) ; Properties props = new Properties ( ) ; StringValue host = env . getIni ( "SMTP" ) ; if ( host != null && ! host . toString ( ) . equals ( "" ) ) props . put ( "mail.smtp.host" , host . toString ( ) ) ; else if ( System . getProperty ( "mail.smtp.host" ) != null ) props . put ( "mail.smtp.host" , System . getProperty ( "mail.smtp.host" ) ) ; StringValue port = env . getIni ( "smtp_port" ) ; if ( port != null && ! port . toString ( ) . equals ( "" ) ) props . put ( "mail.smtp.port" , port . toString ( ) ) ; else if ( System . getProperty ( "mail.smtp.port" ) != null ) props . put ( "mail.smtp.port" , System . getProperty ( "mail.smtp.port" ) ) ; if ( System . getProperty ( "mail.smtp.class" ) != null ) props . put ( "mail.smtp.class" , System . getProperty ( "mail.smtp.class" ) ) ; StringValue user = null ; if ( headers . get ( "from" ) != null ) user = env . createStringOld ( headers . get ( "from" ) ) ; if ( user == null ) user = env . getIni ( "sendmail_from" ) ; if ( user != null && ! user . toString ( ) . equals ( "" ) ) { String userString = user . toString ( ) ; props . put ( "mail.from" , userString ) ; } else if ( System . getProperty ( "mail.from" ) != null ) props . put ( "mail.from" , System . getProperty ( "mail.from" ) ) ; else { try { InetAddress addr = InetAddress . getLocalHost ( ) ; String email = ( System . getProperty ( "user.name" ) + "@" + addr . getHostName ( ) ) ; int index = email . indexOf ( '@' ) ; if ( email . indexOf ( '.' , index ) < 0 ) email += ".com" ; props . put ( "mail.from" , email ) ; } catch ( Exception e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } } String username = env . getIniString ( "smtp_username" ) ; String password = env . getIniString ( "smtp_password" ) ; if ( password != null && ! "" . equals ( password ) ) props . put ( "mail.smtp.auth" , "true" ) ; Session mailSession = Session . getInstance ( props , null ) ; smtp = mailSession . getTransport ( "smtp" ) ; MimeMessage msg = new MimeMessage ( mailSession ) ; if ( subject == null ) subject = "" ; msg . setSubject ( subject ) ; msg . setContent ( message . toString ( ) , "text/plain" ) ; ArrayList < Address > addrList = new ArrayList < Address > ( ) ; if ( to != null && to . length ( ) > 0 ) addRecipients ( msg , Message . RecipientType . TO , to , addrList ) ; if ( headers != null ) addHeaders ( msg , headers , addrList ) ; Address [ ] from = msg . getFrom ( ) ; if ( from == null || from . length == 0 ) { log . fine ( L . l ( "mail 'From' not set, setting to Java System property 'user.name'" ) ) ; msg . setFrom ( ) ; } msg . saveChanges ( ) ; from = msg . getFrom ( ) ; log . fine ( L . l ( "sending mail, From: {0}, To: {1}" , from [ 0 ] , to ) ) ; if ( password != null && ! "" . equals ( password ) ) smtp . connect ( username , password ) ; else smtp . connect ( ) ; Address [ ] addr ; addr = new Address [ addrList . size ( ) ] ; addrList . toArray ( addr ) ; smtp . sendMessage ( msg , addr ) ; log . fine ( "quercus-mail: sent mail to " + to ) ; return true ; } catch ( RuntimeException e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; throw e ; } catch ( AuthenticationFailedException e ) { log . warning ( L . l ( "Quercus[] mail could not send mail to '{0}' because authentication failed\n{1}" , to , e . getMessage ( ) ) ) ; log . log ( Level . FINE , e . toString ( ) , e ) ; env . warning ( e . toString ( ) ) ; return false ; } catch ( MessagingException e ) { Throwable cause = e ; log . warning ( L . l ( "Quercus[] mail could not send mail to '{0}'\n{1}" , to , cause . getMessage ( ) ) ) ; log . log ( Level . FINE , cause . toString ( ) , cause ) ; env . warning ( cause . getMessage ( ) ) ; return false ; } catch ( Exception e ) { Throwable cause = e ; log . warning ( L . l ( "Quercus[] mail could not send mail to '{0}'\n{1}" , to , cause . getMessage ( ) ) ) ; log . log ( Level . FINE , cause . toString ( ) , cause ) ; env . warning ( cause . toString ( ) ) ; return false ; } finally { try { if ( smtp != null ) smtp . close ( ) ; } catch ( Exception e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } } } private static void addRecipients ( MimeMessage msg , Message . RecipientType type , String to , ArrayList < Address > addrList ) throws MessagingException { String [ ] split = to . split ( "," ) ; for ( int i = 0 ; i < split . length ; i ++ ) { String addrStr = split [ i ] ; if ( addrStr . length ( ) > 0 ) { int openBracket = addrStr . indexOf ( '<' ) ; if ( openBracket >= 0 && ! addrStr . contains ( "\"" ) ) { int closeBracket = addrStr . indexOf ( '>' , openBracket + 1 ) ; if ( closeBracket > openBracket ) { int space = addrStr . indexOf ( ' ' , openBracket + 1 ) ; if ( openBracket < space && space < closeBracket ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( addrStr , 0 , openBracket + 1 ) ; sb . append ( "\"" ) ; sb . append ( addrStr , openBracket + 1 , closeBracket ) ; sb . append ( "\"" ) ; sb . append ( addrStr , closeBracket , addrStr . length ( ) ) ; addrStr = sb . toString ( ) ; } } } Address addr = new InternetAddress ( addrStr ) ; addrList . add ( addr ) ; msg . addRecipient ( type , addr ) ; } } } private static void addHeaders ( MimeMessage msg , HashMap < String , String > headerMap , ArrayList < Address > addrList ) throws MessagingException { for ( Map . Entry < String , String > entry : headerMap . entrySet ( ) ) { String name = entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( "" . equals ( value ) ) { } else if ( name . equalsIgnoreCase ( "From" ) ) { msg . setFrom ( new InternetAddress ( value ) ) ; } else if ( name . equalsIgnoreCase ( "To" ) ) { addRecipients ( msg , Message . RecipientType . TO , value , addrList ) ; } else if ( name . equalsIgnoreCase ( "Bcc" ) ) { addRecipients ( msg , Message . RecipientType . BCC , value , addrList ) ; } else if ( name . equalsIgnoreCase ( "Cc" ) ) { addRecipients ( msg , Message . RecipientType . CC , value , addrList ) ; } else msg . addHeader ( name , value ) ; } } private static HashMap < String , String > splitHeaders ( String headers ) { HashMap < String , String > headerMap = new HashMap < String , String > ( ) ; if ( headers == null ) return headerMap ; int i = 0 ; int len = headers . length ( ) ; CharBuffer buffer = new CharBuffer ( ) ; while ( i < len ) { char ch ; for ( ; i < len && Character . isWhitespace ( headers . charAt ( i ) ) ; i ++ ) { } if ( len <= i ) return headerMap ; buffer . clear ( ) ; for ( ; i < len && ( ! Character . isWhitespace ( ch = headers . charAt ( i ) ) && ch != ':' ) ; i ++ ) { buffer . append ( ( char ) ch ) ; } for ( ; i < len && ( ( ch = headers . charAt ( i ) ) == ' ' || ch == '\t' || ch == '\f' || ch == ':' ) ; i ++ ) { } String name = buffer . toString ( ) ; buffer . clear ( ) ; for ( ; i < len && ( ( ch = headers . charAt ( i ) ) != '\r' && ch != '\n' ) ; i ++ ) { buffer . append ( ( char ) ch ) ; } String value = buffer . toString ( ) ; if ( ! "" . equals ( value ) ) headerMap . put ( name , value ) ; } return headerMap ; } } 
=======
class PatternParser { private final ErrorHandler eh ; private final Localizer localizer ; private String pattern ; private int patternOffset ; private int patternLength ; private int currentToken ; private int tokenStartOffset ; private String tokenNamespaceUri ; private String tokenLocalName ; private final PatternBuilder builder = new PatternBuilder ( ) ; private NamespaceContext namespaceContext ; private final StringBuffer nameBuffer = new StringBuffer ( ) ; private static final int TOKEN_EOF = 0 ; private static final int TOKEN_SLASH = 1 ; private static final int TOKEN_SLASH_SLASH = 2 ; private static final int TOKEN_CHOICE = 3 ; private static final int TOKEN_CHILD_AXIS = 4 ; private static final int TOKEN_ATTRIBUTE_AXIS = 5 ; private static final int TOKEN_DOT = 6 ; private static final int TOKEN_QNAME = 7 ; private static final int TOKEN_NCNAME_STAR = 8 ; private static final int TOKEN_STAR = 9 ; private Locator locator ; PatternParser ( ErrorHandler eh , Localizer localizer ) { this . eh = eh ; this . localizer = localizer ; } Pattern parse ( String pattern , Locator locator , NamespaceContext namespaceContext ) throws SAXException , InvalidPatternException { this . pattern = pattern ; this . patternOffset = 0 ; this . patternLength = pattern . length ( ) ; this . locator = locator ; this . namespaceContext = namespaceContext ; try { do { parseChoice ( ) ; } while ( currentToken == TOKEN_CHOICE ) ; return builder . createPattern ( ) ; } finally { builder . cleanup ( ) ; } } private void parseChoice ( ) throws SAXException , InvalidPatternException { for ( ; ; ) { parseStep ( ) ; advance ( ) ; switch ( currentToken ) { case TOKEN_SLASH : break ; case TOKEN_SLASH_SLASH : builder . addDescendantsOrSelf ( ) ; break ; case TOKEN_CHOICE : builder . alternative ( ) ; return ; case TOKEN_EOF : return ; default : throw error ( "expected_step_connector" ) ; } } } private void parseStep ( ) throws SAXException , InvalidPatternException { advance ( ) ; byte type ; switch ( currentToken ) { case TOKEN_ATTRIBUTE_AXIS : type = PatternBuilder . ATTRIBUTE ; advance ( ) ; break ; case TOKEN_CHILD_AXIS : type = PatternBuilder . CHILD ; advance ( ) ; break ; case TOKEN_DOT : return ; default : type = PatternBuilder . CHILD ; break ; } switch ( currentToken ) { case TOKEN_QNAME : builder . addName ( type , tokenNamespaceUri , tokenLocalName ) ; break ; case TOKEN_STAR : builder . addAnyName ( type ) ; break ; case TOKEN_NCNAME_STAR : builder . addNsName ( type , tokenNamespaceUri ) ; break ; default : throw error ( "expected_name_test" ) ; } } private void advance ( ) throws SAXException , InvalidPatternException { for ( ; ; ) { tokenStartOffset = patternOffset ; if ( patternOffset >= patternLength ) { currentToken = TOKEN_EOF ; return ; } char ch = pattern . charAt ( patternOffset ) ; switch ( ch ) { case ' ' : case '\t' : case '\r' : case '\n' : patternOffset ++ ; continue ; case '.' : patternOffset ++ ; currentToken = TOKEN_DOT ; return ; case '@' : patternOffset ++ ; currentToken = TOKEN_ATTRIBUTE_AXIS ; return ; case '|' : patternOffset ++ ; currentToken = TOKEN_CHOICE ; return ; case '/' : if ( ++ patternOffset < patternLength && pattern . charAt ( patternOffset ) == '/' ) { patternOffset ++ ; currentToken = TOKEN_SLASH_SLASH ; } else currentToken = TOKEN_SLASH ; return ; case '*' : patternOffset ++ ; currentToken = TOKEN_STAR ; return ; } String name = scanNCName ( "illegal_char" ) ; if ( ( name . equals ( "child" ) || name . equals ( "attribute" ) ) && tryScanDoubleColon ( ) ) { currentToken = name . charAt ( 0 ) == 'c' ? TOKEN_CHILD_AXIS : TOKEN_ATTRIBUTE_AXIS ; return ; } if ( patternOffset < patternLength && pattern . charAt ( patternOffset ) == ':' ) { tokenNamespaceUri = expandPrefix ( name ) ; patternOffset ++ ; if ( patternOffset == patternLength ) throw error ( "expected_star_or_ncname" ) ; if ( pattern . charAt ( patternOffset ) == '*' ) { patternOffset ++ ; currentToken = TOKEN_NCNAME_STAR ; return ; } tokenLocalName = scanNCName ( "expected_star_or_ncname" ) ; currentToken = TOKEN_QNAME ; return ; } tokenLocalName = name ; tokenNamespaceUri = namespaceContext . defaultPrefix ( ) ; currentToken = TOKEN_QNAME ; return ; } } private boolean tryScanDoubleColon ( ) { for ( int i = patternOffset ; i < patternLength ; i ++ ) { switch ( pattern . charAt ( i ) ) { case ' ' : case '\t' : case '\r' : case '\n' : break ; case ':' : if ( ++ i < patternLength && pattern . charAt ( i ) == ':' ) { patternOffset = i + 1 ; return true ; } default : return false ; } } return false ; } private String expandPrefix ( String prefix ) throws SAXException , InvalidPatternException { String ns = namespaceContext . getNamespaceUri ( prefix ) ; if ( ns == null ) throw error ( "unbound_prefix" , prefix ) ; return ns ; } private String scanNCName ( String message ) throws SAXException , InvalidPatternException { char ch = pattern . charAt ( patternOffset ++ ) ; if ( ! maybeNameStartChar ( ch ) ) throw error ( message ) ; nameBuffer . setLength ( 0 ) ; nameBuffer . append ( ch ) ; for ( ; patternOffset < patternLength ; patternOffset ++ ) { ch = pattern . charAt ( patternOffset ) ; if ( ! maybeNameChar ( ch ) ) break ; nameBuffer . append ( ch ) ; } String name = nameBuffer . toString ( ) ; if ( ! Naming . isNcname ( name ) ) throw error ( "illegal_ncname" , name ) ; return name ; } private static boolean maybeNameStartChar ( char ch ) { return ch > 0x80 || Character . isLetter ( ch ) || ch == '_' ; } private static boolean maybeNameChar ( char ch ) { return ch > 0x80 || Character . isLetterOrDigit ( ch ) || ".-_" . indexOf ( ch ) >= 0 ; } private InvalidPatternException error ( String key ) throws SAXException { if ( eh != null ) eh . error ( new SAXParseException ( addContext ( localizer . message ( key ) ) , locator ) ) ; return new InvalidPatternException ( ) ; } private InvalidPatternException error ( String key , String arg ) throws SAXException { if ( eh != null ) eh . error ( new SAXParseException ( addContext ( localizer . message ( key , arg ) ) , locator ) ) ; return new InvalidPatternException ( ) ; } private String addContext ( String message ) { return localizer . message ( "context" , new Object [ ] { message , pattern . substring ( 0 , tokenStartOffset ) , pattern . substring ( tokenStartOffset , patternOffset ) , pattern . substring ( patternOffset ) } ) ; } static public void main ( String [ ] args ) throws SAXException { PatternParser parser = new PatternParser ( new com . thaiopensource . xml . sax . ErrorHandlerImpl ( ) , new Localizer ( PatternParser . class ) ) ; String [ ] tests = { "foo//bar" , "." , ".//.//././././/foo" , "foo:bar" , "bar:*" , "*" , "/" , "foo/bar|bar/baz" , "foo/" , "" , ".//." , ".//" , "foo / @ bar" , "child::foo:bar" , "attribute::baz" } ; NamespaceContext nsc = new NamespaceContext ( ) { public String getNamespaceUri ( String prefix ) { return "http://" + prefix ; } public String defaultPrefix ( ) { return "" ; } } ; for ( int i = 0 ; i < tests . length ; i ++ ) { try { Pattern pattern = parser . parse ( tests [ i ] , null , nsc ) ; System . out . println ( tests [ i ] + " => " + pattern . toString ( ) ) ; } catch ( InvalidPatternException e ) { } } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
