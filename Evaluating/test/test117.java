<<<<<<< HEAD
public final class ScoresCalculator { private double activityWeight ; private double inlinksWeight ; private double clickthroughsWeight ; private double feedViewsWeight ; private int topActivity ; private static int maxClickthroughs = 0 ; private static int maxFeedViews = 0 ; ScoresCalculator ( ) { initThreading ( ) ; loadPreferences ( null ) ; } public static synchronized boolean registerMaxFeedViews ( int views ) { boolean updated = false ; if ( maxFeedViews < views ) { maxFeedViews = views ; updated = true ; } return updated ; } public static synchronized boolean registerMaxClickthroughs ( int clicks ) { boolean updated = false ; if ( maxClickthroughs < clicks ) { maxClickthroughs = clicks ; updated = true ; } return updated ; } public int calcFinalScore ( IFeed feed ) { int score = - 1 ; if ( feed instanceof DataFeed ) { score = 0 ; if ( ( ( DataFeed ) feed ) . isInitialized ( ) ) { score = getRatingOfFeed ( feed ) ; } } else if ( feed instanceof SearchFeed ) { score = getRatingOfFeed ( feed ) ; } return score ; } private int getRatingOfFeed ( IFeed feed ) { int rating = feed . getRating ( ) ; if ( rating == - 1 ) { rating = feed instanceof SearchFeed ? IFeed . RATING_MAX : calcBlogStarzScore ( feed ) ; } return rating ; } public int calcBlogStarzScore ( IFeed feed ) { return ( Integer ) calculator . getValue ( feed ) ; } private int calculateTheScore ( IFeed feed ) { int score ; double activity = ( feed instanceof DataFeed ) ? calcActivity ( ( DataFeed ) feed ) : - 1 ; double inlinks = ( feed instanceof DirectFeed ) ? calcInlinks ( ( DirectFeed ) feed ) : - 1 ; double clickthroughs = calcClickthroughsScore ( feed ) ; double feedViews = calcFeedViewsScore ( feed ) ; double calcInlinksWeight = inlinks > - 1 ? inlinksWeight : 0 ; double calcActivityWeight = activity > - 1 ? activityWeight : 0 ; double totalWeight = calcActivityWeight + calcInlinksWeight + clickthroughsWeight + feedViewsWeight ; score = ( int ) ( ( activity * calcActivityWeight + inlinks * calcInlinksWeight + clickthroughs * clickthroughsWeight + feedViews * feedViewsWeight ) * 4 / totalWeight ) ; return score ; } public double calcClickthroughsScore ( IFeed feed ) { return maxClickthroughs == 0 ? 0 : ( double ) feed . getClickthroughs ( ) / maxClickthroughs ; } public double calcFeedViewsScore ( IFeed feed ) { return maxFeedViews == 0 ? 0 : ( double ) feed . getViews ( ) / maxFeedViews ; } public double calcInlinksScore ( DirectFeed feed ) { return feed . isInitialized ( ) ? calcInlinks ( feed ) : 0 ; } private double calcInlinks ( DirectFeed feed ) { return calcInlinksScore ( feed . getInLinks ( ) ) ; } public static double calcInlinksScore ( int inboundLinks ) { double aResult = - 1 ; if ( inboundLinks >= 0 ) { if ( inboundLinks < 100 ) { aResult = 0 ; } else if ( inboundLinks < 250 ) { aResult = 0.25 ; } else if ( inboundLinks < 1000 ) { aResult = 0.5 ; } else if ( inboundLinks < 2000 ) { aResult = 0.75 ; } else { aResult = 1 ; } } return aResult ; } public double calcActivity ( DataFeed feed ) { double activity = 0 ; int total = feed . getTotalPolledArticles ( ) ; long initTime = feed . getInitTime ( ) ; if ( initTime > 0 && total > 0 ) { long time = System . currentTimeMillis ( ) ; activity = ( ( double ) total / ( time - initTime ) ) / ( ( double ) topActivity / Constants . MILLIS_IN_DAY ) ; if ( activity > 1 ) activity = 1 ; } return activity ; } private Calculator calculator ; private void initThreading ( ) { calculator = new Calculator ( 1 ) ; } public void invalidateFeed ( IFeed feed ) { calculator . invalidateKey ( feed ) ; } public void invalidateAll ( ) { calculator . invalidateAll ( ) ; } public void feedRemoved ( IFeed feed ) { calculator . removeKey ( feed ) ; } public void loadPreferences ( StarzPreferences prefs ) { if ( prefs == null ) { activityWeight = - 1 ; inlinksWeight = - 1 ; clickthroughsWeight = - 1 ; feedViewsWeight = - 1 ; topActivity = - 1 ; } else { activityWeight = prefs . getActivityWeight ( ) ; inlinksWeight = prefs . getInlinksWeight ( ) ; clickthroughsWeight = prefs . getClickthroughsWeight ( ) ; feedViewsWeight = prefs . getFeedViewsWeight ( ) ; topActivity = prefs . getTopActivity ( ) ; } invalidateAll ( ) ; } public boolean dispatchPropertyChangeEvent ( PropertyChangeEvent evt ) { String prop = evt . getPropertyName ( ) ; final Object source = evt . getSource ( ) ; boolean invalidate = false ; if ( source instanceof StarzPreferences ) { StarzPreferences prefs = ( StarzPreferences ) source ; if ( StarzPreferences . PROP_ACTIVITY_WEIGHT . equals ( prop ) ) { activityWeight = prefs . getActivityWeight ( ) ; invalidate = true ; } else if ( StarzPreferences . PROP_INLINKS_WEIGHT . equals ( prop ) ) { inlinksWeight = prefs . getInlinksWeight ( ) ; invalidate = true ; } else if ( StarzPreferences . PROP_TOP_ACTIVITY . equals ( prop ) ) { topActivity = prefs . getTopActivity ( ) ; invalidate = true ; } else if ( StarzPreferences . PROP_CLICKTHROUGHS_WEIGHT . equals ( prop ) ) { clickthroughsWeight = prefs . getClickthroughsWeight ( ) ; invalidate = true ; } else if ( StarzPreferences . PROP_FEED_VIEWS_WEIGHT . equals ( prop ) ) { feedViewsWeight = prefs . getFeedViewsWeight ( ) ; invalidate = true ; } if ( invalidate ) invalidateAll ( ) ; } return invalidate ; } private class Calculator extends CachingCalculator { public Calculator ( int threads ) { super ( threads ) ; startThreads ( ) ; } protected String getThreadsBaseName ( ) { return "SC" ; } protected Object calculate ( Object key ) { return calculateTheScore ( ( IFeed ) key ) ; } } } 
=======
public class IdSoundnessChecker { private final IdTypeMap idTypeMap ; private final ErrorHandler eh ; private final Map < String , Entry > map = new HashMap < String , Entry > ( ) ; private static class Entry { Locator idLoc ; List < LocatorImpl > idrefLocs ; boolean hadId ; } public IdSoundnessChecker ( IdTypeMap idTypeMap , ErrorHandler eh ) { this . idTypeMap = idTypeMap ; this . eh = eh ; } public void reset ( ) { map . clear ( ) ; } public void endDocument ( ) throws SAXException { for ( String token : map . keySet ( ) ) { Entry entry = map . get ( token ) ; if ( ! entry . hadId ) { for ( LocatorImpl idrefLoc : entry . idrefLocs ) error ( "missing_id" , token , idrefLoc ) ; } } } public void attribute ( Name elementName , Name attributeName , String value , Locator locator ) throws SAXException { int idType = idTypeMap . getIdType ( elementName , attributeName ) ; if ( idType != Datatype . ID_TYPE_NULL ) { String [ ] tokens = StringSplitter . split ( value ) ; switch ( idType ) { case Datatype . ID_TYPE_ID : if ( tokens . length == 1 ) id ( tokens [ 0 ] , locator ) ; else if ( tokens . length == 0 ) error ( "id_no_tokens" , locator ) ; else error ( "id_multiple_tokens" , locator ) ; break ; case Datatype . ID_TYPE_IDREF : if ( tokens . length == 1 ) idref ( tokens [ 0 ] , locator ) ; else if ( tokens . length == 0 ) error ( "idref_no_tokens" , locator ) ; else error ( "idref_multiple_tokens" , locator ) ; break ; case Datatype . ID_TYPE_IDREFS : if ( tokens . length > 0 ) { for ( int j = 0 ; j < tokens . length ; j ++ ) idref ( tokens [ j ] , locator ) ; } else error ( "idrefs_no_tokens" , locator ) ; break ; } } } private void id ( String token , Locator locator ) throws SAXException { Entry entry = map . get ( token ) ; if ( entry == null ) { entry = new Entry ( ) ; map . put ( token , entry ) ; } else if ( entry . hadId ) { error ( "duplicate_id" , token , locator ) ; error ( "first_id" , token , entry . idLoc ) ; return ; } entry . idLoc = new LocatorImpl ( locator ) ; entry . hadId = true ; } private void idref ( String token , Locator locator ) { Entry entry = map . get ( token ) ; if ( entry == null ) { entry = new Entry ( ) ; map . put ( token , entry ) ; } if ( entry . hadId ) return ; if ( entry . idrefLocs == null ) entry . idrefLocs = new ArrayList < LocatorImpl > ( ) ; entry . idrefLocs . add ( new LocatorImpl ( locator ) ) ; } private void error ( String key , Locator locator ) throws SAXException { eh . error ( new SAXParseException ( SchemaBuilderImpl . localizer . message ( key ) , locator ) ) ; } private void error ( String key , String arg , Locator locator ) throws SAXException { eh . error ( new SAXParseException ( SchemaBuilderImpl . localizer . message ( key , arg ) , locator ) ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
