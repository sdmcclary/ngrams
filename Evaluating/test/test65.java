<<<<<<< HEAD
public class Maps { public static < K , V > Map < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < I1 , I2 , V , R > Map < I1 , Map < I2 , Entry < V , R > > > dig ( final Ternary < I1 , I2 , V , R > mapper , final Unary < I2 , V > getV , final Unary < I1 , Collection < I2 > > getI2Collection , final Collection < I1 > collection ) { return Transform . toMap ( new Transform . IdentityFunction < I1 > ( ) , new Unary < I1 , Map < I2 , Entry < V , R > > > ( ) { public Map < I2 , Entry < V , R > > f ( final I1 i1 ) { return Transform . toMap ( new Transform . IdentityFunction < I2 > ( ) , new Unary < I2 , Entry < V , R > > ( ) { public Entry < V , R > f ( I2 i2 ) { V v = getV . f ( i2 ) ; return new Pair < V , R > ( v , mapper . f ( i1 , i2 , v ) ) ; } } , getI2Collection . f ( i1 ) ) ; } } , collection ) ; } public static < I1 , I2 , V , R > Map < I1 , Map < I2 , Entry < V , R > > > digMap ( final Ternary < I1 , I2 , V , R > mapper , Map < I1 , Map < I2 , V > > map ) { return Transform . toMap ( new Transform . MapToKeyFunction < I1 , Map < I2 , V > > ( ) , new Unary < Entry < I1 , Map < I2 , V > > , Map < I2 , Entry < V , R > > > ( ) { public Map < I2 , Entry < V , R > > f ( final Entry < I1 , Map < I2 , V > > entry1 ) { return Transform . toMap ( new Transform . MapToKeyFunction < I2 , V > ( ) , new Unary < Entry < I2 , V > , Entry < V , R > > ( ) { public Entry < V , R > f ( Entry < I2 , V > entry2 ) { return new Pair < V , R > ( entry2 . getValue ( ) , mapper . f ( entry1 . getKey ( ) , entry2 . getKey ( ) , entry2 . getValue ( ) ) ) ; } } , entry1 . getValue ( ) . entrySet ( ) ) ; } } , map . entrySet ( ) ) ; } public static < I1 , I2 , R > Map < I1 , Collection < R > > digMapToCollection ( final Binary < I1 , I2 , R > mapper , Map < I1 , Collection < I2 > > map ) { return Transform . toMap ( new Transform . MapToKeyFunction < I1 , Collection < I2 > > ( ) , new Unary < Entry < I1 , Collection < I2 > > , Collection < R > > ( ) { public Collection < R > f ( final Entry < I1 , Collection < I2 > > entryI1I2 ) { return Transform . map ( new Unary < I2 , R > ( ) { public R f ( I2 i2 ) { return mapper . f ( entryI1I2 . getKey ( ) , i2 ) ; } } , entryI1I2 . getValue ( ) ) ; } } , map . entrySet ( ) ) ; } public static < I1 , I2 , I3 , R > Map < I1 , Map < I2 , Collection < R > > > digMapToCollection ( final Ternary < I1 , I2 , I3 , R > mapper , Map < I1 , Map < I2 , Collection < I3 > > > map ) { return Transform . toMap ( new Transform . MapToKeyFunction < I1 , Map < I2 , Collection < I3 > > > ( ) , new Unary < Entry < I1 , Map < I2 , Collection < I3 > > > , Map < I2 , Collection < R > > > ( ) { public Map < I2 , Collection < R > > f ( final Entry < I1 , Map < I2 , Collection < I3 > > > entryI1I2 ) { return Transform . toMap ( new Transform . MapToKeyFunction < I2 , Collection < I3 > > ( ) , new Unary < Entry < I2 , Collection < I3 > > , Collection < R > > ( ) { public Collection < R > f ( final Entry < I2 , Collection < I3 > > entryI2I3 ) { return Transform . map ( new Unary < I3 , R > ( ) { public R f ( I3 i3 ) { return mapper . f ( entryI1I2 . getKey ( ) , entryI2I3 . getKey ( ) , i3 ) ; } } , entryI2I3 . getValue ( ) ) ; } } , entryI1I2 . getValue ( ) . entrySet ( ) ) ; } } , map . entrySet ( ) ) ; } public static < I1 , I2 , I3 , I4 , R > Map < I1 , Map < I2 , Map < I3 , Collection < R > > > > digMapToCollection ( final Quaternary < I1 , I2 , I3 , I4 , R > mapper , Map < I1 , Map < I2 , Map < I3 , Collection < I4 > > > > map ) { return Transform . toMap ( new Transform . MapToKeyFunction < I1 , Map < I2 , Map < I3 , Collection < I4 > > > > ( ) , new Unary < Entry < I1 , Map < I2 , Map < I3 , Collection < I4 > > > > , Map < I2 , Map < I3 , Collection < R > > > > ( ) { public Map < I2 , Map < I3 , Collection < R > > > f ( final Entry < I1 , Map < I2 , Map < I3 , Collection < I4 > > > > entryI1I2 ) { return Transform . toMap ( new Transform . MapToKeyFunction < I2 , Map < I3 , Collection < I4 > > > ( ) , new Unary < Entry < I2 , Map < I3 , Collection < I4 > > > , Map < I3 , Collection < R > > > ( ) { public Map < I3 , Collection < R > > f ( final Entry < I2 , Map < I3 , Collection < I4 > > > entryI2I3 ) { return Transform . toMap ( new Transform . MapToKeyFunction < I3 , Collection < I4 > > ( ) , new Unary < Entry < I3 , Collection < I4 > > , Collection < R > > ( ) { public Collection < R > f ( final Entry < I3 , Collection < I4 > > entryI3I4 ) { return Transform . map ( new Unary < I4 , R > ( ) { public R f ( I4 i4 ) { return mapper . f ( entryI1I2 . getKey ( ) , entryI2I3 . getKey ( ) , entryI3I4 . getKey ( ) , i4 ) ; } } , entryI3I4 . getValue ( ) ) ; } } , entryI2I3 . getValue ( ) . entrySet ( ) ) ; } } , entryI1I2 . getValue ( ) . entrySet ( ) ) ; } } , map . entrySet ( ) ) ; } public static < T > Map < Integer , T > hashCodeMap ( Collection < T > items ) { return Transform . toMap ( new Unary < T , Integer > ( ) { public Integer f ( T item ) { return item . hashCode ( ) ; } } , new Transform . IdentityFunction < T > ( ) , items ) ; } public static < T > Map < Integer , T > hashCodeMap ( T ... items ) { return hashCodeMap ( Arrays . asList ( items ) ) ; } } 
=======
public class CompactParseable < P , NC , L , EA , CL extends CommentList < L > , A extends Annotations < L , EA , CL > > implements SubParseable < P , NC , L , EA , CL , A > { private final Input in ; private final Resolver resolver ; private final ErrorHandler eh ; private static final String MEDIA_TYPE = "application/relax-ng-compact-syntax" ; public CompactParseable ( Input in , Resolver resolver , ErrorHandler eh ) { this . in = in ; this . resolver = resolver ; this . eh = eh ; } public P parse ( SchemaBuilder < P , NC , L , EA , CL , A > sb , Scope < P , L , EA , CL , A > scope ) throws BuildException , IllegalSchemaException { return new CompactSyntax < P , NC , L , EA , CL , A > ( makeReader ( in ) , in . getUri ( ) , sb , eh ) . parse ( scope ) ; } public SubParseable < P , NC , L , EA , CL , A > createSubParseable ( String href , String base ) throws BuildException { Identifier id = new MediaTypedIdentifier ( href , base , MEDIA_TYPE ) ; Input input = new Input ( ) ; try { resolver . resolve ( id , input ) ; } catch ( ResolverException e ) { throw BuildException . fromResolverException ( e ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } return new CompactParseable < P , NC , L , EA , CL , A > ( input , resolver , eh ) ; } public P parseAsInclude ( SchemaBuilder < P , NC , L , EA , CL , A > sb , IncludedGrammar < P , L , EA , CL , A > g ) throws BuildException , IllegalSchemaException { return new CompactSyntax < P , NC , L , EA , CL , A > ( makeReader ( in ) , in . getUri ( ) , sb , eh ) . parseInclude ( g ) ; } public String getUri ( ) { String uri = in . getUri ( ) ; if ( uri == null ) return null ; return Uri . escapeDisallowedChars ( uri ) ; } private static final String UTF8 = EncodingMap . getJavaName ( "UTF-8" ) ; private static final String UTF16 = EncodingMap . getJavaName ( "UTF-16" ) ; private Reader makeReader ( Input in ) throws BuildException { try { resolver . open ( in ) ; Reader reader = in . getCharacterStream ( ) ; if ( reader == null ) { InputStream byteStream = in . getByteStream ( ) ; if ( byteStream == null ) throw new IllegalArgumentException ( "invalid input for CompactParseable" ) ; String encoding = in . getEncoding ( ) ; if ( encoding == null ) { PushbackInputStream pb = new PushbackInputStream ( byteStream , 2 ) ; encoding = detectEncoding ( pb ) ; byteStream = pb ; } reader = new InputStreamReader ( byteStream , encoding ) ; } return reader ; } catch ( ResolverException e ) { throw BuildException . fromResolverException ( e ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } static private String detectEncoding ( PushbackInputStream in ) throws IOException { String encoding = UTF8 ; int b1 = in . read ( ) ; if ( b1 != - 1 ) { int b2 = in . read ( ) ; if ( b2 != - 1 ) { in . unread ( b2 ) ; if ( ( b1 == 0xFF && b2 == 0xFE ) || ( b1 == 0xFE && b2 == 0xFF ) ) encoding = UTF16 ; } in . unread ( b1 ) ; } return encoding ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
