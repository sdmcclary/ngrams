public final class HTMLUtils { public static final int TAG_OPEN = 1 ; public static final int TAG_CLOSED = 2 ; public static final int TAG_SELF_CLOSED = 4 ; private HTMLUtils ( ) { } public static String stripTagEndings ( String tag ) { String tempName = tag . replaceAll ( "</" , "" ) ; tempName = tempName . replaceAll ( ">" , "" ) ; return tempName . replaceAll ( "<" , "" ) ; } public static String createOpenTag ( String tagName , boolean close ) { String temp = "<" + stripTagEndings ( tagName ) ; if ( close ) { return temp + ">" ; } else { return temp ; } } public static String createSelfClosedTag ( String tagName ) { String temp = "<" + stripTagEndings ( tagName ) ; return temp + " />" ; } public static String createCloseTag ( Lexeme tag , boolean close ) { if ( tag != null && tag . typeIndex == HTMLTokenTypes . START_TAG ) { return createCloseTag ( tag . getText ( ) . substring ( 1 ) , close ) ; } else { return null ; } } public static String createCloseTag ( String tagName , boolean close ) { String temp = "</" + stripTagEndings ( tagName ) ; if ( close ) { return temp + ">" ; } else { return temp ; } } public static String createCloseTag ( Lexeme tag , int offset , boolean close ) { String tempName = getOpenTagName ( tag , offset ) ; return createCloseTag ( tempName , close ) ; } public static String getOpenTagName ( Lexeme tag , int offset ) { String lexemeText = tag . getText ( ) ; if ( tag . containsOffset ( offset ) && offset > tag . offset ) { lexemeText = lexemeText . substring ( 0 , offset - tag . offset ) ; } String tempName = stripTagEndings ( lexemeText ) ; return tempName ; } public static boolean isEqualSignAlreadyInserted ( int offset , LexemeList ll ) { Lexeme sibling = ll . getLexemeFromOffset ( offset ) ; if ( sibling != null && sibling . getText ( ) . equals ( "=" ) ) { return true ; } return false ; } public static boolean isTextQuoted ( String text ) { return isTextQuoted ( text , "\"" ) || isTextQuoted ( text , "'" ) ; } public static boolean isTextQuoted ( String text , String quote ) { if ( text . length ( ) < 2 ) { return false ; } if ( text . startsWith ( quote ) && text . endsWith ( quote ) ) { return true ; } return false ; } public static int isTagClosed ( Lexeme tag , LexemeList lexemeList ) { int position = lexemeList . getLexemeIndex ( tag ) + 1 ; if ( position < 0 ) { return TAG_OPEN ; } while ( position < lexemeList . size ( ) ) { Lexeme curLexeme = lexemeList . get ( position ) ; if ( curLexeme . typeIndex == HTMLTokenTypes . START_TAG || curLexeme . typeIndex == HTMLTokenTypes . END_TAG ) { return TAG_OPEN ; } if ( curLexeme . typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN ) { return TAG_SELF_CLOSED ; } if ( curLexeme . typeIndex == HTMLTokenTypes . GREATER_THAN ) { return TAG_CLOSED ; } position ++ ; } return TAG_OPEN ; } public static boolean isStartTagBalanced ( Lexeme tag , LexemeList lexemeList , HTMLParseState parseState ) { int index = lexemeList . getLexemeIndex ( tag ) ; if ( index == lexemeList . size ( ) - 1 ) { return false ; } if ( tag == null || lexemeList == null || parseState == null ) { throw new IllegalArgumentException ( "null arguments are not accepted" ) ; } if ( ! isStartTag ( tag ) ) { return false ; } if ( isTagSelfClosed ( tag , lexemeList ) ) { return true ; } String originalTagName = stripTagEndings ( tag . getText ( ) ) ; if ( parseState . getCloseTagType ( originalTagName ) == HTMLTagInfo . END_FORBIDDEN ) { return true ; } int balance = 0 ; boolean trackingClose = false ; for ( int i = 0 ; i < lexemeList . size ( ) ; i ++ ) { Lexeme currentLexeme = lexemeList . get ( i ) ; if ( isStartTag ( currentLexeme ) ) { String currenTagName = stripTagEndings ( currentLexeme . getText ( ) ) ; if ( originalTagName . equals ( currenTagName ) ) { trackingClose = true ; } } else if ( isEndTag ( currentLexeme ) ) { if ( trackingClose ) { balance ++ ; trackingClose = false ; } String currenTagName = stripTagEndings ( currentLexeme . getText ( ) ) ; if ( originalTagName . equals ( currenTagName ) ) { balance -- ; } } else if ( trackingClose ) { if ( currentLexeme . typeIndex == HTMLTokenTypes . START_TAG || currentLexeme . typeIndex == HTMLTokenTypes . END_TAG ) { balance ++ ; trackingClose = false ; } else if ( currentLexeme . typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN ) { trackingClose = false ; } else if ( currentLexeme . typeIndex == HTMLTokenTypes . GREATER_THAN ) { balance ++ ; trackingClose = false ; } } } return balance <= 0 ; } public static boolean isEndTagBalanced ( Lexeme tag , LexemeList lexemeList , HTMLParseState parseState ) { int index = lexemeList . getLexemeIndex ( tag ) ; if ( index == 0 ) { return false ; } if ( tag == null || lexemeList == null || parseState == null ) { throw new IllegalArgumentException ( "null arguments are not accepted" ) ; } if ( ! isEndTag ( tag ) ) { return false ; } if ( isTagSelfClosed ( tag , lexemeList ) ) { return true ; } String originalTagName = stripTagEndings ( tag . getText ( ) ) ; if ( parseState . getCloseTagType ( originalTagName ) == HTMLTagInfo . END_FORBIDDEN ) { return true ; } int balance = 1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { Lexeme currentLexeme = lexemeList . get ( i ) ; if ( isEndTag ( currentLexeme ) ) { String currenTagName = stripTagEndings ( currentLexeme . getText ( ) ) ; if ( originalTagName . equals ( currenTagName ) ) { balance ++ ; } } else if ( isStartTag ( currentLexeme ) ) { String currenTagName = stripTagEndings ( currentLexeme . getText ( ) ) ; if ( originalTagName . equals ( currenTagName ) ) { balance -- ; if ( balance <= 0 ) return true ; } } } return false ; } public static boolean isTagSelfClosed ( Lexeme tag , LexemeList lexemeList ) { if ( ! isStartTag ( tag ) ) { return false ; } int position = lexemeList . getLexemeIndex ( tag ) + 1 ; if ( position < 0 ) { return false ; } while ( position < lexemeList . size ( ) ) { Lexeme curLexeme = lexemeList . get ( position ) ; if ( curLexeme . typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN ) { return true ; } if ( curLexeme . typeIndex == HTMLTokenTypes . END_TAG ) { return false ; } if ( curLexeme . typeIndex == HTMLTokenTypes . GREATER_THAN ) { return false ; } if ( curLexeme . typeIndex == HTMLTokenTypes . START_TAG ) { return false ; } position ++ ; } return false ; } public static Lexeme getPreviousUnclosedTag ( Lexeme lexeme , LexemeList lexemeList , HTMLParseState parseState ) { if ( lexeme == null ) { return null ; } int position = lexemeList . getLexemeIndex ( lexeme ) - 1 ; Lexeme startTag = null ; boolean selfClosed = false ; Stack < Lexeme > tags = new Stack < Lexeme > ( ) ; while ( position >= 0 ) { Lexeme curLexeme = lexemeList . get ( position ) ; if ( curLexeme . typeIndex == HTMLTokenTypes . END_TAG ) { tags . push ( curLexeme ) ; } if ( curLexeme . typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN ) { selfClosed = true ; } if ( curLexeme . typeIndex == HTMLTokenTypes . START_TAG ) { if ( selfClosed ) { selfClosed = false ; position -- ; continue ; } String tagName = stripTagEndings ( curLexeme . getText ( ) ) ; if ( tags . size ( ) == 0 ) { if ( parseState . getCloseTagType ( tagName ) == HTMLTagInfo . END_FORBIDDEN ) { position -- ; continue ; } else { return curLexeme ; } } Lexeme l = tags . pop ( ) ; if ( l . typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN ) { position -- ; continue ; } if ( parseState . getCloseTagType ( tagName ) == HTMLTagInfo . END_REQUIRED ) { position -- ; continue ; } if ( stripTagEndings ( l . getText ( ) ) . equals ( tagName ) ) { position -- ; continue ; } else { return curLexeme ; } } position -- ; } return startTag ; } public static Lexeme getTagOpenLexeme ( int offset , LexemeList lexemeList ) { int index = ParentOffsetMapper . getLexemeIndexFromDocumentOffset ( offset , lexemeList ) ; if ( index > - 1 ) { Lexeme l = lexemeList . get ( index ) ; return getTagOpenLexeme ( l , lexemeList ) ; } else { return null ; } } public static Lexeme getTagOpenLexeme ( Lexeme lexeme , LexemeList lexemeList ) { Lexeme startTag = null ; int position = lexemeList . getLexemeIndex ( lexeme ) ; while ( position >= 0 ) { Lexeme curLexeme = lexemeList . get ( position ) ; if ( curLexeme . typeIndex == HTMLTokenTypes . END_TAG ) { break ; } if ( curLexeme . typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN ) { break ; } if ( curLexeme . typeIndex == HTMLTokenTypes . GREATER_THAN ) { break ; } if ( curLexeme . typeIndex == HTMLTokenTypes . START_TAG ) { startTag = curLexeme ; break ; } position -- ; } return startTag ; } public static boolean insideQuotedString ( Lexeme lexeme , int offset ) { String text = lexeme . getText ( ) ; if ( ( text . startsWith ( "\"" ) || text . startsWith ( "'" ) ) && lexeme . containsOffset ( offset ) ) { return true ; } return false ; } public static boolean insideOpenTag ( int offset , LexemeList lexemeList ) { Lexeme startLexeme = HTMLUtils . getTagOpenLexeme ( offset , lexemeList ) ; return ( startLexeme != null ) ; } public static boolean isStartTag ( Lexeme lexeme ) { return ( lexeme . typeIndex == HTMLTokenTypes . START_TAG || ( lexeme . typeIndex == HTMLTokenTypes . ERROR && lexeme . getText ( ) . equals ( "<" ) ) || ( lexeme . typeIndex == HTMLTokenTypes . TEXT && lexeme . getText ( ) . trim ( ) . equals ( "<" ) ) ) ; } public static boolean isEndTag ( Lexeme lexeme ) { return ( lexeme . typeIndex == HTMLTokenTypes . END_TAG || ( lexeme . typeIndex == HTMLTokenTypes . TEXT && lexeme . getText ( ) . equals ( "</" ) ) ) ; } public static Lexeme getFirstLexemeWithText ( String lexemeText , LexemeList lexemeList ) { for ( int i = 0 ; i < lexemeList . size ( ) ; i ++ ) { Lexeme l = lexemeList . get ( i ) ; if ( l . getText ( ) . equals ( lexemeText ) ) { return l ; } } return null ; } public static Lexeme [ ] getLexemesOfType ( int lexemeTypes , LexemeList lexemeList , String language ) { return getLexemesOfType ( new int [ ] { lexemeTypes } , lexemeList , language ) ; } public static Lexeme [ ] getLexemesOfType ( int [ ] lexemeTypes , LexemeList lexemeList , String language ) { Arrays . sort ( lexemeTypes ) ; List < Lexeme > lexemes = new ArrayList < Lexeme > ( ) ; for ( int i = 0 ; i < lexemeList . size ( ) ; i ++ ) { Lexeme l = lexemeList . get ( i ) ; if ( l . getLanguage ( ) . equals ( language ) && Arrays . binarySearch ( lexemeTypes , l . typeIndex ) >= 0 ) { lexemes . add ( l ) ; } } return lexemes . toArray ( new Lexeme [ lexemes . size ( ) ] ) ; } public static Lexeme getTagCloseLexeme ( int offset , LexemeList lexemeList ) { Lexeme l = lexemeList . getCeilingLexeme ( offset ) ; return getTagCloseLexeme ( l , lexemeList ) ; } public static Lexeme getTagCloseLexeme ( Lexeme startLexeme , LexemeList lexemeList ) { return getNextLexemeOfType ( startLexeme , new int [ ] { HTMLTokenTypes . GREATER_THAN , HTMLTokenTypes . SLASH_GREATER_THAN } , lexemeList ) ; } public static Lexeme getNextLexemeOfType ( Lexeme startLexeme , int [ ] lexemeTypes , LexemeList lexemeList ) { return getNextLexemeOfType ( startLexeme , lexemeTypes , new int [ 0 ] , lexemeList ) ; } public static Lexeme getNextLexemeOfType ( Lexeme startLexeme , int [ ] lexemeTypes , int [ ] lexemeTypesToBail , LexemeList lexemeList ) { Arrays . sort ( lexemeTypes ) ; Arrays . sort ( lexemeTypesToBail ) ; int index = lexemeList . getLexemeIndex ( startLexeme ) ; for ( int i = index ; i < lexemeList . size ( ) ; i ++ ) { Lexeme l = lexemeList . get ( i ) ; if ( Arrays . binarySearch ( lexemeTypes , l . typeIndex ) >= 0 ) { return l ; } if ( Arrays . binarySearch ( lexemeTypesToBail , l . typeIndex ) >= 0 ) { return null ; } } return null ; } public static Map < String , String > gatherAttributes ( Lexeme openTagLexeme , Lexeme closeTagLexeme , LexemeList lexemeList ) { Map < String , String > h = new HashMap < String , String > ( ) ; if ( openTagLexeme == null || closeTagLexeme == null ) { return h ; } int startIndex = lexemeList . getLexemeIndex ( openTagLexeme ) ; int endIndex = lexemeList . size ( ) - 1 ; if ( closeTagLexeme != null ) { endIndex = lexemeList . getLexemeIndex ( closeTagLexeme ) ; } if ( startIndex > endIndex ) { throw new IndexOutOfBoundsException ( Messages . HTMLUtils_0 ) ; } String currentName = null ; boolean foundEquals = false ; boolean foundQuote = false ; while ( startIndex < endIndex ) { startIndex ++ ; Lexeme l = lexemeList . get ( startIndex ) ; if ( l . typeIndex == HTMLTokenTypes . NAME && ! foundEquals ) { currentName = l . getText ( ) ; continue ; } if ( l . typeIndex == HTMLTokenTypes . EQUAL ) { foundEquals = true ; continue ; } else if ( l . typeIndex == HTMLTokenTypes . STRING || ( foundEquals && l . typeIndex == HTMLTokenTypes . NAME ) ) { foundEquals = false ; if ( currentName != null && ! h . containsKey ( currentName ) ) { h . put ( currentName , l . getText ( ) ) ; } } else if ( l . typeIndex == HTMLTokenTypes . QUOTE ) { if ( foundQuote == true ) { foundQuote = false ; foundEquals = false ; if ( currentName != null && ! h . containsKey ( currentName ) ) { h . put ( currentName , "" ) ; } } else { foundQuote = true ; } } } return h ; } public static String quoteAttributeValue ( IPreferenceStore store , String value ) { String quoteChar = "" ; if ( store != null ) { quoteChar = store . getString ( IPreferenceConstants . ATTRIBUTE_QUOTE_CHARACTER ) ; } return quoteChar + value + quoteChar ; } public static boolean insertEquals ( IPreferenceStore store ) { if ( store != null ) { return store . getBoolean ( IPreferenceConstants . HTMLEDITOR_INSERT_EQUALS ) ; } else { return false ; } } public static Lexeme getFirstLexemeBreaking ( LexemeList lexemeList , int index , int [ ] acceptedTypes , int [ ] deniedTypes ) { if ( index >= lexemeList . size ( ) ) { return null ; } for ( int i = index ; i < lexemeList . size ( ) ; i ++ ) { Lexeme currentLexeme = lexemeList . get ( i ) ; for ( int j = 0 ; j < deniedTypes . length ; j ++ ) { if ( currentLexeme . typeIndex == deniedTypes [ j ] ) { return null ; } } for ( int j = 0 ; j < acceptedTypes . length ; j ++ ) { if ( currentLexeme . typeIndex == acceptedTypes [ j ] ) { return currentLexeme ; } } } return null ; } } 