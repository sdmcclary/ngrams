public abstract class UnifiedAutoIndentStrategy implements IAutoEditStrategy , IPreferenceClient { protected SourceViewerConfiguration configuration ; protected ISourceViewer sourceViewer ; protected EditorFileContext context ; private String spaces = "                                                                            " ; public UnifiedAutoIndentStrategy ( EditorFileContext context , SourceViewerConfiguration configuration , ISourceViewer sourceViewer ) { this . context = context ; this . configuration = configuration ; this . sourceViewer = sourceViewer ; } public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { if ( command . text == null || command . length > 0 ) { return ; } String [ ] lineDelimiters = document . getLegalLineDelimiters ( ) ; int index = TextUtilities . endsWith ( lineDelimiters , command . text ) ; if ( index > - 1 ) { if ( lineDelimiters [ index ] . equals ( command . text ) ) { indentAfterNewLine ( document , command ) ; } return ; } else if ( command . text . equals ( "\t" ) ) { if ( configuration instanceof UnifiedConfiguration ) { UnifiedConfiguration uc = ( UnifiedConfiguration ) configuration ; if ( uc . useSpacesAsTabs ( ) ) { command . text = uc . getTabAsSpaces ( ) ; } } } else if ( command . text . length ( ) == 1 && isAutoInsertCharacter ( command . text . charAt ( 0 ) ) && isAutoInsertEnabled ( ) && isValidAutoInsertLocation ( document , command ) ) { char current = command . text . charAt ( 0 ) ; if ( overwriteBracket ( current , document , command , getLexemeList ( ) ) ) { return ; } } } private boolean isAutoInsertCharacter ( char c ) { int val = Arrays . binarySearch ( getAutoInsertCharacters ( ) , c ) ; return val >= 0 ; } protected char [ ] getAutoInsertCharacters ( ) { return new char [ ] { '(' , '<' , '[' , '"' , '\'' , '{' } ; } protected char [ ] getAutoOverwriteCharacters ( ) { return new char [ ] { ')' , '>' , ']' , '"' , '\'' , '}' } ; } protected boolean isAutoInsertEnabled ( ) { IPreferenceStore store = getPreferenceStore ( ) ; String abi = com . aptana . ide . editors . preferences . IPreferenceConstants . AUTO_BRACKET_INSERTION ; return ( store == null || store . getString ( abi ) . equals ( "NONE" ) == false ) ; } protected boolean isValidAutoInsertLocation ( IDocument d , DocumentCommand c ) { return true ; } protected void indentAfterNewLine ( IDocument d , DocumentCommand c ) { String indentString = getIndentString ( ) ; if ( indentString . equals ( StringUtils . EMPTY ) ) { return ; } int offset = c . offset ; if ( offset == - 1 || d . getLength ( ) == 0 ) { return ; } c . text += getIndentationAtOffset ( d , offset ) ; return ; } public boolean overwriteBracket ( char bracket , IDocument document , DocumentCommand command , LexemeList ll ) { if ( canOverwriteBracket ( bracket , command . offset , document , ll ) ) { command . text = StringUtils . EMPTY ; command . shiftsCaret = false ; command . caretOffset = command . offset + 1 ; return true ; } return false ; } public boolean canOverwriteBracket ( char bracket , int offset , IDocument document , LexemeList ll ) { if ( offset < document . getLength ( ) ) { char [ ] autoOverwriteChars = getAutoOverwriteCharacters ( ) ; Arrays . sort ( autoOverwriteChars ) ; if ( Arrays . binarySearch ( autoOverwriteChars , bracket ) < 0 ) { return false ; } try { char sibling = document . getChar ( offset ) ; return sibling == bracket ; } catch ( BadLocationException ex ) { return false ; } } return false ; } public boolean closeBracket ( char bracket , IDocument document , DocumentCommand command ) { if ( ! canCloseBracket ( bracket , document ) ) { return false ; } else { command . text = Character . toString ( bracket ) + Character . toString ( UnifiedBracketInserterBase . getPeerCharacter ( bracket ) ) ; command . shiftsCaret = false ; command . caretOffset = command . offset + 1 ; return true ; } } public boolean canCloseBracket ( char bracket , IDocument document ) { if ( ! UnifiedBracketInserterBase . hasPeerCharacter ( bracket ) ) { return false ; } char [ ] autoInsertChars = getAutoInsertCharacters ( ) ; Arrays . sort ( autoInsertChars ) ; if ( Arrays . binarySearch ( autoInsertChars , bracket ) < 0 ) { return false ; } return ! UnifiedBracketInserterBase . isStringBalanced ( document . get ( ) , bracket , true ) ; } protected String getIndentationAtOffset ( IDocument d , int offset ) { String indentation = StringUtils . EMPTY ; try { int p = ( offset == d . getLength ( ) ? offset - 1 : offset ) ; IRegion line = d . getLineInformationOfOffset ( p ) ; int lineOffset = line . getOffset ( ) ; int firstNonWS = findEndOfWhiteSpace ( d , lineOffset , offset ) ; indentation = getIndentationString ( d , lineOffset , firstNonWS ) ; } catch ( BadLocationException excp ) { } return indentation ; } protected String getIndentString ( ) { String [ ] indents = this . configuration . getIndentPrefixes ( this . sourceViewer , this . context . getDefaultLanguage ( ) ) ; boolean hasIndents = ! ( ( indents == null ) || ( indents . length == 0 ) ) ; String indentString = hasIndents ? indents [ 0 ] : "\t" ; return indentString ; } protected String getIndentationString ( IDocument d , int lineOffset , int firstNonWS ) { String lineIndent = StringUtils . EMPTY ; try { lineIndent = d . get ( lineOffset , firstNonWS - lineOffset ) ; } catch ( BadLocationException e1 ) { } if ( lineIndent . equals ( StringUtils . EMPTY ) ) { return lineIndent ; } int indentSize = 0 ; int tabWidth = this . configuration . getTabWidth ( sourceViewer ) ; char [ ] indentChars = lineIndent . toCharArray ( ) ; for ( int i = 0 ; i < indentChars . length ; i ++ ) { char e = indentChars [ i ] ; if ( e == '\t' ) { indentSize += tabWidth - ( indentSize % tabWidth ) ; } else { indentSize ++ ; } } String indentString = getIndentString ( ) ; int indentStringWidth = ( indentString . equals ( "\t" ) ) ? tabWidth : indentString . length ( ) ; if ( indentStringWidth == 0 ) { return StringUtils . EMPTY ; } int indentCount = ( int ) Math . floor ( indentSize / indentStringWidth ) ; String indentation = StringUtils . EMPTY ; for ( int i = 0 ; i < indentCount ; i ++ ) { indentation += indentString ; } int extra = indentSize % indentStringWidth ; indentation += spaces . substring ( 0 , extra ) ; return indentation ; } protected String getIndentForCurrentLine ( IDocument d , DocumentCommand c ) { if ( c . offset == - 1 || d . getLength ( ) == 0 ) { return StringUtils . EMPTY ; } try { int p = ( c . offset == d . getLength ( ) ? c . offset - 1 : c . offset ) ; IRegion info = d . getLineInformationOfOffset ( p ) ; int start = info . getOffset ( ) ; int end = findEndOfWhiteSpace ( d , start , c . offset ) ; StringBuffer buf = new StringBuffer ( ) ; if ( end > start ) { buf . append ( d . get ( start , end - start ) ) ; } return buf . toString ( ) ; } catch ( BadLocationException excp ) { } return StringUtils . EMPTY ; } protected int findEndOfWhiteSpace ( IDocument document , int offset , int end ) throws BadLocationException { while ( offset < end ) { char c = document . getChar ( offset ) ; if ( c != ' ' && c != '\t' ) { return offset ; } offset ++ ; } return end ; } public abstract IPreferenceStore getPreferenceStore ( ) ; protected abstract LexemeList getLexemeList ( ) ; protected boolean indentAfterOpenBrace ( IDocument d , DocumentCommand command ) { int offset = command . offset ; boolean result = false ; if ( offset != - 1 && d . getLength ( ) != 0 ) { String indent = getIndentForCurrentLine ( d , command ) ; String newline = command . text ; String tab = "\t" ; if ( configuration instanceof UnifiedConfiguration ) { UnifiedConfiguration uc = ( UnifiedConfiguration ) configuration ; tab = uc . getIndent ( ) ; } try { if ( command . offset > 0 ) { char c = d . getChar ( command . offset - 1 ) ; if ( c == '{' ) { String startIndent = newline + indent + tab ; if ( command . offset < d . getLength ( ) && d . getChar ( command . offset ) == '}' ) { command . text = startIndent + newline + indent ; } else { command . text = startIndent ; } command . shiftsCaret = false ; command . caretOffset = command . offset + startIndent . length ( ) ; result = true ; } } } catch ( BadLocationException e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , StringUtils . format ( Messages . UnifiedAutoIndentStrategy_InvalidOffset , offset ) , e ) ; } } return result ; } protected void triggerContentAssistPopup ( ) { if ( sourceViewer instanceof SourceViewer ) { if ( ! autoTriggerAssist ( ) ) { return ; } ( ( SourceViewer ) sourceViewer ) . doOperation ( ISourceViewer . CONTENTASSIST_PROPOSALS ) ; } } protected void hideContentAssistPopup ( ) { if ( sourceViewer instanceof UnifiedViewer ) { ( ( UnifiedViewer ) sourceViewer ) . closeContentAssist ( ) ; } } protected void triggerContextAssistPopup ( ) { if ( sourceViewer instanceof SourceViewer ) { if ( ! autoTriggerAssist ( ) ) { return ; } ( ( SourceViewer ) sourceViewer ) . doOperation ( ISourceViewer . CONTENTASSIST_CONTEXT_INFORMATION ) ; } } protected boolean autoTriggerAssist ( ) { return ( getPreferenceStore ( ) != null && getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . CODE_ASSIST_AUTO_ACTIVATION ) ) ; } } 