<<<<<<< HEAD
public class GeneticAgent extends RegisterableAgent implements Agent , CrossoverEvolvable { private double score ; private boolean [ ] genes ; private Sensors sensors = new Sensors ( ) ; private int jumpCounter = 0 ; protected int [ ] marioPosition = null ; private int maxJumpCount ; public static final Random random = new Random ( ) ; private static final int numberOfCases = 6 ; private static final int numberOfButtons = Environment . numberOfButtons * GeneticAgent . numberOfCases ; private static final int CASE_DEFAULT = 0 ; private static final int CASE_WALL = 1 ; private static final int CASE_ENEMIES = 2 ; private static final int CASE_FIREBALLS = 3 ; private static final int CASE_NO_FIREBALLS = 4 ; private static final int CASE_JUMP_COUNT = 5 ; public GeneticAgent ( ) { super ( "GeneticAgent" ) ; action = new boolean [ Environment . numberOfButtons ] ; genes = new boolean [ GeneticAgent . numberOfButtons ] ; maxJumpCount = GeneticAgent . random . nextInt ( ) ; for ( int i = 0 ; i < GeneticAgent . numberOfButtons ; i ++ ) { this . genes [ i ] = GeneticAgent . random . nextBoolean ( ) ; } } public GeneticAgent ( int randSeed ) { super ( "GeneticAgent" ) ; action = new boolean [ Environment . numberOfButtons ] ; genes = new boolean [ GeneticAgent . numberOfButtons ] ; GeneticAgent . random . setSeed ( randSeed ) ; for ( int i = 0 ; i < GeneticAgent . numberOfButtons ; i ++ ) { genes [ i ] = GeneticAgent . random . nextBoolean ( ) ; } reset ( ) ; } public CrossoverEvolvable getNewInstance ( ) { return new GeneticAgent ( ) ; } public CrossoverEvolvable copy ( ) { GeneticAgent agent = new GeneticAgent ( ) ; agent . score = this . score ; agent . sensors = this . sensors ; for ( int i = 0 ; i < GeneticAgent . numberOfButtons ; i ++ ) { agent . genes [ i ] = this . genes [ i ] ; } return agent ; } public void mutate ( ) { int index = ( int ) ( Math . random ( ) * GeneticAgent . numberOfButtons ) ; this . genes [ index ] = ! this . genes [ index ] ; this . maxJumpCount = GeneticAgent . random . nextInt ( ) ; } public CrossoverEvolvable [ ] crossover ( CrossoverEvolvable other ) { int randomIndex = ( int ) ( Math . random ( ) * genes . length ) ; boolean temp ; GeneticAgent [ ] child = new GeneticAgent [ 2 ] ; child [ 0 ] = ( GeneticAgent ) other . copy ( ) ; child [ 1 ] = ( GeneticAgent ) this . copy ( ) ; if ( GeneticAgent . random . nextBoolean ( ) ) { for ( int i = randomIndex ; i < genes . length ; i ++ ) { temp = child [ 0 ] . genes [ i ] ; child [ 0 ] . genes [ i ] = child [ 1 ] . genes [ i ] ; child [ 1 ] . genes [ i ] = temp ; } } else { for ( int i = 0 ; i < randomIndex ; i ++ ) { temp = child [ 0 ] . genes [ i ] ; child [ 0 ] . genes [ i ] = child [ 1 ] . genes [ i ] ; child [ 1 ] . genes [ i ] = temp ; } } randomIndex = GeneticAgent . random . nextInt ( 32 ) ; int mask = 0 | ( 1 << randomIndex ) ; int jumpCountA = child [ 0 ] . maxJumpCount & mask ; int jumpCountB = child [ 1 ] . maxJumpCount & mask ; child [ 0 ] . maxJumpCount = ( child [ 0 ] . maxJumpCount & ~ mask ) | jumpCountB ; child [ 1 ] . maxJumpCount = ( child [ 1 ] . maxJumpCount & ~ mask ) | jumpCountA ; return child ; } public void reset ( ) { for ( int i = 0 ; i < Environment . numberOfButtons ; i ++ ) { action [ i ] = genes [ i ] ; } } protected boolean DangerOfGap ( byte [ ] [ ] levelScene ) { for ( int x = 9 ; x < 13 ; ++ x ) { boolean f = true ; for ( int y = 12 ; y < 22 ; ++ y ) { if ( levelScene [ y ] [ x ] != 0 ) f = false ; } if ( f && levelScene [ 12 ] [ 11 ] != 0 ) return true ; } return false ; } private boolean dangerousEnemies ( byte [ ] [ ] enemiesScene ) { int y = marioPosition [ 0 ] ; int x = marioPosition [ 1 ] ; if ( sensors . isDangerous ( enemiesScene [ y ] [ x ] ) || sensors . isDangerous ( enemiesScene [ y ] [ x + 1 ] ) || sensors . isDangerous ( enemiesScene [ y ] [ x + 2 ] ) ) return true ; return false ; } public void copyState ( int caseValue ) { int start = Environment . numberOfButtons * caseValue ; int end = start + Environment . numberOfButtons ; for ( int i = start ; i < end ; i ++ ) { action [ ( i % 5 ) ] = genes [ i ] ; } } public boolean [ ] getAction ( Environment observation ) { sensors . updateReadings ( observation ) ; marioPosition = sensors . getMarioPosition ( ) ; boolean wasJump = action [ Mario . KEY_JUMP ] ; if ( sensors . levelScene [ 11 ] [ 13 ] != 0 || sensors . levelScene [ 11 ] [ 12 ] != 0 || DangerOfGap ( sensors . levelScene ) ) { if ( observation . mayMarioJump ( ) || ( ! observation . isMarioOnGround ( ) && action [ Mario . KEY_JUMP ] ) ) { copyState ( GeneticAgent . CASE_WALL ) ; } } else if ( dangerousEnemies ( sensors . enemiesScene ) ) { copyState ( GeneticAgent . CASE_ENEMIES ) ; } else { copyState ( GeneticAgent . CASE_DEFAULT ) ; } if ( jumpCounter > this . maxJumpCount ) { copyState ( GeneticAgent . CASE_JUMP_COUNT ) ; } if ( sensors . fireballsOnScreen == 0 ) { copyState ( GeneticAgent . CASE_NO_FIREBALLS ) ; } else { copyState ( GeneticAgent . CASE_FIREBALLS ) ; } if ( action [ Mario . KEY_JUMP ] ) { jumpCounter ++ ; } else if ( wasJump ) { jumpCounter = 0 ; } return action ; } public void setScore ( double score ) { this . score = score ; } public double getScore ( ) { return score ; } public String toString ( ) { String genome = "" ; for ( int i = 0 ; i < genes . length ; i ++ ) { genome += genes [ i ] ? "1" : "0" ; } return genome + " (Max Jump: " + this . maxJumpCount + ")" ; } } 
=======
abstract class AbstractDatetime extends AbstractDatatype { private static int [ ] DAYS_IN_MONTHS = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; AbstractDatetime ( ) { super ( ) ; } private void checkMonth ( String year , String month ) throws DatatypeException { checkMonth ( Integer . parseInt ( year ) , Integer . parseInt ( month ) ) ; } private void checkMonth ( int year , int month ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } } private void checkDate ( String year , String month , String day ) throws DatatypeException { checkDate ( Integer . parseInt ( year ) , Integer . parseInt ( month ) , Integer . parseInt ( day ) ) ; } private void checkDate ( int year , int month , int day ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } if ( day < 1 ) { throw newDatatypeException ( "Day cannot be less than 1." ) ; } if ( day > DAYS_IN_MONTHS [ month - 1 ] ) { if ( ! ( day == 29 && month == 2 && isLeapYear ( year ) ) ) { throw newDatatypeException ( "Day out of range." ) ; } } } private boolean isLeapYear ( int year ) { return ( year % 400 == 0 ) || ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) ; } private void checkYearlessDate ( String month , String day ) throws DatatypeException { checkYearlessDate ( Integer . parseInt ( month ) , Integer . parseInt ( day ) ) ; } private void checkYearlessDate ( int month , int day ) throws DatatypeException { if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } if ( day < 1 ) { throw newDatatypeException ( "Day cannot be less than 1." ) ; } } private void checkWeek ( String year , String week ) throws DatatypeException { checkWeek ( Integer . parseInt ( year ) , Integer . parseInt ( week ) ) ; } private void checkWeek ( int year , int week ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( week < 1 ) { throw newDatatypeException ( "Week cannot be less than 1." ) ; } if ( week > 53 ) { throw newDatatypeException ( "Week cannot be greater than 53." ) ; } } protected final void checkHour ( String hour ) throws DatatypeException { checkHour ( Integer . parseInt ( hour ) ) ; } private void checkHour ( int hour ) throws DatatypeException { if ( hour > 23 ) { throw newDatatypeException ( "Hour cannot be greater than 23." ) ; } } protected final void checkMinute ( String minute ) throws DatatypeException { checkMinute ( Integer . parseInt ( minute ) ) ; } private void checkMinute ( int minute ) throws DatatypeException { if ( minute > 59 ) { throw newDatatypeException ( "Minute cannot be greater than 59." ) ; } } protected final void checkSecond ( String second ) throws DatatypeException { checkSecond ( Integer . parseInt ( second ) ) ; } private void checkSecond ( int second ) throws DatatypeException { if ( second > 59 ) { throw newDatatypeException ( "Second cannot be greater than 59." ) ; } } protected final void checkMilliSecond ( String millisecond ) throws DatatypeException { if ( millisecond . length ( ) > 3 ) { throw newDatatypeException ( "A fraction of a second must be one, two, or three digits." ) ; } } private void checkTzd ( String hours , String minutes ) throws DatatypeException { if ( hours . charAt ( 0 ) == '+' ) { hours = hours . substring ( 1 ) ; } checkTzd ( Integer . parseInt ( hours ) , Integer . parseInt ( minutes ) ) ; } private void checkTzd ( int hours , int minutes ) throws DatatypeException { if ( hours < - 23 || hours > 23 ) { throw newDatatypeException ( "Hours out of range in time zone designator." ) ; } if ( minutes > 59 ) { throw newDatatypeException ( "Minutes out of range in time zone designator." ) ; } } protected abstract Pattern getPattern ( ) ; public void checkValid ( CharSequence literal ) throws DatatypeException { String year ; String month ; String day ; String hour ; String minute ; String seconds ; String milliseconds ; String tzdHours ; String tzdMinutes ; Matcher m = getPattern ( ) . matcher ( literal ) ; if ( m . matches ( ) ) { year = m . group ( 1 ) ; month = m . group ( 2 ) ; if ( year != null ) { checkMonth ( year , month ) ; return ; } year = m . group ( 3 ) ; month = m . group ( 4 ) ; day = m . group ( 5 ) ; if ( year != null ) { checkDate ( year , month , day ) ; return ; } month = m . group ( 6 ) ; day = m . group ( 7 ) ; if ( year != null ) { checkYearlessDate ( month , day ) ; return ; } hour = m . group ( 8 ) ; minute = m . group ( 9 ) ; seconds = m . group ( 10 ) ; milliseconds = m . group ( 11 ) ; if ( hour != null ) { checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } return ; } year = m . group ( 12 ) ; month = m . group ( 13 ) ; day = m . group ( 14 ) ; hour = m . group ( 15 ) ; minute = m . group ( 16 ) ; seconds = m . group ( 17 ) ; milliseconds = m . group ( 18 ) ; if ( year != null ) { checkDate ( year , month , day ) ; checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } return ; } tzdHours = m . group ( 19 ) ; tzdMinutes = m . group ( 20 ) ; if ( tzdHours != null ) { checkTzd ( tzdHours , tzdMinutes ) ; return ; } year = m . group ( 21 ) ; month = m . group ( 22 ) ; day = m . group ( 23 ) ; hour = m . group ( 24 ) ; minute = m . group ( 25 ) ; seconds = m . group ( 26 ) ; milliseconds = m . group ( 27 ) ; tzdHours = m . group ( 28 ) ; tzdMinutes = m . group ( 29 ) ; if ( year != null ) { checkDate ( year , month , day ) ; checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } if ( tzdHours != null ) { checkTzd ( tzdHours , tzdMinutes ) ; } return ; } year = m . group ( 30 ) ; String week = m . group ( 31 ) ; if ( year != null ) { checkWeek ( year , week ) ; } year = m . group ( 32 ) ; if ( year != null && Integer . parseInt ( year ) < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } milliseconds = m . group ( 33 ) ; if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; return ; } milliseconds = m . group ( 34 ) ; if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; return ; } } else { throw newDatatypeException ( "The literal did not satisfy the " + getName ( ) + " format." ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
