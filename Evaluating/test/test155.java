<<<<<<< HEAD
public final class TextProcessor { private static final Pattern PAT_ALL_TAGS = Pattern . compile ( "<[^>]+>" ) ; private static final Pattern PAT_ENTITIES = Pattern . compile ( "&[a-zA-Z]{2,6};" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PAT_NUMERIC_ENTITIES = Pattern . compile ( "&#(x?[0-9a-fA-F]{1,4})(;|(\\s)|$)" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PAT_QUOT = Pattern . compile ( "&quot(;|(\\s)|$)" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PAT_NBSP = Pattern . compile ( "&nbsp(;|(\\s)|$)" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PAT_APOS = Pattern . compile ( "&apos(;|(\\s)|$)" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PAT_AMP = Pattern . compile ( "&amp(;|(\\s)|$)" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PAT_LT = Pattern . compile ( "&lt(;|(\\s)|$)" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PAT_GT = Pattern . compile ( "&gt(;|(\\s)|$)" , Pattern . CASE_INSENSITIVE ) ; public static final Pattern PAT_BACKGROUND_ATTR = Pattern . compile ( "(<[^>]+)background\\s*=\\s*('[\\s]*'|\"[\\s]*\")([^>]*>)" , Pattern . CASE_INSENSITIVE ) ; private static final Pattern PATTERN = Pattern . compile ( "&((nbsp)|(lt)|(gt)|(apos)|(quot)|(amp));" ) ; private static final String [ ] REPLACEMENT = { " " , "<" , ">" , "'" , "\"" , "&" } ; private TextProcessor ( ) { } public static String processHTML ( String text , int sizeLimit ) { return process ( text , sizeLimit , true ) ; } public static String processPlain ( String text , int sizeLimit ) { return process ( text , sizeLimit , false ) ; } static String process ( String aText , int sizeLimit , boolean html ) { if ( aText == null ) return null ; IHtmlParserListener listener ; HtmlParser parser = new HtmlParser ( true ) ; StringBuilderListener bufListener = new StringBuilderListener ( aText . length ( ) , sizeLimit ) ; listener = html ? new SwingHtmlFilter ( bufListener ) : new SwingPlainFilter ( bufListener ) ; try { parser . parse ( new StringReader ( aText ) , listener ) ; } catch ( IOException e ) { } String result = bufListener . toString ( ) ; result = PAT_BACKGROUND_ATTR . matcher ( result ) . replaceAll ( "$1$3" . intern ( ) ) ; result = convertEntity ( result , "&mdash(;|(\\s)|$)" . intern ( ) , "â€”" . intern ( ) ) ; return result ; } public static String convertNumericHTMLEntities ( String text ) { if ( text == null ) return null ; Matcher m = PAT_NUMERIC_ENTITIES . matcher ( text ) ; StringBuffer buf = new StringBuffer ( ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( value . length ( ) > 0 ) { char c ; String replacement ; try { if ( value . toLowerCase ( ) . charAt ( 0 ) == 'x' ) { c = ( char ) Integer . parseInt ( value . substring ( 1 ) , 16 ) ; } else { c = ( char ) Integer . parseInt ( value ) ; } char [ ] chars ; if ( c == 92 || c == 36 ) { chars = new char [ ] { '\\' , c } ; } else { chars = new char [ ] { c } ; } replacement = new String ( chars ) ; } catch ( NumberFormatException e ) { replacement = Constants . EMPTY_STRING ; } String tail = m . group ( 3 ) ; if ( tail != null ) replacement += tail ; m . appendReplacement ( buf , replacement ) ; } } m . appendTail ( buf ) ; return buf . toString ( ) ; } public static String convertHTMLEntities ( String text ) { if ( text == null ) return null ; text = convertEntity ( text , PAT_AMP , "&" ) ; text = convertEntity ( text , PAT_APOS , "'" ) ; text = convertEntity ( text , PAT_NBSP , " " ) ; text = convertEntity ( text , PAT_QUOT , "\"" ) ; text = convertEntity ( text , PAT_LT , "<" ) ; text = convertEntity ( text , PAT_GT , ">" ) ; return text ; } private static String convertEntity ( String text , String pattern , String replacement ) { return convertEntity ( text , Pattern . compile ( pattern ) , replacement ) ; } private static String convertEntity ( String text , Pattern pattern , String replacement ) { if ( text == null ) return null ; Matcher m = pattern . matcher ( text ) ; StringBuffer buf = new StringBuffer ( ) ; while ( m . find ( ) ) { String rep = replacement ; String tail = m . group ( 2 ) ; if ( tail != null ) rep += tail ; m . appendReplacement ( buf , rep ) ; } m . appendTail ( buf ) ; return buf . toString ( ) ; } public static String removeHTMLEntities ( String text ) { return text == null ? null : PAT_ENTITIES . matcher ( text ) . replaceAll ( " " . intern ( ) ) ; } public static String removeTags ( String text ) { return text == null ? null : PAT_ALL_TAGS . matcher ( text ) . replaceAll ( Constants . EMPTY_STRING ) ; } public static String getExcerpt ( String text , int words ) { if ( text == null ) return null ; int i = 0 ; int length = text . length ( ) ; boolean found = false ; while ( i < length && ! ( found = ! Character . isWhitespace ( text . charAt ( i ) ) ) ) i ++ ; String excerpt = null ; if ( found ) { int start = i ; int end = - 1 ; int count = 0 ; boolean isInWord = false ; while ( excerpt == null && count <= words && i < length ) { char ch = text . charAt ( i ) ; if ( ch == 0x0a || ch == 0x0d ) { excerpt = text . substring ( start , i ) + "..." ; } else if ( ch == '.' || ch == '!' || ch == '?' ) { excerpt = text . substring ( start , i + 1 ) ; } else { if ( Character . isLetterOrDigit ( ch ) ) { if ( ! isInWord ) { count ++ ; isInWord = true ; } } else { isInWord = false ; end = i ; } } i ++ ; } if ( excerpt == null ) excerpt = text . substring ( start , i == length ? i : end ) ; if ( count > words ) excerpt += "..." ; } else excerpt = Constants . EMPTY_STRING ; return excerpt ; } public static String filterTitle ( String title , String text ) { boolean excerptRequired = false ; if ( title == null && text != null ) { title = text ; excerptRequired = true ; } if ( title != null ) { title = removeTags ( title ) ; title = convertNumericHTMLEntities ( title ) ; title = convertHTMLEntities ( title ) ; title = removeHTMLEntities ( title ) ; if ( excerptRequired ) { title = getExcerpt ( title , Constants . WORDS_IN_EXCERPT ) ; } } return title ; } public static String filterText ( String text ) { if ( text == null ) return null ; text = text . replaceAll ( "<style[^>]*>[^<]*</style>" , "" ) ; text = processHTML ( text , Constants . ARTICLE_SIZE_LIMIT ) ; text = removeLeadingParagraphs ( text ) ; return text ; } static String removeLeadingParagraphs ( String text ) { return text . replaceFirst ( "^(\\s*<[pP]>)+" , "" ) . trim ( ) ; } public static String toPlainText ( String html ) { String result ; Matcher m = PATTERN . matcher ( html ) ; if ( m . find ( ) ) { StringBuffer sb = new StringBuffer ( ) ; do { int matchIndex = findMatchIndex ( m ) ; m . appendReplacement ( sb , REPLACEMENT [ matchIndex ] ) ; } while ( m . find ( ) ) ; m . appendTail ( sb ) ; result = sb . toString ( ) ; } else { result = html ; } return result ; } private static int findMatchIndex ( Matcher m ) { for ( int i = 2 ; i <= m . groupCount ( ) ; i ++ ) { String val = m . group ( i ) ; if ( val != null ) return i - 2 ; } return 0 ; } } 
=======
abstract class RequiredElementsOrAttributesFunction extends AbstractPatternFunction < Set < Name > > { public Set < Name > caseOther ( Pattern p ) { return Collections . emptySet ( ) ; } public Set < Name > caseChoice ( ChoicePattern p ) { Set < Name > s1 = p . getOperand1 ( ) . apply ( this ) ; Set < Name > s2 = p . getOperand2 ( ) . apply ( this ) ; if ( s1 . isEmpty ( ) ) return s1 ; if ( s2 . isEmpty ( ) ) return s2 ; s1 . retainAll ( s2 ) ; return s1 ; } protected Set < Name > caseNamed ( NameClass nc ) { if ( ! ( nc instanceof SimpleNameClass ) ) return Collections . emptySet ( ) ; Set < Name > s = new HashSet < Name > ( ) ; s . add ( ( ( SimpleNameClass ) nc ) . getName ( ) ) ; return s ; } protected Set < Name > union ( BinaryPattern p ) { Set < Name > s1 = p . getOperand1 ( ) . apply ( this ) ; Set < Name > s2 = p . getOperand2 ( ) . apply ( this ) ; if ( s1 . isEmpty ( ) ) return s2 ; if ( s2 . isEmpty ( ) ) return s1 ; s1 . addAll ( s2 ) ; return s1 ; } public Set < Name > caseInterleave ( InterleavePattern p ) { return union ( p ) ; } public Set < Name > caseAfter ( AfterPattern p ) { return p . getOperand1 ( ) . apply ( this ) ; } public Set < Name > caseOneOrMore ( OneOrMorePattern p ) { return p . getOperand ( ) . apply ( this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
