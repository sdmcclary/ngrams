<<<<<<< HEAD
public class CloneAction extends ContextAction { public CloneAction ( String name , VCSContext context ) { super ( name , context ) ; } @ Override protected void performAction ( ActionEvent event ) { final File root = GitUtils . getRootFile ( context ) ; if ( root == null ) return ; File tmp = root . getParentFile ( ) ; File projFile = GitUtils . getProjectFile ( context ) ; String folderName = root . getName ( ) ; Boolean projIsRepos = true ; if ( ! root . equals ( projFile ) ) { projIsRepos = false ; } for ( int i = 0 ; i < 10000 ; i ++ ) { if ( ! new File ( tmp , folderName + "_clone" + i ) . exists ( ) ) { tmp = new File ( tmp , folderName + "_clone" + i ) ; break ; } } Clone clone = new Clone ( root , tmp ) ; if ( ! clone . showDialog ( ) ) { return ; } URIish source = null ; try { source = new URIish ( root . toURL ( ) ) ; } catch ( MalformedURLException ex ) { Exceptions . printStackTrace ( ex ) ; } performClone ( source , clone . getTargetDir ( ) , projIsRepos , projFile , true , true ) ; } public static RequestProcessor . Task performClone ( final URIish source , final File target , boolean projIsRepos , File projFile , boolean scanForProjects ) { return performClone ( source , target , projIsRepos , projFile , false , scanForProjects ) ; } private static RequestProcessor . Task performClone ( final URIish source , final File target , final Boolean projIsRepos , final File projFile , final boolean isLocalClone , final boolean scanForProjects ) { RequestProcessor rp = Git . getInstance ( ) . getRequestProcessor ( source . toString ( ) ) ; final GitProgressSupport support = new GitProgressSupport ( ) { Repository repo = Git . getInstance ( ) . getRepository ( target ) ; @ Override protected void perform ( ) { String projName = ( projFile != null ) ? GitProjectUtils . getProjectName ( projFile ) : null ; OutputLogger logger = getLogger ( ) ; try { if ( projName != null ) { logger . outputInRed ( NbBundle . getMessage ( CloneAction . class , "MSG_CLONE_FROM" , projName , source ) ) ; logger . outputInRed ( NbBundle . getMessage ( CloneAction . class , "MSG_CLONE_TO" , projName , target ) ) ; } else { logger . outputInRed ( NbBundle . getMessage ( CloneAction . class , "MSG_EXTERNAL_CLONE_FROM" , source ) ) ; logger . outputInRed ( NbBundle . getMessage ( CloneAction . class , "MSG_EXTERNAL_CLONE_TO" , target ) ) ; } logger . output ( "" ) ; doInit ( repo , source , logger ) ; FetchResult r = doFetch ( repo , logger ) ; Ref branch = r . getAdvertisedRef ( Constants . HEAD ) ; if ( branch == null ) { this . cancel ( ) ; } doCheckout ( repo , branch , logger ) ; if ( isLocalClone ) { Git git = Git . getInstance ( ) ; ProjectManager projectManager = ProjectManager . getDefault ( ) ; File normalizedCloneFolder = FileUtil . normalizeFile ( target ) ; File cloneProjFile ; if ( ! projIsRepos ) { String name = ( projFile != null ) ? projFile . getAbsolutePath ( ) . substring ( source . getPath ( ) . length ( ) + 1 ) : target . getAbsolutePath ( ) ; cloneProjFile = new File ( normalizedCloneFolder , name ) ; } else { cloneProjFile = normalizedCloneFolder ; } openProject ( cloneProjFile , projectManager , git ) ; } else if ( scanForProjects ) { CloneCompleted cc = new CloneCompleted ( target ) ; if ( isCanceled ( ) ) { return ; } cc . scanForProjects ( this ) ; } } catch ( URISyntaxException usex ) { notifyLater ( usex ) ; } catch ( IOException ex ) { notifyLater ( ex ) ; } finally { if ( ! isLocalClone ) { logger . outputInRed ( NbBundle . getMessage ( CloneAction . class , "MSG_CLONE_DONE" ) ) ; logger . output ( "" ) ; } } } private void openProject ( final File cloneProjFile , final ProjectManager projectManager , final Git git ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { OutputLogger logger = getLogger ( ) ; try { FileObject cloneProj = FileUtil . toFileObject ( cloneProjFile ) ; Project proj = null ; if ( cloneProjFile != null && cloneProj != null ) { proj = projectManager . findProject ( cloneProj ) ; } if ( proj != null ) { GitProjectUtils . openProject ( proj , this , false ) ; git . versionedFilesChanged ( ) ; git . refreshAllAnnotations ( ) ; } else { logger . outputInRed ( NbBundle . getMessage ( CloneAction . class , "MSG_EXTERNAL_CLONE_PRJ_NOT_FOUND_CANT_SETASMAIN" ) ) ; } } catch ( IOException ioe ) { notifyLater ( ioe ) ; } finally { logger . outputInRed ( NbBundle . getMessage ( CloneAction . class , "MSG_CLONE_DONE" ) ) ; logger . output ( "" ) ; } } } ) ; } } ; return support . start ( rp , source . toString ( ) , org . openide . util . NbBundle . getMessage ( CloneAction . class , "LBL_Clone_Progress" , source ) ) ; } public static void doInit ( Repository repo , URIish uri , OutputLogger logger ) throws IOException , URISyntaxException { repo . create ( ) ; repo . getConfig ( ) . setBoolean ( "core" , null , "bare" , false ) ; repo . getConfig ( ) . save ( ) ; logger . output ( "Initialized empty Git repository in " + repo . getWorkDir ( ) . getAbsolutePath ( ) ) ; logger . flushLog ( ) ; final RemoteConfig rc = new RemoteConfig ( repo . getConfig ( ) , "origin" ) ; rc . addURI ( uri ) ; rc . addFetchRefSpec ( new RefSpec ( ) . setForceUpdate ( true ) . setSourceDestination ( Constants . R_HEADS + "*" , Constants . R_REMOTES + "origin" + "/*" ) ) ; rc . update ( repo . getConfig ( ) ) ; repo . getConfig ( ) . save ( ) ; } public static FetchResult doFetch ( Repository repo , OutputLogger logger ) throws NotSupportedException , TransportException , URISyntaxException { final FetchResult r ; final Transport tn = Transport . open ( repo , "origin" ) ; try { r = tn . fetch ( new GitProgressMonitor ( ) , null ) ; } finally { tn . close ( ) ; } logger . output ( "--- Fetch Completed ---" ) ; return r ; } public static void doCheckout ( Repository repo , Ref branch , OutputLogger logger ) throws IOException { final GitIndex index = new GitIndex ( repo ) ; final Commit mapCommit = repo . mapCommit ( branch . getObjectId ( ) ) ; final Tree tree = mapCommit . getTree ( ) ; final RefUpdate u ; final WorkDirCheckout co ; u = repo . updateRef ( Constants . HEAD ) ; u . setNewObjectId ( mapCommit . getCommitId ( ) ) ; u . forceUpdate ( ) ; co = new WorkDirCheckout ( repo , repo . getWorkDir ( ) , index , tree ) ; co . checkout ( ) ; index . write ( ) ; } } 
=======
class NameDatatype extends TokenDatatype { public boolean lexicallyAllows ( String str ) { return Naming . isName ( str ) ; } public int getLength ( Object obj ) { return ( ( String ) obj ) . length ( ) ; } public boolean alwaysValid ( ) { return false ; } String getLexicalSpaceKey ( ) { return "name" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
