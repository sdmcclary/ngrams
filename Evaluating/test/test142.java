public class ResultsList extends JPanel implements IResultsListModelListener , Scrollable { public static final int DATE_ANY = 0 ; public static final int DATE_TODAY = 1 ; public static final int DATE_YESTERDAY = 2 ; public static final int DATE_WEEK = 3 ; public static final int DATE_MONTH = 4 ; public static final int DATE_YEAR = 5 ; private final Map < Integer , ResultGroupPanel > groups = new TreeMap < Integer , ResultGroupPanel > ( ) ; private int dateRange = DATE_ANY ; private long limitTime ; private int itemGroupLimit ; private ResultItemPanel selectedItem ; private final List < ActionListener > listeners = new ArrayList < ActionListener > ( ) ; public ResultsList ( ResultsListModel model ) { model . addListener ( this ) ; itemGroupLimit = 5 ; limitTime = getLimitTime ( dateRange ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; setFocusable ( true ) ; enableEvents ( AWTEvent . KEY_EVENT_MASK | AWTEvent . MOUSE_EVENT_MASK ) ; } public void onClear ( IResultsListModel model ) { groups . clear ( ) ; removeAll ( ) ; revalidate ( ) ; } public void onItemAdded ( IResultsListModel model , ResultItem item , ResultGroup group ) { ResultItemPanel itemPanel = new ResultItemPanel ( item ) ; ResultGroupPanel groupPanel = groups . get ( group . getKey ( ) ) ; int index = groupPanel . register ( itemPanel ) + 1 ; index += indexOf ( groupPanel ) ; add ( itemPanel , index ) ; revalidate ( ) ; } public void onItemRemoved ( IResultsListModel model , ResultItem item , ResultGroup group ) { ResultGroupPanel groupPanel = groups . get ( group . getKey ( ) ) ; ResultItemPanel itemPanel = groupPanel . removeItemPanelFor ( item ) ; if ( itemPanel != null ) remove ( itemPanel ) ; revalidate ( ) ; } public void onGroupAdded ( IResultsListModel model , ResultGroup group , boolean ordered ) { ResultGroupPanel groupPanel = createGroupPanel ( group ) ; groupPanel . setItemLimit ( itemGroupLimit ) ; groupPanel . setLimitTime ( limitTime ) ; groups . put ( group . getKey ( ) , groupPanel ) ; ResultGroupPanel preGroup = null ; if ( ! ordered ) { Integer key = group . getKey ( ) ; Iterator < Integer > it = groups . keySet ( ) . iterator ( ) ; while ( preGroup == null && it . hasNext ( ) ) { Object otherKey = it . next ( ) ; if ( key == otherKey && it . hasNext ( ) ) preGroup = groups . get ( it . next ( ) ) ; } } int index = preGroup == null ? - 1 : indexOf ( preGroup ) ; add ( groupPanel , index ) ; add ( groupPanel . getMoreComponent ( ) , index == - 1 ? - 1 : index + 1 ) ; } protected ResultGroupPanel createGroupPanel ( ResultGroup group ) { return new ResultGroupPanel ( group . getName ( ) ) ; } public void onGroupRemoved ( IResultsListModel model , ResultGroup group ) { ResultGroupPanel panel = groups . remove ( group . getKey ( ) ) ; remove ( panel ) ; remove ( panel . getMoreComponent ( ) ) ; panel . removeAllItemsFrom ( this ) ; revalidate ( ) ; } public void onGroupUpdated ( IResultsListModel model , ResultGroup group ) { ResultGroupPanel groupPanel = groups . get ( group . getKey ( ) ) ; if ( groupPanel != null ) { String title = group . getName ( ) ; groupPanel . setTitle ( title ) ; } } public void setItemGroupLimit ( int limit ) { itemGroupLimit = limit ; for ( ResultGroupPanel group : groups . values ( ) ) group . setItemLimit ( limit ) ; } public void setDateRange ( int aDateRange ) { if ( dateRange != aDateRange ) { dateRange = aDateRange ; limitTime = getLimitTime ( dateRange ) ; for ( ResultGroupPanel group : groups . values ( ) ) group . setLimitTime ( limitTime ) ; } } public void addActionListener ( ActionListener l ) { listeners . add ( l ) ; } public void removeActionListener ( ActionListener l ) { listeners . remove ( l ) ; } public ResultItem getSelectedItem ( ) { return selectedItem == null ? null : selectedItem . getItem ( ) ; } private int indexOf ( Component comp ) { int index = - 1 ; for ( int i = 0 ; index == - 1 && i < getComponentCount ( ) ; i ++ ) { if ( getComponent ( i ) == comp ) index = i ; } return index ; } private void onItemSelected ( ResultItemPanel item ) { requestFocusInWindow ( ) ; if ( selectedItem != null ) selectedItem . setSelected ( false ) ; selectedItem = item ; if ( selectedItem != null ) { selectedItem . setSelected ( true ) ; scrollRectToVisible ( selectedItem . getBounds ( ) ) ; } } void onItemFired ( ) { ActionEvent event = null ; for ( ActionListener listener : listeners ) { if ( event == null ) event = new ActionEvent ( this , 0 , "" ) ; listener . actionPerformed ( event ) ; } } private void onItemToggleReadState ( ) { if ( selectedItem != null ) { Object o = selectedItem . getItem ( ) . getObject ( ) ; if ( o instanceof IArticle ) { IArticle article = ( IArticle ) o ; GlobalController . readArticles ( ! article . isRead ( ) , null , null , article ) ; } } } private void onItemTogglePinState ( ) { if ( selectedItem != null ) { Object o = selectedItem . getItem ( ) . getObject ( ) ; if ( o instanceof IArticle ) { IArticle article = ( IArticle ) o ; GlobalController . pinArticles ( ! article . isPinned ( ) , null , null , article ) ; } } } public void onPrevItemSelected ( ) { if ( selectedItem != null ) { int index = indexOf ( selectedItem ) ; ResultItemPanel toSelect = null ; for ( int i = index - 1 ; toSelect == null && i > 0 ; i -- ) { Component c = getComponent ( i ) ; if ( c instanceof ResultItemPanel && c . isVisible ( ) ) toSelect = ( ResultItemPanel ) c ; } if ( toSelect != null ) onItemSelected ( toSelect ) ; } } public void onNextItemSelected ( ) { int index = selectedItem == null ? 0 : indexOf ( selectedItem ) ; ResultItemPanel toSelect = null ; for ( int i = index + 1 ; toSelect == null && i < getComponentCount ( ) ; i ++ ) { Component c = getComponent ( i ) ; if ( c instanceof ResultItemPanel && c . isVisible ( ) ) toSelect = ( ResultItemPanel ) c ; } if ( toSelect != null ) onItemSelected ( toSelect ) ; } private static long getLimitTime ( int dateRange ) { if ( dateRange == DATE_ANY ) return - 1L ; GregorianCalendar cal = new GregorianCalendar ( ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; long time ; switch ( dateRange ) { case DATE_YESTERDAY : cal . add ( Calendar . DATE , - 1 ) ; break ; case DATE_WEEK : cal . add ( Calendar . DATE , - 7 ) ; break ; case DATE_MONTH : cal . set ( Calendar . DATE , 1 ) ; break ; case DATE_YEAR : cal . set ( Calendar . DAY_OF_YEAR , 1 ) ; break ; default : break ; } time = cal . getTimeInMillis ( ) ; return time ; } public Dimension getPreferredScrollableViewportSize ( ) { return getPreferredSize ( ) ; } public int getScrollableUnitIncrement ( Rectangle visibleRect , int orientation , int direction ) { int increment = 1 ; if ( orientation == SwingConstants . VERTICAL ) { int px = visibleRect . x ; int py = visibleRect . y ; increment = getIncrementForBorderChild ( direction , px , py ) ; if ( increment == 0 ) { if ( direction < 0 ) { if ( py > 0 ) increment = getIncrementForBorderChild ( direction , px , py - 1 ) ; } else { int height = getHeight ( ) ; if ( py < height - visibleRect . height ) increment = getIncrementForBorderChild ( direction , px , py + 1 ) ; } if ( increment > 0 ) increment ++ ; } } return increment ; } private int getIncrementForBorderChild ( int direction , int px , int py ) { int increment = 0 ; Component comp = findComponentAt ( px , py ) ; if ( comp != null ) { Point inCompPoint = SwingUtilities . convertPoint ( this , px , py , comp ) ; int y = inCompPoint . y ; if ( direction < 0 ) { if ( y > 0 ) increment = y ; } else { int height = comp . getHeight ( ) ; if ( y < height ) increment = height - y ; } } return increment ; } public int getScrollableBlockIncrement ( Rectangle visibleRect , int orientation , int direction ) { int px = visibleRect . x ; int py = visibleRect . y ; int he = getHeight ( ) ; int maxy = he - visibleRect . height ; Component started = findComponentAt ( px , py ) ; int inc = 0 ; boolean found = false ; if ( direction > 0 ) { for ( int y = py + 1 ; ! found && y < maxy ; y ++ ) { Component comp = findComponentAt ( px , y ) ; if ( comp != started && comp instanceof ResultGroupPanel ) { found = true ; inc = getIncrementForBorderChild ( - direction , px , y ) + ( y - py ) - 2 ; } else { y += getIncrementForBorderChild ( direction , px , y ) ; } } } else { for ( int y = py - 1 ; ! found && y >= 0 ; y -- ) { Component comp = findComponentAt ( px , y ) ; if ( comp != started && comp instanceof ResultGroupPanel ) { found = true ; inc = getIncrementForBorderChild ( direction , px , y ) + ( py - y ) ; } else { y -= getIncrementForBorderChild ( direction , px , y ) ; } } } return inc ; } public boolean getScrollableTracksViewportWidth ( ) { return true ; } public boolean getScrollableTracksViewportHeight ( ) { return false ; } protected void processMouseEvent ( MouseEvent e ) { if ( ! SwingUtilities . isLeftMouseButton ( e ) ) return ; Component c = getComponentAt ( e . getPoint ( ) ) ; if ( ! ( c instanceof ResultItemPanel ) ) return ; switch ( e . getID ( ) ) { case MouseEvent . MOUSE_PRESSED : onItemSelected ( ( ResultItemPanel ) c ) ; break ; case MouseEvent . MOUSE_CLICKED : if ( e . getClickCount ( ) == 2 ) onItemFired ( ) ; break ; } } protected void processKeyEvent ( KeyEvent e ) { if ( e . getID ( ) != KeyEvent . KEY_PRESSED ) return ; int code = e . getKeyCode ( ) ; switch ( code ) { case KeyEvent . VK_UP : onPrevItemSelected ( ) ; break ; case KeyEvent . VK_DOWN : onNextItemSelected ( ) ; break ; case KeyEvent . VK_ENTER : onItemFired ( ) ; break ; case KeyEvent . VK_Q : onItemToggleReadState ( ) ; break ; case KeyEvent . VK_P : onItemTogglePinState ( ) ; break ; case KeyEvent . VK_PAGE_UP : Rectangle visible = getVisibleRect ( ) ; visible . y = Math . max ( 0 , visible . y - visible . height ) ; scrollRectToVisible ( visible ) ; break ; case KeyEvent . VK_PAGE_DOWN : visible = getVisibleRect ( ) ; visible . y = Math . max ( 0 , Math . min ( getHeight ( ) - visible . height , visible . y + visible . height ) ) ; scrollRectToVisible ( visible ) ; break ; case KeyEvent . VK_HOME : visible = getVisibleRect ( ) ; visible . y = 0 ; scrollRectToVisible ( visible ) ; break ; case KeyEvent . VK_END : visible = getVisibleRect ( ) ; visible . y = Math . max ( 0 , getHeight ( ) - visible . height ) ; scrollRectToVisible ( visible ) ; break ; } } } 