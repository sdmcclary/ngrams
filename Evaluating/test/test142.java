<<<<<<< HEAD
public class ResultsList extends JPanel implements IResultsListModelListener , Scrollable { public static final int DATE_ANY = 0 ; public static final int DATE_TODAY = 1 ; public static final int DATE_YESTERDAY = 2 ; public static final int DATE_WEEK = 3 ; public static final int DATE_MONTH = 4 ; public static final int DATE_YEAR = 5 ; private final Map < Integer , ResultGroupPanel > groups = new TreeMap < Integer , ResultGroupPanel > ( ) ; private int dateRange = DATE_ANY ; private long limitTime ; private int itemGroupLimit ; private ResultItemPanel selectedItem ; private final List < ActionListener > listeners = new ArrayList < ActionListener > ( ) ; public ResultsList ( ResultsListModel model ) { model . addListener ( this ) ; itemGroupLimit = 5 ; limitTime = getLimitTime ( dateRange ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; setFocusable ( true ) ; enableEvents ( AWTEvent . KEY_EVENT_MASK | AWTEvent . MOUSE_EVENT_MASK ) ; } public void onClear ( IResultsListModel model ) { groups . clear ( ) ; removeAll ( ) ; revalidate ( ) ; } public void onItemAdded ( IResultsListModel model , ResultItem item , ResultGroup group ) { ResultItemPanel itemPanel = new ResultItemPanel ( item ) ; ResultGroupPanel groupPanel = groups . get ( group . getKey ( ) ) ; int index = groupPanel . register ( itemPanel ) + 1 ; index += indexOf ( groupPanel ) ; add ( itemPanel , index ) ; revalidate ( ) ; } public void onItemRemoved ( IResultsListModel model , ResultItem item , ResultGroup group ) { ResultGroupPanel groupPanel = groups . get ( group . getKey ( ) ) ; ResultItemPanel itemPanel = groupPanel . removeItemPanelFor ( item ) ; if ( itemPanel != null ) remove ( itemPanel ) ; revalidate ( ) ; } public void onGroupAdded ( IResultsListModel model , ResultGroup group , boolean ordered ) { ResultGroupPanel groupPanel = createGroupPanel ( group ) ; groupPanel . setItemLimit ( itemGroupLimit ) ; groupPanel . setLimitTime ( limitTime ) ; groups . put ( group . getKey ( ) , groupPanel ) ; ResultGroupPanel preGroup = null ; if ( ! ordered ) { Integer key = group . getKey ( ) ; Iterator < Integer > it = groups . keySet ( ) . iterator ( ) ; while ( preGroup == null && it . hasNext ( ) ) { Object otherKey = it . next ( ) ; if ( key == otherKey && it . hasNext ( ) ) preGroup = groups . get ( it . next ( ) ) ; } } int index = preGroup == null ? - 1 : indexOf ( preGroup ) ; add ( groupPanel , index ) ; add ( groupPanel . getMoreComponent ( ) , index == - 1 ? - 1 : index + 1 ) ; } protected ResultGroupPanel createGroupPanel ( ResultGroup group ) { return new ResultGroupPanel ( group . getName ( ) ) ; } public void onGroupRemoved ( IResultsListModel model , ResultGroup group ) { ResultGroupPanel panel = groups . remove ( group . getKey ( ) ) ; remove ( panel ) ; remove ( panel . getMoreComponent ( ) ) ; panel . removeAllItemsFrom ( this ) ; revalidate ( ) ; } public void onGroupUpdated ( IResultsListModel model , ResultGroup group ) { ResultGroupPanel groupPanel = groups . get ( group . getKey ( ) ) ; if ( groupPanel != null ) { String title = group . getName ( ) ; groupPanel . setTitle ( title ) ; } } public void setItemGroupLimit ( int limit ) { itemGroupLimit = limit ; for ( ResultGroupPanel group : groups . values ( ) ) group . setItemLimit ( limit ) ; } public void setDateRange ( int aDateRange ) { if ( dateRange != aDateRange ) { dateRange = aDateRange ; limitTime = getLimitTime ( dateRange ) ; for ( ResultGroupPanel group : groups . values ( ) ) group . setLimitTime ( limitTime ) ; } } public void addActionListener ( ActionListener l ) { listeners . add ( l ) ; } public void removeActionListener ( ActionListener l ) { listeners . remove ( l ) ; } public ResultItem getSelectedItem ( ) { return selectedItem == null ? null : selectedItem . getItem ( ) ; } private int indexOf ( Component comp ) { int index = - 1 ; for ( int i = 0 ; index == - 1 && i < getComponentCount ( ) ; i ++ ) { if ( getComponent ( i ) == comp ) index = i ; } return index ; } private void onItemSelected ( ResultItemPanel item ) { requestFocusInWindow ( ) ; if ( selectedItem != null ) selectedItem . setSelected ( false ) ; selectedItem = item ; if ( selectedItem != null ) { selectedItem . setSelected ( true ) ; scrollRectToVisible ( selectedItem . getBounds ( ) ) ; } } void onItemFired ( ) { ActionEvent event = null ; for ( ActionListener listener : listeners ) { if ( event == null ) event = new ActionEvent ( this , 0 , "" ) ; listener . actionPerformed ( event ) ; } } private void onItemToggleReadState ( ) { if ( selectedItem != null ) { Object o = selectedItem . getItem ( ) . getObject ( ) ; if ( o instanceof IArticle ) { IArticle article = ( IArticle ) o ; GlobalController . readArticles ( ! article . isRead ( ) , null , null , article ) ; } } } private void onItemTogglePinState ( ) { if ( selectedItem != null ) { Object o = selectedItem . getItem ( ) . getObject ( ) ; if ( o instanceof IArticle ) { IArticle article = ( IArticle ) o ; GlobalController . pinArticles ( ! article . isPinned ( ) , null , null , article ) ; } } } public void onPrevItemSelected ( ) { if ( selectedItem != null ) { int index = indexOf ( selectedItem ) ; ResultItemPanel toSelect = null ; for ( int i = index - 1 ; toSelect == null && i > 0 ; i -- ) { Component c = getComponent ( i ) ; if ( c instanceof ResultItemPanel && c . isVisible ( ) ) toSelect = ( ResultItemPanel ) c ; } if ( toSelect != null ) onItemSelected ( toSelect ) ; } } public void onNextItemSelected ( ) { int index = selectedItem == null ? 0 : indexOf ( selectedItem ) ; ResultItemPanel toSelect = null ; for ( int i = index + 1 ; toSelect == null && i < getComponentCount ( ) ; i ++ ) { Component c = getComponent ( i ) ; if ( c instanceof ResultItemPanel && c . isVisible ( ) ) toSelect = ( ResultItemPanel ) c ; } if ( toSelect != null ) onItemSelected ( toSelect ) ; } private static long getLimitTime ( int dateRange ) { if ( dateRange == DATE_ANY ) return - 1L ; GregorianCalendar cal = new GregorianCalendar ( ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; long time ; switch ( dateRange ) { case DATE_YESTERDAY : cal . add ( Calendar . DATE , - 1 ) ; break ; case DATE_WEEK : cal . add ( Calendar . DATE , - 7 ) ; break ; case DATE_MONTH : cal . set ( Calendar . DATE , 1 ) ; break ; case DATE_YEAR : cal . set ( Calendar . DAY_OF_YEAR , 1 ) ; break ; default : break ; } time = cal . getTimeInMillis ( ) ; return time ; } public Dimension getPreferredScrollableViewportSize ( ) { return getPreferredSize ( ) ; } public int getScrollableUnitIncrement ( Rectangle visibleRect , int orientation , int direction ) { int increment = 1 ; if ( orientation == SwingConstants . VERTICAL ) { int px = visibleRect . x ; int py = visibleRect . y ; increment = getIncrementForBorderChild ( direction , px , py ) ; if ( increment == 0 ) { if ( direction < 0 ) { if ( py > 0 ) increment = getIncrementForBorderChild ( direction , px , py - 1 ) ; } else { int height = getHeight ( ) ; if ( py < height - visibleRect . height ) increment = getIncrementForBorderChild ( direction , px , py + 1 ) ; } if ( increment > 0 ) increment ++ ; } } return increment ; } private int getIncrementForBorderChild ( int direction , int px , int py ) { int increment = 0 ; Component comp = findComponentAt ( px , py ) ; if ( comp != null ) { Point inCompPoint = SwingUtilities . convertPoint ( this , px , py , comp ) ; int y = inCompPoint . y ; if ( direction < 0 ) { if ( y > 0 ) increment = y ; } else { int height = comp . getHeight ( ) ; if ( y < height ) increment = height - y ; } } return increment ; } public int getScrollableBlockIncrement ( Rectangle visibleRect , int orientation , int direction ) { int px = visibleRect . x ; int py = visibleRect . y ; int he = getHeight ( ) ; int maxy = he - visibleRect . height ; Component started = findComponentAt ( px , py ) ; int inc = 0 ; boolean found = false ; if ( direction > 0 ) { for ( int y = py + 1 ; ! found && y < maxy ; y ++ ) { Component comp = findComponentAt ( px , y ) ; if ( comp != started && comp instanceof ResultGroupPanel ) { found = true ; inc = getIncrementForBorderChild ( - direction , px , y ) + ( y - py ) - 2 ; } else { y += getIncrementForBorderChild ( direction , px , y ) ; } } } else { for ( int y = py - 1 ; ! found && y >= 0 ; y -- ) { Component comp = findComponentAt ( px , y ) ; if ( comp != started && comp instanceof ResultGroupPanel ) { found = true ; inc = getIncrementForBorderChild ( direction , px , y ) + ( py - y ) ; } else { y -= getIncrementForBorderChild ( direction , px , y ) ; } } } return inc ; } public boolean getScrollableTracksViewportWidth ( ) { return true ; } public boolean getScrollableTracksViewportHeight ( ) { return false ; } protected void processMouseEvent ( MouseEvent e ) { if ( ! SwingUtilities . isLeftMouseButton ( e ) ) return ; Component c = getComponentAt ( e . getPoint ( ) ) ; if ( ! ( c instanceof ResultItemPanel ) ) return ; switch ( e . getID ( ) ) { case MouseEvent . MOUSE_PRESSED : onItemSelected ( ( ResultItemPanel ) c ) ; break ; case MouseEvent . MOUSE_CLICKED : if ( e . getClickCount ( ) == 2 ) onItemFired ( ) ; break ; } } protected void processKeyEvent ( KeyEvent e ) { if ( e . getID ( ) != KeyEvent . KEY_PRESSED ) return ; int code = e . getKeyCode ( ) ; switch ( code ) { case KeyEvent . VK_UP : onPrevItemSelected ( ) ; break ; case KeyEvent . VK_DOWN : onNextItemSelected ( ) ; break ; case KeyEvent . VK_ENTER : onItemFired ( ) ; break ; case KeyEvent . VK_Q : onItemToggleReadState ( ) ; break ; case KeyEvent . VK_P : onItemTogglePinState ( ) ; break ; case KeyEvent . VK_PAGE_UP : Rectangle visible = getVisibleRect ( ) ; visible . y = Math . max ( 0 , visible . y - visible . height ) ; scrollRectToVisible ( visible ) ; break ; case KeyEvent . VK_PAGE_DOWN : visible = getVisibleRect ( ) ; visible . y = Math . max ( 0 , Math . min ( getHeight ( ) - visible . height , visible . y + visible . height ) ) ; scrollRectToVisible ( visible ) ; break ; case KeyEvent . VK_HOME : visible = getVisibleRect ( ) ; visible . y = 0 ; scrollRectToVisible ( visible ) ; break ; case KeyEvent . VK_END : visible = getVisibleRect ( ) ; visible . y = Math . max ( 0 , getHeight ( ) - visible . height ) ; scrollRectToVisible ( visible ) ; break ; } } } 
=======
public class PatternDumper { private static final String INTERNAL_NAMESPACE = "http://www.thaiopensource.com/relaxng/internal" ; private boolean startTagOpen = false ; private final ArrayList < String > tagStack = new ArrayList < String > ( ) ; private final StringBuilder buf ; private int level = 0 ; private boolean suppressIndent = false ; private final List < ElementPattern > patternList = new ArrayList < ElementPattern > ( ) ; private final Map < String , Integer > localNamePatternCount = new HashMap < String , Integer > ( ) ; private int otherPatternCount ; private final Map < ElementPattern , String > patternNameMap = new HashMap < ElementPattern , String > ( ) ; private final PatternFunction < VoidValue > dumper = new Dumper ( ) ; private final PatternFunction < VoidValue > elementDumper = new ElementDumper ( ) ; private final PatternFunction < VoidValue > optionalDumper = new OptionalDumper ( ) ; private final PatternFunction < VoidValue > groupDumper = new GroupDumper ( ) ; private final PatternFunction < VoidValue > choiceDumper = new ChoiceDumper ( ) ; private final PatternFunction < VoidValue > interleaveDumper = new InterleaveDumper ( ) ; private final NameClassVisitor nameClassDumper = new NameClassDumper ( ) ; private final NameClassVisitor choiceNameClassDumper = new ChoiceNameClassDumper ( ) ; static public String toString ( Pattern p ) { return new PatternDumper ( ) . dump ( p ) . getSchema ( ) ; } private PatternDumper ( ) { buf = new StringBuilder ( ) ; } private String getSchema ( ) { return buf . toString ( ) ; } private PatternDumper dump ( Pattern p ) { write ( "<?xml version=\"1.0\"?>" ) ; startElement ( "grammar" ) ; attribute ( "xmlns" , WellKnownNamespaces . RELAX_NG ) ; startElement ( "start" ) ; p . apply ( dumper ) ; endElement ( ) ; for ( int i = 0 ; i < patternList . size ( ) ; i ++ ) { startElement ( "define" ) ; ElementPattern tem = patternList . get ( i ) ; attribute ( "name" , getName ( tem ) ) ; tem . apply ( elementDumper ) ; endElement ( ) ; } endElement ( ) ; write ( '\n' ) ; return this ; } private String getName ( ElementPattern p ) { String name = patternNameMap . get ( p ) ; if ( name == null ) { NameClass nc = p . getNameClass ( ) ; if ( nc instanceof SimpleNameClass ) { String localName = ( ( SimpleNameClass ) nc ) . getName ( ) . getLocalName ( ) ; Integer i = localNamePatternCount . get ( localName ) ; if ( i == null ) { i = 1 ; name = localName ; int u = name . lastIndexOf ( '_' ) ; if ( u >= 0 ) { try { if ( Integer . valueOf ( name . substring ( u + 1 , name . length ( ) ) ) > 0 ) name += "_1" ; } catch ( NumberFormatException e ) { } } } else name = localName + "_" + ++ i ; localNamePatternCount . put ( localName , i ) ; } else name = "_" + ++ otherPatternCount ; patternList . add ( p ) ; patternNameMap . put ( p , name ) ; } return name ; } private void startElement ( String name ) { closeStartTag ( ) ; indent ( level ) ; write ( '<' ) ; write ( name ) ; push ( name ) ; startTagOpen = true ; level ++ ; } private void closeStartTag ( ) { if ( startTagOpen ) { startTagOpen = false ; write ( '>' ) ; } } private void attribute ( String name , String value ) { write ( ' ' ) ; write ( name ) ; write ( '=' ) ; write ( '"' ) ; chars ( value , true ) ; write ( '"' ) ; } private void data ( String str ) { if ( str . length ( ) > 0 ) { closeStartTag ( ) ; chars ( str , false ) ; suppressIndent = true ; } } private void chars ( String str , boolean isAttribute ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case '&' : write ( "&amp;" ) ; break ; case '<' : write ( "&lt;" ) ; break ; case '>' : write ( "&gt;" ) ; break ; case 0xD : write ( "&#xD;" ) ; break ; case 0xA : if ( isAttribute ) write ( "&#xA;" ) ; else write ( c ) ; break ; case 0x9 : if ( isAttribute ) write ( "&#x9;" ) ; else write ( c ) ; break ; case '"' : if ( isAttribute ) write ( "&quot;" ) ; else write ( c ) ; break ; default : write ( c ) ; break ; } } } private void endElement ( ) { -- level ; if ( startTagOpen ) { startTagOpen = false ; write ( "/>" ) ; pop ( ) ; } else { if ( ! suppressIndent ) indent ( level ) ; write ( "</" ) ; write ( pop ( ) ) ; write ( ">" ) ; } suppressIndent = false ; } private void indent ( int level ) { write ( '\n' ) ; for ( int i = 0 ; i < level ; i ++ ) write ( "  " ) ; } private void write ( String str ) { buf . append ( str ) ; } private void write ( char c ) { buf . append ( c ) ; } private void push ( String s ) { tagStack . add ( s ) ; } private String pop ( ) { return tagStack . remove ( tagStack . size ( ) - 1 ) ; } class Dumper implements PatternFunction < VoidValue > { public VoidValue caseEmpty ( EmptyPattern p ) { startElement ( "empty" ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseNotAllowed ( NotAllowedPattern p ) { startElement ( "notAllowed" ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseGroup ( GroupPattern p ) { startElement ( "group" ) ; p . getOperand1 ( ) . apply ( groupDumper ) ; p . getOperand2 ( ) . apply ( groupDumper ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseInterleave ( InterleavePattern p ) { startElement ( "interleave" ) ; p . getOperand1 ( ) . apply ( interleaveDumper ) ; p . getOperand2 ( ) . apply ( interleaveDumper ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseChoice ( ChoicePattern p ) { final Pattern p1 = p . getOperand1 ( ) ; final Pattern p2 = p . getOperand2 ( ) ; if ( p1 instanceof EmptyPattern ) p2 . apply ( optionalDumper ) ; else if ( p2 instanceof EmptyPattern ) p1 . apply ( optionalDumper ) ; else choice ( p1 , p2 ) ; return VoidValue . VOID ; } protected void choice ( Pattern p1 , Pattern p2 ) { startElement ( "choice" ) ; p1 . apply ( choiceDumper ) ; p2 . apply ( choiceDumper ) ; endElement ( ) ; } public VoidValue caseOneOrMore ( OneOrMorePattern p ) { startElement ( "oneOrMore" ) ; p . getOperand ( ) . apply ( dumper ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseElement ( ElementPattern p ) { startElement ( "ref" ) ; attribute ( "name" , getName ( p ) ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseAttribute ( AttributePattern p ) { startElement ( "attribute" ) ; outputName ( p . getNameClass ( ) ) ; p . getContent ( ) . apply ( dumper ) ; endElement ( ) ; return VoidValue . VOID ; } protected void outputName ( NameClass nc ) { if ( nc instanceof SimpleNameClass ) { Name name = ( ( SimpleNameClass ) nc ) . getName ( ) ; attribute ( "name" , name . getLocalName ( ) ) ; attribute ( "ns" , name . getNamespaceUri ( ) ) ; } else nc . accept ( nameClassDumper ) ; } public VoidValue caseData ( DataPattern p ) { startData ( p ) ; endElement ( ) ; return VoidValue . VOID ; } private void startData ( DataPattern p ) { startElement ( "data" ) ; final Name dtName = p . getDatatypeName ( ) ; attribute ( "type" , dtName . getLocalName ( ) ) ; attribute ( "datatypeLibrary" , dtName . getNamespaceUri ( ) ) ; for ( Iterator < String > iter = p . getParams ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { startElement ( "param" ) ; attribute ( "name" , iter . next ( ) ) ; data ( iter . next ( ) ) ; endElement ( ) ; } } public VoidValue caseDataExcept ( DataExceptPattern p ) { startData ( p ) ; startElement ( "except" ) ; p . getExcept ( ) . apply ( dumper ) ; endElement ( ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseValue ( ValuePattern p ) { startElement ( "value" ) ; Name dtName = p . getDatatypeName ( ) ; attribute ( "type" , dtName . getLocalName ( ) ) ; attribute ( "datatypeLibrary" , dtName . getNamespaceUri ( ) ) ; String stringValue = p . getStringValue ( ) ; final Object value = p . getValue ( ) ; String ns = "" ; if ( value instanceof Name ) { ns = ( ( Name ) value ) . getNamespaceUri ( ) ; int colonIndex = stringValue . indexOf ( ':' ) ; if ( colonIndex < 0 ) stringValue = stringValue . substring ( colonIndex + 1 , stringValue . length ( ) ) ; } attribute ( "ns" , ns ) ; data ( stringValue ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseText ( TextPattern p ) { startElement ( "text" ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseList ( ListPattern p ) { startElement ( "list" ) ; p . getOperand ( ) . apply ( dumper ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseRef ( RefPattern p ) { return p . getPattern ( ) . apply ( this ) ; } public VoidValue caseAfter ( AfterPattern p ) { startElement ( "i:after" ) ; attribute ( "xmlns:i" , INTERNAL_NAMESPACE ) ; p . getOperand1 ( ) . apply ( this ) ; p . getOperand2 ( ) . apply ( this ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseError ( ErrorPattern p ) { startElement ( "i:error" ) ; attribute ( "xmlns:i" , INTERNAL_NAMESPACE ) ; endElement ( ) ; return VoidValue . VOID ; } } class ElementDumper extends Dumper { public VoidValue caseElement ( ElementPattern p ) { startElement ( "element" ) ; outputName ( p . getNameClass ( ) ) ; p . getContent ( ) . apply ( dumper ) ; endElement ( ) ; return VoidValue . VOID ; } } class OptionalDumper extends AbstractPatternFunction < VoidValue > { public VoidValue caseOther ( Pattern p ) { startElement ( "optional" ) ; p . apply ( dumper ) ; endElement ( ) ; return VoidValue . VOID ; } public VoidValue caseOneOrMore ( OneOrMorePattern p ) { startElement ( "zeroOrMore" ) ; p . getOperand ( ) . apply ( dumper ) ; endElement ( ) ; return VoidValue . VOID ; } } class GroupDumper extends Dumper { public VoidValue caseGroup ( GroupPattern p ) { p . getOperand1 ( ) . apply ( this ) ; p . getOperand2 ( ) . apply ( this ) ; return VoidValue . VOID ; } } class ChoiceDumper extends Dumper { protected void choice ( Pattern p1 , Pattern p2 ) { p1 . apply ( this ) ; p2 . apply ( this ) ; } } class InterleaveDumper extends Dumper { public VoidValue caseInterleave ( InterleavePattern p ) { p . getOperand1 ( ) . apply ( this ) ; p . getOperand2 ( ) . apply ( this ) ; return VoidValue . VOID ; } } class NameClassDumper implements NameClassVisitor { public void visitChoice ( NameClass nc1 , NameClass nc2 ) { startElement ( "choice" ) ; nc1 . accept ( choiceNameClassDumper ) ; nc2 . accept ( choiceNameClassDumper ) ; endElement ( ) ; } public void visitNsName ( String ns ) { startElement ( "nsName" ) ; attribute ( "ns" , ns ) ; endElement ( ) ; } public void visitNsNameExcept ( String ns , NameClass nc ) { startElement ( "nsName" ) ; attribute ( "ns" , ns ) ; startElement ( "except" ) ; nc . accept ( nameClassDumper ) ; endElement ( ) ; endElement ( ) ; } public void visitAnyName ( ) { startElement ( "anyName" ) ; endElement ( ) ; } public void visitAnyNameExcept ( NameClass nc ) { startElement ( "anyName" ) ; startElement ( "except" ) ; nc . accept ( nameClassDumper ) ; endElement ( ) ; endElement ( ) ; } public void visitName ( Name name ) { startElement ( "name" ) ; attribute ( "ns" , name . getNamespaceUri ( ) ) ; data ( name . getLocalName ( ) ) ; endElement ( ) ; } public void visitError ( ) { startElement ( "error" ) ; endElement ( ) ; } public void visitNull ( ) { visitAnyName ( ) ; } } class ChoiceNameClassDumper extends NameClassDumper { public void visitChoice ( NameClass nc1 , NameClass nc2 ) { nc1 . accept ( this ) ; nc2 . accept ( this ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
