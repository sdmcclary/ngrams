<<<<<<< HEAD
public class EncryptedPrivateKeyInfo { private AlgorithmId algid ; private byte [ ] encryptedData ; private byte [ ] encoded = null ; public EncryptedPrivateKeyInfo ( byte [ ] encoded ) throws IOException { if ( encoded == null ) { throw new NullPointerException ( "the encoded parameter " + "must be non-null" ) ; } this . encoded = ( byte [ ] ) encoded . clone ( ) ; DerValue val = new DerValue ( this . encoded ) ; DerValue [ ] seq = new DerValue [ 2 ] ; seq [ 0 ] = val . data . getDerValue ( ) ; seq [ 1 ] = val . data . getDerValue ( ) ; if ( val . data . available ( ) != 0 ) { throw new IOException ( "overrun, bytes = " + val . data . available ( ) ) ; } this . algid = AlgorithmId . parse ( seq [ 0 ] ) ; if ( seq [ 0 ] . data . available ( ) != 0 ) { throw new IOException ( "encryptionAlgorithm field overrun" ) ; } this . encryptedData = seq [ 1 ] . getOctetString ( ) ; if ( seq [ 1 ] . data . available ( ) != 0 ) { throw new IOException ( "encryptedData field overrun" ) ; } } public EncryptedPrivateKeyInfo ( String algName , byte [ ] encryptedData ) throws NoSuchAlgorithmException { if ( algName == null ) throw new NullPointerException ( "the algName parameter " + "must be non-null" ) ; this . algid = AlgorithmId . get ( algName ) ; if ( encryptedData == null ) { throw new NullPointerException ( "the encryptedData " + "parameter must be non-null" ) ; } else if ( encryptedData . length == 0 ) { throw new IllegalArgumentException ( "the encryptedData " + "parameter must not be empty" ) ; } else { this . encryptedData = ( byte [ ] ) encryptedData . clone ( ) ; } this . encoded = null ; } public EncryptedPrivateKeyInfo ( AlgorithmParameters algParams , byte [ ] encryptedData ) throws NoSuchAlgorithmException { if ( algParams == null ) { throw new NullPointerException ( "algParams must be non-null" ) ; } this . algid = AlgorithmId . get ( algParams ) ; if ( encryptedData == null ) { throw new NullPointerException ( "encryptedData must be non-null" ) ; } else if ( encryptedData . length == 0 ) { throw new IllegalArgumentException ( "the encryptedData " + "parameter must not be empty" ) ; } else { this . encryptedData = ( byte [ ] ) encryptedData . clone ( ) ; } this . encoded = null ; } public String getAlgName ( ) { return this . algid . getName ( ) ; } public AlgorithmParameters getAlgParameters ( ) { return this . algid . getParameters ( ) ; } public byte [ ] getEncryptedData ( ) { return ( byte [ ] ) this . encryptedData . clone ( ) ; } public PKCS8EncodedKeySpec getKeySpec ( Cipher cipher ) throws InvalidKeySpecException { byte [ ] encoded = null ; try { encoded = cipher . doFinal ( ( byte [ ] ) encryptedData ) ; checkPKCS8Encoding ( encoded ) ; } catch ( GeneralSecurityException gse ) { InvalidKeySpecException ikse = new InvalidKeySpecException ( "Cannot retrieve the PKCS8EncodedKeySpec" ) ; ikse . initCause ( gse ) ; throw ikse ; } catch ( IOException ioe ) { InvalidKeySpecException ikse = new InvalidKeySpecException ( "Cannot retrieve the PKCS8EncodedKeySpec" ) ; ikse . initCause ( ioe ) ; throw ikse ; } catch ( IllegalStateException ise ) { InvalidKeySpecException ikse = new InvalidKeySpecException ( "Cannot retrieve the PKCS8EncodedKeySpec" ) ; ikse . initCause ( ise ) ; throw ikse ; } return new PKCS8EncodedKeySpec ( encoded ) ; } private PKCS8EncodedKeySpec getKeySpecImpl ( Key decryptKey , Provider provider ) throws NoSuchAlgorithmException , InvalidKeyException { byte [ ] encoded = null ; Cipher c ; try { if ( provider == null ) { c = Cipher . getInstance ( algid . getName ( ) ) ; } else { c = Cipher . getInstance ( algid . getName ( ) , provider ) ; } c . init ( Cipher . DECRYPT_MODE , decryptKey , algid . getParameters ( ) ) ; encoded = c . doFinal ( encryptedData ) ; checkPKCS8Encoding ( encoded ) ; } catch ( NoSuchAlgorithmException nsae ) { throw nsae ; } catch ( GeneralSecurityException gse ) { InvalidKeyException ike = new InvalidKeyException ( "Cannot retrieve the PKCS8EncodedKeySpec" ) ; ike . initCause ( gse ) ; throw ike ; } catch ( IOException ioe ) { InvalidKeyException ike = new InvalidKeyException ( "Cannot retrieve the PKCS8EncodedKeySpec" ) ; ike . initCause ( ioe ) ; throw ike ; } return new PKCS8EncodedKeySpec ( encoded ) ; } public PKCS8EncodedKeySpec getKeySpec ( Key decryptKey ) throws NoSuchAlgorithmException , InvalidKeyException { if ( decryptKey == null ) { throw new NullPointerException ( "decryptKey is null" ) ; } return getKeySpecImpl ( decryptKey , null ) ; } public PKCS8EncodedKeySpec getKeySpec ( Key decryptKey , String providerName ) throws NoSuchProviderException , NoSuchAlgorithmException , InvalidKeyException { if ( decryptKey == null ) { throw new NullPointerException ( "decryptKey is null" ) ; } if ( providerName == null ) { throw new NullPointerException ( "provider is null" ) ; } Provider provider = Security . getProvider ( providerName ) ; if ( provider == null ) { throw new NoSuchProviderException ( "provider " + providerName + " not found" ) ; } return getKeySpecImpl ( decryptKey , provider ) ; } public PKCS8EncodedKeySpec getKeySpec ( Key decryptKey , Provider provider ) throws NoSuchAlgorithmException , InvalidKeyException { if ( decryptKey == null ) { throw new NullPointerException ( "decryptKey is null" ) ; } if ( provider == null ) { throw new NullPointerException ( "provider is null" ) ; } return getKeySpecImpl ( decryptKey , provider ) ; } public byte [ ] getEncoded ( ) throws IOException { if ( this . encoded == null ) { DerOutputStream out = new DerOutputStream ( ) ; DerOutputStream tmp = new DerOutputStream ( ) ; algid . encode ( tmp ) ; tmp . putOctetString ( encryptedData ) ; out . write ( DerValue . tag_Sequence , tmp ) ; this . encoded = out . toByteArray ( ) ; } return ( byte [ ] ) this . encoded . clone ( ) ; } private static void checkTag ( DerValue val , byte tag , String valName ) throws IOException { if ( val . getTag ( ) != tag ) { throw new IOException ( "invalid key encoding - wrong tag for " + valName ) ; } } private static void checkPKCS8Encoding ( byte [ ] encodedKey ) throws IOException { DerInputStream in = new DerInputStream ( encodedKey ) ; DerValue [ ] values = in . getSequence ( 3 ) ; switch ( values . length ) { case 4 : checkTag ( values [ 3 ] , DerValue . TAG_CONTEXT , "attributes" ) ; case 3 : checkTag ( values [ 0 ] , DerValue . tag_Integer , "version" ) ; DerInputStream algid = values [ 1 ] . toDerInputStream ( ) ; algid . getOID ( ) ; if ( algid . available ( ) != 0 ) { algid . getDerValue ( ) ; } checkTag ( values [ 2 ] , DerValue . tag_OctetString , "privateKey" ) ; break ; default : throw new IOException ( "invalid key encoding" ) ; } } } 
=======
public class Script extends CdoCdcPair { public static final Script THE_INSTANCE = new Script ( ) ; protected Script ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { super . checkValid ( literal ) ; return ; } @ Override public String getName ( ) { return "embedded script content" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
