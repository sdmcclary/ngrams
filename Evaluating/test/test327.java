<<<<<<< HEAD
abstract public class Value implements java . io . Serializable { protected static final L10N L = new L10N ( Value . class ) ; public static final StringValue SCALAR_V = new ConstStringValue ( "scalar" ) ; public static final Value [ ] NULL_VALUE_ARRAY = new Value [ 0 ] ; public static final Value [ ] NULL_ARGS = new Value [ 0 ] ; public String getClassName ( ) { return getType ( ) ; } public boolean isA ( String name ) { return false ; } final public boolean isA ( Value value ) { if ( value . isObject ( ) ) return isA ( value . getClassName ( ) ) ; else return isA ( value . toString ( ) ) ; } public void checkProtected ( Env env , String className ) { } public void checkPrivate ( Env env , String className ) { } public ValueType getValueType ( ) { return ValueType . VALUE ; } public boolean isArray ( ) { return false ; } public boolean isDoubleConvertible ( ) { return false ; } public boolean isLongConvertible ( ) { return false ; } public boolean isLong ( ) { return false ; } public boolean isDouble ( ) { return false ; } public boolean isNull ( ) { return false ; } public boolean isNumberConvertible ( ) { return isLongConvertible ( ) || isDoubleConvertible ( ) ; } public boolean isNumeric ( ) { return false ; } public boolean isObject ( ) { return false ; } public boolean isResource ( ) { return false ; } public boolean isString ( ) { return false ; } public boolean isBinary ( ) { return false ; } public boolean isUnicode ( ) { return false ; } public boolean isBoolean ( ) { return false ; } public boolean isDefault ( ) { return false ; } public boolean isset ( ) { return true ; } public boolean isEmpty ( ) { return false ; } public boolean hasCurrent ( ) { return false ; } public Value eqValue ( Value rValue ) { return eq ( rValue ) ? BooleanValue . TRUE : BooleanValue . FALSE ; } public boolean eq ( Value rValue ) { if ( rValue instanceof BooleanValue ) return toBoolean ( ) == rValue . toBoolean ( ) ; else if ( isLongConvertible ( ) && rValue . isLongConvertible ( ) ) return toLong ( ) == rValue . toLong ( ) ; else if ( isNumberConvertible ( ) || rValue . isNumberConvertible ( ) ) return toDouble ( ) == rValue . toDouble ( ) ; else return toString ( ) . equals ( rValue . toString ( ) ) ; } public boolean eql ( Value rValue ) { return this == rValue . toValue ( ) ; } public int cmp ( Value rValue ) { Value lVal = toValue ( ) ; Value rVal = rValue . toValue ( ) ; if ( lVal instanceof StringValue && rVal instanceof NullValue ) return ( ( StringValue ) lVal ) . cmpString ( StringValue . EMPTY ) ; if ( lVal instanceof NullValue && rVal instanceof StringValue ) return StringValue . EMPTY . cmpString ( ( StringValue ) rVal ) ; if ( lVal instanceof StringValue && rVal instanceof StringValue ) return ( ( StringValue ) lVal ) . cmpString ( ( StringValue ) rVal ) ; if ( lVal instanceof NullValue || lVal instanceof BooleanValue || rVal instanceof NullValue || rVal instanceof BooleanValue ) { boolean lBool = toBoolean ( ) ; boolean rBool = rValue . toBoolean ( ) ; if ( ! lBool && rBool ) return - 1 ; if ( lBool && ! rBool ) return 1 ; return 0 ; } if ( lVal . isObject ( ) && rVal . isObject ( ) ) return ( ( ObjectValue ) lVal ) . cmpObject ( ( ObjectValue ) rVal ) ; if ( ( lVal instanceof StringValue || lVal instanceof NumberValue || lVal instanceof ResourceValue ) && ( rVal instanceof StringValue || rVal instanceof NumberValue || rVal instanceof ResourceValue ) ) return NumberValue . compareNum ( lVal , rVal ) ; if ( lVal instanceof ArrayValue ) return 1 ; if ( rVal instanceof ArrayValue ) return - 1 ; if ( lVal instanceof ObjectValue ) return 1 ; if ( rVal instanceof ObjectValue ) return - 1 ; throw new RuntimeException ( "values are incomparable: " + lVal + " <=> " + rVal ) ; } public boolean lt ( Value rValue ) { return cmp ( rValue ) < 0 ; } public boolean leq ( Value rValue ) { return cmp ( rValue ) <= 0 ; } public boolean gt ( Value rValue ) { return cmp ( rValue ) > 0 ; } public boolean geq ( Value rValue ) { return cmp ( rValue ) >= 0 ; } public boolean toBoolean ( ) { return true ; } public long toLong ( ) { return toBoolean ( ) ? 1 : 0 ; } public int toInt ( ) { return ( int ) toLong ( ) ; } public double toDouble ( ) { return 0 ; } public char toChar ( ) { String s = toString ( ) ; if ( s == null || s . length ( ) < 1 ) return 0 ; else return s . charAt ( 0 ) ; } public StringValue toReprString ( Env env ) { return toStringValue ( env ) ; } public Value toArray ( ) { return new ArrayValueImpl ( ) . append ( this ) ; } public Value toAutoArray ( ) { return this ; } public ArrayValue toArrayValue ( Env env ) { env . warning ( L . l ( "'{0}' ({1}) is not assignable to ArrayValue" , this , getType ( ) ) ) ; return null ; } public Value toAutoObject ( Env env ) { return this ; } public Value toObject ( Env env ) { ObjectValue obj = env . createObject ( ) ; obj . putField ( env , env . createStringOld ( "scalar" ) , this ) ; return obj ; } public Object toJavaObject ( ) { return null ; } public < T > T toJavaObject ( Env env , Class < T > type ) { env . warning ( L . l ( "Can't convert {0} to Java {1}" , getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } public < T > T toJavaObjectNotNull ( Env env , Class < T > type ) { env . warning ( L . l ( "Can't convert {0} to Java {1}" , getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } public Boolean toJavaBoolean ( ) { return toBoolean ( ) ? Boolean . TRUE : Boolean . FALSE ; } public Byte toJavaByte ( ) { return new Byte ( ( byte ) toLong ( ) ) ; } public Short toJavaShort ( ) { return new Short ( ( short ) toLong ( ) ) ; } public Integer toJavaInteger ( ) { return new Integer ( ( int ) toLong ( ) ) ; } public Long toJavaLong ( ) { return new Long ( ( int ) toLong ( ) ) ; } public Float toJavaFloat ( ) { return new Float ( ( float ) toDouble ( ) ) ; } public Double toJavaDouble ( ) { return new Double ( toDouble ( ) ) ; } public Character toJavaCharacter ( ) { return new Character ( toChar ( ) ) ; } public String toJavaString ( ) { return toString ( ) ; } public < T > Collection < T > toJavaCollection ( Env env , Class < ? extends Collection < T > > type ) { env . warning ( L . l ( "Can't convert {0} to Java {1}" , getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } public < T > List < T > toJavaList ( Env env , Class < ? extends List < T > > type ) { env . warning ( L . l ( "Can't convert {0} to Java {1}" , getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } public < K , V > Map < K , V > toJavaMap ( Env env , Class < ? extends Map < K , V > > type ) { env . warning ( L . l ( "Can't convert {0} to Java {1}" , getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } public Calendar toJavaCalendar ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTimeInMillis ( toLong ( ) ) ; return cal ; } public Date toJavaDate ( ) { return new Date ( toLong ( ) ) ; } public URL toJavaURL ( Env env ) { try { return new URL ( toString ( ) ) ; } catch ( MalformedURLException e ) { env . warning ( L . l ( e . getMessage ( ) ) ) ; return null ; } } public BigDecimal toBigDecimal ( ) { return new BigDecimal ( toString ( ) ) ; } public BigInteger toBigInteger ( ) { return new BigInteger ( toString ( ) ) ; } public QuercusException toException ( Env env , String file , int line ) { putField ( env , env . createStringOld ( "file" ) , env . createStringOld ( file ) ) ; putField ( env , env . createStringOld ( "line" ) , LongValue . create ( line ) ) ; return new QuercusLanguageException ( this ) ; } public Value toValue ( ) { return this ; } public Value toKey ( ) { throw new QuercusRuntimeException ( L . l ( "{0} is not a valid key" , this ) ) ; } public Value toRef ( ) { return this ; } public Value toArgValueReadOnly ( ) { return this ; } public Value toArgValue ( ) { return this ; } public Value toRefValue ( ) { return this ; } public Var toVar ( ) { return new Var ( toArgValue ( ) ) ; } public Var toRefVar ( ) { return new Var ( this ) ; } public StringValue toStringValue ( ) { return toStringValue ( Env . getInstance ( ) ) ; } public StringValue toStringValue ( Env env ) { return toStringBuilder ( env ) ; } public StringValue toUnicodeValue ( ) { return toUnicodeValue ( Env . getInstance ( ) ) ; } public StringValue toUnicodeValue ( Env env ) { return env . createStringOld ( toString ( ) ) ; } public StringValue toBinaryValue ( ) { return toBinaryValue ( Env . getInstance ( ) ) ; } public StringValue toBinaryValue ( String charset ) { return toBinaryValue ( ) ; } public StringValue toBinaryValue ( Env env ) { StringValue bb = env . createBinaryBuilder ( ) ; bb . append ( this ) ; return bb ; } public InputStream toInputStream ( ) { return new StringInputStream ( toString ( ) ) ; } public StringValue toStringBuilder ( ) { return toStringBuilder ( Env . getInstance ( ) ) ; } public StringValue toStringBuilder ( Env env ) { return env . createUnicodeBuilder ( ) . appendUnicode ( this ) ; } public StringValue toStringBuilder ( Env env , Value value ) { return toStringBuilder ( env ) . appendUnicode ( value ) ; } public StringValue toStringBuilder ( Env env , StringValue value ) { return toStringBuilder ( env ) . appendUnicode ( value ) ; } public StringValue copyStringBuilder ( ) { return toStringBuilder ( ) ; } public LongValue toLongValue ( ) { return LongValue . create ( toLong ( ) ) ; } public DoubleValue toDoubleValue ( ) { return new DoubleValue ( toDouble ( ) ) ; } public StringValue appendTo ( UnicodeBuilderValue sb ) { return sb . append ( toString ( ) ) ; } public StringValue appendTo ( StringBuilderValue sb ) { return sb . append ( toString ( ) ) ; } public StringValue appendTo ( BinaryBuilderValue sb ) { return sb . appendBytes ( toString ( ) ) ; } public StringValue appendTo ( LargeStringBuilderValue sb ) { return sb . append ( toString ( ) ) ; } public Value copy ( ) { return this ; } public Value copyArrayItem ( ) { return copy ( ) ; } public Value copyReturn ( ) { return this ; } public final Value copy ( Env env ) { return copy ( env , new IdentityHashMap < Value , Value > ( ) ) ; } public Value copy ( Env env , IdentityHashMap < Value , Value > map ) { return this ; } public Value copyTree ( Env env , CopyRoot root ) { return this ; } public Value clone ( ) { return this ; } public String getType ( ) { return "value" ; } public String getResourceType ( ) { return null ; } public Value key ( ) { return BooleanValue . FALSE ; } public Value current ( ) { return BooleanValue . FALSE ; } public Value next ( ) { return BooleanValue . FALSE ; } public AbstractFunction findFunction ( String methodName ) { return null ; } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Expr [ ] args ) { Value [ ] value = new Value [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { value [ i ] = args [ i ] . eval ( env ) ; } return callMethod ( env , hash , name , nameLen , value ) ; } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value [ ] args ) { switch ( args . length ) { case 0 : return callMethod ( env , hash , name , nameLen ) ; case 1 : return callMethod ( env , hash , name , nameLen , args [ 0 ] ) ; case 2 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] ) ; case 3 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; case 4 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; case 5 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] , args [ 4 ] ) ; default : return errorNoMethod ( env , name , nameLen ) ; } } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a0 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 , Value a2 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 , Value a2 , Value a3 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 , Value a2 , Value a3 , Value a5 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Expr [ ] args ) { Value [ ] value = new Value [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { value [ i ] = args [ i ] . eval ( env ) ; } return callMethodRef ( env , hash , name , nameLen , value ) ; } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value [ ] args ) { switch ( args . length ) { case 0 : return callMethodRef ( env , hash , name , nameLen ) ; case 1 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] ) ; case 2 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] ) ; case 3 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; case 4 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; case 5 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] , args [ 4 ] ) ; default : return errorNoMethod ( env , name , nameLen ) ; } } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a0 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 , Value a2 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 , Value a2 , Value a3 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a0 , Value a1 , Value a2 , Value a3 , Value a5 ) { return errorNoMethod ( env , name , nameLen ) ; } public Value callMethod ( Env env , StringValue nameValue , Expr [ ] args ) { Value [ ] value = new Value [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { value [ i ] = args [ i ] . eval ( env ) ; } char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethod ( env , hash , name , nameLen , value ) ; } public Value callMethod ( Env env , StringValue nameValue , Value [ ] args ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; switch ( args . length ) { case 0 : return callMethod ( env , hash , name , nameLen ) ; case 1 : return callMethod ( env , hash , name , nameLen , args [ 0 ] ) ; case 2 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] ) ; case 3 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; case 4 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; case 5 : return callMethod ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] , args [ 4 ] ) ; default : return callMethod ( env , hash , name , nameLen , args ) ; } } public Value callMethod ( Env env , StringValue nameValue ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethod ( env , hash , name , nameLen ) ; } public Value callMethod ( Env env , StringValue nameValue , Value a0 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethod ( env , hash , name , nameLen , a0 ) ; } public Value callMethod ( Env env , StringValue nameValue , Value a0 , Value a1 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethod ( env , hash , name , nameLen , a0 , a1 ) ; } public Value callMethod ( Env env , StringValue nameValue , Value a0 , Value a1 , Value a2 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethod ( env , hash , name , nameLen , a0 , a1 , a2 ) ; } public Value callMethod ( Env env , StringValue nameValue , Value a0 , Value a1 , Value a2 , Value a3 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethod ( env , hash , name , nameLen , a0 , a1 , a2 , a3 ) ; } public Value callMethod ( Env env , StringValue nameValue , Value a0 , Value a1 , Value a2 , Value a3 , Value a4 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethod ( env , hash , name , nameLen , a0 , a1 , a2 , a3 , a4 ) ; } public Value callMethodRef ( Env env , StringValue nameValue , Expr [ ] args ) { Value [ ] value = new Value [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { value [ i ] = args [ i ] . eval ( env ) ; } char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethodRef ( env , hash , name , nameLen , value ) ; } public Value callMethodRef ( Env env , StringValue nameValue , Value [ ] args ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; switch ( args . length ) { case 0 : return callMethodRef ( env , hash , name , nameLen ) ; case 1 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] ) ; case 2 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] ) ; case 3 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; case 4 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; case 5 : return callMethodRef ( env , hash , name , nameLen , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] , args [ 4 ] ) ; default : return errorNoMethod ( env , name , nameLen ) ; } } public Value callMethodRef ( Env env , StringValue nameValue ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethodRef ( env , hash , name , nameLen ) ; } public Value callMethodRef ( Env env , StringValue nameValue , Value a0 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethodRef ( env , hash , name , nameLen , a0 ) ; } public Value callMethodRef ( Env env , StringValue nameValue , Value a0 , Value a1 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethodRef ( env , hash , name , nameLen , a0 , a1 ) ; } public Value callMethodRef ( Env env , StringValue nameValue , Value a0 , Value a1 , Value a2 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethodRef ( env , hash , name , nameLen , a0 , a1 , a2 ) ; } public Value callMethodRef ( Env env , StringValue nameValue , Value a0 , Value a1 , Value a2 , Value a3 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethodRef ( env , hash , name , nameLen , a0 , a1 , a2 , a3 ) ; } public Value callMethodRef ( Env env , StringValue nameValue , Value a0 , Value a1 , Value a2 , Value a3 , Value a4 ) { char [ ] name = nameValue . getRawCharArray ( ) ; int nameLen = nameValue . length ( ) ; int hash = MethodMap . hash ( name , nameLen ) ; return callMethodRef ( env , hash , name , nameLen , a0 , a1 , a2 , a3 , a4 ) ; } public Value callClassMethod ( Env env , AbstractFunction fun , Value [ ] args ) { return NullValue . NULL ; } private Value errorNoMethod ( Env env , char [ ] name , int nameLen ) { String methodName = new String ( name , 0 , nameLen ) ; if ( isNull ( ) ) return env . error ( L . l ( "Method call '{0}' is not allowed for a null value." , methodName ) ) ; else return env . error ( L . l ( "'{0}' is an unknown method of {1}." , methodName , toDebugString ( ) ) ) ; } public Value neg ( ) { return LongValue . create ( - toLong ( ) ) ; } public Value pos ( ) { return LongValue . create ( toLong ( ) ) ; } public Value add ( Value rValue ) { if ( getValueType ( ) . isLongAdd ( ) && rValue . getValueType ( ) . isLongAdd ( ) ) return LongValue . create ( toLong ( ) + rValue . toLong ( ) ) ; return DoubleValue . create ( toDouble ( ) + rValue . toDouble ( ) ) ; } public Value add ( long lLong ) { return new DoubleValue ( lLong + toDouble ( ) ) ; } public Value preincr ( int incr ) { return increment ( incr ) ; } public Value postincr ( int incr ) { return increment ( incr ) ; } public Value increment ( int incr ) { long lValue = toLong ( ) ; return LongValue . create ( lValue + incr ) ; } public Value sub ( Value rValue ) { if ( getValueType ( ) . isLongAdd ( ) && rValue . getValueType ( ) . isLongAdd ( ) ) return LongValue . create ( toLong ( ) - rValue . toLong ( ) ) ; return DoubleValue . create ( toDouble ( ) - rValue . toDouble ( ) ) ; } public Value sub ( long rLong ) { return new DoubleValue ( toDouble ( ) - rLong ) ; } public Value sub_rev ( long lLong ) { if ( getValueType ( ) . isLongAdd ( ) ) return LongValue . create ( lLong - toLong ( ) ) ; else return new DoubleValue ( lLong - toDouble ( ) ) ; } public Value mul ( Value rValue ) { if ( getValueType ( ) . isLongAdd ( ) && rValue . getValueType ( ) . isLongAdd ( ) ) return LongValue . create ( toLong ( ) * rValue . toLong ( ) ) ; else return new DoubleValue ( toDouble ( ) * rValue . toDouble ( ) ) ; } public Value mul ( long r ) { if ( isLongConvertible ( ) ) return LongValue . create ( toLong ( ) * r ) ; else return new DoubleValue ( toDouble ( ) * r ) ; } public Value div ( Value rValue ) { if ( getValueType ( ) . isLongAdd ( ) && rValue . getValueType ( ) . isLongAdd ( ) ) { long l = toLong ( ) ; long r = rValue . toLong ( ) ; if ( r != 0 && l % r == 0 ) return LongValue . create ( l / r ) ; else return new DoubleValue ( toDouble ( ) / rValue . toDouble ( ) ) ; } else return new DoubleValue ( toDouble ( ) / rValue . toDouble ( ) ) ; } public Value div ( long r ) { long l = toLong ( ) ; if ( r != 0 && l % r == 0 ) return LongValue . create ( l / r ) ; else return new DoubleValue ( toDouble ( ) / r ) ; } public Value mod ( Value rValue ) { double lDouble = toDouble ( ) ; double rDouble = rValue . toDouble ( ) ; return LongValue . create ( ( long ) lDouble % rDouble ) ; } public Value lshift ( Value rValue ) { long lLong = toLong ( ) ; long rLong = rValue . toLong ( ) ; return LongValue . create ( lLong << rLong ) ; } public Value rshift ( Value rValue ) { long lLong = toLong ( ) ; long rLong = rValue . toLong ( ) ; return LongValue . create ( lLong > > rLong ) ; } public Value bitAnd ( Value rValue ) { return LongValue . create ( toLong ( ) & rValue . toLong ( ) ) ; } public Value bitOr ( Value rValue ) { return LongValue . create ( toLong ( ) | rValue . toLong ( ) ) ; } public Value bitXor ( Value rValue ) { return LongValue . create ( toLong ( ) ^ rValue . toLong ( ) ) ; } public Value abs ( ) { if ( getValueType ( ) . isDoubleCmp ( ) ) return new DoubleValue ( Math . abs ( toDouble ( ) ) ) ; else return LongValue . create ( Math . abs ( toLong ( ) ) ) ; } public long nextIndex ( long oldIndex ) { return oldIndex ; } public int length ( ) { return toStringValue ( ) . length ( ) ; } public int getSize ( ) { return 1 ; } public int getCount ( Env env ) { return 1 ; } public int getCountRecursive ( Env env ) { return getCount ( env ) ; } public Iterator < Map . Entry < Value , Value > > getIterator ( Env env ) { Set < Map . Entry < Value , Value > > emptySet = Collections . emptySet ( ) ; return emptySet . iterator ( ) ; } public Iterator < Value > getKeyIterator ( Env env ) { final Iterator < Map . Entry < Value , Value > > iter = getIterator ( env ) ; return new Iterator < Value > ( ) { public boolean hasNext ( ) { return iter . hasNext ( ) ; } public Value next ( ) { return iter . next ( ) . getKey ( ) ; } public void remove ( ) { iter . remove ( ) ; } } ; } public Value [ ] getKeyArray ( Env env ) { return NULL_VALUE_ARRAY ; } public Value [ ] getValueArray ( Env env ) { return NULL_VALUE_ARRAY ; } public Iterator < Value > getValueIterator ( Env env ) { final Iterator < Map . Entry < Value , Value > > iter = getIterator ( env ) ; return new Iterator < Value > ( ) { public boolean hasNext ( ) { return iter . hasNext ( ) ; } public Value next ( ) { return iter . next ( ) . getValue ( ) ; } public void remove ( ) { iter . remove ( ) ; } } ; } public Value getField ( Env env , StringValue name ) { return NullValue . NULL ; } public Var getFieldRef ( Env env , StringValue name ) { Value value = getField ( env , name ) ; if ( value instanceof Var ) return ( Var ) value ; else return new Var ( value ) ; } public Value getFieldArg ( Env env , StringValue name , boolean isTop ) { return getFieldRef ( env , name ) ; } public Value getFieldArgRef ( Env env , StringValue name ) { return getFieldRef ( env , name ) ; } public Value getFieldObject ( Env env , StringValue name ) { Value v = getField ( env , name ) ; if ( ! v . isset ( ) ) { v = env . createObject ( ) ; putField ( env , name , v ) ; } return v ; } public Value getFieldArray ( Env env , StringValue name ) { Value v = getField ( env , name ) ; Value array = v . toAutoArray ( ) ; if ( v == array ) return v ; else { putField ( env , name , array ) ; return array ; } } public Value putField ( Env env , StringValue name , Value object ) { return NullValue . NULL ; } public final Value putField ( Env env , StringValue name , Value value , Value innerIndex , Value innerValue ) { Value result = value . append ( innerIndex , innerValue ) ; return putField ( env , name , result ) ; } public boolean issetField ( StringValue name ) { return false ; } public void unsetField ( StringValue name ) { } public Value getThisField ( Env env , StringValue name ) { return getField ( env , name ) ; } public Var getThisFieldRef ( Env env , StringValue name ) { Value value = getThisField ( env , name ) ; if ( value instanceof Var ) return ( Var ) value ; else return new Var ( value ) ; } public Value getThisFieldArg ( Env env , StringValue name ) { return getThisFieldRef ( env , name ) ; } public Value getThisFieldArgRef ( Env env , StringValue name ) { return getThisFieldRef ( env , name ) ; } public Value getThisFieldObject ( Env env , StringValue name ) { Value v = getThisField ( env , name ) ; if ( ! v . isset ( ) ) { v = env . createObject ( ) ; putThisField ( env , name , v ) ; } return v ; } public Value getThisFieldArray ( Env env , StringValue name ) { Value v = getThisField ( env , name ) ; Value array = v . toAutoArray ( ) ; if ( v == array ) return v ; else { putField ( env , name , array ) ; return array ; } } public void initField ( StringValue key , Value value , FieldVisibility visibility ) { putThisField ( Env . getInstance ( ) , key , value ) ; } public Value putThisField ( Env env , StringValue name , Value object ) { return putField ( env , name , object ) ; } public boolean issetThisField ( StringValue name ) { return issetField ( name ) ; } public void unsetThisField ( StringValue name ) { unsetField ( name ) ; } public Value putField ( Env env , String name , Value value ) { return putThisField ( env , env . createStringOld ( name ) , value ) ; } public Value get ( Value index ) { return UnsetValue . UNSET ; } public Var getRef ( Value index ) { Value value = get ( index ) ; if ( value instanceof Var ) return ( Var ) value ; else return new Var ( value ) ; } public Value getArg ( Value index , boolean isTop ) { return get ( index ) ; } public Value getDirty ( Value index ) { return get ( index ) ; } public Value getArray ( ) { return this ; } public Value getArray ( Value index ) { return NullValue . NULL ; } public Value getObject ( Env env ) { return NullValue . NULL ; } public Value getObject ( Env env , Value index ) { return NullValue . NULL ; } public Value set ( Value value ) { return value ; } public Value put ( Value index , Value value ) { return value ; } public final Value put ( Value index , Value value , Value innerIndex , Value innerValue ) { Value result = value . append ( innerIndex , innerValue ) ; put ( index , result ) ; return innerValue ; } public Value put ( Value value ) { return value ; } public Value append ( Value index , Value value ) { return this ; } public Var putRef ( ) { return new Var ( ) ; } public Value putArray ( ) { ArrayValue value = new ArrayValueImpl ( ) ; put ( value ) ; return value ; } public Value putObject ( Env env ) { Value value = env . createObject ( ) ; put ( value ) ; return value ; } public boolean isset ( Value index ) { return false ; } public Value remove ( Value index ) { return UnsetValue . UNSET ; } public < T > T [ ] valuesToArray ( Env env , Class < T > elementType ) { env . error ( L . l ( "Can't assign {0} with type {1} to {2}[]" , this , this . getClass ( ) , elementType ) ) ; return null ; } public Value charValueAt ( long index ) { return NullValue . NULL ; } public Value setCharValueAt ( long index , Value value ) { return NullValue . NULL ; } public void print ( Env env ) { env . print ( toReprString ( env ) ) ; } public void print ( Env env , WriteStream out ) { try { out . print ( toReprString ( env ) ) ; } catch ( IOException e ) { throw new QuercusRuntimeException ( e ) ; } } public void serialize ( Env env , StringBuilder sb , SerializeMap serializeMap ) { serializeMap . incrementIndex ( ) ; serialize ( env , sb ) ; } public void serialize ( Env env , StringBuilder sb ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public void varExport ( StringBuilder sb ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public void generate ( PrintWriter out ) throws IOException { } protected static void printJavaChar ( PrintWriter out , char ch ) { switch ( ch ) { case '\r' : out . print ( "\\r" ) ; break ; case '\n' : out . print ( "\\n" ) ; break ; case '\'' : out . print ( "\\\'" ) ; break ; case '\\' : out . print ( "\\\\" ) ; break ; default : out . print ( ch ) ; break ; } } protected static void printJavaString ( PrintWriter out , StringValue s ) { if ( s == null ) { out . print ( "" ) ; return ; } int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case '\r' : out . print ( "\\r" ) ; break ; case '\n' : out . print ( "\\n" ) ; break ; case '\"' : out . print ( "\\\"" ) ; break ; case '\'' : out . print ( "\\\'" ) ; break ; case '\\' : out . print ( "\\\\" ) ; break ; default : out . print ( ch ) ; break ; } } } public String toInternString ( ) { return toString ( ) . intern ( ) ; } public String toDebugString ( ) { return toString ( ) ; } public final void varDump ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { if ( valueSet . get ( this ) != null ) { out . print ( "#recursion#" ) ; return ; } valueSet . put ( this , "printing" ) ; try { varDumpImpl ( env , out , depth , valueSet ) ; } finally { valueSet . remove ( this ) ; } } protected void varDumpImpl ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { out . print ( "resource(" + toString ( ) + ")" ) ; } public final void printR ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { if ( valueSet . get ( this ) != null ) { out . print ( "#recursion#" ) ; return ; } valueSet . put ( this , "printing" ) ; try { printRImpl ( env , out , depth , valueSet ) ; } finally { valueSet . remove ( this ) ; } } protected void printRImpl ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { out . print ( toString ( ) ) ; } protected void printDepth ( WriteStream out , int depth ) throws IOException { for ( int i = 0 ; i < depth ; i ++ ) out . print ( ' ' ) ; } } 
=======
interface NamespaceContext { String getNamespaceUri ( String string ) ; String defaultPrefix ( ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
