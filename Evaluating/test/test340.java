<<<<<<< HEAD
public class Authentication { public static String getAuthorization ( String user , String pass , String requestMethod , String uri , String header ) { if ( header . startsWith ( "Digest" ) ) return digest ( user , pass , requestMethod , uri , header ) ; else return basic ( user , pass ) ; } public static String basic ( String user , String pass ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( user ) ; sb . append ( ':' ) ; sb . append ( pass ) ; return basic ( sb . toString ( ) ) ; } public static String basic ( String usernamePassword ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "Basic " ) ; sb . append ( Base64 . encode ( usernamePassword ) ) ; return sb . toString ( ) ; } public static String digest ( String user , String pass , String requestMethod , String uri , String header ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "Digest " ) ; sb . append ( "username=\"" ) ; sb . append ( user ) ; Scanner scanner = new Scanner ( header ) ; String realm = "" ; String nonce = "" ; String qop = "" ; String opaque = null ; String algorithm = null ; String key ; while ( ( key = scanner . readKey ( ) ) != null ) { String value = scanner . readValue ( ) ; if ( key . equals ( "realm" ) ) realm = value ; else if ( key . equals ( "nonce" ) ) nonce = value ; else if ( key . equals ( "qop" ) ) qop = value ; else if ( key . equals ( "opaque" ) ) opaque = value ; else if ( key . equals ( "algorithm" ) ) algorithm = value ; } scanner . close ( ) ; sb . append ( "\", realm=\"" ) ; sb . append ( realm ) ; sb . append ( "\", nonce=\"" ) ; sb . append ( nonce ) ; sb . append ( "\", uri=\"" ) ; sb . append ( uri ) ; sb . append ( "\", qop=\"" ) ; sb . append ( "auth" ) ; String cnonce = Base64 . encode ( String . valueOf ( RandomUtil . getRandomLong ( ) ) ) ; sb . append ( "\", cnonce=\"" ) ; sb . append ( cnonce ) ; String nc = "00000001" ; sb . append ( "\", nc=\"" ) ; sb . append ( nc ) ; if ( opaque != null ) { sb . append ( "\", opaque=\"" ) ; sb . append ( opaque ) ; } if ( algorithm != null ) { sb . append ( "\", algorithm=\"" ) ; sb . append ( algorithm ) ; } else algorithm = "MD5" ; sb . append ( "\", response=\"" ) ; appendResponse ( sb , user , realm , pass , requestMethod , uri , nonce , nc , cnonce , qop , algorithm ) ; sb . append ( '"' ) ; return sb . toString ( ) ; } private static void appendResponse ( StringBuilder sb , String user , String realm , String pass , String requestMethod , String uri , String nonce , String nc , String cnonce , String qop , String algorithm ) { MessageDigest resultDigest = null ; MessageDigest scratchDigest = null ; try { resultDigest = MessageDigest . getInstance ( algorithm ) ; scratchDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new QuercusModuleException ( e ) ; } { md5 ( scratchDigest , user ) ; scratchDigest . update ( ( byte ) ':' ) ; md5 ( scratchDigest , realm ) ; scratchDigest . update ( ( byte ) ':' ) ; md5 ( scratchDigest , pass ) ; update ( resultDigest , scratchDigest . digest ( ) ) ; resultDigest . update ( ( byte ) ':' ) ; } md5 ( resultDigest , nonce ) ; resultDigest . update ( ( byte ) ':' ) ; md5 ( resultDigest , nc ) ; resultDigest . update ( ( byte ) ':' ) ; md5 ( resultDigest , cnonce ) ; resultDigest . update ( ( byte ) ':' ) ; md5 ( resultDigest , qop ) ; resultDigest . update ( ( byte ) ':' ) ; { scratchDigest . reset ( ) ; md5 ( scratchDigest , requestMethod ) ; scratchDigest . update ( ( byte ) ':' ) ; md5 ( scratchDigest , uri ) ; update ( resultDigest , scratchDigest . digest ( ) ) ; } appendHex ( sb , resultDigest . digest ( ) ) ; } private static void md5 ( MessageDigest md , String string ) { int length = string . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { md . update ( ( byte ) string . charAt ( i ) ) ; } } private static void update ( MessageDigest resultDigest , byte [ ] digest ) { for ( int i = 0 ; i < digest . length ; i ++ ) { int d1 = ( digest [ i ] > > 4 ) & 0xf ; int d2 = ( digest [ i ] & 0xf ) ; resultDigest . update ( ( byte ) toHexChar ( d1 ) ) ; resultDigest . update ( ( byte ) toHexChar ( d2 ) ) ; } } private static void appendHex ( StringBuilder sb , byte [ ] digest ) { for ( int i = 0 ; i < digest . length ; i ++ ) { int d1 = ( digest [ i ] > > 4 ) & 0xf ; int d2 = ( digest [ i ] & 0xf ) ; sb . append ( toHexChar ( d1 ) ) ; sb . append ( toHexChar ( d2 ) ) ; } } private static char toHexChar ( int d ) { d &= 0xf ; if ( d < 10 ) return ( char ) ( d + '0' ) ; else return ( char ) ( d - 10 + 'a' ) ; } } class Scanner { String _header ; int _position ; int _length ; CharBuffer _cb ; Scanner ( String header ) { _header = header ; _position = header . indexOf ( "Digest" ) + "Digest" . length ( ) ; _length = header . length ( ) ; _cb = CharBuffer . allocate ( ) ; } String readKey ( ) { int ch = skipWhitespace ( ) ; if ( ch < 0 ) return null ; if ( ch == ',' ) ch = skipWhitespace ( ) ; do { _cb . append ( ( char ) ch ) ; } while ( ( ch = read ( ) ) != '=' ) ; read ( ) ; String key = _cb . toString ( ) ; _cb . clear ( ) ; return key ; } String readValue ( ) { int ch ; while ( ( ch = read ( ) ) != '"' ) { _cb . append ( ( char ) ch ) ; } String value = _cb . toString ( ) ; _cb . clear ( ) ; return value ; } int skipWhitespace ( ) { int ch ; while ( ( ch = read ( ) ) >= 0 ) { if ( ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n' && ch != '\f' ) break ; } return ch ; } int read ( ) { if ( _position >= _length ) return - 1 ; else return _header . charAt ( _position ++ ) ; } void close ( ) { _cb . free ( ) ; } } 
=======
interface SelectionHandler { void selectElement ( ErrorContext ec , Path path , PatternManager pm ) ; void selectAttribute ( ErrorContext ec , Path path , String value ) ; void selectComplete ( ErrorContext ec ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
