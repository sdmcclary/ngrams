<<<<<<< HEAD
public class SyncModel extends BaseModelObject implements ILoggable { public static final int USE_STREAM = - 100 ; public static final int WAITING = 0 ; public static final int RUNNING = 1 ; public static final int SUCCESS = 2 ; public static final int FAILURE = 3 ; public class SyncPair extends VirtualFileSyncPair { int status ; IConnectionPoint sourceManager ; IConnectionPoint destManager ; String fromEndpoint ; String fromFolder ; String toEndpoint ; String toFolder ; SyncPair ( VirtualFileSyncPair vfsPair ) { this ( vfsPair . getSourceFile ( ) , vfsPair . getDestinationFile ( ) , vfsPair . getRelativePath ( ) , vfsPair . getSyncState ( ) ) ; } SyncPair ( IFileStore sourceFile , IFileStore destinationFile , String relativePath , int syncState ) { super ( sourceFile , destinationFile , relativePath , syncState ) ; } public IConnectionPoint getDestManager ( ) { return destManager ; } public IConnectionPoint getSourceManager ( ) { return sourceManager ; } public int getStatus ( ) { return status ; } public String getFromEndpoint ( ) { return fromEndpoint ; } public String getFromFolder ( ) { return fromFolder ; } public String getToEndpoint ( ) { return toEndpoint ; } public String getToFolder ( ) { return toFolder ; } } private class Pair { Object from ; Object to ; Pair ( Object from , Object to ) { this . from = from ; this . to = to ; } } private List < SyncPair > items ; private List < Pair > toBeProcessed ; private SyncPair lastSync ; private SyncPair lastAdded ; private SyncPair currentSync ; private Job buildJob ; private Job syncJob ; private ILogger logger ; public SyncModel ( ) { this . items = new ArrayList < SyncPair > ( ) ; this . toBeProcessed = new ArrayList < Pair > ( ) ; this . lastSync = null ; this . lastAdded = null ; this . currentSync = null ; listeners = new ListenerList ( ) ; buildJob = new Job ( "Building sync pairs" ) { protected IStatus run ( IProgressMonitor monitor ) { Pair pair = null ; synchronized ( toBeProcessed ) { while ( toBeProcessed . isEmpty ( ) ) { try { toBeProcessed . wait ( ) ; } catch ( InterruptedException e ) { } if ( monitor != null && monitor . isCanceled ( ) ) { return Status . CANCEL_STATUS ; } } if ( toBeProcessed . size ( ) > 0 ) { pair = toBeProcessed . remove ( 0 ) ; } } if ( pair != null ) { String fromEnd = null ; String fromFolder = null ; String toEnd = null ; String toFolder = null ; Object from = pair . from ; Object to = pair . to ; IConnectionPoint fromPoint = null ; IConnectionPoint toPoint = null ; IFileStore fromFile = null ; IFileStore toFile = null ; if ( from instanceof IFileStore ) { fromFile = ( IFileStore ) from ; fromEnd = fromPoint . getName ( ) ; fromFolder = EFSUtils . getRelativePath ( fromPoint , fromFile ) ; } if ( to instanceof IFileStore ) { toFile = ( IFileStore ) to ; toEnd = toPoint . getName ( ) ; toFolder = EFSUtils . getRelativePath ( toPoint , toFile ) ; } else if ( to instanceof IConnectionPoint ) { try { toFile = ( ( IConnectionPoint ) to ) . getRoot ( ) ; } catch ( CoreException e ) { e . printStackTrace ( ) ; } toEnd = ( ( IConnectionPoint ) to ) . getName ( ) ; toFolder = EFSUtils . getRelativePath ( toPoint , toFile ) ; } if ( fromFile != null && toFile != null ) { if ( fromFile . fetchInfo ( ) . isDirectory ( ) ) { try { boolean dirExists = false ; IFileStore toDir = toFile . getFileStore ( new Path ( fromFile . getName ( ) ) ) ; IFileStore [ ] files = EFSUtils . getFiles ( toFile , null ) ; for ( IFileStore target : files ) { if ( target . fetchInfo ( ) . isDirectory ( ) && target . getName ( ) . equals ( fromFile . getName ( ) ) ) { dirExists = true ; break ; } } if ( ! dirExists ) { toDir . mkdir ( EFS . NONE , null ) ; if ( to instanceof IContainer ) { try { ( ( IContainer ) to ) . refreshLocal ( IResource . DEPTH_INFINITE , null ) ; } catch ( CoreException e ) { } } } IConnectionPoint fromManager = ( IConnectionPoint ) fromPoint ; IConnectionPoint toManager = ( IConnectionPoint ) toPoint ; if ( fromManager != null && toManager != null ) { Synchronizer syncer = new Synchronizer ( ) ; syncer . setLogger ( logger ) ; syncer . setServerFileManager ( toManager ) ; syncer . setClientFileManager ( fromManager ) ; VirtualFileSyncPair [ ] pairs = syncer . getSyncItems ( fromPoint , toPoint , fromFile , toDir , monitor ) ; for ( VirtualFileSyncPair vfsPair : pairs ) { if ( vfsPair . getSyncState ( ) != SyncState . ClientItemOnly ) { vfsPair . setSyncState ( SyncState . ClientItemIsNewer ) ; } SyncPair syncPair = new SyncPair ( vfsPair ) ; syncPair . fromEndpoint = fromEnd ; syncPair . fromFolder = fromFolder ; syncPair . toEndpoint = toEnd ; syncPair . toFolder = toFolder ; syncPair . status = SyncModel . WAITING ; syncPair . destManager = toManager ; syncPair . sourceManager = fromManager ; synchronized ( items ) { items . add ( syncPair ) ; lastAdded = syncPair ; fireChange ( ) ; items . notify ( ) ; } } } } catch ( IOException e ) { log ( StringUtils . format ( Messages . Synchronizer_Error , e . getLocalizedMessage ( ) ) ) ; } catch ( CoreException e ) { log ( StringUtils . format ( Messages . Synchronizer_Error , e . getLocalizedMessage ( ) ) ) ; } } else { toFile = toFile . getFileStore ( new Path ( fromFile . getName ( ) ) ) ; VirtualFileSyncPair vfsPair = new VirtualFileSyncPair ( fromFile , toFile , "" , USE_STREAM ) ; SyncPair syncPair = new SyncPair ( vfsPair ) ; syncPair . fromEndpoint = fromEnd ; syncPair . fromFolder = fromFolder ; syncPair . toEndpoint = toEnd ; syncPair . toFolder = toFolder ; syncPair . status = SyncModel . WAITING ; syncPair . destManager = toPoint ; syncPair . sourceManager = fromPoint ; synchronized ( items ) { items . add ( syncPair ) ; lastAdded = syncPair ; fireChange ( ) ; items . notify ( ) ; } } } } if ( monitor == null || ! monitor . isCanceled ( ) ) { this . schedule ( ) ; } return Status . OK_STATUS ; } } ; buildJob . setPriority ( Job . BUILD ) ; buildJob . setSystem ( true ) ; buildJob . schedule ( ) ; syncJob = new Job ( "Running Sync jobs" ) { protected IStatus run ( IProgressMonitor monitor ) { synchronized ( items ) { while ( items . isEmpty ( ) ) { try { items . wait ( ) ; } catch ( InterruptedException e ) { } if ( monitor != null && monitor . isCanceled ( ) ) { return Status . CANCEL_STATUS ; } } if ( items . size ( ) > 0 ) { SyncPair pair = items . remove ( 0 ) ; currentSync = pair ; currentSync . status = SyncModel . RUNNING ; fireChange ( ) ; if ( pair . getSyncState ( ) == USE_STREAM ) { try { log ( FileUtils . NEW_LINE + StringUtils . format ( Messages . Synchronizer_Uploading , EFSUtils . getAbsolutePath ( pair . getSourceFile ( ) ) ) ) ; if ( ! pair . getDestinationFile ( ) . equals ( pair . getSourceFile ( ) ) ) { pair . getSourceFile ( ) . copy ( pair . getDestinationFile ( ) , EFS . OVERWRITE , null ) ; try { EFSUtils . setModificationTime ( pair . getSourceFileInfo ( ) . getLastModified ( ) , pair . getDestinationFile ( ) ) ; } catch ( Exception e ) { } } log ( Messages . Synchronizer_Success ) ; pair . status = SyncModel . SUCCESS ; lastSync = pair ; fireChange ( ) ; } catch ( Exception e ) { log ( StringUtils . format ( Messages . Synchronizer_Error , e . getLocalizedMessage ( ) ) ) ; pair . status = SyncModel . FAILURE ; lastSync = pair ; fireChange ( ) ; } } else { Synchronizer syncer = new Synchronizer ( ) ; syncer . setLogger ( logger ) ; try { syncer . setClientFileManager ( pair . sourceManager ) ; syncer . setServerFileManager ( pair . destManager ) ; syncer . uploadAndDelete ( new VirtualFileSyncPair [ ] { pair } , null ) ; pair . status = SyncModel . SUCCESS ; lastSync = pair ; fireChange ( ) ; } catch ( Exception e ) { log ( StringUtils . format ( Messages . Synchronizer_Error , e . getLocalizedMessage ( ) ) ) ; pair . status = SyncModel . FAILURE ; lastSync = pair ; fireChange ( ) ; } } } } if ( monitor == null || ! monitor . isCanceled ( ) ) { this . schedule ( ) ; } return Status . OK_STATUS ; } } ; syncJob . setPriority ( Job . BUILD ) ; syncJob . setSystem ( true ) ; syncJob . schedule ( ) ; } public void dispose ( ) { synchronized ( items ) { syncJob . cancel ( ) ; items . notify ( ) ; } synchronized ( toBeProcessed ) { buildJob . cancel ( ) ; toBeProcessed . notify ( ) ; } } private synchronized void log ( String message ) { if ( this . logger != null ) { this . logger . logInfo ( message ) ; } } public void addSyncing ( Object from , Object to ) { synchronized ( toBeProcessed ) { toBeProcessed . add ( new Pair ( from , to ) ) ; toBeProcessed . notify ( ) ; } } public SyncPair [ ] getItems ( ) { return this . items . toArray ( new SyncPair [ 0 ] ) ; } public SyncPair getLastSync ( ) { return this . lastSync ; } public SyncPair getLastAdded ( ) { return this . lastAdded ; } public SyncPair getCurrentSync ( ) { return this . currentSync ; } public ILogger getLogger ( ) { return this . logger ; } public synchronized void setLogger ( ILogger logger ) { this . logger = logger ; } } 
=======
public class StadiumNamesResult extends LiteralArrayVector { protected String getItemDescriptor ( ) { return "string" ; } protected Class getElementClass ( ) { return PropertyInfo . STRING_CLASS ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
