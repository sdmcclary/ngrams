<<<<<<< HEAD
class CollectionLoader { private static final Logger LOG = Logger . getLogger ( CollectionLoader . class . getName ( ) ) ; public static void load ( CollectionFolder collection , URL indexURL , boolean loadReadingLists , boolean skipLevel , IProgressListener listener ) { String error = null ; if ( listener != null ) listener . started ( ) ; try { Document doc = parseDocument ( indexURL ) ; if ( listener != null ) listener . progress ( 50 ) ; if ( ! isValid ( doc ) ) { throw new LoaderException ( Strings . error ( "failed.to.load.the.collection" ) ) ; } else { processCollection ( collection , doc , loadReadingLists , skipLevel , indexURL , listener ) ; } if ( listener != null ) listener . progress ( 100 ) ; } catch ( LoaderException e ) { error = e . getMessage ( ) ; } finally { if ( listener != null ) listener . finished ( error ) ; } } private static void processCollection ( CollectionFolder col , Document doc , boolean loadReadingLists , boolean skipLevel , URL baseURL , IProgressListener listener ) { Element root = doc . getRootElement ( ) ; Namespace bbNS = root . getNamespace ( FormatConstants . BB_NS_PREFIX ) ; Element body = root . getChild ( "body" ) ; loadToNode ( col , bbNS , body , loadReadingLists , skipLevel , baseURL , listener ) ; } private static void loadToNode ( CollectionFolder node , Namespace bbNS , Element element , boolean loadReadingLists , boolean skipLevel , URL baseURL , IProgressListener listener ) { List outlines = element . getChildren ( "outline" ) ; for ( int i = 0 ; i < outlines . size ( ) ; i ++ ) { Element outline = ( Element ) outlines . get ( i ) ; Transformation . lowercaseAttributes ( outline ) ; String tagsS = bbNS == null ? outline . getAttributeValue ( "tags" ) : outline . getAttributeValue ( "tags" , bbNS ) ; String [ ] tags = new String [ 0 ] ; if ( ! StringUtils . isEmpty ( tagsS ) ) tags = StringUtils . split ( tagsS , "," ) ; String type = outline . getAttributeValue ( "type" ) ; String title = outline . getAttributeValue ( "title" ) ; String text = outline . getAttributeValue ( "text" ) ; String htmlURL = outline . getAttributeValue ( "htmlurl" ) ; String xmlURLS = outline . getAttributeValue ( "xmlurl" ) ; if ( xmlURLS == null ) xmlURLS = outline . getAttributeValue ( "url" ) ; URL xmlURL = null ; try { if ( xmlURLS != null ) xmlURL = new URL ( baseURL , xmlURLS ) ; } catch ( MalformedURLException e ) { LOG . log ( Level . WARNING , MessageFormat . format ( Strings . error ( "invalid.url" ) , new Object [ ] { xmlURL } ) , e ) ; } if ( title == null ) title = text ; if ( title == null ) continue ; if ( type == null ) { handleFolder ( node , outline , bbNS , baseURL , title , text , tags , htmlURL , xmlURLS , xmlURL , loadReadingLists , skipLevel , listener ) ; } else if ( "list" . equals ( type ) ) { } else if ( "link" . equals ( type ) ) { if ( xmlURL != null && ( xmlURLS . endsWith ( ".opml" ) || xmlURL . getPath ( ) . endsWith ( ".opml" ) ) ) { handleFolder ( node , outline , bbNS , baseURL , title , text , tags , htmlURL , xmlURLS , xmlURL , loadReadingLists , skipLevel , listener ) ; } } else if ( "rss" . equals ( type ) && xmlURL != null && ! loadReadingLists ) { CollectionItem feed = new CollectionItem ( title , text , tags , htmlURL , xmlURLS ) ; node . addNode ( feed ) ; } } CollectionFolder fldr = hasDuplicateLevelFolder ( node ) ; if ( fldr != null ) { node . nodes . clear ( ) ; Iterator en = fldr . nodes . iterator ( ) ; while ( en . hasNext ( ) ) node . addNode ( ( CollectionNode ) en . next ( ) ) ; } } private static CollectionFolder hasDuplicateLevelFolder ( CollectionFolder node ) { CollectionFolder theOnlyFolder = null ; if ( node instanceof LazyCollectionFolder ) { LazyCollectionFolder lcf = ( LazyCollectionFolder ) node ; if ( lcf . getChildCountNoCheck ( ) == 1 && lcf . getChildAtNoCheck ( 0 ) instanceof CollectionFolder ) { theOnlyFolder = ( CollectionFolder ) lcf . getChildAtNoCheck ( 0 ) ; } } else if ( node . getChildCount ( ) == 1 && node . getChildAt ( 0 ) instanceof CollectionFolder ) { theOnlyFolder = ( CollectionFolder ) node . getChildAt ( 0 ) ; } return theOnlyFolder != null && node . getTitle ( ) != null && node . getTitle ( ) . equals ( theOnlyFolder . getTitle ( ) ) ? theOnlyFolder : null ; } private static void handleFolder ( CollectionFolder node , Element outline , Namespace bbNS , URL baseURL , String title , String text , String [ ] tags , String htmlURL , String xmlURLS , URL xmlURL , boolean loadReadingLists , boolean skipLevel , IProgressListener listener ) { if ( xmlURL != null ) { if ( loadReadingLists && ( ! skipLevel || ! ( node instanceof Collection ) ) ) { CollectionItem rl = new CollectionItem ( title , text , tags , htmlURL , xmlURLS ) ; node . addNode ( rl ) ; } else { node . addNode ( new LazyCollectionFolder ( title , text , tags , xmlURL , loadReadingLists ) ) ; } } else { CollectionFolder outlineFolder = new CollectionFolder ( title , text , tags ) ; loadToNode ( outlineFolder , bbNS , outline , loadReadingLists , false , baseURL , listener ) ; if ( outlineFolder . getChildCount ( ) > 0 ) node . addNode ( outlineFolder ) ; } } private static class LazyCollectionFolder extends CollectionFolder { private URL xmlURL ; private boolean loaded ; private boolean loadReadingLists ; public LazyCollectionFolder ( String title , String description , String [ ] tags , URL xmlURL , boolean loadReadingLists ) { super ( title , description , tags ) ; this . xmlURL = xmlURL ; this . loadReadingLists = loadReadingLists ; loaded = false ; } private synchronized void loadItems ( ) { if ( ! loaded ) { loadSubCollection ( this , xmlURL , loadReadingLists ) ; loaded = true ; } } public int getChildCount ( ) { loadItems ( ) ; return super . getChildCount ( ) ; } public TreeNode getChildAt ( int childIndex ) { loadItems ( ) ; return super . getChildAt ( childIndex ) ; } public int getIndex ( TreeNode node ) { loadItems ( ) ; return super . getIndex ( node ) ; } public boolean isLeaf ( ) { return loaded && super . isLeaf ( ) ; } int getChildCountNoCheck ( ) { return super . getChildCount ( ) ; } TreeNode getChildAtNoCheck ( int i ) { return super . getChildAt ( i ) ; } } private static void loadSubCollection ( CollectionFolder node , URL xmlURL , boolean loadReadingLists ) { load ( node , xmlURL , loadReadingLists , false , null ) ; } private static boolean isValid ( Document doc ) { Element root = doc . getRootElement ( ) ; if ( ! "opml" . equalsIgnoreCase ( root . getName ( ) ) ) return false ; Element body = root . getChild ( "body" ) ; return body != null ; } private static Document parseDocument ( URL url ) throws LoaderException { SAXBuilder builder = new SAXBuilder ( false ) ; builder . setEntityResolver ( EmptyEntityResolver . INSTANCE ) ; Document doc ; try { doc = builder . build ( XmlReaderFactory . create ( new URLInputStream ( url ) ) ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , MessageFormat . format ( Strings . error ( "there.was.a.problem.reading.a.collection.0" ) , new Object [ ] { url } ) , e ) ; throw new LoaderException ( Strings . error ( "there.was.a.problem.reading.a.collection" ) ) ; } return doc ; } private static class LoaderException extends Exception { public LoaderException ( String message ) { super ( message ) ; } } } 
=======
class RecoverAfterFunction extends AbstractPatternFunction < Pattern > { private final ValidatorPatternBuilder builder ; RecoverAfterFunction ( ValidatorPatternBuilder builder ) { this . builder = builder ; } public Pattern caseOther ( Pattern p ) { throw new RuntimeException ( "recover after botch" ) ; } public Pattern caseChoice ( ChoicePattern p ) { return builder . makeChoice ( p . getOperand1 ( ) . apply ( this ) , p . getOperand2 ( ) . apply ( this ) ) ; } public Pattern caseAfter ( AfterPattern p ) { return p . getOperand2 ( ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
