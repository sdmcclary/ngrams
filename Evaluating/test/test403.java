<<<<<<< HEAD
public class RekeyedRefTree extends AbstractMutableRefTree { private KeyMap map ; private RefTree ft ; private IdAddressableRefTree ift ; private MutableRefTree mft ; private Class LOCAL_KEY_CLASS = LocalKey . class ; private RekeyedRefTree ( RefTree frontTree , KeyMap map ) { this . map = map ; ft = frontTree ; ift = frontTree instanceof IdAddressableRefTree ? ( IdAddressableRefTree ) ft : null ; mft = frontTree instanceof MutableRefTree ? ( MutableRefTree ) ft : null ; } public static RefTree create ( RefTree frontTree , KeyMap map ) { return new RekeyedRefTree ( frontTree , map ) ; } public static IdAddressableRefTree create ( IdAddressableRefTree frontTree , KeyMap map ) { return new RekeyedRefTree ( frontTree , map ) ; } public static MutableRefTree create ( MutableRefTree frontTree , KeyMap map ) { return new RekeyedRefTree ( frontTree , map ) ; } @ Override public void delete ( Key id ) throws NodeNotFoundException { mft . delete ( getExistingLocal ( id ) ) ; } @ Override public Key insert ( Key parentId , long pos , Key newId , Object content ) throws NodeNotFoundException { assert ! ( content instanceof Reference ) : "ref insert not coded" ; Key lp = getExistingLocal ( parentId ) ; return LocalKey . create ( mft . insert ( lp , newId , content ) , ft ) ; } @ Override public Key move ( Key nodeId , Key parentId , long pos ) throws NodeNotFoundException { Key lp = getExistingLocal ( parentId ) ; Key ln = getExistingLocal ( nodeId ) ; return mft . move ( ln , lp , pos ) ; } @ Override public boolean update ( Key nodeId , Object content ) throws NodeNotFoundException { Key ln = getExistingLocal ( nodeId ) ; return mft . update ( ln , content ) ; } @ Override public RefTreeNode getNode ( Key id ) { return ift . getNode ( getRealKey ( id ) ) ; } public RefTreeNode getRoot ( ) { return wrap ( ft . getRoot ( ) ) ; } private Key getExistingLocal ( Key id ) throws NodeNotFoundException { Key local = getRealKey ( id ) ; if ( local == null || ! ift . contains ( id ) ) throw new NodeNotFoundException ( "Not found (front key=" + local + ")" , id ) ; return local ; } private Key getRealKey ( Key id ) { if ( id == null ) return null ; if ( LOCAL_KEY_CLASS == id . getClass ( ) ) { if ( ( ( LocalKey ) id ) . inScope ( ft ) ) return id ; } return map . getFrontKey ( id ) ; } private RefTreeNode wrap ( RefTreeNode n ) { return n == null ? null : new RekeyNode ( n ) ; } private class RekeyNode implements RefTreeNode { RefTreeNode n ; Key cachedKey ; public RekeyNode ( RefTreeNode n ) { this . n = n ; } public Key getId ( ) { if ( cachedKey == null ) { Key bk = n . isReference ( ) ? n . getReference ( ) . getTarget ( ) : map . getBackKey ( n . getId ( ) ) ; cachedKey = bk == null ? LocalKey . create ( n . getId ( ) , ft ) : bk ; } return cachedKey ; } public RefTreeNode getParent ( ) { return wrap ( n . getParent ( ) ) ; } public Object getContent ( ) { return n . getContent ( ) ; } public Iterator getChildIterator ( ) { final Iterator i = n . getChildIterator ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return i . hasNext ( ) ; } public Object next ( ) { return wrap ( ( RefTreeNode ) i . next ( ) ) ; } public void remove ( ) { i . remove ( ) ; } } ; } public Reference getReference ( ) { return n . getReference ( ) ; } public boolean isReference ( ) { return n . isReference ( ) ; } public boolean isTreeRef ( ) { return n . isTreeRef ( ) ; } public boolean isNodeRef ( ) { return n . isNodeRef ( ) ; } } private static class LocalKey implements Key { Key key ; RefTree scope ; public static LocalKey create ( Key k , RefTree scope ) { assert scope != null ; if ( k == null ) return null ; else return new LocalKey ( k , scope ) ; } public LocalKey ( Key k , RefTree scope ) { this . key = k ; this . scope = scope ; } @ Override public boolean equals ( Object o ) { return o instanceof LocalKey && o != null && Util . equals ( scope , ( ( LocalKey ) o ) . scope ) && Util . equals ( key , ( ( LocalKey ) o ) . key ) ; } @ Override public int hashCode ( ) { return key . hashCode ( ) ^ scope . hashCode ( ) ; } @ Override public String toString ( ) { return "LK(" + key . toString ( ) + "," + System . identityHashCode ( scope ) + ")" ; } public Key getKey ( ) { return key ; } public RefTree getScope ( ) { return scope ; } public boolean inScope ( RefTree t ) { return scope == t ; } } public static class RemapRefsTree implements RefTree { private RefTree t ; private KeyMap map ; public RemapRefsTree ( RefTree t , KeyMap map ) { this . t = t ; this . map = map ; } public RefTreeNode getRoot ( ) { return wrap ( t . getRoot ( ) ) ; } private RefTreeNode wrap ( RefTreeNode n ) { return n == null ? null : new ReRefNode ( n ) ; } private class ReRefNode implements RefTreeNode { private RefTreeNode n ; public ReRefNode ( RefTreeNode n ) { this . n = n ; } public Iterator getChildIterator ( ) { final Iterator i = n . getChildIterator ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return i . hasNext ( ) ; } public Object next ( ) { return wrap ( ( RefTreeNode ) i . next ( ) ) ; } public void remove ( ) { i . remove ( ) ; } } ; } public Object getContent ( ) { return n . getContent ( ) ; } public Key getId ( ) { return n . getId ( ) ; } public RefTreeNode getParent ( ) { return wrap ( n . getParent ( ) ) ; } public Reference getReference ( ) { Reference r = n . getReference ( ) ; if ( r == null ) return null ; if ( r . isTreeReference ( ) ) { return new TreeReference ( map . getFrontKey ( r . getTarget ( ) ) ) ; } else return new NodeReference ( map . getFrontKey ( r . getTarget ( ) ) ) ; } public boolean isNodeRef ( ) { return n . isNodeRef ( ) ; } public boolean isReference ( ) { return n . isReference ( ) ; } public boolean isTreeRef ( ) { return n . isTreeRef ( ) ; } } } } 
=======
public interface DatatypeLibraryFactory { DatatypeLibrary createDatatypeLibrary ( String namespaceURI ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
