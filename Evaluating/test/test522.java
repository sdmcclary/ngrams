public class NameMatcher { protected final String TAG = "NameMatcher" ; protected final String mBadChars = "ŠŚŞŹŽŻşšśžźżŸĄÀÁÂÃÄÅÇĆÈÉÊËĘÌÍÎÏİÐĞŁŃÑÖÒÓÔÕÖÙÚÛÜÝąàáâãäåçćèéêëęìíîïıðğłñńòóôõöùúûüýÿ" ; protected final String mGoodChars = "SSSZZZssszzzYAAAAAAACCEEEEEIIIIIDGLNNOOOOOOUUUUYaaaaaaacceeeeeiiiiidglnnooooouuuuyy " ; private final TreeMap < String , ArrayList < PhoneContact > > mFirstNames = new TreeMap < String , ArrayList < PhoneContact > > ( ) ; ; private final TreeMap < String , ArrayList < PhoneContact > > mLastNames = new TreeMap < String , ArrayList < PhoneContact > > ( ) ; private final HashMap < Object , ArrayList < PhoneContact > > mNickNames = new HashMap < Object , ArrayList < PhoneContact > > ( ) ; ; private final HashMap < String , Object > mDiminutives = new HashMap < String , Object > ( ) ; protected final WeakReference < Context > mContext ; public NameMatcher ( Context context , InputStream diminutives , boolean withPhone ) throws Exception { mContext = new WeakReference < Context > ( context ) ; loadDiminutives ( diminutives ) ; loadPhoneContacts ( withPhone ) ; } protected PhoneContact createFromCursor ( Cursor cursor ) { if ( cursor == null || cursor . isClosed ( ) ) { return null ; } String id = cursor . getString ( cursor . getColumnIndex ( People . _ID ) ) ; String name = cursor . getString ( cursor . getColumnIndex ( People . NAME ) ) ; if ( Log . debug ) Log . d ( TAG , "NameMatcher is processing contact " + name ) ; return new PhoneContact ( id , name ) ; } protected void loadPhoneContacts ( boolean withPhone ) { Cursor cursor = doQuery ( withPhone ) ; if ( cursor == null ) { return ; } while ( cursor . moveToNext ( ) ) { PhoneContact contact = createFromCursor ( cursor ) ; if ( contact == null ) { continue ; } String name = normalizeName ( contact . name ) ; if ( name == null ) { continue ; } String [ ] components = name . split ( " " ) ; String fname = components [ 0 ] ; String lname = components [ components . length - 1 ] ; if ( mFirstNames . get ( fname ) == null ) mFirstNames . put ( fname , new ArrayList < PhoneContact > ( 3 ) ) ; mFirstNames . get ( fname ) . add ( contact ) ; if ( Log . debug ) Log . d ( TAG , "added " + fname + " to mFirstNames = " + contact . name ) ; if ( mLastNames . get ( lname ) == null ) mLastNames . put ( lname , new ArrayList < PhoneContact > ( 3 ) ) ; mLastNames . get ( lname ) . add ( contact ) ; Object sentinel = mDiminutives . get ( fname ) ; if ( sentinel != null ) { if ( mNickNames . get ( sentinel ) == null ) { mNickNames . put ( sentinel , new ArrayList < PhoneContact > ( 3 ) ) ; } if ( Log . debug ) Log . d ( TAG , "linking " + sentinel + " with " + contact . name ) ; mNickNames . get ( sentinel ) . add ( contact ) ; } } cursor . close ( ) ; } protected Cursor doQuery ( boolean withPhone ) { Context context = mContext . get ( ) ; if ( context == null ) { return null ; } String where = "" ; if ( withPhone ) { where = People . PRIMARY_PHONE_ID + " IS NOT NULL" ; } return context . getContentResolver ( ) . query ( People . CONTENT_URI , new String [ ] { People . _ID , People . NAME , People . PRIMARY_PHONE_ID } , where , null , null ) ; } public void destroy ( ) { if ( mFirstNames != null ) { mFirstNames . clear ( ) ; } if ( mLastNames != null ) { mLastNames . clear ( ) ; } if ( mNickNames != null ) { mNickNames . clear ( ) ; } if ( mDiminutives != null ) { mDiminutives . clear ( ) ; } } public void dump ( ) { for ( String name : mFirstNames . keySet ( ) ) { if ( Log . debug ) Log . d ( TAG , String . format ( "First name:%s" , name ) ) ; for ( PhoneContact c : mFirstNames . get ( name ) ) { if ( Log . debug ) Log . d ( TAG , String . format ( "Phone Contact:%s" , c . name ) ) ; } } for ( String name : mLastNames . keySet ( ) ) { if ( Log . debug ) Log . d ( TAG , String . format ( "Last name:%s" , name ) ) ; for ( PhoneContact c : mLastNames . get ( name ) ) { if ( Log . debug ) Log . d ( TAG , String . format ( "Phone Contact:%s" , c . name ) ) ; } } for ( Object o : mNickNames . keySet ( ) ) { if ( Log . debug ) Log . d ( TAG , String . format ( "Nick name:%s" , o ) ) ; for ( PhoneContact c : mNickNames . get ( o ) ) { if ( Log . debug ) Log . d ( TAG , String . format ( "Phone Contact:%s" , c . name ) ) ; } } } private void loadDiminutives ( InputStream diminutivesFile ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( diminutivesFile , "UTF-8" ) , 8 * 1024 ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { Object sentinel = null ; String [ ] names = line . split ( "," ) ; for ( int i = 0 ; i < names . length ; i ++ ) { Object o = mDiminutives . get ( names [ i ] ) ; if ( o != null ) { sentinel = o ; break ; } } if ( sentinel != null ) { } else { sentinel = new Object ( ) ; } for ( int i = 0 ; i < names . length ; i ++ ) { Object existingSentinel = mDiminutives . get ( names [ i ] ) ; if ( existingSentinel != null && existingSentinel != sentinel ) { if ( Log . debug ) Log . d ( TAG , "THREE LINE CONFLICT  " + sentinel + " " + mDiminutives . get ( names [ i ] ) ) ; } else { mDiminutives . put ( names [ i ] , sentinel ) ; } } } if ( false ) { for ( String s : mDiminutives . keySet ( ) ) System . out . println ( mDiminutives . get ( s ) + " " + s ) ; } } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; throw new Error ( e ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new Error ( e ) ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch ( IOException e ) { } } } private String normalizeName ( String name ) { name = GreekTranscribe . string ( name ) ; if ( name == null ) { return null ; } StringBuffer newName = new StringBuffer ( name . toLowerCase ( ) . trim ( ) ) ; int bracket = 0 ; int newNameLength = newName . length ( ) ; for ( int i = 0 ; i < newNameLength ; i ++ ) { char c = newName . charAt ( i ) ; int badIndex = mBadChars . indexOf ( c ) ; if ( badIndex > - 1 ) newName . setCharAt ( i , mGoodChars . charAt ( badIndex ) ) ; if ( c == '(' ) bracket ++ ; if ( bracket > 0 || ( i == newNameLength - 1 && c == '-' ) || ( c == ' ' && i == 0 ) || ( c == ' ' && i > 0 && newName . charAt ( i - 1 ) == ' ' ) ) { if ( c == ')' ) bracket -- ; newName . deleteCharAt ( i ) ; newNameLength -- ; i -- ; continue ; } } return newName . toString ( ) ; } private String [ ] reverse ( String [ ] components ) { String [ ] reversedComponents = new String [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) reversedComponents [ i ] = components [ components . length - 1 - i ] ; return reversedComponents ; } public final PhoneContact exactMatch ( String name ) { return exactMatch ( name , false ) ; } private PhoneContact exactMatch ( String name , boolean reverse ) { if ( name == null ) { return null ; } String [ ] components = normalizeName ( name ) . split ( " " ) ; if ( reverse ) { components = reverse ( components ) ; } ArrayList < PhoneContact > possibilities = mFirstNames . get ( components [ 0 ] ) ; if ( possibilities != null ) { if ( Log . debug ) Log . d ( TAG , "prefix match from " + components [ 0 ] + " to " ) ; for ( PhoneContact u : possibilities ) { if ( Log . debug ) Log . d ( TAG , "   " + u . name ) ; String [ ] matchParts = normalizeName ( u . name ) . split ( " " ) ; String lname = matchParts [ matchParts . length - 1 ] ; if ( lname != null && lname . equals ( components [ components . length - 1 ] ) ) { return u ; } } } if ( ! reverse ) { return exactMatch ( name , true ) ; } return null ; } public final PhoneContact match ( String name , boolean firstNameOnlyMatches ) { return match ( name , firstNameOnlyMatches , false ) ; } private PhoneContact match ( String name , boolean firstNameOnlyMatches , boolean reverse ) { if ( name == null ) { return null ; } String [ ] components = normalizeName ( name ) . split ( " " ) ; if ( reverse ) { components = reverse ( components ) ; } if ( Log . debug ) Log . d ( TAG , "Trying to match: " + Utils . join ( components , ' ' ) ) ; TreeSet < PhoneContact > possibilities = new TreeSet < PhoneContact > ( prefixMatch ( components [ 0 ] , mFirstNames ) ) ; if ( possibilities . size ( ) > 0 ) { if ( Log . debug ) Log . d ( TAG , "prefix match from " + components [ 0 ] + " to " ) ; for ( PhoneContact u : possibilities ) if ( Log . debug ) Log . d ( TAG , "   " + u . name ) ; } ArrayList < PhoneContact > matches = nicknameMatch ( components [ 0 ] ) ; if ( matches != null ) { if ( matches . size ( ) > 1 ) { if ( Log . debug ) Log . d ( TAG , "multiple nickname matches:" ) ; for ( PhoneContact temp : matches ) if ( Log . debug ) Log . d ( TAG , "   " + temp . name ) ; } else if ( matches . size ( ) == 1 ) { if ( Log . debug ) Log . d ( TAG , "nickname matched " + components [ 0 ] + " to " + matches . get ( 0 ) . name ) ; } possibilities . addAll ( matches ) ; } else if ( Log . debug ) Log . d ( TAG , "no nickname matches" ) ; if ( possibilities . size ( ) > 0 ) { if ( components . length > 1 ) { for ( PhoneContact possibility : possibilities ) { String [ ] matchParts = normalizeName ( possibility . name ) . split ( " " ) ; String lname = matchParts [ matchParts . length - 1 ] ; if ( lname . startsWith ( components [ components . length - 1 ] ) || components [ components . length - 1 ] . startsWith ( lname ) ) { if ( Log . debug ) Log . d ( TAG , "matched " + name + " to " + possibility . name ) ; return possibility ; } } if ( Log . debug ) Log . d ( TAG , "all inexact first name matches violated last name constraints" ) ; } if ( firstNameOnlyMatches ) { if ( possibilities . size ( ) == 1 ) { PhoneContact answer = possibilities . iterator ( ) . next ( ) ; if ( getWordCount ( answer . name ) == 1 ) { if ( Log . debug ) Log . d ( TAG , "only one possibility, matched " + name + " to " + answer . name ) ; return answer ; } } else { ArrayList < PhoneContact > exactMatches ; exactMatches = mFirstNames . get ( components [ 0 ] ) ; if ( exactMatches != null && exactMatches . size ( ) == 1 && getWordCount ( exactMatches . get ( 0 ) . name ) == 1 ) { if ( Log . debug ) Log . d ( TAG , "exact first name match " + components [ 0 ] + " to " + exactMatches . get ( 0 ) . name ) ; return exactMatches . get ( 0 ) ; } if ( Log . debug ) Log . d ( TAG , "first name matched multiple people and there is no disambiguating last name" ) ; } } } if ( components . length == 1 ) { ArrayList < PhoneContact > users = mLastNames . get ( components [ 0 ] ) ; if ( users != null && users . size ( ) == 1 ) { if ( Log . debug ) Log . d ( TAG , "exact last name match: " + users . get ( 0 ) . name ) ; return users . get ( 0 ) ; } } else if ( ! reverse ) { return match ( name , firstNameOnlyMatches , true ) ; } if ( Log . debug ) Log . d ( TAG , "No match found for " + name ) ; return null ; } private ArrayList < PhoneContact > nicknameMatch ( String nickname ) { if ( nickname == null ) { return null ; } Object sentinel = mDiminutives . get ( nickname ) ; if ( sentinel == null ) return null ; return mNickNames . get ( sentinel ) ; } private ArrayList < PhoneContact > prefixMatch ( String part , TreeMap < String , ArrayList < PhoneContact > > map ) { ArrayList < PhoneContact > results = new ArrayList < PhoneContact > ( 3 ) ; if ( map == null || part == null || part . length ( ) == 0 ) { return results ; } String startKey = part ; StringBuffer endKey = new StringBuffer ( startKey ) ; endKey . setCharAt ( startKey . length ( ) - 1 , ( char ) ( startKey . charAt ( startKey . length ( ) - 1 ) + 1 ) ) ; SortedMap < String , ArrayList < PhoneContact > > selection = map . subMap ( startKey , endKey . toString ( ) ) ; for ( String s : selection . keySet ( ) ) { if ( s . startsWith ( part ) ) { results . addAll ( selection . get ( s ) ) ; } else { if ( Log . debug ) Log . d ( TAG , "unexpected: " + s + ", " + part ) ; } } return results ; } private int getWordCount ( String phrase ) { if ( phrase == null ) { return 0 ; } return phrase . split ( " " ) . length ; } } 