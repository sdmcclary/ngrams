public class XasExtUtil { private static DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; private XasExtUtil ( ) { } private static String searchPrefix ( String namespace , Stack nss ) { for ( int i = nss . size ( ) - 1 ; i >= 0 ; i -- ) { EventList el = ( EventList ) nss . elementAt ( i ) ; for ( int j = 0 ; j < el . size ( ) ; j ++ ) { Event ev = el . get ( j ) ; if ( Util . equals ( namespace , ev . getNamespace ( ) ) ) { return ( String ) ev . getValue ( ) ; } } } return null ; } private static Node readerToDom ( Document doc , XmlReader xr , Stack nss ) { Node result = null ; Event ev = xr . getCurrentEvent ( ) ; EventList pms = new EventList ( ) ; switch ( ev . getType ( ) ) { case Event . START_DOCUMENT : { xr . advance ( ) ; Node node ; while ( ( node = readerToDom ( doc , xr ) ) != null ) { doc . appendChild ( node ) ; } result = doc ; break ; } case Event . END_DOCUMENT : xr . advance ( ) ; break ; case Event . NAMESPACE_PREFIX : do { pms . add ( xr . advance ( ) ) ; } while ( ( ev = xr . getCurrentEvent ( ) ) . getType ( ) == Event . NAMESPACE_PREFIX ) ; case Event . START_ELEMENT : { nss . push ( pms ) ; String ns = ev . getNamespace ( ) ; String name = ev . getName ( ) ; String prefix = searchPrefix ( ns , nss ) ; if ( prefix != null ) { name = prefix + ":" + name ; } Element elem = doc . createElementNS ( ns , name ) ; for ( Enumeration e = pms . events ( ) ; e . hasMoreElements ( ) ; ) { ev = ( Event ) e . nextElement ( ) ; elem . setAttributeNS ( "http://www.w3.org/2000/xmlns/" , "xmlns:" + ev . getValue ( ) , ev . getNamespace ( ) ) ; } xr . advance ( ) ; while ( ( ev = xr . getCurrentEvent ( ) ) . getType ( ) == Event . ATTRIBUTE ) { ns = ev . getNamespace ( ) ; name = ev . getName ( ) ; prefix = searchPrefix ( ns , nss ) ; if ( prefix != null ) { name = prefix + ":" + name ; } elem . setAttributeNS ( ns , name , ( String ) ev . getValue ( ) ) ; xr . advance ( ) ; } Node node ; while ( ( node = readerToDom ( doc , xr , nss ) ) != null ) { elem . appendChild ( node ) ; } nss . pop ( ) ; result = elem ; break ; } case Event . END_ELEMENT : xr . advance ( ) ; break ; case Event . CONTENT : result = doc . createTextNode ( ( String ) ev . getValue ( ) ) ; xr . advance ( ) ; break ; case Event . COMMENT : result = doc . createComment ( ( String ) ev . getValue ( ) ) ; xr . advance ( ) ; break ; case Event . PROCESSING_INSTRUCTION : { String target = ( String ) ev . getValue ( ) ; String data = null ; int i = target . indexOf ( ' ' ) ; if ( i >= 0 ) { data = target . substring ( i + 1 ) ; target = target . substring ( 0 , i ) ; } result = doc . createProcessingInstruction ( target , data ) ; xr . advance ( ) ; break ; } case Event . ENTITY_REFERENCE : result = doc . createEntityReference ( ev . getName ( ) ) ; xr . advance ( ) ; break ; default : if ( ( ev . getType ( ) & Event . FLAG_BITMASK ) == Event . TYPE_EXTENSION_FLAG ) { EventSequence es = ( EventSequence ) ev . getValue ( ) ; if ( es != null ) { result = sequenceToDom ( doc , es ) ; } } else { throw new IllegalArgumentException ( "Unhandled event type: " + ev . getType ( ) ) ; } } return result ; } public static Document newDocument ( ) throws ParserConfigurationException { return dbf . newDocumentBuilder ( ) . newDocument ( ) ; } public static Node readerToDom ( Document doc , XmlReader xr ) { return readerToDom ( doc , xr , new Stack ( ) ) ; } public static Node sequenceToDom ( Document doc , EventSequence es ) { XmlReader reader = new XmlReader ( es ) ; return readerToDom ( doc , reader ) ; } public static EventSequence domToSequence ( Node n ) { EventList el = new EventList ( ) ; switch ( n . getNodeType ( ) ) { case Node . DOCUMENT_NODE : { el . add ( Event . createStartDocument ( ) ) ; NodeList nodes = n . getChildNodes ( ) ; if ( nodes != null ) { for ( int i = 0 ; i < nodes . getLength ( ) ; i ++ ) { el . addAll ( domToSequence ( nodes . item ( i ) ) ) ; } } el . add ( Event . createEndDocument ( ) ) ; break ; } case Node . ELEMENT_NODE : { EventList pms = new EventList ( ) ; EventList atts = new EventList ( ) ; NamedNodeMap attMap = n . getAttributes ( ) ; for ( int i = 0 ; i < attMap . getLength ( ) ; i ++ ) { Attr att = ( Attr ) attMap . item ( i ) ; String name = att . getNodeName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { pms . add ( Event . createNamespacePrefix ( att . getValue ( ) , name . substring ( 6 ) ) ) ; } else { atts . add ( Event . createAttribute ( att . getNamespaceURI ( ) , att . getLocalName ( ) , att . getValue ( ) ) ) ; } } el . addAll ( pms ) ; el . add ( Event . createStartElement ( n . getNamespaceURI ( ) , n . getLocalName ( ) ) ) ; el . addAll ( atts ) ; NodeList children = n . getChildNodes ( ) ; if ( children != null ) { for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { el . addAll ( domToSequence ( children . item ( i ) ) ) ; } } el . add ( Event . createEndElement ( n . getNamespaceURI ( ) , n . getLocalName ( ) ) ) ; break ; } case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : el . add ( Event . createContent ( n . getNodeValue ( ) ) ) ; break ; case Node . ENTITY_REFERENCE_NODE : el . add ( Event . createEntityReference ( n . getNodeName ( ) ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : el . add ( Event . createProcessingInstruction ( n . getNodeName ( ) + " " + n . getNodeValue ( ) ) ) ; break ; case Node . COMMENT_NODE : el . add ( Event . createComment ( n . getNodeValue ( ) ) ) ; break ; default : throw new IllegalArgumentException ( "Unhandled node type: " + n . getNodeType ( ) ) ; } return el ; } public static TypedXmlParser getParser ( InputStream in , String enc ) throws IOException { return getParser ( new XebuXmlIdentifier ( in ) , enc ) ; } public static TypedXmlParser getParser ( MagicInputStream in , String enc ) throws IOException { String type = in . getMimeType ( ) ; if ( type == null ) return null ; CodecFactory cf = CodecIndustry . getFactory ( type ) ; if ( cf == null ) return null ; TypedXmlParser p = cf . getNewDecoder ( new Object ( ) ) ; try { boolean isBinary = ! ( p instanceof DefaultXmlParser ) ; p . setInput ( in , isBinary ? p . getInputEncoding ( ) : enc ) ; } catch ( XmlPullParserException ex ) { IOException iox = new IOException ( "XmlPullParserException" ) ; iox . initCause ( ex ) ; throw iox ; } return p ; } public static TypedXmlSerializer getSerializer ( OutputStream out , String enc ) throws IOException { return getSerializer ( out , "application/x-ebu+item" , enc ) ; } public static TypedXmlSerializer getSerializer ( OutputStream out , String mimeType , String enc ) throws IOException { CodecFactory cf = CodecIndustry . getFactory ( mimeType ) ; if ( cf == null ) return null ; TypedXmlSerializer ser = cf . getNewEncoder ( new Object ( ) ) ; boolean isBinary = ! ( ser instanceof DefaultXmlSerializer ) ; ser . setOutput ( out , isBinary ? "ISO-8859-1" : enc ) ; if ( ! isBinary ) ser . setFeature ( "http://xmlpull.org/v1/doc/features.html#indent-output" , true ) ; return ser ; } public static class XebuXmlIdentifier extends MagicInputStream { public XebuXmlIdentifier ( InputStream in ) throws IOException { super ( in ) ; } @ Override protected String identify ( byte [ ] magic , int len ) { final String [ ] SUBTYPES = { "none" , "item" , null , "data" , "elem" , "elit" , null , "elid" } ; String ms = new String ( magic , 0 , len ) ; if ( len == 4 && ms . toLowerCase ( ) . startsWith ( "<?xm" ) ) return "text/xml" ; if ( len < 1 ) return null ; if ( ( magic [ 0 ] & XebuConstants . TOKEN_SPACE ) == XebuConstants . DOCUMENT ) { int subtype = ( ( magic [ 0 ] & XebuConstants . FLAG_SEQUENCE_CACHING ) != 0 ? 4 : 0 ) + ( ( magic [ 0 ] & XebuConstants . FLAG_CONTENT_CACHING ) != 0 ? 2 : 0 ) + ( ( magic [ 0 ] & XebuConstants . FLAG_ITEM_CACHING ) != 0 ? 1 : 0 ) ; return SUBTYPES [ subtype ] == null ? null : "application/x-ebu+" + SUBTYPES [ subtype ] ; } return null ; } } } 