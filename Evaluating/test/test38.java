public abstract class RGeomElem { public static final int SHAPE = 0 ; public static final int SUBSHAPE = 1 ; public static final int COMMAND = 2 ; public static final int POLYGON = 3 ; public static final int CONTOUR = 4 ; public static final int MESH = 5 ; public static final int TRISTRIP = 6 ; public static final int GROUP = 7 ; public static final int UNKNOWN = 8 ; public float width ; public float height ; float origWidth ; float origHeight ; public abstract void draw ( PGraphics g ) ; public abstract void draw ( PApplet g ) ; public void draw ( ) { this . draw ( RG . parent ( ) ) ; } public abstract RPoint getPoint ( float t ) ; public abstract RPoint getTangent ( float t ) ; public abstract RPoint [ ] getHandles ( ) ; public abstract RPoint [ ] getPoints ( ) ; public abstract RPoint [ ] getTangents ( ) ; public abstract RPoint [ ] [ ] getHandlesInPaths ( ) ; public abstract RPoint [ ] [ ] getPointsInPaths ( ) ; public abstract RPoint [ ] [ ] getTangentsInPaths ( ) ; public abstract boolean contains ( RPoint p ) ; public boolean contains ( RGeomElem shp ) { return contains ( shp . getPoints ( ) ) ; } public boolean containsBounds ( RGeomElem shp ) { RPoint tl = shp . getTopLeft ( ) ; RPoint tr = shp . getTopRight ( ) ; RPoint bl = shp . getBottomRight ( ) ; RPoint br = shp . getBottomLeft ( ) ; if ( this . contains ( tl ) && this . contains ( tr ) && this . contains ( bl ) && this . contains ( br ) ) { return true ; } return false ; } public boolean containsHandles ( RGeomElem shp ) { return contains ( shp . getHandles ( ) ) ; } public boolean contains ( RPoint [ ] pts ) { if ( pts . length == 0 ) { return false ; } boolean inside = true ; for ( RPoint pt : pts ) { if ( ! contains ( pt ) ) { inside = false ; break ; } } return inside ; } public boolean intersects ( RGeomElem shp ) { return intersects ( shp . getPoints ( ) ) ; } public boolean intersectsBounds ( RGeomElem shp ) { RPoint tl = shp . getTopLeft ( ) ; RPoint tr = shp . getTopRight ( ) ; RPoint bl = shp . getBottomRight ( ) ; RPoint br = shp . getBottomLeft ( ) ; if ( this . contains ( tl ) || this . contains ( tr ) || this . contains ( bl ) || this . contains ( br ) ) { return true ; } return false ; } public boolean intersectsHandles ( RGeomElem shp ) { return intersects ( shp . getHandles ( ) ) ; } public boolean intersects ( RPoint [ ] ps ) { boolean intersects = false ; if ( ps != null ) { for ( int i = 0 ; i < ps . length ; i ++ ) { intersects |= this . contains ( ps [ i ] ) ; } } return intersects ; } public abstract int getType ( ) ; public abstract RShape toShape ( ) ; public void print ( ) { } ; protected float [ ] lenCurves ; protected float lenCurve = - 1F ; public String name = "" ; protected RStyle style = new RStyle ( ) ; public void setFill ( boolean _fill ) { style . setFill ( _fill ) ; } public void setFill ( int _fillColor ) { style . setFill ( _fillColor ) ; } public void setFill ( String str ) { style . setFill ( str ) ; } public void setStroke ( boolean _stroke ) { style . setStroke ( _stroke ) ; } public void setStroke ( int _strokeColor ) { style . setStroke ( _strokeColor ) ; } public void setStroke ( String str ) { style . setStroke ( str ) ; } public void setStrokeWeight ( float value ) { style . setStrokeWeight ( value ) ; } public void setStrokeWeight ( String str ) { style . setStrokeWeight ( str ) ; } public void setStrokeCap ( String str ) { style . setStrokeCap ( str ) ; } public void setStrokeJoin ( String str ) { style . setStrokeJoin ( str ) ; } public void setStrokeAlpha ( int opacity ) { style . setStrokeAlpha ( opacity ) ; } public void setStrokeAlpha ( String str ) { style . setStrokeAlpha ( str ) ; } public void setFillAlpha ( int opacity ) { style . setFillAlpha ( opacity ) ; } public void setFillAlpha ( String str ) { style . setFillAlpha ( str ) ; } public void setAlpha ( float opacity ) { style . setAlpha ( opacity ) ; } public void setAlpha ( int opacity ) { style . setAlpha ( opacity ) ; } public void setAlpha ( String str ) { style . setAlpha ( str ) ; } public RStyle getStyle ( ) { return this . style ; } protected void saveContext ( PGraphics g ) { style . saveContext ( g ) ; } protected void saveContext ( PApplet p ) { style . saveContext ( p ) ; } protected void saveContext ( ) { style . saveContext ( ) ; } protected void restoreContext ( PGraphics g ) { style . restoreContext ( g ) ; } protected void restoreContext ( PApplet p ) { style . restoreContext ( p ) ; } protected void restoreContext ( ) { style . restoreContext ( ) ; } protected void setContext ( PGraphics g ) { style . setContext ( g ) ; } protected void setContext ( PApplet p ) { style . setContext ( p ) ; } protected void setContext ( ) { style . setContext ( ) ; } public void setStyle ( RStyle s ) { style = s ; } protected void setStyle ( RGeomElem p ) { name = p . name ; width = p . width ; height = p . height ; origWidth = p . origWidth ; origHeight = p . origHeight ; style = new RStyle ( p . style ) ; } protected void setStyle ( String styleString ) { style . setStyle ( styleString ) ; } public void setName ( String str ) { this . name = str ; } protected void calculateCurveLengths ( ) { PApplet . println ( "Feature not yet implemented for this class." ) ; } public float [ ] getCurveLengths ( ) { if ( lenCurves == null ) { calculateCurveLengths ( ) ; } return lenCurves ; } public float getCurveLength ( ) { if ( lenCurve == - 1F ) { calculateCurveLengths ( ) ; } return lenCurve ; } public RPolygon toPolygon ( ) { return toShape ( ) . toPolygon ( ) ; } public RMesh toMesh ( ) { return toShape ( ) . toPolygon ( ) . toMesh ( ) ; } public void transform ( RMatrix m ) { RPoint [ ] ps = getHandles ( ) ; if ( ps == null ) return ; for ( int i = 0 ; i < ps . length ; i ++ ) { ps [ i ] . transform ( m ) ; } } public void transform ( float x , float y , float w , float h , boolean keepAspectRatio ) { RMatrix mtx = new RMatrix ( ) ; RRectangle orig = this . getBounds ( ) ; float orig_w = orig . getMaxX ( ) - orig . getMinX ( ) ; float orig_h = orig . getMaxY ( ) - orig . getMinY ( ) ; mtx . translate ( - orig . getMinX ( ) , - orig . getMinY ( ) ) ; if ( keepAspectRatio ) { mtx . scale ( Math . min ( w / orig_w , h / orig_h ) ) ; } else { mtx . scale ( w / orig_w , h / orig_h ) ; } mtx . translate ( x , y ) ; this . transform ( mtx ) ; return ; } public void transform ( float x , float y , float w , float h ) { this . transform ( x , y , w , h , true ) ; return ; } public RRectangle getBounds ( ) { float xmax = Float . NEGATIVE_INFINITY ; float ymax = Float . NEGATIVE_INFINITY ; float xmin = Float . POSITIVE_INFINITY ; float ymin = Float . POSITIVE_INFINITY ; RPoint [ ] points = getHandles ( ) ; if ( points != null ) { for ( int i = 0 ; i < points . length ; i ++ ) { float tempx = points [ i ] . x ; float tempy = points [ i ] . y ; if ( tempx < xmin ) { xmin = tempx ; } if ( tempx > xmax ) { xmax = tempx ; } if ( tempy < ymin ) { ymin = tempy ; } if ( tempy > ymax ) { ymax = tempy ; } } } RRectangle c = new RRectangle ( new RPoint ( xmin , ymin ) , new RPoint ( xmax , ymax ) ) ; return c ; } public RPoint [ ] getBoundsPoints ( ) { return getBounds ( ) . getPoints ( ) ; } public RPoint getTopLeft ( ) { RRectangle orig = this . getBounds ( ) ; return new RPoint ( orig . getMinX ( ) , orig . getMinY ( ) ) ; } public RPoint getTopRight ( ) { RRectangle orig = this . getBounds ( ) ; return new RPoint ( orig . getMaxX ( ) , orig . getMinY ( ) ) ; } public RPoint getBottomLeft ( ) { RRectangle orig = this . getBounds ( ) ; return new RPoint ( orig . getMinX ( ) , orig . getMaxY ( ) ) ; } public RPoint getBottomRight ( ) { RRectangle orig = this . getBounds ( ) ; return new RPoint ( orig . getMaxX ( ) , orig . getMaxY ( ) ) ; } public float getX ( ) { RRectangle orig = this . getBounds ( ) ; return orig . getMinX ( ) ; } public float getY ( ) { RRectangle orig = this . getBounds ( ) ; return orig . getMinY ( ) ; } public float getOrigHeight ( ) { return origHeight != 0.0 ? origHeight : getHeight ( ) ; } public float getOrigWidth ( ) { return origWidth != 0.0 ? origWidth : getWidth ( ) ; } protected void updateOrigParams ( ) { this . origWidth = this . getWidth ( ) ; this . origHeight = this . getHeight ( ) ; } public float getWidth ( ) { RRectangle orig = this . getBounds ( ) ; return orig . getMaxX ( ) - orig . getMinX ( ) ; } public float getHeight ( ) { RRectangle orig = this . getBounds ( ) ; return orig . getMaxY ( ) - orig . getMinY ( ) ; } public RPoint getCenter ( ) { RRectangle c = getBounds ( ) ; return new RPoint ( ( c . getMaxX ( ) + c . getMinX ( ) ) / 2 , ( c . getMaxY ( ) + c . getMinY ( ) ) / 2 ) ; } public RPoint getCentroid ( ) { RPoint [ ] ps = getPoints ( ) ; float areaAcc = 0.0f ; float xAcc = 0.0f ; float yAcc = 0.0f ; for ( int i = 0 ; i < ps . length - 1 ; i ++ ) { areaAcc += ps [ i ] . x * ps [ i + 1 ] . y - ps [ i + 1 ] . x * ps [ i ] . y ; xAcc += ( ps [ i ] . x + ps [ i + 1 ] . x ) * ( ps [ i ] . x * ps [ i + 1 ] . y - ps [ i + 1 ] . x * ps [ i ] . y ) ; yAcc += ( ps [ i ] . y + ps [ i + 1 ] . y ) * ( ps [ i ] . x * ps [ i + 1 ] . y - ps [ i + 1 ] . x * ps [ i ] . y ) ; } areaAcc /= 2.0f ; RPoint p = new RPoint ( xAcc / ( 6.0f * areaAcc ) , yAcc / ( 6.0f * areaAcc ) ) ; return p ; } public float getArea ( ) { RPoint [ ] ps = getPoints ( ) ; float areaAcc = 0.0f ; for ( int i = 0 ; i < ps . length - 1 ; i ++ ) { areaAcc += ps [ i ] . x * ps [ i + 1 ] . y - ps [ i + 1 ] . x * ps [ i ] . y ; } areaAcc /= 2.0f ; return Math . abs ( areaAcc ) ; } public boolean isIn ( PGraphics g ) { RRectangle c = getBounds ( ) ; float x0 = g . screenX ( c . topLeft . x , c . topLeft . y ) ; float y0 = g . screenY ( c . topLeft . x , c . topLeft . y ) ; float x1 = g . screenX ( c . bottomRight . x , c . topLeft . y ) ; float y1 = g . screenY ( c . bottomRight . x , c . topLeft . y ) ; float x2 = g . screenX ( c . bottomRight . x , c . bottomRight . y ) ; float y2 = g . screenY ( c . bottomRight . x , c . bottomRight . y ) ; float x3 = g . screenX ( c . topLeft . x , c . bottomRight . y ) ; float y3 = g . screenY ( c . topLeft . x , c . bottomRight . y ) ; float xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; float ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; float xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; float ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; return ! ( ( xmax < 0 || xmin > g . width ) && ( ymax < 0 || ymin > g . height ) ) ; } public boolean isIn ( PApplet g ) { RRectangle c = getBounds ( ) ; float x0 = g . screenX ( c . topLeft . x , c . topLeft . y ) ; float y0 = g . screenY ( c . topLeft . x , c . topLeft . y ) ; float x1 = g . screenX ( c . bottomRight . x , c . topLeft . y ) ; float y1 = g . screenY ( c . bottomRight . x , c . topLeft . y ) ; float x2 = g . screenX ( c . bottomRight . x , c . bottomRight . y ) ; float y2 = g . screenY ( c . bottomRight . x , c . bottomRight . y ) ; float x3 = g . screenX ( c . topLeft . x , c . bottomRight . y ) ; float y3 = g . screenY ( c . topLeft . x , c . bottomRight . y ) ; float xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; float ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; float xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; float ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; return ! ( ( xmax < 0 || xmin > g . width ) && ( ymax < 0 || ymin > g . height ) ) ; } public RMatrix getCenteringTransf ( PGraphics g , float margin , float sclDamping , float trnsDamping ) throws RuntimeException { RMatrix transf ; float mrgn = margin * 2 ; RRectangle c = getBounds ( ) ; float scl = ( float ) Math . min ( ( g . width - mrgn ) / ( float ) Math . abs ( c . getMinX ( ) - c . getMaxX ( ) ) , ( g . height - mrgn ) / ( float ) Math . abs ( c . getMinY ( ) - c . getMaxY ( ) ) ) ; RPoint trns = getCenter ( ) ; transf = new RMatrix ( ) ; if ( sclDamping != 0 ) { transf . scale ( 1 + ( scl - 1 ) * sclDamping ) ; } if ( trnsDamping != 0 ) { transf . translate ( - trns . x * trnsDamping , - trns . y * trnsDamping ) ; } return transf ; } public RMatrix getCenteringTransf ( PGraphics g ) throws RuntimeException { return getCenteringTransf ( g , 0 , 1 , 1 ) ; } public RMatrix getCenteringTransf ( PGraphics g , float margin ) throws RuntimeException { return getCenteringTransf ( g , margin , 1 , 1 ) ; } public void centerIn ( PGraphics g ) { transform ( getCenteringTransf ( g ) ) ; } public void centerIn ( PGraphics g , float margin ) { transform ( getCenteringTransf ( g , margin , 1 , 1 ) ) ; } public void centerIn ( PGraphics g , float margin , float sclDamping , float trnsDamping ) throws RuntimeException { transform ( getCenteringTransf ( g , margin , sclDamping , trnsDamping ) ) ; } public void translate ( float tx , float ty ) { RMatrix transf = new RMatrix ( ) ; transf . translate ( tx , ty ) ; transform ( transf ) ; } public void translate ( RPoint t ) { RMatrix transf = new RMatrix ( ) ; transf . translate ( t ) ; transform ( transf ) ; } public void rotate ( float angle , float vx , float vy ) { RMatrix transf = new RMatrix ( ) ; transf . rotate ( angle , vx , vy ) ; transform ( transf ) ; } public void rotate ( float angle ) { RMatrix transf = new RMatrix ( ) ; transf . rotate ( angle ) ; transform ( transf ) ; } public void rotate ( float angle , RPoint v ) { RMatrix transf = new RMatrix ( ) ; transf . rotate ( angle , v ) ; transform ( transf ) ; } public void scale ( float sx , float sy , RPoint p ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( sx , sy , p ) ; transform ( transf ) ; } public void scale ( float sx , float sy ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( sx , sy ) ; transform ( transf ) ; } public void scale ( float sx , float sy , float x , float y ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( sx , sy , x , y ) ; transform ( transf ) ; } public void scale ( float s , RPoint p ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( s , p ) ; transform ( transf ) ; } public void scale ( float s ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( s ) ; transform ( transf ) ; } public void scale ( float s , float x , float y ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( s , x , y ) ; transform ( transf ) ; } public void skewX ( float angle ) { RMatrix transf = new RMatrix ( ) ; transf . skewY ( angle ) ; transform ( transf ) ; } public void skewY ( float angle ) { RMatrix transf = new RMatrix ( ) ; transf . skewY ( angle ) ; transform ( transf ) ; } public void shear ( float shx , float shy ) { RMatrix transf = new RMatrix ( ) ; transf . shear ( shx , shy ) ; transform ( transf ) ; } } 