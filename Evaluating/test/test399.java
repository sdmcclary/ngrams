<<<<<<< HEAD
public final class DeweyKey { private static final DeweyKey ROOT = new DeweyKey ( null , 0 ) ; private DeweyKey parent ; private int value ; private DeweyKey ( DeweyKey parent , int value ) { this . parent = parent ; this . value = value ; } public static DeweyKey root ( ) { return ROOT ; } public static DeweyKey initial ( ) { return topLevel ( 0 ) ; } public static DeweyKey topLevel ( int value ) { if ( value < 0 ) { throw new IllegalArgumentException ( "DeweyKey component " + value + " negative" ) ; } return new DeweyKey ( ROOT , value ) ; } private static DeweyKey construct ( int [ ] path , int last ) { if ( last == 0 ) { return topLevel ( path [ 0 ] ) ; } else { return construct ( path , last - 1 ) . child ( path [ last ] ) ; } } public DeweyKey append ( int [ ] path ) { if ( path != null ) { return append ( path , 0 , path . length ) ; } else { return this ; } } public DeweyKey append ( int [ ] path , int offset , int length ) { DeweyKey k = this ; for ( int i = 0 ; i < length ; i ++ ) { k = k . child ( path [ offset + i ] ) ; } return k ; } public static DeweyKey construct ( int [ ] path ) { if ( path == null || path . length == 0 ) { return ROOT ; } else { return construct ( path , path . length - 1 ) ; } } public static DeweyKey construct ( int [ ] path , int offset , int length ) { if ( path == null || length == 0 ) { return ROOT ; } if ( offset < 0 || length < 0 || offset + length > path . length ) { throw new IllegalArgumentException ( "offset=" + offset + ",length=" + length ) ; } if ( length == 1 ) { return topLevel ( path [ offset ] ) ; } else { return construct ( path , offset , length - 1 ) ; } } private int [ ] deconstruct ( int depth ) { int [ ] result ; if ( parent . isRoot ( ) ) { result = new int [ depth + 1 ] ; result [ 0 ] = value ; } else { result = parent . deconstruct ( depth + 1 ) ; result [ result . length - depth - 1 ] = value ; } return result ; } public int [ ] deconstruct ( ) { if ( isRoot ( ) ) { return new int [ 0 ] ; } else { return deconstruct ( 0 ) ; } } public boolean isRoot ( ) { return this == ROOT ; } public DeweyKey up ( ) { if ( isRoot ( ) ) { throw new IllegalStateException ( "Cannot go up from root DeweyKey" ) ; } return parent ; } public DeweyKey next ( ) { if ( isRoot ( ) ) { throw new IllegalStateException ( "Root DeweyKey does not have a next key" ) ; } return new DeweyKey ( parent , value + 1 ) ; } public DeweyKey prev ( ) { if ( isRoot ( ) ) { throw new IllegalStateException ( "Root DeweyKey does not have a previous key" ) ; } else if ( value == 0 ) { throw new IllegalStateException ( "Key " + this + " is first child" ) ; } else { return new DeweyKey ( parent , value - 1 ) ; } } public DeweyKey down ( ) { return child ( 0 ) ; } public DeweyKey child ( int value ) { if ( value < 0 ) { throw new IllegalArgumentException ( "Negative value " + value + " not allowed as DeweyKey component" ) ; } return new DeweyKey ( this , value ) ; } public DeweyKey next ( DeweyKey ancestor ) { Verifier . checkNotNull ( ancestor ) ; if ( Util . equals ( parent , ancestor ) ) { return next ( ) ; } else if ( parent . isRoot ( ) ) { throw new IllegalArgumentException ( "Key " + ancestor + " not an ancestor of " + this ) ; } else { return parent . next ( ancestor ) . child ( value ) ; } } public DeweyKey prev ( DeweyKey ancestor ) { Verifier . checkNotNull ( ancestor ) ; if ( Util . equals ( parent , ancestor ) ) { return prev ( ) ; } else if ( parent . isRoot ( ) ) { throw new IllegalArgumentException ( "Key " + ancestor + " not an ancestor of " + this ) ; } else { return parent . prev ( ancestor ) . child ( value ) ; } } public DeweyKey replaceAncestorSelf ( DeweyKey old , DeweyKey repl ) { Verifier . checkNotNull ( old ) ; Verifier . checkNotNull ( repl ) ; if ( equals ( old ) ) { return repl ; } else { return replaceAncestor ( old , repl ) ; } } public DeweyKey replaceAncestor ( DeweyKey old , DeweyKey repl ) { Verifier . checkNotNull ( old ) ; Verifier . checkNotNull ( repl ) ; if ( Util . equals ( parent , old ) ) { if ( repl . isRoot ( ) ) { return DeweyKey . topLevel ( value ) ; } else { return repl . child ( value ) ; } } else if ( parent == null || parent . isRoot ( ) ) { throw new IllegalArgumentException ( "Key " + old + " not an ancestor of " + this ) ; } else { return parent . replaceAncestor ( old , repl ) . child ( value ) ; } } public boolean isChild ( DeweyKey key ) { Verifier . checkNotNull ( key ) ; return Util . equals ( parent , key ) ; } public boolean isDescendant ( DeweyKey key ) { Verifier . checkNotNull ( key ) ; return key . isRoot ( ) || isChild ( key ) || ( ! parent . isRoot ( ) && parent . isDescendant ( key ) ) ; } public boolean isDescendantSelf ( DeweyKey key ) { Verifier . checkNotNull ( key ) ; return this . equals ( key ) || this . isDescendant ( key ) ; } public boolean precedeSibling ( DeweyKey key ) { Verifier . checkNotNull ( key ) ; return ! key . isRoot ( ) && Util . equals ( parent , key . parent ) && value < key . value ; } public boolean followSibling ( DeweyKey key ) { Verifier . checkNotNull ( key ) ; return ! key . isRoot ( ) && key . precedeSibling ( this ) ; } public boolean descendantFollowSibling ( DeweyKey key ) { Verifier . checkNotNull ( key ) ; if ( key . isRoot ( ) ) { return false ; } DeweyKey targetKey = key . parent ; int targetValue = key . value ; DeweyKey currentKey = parent ; int currentValue = value ; if ( targetKey . isRoot ( ) ) { while ( ! currentKey . isRoot ( ) ) { currentValue = currentKey . value ; currentKey = currentKey . parent ; } return currentValue > targetValue ; } else { while ( ! currentKey . isRoot ( ) && ! currentKey . equals ( targetKey ) ) { currentValue = currentKey . value ; currentKey = currentKey . parent ; } if ( currentKey . isRoot ( ) ) { return false ; } else { return currentValue > targetValue ; } } } public DeweyKey commonAncestor ( DeweyKey key ) { Verifier . checkNotNull ( key ) ; while ( ! this . isDescendant ( key ) ) { key = key . parent ; } return key ; } public int getLastStep ( ) { return value ; } public int size ( ) { if ( isRoot ( ) ) { return 0 ; } else { return parent . size ( ) + 1 ; } } @ Override public int hashCode ( ) { return 37 * Util . hashCode ( parent ) + value ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } else if ( ! ( o instanceof DeweyKey ) ) { return false ; } else { DeweyKey d = ( DeweyKey ) o ; return value == d . value && Util . equals ( parent , d . parent ) ; } } @ Override public String toString ( ) { if ( isRoot ( ) ) { return "/" ; } else if ( parent . isRoot ( ) ) { return "/" + value ; } else { return parent . toString ( ) + "/" + value ; } } } 
=======
public interface Datatype { boolean isValid ( String literal , ValidationContext context ) ; void checkValid ( String literal , ValidationContext context ) throws DatatypeException ; DatatypeStreamingValidator createStreamingValidator ( ValidationContext context ) ; Object createValue ( String literal , ValidationContext context ) ; boolean sameValue ( Object value1 , Object value2 ) ; int valueHashCode ( Object value ) ; public static final int ID_TYPE_NULL = 0 ; public static final int ID_TYPE_ID = 1 ; public static final int ID_TYPE_IDREF = 2 ; public static final int ID_TYPE_IDREFS = 3 ; public int getIdType ( ) ; public boolean isContextDependent ( ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
