<<<<<<< HEAD
class Main { private static final class ParameterDescriptionComparator implements Comparator < ParameterDescription > { public int compare ( ParameterDescription a , ParameterDescription b ) { return a . getLongestName ( ) . compareTo ( b . getLongestName ( ) ) ; } } private static final class DefaultFormatter implements JSLintResultFormatter { public String format ( JSLintResult result ) { if ( result . getIssues ( ) . isEmpty ( ) ) { return "" ; } String nl = System . getProperty ( "line.separator" ) ; StringBuilder sb = new StringBuilder ( ) ; for ( Issue issue : result . getIssues ( ) ) { sb . append ( PROGNAME ) ; sb . append ( ':' ) ; sb . append ( issue . toString ( ) ) ; sb . append ( nl ) ; } sb . delete ( sb . length ( ) - nl . length ( ) , sb . length ( ) ) ; return sb . toString ( ) ; } public String footer ( ) { return null ; } public String header ( ) { return null ; } } @ SuppressWarnings ( "serial" ) public static class DieException extends RuntimeException { private final int code ; public DieException ( String message , int code ) { super ( message ) ; this . code = code ; } public int getCode ( ) { return code ; } } private static final String FULL_PROGRAM_NAME = "jslint4java" ; private static final String PROGNAME = "jslint" ; public static void main ( String [ ] args ) throws IOException { try { System . exit ( new Main ( ) . run ( args ) ) ; } catch ( DieException e ) { if ( e . getMessage ( ) != null ) { System . err . println ( PROGNAME + ": " + e . getMessage ( ) ) ; } System . exit ( e . getCode ( ) ) ; } } int run ( String [ ] args ) throws IOException { List < String > files = processOptions ( args ) ; if ( formatter . header ( ) != null ) { info ( formatter . header ( ) ) ; } for ( String file : files ) { lintFile ( file ) ; } if ( formatter . footer ( ) != null ) { info ( formatter . footer ( ) ) ; } return isErrored ( ) ? 1 : 0 ; } private Charset encoding = Charset . defaultCharset ( ) ; private boolean errored = false ; private JSLintResultFormatter formatter ; private JSLint lint ; private final JSLintBuilder lintBuilder = new JSLintBuilder ( ) ; private void die ( String message ) { throw new DieException ( message , 1 ) ; } private Option getOption ( String optName ) { try { return Option . valueOf ( optName ) ; } catch ( IllegalArgumentException e ) { return null ; } } private void info ( String message ) { System . out . println ( message ) ; } private boolean isErrored ( ) { return errored ; } private void lintFile ( String file ) throws IOException { BufferedReader reader = null ; try { reader = readerForFile ( file ) ; JSLintResult result = lint . lint ( file , reader ) ; String msg = formatter . format ( result ) ; if ( msg . length ( ) > 0 ) { info ( msg ) ; } if ( ! result . getIssues ( ) . isEmpty ( ) ) { setErrored ( true ) ; } } catch ( FileNotFoundException e ) { die ( file + ": No such file or directory." ) ; } finally { if ( reader != null ) { reader . close ( ) ; } } } @ SuppressWarnings ( "resource" ) private BufferedReader readerForFile ( String file ) throws IOException , FileNotFoundException { InputStream inputStream = "-" . equals ( file ) ? System . in : new FileInputStream ( file ) ; return new BufferedReader ( new InputStreamReader ( new UnicodeBomInputStream ( inputStream ) . skipBOM ( ) , encoding ) ) ; } private JSLint makeLint ( Flags flags ) { try { if ( flags . timeout > 0 ) { lintBuilder . timeout ( flags . timeout ) ; } if ( flags . jslint != null ) { return lintBuilder . fromFile ( new File ( flags . jslint ) ) ; } else { return lintBuilder . fromDefault ( ) ; } } catch ( IOException e ) { die ( e . getMessage ( ) ) ; } return null ; } private List < String > processOptions ( String [ ] args ) { JSLintFlags jslintFlags = new JSLintFlags ( ) ; Flags flags = new Flags ( ) ; JCommander jc = new JCommander ( new Object [ ] { flags , jslintFlags } ) ; jc . setProgramName ( FULL_PROGRAM_NAME ) ; try { jc . parse ( args ) ; } catch ( ParameterException e ) { info ( e . getMessage ( ) ) ; usage ( jc ) ; } if ( flags . version ) { version ( ) ; } if ( flags . help ) { usage ( jc ) ; } if ( flags . encoding != null ) { encoding = flags . encoding ; } lint = makeLint ( flags ) ; setResultFormatter ( flags . report ) ; for ( ParameterDescription pd : jc . getParameters ( ) ) { Parameterized p = pd . getParameterized ( ) ; if ( ! pd . getObject ( ) . getClass ( ) . isAssignableFrom ( JSLintFlags . class ) ) { continue ; } try { Option o = getOption ( p . getName ( ) ) ; Object val = p . get ( jslintFlags ) ; if ( val == null ) { continue ; } Class < ? > type = p . getType ( ) ; if ( type . isAssignableFrom ( Boolean . class ) ) { lint . addOption ( o ) ; } else if ( type . isAssignableFrom ( String . class ) ) { lint . addOption ( o , ( String ) val ) ; } else { die ( "unknown type \"" + type + "\" (for " + p . getName ( ) + ")" ) ; } } catch ( IllegalArgumentException e ) { die ( e . getMessage ( ) ) ; } } if ( flags . files . isEmpty ( ) ) { usage ( jc ) ; return null ; } else { return flags . files ; } } private void setErrored ( boolean errored ) { this . errored = errored ; } private void setResultFormatter ( String reportType ) { if ( reportType == null || reportType . equals ( "" ) ) { formatter = new DefaultFormatter ( ) ; } else if ( reportType . equals ( "plain" ) ) { formatter = new PlainFormatter ( ) ; } else if ( reportType . equals ( "xml" ) ) { formatter = new JSLintXmlFormatter ( ) ; } else if ( reportType . equals ( "junit" ) ) { formatter = new JUnitXmlFormatter ( ) ; } else if ( reportType . equals ( "report" ) ) { formatter = new ReportFormatter ( ) ; } else if ( reportType . equals ( "checkstyle" ) ) { formatter = new CheckstyleXmlFormatter ( ) ; } else { die ( "unknown report type '" + reportType + "'" ) ; } } private void usage ( JCommander jc ) { info ( String . format ( "Usage: %s [options] file.js ..." , FULL_PROGRAM_NAME ) ) ; info ( "" ) ; List < ParameterDescription > parameters = jc . getParameters ( ) ; String spec = " %-" + getLongestName ( parameters ) + "s %s" ; Collections . sort ( parameters , new ParameterDescriptionComparator ( ) ) ; for ( ParameterDescription pd : parameters ) { info ( String . format ( spec , pd . getLongestName ( ) , pd . getDescription ( ) ) ) ; } info ( "" ) ; version ( ) ; } private int getLongestName ( List < ParameterDescription > parameters ) { int length = 0 ; for ( ParameterDescription pd : parameters ) { if ( pd . getLongestName ( ) . length ( ) > length ) { length = pd . getLongestName ( ) . length ( ) ; } } return length ; } private void version ( ) { if ( lint == null ) { lint = lintBuilder . fromDefault ( ) ; } info ( "using jslint version " + lint . getEdition ( ) ) ; throw new DieException ( null , 0 ) ; } } 
=======
class Alphabet { private NameClass nameClass ; boolean isEmpty ( ) { return nameClass == null ; } void addElement ( NameClass nc ) { if ( nameClass == null ) nameClass = nc ; else if ( nc != null ) nameClass = new ChoiceNameClass ( nameClass , nc ) ; } void addAlphabet ( Alphabet a ) { addElement ( a . nameClass ) ; } void checkOverlap ( Alphabet a ) throws RestrictionViolationException { if ( nameClass != null && a . nameClass != null ) OverlapDetector . checkOverlap ( nameClass , a . nameClass , "interleave_element_overlap_name" , "interleave_element_overlap_ns" , "interleave_element_overlap" ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
