<<<<<<< HEAD
public class DerefRefTree implements IdAddressableRefTree { protected int modCount = 0 ; protected Map < Integer , Integer > _modCounts ; protected int _MODCOUNT_KEYMASK = 4096 - 1 ; protected IdAddressableRefTree refTree ; protected IdAddressableRefTree backingTree ; protected IOExceptionTrap trap = null ; protected KeyMap km = null ; public DerefRefTree ( IdAddressableRefTree refTree , IdAddressableRefTree backingTree , KeyMap km ) { assert ( _modCounts = new HashMap < Integer , Integer > ( ) ) != null ; this . refTree = refTree ; this . backingTree = backingTree ; this . km = km ; } public RefTreeNode getRoot ( ) { RefTreeNode rr = refTree . getRoot ( ) ; if ( rr == null ) return new BackProxyNode ( backingTree . getRoot ( ) ) ; if ( rr . isTreeRef ( ) ) { return new BackProxyNode ( getExistingBackNode ( rr ) ) ; } return new FrontProxyNode ( rr ) ; } public RefTreeNode getNode ( Key id ) { RefTreeNode rr = refTree . getNode ( id ) ; if ( rr == null ) { Key bk = km . getBackKey ( id ) ; rr = isDeleted ( bk ) ? null : backingTree . getNode ( bk ) ; return rr == null ? null : new BackProxyNode ( rr ) ; } else if ( rr . isTreeRef ( ) ) { return new BackProxyNode ( getExistingBackNode ( rr ) ) ; } else return new FrontProxyNode ( rr ) ; } public boolean contains ( Key id ) { if ( refTree . contains ( id ) ) return true ; Key bk = km . getBackKey ( id ) ; return backingTree . contains ( bk ) && ! isDeleted ( bk ) ; } public Key getParent ( Key nid ) throws NodeNotFoundException { if ( refTree . contains ( nid ) ) return refTree . getParent ( nid ) ; Key bk = km . getBackKey ( nid ) ; Key bpk = isDeleted ( bk ) ? null : backingTree . getParent ( bk ) ; return km . getFrontKey ( bpk ) ; } public Iterator < Key > childIterator ( Key nid ) throws NodeNotFoundException { RefTreeNode n = refTree . getNode ( nid ) ; if ( n != null && ! n . isTreeRef ( ) ) return refTree . childIterator ( nid ) ; Key bk = km . getBackKey ( nid ) ; if ( isDeleted ( bk ) || ! backingTree . contains ( bk ) ) throw new NodeNotFoundException ( nid ) ; final Iterator bci = backingTree . childIterator ( bk ) ; return new Iterator ( ) { public boolean hasNext ( ) { return bci . hasNext ( ) ; } public Object next ( ) { return km . getFrontKey ( ( Key ) bci . next ( ) ) ; } public void remove ( ) { bci . remove ( ) ; } } ; } protected RefTreeNode getExistingBackNode ( RefTreeNode m ) { Reference r = m . getReference ( ) ; if ( r == null ) return null ; RefTreeNode bn = ( backingTree . getNode ( r . getTarget ( ) ) ) ; if ( bn == null ) trap ( new NodeNotFoundException ( r . getTarget ( ) ) ) ; return bn ; } protected boolean isDeleted ( Key bk ) { return false ; } protected void trap ( Exception e ) { if ( ! ( e instanceof IOException ) ) { IOException ee = new IOException ( "Trapped exception" ) ; ee . initCause ( e ) ; e = ee ; } if ( trap != null ) trap . trap ( ( IOException ) e ) ; else throw new IOExceptionTrap . RuntimeIOException ( ( IOException ) e ) ; } protected class FrontProxyNode implements RefTreeNode { RefTreeNode n ; public FrontProxyNode ( RefTreeNode n ) { assert _modCounts . put ( System . identityHashCode ( this ) & _MODCOUNT_KEYMASK , modCount ) == null || true ; assert ! n . isTreeRef ( ) ; assert n != null ; this . n = n ; } public Reference getReference ( ) { assert checkModCount ( ) == true ; if ( n . isNodeRef ( ) ) { RefTreeNode bn = getExistingBackNode ( n ) ; return bn . getReference ( ) ; } return n . getReference ( ) ; } public Key getId ( ) { assert checkModCount ( ) == true ; return n . getId ( ) ; } public RefTreeNode getParent ( ) { assert checkModCount ( ) == true ; RefTreeNode p = n . getParent ( ) ; return p != null ? new FrontProxyNode ( p ) : null ; } public Object getContent ( ) { assert checkModCount ( ) == true ; if ( n . isNodeRef ( ) ) { RefTreeNode bn = getExistingBackNode ( n ) ; Object c = bn . getContent ( ) ; return c ; } return n . getContent ( ) ; } public Iterator getChildIterator ( ) { assert checkModCount ( ) == true ; final Iterator ri = n . getChildIterator ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return ri . hasNext ( ) ; } public Object next ( ) { RefTreeNode c = ( RefTreeNode ) ri . next ( ) ; if ( c . isTreeRef ( ) ) { RefTreeNode bn = getExistingBackNode ( c ) ; return new BackProxyNode ( bn ) ; } else return new FrontProxyNode ( c ) ; } public void remove ( ) { ri . remove ( ) ; } } ; } public boolean isReference ( ) { assert checkModCount ( ) == true ; return isNodeRef ( ) || isTreeRef ( ) ; } public boolean isTreeRef ( ) { assert checkModCount ( ) == true ; return false ; } public boolean isNodeRef ( ) { assert checkModCount ( ) == true ; return getReference ( ) instanceof NodeReference ; } @ Override public boolean equals ( Object o ) { assert checkModCount ( ) == true ; return n . isNodeRef ( ) ? getExistingBackNode ( n ) . equals ( o ) : n . equals ( o ) ; } @ Override public int hashCode ( ) { assert checkModCount ( ) == true ; return n . isNodeRef ( ) ? getExistingBackNode ( n ) . hashCode ( ) : n . hashCode ( ) ; } @ Override public String toString ( ) { return "[FP] " + n . toString ( ) ; } protected boolean checkModCount ( ) { Integer count = _modCounts . get ( System . identityHashCode ( this ) & _MODCOUNT_KEYMASK ) ; if ( count != null && count != modCount ) throw new ConcurrentModificationException ( "This node object has become stale due to an edit." ) ; return true ; } } protected class BackProxyNode extends FrontProxyNode { public BackProxyNode ( RefTreeNode n ) { super ( n ) ; } @ Override public Reference getReference ( ) { return n . getReference ( ) ; } @ Override public Key getId ( ) { assert checkModCount ( ) == true ; return km . getFrontKey ( n . getId ( ) ) ; } @ Override public RefTreeNode getParent ( ) { assert checkModCount ( ) == true ; Key fk = km . getFrontKey ( n . getId ( ) ) ; if ( refTree . contains ( fk ) ) { assert refTree . getNode ( fk ) . isTreeRef ( ) ; RefTreeNode p = refTree . getNode ( fk ) . getParent ( ) ; return p == null ? null : new FrontProxyNode ( p ) ; } else { RefTreeNode p = n . getParent ( ) ; return p == null ? null : new BackProxyNode ( p ) ; } } @ Override public Object getContent ( ) { assert checkModCount ( ) == true ; return n . getContent ( ) ; } @ Override public Iterator getChildIterator ( ) { assert checkModCount ( ) == true ; final Iterator ri = n . getChildIterator ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return ri . hasNext ( ) ; } public Object next ( ) { return new BackProxyNode ( ( RefTreeNode ) ri . next ( ) ) ; } public void remove ( ) { ri . remove ( ) ; } } ; } @ Override public boolean isReference ( ) { assert checkModCount ( ) == true ; return n . isReference ( ) ; } @ Override public boolean isTreeRef ( ) { assert checkModCount ( ) == true ; return n . isTreeRef ( ) ; } @ Override public boolean isNodeRef ( ) { assert checkModCount ( ) == true ; return n . isNodeRef ( ) ; } @ Override public String toString ( ) { return "[BP] " + n . toString ( ) ; } } public IOExceptionTrap getTrap ( ) { return trap ; } public void setTrap ( IOExceptionTrap trap ) { this . trap = trap ; } } 
=======
public interface DatatypeLibrary { DatatypeBuilder createDatatypeBuilder ( String baseTypeLocalName ) throws DatatypeException ; Datatype createDatatype ( String typeLocalName ) throws DatatypeException ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
