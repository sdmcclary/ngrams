public class AMQProtocolHandler extends IoHandlerAdapter { private static final Logger _logger = LoggerFactory . getLogger ( AMQProtocolHandler . class ) ; private AMQConnection _connection ; private volatile AMQProtocolSession _protocolSession ; private AMQStateManager _stateManager = new AMQStateManager ( ) ; private final CopyOnWriteArraySet _frameListeners = new CopyOnWriteArraySet ( ) ; private FailoverHandler _failoverHandler ; private FailoverState _failoverState = FailoverState . NOT_STARTED ; private CountDownLatch _failoverLatch ; private class FailoverHandler implements Runnable { private final IoSession _session ; private String _host ; private int _port ; public FailoverHandler ( IoSession session ) { _session = session ; } public void run ( ) { _failoverLatch = new CountDownLatch ( 1 ) ; propagateExceptionToWaiters ( new FailoverException ( "Failing over about to start" ) ) ; synchronized ( _connection . getFailoverMutex ( ) ) { _logger . info ( "Starting failover process" ) ; AMQStateManager existingStateManager = _stateManager ; _stateManager = new AMQStateManager ( ) ; if ( ! _connection . firePreFailover ( _host != null ) ) { _stateManager = existingStateManager ; if ( _host != null ) { _connection . exceptionReceived ( new AMQDisconnectedException ( "Redirect was vetoed by client" ) ) ; } else { _connection . exceptionReceived ( new AMQDisconnectedException ( "Failover was vetoed by client" ) ) ; } _failoverLatch . countDown ( ) ; _failoverLatch = null ; return ; } boolean failoverSucceeded ; if ( _host != null ) { failoverSucceeded = _connection . attemptReconnection ( _host , _port ) ; } else { failoverSucceeded = _connection . attemptReconnection ( ) ; } if ( ! failoverSucceeded ) { _stateManager = existingStateManager ; _connection . exceptionReceived ( new AMQDisconnectedException ( "Server closed connection and no failover " + "was successful" ) ) ; } else { _stateManager = existingStateManager ; try { if ( _connection . firePreResubscribe ( ) ) { _logger . info ( "Resubscribing on new connection" ) ; _connection . resubscribeSessions ( ) ; } else { _logger . info ( "Client vetoed automatic resubscription" ) ; } _connection . fireFailoverComplete ( ) ; _failoverState = FailoverState . NOT_STARTED ; _logger . info ( "Connection failover completed successfully" ) ; } catch ( Exception e ) { _logger . info ( "Failover process failed - exception being propagated by protocol handler" ) ; _failoverState = FailoverState . FAILED ; try { exceptionCaught ( _session , e ) ; } catch ( Exception ex ) { _logger . error ( "Error notifying protocol session of error: " + ex , ex ) ; } } } } _failoverLatch . countDown ( ) ; } } public AMQProtocolHandler ( AMQConnection con ) { _connection = con ; _frameListeners . add ( new AMQMethodListener ( ) { public boolean methodReceived ( AMQMethodEvent evt ) throws AMQException { return _stateManager . methodReceived ( evt ) ; } public void error ( Exception e ) { _stateManager . error ( e ) ; } } ) ; } public void sessionCreated ( IoSession session ) throws Exception { _logger . debug ( "Protocol session created for session " + System . identityHashCode ( session ) ) ; _failoverHandler = new FailoverHandler ( session ) ; final ProtocolCodecFilter pcf = new ProtocolCodecFilter ( new AMQCodecFactory ( false ) ) ; if ( Boolean . getBoolean ( "amqj.shared_read_write_pool" ) ) { session . getFilterChain ( ) . addBefore ( "AsynchronousWriteFilter" , "protocolFilter" , pcf ) ; } else { session . getFilterChain ( ) . addLast ( "protocolFilter" , pcf ) ; } _protocolSession = new AMQProtocolSession ( this , session , _connection ) ; _protocolSession . init ( ) ; } public void sessionOpened ( IoSession session ) throws Exception { } public void sessionClosed ( IoSession session ) throws Exception { _logger . info ( "Session closed called with failover state currently " + _failoverState ) ; if ( _failoverState == FailoverState . IN_PROGRESS && ! _connection . isClosed ( ) ) { String message = session . getRemoteAddress ( ) . toString ( ) + " closed. Remote server closed connection" ; _logger . warn ( message ) ; _stateManager . error ( new Exception ( message ) ) ; } else if ( _failoverState == FailoverState . NOT_STARTED && ! _connection . isClosed ( ) ) { _failoverState = FailoverState . IN_PROGRESS ; new Thread ( _failoverHandler ) . start ( ) ; } _logger . info ( "Protocol Session [" + this + "] closed" ) ; } public void sessionIdle ( IoSession session , IdleStatus status ) throws Exception { _logger . debug ( "Protocol Session [" + this + ":" + session + "] idle: " + status ) ; if ( IdleStatus . WRITER_IDLE . equals ( status ) ) { _logger . debug ( "Sent heartbeat" ) ; session . write ( HeartbeatBody . FRAME ) ; HeartbeatDiagnostics . sent ( ) ; } else if ( IdleStatus . READER_IDLE . equals ( status ) ) { HeartbeatDiagnostics . timeout ( ) ; _logger . warn ( "Timed out while waiting for heartbeat from peer." ) ; session . close ( ) ; } } public void exceptionCaught ( IoSession session , Throwable cause ) throws Exception { if ( _failoverState == FailoverState . NOT_STARTED ) { _logger . info ( "Exception caught therefore going to attempt failover: " + cause , cause ) ; sessionClosed ( session ) ; } else if ( _failoverState == FailoverState . FAILED ) { _logger . error ( "Exception caught by protocol handler: " + cause , cause ) ; _connection . exceptionReceived ( cause ) ; AMQException amqe = new AMQException ( "Protocol handler error: " + cause , cause ) ; propagateExceptionToWaiters ( amqe ) ; } } private void propagateExceptionToWaiters ( Exception e ) { _stateManager . error ( e ) ; final Iterator it = _frameListeners . iterator ( ) ; while ( it . hasNext ( ) ) { final AMQMethodListener ml = ( AMQMethodListener ) it . next ( ) ; ml . error ( e ) ; } } private static int _messageReceivedCount ; public void messageReceived ( IoSession session , Object message ) throws Exception { if ( _messageReceivedCount ++ % 1000 == 0 ) { _logger . debug ( "Received " + _messageReceivedCount + " protocol messages" ) ; } Iterator it = _frameListeners . iterator ( ) ; AMQFrame frame = ( AMQFrame ) message ; HeartbeatDiagnostics . received ( frame . bodyFrame instanceof HeartbeatBody ) ; if ( frame . bodyFrame instanceof AMQMethodBody ) { if ( _logger . isDebugEnabled ( ) ) { _logger . debug ( "Method frame received: " + frame ) ; } final AMQMethodEvent evt = new AMQMethodEvent ( frame . channel , ( AMQMethodBody ) frame . bodyFrame , _protocolSession ) ; try { boolean wasAnyoneInterested = false ; while ( it . hasNext ( ) ) { final AMQMethodListener listener = ( AMQMethodListener ) it . next ( ) ; wasAnyoneInterested = listener . methodReceived ( evt ) || wasAnyoneInterested ; } if ( ! wasAnyoneInterested ) { throw new AMQException ( "AMQMethodEvent " + evt + " was not processed by any listener." ) ; } } catch ( AMQException e ) { it = _frameListeners . iterator ( ) ; while ( it . hasNext ( ) ) { final AMQMethodListener listener = ( AMQMethodListener ) it . next ( ) ; listener . error ( e ) ; } exceptionCaught ( session , e ) ; } } else if ( frame . bodyFrame instanceof ContentHeaderBody ) { _protocolSession . messageContentHeaderReceived ( frame . channel , ( ContentHeaderBody ) frame . bodyFrame ) ; } else if ( frame . bodyFrame instanceof ContentBody ) { _protocolSession . messageContentBodyReceived ( frame . channel , ( ContentBody ) frame . bodyFrame ) ; } else if ( frame . bodyFrame instanceof HeartbeatBody ) { _logger . debug ( "Received heartbeat" ) ; } _connection . bytesReceived ( _protocolSession . getIoSession ( ) . getReadBytes ( ) ) ; } private static int _messagesOut ; public void messageSent ( IoSession session , Object message ) throws Exception { if ( _messagesOut ++ % 1000 == 0 ) { _logger . debug ( "Sent " + _messagesOut + " protocol messages" ) ; } _connection . bytesSent ( session . getWrittenBytes ( ) ) ; if ( _logger . isDebugEnabled ( ) ) { _logger . debug ( "Sent frame " + message ) ; } } public void addFrameListener ( AMQMethodListener listener ) { _frameListeners . add ( listener ) ; } public void removeFrameListener ( AMQMethodListener listener ) { _frameListeners . remove ( listener ) ; } public void attainState ( AMQState s ) throws AMQException { _stateManager . attainState ( s ) ; } public void writeFrame ( AMQDataBlock frame ) { _protocolSession . writeFrame ( frame ) ; } public void writeFrame ( AMQDataBlock frame , boolean wait ) { _protocolSession . writeFrame ( frame , wait ) ; } public AMQMethodEvent writeCommandFrameAndWaitForReply ( AMQFrame frame , BlockingMethodFrameListener listener ) throws AMQException { _frameListeners . add ( listener ) ; _protocolSession . writeFrame ( frame ) ; return listener . blockForFrame ( ) ; } public void addSessionByChannel ( int channelId , AMQSession session ) { _protocolSession . addSessionByChannel ( channelId , session ) ; } public void removeSessionByChannel ( int channelId ) { _protocolSession . removeSessionByChannel ( channelId ) ; } public void closeSession ( AMQSession session ) throws AMQException { BlockingMethodFrameListener listener = new SpecificMethodFrameListener ( session . getChannelId ( ) , ChannelCloseOkBody . class ) ; _frameListeners . add ( listener ) ; _protocolSession . closeSession ( session ) ; _logger . debug ( "Blocking for channel close frame for channel " + session . getChannelId ( ) ) ; listener . blockForFrame ( ) ; _logger . debug ( "Received channel close frame" ) ; } public void closeConnection ( ) throws AMQException { BlockingMethodFrameListener listener = new ConnectionCloseOkListener ( ) ; _frameListeners . add ( listener ) ; _stateManager . changeState ( AMQState . CONNECTION_CLOSING ) ; final AMQFrame frame = ConnectionCloseBody . createAMQFrame ( 0 , AMQConstant . REPLY_SUCCESS . getCode ( ) , "JMS client is closing the connection." , 0 , 0 ) ; writeFrame ( frame ) ; _logger . debug ( "Blocking for connection close ok frame" ) ; listener . blockForFrame ( ) ; _protocolSession . closeProtocolSession ( ) ; } public long getReadBytes ( ) { return _protocolSession . getIoSession ( ) . getReadBytes ( ) ; } public long getWrittenBytes ( ) { return _protocolSession . getIoSession ( ) . getWrittenBytes ( ) ; } public void failover ( String host , int port ) { _failoverHandler . _host = host ; _failoverHandler . _port = port ; new Thread ( _failoverHandler ) . start ( ) ; } public void blockUntilNotFailingOver ( ) throws InterruptedException { if ( _failoverLatch != null ) { _failoverLatch . await ( ) ; } } public String generateQueueName ( ) { return _protocolSession . generateQueueName ( ) ; } } 