<<<<<<< HEAD
public final class LruCache < K , V > { private static final Object NULL = new Object ( ) ; private int _capacity ; private int _capacity1 ; private CacheItem < K , V > [ ] _entries ; private int _mask ; private boolean _isEnableListeners = true ; private final Object _lruLock = new Object ( ) ; private int _size1 ; private CacheItem < K , V > _head1 ; private CacheItem < K , V > _tail1 ; private int _size2 ; private CacheItem < K , V > _head2 ; private CacheItem < K , V > _tail2 ; private int _lruTimeout = 1 ; private volatile int _lruCounter ; private volatile long _hitCount ; private volatile long _missCount ; public LruCache ( int initialCapacity ) { this ( initialCapacity , false ) ; } @ SuppressWarnings ( "unchecked" ) public LruCache ( int initialCapacity , boolean isStatistics ) { int capacity ; for ( capacity = 16 ; capacity < 2 * initialCapacity ; capacity *= 2 ) { } _entries = ( CacheItem < K , V > [ ] ) new CacheItem [ capacity ] ; _mask = capacity - 1 ; _capacity = initialCapacity ; _capacity1 = _capacity / 2 ; _lruTimeout = _capacity / 16 ; if ( _lruTimeout < 1 ) _lruTimeout = 1 ; } public void setEnableListeners ( boolean isEnable ) { _isEnableListeners = isEnable ; } public int size ( ) { return _size1 + _size2 ; } public int getCapacity ( ) { return _capacity ; } public void clear ( ) { if ( _size1 == 0 && _size2 == 0 ) return ; ArrayList < CacheListener > listeners = null ; synchronized ( this ) { for ( int i = _entries . length - 1 ; i >= 0 ; i -- ) { CacheItem < K , V > item = _entries [ i ] ; _entries [ i ] = null ; if ( _isEnableListeners ) { for ( ; item != null ; item = item . _nextHash ) { if ( item . _value instanceof CacheListener ) { if ( listeners == null ) listeners = new ArrayList < CacheListener > ( ) ; listeners . add ( ( CacheListener ) item . _value ) ; } } } } synchronized ( _lruLock ) { _size1 = 0 ; _head1 = null ; _tail1 = null ; _size2 = 0 ; _head2 = null ; _tail2 = null ; } } for ( int i = listeners != null ? listeners . size ( ) - 1 : - 1 ; i >= 0 ; i -- ) { CacheListener listener = listeners . get ( i ) ; listener . removeEvent ( ) ; } } public V get ( K key ) { Object okey = key ; if ( okey == null ) okey = NULL ; int hash = okey . hashCode ( ) & _mask ; CacheItem < K , V > item ; for ( item = _entries [ hash ] ; item != null ; item = item . _nextHash ) { Object itemKey = item . _key ; if ( itemKey == okey || itemKey . equals ( okey ) ) { updateLru ( item ) ; _hitCount ++ ; return item . _value ; } } _missCount ++ ; return null ; } public V put ( K key , V value ) { V oldValue = compareAndPut ( null , key , value , false ) ; return oldValue ; } public V putIfNew ( K key , V value ) { V oldValue = compareAndPut ( null , key , value , true ) ; if ( oldValue != null ) return oldValue ; else return value ; } public boolean compareAndPut ( V testValue , K key , V value ) { V result = compareAndPut ( testValue , key , value , true ) ; return testValue == result ; } @ SuppressWarnings ( "unchecked" ) private V compareAndPut ( V testValue , K key , V value , boolean isCompare ) { Object okey = key ; if ( okey == null ) okey = NULL ; while ( _capacity <= _size1 + _size2 ) { if ( ! removeTail ( ) ) throw new IllegalStateException ( "unable to remove tail from cache" ) ; } int hash = okey . hashCode ( ) & _mask ; V oldValue = null ; synchronized ( this ) { CacheItem < K , V > item = _entries [ hash ] ; for ( ; item != null ; item = item . _nextHash ) { if ( item . _key == okey || okey . equals ( item . _key ) ) { oldValue = item . _value ; if ( isCompare && testValue != oldValue ) { updateLru ( item ) ; return oldValue ; } item . _value = value ; if ( value == oldValue ) oldValue = null ; updateLru ( item ) ; break ; } } if ( isCompare && testValue != oldValue ) { return null ; } if ( item == null ) { CacheItem < K , V > next = _entries [ hash ] ; item = new CacheItem < K , V > ( ( K ) okey , value ) ; item . _nextHash = next ; _entries [ hash ] = item ; synchronized ( _lruLock ) { _lruCounter ++ ; _size1 ++ ; item . _nextLru = _head1 ; if ( _head1 != null ) _head1 . _prevLru = item ; else _tail1 = item ; _head1 = item ; } return null ; } if ( _isEnableListeners && oldValue instanceof SyncCacheListener ) ( ( SyncCacheListener ) oldValue ) . syncRemoveEvent ( ) ; } if ( _isEnableListeners && oldValue instanceof CacheListener ) ( ( CacheListener ) oldValue ) . removeEvent ( ) ; return oldValue ; } private void updateLru ( CacheItem < K , V > item ) { long lruCounter = _lruCounter ; long itemCounter = item . _lruCounter ; long delta = lruCounter - itemCounter ; if ( _lruTimeout < delta || delta < 0 ) { updateLruImpl ( item ) ; } } private void updateLruImpl ( CacheItem < K , V > item ) { synchronized ( _lruLock ) { _lruCounter = ( _lruCounter + 1 ) & 0x3fffffff ; item . _lruCounter = _lruCounter ; CacheItem < K , V > prevLru = item . _prevLru ; CacheItem < K , V > nextLru = item . _nextLru ; if ( item . _hitCount ++ == 1 ) { if ( prevLru != null ) prevLru . _nextLru = nextLru ; else _head1 = nextLru ; if ( nextLru != null ) nextLru . _prevLru = prevLru ; else _tail1 = prevLru ; item . _prevLru = null ; if ( _head2 != null ) _head2 . _prevLru = item ; else _tail2 = item ; item . _nextLru = _head2 ; _head2 = item ; _size1 -- ; _size2 ++ ; } else { if ( prevLru == null ) return ; prevLru . _nextLru = nextLru ; item . _prevLru = null ; item . _nextLru = _head2 ; _head2 . _prevLru = item ; _head2 = item ; if ( nextLru != null ) nextLru . _prevLru = prevLru ; else _tail2 = prevLru ; } } } public boolean removeTail ( ) { CacheItem < K , V > tail ; synchronized ( this ) { if ( _capacity1 <= _size1 ) tail = _tail1 ; else if ( _size2 > 0 ) tail = _tail2 ; else if ( _size1 > 0 ) tail = _tail1 ; else return false ; } V oldValue = tail . _value ; if ( oldValue instanceof LruListener ) ( ( LruListener ) oldValue ) . lruEvent ( ) ; remove ( tail . _key ) ; return true ; } public boolean removeLongestTail ( ) { CacheItem < K , V > tail ; synchronized ( this ) { if ( _size1 <= _size2 ) tail = _tail2 != null ? _tail2 : _tail1 ; else tail = _tail1 != null ? _tail1 : _tail2 ; } if ( tail == null ) return false ; V oldValue = tail . _value ; if ( oldValue instanceof LruListener ) ( ( LruListener ) oldValue ) . lruEvent ( ) ; remove ( tail . _key ) ; return true ; } public V remove ( K key ) { Object okey = key ; if ( okey == null ) okey = NULL ; int hash = okey . hashCode ( ) & _mask ; V value = null ; synchronized ( this ) { CacheItem < K , V > prevItem = null ; for ( CacheItem < K , V > item = _entries [ hash ] ; item != null ; item = item . _nextHash ) { if ( item . _key == okey || item . _key . equals ( okey ) ) { CacheItem < K , V > nextHash = item . _nextHash ; if ( prevItem != null ) prevItem . _nextHash = nextHash ; else _entries [ hash ] = nextHash ; synchronized ( _lruLock ) { CacheItem < K , V > prevLru = item . _prevLru ; CacheItem < K , V > nextLru = item . _nextLru ; if ( item . _hitCount == 1 ) { _size1 -- ; if ( prevLru != null ) prevLru . _nextLru = nextLru ; else _head1 = nextLru ; if ( nextLru != null ) nextLru . _prevLru = prevLru ; else _tail1 = prevLru ; } else { _size2 -- ; if ( prevLru != null ) prevLru . _nextLru = nextLru ; else _head2 = nextLru ; if ( nextLru != null ) nextLru . _prevLru = prevLru ; else _tail2 = prevLru ; } } value = item . _value ; break ; } prevItem = item ; } if ( _isEnableListeners && value instanceof SyncCacheListener ) ( ( SyncCacheListener ) value ) . syncRemoveEvent ( ) ; } if ( _isEnableListeners && value instanceof CacheListener ) ( ( CacheListener ) value ) . removeEvent ( ) ; return value ; } public Iterator < K > keys ( ) { KeyIterator < K , V > iter = new KeyIterator < K , V > ( this ) ; iter . init ( this ) ; return iter ; } public Iterator < K > keys ( Iterator < K > oldIter ) { KeyIterator < K , V > iter = ( KeyIterator < K , V > ) oldIter ; iter . init ( this ) ; return oldIter ; } public Iterator < V > values ( ) { ValueIterator < K , V > iter = new ValueIterator < K , V > ( this ) ; iter . init ( this ) ; return iter ; } public Iterator < V > values ( Iterator < V > oldIter ) { ValueIterator < K , V > iter = ( ValueIterator < K , V > ) oldIter ; iter . init ( this ) ; return oldIter ; } public Iterator < Entry < K , V > > iterator ( ) { return new EntryIterator ( ) ; } public long getHitCount ( ) { return _hitCount ; } public long getMissCount ( ) { return _missCount ; } static class CacheItem < K , V > { volatile CacheItem < K , V > _nextHash ; CacheItem < K , V > _prevLru ; CacheItem < K , V > _nextLru ; volatile int _lruCounter ; final K _key ; V _value ; int _index ; int _hitCount ; CacheItem ( K key , V value ) { if ( key == null ) throw new NullPointerException ( ) ; _key = key ; _value = value ; _hitCount = 1 ; } } static class KeyIterator < K , V > implements Iterator < K > { private LruCache < K , V > _cache ; private CacheItem < K , V > _item ; private boolean _isHead1 ; KeyIterator ( LruCache < K , V > cache ) { init ( cache ) ; } void init ( LruCache < K , V > cache ) { _cache = cache ; _item = _cache . _head2 ; _isHead1 = false ; if ( _item == null ) { _item = _cache . _head1 ; _isHead1 = true ; } } public boolean hasNext ( ) { return _item != null ; } public K next ( ) { CacheItem < K , V > entry = _item ; if ( _item != null ) _item = _item . _nextLru ; if ( _item == null && ! _isHead1 ) { _isHead1 = true ; _item = _cache . _head1 ; } if ( entry != null ) return entry . _key ; else return null ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } static class ValueIterator < K , V > implements Iterator < V > { private LruCache < K , V > _cache ; private CacheItem < K , V > _item ; private boolean _isHead1 ; ValueIterator ( LruCache < K , V > cache ) { init ( cache ) ; } void init ( LruCache < K , V > cache ) { _cache = cache ; _item = _cache . _head2 ; _isHead1 = false ; if ( _item == null ) { _item = _cache . _head1 ; _isHead1 = true ; } } public boolean hasNext ( ) { return _item != null ; } public V next ( ) { CacheItem < K , V > entry = _item ; if ( _item != null ) _item = _item . _nextLru ; if ( _item == null && ! _isHead1 ) { _isHead1 = true ; _item = _cache . _head1 ; } if ( entry != null ) return entry . _value ; else return null ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } public interface Entry < K , V > { public K getKey ( ) ; public V getValue ( ) ; } class EntryIterator implements Iterator < Entry < K , V > > , Entry < K , V > { private int _i = - 1 ; public boolean hasNext ( ) { int i = _i + 1 ; CacheItem < K , V > [ ] entries = _entries ; int length = entries . length ; for ( ; i < length && entries [ i ] == null ; i ++ ) { } _i = i - 1 ; return i < length ; } public Entry < K , V > next ( ) { int i = _i + 1 ; CacheItem < K , V > [ ] entries = _entries ; int length = entries . length ; for ( ; i < length && entries [ i ] == null ; i ++ ) { } _i = i ; if ( _i < length ) { return this ; } else return null ; } public K getKey ( ) { if ( _i < _entries . length ) { CacheItem < K , V > entry = _entries [ _i ] ; if ( entry == null ) return null ; else if ( entry . _key == NULL ) return null ; else return entry . _key ; } return null ; } public V getValue ( ) { if ( _i < _entries . length ) { CacheItem < K , V > entry = _entries [ _i ] ; return entry != null ? entry . _value : null ; } return null ; } public void remove ( ) { if ( _i < _entries . length ) { CacheItem < K , V > entry = _entries [ _i ] ; if ( entry != null ) LruCache . this . remove ( entry . _key ) ; } } } } 
=======
class ValidatorImpl extends Validator2 { private final ValidatorHandler2 handler ; private XMLReader cachedXMLReader = null ; private LSResourceResolver cachedResourceResolver = null ; private boolean needReset = false ; private static final String LEXICAL_HANDLER_PROPERTY = "http://xml.org/sax/properties/lexical-handler" ; public ValidatorImpl ( ValidatorHandler2 handler ) { this . handler = handler ; } public void reset ( ) { handler . reset ( ) ; needReset = false ; handler . setErrorHandler ( null ) ; handler . setResourceResolver ( null ) ; } public void validate ( Source source , Result result ) throws SAXException , IOException { if ( source == null ) throw new NullPointerException ( ) ; try { if ( source instanceof SAXSource ) { if ( result != null && ! ( result instanceof SAXResult ) ) throw new IllegalArgumentException ( ) ; doValidate ( ( SAXSource ) source , result ) ; } else if ( source instanceof StreamSource ) { if ( result != null && ! ( result instanceof StreamResult ) ) throw new IllegalArgumentException ( ) ; doValidate ( new SAXSource ( SAXSource . sourceToInputSource ( source ) ) , result ) ; } else if ( source instanceof DOMSource ) { if ( result != null && ! ( result instanceof DOMResult ) ) throw new IllegalArgumentException ( ) ; doValidate ( ( DOMSource ) source , ( DOMResult ) result ) ; } else throw new IllegalArgumentException ( "unsupported type of Source: " + source . getClass ( ) . getName ( ) ) ; } catch ( TransformerException e ) { throw new SAXException ( e ) ; } } private void doValidate ( DOMSource source , DOMResult result ) throws SAXException , IOException , TransformerException { throw new IllegalArgumentException ( ) ; } private TransformerHandler getIdentityTransformerHandler ( ) throws SAXException , TransformerConfigurationException { TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; if ( ! transformerFactory . getFeature ( SAXTransformerFactory . FEATURE ) ) throw new SAXException ( "TransformerFactory must implement SAXTransformerFactory" ) ; return ( ( SAXTransformerFactory ) transformerFactory ) . newTransformerHandler ( ) ; } private void doValidate ( SAXSource source , Result result ) throws SAXException , IOException , TransformerConfigurationException { if ( result == null ) doValidate ( source , null , null , null ) ; else if ( result instanceof SAXResult ) { SAXResult saxResult = ( SAXResult ) result ; doValidate ( source , saxResult . getHandler ( ) , saxResult . getLexicalHandler ( ) , null ) ; } else { TransformerHandler identityHandler = getIdentityTransformerHandler ( ) ; identityHandler . setResult ( result ) ; doValidate ( source , identityHandler , identityHandler , identityHandler ) ; } } private void doValidate ( SAXSource source , ContentHandler contentHandler , LexicalHandler lexicalHandler , DTDHandler dtdHandler ) throws SAXException , IOException { XMLReader xr = source . getXMLReader ( ) ; if ( xr == null ) { LSResourceResolver resourceResolver = handler . getResourceResolver ( ) ; if ( cachedXMLReader != null && cachedResourceResolver == resourceResolver ) xr = cachedXMLReader ; else { Resolver resolver = null ; if ( resourceResolver != null ) resolver = LS . createResolver ( resourceResolver ) ; xr = new SAXResolver ( resolver ) . createXMLReader ( ) ; cachedXMLReader = xr ; cachedResourceResolver = resourceResolver ; } } handler . setContentHandler ( contentHandler ) ; handler . setDTDHandler ( dtdHandler ) ; try { xr . setProperty ( LEXICAL_HANDLER_PROPERTY , lexicalHandler ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } xr . setContentHandler ( handler ) ; xr . setDTDHandler ( handler ) ; ErrorHandler eh = handler . getErrorHandler ( ) ; if ( eh == null ) eh = new DraconianErrorHandler ( ) ; xr . setErrorHandler ( eh ) ; if ( needReset ) handler . reset ( ) ; else needReset = true ; xr . parse ( source . getInputSource ( ) ) ; } public void setErrorHandler ( ErrorHandler errorHandler ) { handler . setErrorHandler ( errorHandler ) ; } public ErrorHandler getErrorHandler ( ) { return handler . getErrorHandler ( ) ; } public void setResourceResolver ( LSResourceResolver resourceResolver ) { handler . setResourceResolver ( resourceResolver ) ; } public LSResourceResolver getResourceResolver ( ) { return handler . getResourceResolver ( ) ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return handler . getFeature ( name ) ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { handler . setFeature ( name , value ) ; } public void setProperty ( String name , Object object ) throws SAXNotRecognizedException , SAXNotSupportedException { handler . setProperty ( name , object ) ; } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return handler . getProperty ( name ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
