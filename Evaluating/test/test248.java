<<<<<<< HEAD
public class PopupTableSelector { private Shell shell ; private List < IJavaElement > items ; private Object selection ; private TriggerSequence [ ] forwardTriggerSequences = null ; private TriggerSequence [ ] backwardTriggerSequences = null ; private String commandForward ; private String commandBackward ; private ILabelProvider labelProvider ; private String title = "" ; private boolean forward = true ; public PopupTableSelector ( Shell shell , List < IJavaElement > items ) { this . shell = shell ; this . items = items ; } public void setCommandBackward ( String string ) { commandBackward = string ; } public void setCommandForward ( String string ) { commandForward = string ; } public void setTitle ( String string ) { title = string ; } public void setLabelProvider ( ILabelProvider provider ) { labelProvider = provider ; } public Object select ( ) { final int MAX_ITEMS = 22 ; selection = null ; final Shell dialog = new Shell ( shell , SWT . MODELESS ) ; Display display = dialog . getDisplay ( ) ; dialog . setLayout ( new FillLayout ( ) ) ; final Table table = new Table ( dialog , SWT . SINGLE | SWT . FULL_SELECTION ) ; table . setHeaderVisible ( true ) ; table . setLinesVisible ( true ) ; TableColumn tc = new TableColumn ( table , SWT . NONE ) ; tc . setResizable ( false ) ; tc . setText ( title ) ; addItems ( table , items ) ; int tableItemCount = table . getItemCount ( ) ; switch ( tableItemCount ) { case 0 : break ; case 1 : table . setSelection ( 0 ) ; break ; default : table . setSelection ( forward ? 0 : table . getItemCount ( ) - 1 ) ; } tc . pack ( ) ; table . pack ( ) ; Rectangle tableBounds = table . getBounds ( ) ; tableBounds . height = Math . min ( tableBounds . height , table . getItemHeight ( ) * MAX_ITEMS ) ; table . setBounds ( tableBounds ) ; dialog . pack ( ) ; tc . setWidth ( table . getClientArea ( ) . width ) ; table . setFocus ( ) ; table . addFocusListener ( new FocusListener ( ) { public void focusGained ( FocusEvent e ) { } public void focusLost ( FocusEvent e ) { cancel ( dialog ) ; } } ) ; Rectangle dialogBounds = dialog . getBounds ( ) ; Rectangle displayBounds = display . getClientArea ( ) ; Rectangle parentBounds = dialog . getParent ( ) . getBounds ( ) ; dialogBounds . x = parentBounds . x + ( ( parentBounds . width - dialogBounds . width ) / 2 ) ; dialogBounds . y = parentBounds . y + ( ( parentBounds . height - dialogBounds . height ) / 2 ) ; if ( ! displayBounds . contains ( dialogBounds . x , dialogBounds . y ) || ! displayBounds . contains ( dialogBounds . x + dialogBounds . width , dialogBounds . y + dialogBounds . height ) ) { dialogBounds . x = ( displayBounds . width - dialogBounds . width ) / 2 ; dialogBounds . y = ( displayBounds . height - dialogBounds . height ) / 2 ; } dialog . setLocation ( dialogBounds . x , dialogBounds . y ) ; final IBindingService bindingService = ( IBindingService ) PlatformUI . getWorkbench ( ) . getAdapter ( IBindingService . class ) ; if ( commandForward != null ) { forwardTriggerSequences = bindingService . getActiveBindingsFor ( commandForward ) ; } if ( commandBackward != null ) { backwardTriggerSequences = bindingService . getActiveBindingsFor ( commandBackward ) ; } try { dialog . open ( ) ; addMouseListener ( table , dialog ) ; addKeyListener ( table , dialog ) ; addTraverseListener ( table ) ; while ( ! dialog . isDisposed ( ) ) if ( ! display . readAndDispatch ( ) ) display . sleep ( ) ; } finally { if ( ! dialog . isDisposed ( ) ) cancel ( dialog ) ; } return selection ; } private void addItems ( Table table , List < IJavaElement > items ) { TableItem tableItem = null ; for ( int i = 0 ; i < items . size ( ) ; ++ i ) { Object item = items . get ( i ) ; tableItem = new TableItem ( table , SWT . NONE ) ; tableItem . setText ( labelProvider . getText ( item ) ) ; tableItem . setData ( item ) ; } } private void addMouseListener ( final Table table , final Shell dialog ) { table . addMouseListener ( new MouseListener ( ) { public void mouseDoubleClick ( MouseEvent e ) { ok ( dialog , table ) ; } public void mouseDown ( MouseEvent e ) { ok ( dialog , table ) ; } public void mouseUp ( MouseEvent e ) { ok ( dialog , table ) ; } } ) ; } private final void addTraverseListener ( final Table table ) { table . addTraverseListener ( new TraverseListener ( ) { public final void keyTraversed ( final TraverseEvent event ) { event . doit = false ; } } ) ; } private void addKeyListener ( final Table table , final Shell dialog ) { table . addKeyListener ( new KeyListener ( ) { private boolean firstKey = true ; private boolean quickReleaseMode = false ; public void keyPressed ( KeyEvent e ) { int keyCode = e . keyCode ; char character = e . character ; int accelerator = SWTKeySupport . convertEventToUnmodifiedAccelerator ( e ) ; KeyStroke keyStroke = SWTKeySupport . convertAcceleratorToKeyStroke ( accelerator ) ; boolean acceleratorForward = false ; boolean acceleratorBackward = false ; if ( commandForward != null ) { if ( forwardTriggerSequences != null ) { final int forwardCount = forwardTriggerSequences . length ; for ( int i = 0 ; i < forwardCount ; i ++ ) { final TriggerSequence triggerSequence = forwardTriggerSequences [ i ] ; final Trigger [ ] triggers = triggerSequence . getTriggers ( ) ; final int triggersLength = triggers . length ; if ( ( triggersLength > 0 ) && ( triggers [ triggersLength - 1 ] . equals ( keyStroke ) ) ) { acceleratorForward = true ; break ; } } } } if ( commandBackward != null ) { if ( backwardTriggerSequences != null ) { final int backwardCount = backwardTriggerSequences . length ; for ( int i = 0 ; i < backwardCount ; i ++ ) { final TriggerSequence triggerSequence = backwardTriggerSequences [ i ] ; final Trigger [ ] triggers = triggerSequence . getTriggers ( ) ; final int triggersLength = triggers . length ; if ( ( triggersLength > 0 ) && ( triggers [ triggersLength - 1 ] . equals ( keyStroke ) ) ) { acceleratorBackward = true ; break ; } } } } if ( character == SWT . CR || character == SWT . LF ) ok ( dialog , table ) ; else if ( acceleratorForward ) { if ( firstKey && e . stateMask != 0 ) quickReleaseMode = true ; int index = table . getSelectionIndex ( ) ; table . setSelection ( ( index + 1 ) % table . getItemCount ( ) ) ; } else if ( acceleratorBackward ) { if ( firstKey && e . stateMask != 0 ) quickReleaseMode = true ; int index = table . getSelectionIndex ( ) ; table . setSelection ( index >= 1 ? index - 1 : table . getItemCount ( ) - 1 ) ; } else if ( keyCode != SWT . ALT && keyCode != SWT . COMMAND && keyCode != SWT . CTRL && keyCode != SWT . SHIFT && keyCode != SWT . ARROW_DOWN && keyCode != SWT . ARROW_UP && keyCode != SWT . ARROW_LEFT && keyCode != SWT . ARROW_RIGHT ) cancel ( dialog ) ; firstKey = false ; } public void keyReleased ( KeyEvent e ) { int keyCode = e . keyCode ; int stateMask = e . stateMask ; final IPreferencesService service = Platform . getPreferencesService ( ) ; final boolean stickyCycle = service . getBoolean ( "org.eclipse.ui.workbench" , "STICKY_CYCLE" , false , null ) ; if ( ( ! stickyCycle && ( firstKey || quickReleaseMode ) ) && keyCode == stateMask ) ok ( dialog , table ) ; } } ) ; } private void cancel ( Shell dialog ) { selection = null ; dialog . close ( ) ; } private void ok ( Shell dialog , final Table table ) { TableItem [ ] items = table . getSelection ( ) ; if ( items != null && items . length == 1 ) selection = items [ 0 ] . getData ( ) ; dialog . close ( ) ; } } 
=======
public class RewindableInputStream extends InputStream implements Rewindable { static class Block { Block next ; final byte [ ] buf ; int used = 0 ; static final int MIN_SIZE = 1024 ; Block ( int minSize ) { buf = new byte [ Math . max ( MIN_SIZE , minSize ) ] ; } Block ( ) { this ( 0 ) ; } void append ( byte b ) { buf [ used ++ ] = b ; } void append ( byte [ ] b , int off , int len ) { System . arraycopy ( b , off , buf , used , len ) ; used += len ; } } private Block head ; private int curBlockAvail ; private Block curBlock ; private int curBlockPos ; private Block lastBlock ; private boolean saving = true ; private final InputStream in ; private boolean pretendClosed = false ; private boolean eof ; public RewindableInputStream ( InputStream in ) { if ( in == null ) throw new NullPointerException ( ) ; this . in = in ; } public void close ( ) throws IOException { if ( saving ) { curBlockAvail = 0 ; curBlock = null ; pretendClosed = true ; } else { head = null ; curBlock = null ; lastBlock = null ; saving = false ; curBlockAvail = 0 ; in . close ( ) ; } } public void rewind ( ) { if ( ! saving ) throw new IllegalStateException ( "rewind() after willNotRewind()" ) ; pretendClosed = false ; if ( head == null ) return ; curBlock = head ; curBlockPos = 0 ; curBlockAvail = curBlock . used ; } public boolean canRewind ( ) { return saving ; } public void willNotRewind ( ) { saving = false ; head = null ; lastBlock = null ; if ( pretendClosed ) { pretendClosed = false ; try { in . close ( ) ; } catch ( IOException e ) { } } } public int read ( ) throws IOException { if ( curBlockAvail > 0 ) { int c = curBlock . buf [ curBlockPos ++ ] & 0xFF ; -- curBlockAvail ; if ( curBlockAvail == 0 ) { curBlock = curBlock . next ; if ( curBlock != null ) { curBlockPos = 0 ; curBlockAvail = curBlock . used ; } } return c ; } int c = in . read ( ) ; if ( saving && c != - 1 ) { if ( lastBlock == null ) lastBlock = head = new Block ( ) ; else if ( lastBlock . used == lastBlock . buf . length ) lastBlock = lastBlock . next = new Block ( ) ; lastBlock . append ( ( byte ) c ) ; } return c ; } public int read ( byte b [ ] , int off , int len ) throws IOException { if ( curBlockAvail == 0 && ! saving ) return in . read ( b , off , len ) ; if ( b == null ) throw new NullPointerException ( ) ; if ( len < 0 ) throw new IndexOutOfBoundsException ( ) ; int nRead = 0 ; if ( curBlockAvail != 0 ) { for ( ; ; ) { if ( len == 0 ) return nRead ; b [ off ++ ] = curBlock . buf [ curBlockPos ++ ] ; -- len ; nRead ++ ; -- curBlockAvail ; if ( curBlockAvail == 0 ) { curBlock = curBlock . next ; if ( curBlock == null ) break ; curBlockAvail = curBlock . used ; curBlockPos = 0 ; } } } if ( len == 0 ) return nRead ; if ( eof ) return nRead > 0 ? nRead : - 1 ; try { int n = in . read ( b , off , len ) ; if ( n < 0 ) { eof = true ; return nRead > 0 ? nRead : - 1 ; } nRead += n ; if ( saving ) { if ( lastBlock == null ) lastBlock = head = new Block ( n ) ; else if ( lastBlock . buf . length - lastBlock . used < n ) { if ( lastBlock . used != lastBlock . buf . length ) { int free = lastBlock . buf . length - lastBlock . used ; lastBlock . append ( b , off , free ) ; off += free ; n -= free ; } lastBlock = lastBlock . next = new Block ( n ) ; } lastBlock . append ( b , off , n ) ; } } catch ( IOException e ) { eof = true ; if ( nRead == 0 ) throw e ; } return nRead ; } public int available ( ) throws IOException { if ( curBlockAvail == 0 ) return in . available ( ) ; int n = curBlockAvail ; for ( Block b = curBlock . next ; b != null ; b = b . next ) n += b . used ; return n + in . available ( ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
