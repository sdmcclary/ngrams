public class BenchmarkWorker implements Runnable { private byte [ ] buffer = new byte [ 4096 ] ; private final int verbosity ; private final HttpParams params ; private final HttpContext context ; private final BasicHttpProcessor httpProcessor ; private final HttpRequestExecutor httpexecutor ; private final ConnectionReuseStrategy connstrategy ; private final HttpHost targetHost ; private final int count ; private final boolean keepalive ; private final Stats stats = new Stats ( ) ; private final RequestGenerator requestGenerator ; public BenchmarkWorker ( final HttpParams params , int verbosity , final RequestGenerator requestGenerator , final HttpHost targetHost , int count , boolean keepalive ) { super ( ) ; this . params = params ; this . requestGenerator = requestGenerator ; this . context = new BasicHttpContext ( null ) ; this . targetHost = targetHost ; this . count = count ; this . keepalive = keepalive ; this . httpProcessor = new BasicHttpProcessor ( ) ; this . httpexecutor = new HttpRequestExecutor ( ) ; this . httpProcessor . addInterceptor ( new RequestContent ( ) ) ; this . httpProcessor . addInterceptor ( new RequestTargetHost ( ) ) ; this . httpProcessor . addInterceptor ( new RequestConnControl ( ) ) ; this . httpProcessor . addInterceptor ( new RequestUserAgent ( ) ) ; this . httpProcessor . addInterceptor ( new RequestExpectContinue ( ) ) ; this . connstrategy = new DefaultConnectionReuseStrategy ( ) ; this . verbosity = verbosity ; } public void run ( ) { HttpResponse response = null ; DefaultHttpClientConnection conn = new DefaultHttpClientConnection ( ) ; String hostname = targetHost . getHostName ( ) ; int port = targetHost . getPort ( ) ; if ( port == - 1 ) { port = 80 ; } this . context . setAttribute ( ExecutionContext . HTTP_CONNECTION , conn ) ; this . context . setAttribute ( ExecutionContext . HTTP_TARGET_HOST , this . targetHost ) ; stats . start ( ) ; for ( int i = 0 ; i < count ; i ++ ) { try { HttpRequest req = requestGenerator . generateRequest ( count ) ; if ( ! conn . isOpen ( ) ) { Socket socket = null ; if ( "https" . equals ( targetHost . getSchemeName ( ) ) ) { SocketFactory socketFactory = SSLSocketFactory . getDefault ( ) ; socket = socketFactory . createSocket ( hostname , port ) ; } else { socket = new Socket ( hostname , port ) ; } conn . bind ( socket , params ) ; } try { this . httpexecutor . preProcess ( req , this . httpProcessor , this . context ) ; response = this . httpexecutor . execute ( req , conn , this . context ) ; this . httpexecutor . postProcess ( response , this . httpProcessor , this . context ) ; } catch ( HttpException e ) { stats . incWriteErrors ( ) ; if ( this . verbosity >= 2 ) { System . err . println ( "Failed HTTP request : " + e . getMessage ( ) ) ; } continue ; } verboseOutput ( req , response ) ; if ( response . getStatusLine ( ) . getStatusCode ( ) == HttpStatus . SC_OK ) { stats . incSuccessCount ( ) ; } else { stats . incFailureCount ( ) ; continue ; } HttpEntity entity = response . getEntity ( ) ; String charset = EntityUtils . getContentCharSet ( entity ) ; if ( charset == null ) { charset = HTTP . DEFAULT_CONTENT_CHARSET ; } long contentlen = 0 ; if ( entity != null ) { InputStream instream = entity . getContent ( ) ; int l = 0 ; while ( ( l = instream . read ( this . buffer ) ) != - 1 ) { stats . incTotalBytesRecv ( l ) ; contentlen += l ; if ( this . verbosity >= 4 ) { String s = new String ( this . buffer , 0 , l , charset ) ; System . out . print ( s ) ; } } instream . close ( ) ; } if ( this . verbosity >= 4 ) { System . out . println ( ) ; System . out . println ( ) ; } if ( ! keepalive || ! this . connstrategy . keepAlive ( response , this . context ) ) { conn . close ( ) ; } stats . setContentLength ( contentlen ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; stats . incFailureCount ( ) ; if ( this . verbosity >= 2 ) { System . err . println ( "I/O error: " + ex . getMessage ( ) ) ; } } } stats . finish ( ) ; if ( response != null ) { Header header = response . getFirstHeader ( "Server" ) ; if ( header != null ) { stats . setServerName ( header . getValue ( ) ) ; } } try { conn . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; stats . incFailureCount ( ) ; if ( this . verbosity >= 2 ) { System . err . println ( "I/O error: " + ex . getMessage ( ) ) ; } } } private void verboseOutput ( HttpRequest request , HttpResponse response ) { if ( this . verbosity >= 3 ) { System . out . println ( ">> " + request . getRequestLine ( ) . toString ( ) ) ; Header [ ] headers = request . getAllHeaders ( ) ; for ( int h = 0 ; h < headers . length ; h ++ ) { System . out . println ( ">> " + headers [ h ] . toString ( ) ) ; } System . out . println ( ) ; } if ( this . verbosity >= 2 ) { System . out . println ( response . getStatusLine ( ) . getStatusCode ( ) ) ; } if ( this . verbosity >= 3 ) { System . out . println ( "<< " + response . getStatusLine ( ) . toString ( ) ) ; Header [ ] headers = response . getAllHeaders ( ) ; for ( int h = 0 ; h < headers . length ; h ++ ) { System . out . println ( "<< " + headers [ h ] . toString ( ) ) ; } System . out . println ( ) ; } } public Stats getStats ( ) { return stats ; } } 