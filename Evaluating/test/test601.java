<<<<<<< HEAD
public class JSASTHandler extends JSAbstractHandler { private List < JSParseNode > _statements ; public JSASTHandler ( ) { super ( ) ; this . _statements = new ArrayList < JSParseNode > ( ) ; } public void afterParse ( IParseState parseState , IParseNode parentNode ) { if ( parentNode != null ) { Object [ ] results = this . getValues ( ) ; if ( results != null && results . length > 0 ) { Object result = results [ 0 ] ; if ( result instanceof ParseFragment ) { parentNode . appendChild ( ( ParseFragment ) result ) ; } } } this . _statements . clear ( ) ; super . afterParse ( parseState , parentNode ) ; } protected Object onAddArgument ( Object [ ] nodes ) { ParseFragment arguments = ( ParseFragment ) nodes [ 0 ] ; JSParseNode argument = ( JSParseNode ) nodes [ 2 ] ; arguments . appendChild ( argument ) ; return arguments ; } protected Object onAddCaseClause ( Object [ ] nodes ) { ParseFragment clauses = ( ParseFragment ) nodes [ 0 ] ; JSParseNode clause = ( JSParseNode ) nodes [ 1 ] ; clauses . appendChild ( clause ) ; return clauses ; } protected Object onAddElement ( Object [ ] nodes ) { ParseFragment elements = ( ParseFragment ) nodes [ 0 ] ; JSParseNode element = ( JSParseNode ) nodes [ 2 ] ; elements . appendChild ( element ) ; return elements ; } protected Object onAddElidedElement ( Object [ ] nodes ) { ParseFragment elements = ( ParseFragment ) nodes [ 0 ] ; ParseFragment elisions = ( ParseFragment ) nodes [ 2 ] ; JSParseNode element = ( JSParseNode ) nodes [ 3 ] ; elements . appendChild ( elisions ) ; elements . appendChild ( element ) ; return elements ; } protected Object onAddElision ( Object [ ] nodes ) { JSParseNode nullNode = this . createNode ( JSParseNodeTypes . NULL , null ) ; ParseFragment elisions = ( ParseFragment ) nodes [ 0 ] ; elisions . appendChild ( nullNode ) ; return elisions ; } protected Object onAddParameter ( Object [ ] nodes ) { JSParseNode parameters = ( JSParseNode ) nodes [ 0 ] ; Lexeme name = ( Lexeme ) nodes [ 2 ] ; JSParseNode identifier = this . createNode ( JSParseNodeTypes . IDENTIFIER , name ) ; parameters . appendChild ( identifier ) ; return parameters ; } protected Object onAddProperty ( Object [ ] nodes ) { ParseFragment properties = ( ParseFragment ) nodes [ 0 ] ; Lexeme identifier = ( Lexeme ) nodes [ 2 ] ; JSParseNode name = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode value = ( JSParseNode ) nodes [ 4 ] ; JSParseNode property = this . createNode ( JSParseNodeTypes . NAME_VALUE_PAIR , null ) ; property . appendChild ( name ) ; property . appendChild ( value ) ; properties . appendChild ( property ) ; return properties ; } protected Object onAddSourceElement ( Object [ ] nodes ) { ParseFragment fragment = ( ParseFragment ) nodes [ 0 ] ; JSParseNode element = ( JSParseNode ) nodes [ 1 ] ; fragment . appendChild ( element ) ; return fragment ; } protected Object onAddStatement ( Object [ ] nodes ) { JSParseNode statements = ( JSParseNode ) nodes [ 0 ] ; JSParseNode statement = ( JSParseNode ) nodes [ 1 ] ; statements . appendChild ( statement ) ; return statements ; } protected Object onAddVarDeclaration ( Object [ ] nodes ) { ParseFragment declarations = ( ParseFragment ) nodes [ 0 ] ; JSParseNode declaration = ( JSParseNode ) nodes [ 2 ] ; declarations . appendChild ( declaration ) ; return declarations ; } protected Object onArguments ( Object [ ] nodes ) { Lexeme lparen = ( Lexeme ) nodes [ 0 ] ; ParseFragment arguments = ( ParseFragment ) nodes [ 1 ] ; Lexeme rparen = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . ARGUMENTS , lparen ) ; result . appendChild ( arguments ) ; result . includeLexemeInRange ( rparen ) ; return result ; } protected Object onArrayLiteral ( Object [ ] nodes ) { Lexeme lbracket = ( Lexeme ) nodes [ 0 ] ; ParseFragment elements = ( ParseFragment ) nodes [ 1 ] ; Lexeme rbracket = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . ARRAY_LITERAL , lbracket ) ; result . appendChild ( elements ) ; result . includeLexemeInRange ( rbracket ) ; return result ; } protected Object onArrayLiteralTrailingComma ( Object [ ] nodes ) { Lexeme lbracket = ( Lexeme ) nodes [ 0 ] ; ParseFragment elements = ( ParseFragment ) nodes [ 1 ] ; JSParseNode nullNode = this . createNode ( JSParseNodeTypes . NULL , null ) ; Lexeme rbracket = ( Lexeme ) nodes [ 3 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . ARRAY_LITERAL , lbracket ) ; result . appendChild ( elements ) ; result . appendChild ( nullNode ) ; result . includeLexemeInRange ( rbracket ) ; return result ; } protected Object onArrayLiteralTrailingElision ( Object [ ] nodes ) { Lexeme lbracket = ( Lexeme ) nodes [ 0 ] ; ParseFragment elements = ( ParseFragment ) nodes [ 1 ] ; ParseFragment elisions = ( ParseFragment ) nodes [ 3 ] ; Lexeme rbracket = ( Lexeme ) nodes [ 4 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . ARRAY_LITERAL , lbracket ) ; result . appendChild ( elements ) ; result . appendChild ( elisions ) ; result . includeLexemeInRange ( rbracket ) ; return result ; } protected Object onAssignmentExpression ( Object [ ] nodes ) { JSParseNode lhs = ( JSParseNode ) nodes [ 0 ] ; Lexeme operator = ( Lexeme ) nodes [ 1 ] ; JSParseNode rhs = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result ; switch ( operator . typeIndex ) { case JSTokenTypes . EQUAL : result = this . createNode ( JSParseNodeTypes . ASSIGN , operator ) ; break ; case JSTokenTypes . STAR_EQUAL : result = this . createNode ( JSParseNodeTypes . MULTIPLY_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . FORWARD_SLASH_EQUAL : result = this . createNode ( JSParseNodeTypes . DIVIDE_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . PERCENT_EQUAL : result = this . createNode ( JSParseNodeTypes . MOD_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . PLUS_EQUAL : result = this . createNode ( JSParseNodeTypes . ADD_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . MINUS_EQUAL : result = this . createNode ( JSParseNodeTypes . SUBTRACT_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . LESS_LESS_EQUAL : result = this . createNode ( JSParseNodeTypes . SHIFT_LEFT_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . GREATER_GREATER_EQUAL : result = this . createNode ( JSParseNodeTypes . SHIFT_RIGHT_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . GREATER_GREATER_GREATER_EQUAL : result = this . createNode ( JSParseNodeTypes . ARITHMETIC_SHIFT_RIGHT_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . AMPERSAND_EQUAL : result = this . createNode ( JSParseNodeTypes . BITWISE_AND_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . CARET_EQUAL : result = this . createNode ( JSParseNodeTypes . BITWISE_XOR_AND_ASSIGN , operator ) ; break ; case JSTokenTypes . PIPE_EQUAL : result = this . createNode ( JSParseNodeTypes . BITWISE_OR_AND_ASSIGN , operator ) ; break ; default : throw new IllegalArgumentException ( MessageFormat . format ( Messages . JSASTHandler_Unknown_operator_0 , operator ) ) ; } result . appendChild ( lhs ) ; result . appendChild ( rhs ) ; return result ; } protected Object onBinaryExpression ( Object [ ] nodes ) { JSParseNode lhs = ( JSParseNode ) nodes [ 0 ] ; Lexeme operator = ( Lexeme ) nodes [ 1 ] ; JSParseNode rhs = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result ; switch ( operator . typeIndex ) { case JSTokenTypes . STAR : result = this . createNode ( JSParseNodeTypes . MULTIPLY , operator ) ; break ; case JSTokenTypes . FORWARD_SLASH : result = this . createNode ( JSParseNodeTypes . DIVIDE , operator ) ; break ; case JSTokenTypes . PERCENT : result = this . createNode ( JSParseNodeTypes . MOD , operator ) ; break ; case JSTokenTypes . MINUS : result = this . createNode ( JSParseNodeTypes . SUBTRACT , operator ) ; break ; case JSTokenTypes . PLUS : result = this . createNode ( JSParseNodeTypes . ADD , operator ) ; break ; case JSTokenTypes . LESS_LESS : result = this . createNode ( JSParseNodeTypes . SHIFT_LEFT , operator ) ; break ; case JSTokenTypes . GREATER_GREATER : result = this . createNode ( JSParseNodeTypes . SHIFT_RIGHT , operator ) ; break ; case JSTokenTypes . GREATER_GREATER_GREATER : result = this . createNode ( JSParseNodeTypes . ARITHMETIC_SHIFT_RIGHT , operator ) ; break ; case JSTokenTypes . LESS : result = this . createNode ( JSParseNodeTypes . LESS_THAN , operator ) ; break ; case JSTokenTypes . GREATER : result = this . createNode ( JSParseNodeTypes . GREATER_THAN , operator ) ; break ; case JSTokenTypes . LESS_EQUAL : result = this . createNode ( JSParseNodeTypes . LESS_THAN_OR_EQUAL , operator ) ; break ; case JSTokenTypes . GREATER_EQUAL : result = this . createNode ( JSParseNodeTypes . GREATER_THAN_OR_EQUAL , operator ) ; break ; case JSTokenTypes . INSTANCEOF : result = this . createNode ( JSParseNodeTypes . INSTANCE_OF , operator ) ; break ; case JSTokenTypes . IN : result = this . createNode ( JSParseNodeTypes . IN , operator ) ; break ; case JSTokenTypes . EQUAL_EQUAL : result = this . createNode ( JSParseNodeTypes . EQUAL , operator ) ; break ; case JSTokenTypes . EXCLAMATION_EQUAL : result = this . createNode ( JSParseNodeTypes . NOT_EQUAL , operator ) ; break ; case JSTokenTypes . EQUAL_EQUAL_EQUAL : result = this . createNode ( JSParseNodeTypes . IDENTITY , operator ) ; break ; case JSTokenTypes . EXCLAMATION_EQUAL_EQUAL : result = this . createNode ( JSParseNodeTypes . NOT_IDENTITY , operator ) ; break ; case JSTokenTypes . AMPERSAND : result = this . createNode ( JSParseNodeTypes . BITWISE_AND , operator ) ; break ; case JSTokenTypes . CARET : result = this . createNode ( JSParseNodeTypes . BITWISE_XOR , operator ) ; break ; case JSTokenTypes . PIPE : result = this . createNode ( JSParseNodeTypes . BITWISE_OR , operator ) ; break ; case JSTokenTypes . AMPERSAND_AMPERSAND : result = this . createNode ( JSParseNodeTypes . LOGICAL_AND , operator ) ; break ; case JSTokenTypes . PIPE_PIPE : result = this . createNode ( JSParseNodeTypes . LOGICAL_OR , operator ) ; break ; default : throw new IllegalArgumentException ( MessageFormat . format ( Messages . JSASTHandler_Unknown_operator_0 , operator ) ) ; } result . appendChild ( lhs ) ; result . appendChild ( rhs ) ; return result ; } protected Object onBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 2 ] ; JSParseNode statements = ( JSParseNode ) nodes [ 1 ] ; statements . includeLexemesInRange ( lcurly , rcurly ) ; return statements ; } protected Object onBreak ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 1 ] ; JSParseNode label = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . BREAK , keyword ) ; result . appendChild ( label ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onBreakLabel ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme identifier = ( Lexeme ) nodes [ 1 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 2 ] ; JSParseNode label = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . BREAK , keyword ) ; result . appendChild ( label ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onCallExpression ( Object [ ] nodes ) { JSParseNode expression = ( JSParseNode ) nodes [ 0 ] ; JSParseNode arguments = ( JSParseNode ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . INVOKE , null ) ; result . appendChild ( expression ) ; result . appendChild ( arguments ) ; return result ; } protected Object onCaseClause ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; JSParseNode statements = ( JSParseNode ) nodes [ 3 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . CASE , keyword ) ; result . appendChild ( expression ) ; for ( int i = 0 ; i < statements . getChildCount ( ) ; i ++ ) { result . appendChild ( statements . getChild ( i ) ) ; } return result ; } protected Object onCasesAndDefaultBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; ParseFragment cases = ( ParseFragment ) nodes [ 1 ] ; JSParseNode defaultClause = ( JSParseNode ) nodes [ 2 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 3 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( cases ) ; result . appendChild ( defaultClause ) ; result . includeLexemesInRange ( lcurly , rcurly ) ; return result ; } protected Object onCasesBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; ParseFragment cases = ( ParseFragment ) nodes [ 1 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 2 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( cases ) ; result . includeLexemesInRange ( lcurly , rcurly ) ; return result ; } protected Object onCasesDefaultCasesBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; ParseFragment cases1 = ( ParseFragment ) nodes [ 1 ] ; JSParseNode defaultClause = ( JSParseNode ) nodes [ 2 ] ; ParseFragment cases2 = ( ParseFragment ) nodes [ 3 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 4 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( cases1 ) ; result . appendChild ( defaultClause ) ; result . appendChild ( cases2 ) ; result . includeLexemesInRange ( lcurly , rcurly ) ; return result ; } protected Object onCatch ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme identifier = ( Lexeme ) nodes [ 2 ] ; JSParseNode name = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode body = ( JSParseNode ) nodes [ 4 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . CATCH , keyword ) ; result . appendChild ( name ) ; result . appendChild ( body ) ; return result ; } protected Object onCommaExpression ( Object [ ] nodes ) { JSParseNode lhs = ( JSParseNode ) nodes [ 0 ] ; JSParseNode rhs = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . COMMA , null ) ; result . appendChild ( lhs ) ; result . appendChild ( rhs ) ; return result ; } protected Object onConditionalExpression ( Object [ ] nodes ) { JSParseNode condition = ( JSParseNode ) nodes [ 0 ] ; JSParseNode trueCase = ( JSParseNode ) nodes [ 2 ] ; JSParseNode falseCase = ( JSParseNode ) nodes [ 4 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . CONDITIONAL , null ) ; result . appendChild ( condition ) ; result . appendChild ( trueCase ) ; result . appendChild ( falseCase ) ; return result ; } protected Object onContinue ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 1 ] ; JSParseNode label = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . CONTINUE , keyword ) ; result . appendChild ( label ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onContinueLabel ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme identifier = ( Lexeme ) nodes [ 1 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 2 ] ; JSParseNode label = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . CONTINUE , keyword ) ; result . appendChild ( label ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onDefaultAndCasesBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; JSParseNode defaultClause = ( JSParseNode ) nodes [ 1 ] ; ParseFragment cases = ( ParseFragment ) nodes [ 2 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 3 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( defaultClause ) ; result . appendChild ( cases ) ; result . includeLexemesInRange ( lcurly , rcurly ) ; return result ; } protected Object onDefaultBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; JSParseNode defaultClause = ( JSParseNode ) nodes [ 1 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 2 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( defaultClause ) ; result . includeLexemesInRange ( lcurly , rcurly ) ; return result ; } protected Object onDefaultClause ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode statements = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . DEFAULT , keyword ) ; for ( int i = 0 ; i < statements . getChildCount ( ) ; i ++ ) { result . appendChild ( statements . getChild ( i ) ) ; } return result ; } protected Object onDoStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode body = ( JSParseNode ) nodes [ 1 ] ; JSParseNode condition = ( JSParseNode ) nodes [ 4 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 5 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . DO , keyword ) ; result . appendChild ( body ) ; result . appendChild ( condition ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onElidedArray ( Object [ ] nodes ) { Lexeme lbracket = ( Lexeme ) nodes [ 0 ] ; ParseFragment elisions = ( ParseFragment ) nodes [ 1 ] ; Lexeme rbracket = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . ARRAY_LITERAL , lbracket ) ; result . appendChild ( elisions ) ; result . includeLexemeInRange ( rbracket ) ; return result ; } protected Object onEmptyArguments ( Object [ ] nodes ) { Lexeme lparen = ( Lexeme ) nodes [ 0 ] ; Lexeme rparen = ( Lexeme ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . ARGUMENTS , lparen ) ; result . includeLexemeInRange ( rparen ) ; return result ; } protected Object onEmptyArray ( Object [ ] nodes ) { Lexeme lbracket = ( Lexeme ) nodes [ 0 ] ; Lexeme rbracket = ( Lexeme ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . ARRAY_LITERAL , lbracket ) ; result . includeLexemeInRange ( rbracket ) ; return result ; } protected Object onEmptyBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . STATEMENTS , lcurly ) ; result . includeLexemeInRange ( rcurly ) ; return result ; } protected Object onEmptyCaseBlock ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 1 ] ; ParseFragment result = new ParseFragment ( ) ; result . includeLexemesInRange ( lcurly , rcurly ) ; return result ; } protected Object onEmptyCaseClause ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; Lexeme colon = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . CASE , keyword ) ; result . appendChild ( expression ) ; result . includeLexemeInRange ( colon ) ; return result ; } protected Object onEmptyDefaultClause ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme colon = ( Lexeme ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . DEFAULT , keyword ) ; result . includeLexemeInRange ( colon ) ; return result ; } protected Object onEmptyFunctionBody ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . STATEMENTS , lcurly ) ; result . includeLexemeInRange ( rcurly ) ; return result ; } protected Object onEmptyObject ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . OBJECT_LITERAL , lcurly ) ; result . includeLexemeInRange ( rcurly ) ; return result ; } protected Object onEmptyParameterList ( Object [ ] nodes ) { Lexeme lparen = ( Lexeme ) nodes [ 0 ] ; Lexeme rparen = ( Lexeme ) nodes [ 1 ] ; JSParseNode params = this . createNode ( JSParseNodeTypes . EMPTY , lparen ) ; params . includeLexemeInRange ( rparen ) ; return params ; } protected Object onEmptyStatement ( Object [ ] nodes ) { Lexeme semicolon = ( Lexeme ) nodes [ 0 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . EMPTY , semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onExpressionStatement ( Object [ ] nodes ) { JSParseNode expression = ( JSParseNode ) nodes [ 0 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 1 ] ; expression . includeLexemeInRange ( semicolon ) ; expression . setIncludesSemicolon ( true ) ; return expression ; } protected Object onFalse ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; return this . createNode ( JSParseNodeTypes . FALSE , keyword ) ; } protected Object onFinally ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode body = ( JSParseNode ) nodes [ 1 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FINALLY , keyword ) ; result . appendChild ( body ) ; return result ; } protected Object onFirstArgument ( Object [ ] nodes ) { JSParseNode argument = ( JSParseNode ) nodes [ 0 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( argument ) ; return result ; } protected Object onFirstCaseClause ( Object [ ] nodes ) { JSParseNode clause = ( JSParseNode ) nodes [ 0 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( clause ) ; return result ; } protected Object onFirstElement ( Object [ ] nodes ) { JSParseNode element = ( JSParseNode ) nodes [ 0 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( element ) ; return result ; } protected Object onFirstElidedElement ( Object [ ] nodes ) { ParseFragment elisions = ( ParseFragment ) nodes [ 0 ] ; JSParseNode element = ( JSParseNode ) nodes [ 1 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( elisions ) ; result . appendChild ( element ) ; return result ; } protected Object onFirstElision ( Object [ ] nodes ) { JSParseNode nullNode = this . createNode ( JSParseNodeTypes . NULL , null ) ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( nullNode ) ; return result ; } protected Object onFirstParameter ( Object [ ] nodes ) { Lexeme name = ( Lexeme ) nodes [ 0 ] ; JSParseNode identifier = this . createNode ( JSParseNodeTypes . IDENTIFIER , name ) ; JSParseNode parameters = this . createNode ( JSParseNodeTypes . PARAMETERS , name ) ; parameters . appendChild ( identifier ) ; return parameters ; } protected Object onFirstProperty ( Object [ ] nodes ) { Lexeme identifier = ( Lexeme ) nodes [ 0 ] ; JSParseNode name = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode value = ( JSParseNode ) nodes [ 2 ] ; JSParseNode property = this . createNode ( JSParseNodeTypes . NAME_VALUE_PAIR , null ) ; property . appendChild ( name ) ; property . appendChild ( value ) ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( property ) ; return result ; } protected Object onFirstSourceElement ( Object [ ] nodes ) { ParseFragment fragment = new ParseFragment ( ) ; JSParseNode element = ( JSParseNode ) nodes [ 0 ] ; fragment . appendChild ( element ) ; return fragment ; } protected Object onFirstStatement ( Object [ ] nodes ) { JSParseNode statement = ( JSParseNode ) nodes [ 0 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . STATEMENTS , null ) ; result . appendChild ( statement ) ; return result ; } protected Object onFirstVarDeclaration ( Object [ ] nodes ) { JSParseNode declaration = ( JSParseNode ) nodes [ 0 ] ; ParseFragment result = new ParseFragment ( ) ; result . appendChild ( declaration ) ; return result ; } protected Object onForAdvanceOnlyStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode condition = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode advance = ( JSParseNode ) nodes [ 4 ] ; JSParseNode body = ( JSParseNode ) nodes [ 6 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForBodyOnlyStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode condition = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode advance = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode body = ( JSParseNode ) nodes [ 5 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForConditionOnlyStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode condition = ( JSParseNode ) nodes [ 3 ] ; JSParseNode advance = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode body = ( JSParseNode ) nodes [ 6 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForInitializeOnlyStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = ( JSParseNode ) nodes [ 2 ] ; JSParseNode condition = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode advance = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode body = ( JSParseNode ) nodes [ 6 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForInStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = ( JSParseNode ) nodes [ 2 ] ; JSParseNode object = ( JSParseNode ) nodes [ 4 ] ; JSParseNode body = ( JSParseNode ) nodes [ 6 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR_IN , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( object ) ; result . appendChild ( body ) ; return result ; } protected Object onForNoAdvanceStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = ( JSParseNode ) nodes [ 2 ] ; JSParseNode condition = ( JSParseNode ) nodes [ 4 ] ; JSParseNode advance = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode body = ( JSParseNode ) nodes [ 7 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForNoConditionStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = ( JSParseNode ) nodes [ 2 ] ; JSParseNode condition = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode advance = ( JSParseNode ) nodes [ 5 ] ; JSParseNode body = ( JSParseNode ) nodes [ 7 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForNoInitializeStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode condition = ( JSParseNode ) nodes [ 3 ] ; JSParseNode advance = ( JSParseNode ) nodes [ 5 ] ; JSParseNode body = ( JSParseNode ) nodes [ 7 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode initialize = ( JSParseNode ) nodes [ 2 ] ; JSParseNode condition = ( JSParseNode ) nodes [ 4 ] ; JSParseNode advance = ( JSParseNode ) nodes [ 6 ] ; JSParseNode body = ( JSParseNode ) nodes [ 8 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForVarInitializeOnlyStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; ParseFragment declarations = ( ParseFragment ) nodes [ 3 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . VAR , null ) ; initialize . appendChild ( declarations ) ; JSParseNode condition = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode advance = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode body = ( JSParseNode ) nodes [ 7 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForVarInStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; ParseFragment declarations = ( ParseFragment ) nodes [ 3 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . VAR , null ) ; initialize . appendChild ( declarations ) ; JSParseNode object = ( JSParseNode ) nodes [ 5 ] ; JSParseNode body = ( JSParseNode ) nodes [ 7 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR_IN , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( object ) ; result . appendChild ( body ) ; return result ; } protected Object onForVarNoAdvanceStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; ParseFragment declarations = ( ParseFragment ) nodes [ 3 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . VAR , null ) ; initialize . appendChild ( declarations ) ; JSParseNode condition = ( JSParseNode ) nodes [ 5 ] ; JSParseNode advance = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode body = ( JSParseNode ) nodes [ 8 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForVarNoConditionStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; ParseFragment declarations = ( ParseFragment ) nodes [ 3 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . VAR , null ) ; initialize . appendChild ( declarations ) ; JSParseNode condition = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode advance = ( JSParseNode ) nodes [ 6 ] ; JSParseNode body = ( JSParseNode ) nodes [ 8 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onForVarStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; ParseFragment declarations = ( ParseFragment ) nodes [ 3 ] ; JSParseNode initialize = this . createNode ( JSParseNodeTypes . VAR , null ) ; initialize . appendChild ( declarations ) ; JSParseNode condition = ( JSParseNode ) nodes [ 5 ] ; JSParseNode advance = ( JSParseNode ) nodes [ 7 ] ; JSParseNode body = ( JSParseNode ) nodes [ 9 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . FOR , keyword ) ; result . appendChild ( initialize ) ; result . appendChild ( condition ) ; result . appendChild ( advance ) ; result . appendChild ( body ) ; return result ; } protected Object onFunctionBody ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; ParseFragment statements = ( ParseFragment ) nodes [ 1 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . STATEMENTS , lcurly ) ; result . appendChild ( statements ) ; result . includeLexemeInRange ( rcurly ) ; return result ; } protected Object onFunctionDeclaration ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme name = ( Lexeme ) nodes [ 1 ] ; JSParseNode params = ( JSParseNode ) nodes [ 2 ] ; JSParseNode body = ( JSParseNode ) nodes [ 3 ] ; JSFunctionNode result = ( JSFunctionNode ) this . createNode ( JSParseNodeTypes . FUNCTION , keyword ) ; result . appendChild ( params ) ; result . appendChild ( body ) ; result . setAttribute ( "name" , name . getText ( ) ) ; return result ; } protected Object onFunctionExpression ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode params = ( JSParseNode ) nodes [ 1 ] ; JSParseNode body = ( JSParseNode ) nodes [ 2 ] ; JSFunctionNode result = ( JSFunctionNode ) this . createNode ( JSParseNodeTypes . FUNCTION , keyword ) ; result . appendChild ( params ) ; result . appendChild ( body ) ; return result ; } protected Object onGetElement ( Object [ ] nodes ) { JSParseNode expression = ( JSParseNode ) nodes [ 0 ] ; Lexeme lbrace = ( Lexeme ) nodes [ 1 ] ; JSParseNode indexExpression = ( JSParseNode ) nodes [ 2 ] ; Lexeme rbrace = ( Lexeme ) nodes [ 3 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . GET_ELEMENT , lbrace ) ; result . appendChild ( expression ) ; result . appendChild ( indexExpression ) ; result . includeLexemeInRange ( rbrace ) ; return result ; } protected Object onGetProperty ( Object [ ] nodes ) { JSParseNode expression = ( JSParseNode ) nodes [ 0 ] ; Lexeme dot = ( Lexeme ) nodes [ 1 ] ; Lexeme identifier = ( Lexeme ) nodes [ 2 ] ; JSParseNode name = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . GET_PROPERTY , dot ) ; result . appendChild ( expression ) ; result . appendChild ( name ) ; return result ; } protected Object onGroupExpression ( Object [ ] nodes ) { Lexeme lparen = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; Lexeme rparen = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . GROUP , lparen ) ; result . appendChild ( expression ) ; result . includeLexemeInRange ( rparen ) ; return result ; } protected Object onIdentifier ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; return this . createNode ( JSParseNodeTypes . IDENTIFIER , keyword ) ; } protected Object onIfElseStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode condition = ( JSParseNode ) nodes [ 2 ] ; JSParseNode trueCase = ( JSParseNode ) nodes [ 4 ] ; JSParseNode falseCase = ( JSParseNode ) nodes [ 6 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . IF , keyword ) ; result . appendChild ( condition ) ; result . appendChild ( trueCase ) ; result . appendChild ( falseCase ) ; return result ; } protected Object onIfStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode condition = ( JSParseNode ) nodes [ 2 ] ; JSParseNode trueCase = ( JSParseNode ) nodes [ 4 ] ; JSParseNode falseCase = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . IF , keyword ) ; result . appendChild ( condition ) ; result . appendChild ( trueCase ) ; result . appendChild ( falseCase ) ; return result ; } protected Object onLabelledStatement ( Object [ ] nodes ) { Lexeme identifier = ( Lexeme ) nodes [ 0 ] ; JSParseNode label = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode statement = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . LABELLED , null ) ; result . appendChild ( label ) ; result . appendChild ( statement ) ; return result ; } protected Object onNewExpression ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; JSParseNode arguments = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . CONSTRUCT , keyword ) ; result . appendChild ( expression ) ; result . appendChild ( arguments ) ; return result ; } protected Object onNewExpressionWithoutArguments ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; JSParseNode arguments = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . CONSTRUCT , keyword ) ; result . appendChild ( expression ) ; result . appendChild ( arguments ) ; return result ; } protected Object onNull ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; return this . createNode ( JSParseNodeTypes . NULL , keyword ) ; } protected Object onNumber ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; return this . createNode ( JSParseNodeTypes . NUMBER , keyword ) ; } protected Object onObjectLiteral ( Object [ ] nodes ) { Lexeme lcurly = ( Lexeme ) nodes [ 0 ] ; ParseFragment properties = ( ParseFragment ) nodes [ 1 ] ; Lexeme rcurly = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . OBJECT_LITERAL , lcurly ) ; result . appendChild ( properties ) ; result . includeLexemeInRange ( rcurly ) ; return result ; } protected Object onParameterList ( Object [ ] nodes ) { Lexeme lparen = ( Lexeme ) nodes [ 0 ] ; JSParseNode params = ( JSParseNode ) nodes [ 1 ] ; Lexeme rparen = ( Lexeme ) nodes [ 2 ] ; params . includeLexemeInRange ( lparen ) ; params . includeLexemeInRange ( rparen ) ; return params ; } protected Object onPostfixExpression ( Object [ ] nodes ) { JSParseNode expression = ( JSParseNode ) nodes [ 0 ] ; Lexeme operator = ( Lexeme ) nodes [ 1 ] ; JSParseNode result ; switch ( operator . typeIndex ) { case JSTokenTypes . PLUS_PLUS : result = this . createNode ( JSParseNodeTypes . POST_INCREMENT , operator ) ; break ; case JSTokenTypes . MINUS_MINUS : result = this . createNode ( JSParseNodeTypes . POST_DECREMENT , operator ) ; break ; default : throw new IllegalArgumentException ( MessageFormat . format ( Messages . JSASTHandler_Unknown_operator_0 , operator ) ) ; } result . appendChild ( expression ) ; return result ; } protected Object onRegex ( Object [ ] nodes ) { Lexeme regex = ( Lexeme ) nodes [ 0 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . REGULAR_EXPRESSION , regex ) ; return result ; } protected Object onReturn ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 1 ] ; JSParseNode expression = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . RETURN , keyword ) ; result . appendChild ( expression ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onReturnValue ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . RETURN , keyword ) ; result . appendChild ( expression ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onString ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; return this . createNode ( JSParseNodeTypes . STRING , keyword ) ; } protected Object onSwitchStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 2 ] ; ParseFragment clauses = ( ParseFragment ) nodes [ 4 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . SWITCH , keyword ) ; result . appendChild ( expression ) ; result . appendChild ( clauses ) ; return result ; } protected Object onThis ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; return this . createNode ( JSParseNodeTypes . THIS , keyword ) ; } protected Object onThrowStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . THROW , keyword ) ; result . appendChild ( expression ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onTrue ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; return this . createNode ( JSParseNodeTypes . TRUE , keyword ) ; } protected Object onTryCatchFinallyStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode body = ( JSParseNode ) nodes [ 1 ] ; JSParseNode catchNode = ( JSParseNode ) nodes [ 2 ] ; JSParseNode finallyNode = ( JSParseNode ) nodes [ 3 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . TRY , keyword ) ; result . appendChild ( body ) ; result . appendChild ( catchNode ) ; result . appendChild ( finallyNode ) ; return result ; } protected Object onTryCatchStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode body = ( JSParseNode ) nodes [ 1 ] ; JSParseNode catchNode = ( JSParseNode ) nodes [ 2 ] ; JSParseNode finallyNode = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . TRY , keyword ) ; result . appendChild ( body ) ; result . appendChild ( catchNode ) ; result . appendChild ( finallyNode ) ; return result ; } protected Object onTryFinallyStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode body = ( JSParseNode ) nodes [ 1 ] ; JSParseNode catchNode = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode finallyNode = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . TRY , keyword ) ; result . appendChild ( body ) ; result . appendChild ( catchNode ) ; result . appendChild ( finallyNode ) ; return result ; } protected Object onUnaryExpression ( Object [ ] nodes ) { Lexeme operator = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 1 ] ; JSParseNode result ; switch ( operator . typeIndex ) { case JSTokenTypes . DELETE : result = this . createNode ( JSParseNodeTypes . DELETE , operator ) ; break ; case JSTokenTypes . EXCLAMATION : result = this . createNode ( JSParseNodeTypes . LOGICAL_NOT , operator ) ; break ; case JSTokenTypes . MINUS : result = this . createNode ( JSParseNodeTypes . NEGATE , operator ) ; break ; case JSTokenTypes . MINUS_MINUS : result = this . createNode ( JSParseNodeTypes . PRE_DECREMENT , operator ) ; break ; case JSTokenTypes . PLUS : result = this . createNode ( JSParseNodeTypes . POSITIVE , operator ) ; break ; case JSTokenTypes . PLUS_PLUS : result = this . createNode ( JSParseNodeTypes . PRE_INCREMENT , operator ) ; break ; case JSTokenTypes . TILDE : result = this . createNode ( JSParseNodeTypes . BITWISE_NOT , operator ) ; break ; case JSTokenTypes . TYPEOF : result = this . createNode ( JSParseNodeTypes . TYPEOF , operator ) ; break ; case JSTokenTypes . VOID : result = this . createNode ( JSParseNodeTypes . VOID , operator ) ; break ; default : throw new IllegalArgumentException ( MessageFormat . format ( Messages . JSASTHandler_Unknown_operator_0 , operator ) ) ; } result . appendChild ( expression ) ; return result ; } protected Object onVarDeclaration ( Object [ ] nodes ) { Lexeme identifier = ( Lexeme ) nodes [ 0 ] ; JSParseNode id = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode assignment = this . createNode ( JSParseNodeTypes . EMPTY , null ) ; JSParseNode result = this . createNode ( JSParseNodeTypes . DECLARATION , null ) ; result . appendChild ( id ) ; result . appendChild ( assignment ) ; return result ; } protected Object onVarDeclarationAssignment ( Object [ ] nodes ) { Lexeme identifier = ( Lexeme ) nodes [ 0 ] ; JSParseNode id = this . createNode ( JSParseNodeTypes . IDENTIFIER , identifier ) ; JSParseNode assignment = ( JSParseNode ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . DECLARATION , null ) ; result . appendChild ( id ) ; result . appendChild ( assignment ) ; return result ; } protected Object onVarStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; ParseFragment declarations = ( ParseFragment ) nodes [ 1 ] ; Lexeme semicolon = ( Lexeme ) nodes [ 2 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . VAR , keyword ) ; result . appendChild ( declarations ) ; result . includeLexemeInRange ( semicolon ) ; result . setIncludesSemicolon ( true ) ; return result ; } protected Object onWhileStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode condition = ( JSParseNode ) nodes [ 2 ] ; JSParseNode body = ( JSParseNode ) nodes [ 4 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . WHILE , keyword ) ; result . appendChild ( condition ) ; result . appendChild ( body ) ; return result ; } protected Object onWithStatement ( Object [ ] nodes ) { Lexeme keyword = ( Lexeme ) nodes [ 0 ] ; JSParseNode expression = ( JSParseNode ) nodes [ 2 ] ; JSParseNode body = ( JSParseNode ) nodes [ 4 ] ; JSParseNode result = this . createNode ( JSParseNodeTypes . WITH , keyword ) ; result . appendChild ( expression ) ; result . appendChild ( body ) ; return result ; } } 
=======
public class FloatingPointExponentPositive extends AbstractDatatype { public static final FloatingPointExponentPositive THE_INSTANCE = new FloatingPointExponentPositive ( ) ; private enum State { AT_START , IN_INTEGER_PART_DIGITS_SEEN , DOT_SEEN , E_SEEN , IN_DECIMAL_PART_DIGITS_SEEN , IN_EXPONENT_SIGN_SEEN , IN_EXPONENT_DIGITS_SEEN } private FloatingPointExponentPositive ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { State state = State . AT_START ; boolean zero = true ; for ( int i = 0 ; i < literal . length ( ) ; i ++ ) { char c = literal . charAt ( i ) ; switch ( state ) { case AT_START : if ( c == '-' ) { throw newDatatypeException ( i , "A positive floating point number cannot start with the minus sign." ) ; } else if ( isAsciiDigit ( c ) ) { if ( c != '0' ) { zero = false ; } state = State . IN_INTEGER_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } case IN_INTEGER_PART_DIGITS_SEEN : if ( c == '.' ) { state = State . DOT_SEEN ; continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { if ( c != '0' ) { zero = false ; } continue ; } else { throw newDatatypeException ( i , "Expected a decimal point, “e”, “E” or a digit but saw " , c , " instead." ) ; } case DOT_SEEN : if ( isAsciiDigit ( c ) ) { if ( c != '0' ) { zero = false ; } state = State . IN_DECIMAL_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit after the decimal point but saw " , c , " instead." ) ; } case IN_DECIMAL_PART_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { if ( c != '0' ) { zero = false ; } continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected “e”, “E” or a digit but saw " , c , " instead." ) ; } case E_SEEN : if ( c == '-' || c == '+' ) { state = State . IN_EXPONENT_SIGN_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a minus sign, a plus sign or a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_SIGN_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } } } switch ( state ) { case IN_INTEGER_PART_DIGITS_SEEN : case IN_DECIMAL_PART_DIGITS_SEEN : case IN_EXPONENT_DIGITS_SEEN : if ( zero ) { throw newDatatypeException ( "Zero is not a valid positive floating point number." ) ; } return ; case AT_START : throw newDatatypeException ( "The empty string is not a valid positive floating point number." ) ; case DOT_SEEN : throw newDatatypeException ( "A positive floating point number must not end with the decimal point." ) ; case E_SEEN : throw newDatatypeException ( "A positive floating point number must not end with the exponent “e”." ) ; case IN_EXPONENT_SIGN_SEEN : throw newDatatypeException ( "A positive floating point number must not end with only a sign in the exponent." ) ; } } @ Override public String getName ( ) { return "positive floating point number" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
