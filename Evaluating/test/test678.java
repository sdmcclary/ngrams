<<<<<<< HEAD
public class RegexHandler extends AbstractHandler { private int _acceptState ; public RegexHandler ( int acceptState ) { this . _acceptState = acceptState ; } public Object onStartOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 1 ] ; } public Object onStartAndEndOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 1 ] ; } public Object onOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onEndOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onAddAndExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; NFAGraph lhs = ( NFAGraph ) nodes [ 0 ] ; NFAGraph rhs = ( NFAGraph ) nodes [ 2 ] ; lhs . orMachines ( rhs ) ; return lhs ; } public Object onFirstAndExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onAddFactor ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; NFAGraph lhs = ( NFAGraph ) nodes [ 0 ] ; NFAGraph rhs = ( NFAGraph ) nodes [ 1 ] ; lhs . andMachines ( rhs ) ; return lhs ; } public Object onFirstFactor ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onTermStart ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; NFAGraph newState = ( NFAGraph ) nodes [ 0 ] ; newState . kleeneClosure ( ) ; return newState ; } public Object onTermPlus ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; NFAGraph newState = ( NFAGraph ) nodes [ 0 ] ; newState . positiveClosure ( ) ; return newState ; } public Object onTermQuestion ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; NFAGraph newState = ( NFAGraph ) nodes [ 0 ] ; newState . option ( ) ; return newState ; } public Object onTerm ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onOrExprGroup ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 1 ] ; } public Object onCharacter ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; NFAGraph newState = new NFAGraph ( this . _acceptState ) ; char c = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) . charAt ( 0 ) ; newState . add ( new CharacterInput ( c ) ) ; return newState ; } public Object onDot ( IReductionContext context ) { NFAGraph newState = new NFAGraph ( this . _acceptState ) ; newState . add ( new AnyInput ( ) ) ; return newState ; } public Object onCharacterClass ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; NFAGraph newState = new NFAGraph ( this . _acceptState ) ; newState . add ( ( Input ) nodes [ 0 ] ) ; return newState ; } public Object onEmptyCC ( IReductionContext context ) { return new CharacterClassInput ( ) ; } public Object onNegatedEmptyCC ( IReductionContext context ) { CharacterClassInput cc = new CharacterClassInput ( ) ; cc . setComplement ( true ) ; return cc ; } public Object onMinusOnlyCC ( IReductionContext context ) { CharacterClassInput cc = new CharacterClassInput ( ) ; cc . addInput ( '-' ) ; return cc ; } public Object onNegatedMinusOnlyCC ( IReductionContext context ) { CharacterClassInput cc = new CharacterClassInput ( ) ; cc . setComplement ( true ) ; cc . addInput ( '-' ) ; return cc ; } public Object onCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 1 ] ; } public Object onNegatedCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassInput cc = ( CharacterClassInput ) nodes [ 2 ] ; cc . setComplement ( true ) ; return cc ; } public Object onMinusCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassInput cc = ( CharacterClassInput ) nodes [ 2 ] ; cc . addInput ( '-' ) ; return cc ; } public Object onNegatedMinusCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassInput cc = ( CharacterClassInput ) nodes [ 3 ] ; cc . setComplement ( true ) ; cc . addInput ( '-' ) ; return cc ; } public Object onAddCCExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassInput cc = ( CharacterClassInput ) nodes [ 0 ] ; CharacterClassInput cc2 = ( CharacterClassInput ) nodes [ 1 ] ; cc . addInputs ( cc2 . getCharacters ( ) ) ; return cc ; } public Object onFirstCCExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onCharacterExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassInput cc = new CharacterClassInput ( ) ; cc . addInput ( ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) . charAt ( 0 ) ) ; return cc ; } public Object onCharacterRangeExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassInput cc = new CharacterClassInput ( ) ; char startChar = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) . charAt ( 0 ) ; char endChar = ( ( Lexeme ) nodes [ 2 ] ) . getText ( ) . charAt ( 0 ) ; cc . addInputs ( startChar , endChar ) ; return cc ; } } 
=======
public class MarshalHashtable implements Marshal { public static final String NAMESPACE = "http://xml.apache.org/xml-soap" ; public static final String NAME = "Map" ; public static final Class HASHTABLE_CLASS = new Hashtable ( ) . getClass ( ) ; SoapSerializationEnvelope envelope ; public Object readInstance ( XmlPullParser parser , String namespace , String name , PropertyInfo expected ) throws IOException , XmlPullParserException { Hashtable instance = new Hashtable ( ) ; String elementName = parser . getName ( ) ; while ( parser . nextTag ( ) != XmlPullParser . END_TAG ) { SoapObject item = new ItemSoapObject ( instance ) ; parser . require ( XmlPullParser . START_TAG , null , "item" ) ; parser . nextTag ( ) ; Object key = envelope . read ( parser , item , 0 , null , null , PropertyInfo . OBJECT_TYPE ) ; parser . nextTag ( ) ; if ( key != null ) { item . setProperty ( 0 , key ) ; } Object value = envelope . read ( parser , item , 1 , null , null , PropertyInfo . OBJECT_TYPE ) ; parser . nextTag ( ) ; if ( value != null ) { item . setProperty ( 1 , value ) ; } parser . require ( XmlPullParser . END_TAG , null , "item" ) ; } parser . require ( XmlPullParser . END_TAG , null , elementName ) ; return instance ; } public void writeInstance ( XmlSerializer writer , Object instance ) throws IOException { Hashtable h = ( Hashtable ) instance ; SoapObject item = new SoapObject ( null , null ) ; item . addProperty ( "key" , null ) ; item . addProperty ( "value" , null ) ; for ( Enumeration keys = h . keys ( ) ; keys . hasMoreElements ( ) ; ) { writer . startTag ( "" , "item" ) ; Object key = keys . nextElement ( ) ; item . setProperty ( 0 , key ) ; item . setProperty ( 1 , h . get ( key ) ) ; envelope . writeObjectBody ( writer , item ) ; writer . endTag ( "" , "item" ) ; } } class ItemSoapObject extends SoapObject { Hashtable h ; int resolvedIndex = - 1 ; ItemSoapObject ( Hashtable h ) { super ( null , null ) ; this . h = h ; addProperty ( "key" , null ) ; addProperty ( "value" , null ) ; } public void setProperty ( int index , Object value ) { if ( resolvedIndex == - 1 ) { super . setProperty ( index , value ) ; resolvedIndex = index ; } else { Object resolved = resolvedIndex == 0 ? getProperty ( 0 ) : getProperty ( 1 ) ; if ( index == 0 ) h . put ( value , resolved ) ; else h . put ( resolved , value ) ; } } } public void register ( SoapSerializationEnvelope cm ) { envelope = cm ; cm . addMapping ( MarshalHashtable . NAMESPACE , MarshalHashtable . NAME , HASHTABLE_CLASS , this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
