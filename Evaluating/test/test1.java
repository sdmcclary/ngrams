<<<<<<< HEAD
public final class KetamaNodeLocator extends SpyObject implements NodeLocator { private volatile TreeMap < Long , MemcachedNode > ketamaNodes ; private volatile Collection < MemcachedNode > allNodes ; private final HashAlgorithm hashAlg ; private final Map < InetSocketAddress , Integer > weights ; private final boolean isWeightedKetama ; private final KetamaNodeLocatorConfiguration config ; public KetamaNodeLocator ( List < MemcachedNode > nodes , HashAlgorithm alg ) { this ( nodes , alg , KetamaNodeKeyFormatter . Format . SPYMEMCACHED , new HashMap < InetSocketAddress , Integer > ( ) ) ; } public KetamaNodeLocator ( List < MemcachedNode > nodes , HashAlgorithm alg , KetamaNodeKeyFormatter . Format nodeKeyFormat , Map < InetSocketAddress , Integer > weights ) { this ( nodes , alg , weights , new DefaultKetamaNodeLocatorConfiguration ( new KetamaNodeKeyFormatter ( nodeKeyFormat ) ) ) ; } public KetamaNodeLocator ( List < MemcachedNode > nodes , HashAlgorithm alg , KetamaNodeLocatorConfiguration conf ) { this ( nodes , alg , new HashMap < InetSocketAddress , Integer > ( ) , conf ) ; } public KetamaNodeLocator ( List < MemcachedNode > nodes , HashAlgorithm alg , Map < InetSocketAddress , Integer > nodeWeights , KetamaNodeLocatorConfiguration configuration ) { super ( ) ; allNodes = nodes ; hashAlg = alg ; config = configuration ; weights = nodeWeights ; isWeightedKetama = ! weights . isEmpty ( ) ; setKetamaNodes ( nodes ) ; } private KetamaNodeLocator ( TreeMap < Long , MemcachedNode > smn , Collection < MemcachedNode > an , HashAlgorithm alg , Map < InetSocketAddress , Integer > nodeWeights , KetamaNodeLocatorConfiguration conf ) { super ( ) ; ketamaNodes = smn ; allNodes = an ; hashAlg = alg ; config = conf ; weights = nodeWeights ; isWeightedKetama = ! weights . isEmpty ( ) ; } public Collection < MemcachedNode > getAll ( ) { return allNodes ; } public MemcachedNode getPrimary ( final String k ) { MemcachedNode rv = getNodeForKey ( hashAlg . hash ( k ) ) ; assert rv != null : "Found no node for key " + k ; return rv ; } long getMaxKey ( ) { return getKetamaNodes ( ) . lastKey ( ) ; } MemcachedNode getNodeForKey ( long hash ) { final MemcachedNode rv ; if ( ! ketamaNodes . containsKey ( hash ) ) { SortedMap < Long , MemcachedNode > tailMap = getKetamaNodes ( ) . tailMap ( hash ) ; if ( tailMap . isEmpty ( ) ) { hash = getKetamaNodes ( ) . firstKey ( ) ; } else { hash = tailMap . firstKey ( ) ; } } rv = getKetamaNodes ( ) . get ( hash ) ; return rv ; } public Iterator < MemcachedNode > getSequence ( String k ) { return new KetamaIterator ( k , 7 , getKetamaNodes ( ) , hashAlg ) ; } public NodeLocator getReadonlyCopy ( ) { TreeMap < Long , MemcachedNode > smn = new TreeMap < Long , MemcachedNode > ( getKetamaNodes ( ) ) ; Collection < MemcachedNode > an = new ArrayList < MemcachedNode > ( allNodes . size ( ) ) ; for ( Map . Entry < Long , MemcachedNode > me : smn . entrySet ( ) ) { smn . put ( me . getKey ( ) , new MemcachedNodeROImpl ( me . getValue ( ) ) ) ; } for ( MemcachedNode n : allNodes ) { an . add ( new MemcachedNodeROImpl ( n ) ) ; } return new KetamaNodeLocator ( smn , an , hashAlg , weights , config ) ; } @ Override public void updateLocator ( List < MemcachedNode > nodes ) { allNodes = nodes ; setKetamaNodes ( nodes ) ; } protected TreeMap < Long , MemcachedNode > getKetamaNodes ( ) { return ketamaNodes ; } protected void setKetamaNodes ( List < MemcachedNode > nodes ) { TreeMap < Long , MemcachedNode > newNodeMap = new TreeMap < Long , MemcachedNode > ( ) ; int numReps = config . getNodeRepetitions ( ) ; int nodeCount = nodes . size ( ) ; int totalWeight = 0 ; if ( isWeightedKetama ) { for ( MemcachedNode node : nodes ) { totalWeight += weights . get ( node . getSocketAddress ( ) ) ; } } for ( MemcachedNode node : nodes ) { if ( isWeightedKetama ) { int thisWeight = weights . get ( node . getSocketAddress ( ) ) ; float percent = ( float ) thisWeight / ( float ) totalWeight ; int pointerPerServer = ( int ) ( ( Math . floor ( ( float ) ( percent * ( float ) config . getNodeRepetitions ( ) / 4 * ( float ) nodeCount + 0.0000000001 ) ) ) * 4 ) ; for ( int i = 0 ; i < pointerPerServer / 4 ; i ++ ) { for ( long position : ketamaNodePositionsAtIteration ( node , i ) ) { newNodeMap . put ( position , node ) ; getLogger ( ) . debug ( "Adding node %s with weight %s in position %d" , node , thisWeight , position ) ; } } } else { if ( hashAlg == DefaultHashAlgorithm . KETAMA_HASH ) { for ( int i = 0 ; i < numReps / 4 ; i ++ ) { for ( long position : ketamaNodePositionsAtIteration ( node , i ) ) { newNodeMap . put ( position , node ) ; getLogger ( ) . debug ( "Adding node %s in position %d" , node , position ) ; } } } else { for ( int i = 0 ; i < numReps ; i ++ ) { newNodeMap . put ( hashAlg . hash ( config . getKeyForNode ( node , i ) ) , node ) ; } } } } assert newNodeMap . size ( ) == numReps * nodes . size ( ) ; ketamaNodes = newNodeMap ; } private List < Long > ketamaNodePositionsAtIteration ( MemcachedNode node , int iteration ) { List < Long > positions = new ArrayList < Long > ( ) ; byte [ ] digest = DefaultHashAlgorithm . computeMd5 ( config . getKeyForNode ( node , iteration ) ) ; for ( int h = 0 ; h < 4 ; h ++ ) { Long k = ( ( long ) ( digest [ 3 + h * 4 ] & 0xFF ) << 24 ) | ( ( long ) ( digest [ 2 + h * 4 ] & 0xFF ) << 16 ) | ( ( long ) ( digest [ 1 + h * 4 ] & 0xFF ) << 8 ) | ( digest [ h * 4 ] & 0xFF ) ; positions . add ( k ) ; } return positions ; } } 
=======
class IdrefDatatype extends NCNameDatatype { public int getIdType ( ) { return ID_TYPE_IDREF ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
