<<<<<<< HEAD
public final class GeneralPreferencesPanel extends JPanel { private JCheckBox chReadOnChanChange ; private JCheckBox chReadOnGuideChange ; private JTextField purgeCount ; private JCheckBox chDoNotRemoveUnread ; private JTextField rssPollInterval ; private JCheckBox chReadOnDelay ; private JTextField tfReadOnDelaySeconds ; private JComboBox cbTheme ; private JComboBox cbFontFamilies ; private JCheckBox chShowToolbar ; private JCheckBox chShowToolbarLabels ; public GeneralPreferencesPanel ( UserPreferences settings , FeedRenderingSettings aCrs , ValueModel triggerChannel ) { initComponents ( settings , aCrs , triggerChannel ) ; build ( ) ; } private void initComponents ( UserPreferences settings , FeedRenderingSettings frs , ValueModel triggerChannel ) { chReadOnChanChange = ComponentsFactory . createCheckBox ( Strings . message ( "userprefs.tab.general.when.changing.feeds.mark.all.articles.read" ) , new ToggleButtonAdapter ( new BufferedValueModel ( new PropertyAdapter ( settings , UserPreferences . PROP_MARK_READ_WHEN_CHANGING_CHANNELS ) , triggerChannel ) ) ) ; chReadOnGuideChange = ComponentsFactory . createCheckBox ( Strings . message ( "userprefs.tab.general.when.changing.guides.mark.all.articles.read" ) , new ToggleButtonAdapter ( new BufferedValueModel ( new PropertyAdapter ( settings , UserPreferences . PROP_MARK_READ_WHEN_CHANGING_GUIDES ) , triggerChannel ) ) ) ; chReadOnDelay = ComponentsFactory . createCheckBox ( Strings . message ( "userprefs.tab.general.mark.article.as.read.on.delay" ) , new ToggleButtonAdapter ( new BufferedValueModel ( new PropertyAdapter ( settings , UserPreferences . PROP_MARK_READ_AFTER_DELAY ) , triggerChannel ) ) ) ; tfReadOnDelaySeconds = new JTextField ( ) ; tfReadOnDelaySeconds . setDocument ( new DocumentAdapter ( new BufferedValueModel ( new PropertyAdapter ( settings , "markReadAfterSecondsString" ) , triggerChannel ) ) ) ; configurePurgeControls ( settings , triggerChannel ) ; rssPollInterval = new JTextField ( ) ; rssPollInterval . setDocument ( new DocumentAdapter ( new BufferedValueModel ( new PropertyAdapter ( settings , "rssPollIntervalString" ) , triggerChannel ) ) ) ; cbTheme = new JComboBox ( ) ; ValueModel valueModel = new BufferedValueModel ( new PropertyAdapter ( frs , RenderingSettingsNames . THEME ) , triggerChannel ) ; cbTheme . setModel ( new ThemeListModel ( valueModel ) ) ; cbFontFamilies = new JComboBox ( ) ; final BufferedValueModel vmMainFont = new BufferedValueModel ( new MainFontFamilyValueModel ( frs ) , triggerChannel ) ; cbFontFamilies . setModel ( new FontFamiliesListModel ( vmMainFont ) ) ; valueModel . addValueChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { Theme theme = ( Theme ) evt . getNewValue ( ) ; Font newFont = theme . getMainFontDirect ( ) ; vmMainFont . setValue ( newFont . getFamily ( ) ) ; } } ) ; chShowToolbar = ComponentsFactory . createCheckBox ( Strings . message ( "userprefs.tab.general.show.toolbar" ) , new ToggleButtonAdapter ( new BufferedValueModel ( new PropertyAdapter ( settings , UserPreferences . PROP_SHOW_TOOLBAR ) , triggerChannel ) ) ) ; chShowToolbarLabels = ComponentsFactory . createCheckBox ( Strings . message ( "userprefs.tab.general.show.toolbar.labels" ) , new ToggleButtonAdapter ( new BufferedValueModel ( new PropertyAdapter ( settings , UserPreferences . PROP_SHOW_TOOLBAR_LABELS ) , triggerChannel ) ) ) ; chShowToolbar . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { onShowToolbar ( ) ; } } ) ; onShowToolbar ( ) ; } private void configurePurgeControls ( UserPreferences settings , ValueModel triggerChannel ) { PropertyAdapter propCheck , propCount ; propCheck = new PropertyAdapter ( settings , UserPreferences . PROP_PRESERVE_UNREAD ) ; propCount = new PropertyAdapter ( settings , "purgeCountString" ) ; BufferedValueModel modelCheck = null , modelCount ; if ( ! settings . isPreserveUnread ( ) ) modelCheck = new BufferedValueModel ( propCheck , triggerChannel ) ; modelCount = new BufferedValueModel ( propCount , triggerChannel ) ; if ( settings . isPreserveUnread ( ) ) modelCheck = new BufferedValueModel ( propCheck , triggerChannel ) ; chDoNotRemoveUnread = ComponentsFactory . createCheckBox ( Strings . message ( "userprefs.tab.general.do.not.purge.unread.articles" ) , new ToggleButtonAdapter ( modelCheck ) ) ; purgeCount = new JTextField ( ) ; purgeCount . setDocument ( new DocumentAdapter ( modelCount ) ) ; } private void onShowToolbar ( ) { chShowToolbarLabels . setEnabled ( chShowToolbar . isSelected ( ) ) ; } private void build ( ) { BBFormBuilder builder = new BBFormBuilder ( "7dlu, left:p, 2dlu, 20dlu, 2dlu, 0:grow" , this ) ; builder . setDefaultDialogBorder ( ) ; builder . setLeadingColumnOffset ( 1 ) ; builder . appendSeparator ( Strings . message ( "userprefs.tab.general.separator.theme" ) ) ; builder . append ( buildThemePanel ( ) , 5 ) ; builder . nextLine ( ) ; builder . append ( createToolbarPanel ( ) , 5 ) ; builder . appendSeparator ( Strings . message ( "userprefs.tab.general.separator.behavior" ) ) ; builder . append ( chReadOnChanChange , 5 ) ; builder . append ( chReadOnGuideChange , 5 ) ; builder . append ( chReadOnDelay , tfReadOnDelaySeconds ) ; builder . append ( Strings . message ( "userprefs.tab.general.seconds" ) , 1 ) ; builder . appendSeparator ( Strings . message ( "userprefs.tab.general.separator.updates.and.cleanups" ) ) ; builder . append ( Strings . message ( "userprefs.tab.general.feed.polling.interval" ) , rssPollInterval ) ; builder . nextLine ( ) ; builder . append ( Strings . message ( "userprefs.tab.general.articles.remaining.after.purge" ) , purgeCount ) ; builder . nextLine ( ) ; builder . append ( chDoNotRemoveUnread , 5 ) ; } private JComponent createToolbarPanel ( ) { BBFormBuilder builder = new BBFormBuilder ( "p, 4dlu, p" ) ; builder . append ( chShowToolbar ) ; builder . append ( chShowToolbarLabels ) ; return builder . getPanel ( ) ; } private JComponent buildThemePanel ( ) { BBFormBuilder builder = new BBFormBuilder ( "min(75dlu;p), 14dlu, p, 5dlu, min(75dlu;p)" ) ; builder . append ( cbTheme ) ; builder . append ( Strings . message ( "userprefs.tab.general.font" ) , cbFontFamilies ) ; return builder . getPanel ( ) ; } private static class ThemeListModel extends ThemeSupport . ThemesComboBoxModel { private ValueModel model ; public ThemeListModel ( ValueModel aModel ) { model = aModel ; } public Object getSelectedItem ( ) { return model . getValue ( ) ; } public void setSelectedItem ( Object anItem ) { model . setValue ( anItem ) ; } } private static class FontFamiliesListModel extends ThemeSupport . FontsComboBoxModel { private ValueModel model ; public FontFamiliesListModel ( ValueModel aModel ) { model = aModel ; } public Object getSelectedItem ( ) { return model . getValue ( ) ; } public void setSelectedItem ( Object anItem ) { model . setValue ( anItem ) ; } } private static class MainFontFamilyValueModel implements ValueModel { private final FeedRenderingSettings feedRS ; public MainFontFamilyValueModel ( FeedRenderingSettings frs ) { feedRS = frs ; } public Object getValue ( ) { return getFont ( ) . getFamily ( ) ; } private Font getFont ( ) { return feedRS . getMainContentFont ( ) ; } public void setValue ( Object object ) { String name = ( String ) object ; int size = getFont ( ) . getSize ( ) ; feedRS . setMainContentFont ( Font . decode ( name + "-" + size ) ) ; } public void addValueChangeListener ( PropertyChangeListener listener ) { } public void removeValueChangeListener ( PropertyChangeListener listener ) { } } } 
=======
class InterleavePattern extends BinaryPattern { InterleavePattern ( Pattern p1 , Pattern p2 ) { super ( p1 . isNullable ( ) && p2 . isNullable ( ) , combineHashCode ( INTERLEAVE_HASH_CODE , p1 . hashCode ( ) , p2 . hashCode ( ) ) , p1 , p2 ) ; } Pattern expand ( SchemaPatternBuilder b ) { Pattern ep1 = p1 . expand ( b ) ; Pattern ep2 = p2 . expand ( b ) ; if ( ep1 != p1 || ep2 != p2 ) return b . makeInterleave ( ep1 , ep2 ) ; else return this ; } void checkRestrictions ( int context , DuplicateAttributeDetector dad , Alphabet alpha ) throws RestrictionViolationException { switch ( context ) { case START_CONTEXT : throw new RestrictionViolationException ( "start_contains_interleave" ) ; case DATA_EXCEPT_CONTEXT : throw new RestrictionViolationException ( "data_except_contains_interleave" ) ; case LIST_CONTEXT : throw new RestrictionViolationException ( "list_contains_interleave" ) ; } if ( context == ELEMENT_REPEAT_CONTEXT ) context = ELEMENT_REPEAT_INTERLEAVE_CONTEXT ; Alphabet a1 ; if ( alpha != null && alpha . isEmpty ( ) ) a1 = alpha ; else a1 = new Alphabet ( ) ; p1 . checkRestrictions ( context , dad , a1 ) ; if ( a1 . isEmpty ( ) ) p2 . checkRestrictions ( context , dad , a1 ) ; else { Alphabet a2 = new Alphabet ( ) ; p2 . checkRestrictions ( context , dad , a2 ) ; a1 . checkOverlap ( a2 ) ; if ( alpha != null ) { if ( alpha != a1 ) alpha . addAlphabet ( a1 ) ; alpha . addAlphabet ( a2 ) ; } } if ( ! contentTypeGroupable ( p1 . getContentType ( ) , p2 . getContentType ( ) ) ) throw new RestrictionViolationException ( "interleave_string" ) ; if ( p1 . getContentType ( ) == MIXED_CONTENT_TYPE && p2 . getContentType ( ) == MIXED_CONTENT_TYPE ) throw new RestrictionViolationException ( "interleave_text_overlap" ) ; } < T > T apply ( PatternFunction < T > f ) { return f . caseInterleave ( this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
