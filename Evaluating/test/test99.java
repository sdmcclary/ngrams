<<<<<<< HEAD
public class FileHelperEngine < T > extends EngineBase < T > implements Iterable < T > { private int maxRecords = 0 ; private int currentRecord = 0 ; private LineInfo line ; private String currentLine ; private String completeLine ; private FileReader fr = null ; private ForwardReader freader = null ; private BeforeReadRecordHandler < T > beforeReadRecordHandler ; private AfterReadRecordHandler < T > afterReadRecordHandler ; private BeforeWriteRecordHandler < T > beforeWriteRecordHandler ; private AfterWriteRecordHandler < T > afterWriteRecordHandler ; public FileHelperEngine ( Class < T > recordClass ) { super ( recordClass ) ; } public List < T > readFile ( String fileName ) throws IOException { return readFile ( fileName , Integer . MAX_VALUE ) ; } public void writeFile ( String fileName , List < T > records ) throws IOException { writeFile ( fileName , records , - 1 ) ; } public void writeFile ( String fileName , List < T > records , int maxRecords ) throws IOException { FileWriter fw = null ; try { fw = new FileWriter ( new File ( fileName ) ) ; writeStream ( fw , records , maxRecords ) ; } finally { if ( fw != null ) { fw . flush ( ) ; fw . close ( ) ; } } } public String getRecordsAsString ( List < T > records ) throws IOException { StringWriter sw = new StringWriter ( ) ; writeStream ( sw , records , - 1 ) ; return sw . getBuffer ( ) . toString ( ) ; } private void writeStream ( Writer osr , Iterable < T > records , int maxRecords ) throws IOException { BufferedWriter writer = new BufferedWriter ( osr ) ; try { resetFields ( ) ; if ( getHeaderText ( ) != null && getHeaderText ( ) . length ( ) != 0 ) { if ( getHeaderText ( ) . endsWith ( StringHelper . NEW_LINE ) ) { writer . write ( getHeaderText ( ) ) ; } else { writer . write ( getHeaderText ( ) + StringHelper . NEW_LINE ) ; } } int max = maxRecords ; if ( records instanceof Collection ) { max = Math . min ( max < 0 ? Integer . MAX_VALUE : max , ( ( Collection < T > ) records ) . size ( ) ) ; } ProgressHelper . notify ( notifyHandler , progressMode , 0 , max ) ; int recIndex = 0 ; boolean first = true ; for ( T rec : records ) { if ( recIndex == maxRecords ) { break ; } this . lineNumber ++ ; try { if ( rec == null ) { throw new IllegalArgumentException ( "The record at index " + recIndex + " is null." ) ; } if ( first ) { first = false ; } boolean skip = false ; ProgressHelper . notify ( notifyHandler , progressMode , recIndex + 1 , max ) ; skip = onBeforeWriteRecord ( rec ) ; if ( ! skip ) { currentLine = recordInfo . recordToStr ( rec ) ; currentLine = onAfterWriteRecord ( currentLine , rec ) ; writer . write ( currentLine + StringHelper . NEW_LINE ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } recIndex ++ ; } currentLine = null ; totalRecords = recIndex ; } finally { writer . flush ( ) ; } } public List < T > readFile ( String fileName , int maxRecords ) throws IOException { List < T > tempRes = null ; Reader r = null ; try { r = new FileReader ( new File ( fileName ) ) ; tempRes = readStream ( r , maxRecords ) ; } finally { if ( r != null ) { r . close ( ) ; } } return tempRes ; } public List < T > readResource ( String resourceName ) throws IOException { return readResource ( resourceName , Integer . MAX_VALUE ) ; } public List < T > readResource ( String fileName , int maxRecords ) throws IOException { List < T > tempRes = null ; Reader r = null ; try { r = new InputStreamReader ( getClass ( ) . getResourceAsStream ( fileName ) ) ; tempRes = readStream ( r , maxRecords ) ; } finally { if ( r != null ) { r . close ( ) ; } } return tempRes ; } public List < T > readStream ( Reader fileReader , int maxRecords ) throws IOException { List < T > list = null ; try { list = new ArrayList < T > ( ) ; openStream ( fileReader , maxRecords ) ; for ( T t : this ) { if ( t != null ) { list . add ( t ) ; } } } catch ( IOException e ) { throw e ; } finally { close ( ) ; } return list ; } public void openFile ( String fileName ) throws IOException { openFile ( fileName , Integer . MAX_VALUE ) ; } public void openFile ( String fileName , int maxRecords ) throws IOException { fr = new FileReader ( new File ( fileName ) ) ; openStream ( fr , maxRecords ) ; } public void openResource ( String resourceName ) throws IOException { openResource ( resourceName , Integer . MAX_VALUE ) ; } public void openResource ( String fileName , int maxRecords ) throws IOException { Reader r = null ; r = new InputStreamReader ( getClass ( ) . getResourceAsStream ( fileName ) ) ; openStream ( r , maxRecords ) ; } public void openStream ( Reader fileReader , int maxRecords ) throws IOException { BufferedReader reader = new BufferedReader ( fileReader ) ; resetFields ( ) ; setHeaderText ( "" ) ; setFooterText ( "" ) ; freader = new ForwardReader ( reader , recordInfo . getIgnoreLast ( ) ) ; freader . setDiscardForward ( true ) ; setLineNumber ( 1 ) ; completeLine = freader . readNextLine ( ) ; currentLine = completeLine ; ProgressHelper . notify ( notifyHandler , progressMode , 0 , - 1 ) ; if ( recordInfo . getIgnoreFirst ( ) > 0 ) { for ( int i = 0 ; i < recordInfo . getIgnoreFirst ( ) && currentLine != null ; i ++ ) { headerText += currentLine + StringHelper . NEW_LINE ; currentLine = freader . readNextLine ( ) ; lineNumber ++ ; } } if ( maxRecords < 0 ) { this . maxRecords = Integer . MAX_VALUE ; } else { this . maxRecords = maxRecords ; } line = new LineInfo ( currentLine ) ; line . setReader ( freader ) ; } public void close ( ) throws IOException { if ( fr != null ) { fr . close ( ) ; } } public void setBeforeReadRecordHandler ( BeforeReadRecordHandler < T > beforeReadRecordHandler ) { this . beforeReadRecordHandler = beforeReadRecordHandler ; } public void setAfterReadRecordHandler ( AfterReadRecordHandler < T > afterReadRecordHandler ) { this . afterReadRecordHandler = afterReadRecordHandler ; } public void setBeforeWriteRecordHandler ( BeforeWriteRecordHandler < T > beforeWriteRecordHandler ) { this . beforeWriteRecordHandler = beforeWriteRecordHandler ; } public void setAfterWriteRecordHandler ( AfterWriteRecordHandler < T > afterWriteRecordHandler ) { this . afterWriteRecordHandler = afterWriteRecordHandler ; } private boolean onBeforeReadRecord ( BeforeReadRecordEventArgs < T > e ) { if ( beforeReadRecordHandler != null ) { beforeReadRecordHandler . handleBeforeReadRecord ( this , e ) ; return e . getSkipThisRecord ( ) ; } return false ; } @ SuppressWarnings ( "unchecked" ) private boolean onAfterReadRecord ( String line , T record ) { if ( recordInfo . isNotifyRead ( ) ) { ( ( NotifyRead < T > ) record ) . afterRead ( this , line ) ; } if ( afterReadRecordHandler != null ) { AfterReadRecordEventArgs < T > e = new AfterReadRecordEventArgs < T > ( line , record , lineNumber ) ; afterReadRecordHandler . handleAfterReadRecord ( this , e ) ; return e . getSkipThisRecord ( ) ; } return false ; } @ SuppressWarnings ( "unchecked" ) private boolean onBeforeWriteRecord ( T record ) { if ( recordInfo . isNotifyWrite ( ) ) { ( ( NotifyWrite < T > ) record ) . beforeWrite ( this ) ; } if ( beforeWriteRecordHandler != null ) { BeforeWriteRecordEventArgs < T > e = new BeforeWriteRecordEventArgs < T > ( record , lineNumber ) ; beforeWriteRecordHandler . handleBeforeWriteRecord ( this , e ) ; return e . getSkipThisRecord ( ) ; } return false ; } private String onAfterWriteRecord ( String line , T record ) { if ( afterWriteRecordHandler != null ) { AfterWriteRecordEventArgs < T > e = new AfterWriteRecordEventArgs < T > ( record , lineNumber , line ) ; afterWriteRecordHandler . handleAfterWriteRecord ( this , e ) ; return e . getRecordLine ( ) ; } return line ; } public boolean hasNext ( ) { return ( currentLine != null ) ; } public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { @ Override public boolean hasNext ( ) { return ( currentLine != null ) ; } @ Override public T next ( ) { T record = null ; if ( currentLine != null && currentRecord < maxRecords ) { try { totalRecords ++ ; currentRecord ++ ; line . reload ( currentLine ) ; boolean skip = false ; ProgressHelper . notify ( notifyHandler , progressMode , currentRecord , - 1 ) ; BeforeReadRecordEventArgs < T > e = new BeforeReadRecordEventArgs < T > ( currentLine , lineNumber ) ; skip = onBeforeReadRecord ( e ) ; if ( e . getRecordLineChanged ( ) ) { line . reload ( e . getRecordLine ( ) ) ; } if ( ! skip ) { record = recordInfo . strToRecord ( line ) ; skip = onAfterReadRecord ( currentLine , record ) ; if ( skip ) { record = null ; } } currentLine = freader . readNextLine ( ) ; completeLine = currentLine ; lineNumber ++ ; } catch ( IOException ex ) { throw new Error ( ex ) ; } } return record ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; } } ; } } 
=======
class DataDataDerivType extends DataDerivType { private final DataPattern dp ; private PatternMemo validMemo ; private PatternMemo invalidMemo ; DataDataDerivType ( DataPattern dp ) { this . dp = dp ; } PatternMemo dataDeriv ( ValidatorPatternBuilder builder , Pattern p , String str , ValidationContext vc , List < DataDerivFailure > fail ) { boolean isValid ; final Datatype dt = dp . getDatatype ( ) ; DataDerivFailure ddf = null ; if ( fail != null ) { try { dt . checkValid ( str , vc ) ; isValid = true ; } catch ( DatatypeException e ) { isValid = false ; ddf = new DataDerivFailure ( dp , e ) ; } } else isValid = dt . isValid ( str , vc ) ; if ( isValid ) { if ( validMemo == null || ( fail != null && validMemo . isNotAllowed ( ) ) ) validMemo = super . dataDeriv ( builder , p , str , vc , fail ) ; return validMemo ; } else { if ( invalidMemo == null ) invalidMemo = super . dataDeriv ( builder , p , str , vc , fail ) ; else if ( invalidMemo . isNotAllowed ( ) && ddf != null ) fail . add ( ddf ) ; return invalidMemo ; } } DataDerivType copy ( ) { return new DataDataDerivType ( dp ) ; } DataDerivType combine ( DataDerivType ddt ) { if ( ddt instanceof DataDataDerivType ) { if ( ( ( DataDataDerivType ) ddt ) . dp . getDatatype ( ) == dp . getDatatype ( ) ) return this ; return InconsistentDataDerivType . getInstance ( ) ; } if ( ddt instanceof ValueDataDerivType ) { if ( ( ( ValueDataDerivType ) ddt ) . getDatatype ( ) == dp . getDatatype ( ) ) return ddt ; return InconsistentDataDerivType . getInstance ( ) ; } return ddt . combine ( this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
