<<<<<<< HEAD
public class SignatureSet { private static final boolean DEBUG_PARSING = false ; List < Signature > synSignatures = new ArrayList < Signature > ( ) ; List < Signature > ackSignatures = new ArrayList < Signature > ( ) ; SignatureSet ( boolean syn , boolean ack , boolean rst , boolean open ) { if ( syn ) { for ( String s : SignatureData . synSignatures ) { try { Signature sig = Signature . createSynSignature ( s ) ; synSignatures . add ( sig ) ; } catch ( ParseException e ) { if ( DEBUG_PARSING ) { System . out . println ( "Failed to parse: " + s + "(" + e . getMessage ( ) + ")" ) ; } } } } if ( ack ) { for ( String s : SignatureData . ackSignatures ) { try { Signature sig = Signature . createAckSignature ( s ) ; ackSignatures . add ( sig ) ; } catch ( ParseException e ) { if ( DEBUG_PARSING ) { System . out . println ( "Failure to parse (ACK) :" + s + "(" + e . getMessage ( ) + ")" ) ; } } } } } Signature match ( int len , boolean df , int ttl , int wss , byte [ ] ops , int nops , int mss , int wsc , int tstamp , int tos , int quirks , int type ) { switch ( type ) { case PassiveFingerprint . MODE_SYN : return matchSyn ( len , df , ttl , wss , ops , nops , mss , wsc , tstamp , tos , quirks ) ; case PassiveFingerprint . MODE_ACK : return matchAck ( len , df , ttl , wss , ops , nops , mss , wsc , tstamp , tos , quirks ) ; default : return null ; } } private Signature matchSyn ( int totalLen , boolean df , int ttl , int wss , byte [ ] ops , int opCount , int mss , int wsc , int tstamp , int tos , int quirks ) { for ( Signature s : synSignatures ) { if ( s . match ( totalLen , df , ttl , wss , ops , opCount , mss , wsc , tstamp , tos , quirks ) ) { return s ; } } if ( ! df ) { df = true ; for ( Signature s : synSignatures ) { if ( s . match ( totalLen , df , ttl , wss , ops , opCount , mss , wsc , tstamp , tos , quirks ) ) { return s ; } } } return null ; } private Signature matchAck ( int len , boolean df , int ttl , int wss , byte [ ] ops , int nops , int mss , int wsc , int tstamp , int tos , int quirks ) { for ( Signature s : ackSignatures ) { if ( s . match ( len , df , ttl , wss , ops , nops , mss , wsc , tstamp , tos , quirks ) ) { return s ; } } if ( ! df ) { df = true ; for ( Signature s : ackSignatures ) { if ( s . match ( len , df , ttl , wss , ops , nops , mss , wsc , tstamp , tos , quirks ) ) { return s ; } } } return null ; } String printSignature ( int len , boolean df , int ttl , int wss , byte [ ] ops , int nops , int mss , int wsc , int tstamp , int tos , int quirks , int mode ) { StringBuilder sb = new StringBuilder ( ) ; if ( mss != 0 && wss != 0 && ( wss % mss ) == 0 ) { sb . append ( "S" + ( wss / mss ) ) ; } else if ( wss != 0 && ( wss % 1460 ) == 0 ) { sb . append ( "S" + ( wss / 1460 ) ) ; } else if ( mss != 0 && wss != 0 && ( wss % ( mss + 40 ) ) == 0 ) { sb . append ( "T" + ( wss / ( mss + 40 ) ) ) ; } else if ( wss != 0 && ( wss % 1500 ) == 0 ) { sb . append ( "T" + wss / 1500 ) ; } else if ( wss == 12345 ) { sb . append ( "*(12345)" ) ; } else { sb . append ( wss ) ; } if ( mode != PassiveFingerprint . MODE_OPEN ) { if ( len < 100 ) { sb . append ( ":" + ttl + ":" + ( df ? "1" : "0" ) + ":" + len + ":" ) ; } else { sb . append ( ":" + ttl + ":" + ( df ? "1" : "0" ) + ":*:" ) ; } } else { sb . append ( ":" + ttl + ":" + ( df ? "1" : "0" ) + ":*:" ) ; } for ( int i = 0 ; i < nops ; i ++ ) { switch ( ops [ i ] ) { case TCP . OPT_NOP : sb . append ( 'N' ) ; break ; case TCP . OPT_WSCALE : sb . append ( "W" + wsc ) ; break ; case TCP . OPT_MAXSEG : sb . append ( "M" + mss ) ; break ; case TCP . OPT_TIMESTAMP : sb . append ( 'T' ) ; if ( tstamp == 0 ) { sb . append ( '0' ) ; } break ; case TCP . OPT_SACKOK : sb . append ( 'S' ) ; break ; case TCP . OPT_EOL : sb . append ( 'E' ) ; break ; default : sb . append ( '?' ) ; sb . append ( ops [ i ] ) ; } if ( i != ( nops - 1 ) ) { sb . append ( ',' ) ; } } if ( nops == 0 ) { sb . append ( '.' ) ; } sb . append ( ':' ) ; if ( quirks == 0 ) { sb . append ( '.' ) ; } if ( ( quirks & Signature . QUIRK_RSTACK ) != 0 ) sb . append ( 'K' ) ; if ( ( quirks & Signature . QUIRK_SEQEQ ) != 0 ) sb . append ( 'Q' ) ; if ( ( quirks & Signature . QUIRK_SEQ0 ) != 0 ) sb . append ( '0' ) ; if ( ( quirks & Signature . QUIRK_PAST ) != 0 ) sb . append ( 'P' ) ; if ( ( quirks & Signature . QUIRK_ZEROID ) != 0 ) sb . append ( 'Z' ) ; if ( ( quirks & Signature . QUIRK_IPOPT ) != 0 ) sb . append ( 'I' ) ; if ( ( quirks & Signature . QUIRK_URG ) != 0 ) sb . append ( 'U' ) ; if ( ( quirks & Signature . QUIRK_X2 ) != 0 ) sb . append ( 'X' ) ; if ( ( quirks & Signature . QUIRK_ACK ) != 0 ) sb . append ( 'A' ) ; if ( ( quirks & Signature . QUIRK_T2 ) != 0 ) sb . append ( 'T' ) ; if ( ( quirks & Signature . QUIRK_FLAGS ) != 0 ) sb . append ( 'F' ) ; if ( ( quirks & Signature . QUIRK_DATA ) != 0 ) sb . append ( 'D' ) ; if ( ( quirks & Signature . QUIRK_BROKEN ) != 0 ) sb . append ( '!' ) ; return sb . toString ( ) ; } } 
=======
class IntSet { static private final int INIT_SIZE = 4 ; private int [ ] v = null ; private int len = 0 ; void add ( int n ) { if ( v == null ) { v = new int [ INIT_SIZE ] ; v [ 0 ] = n ; len = 1 ; return ; } if ( len == v . length ) { int [ ] newv = new int [ len * 2 ] ; System . arraycopy ( v , 0 , newv , 0 , len ) ; v = newv ; } if ( n > v [ len - 1 ] ) { v [ len ++ ] = n ; return ; } int i = 0 ; for ( ; i < len ; i ++ ) { if ( n <= v [ i ] ) { if ( n == v [ i ] ) return ; break ; } } for ( int j = len ; j >= i ; j -- ) v [ j + 1 ] = v [ j ] ; v [ i ] = n ; ++ len ; } void addAll ( IntSet is ) { if ( is . len == 0 ) return ; int [ ] newv = new int [ len + is . len ] ; int i = 0 , j = 0 , k = 0 ; while ( i < len && j < is . len ) { if ( v [ i ] < is . v [ j ] ) newv [ k ++ ] = v [ i ++ ] ; else if ( is . v [ j ] < v [ i ] ) newv [ k ++ ] = is . v [ j ++ ] ; else { newv [ k ++ ] = v [ i ++ ] ; j ++ ; } } while ( i < len ) newv [ k ++ ] = v [ i ++ ] ; while ( j < is . len ) newv [ k ++ ] = is . v [ j ++ ] ; v = newv ; len = k ; } int size ( ) { return len ; } int get ( int i ) { if ( i >= len ) throw new IndexOutOfBoundsException ( ) ; try { return v [ i ] ; } catch ( NullPointerException e ) { throw new IndexOutOfBoundsException ( ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
