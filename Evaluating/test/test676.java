public class LRParser extends AbstractParser { protected GrammarNode _grammar ; private GrammarNode _expandedGrammar ; private State [ ] _states ; private List < IReductionHandler > _handlers ; private String _message ; protected LRParser ( String language ) throws ParserInitializationException { super ( language ) ; this . _states = this . createStateTable ( ) ; } protected LRParser ( TokenList tokenList , GrammarNode grammar ) throws ParserInitializationException { super ( tokenList ) ; this . _grammar = grammar ; this . _states = this . createStateTable ( ) ; } public void addHandler ( IReductionHandler handler ) { if ( this . _handlers == null ) { this . _handlers = new ArrayList < IReductionHandler > ( ) ; } this . _handlers . add ( handler ) ; } protected IReductionContext createReductionContext ( String productionName , SequenceNode rule ) { return new ReductionContext ( productionName , rule , this ) ; } private State [ ] createStateTable ( ) { List < State > states = new ArrayList < State > ( ) ; GrammarNode grammar = this . getGrammar ( ) ; if ( grammar != null ) { GrammarNode expandedGrammar = grammar . getExpandedGrammar ( ) ; this . _expandedGrammar = grammar . getExpandedGrammar ( ) ; Item startItem = new Item ( ( ProductionNode ) expandedGrammar . getChild ( 0 ) ) ; Map < String , State > stateCache = new HashMap < String , State > ( ) ; states . add ( new State ( expandedGrammar , startItem ) ) ; for ( int index = 0 ; index < states . size ( ) ; index ++ ) { State currentState = states . get ( index ) ; for ( IGrammarNode transition : currentState . getTransitionInputs ( ) ) { String name = transition . getName ( ) ; State newState = currentState . getTransitionState ( transition , stateCache ) ; if ( newState . getIndex ( ) == - 1 ) { newState . setIndex ( states . size ( ) ) ; states . add ( newState ) ; } if ( transition . getTypeIndex ( ) == GrammarNodeTypes . NONTERMINAL ) { currentState . addGoto ( name , newState . getIndex ( ) ) ; } else { currentState . addShift ( name , newState . getIndex ( ) ) ; } } } for ( State state : states ) { for ( Item item : state . getItems ( ) ) { if ( item . isCompletedItem ( ) ) { String name = item . getName ( ) ; if ( expandedGrammar . getStartingName ( ) . equals ( name ) ) { state . addAccept ( "$" ) ; } else { int newState = item . getIndex ( ) ; for ( TerminalNode terminal : expandedGrammar . getFollow ( name ) ) { state . addReduce ( terminal . getName ( ) , newState ) ; } } } } } } return states . toArray ( new State [ states . size ( ) ] ) ; } private void fireOnAfterParse ( IParseNode parentNode ) { if ( this . _handlers != null ) { IParseState parseState = this . getParseState ( ) ; for ( IReductionHandler handler : this . _handlers ) { handler . afterParse ( parseState , parentNode ) ; } } } private void fireOnBeforeParse ( IParseNode parentNode ) { if ( this . _handlers != null ) { IParseState parseState = this . getParseState ( ) ; for ( IReductionHandler handler : this . _handlers ) { handler . beforeParse ( parseState , parentNode ) ; } } } private void fireReductions ( ProductionNode production ) { if ( this . _handlers != null ) { if ( production != null ) { String productionName = production . getName ( ) ; SequenceNode rule = ( SequenceNode ) production . getChild ( 0 ) ; IReductionContext context = this . createReductionContext ( productionName , rule ) ; for ( IReductionHandler handler : this . _handlers ) { handler . reduce ( context ) ; } } } } public GrammarNode getExpandedGrammar ( ) { return this . _expandedGrammar ; } public GrammarNode getGrammar ( ) { return this . _grammar ; } public String getMessage ( ) { return this . _message ; } public void parseAll ( IParseNode parentNode ) throws ParseException , LexerException { IParseNode rootNode = this . getParseRootNode ( parentNode , IParseNode . class ) ; boolean accept = false ; boolean error = false ; Stack < State > states = new Stack < State > ( ) ; this . fireOnBeforeParse ( rootNode ) ; if ( this . _states != null && this . _states . length > 0 ) { State currentState = this . _states [ 0 ] ; states . push ( currentState ) ; this . advance ( ) ; this . _message = "" ; while ( accept == false && error == false ) { Action action = currentState . getAction ( this . currentLexeme . getType ( ) ) ; switch ( action . type ) { case SHIFT : this . pushCurrentLexeme ( currentLexeme ) ; if ( this . isEOS ( ) ) { break ; } else { this . advance ( ) ; } currentState = this . _states [ action . newState ] ; states . push ( currentState ) ; break ; case REDUCE : ProductionNode production = ( ProductionNode ) this . _expandedGrammar . getChild ( action . newState ) ; String name = production . getName ( ) ; int symbolCount = production . getSymbolCount ( ) ; for ( int i = 0 ; i < symbolCount ; i ++ ) { states . pop ( ) ; } this . fireReductions ( production ) ; Action newAction = states . peek ( ) . getAction ( name ) ; currentState = this . _states [ newAction . newState ] ; states . push ( currentState ) ; break ; case ACCEPT : accept = true ; break ; case GOTO : this . _message = MessageFormat . format ( Messages . getString ( "LRParser.Unexpected_goto_at_0_in_state_1" ) , currentLexeme , currentState . getIndex ( ) ) ; error = true ; break ; case ERROR : if ( this . recover ( ) ) { currentState = this . _states [ 0 ] ; states . clear ( ) ; states . push ( currentState ) ; } else { this . _message = MessageFormat . format ( Messages . getString ( "LRParser.No_transition_for_0_in_state_1" ) , currentLexeme , currentState . getIndex ( ) ) ; error = true ; } break ; default : break ; } } } this . fireOnAfterParse ( rootNode ) ; } private void pushCurrentLexeme ( Lexeme currentLexeme ) { if ( this . _handlers != null ) { for ( IReductionHandler handler : this . _handlers ) { handler . push ( currentLexeme ) ; } } } protected boolean recover ( ) { return false ; } public void removeHandler ( IReductionHandler handler ) { if ( this . _handlers != null ) { this . _handlers . remove ( handler ) ; } } } 