<<<<<<< HEAD
public class ListModel extends ResultsListModel implements ILinkResolverListener { private static final int MIN_REFS_IN_GROUP = 2 ; private static final int MAX_HOT_LINKS = 20 ; private int hotlinkSeqNum ; private final Engine engine ; private final ValueModel mdlStarz ; private final ValueModel mdlOnlyUnread ; private final ValueModel mdlTimeOption ; private final LinkResolver resolver ; private List < Engine . HotLink > hotlinks = new ArrayList < Engine . HotLink > ( ) ; private IGuide targetGuide ; private Pattern ignorePattern ; private boolean dontCountSelfReferences ; private boolean suppressSameSourceLinks ; public ListModel ( Engine engine , ValueModel mdlStarz , ValueModel mdlOnlyUnread , ValueModel mdlTimeOption ) { this . engine = engine ; this . mdlStarz = mdlStarz ; this . mdlOnlyUnread = mdlOnlyUnread ; this . mdlTimeOption = mdlTimeOption ; resolver = new LinkResolver ( this ) ; FilterListener fl = new FilterListener ( ) ; mdlStarz . addValueChangeListener ( fl ) ; mdlOnlyUnread . addValueChangeListener ( fl ) ; mdlTimeOption . addValueChangeListener ( fl ) ; } public void onGroupResolved ( final HotResultGroup group ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { fireGroupUpdated ( group ) ; } } ) ; } public void stopLinkResolution ( ) { if ( resolver != null ) resolver . stop ( ) ; } public SwingWorker scan ( ) { return new Scanner ( ) ; } void processLinks ( List < Engine . HotLink > links ) { for ( Engine . HotLink hotLink : links ) { if ( hotLink . size ( ) < MIN_REFS_IN_GROUP ) break ; hotlinks . add ( hotLink ) ; } review ( ) ; } private void review ( ) { List < HotResultItem > groupItems = new LinkedList < HotResultItem > ( ) ; List < HotResultGroup > newGroups = new LinkedList < HotResultGroup > ( ) ; for ( Engine . HotLink link : hotlinks ) { List < IArticle > matchingArticles = getMatchingArticles ( link ) ; if ( matchingArticles == null ) continue ; String linkString = link . getLink ( ) . toString ( ) ; groupItems . clear ( ) ; for ( IArticle article : matchingArticles ) { groupItems . add ( new HotResultItem ( article , linkString ) ) ; } if ( groupItems . size ( ) >= MIN_REFS_IN_GROUP ) { HotResultGroup group = new HotResultGroup ( hotlinkSeqNum ++ , link ) ; for ( HotResultItem item : groupItems ) group . add ( item ) ; newGroups . add ( group ) ; } } Collections . sort ( newGroups ) ; fireClear ( ) ; int i = 0 ; for ( HotResultGroup group : newGroups ) { group . setVisible ( true ) ; if ( ! group . isResolved ( ) ) { String title = resolver . resolve ( group ) ; if ( title != null ) group . setResolvedTitle ( title ) ; } fireGroupAdded ( group , true ) ; for ( HotResultItem item : group ) fireItemAdded ( item , group ) ; i ++ ; if ( i > MAX_HOT_LINKS ) break ; } } private List < IArticle > getMatchingArticles ( Engine . HotLink link ) { List < IArticle > matches ; if ( ignorePattern != null && ignorePattern . matcher ( link . getLink ( ) . toString ( ) ) . find ( ) ) return null ; IFeed feed = null ; matches = new LinkedList < IArticle > ( ) ; boolean fine = ! suppressSameSourceLinks ; for ( IArticle article : link ) { if ( ! matches ( link , article ) ) continue ; matches . add ( article ) ; if ( ! fine ) { if ( feed == null ) feed = article . getFeed ( ) ; else if ( feed != article . getFeed ( ) ) fine = true ; } } return ! fine ? null : matches ; } private boolean matches ( Engine . HotLink link , IArticle article ) { if ( ( Boolean ) mdlOnlyUnread . getValue ( ) && article . isRead ( ) ) return false ; TimeOption to = ( TimeOption ) mdlTimeOption . getValue ( ) ; if ( article . getPublicationDate ( ) . getTime ( ) < System . currentTimeMillis ( ) - to . getOffset ( ) ) return false ; Integer starz = ( Integer ) mdlStarz . getValue ( ) ; IFeed feed = article . getFeed ( ) ; if ( starz > 1 && feed . getRating ( ) < starz ) return false ; if ( dontCountSelfReferences ) { String linkHost = link . getLink ( ) . getHost ( ) ; URL articleLink = article . getLink ( ) ; if ( articleLink != null && articleLink . getHost ( ) . equalsIgnoreCase ( linkHost ) ) return false ; } return targetGuide == null || targetGuide . getID ( ) == - 1 || feed . belongsTo ( targetGuide ) ; } public void setSetup ( String ignorePatterns , boolean dontCountSelfReferences , boolean suppressSameSourceLinks , IGuide targetGuide ) { ignorePattern = StringUtils . isEmpty ( ignorePatterns ) ? null : Pattern . compile ( StringUtils . keywordsToPattern ( ignorePatterns ) ) ; this . dontCountSelfReferences = dontCountSelfReferences ; this . suppressSameSourceLinks = suppressSameSourceLinks ; this . targetGuide = targetGuide ; review ( ) ; } private class Scanner extends SwingWorker < List < Engine . HotLink > , Integer > implements IProgressListener { protected List < Engine . HotLink > doInBackground ( ) throws Exception { return engine . scan ( this ) ; } @ Override protected void done ( ) { List < Engine . HotLink > links ; try { links = get ( ) ; } catch ( Exception e ) { return ; } processLinks ( links ) ; } public void onProgress ( int percent ) { setProgress ( percent ) ; } } private class FilterListener implements PropertyChangeListener { public void propertyChange ( PropertyChangeEvent evt ) { review ( ) ; } } } 
=======
class ValuePattern extends StringPattern { private final Object obj ; private final Datatype dt ; private final Name dtName ; private final String stringValue ; ValuePattern ( Datatype dt , Name dtName , Object obj , String stringValue ) { super ( combineHashCode ( VALUE_HASH_CODE , dt . valueHashCode ( obj ) ) ) ; this . dt = dt ; this . dtName = dtName ; this . obj = obj ; this . stringValue = stringValue ; } boolean samePattern ( Pattern other ) { if ( getClass ( ) != other . getClass ( ) ) return false ; if ( ! ( other instanceof ValuePattern ) ) return false ; return ( dt . equals ( ( ( ValuePattern ) other ) . dt ) && dt . sameValue ( obj , ( ( ValuePattern ) other ) . obj ) ) ; } < T > T apply ( PatternFunction < T > f ) { return f . caseValue ( this ) ; } void checkRestrictions ( int context , DuplicateAttributeDetector dad , Alphabet alpha ) throws RestrictionViolationException { switch ( context ) { case START_CONTEXT : throw new RestrictionViolationException ( "start_contains_value" ) ; } } Datatype getDatatype ( ) { return dt ; } Name getDatatypeName ( ) { return dtName ; } Object getValue ( ) { return obj ; } String getStringValue ( ) { return stringValue ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
