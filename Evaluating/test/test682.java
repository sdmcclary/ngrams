public class SoapSerializationEnvelope extends SoapEnvelope { protected static final int QNAME_TYPE = 1 ; protected static final int QNAME_NAMESPACE = 0 ; protected static final int QNAME_MARSHAL = 3 ; private static final String ANY_TYPE_LABEL = "anyType" ; private static final String ARRAY_MAPPING_NAME = "Array" ; private static final String NULL_LABEL = "null" ; private static final String NIL_LABEL = "nil" ; private static final String HREF_LABEL = "href" ; private static final String ID_LABEL = "id" ; private static final String ROOT_LABEL = "root" ; private static final String TYPE_LABEL = "type" ; private static final String ITEM_LABEL = "item" ; private static final String ARRAY_TYPE_LABEL = "arrayType" ; static final Marshal DEFAULT_MARSHAL = new DM ( ) ; public Hashtable properties = new Hashtable ( ) ; Hashtable idMap = new Hashtable ( ) ; Vector multiRef ; public boolean implicitTypes ; public boolean dotNet ; protected Hashtable qNameToClass = new Hashtable ( ) ; protected Hashtable classToQName = new Hashtable ( ) ; protected boolean addAdornments = true ; public SoapSerializationEnvelope ( int version ) { super ( version ) ; addMapping ( enc , ARRAY_MAPPING_NAME , PropertyInfo . VECTOR_CLASS ) ; DEFAULT_MARSHAL . register ( this ) ; } public boolean isAddAdornments ( ) { return addAdornments ; } public void setAddAdornments ( boolean addAdornments ) { this . addAdornments = addAdornments ; } public void parseBody ( XmlPullParser parser ) throws IOException , XmlPullParserException { bodyIn = null ; parser . nextTag ( ) ; if ( parser . getEventType ( ) == XmlPullParser . START_TAG && parser . getNamespace ( ) . equals ( env ) && parser . getName ( ) . equals ( "Fault" ) ) { SoapFault fault = new SoapFault ( ) ; fault . parse ( parser ) ; bodyIn = fault ; } else { while ( parser . getEventType ( ) == XmlPullParser . START_TAG ) { String rootAttr = parser . getAttributeValue ( enc , ROOT_LABEL ) ; Object o = read ( parser , null , - 1 , parser . getNamespace ( ) , parser . getName ( ) , PropertyInfo . OBJECT_TYPE ) ; if ( "1" . equals ( rootAttr ) || bodyIn == null ) bodyIn = o ; parser . nextTag ( ) ; } } } protected void readSerializable ( XmlPullParser parser , SoapObject obj ) throws IOException , XmlPullParserException { for ( int counter = 0 ; counter < parser . getAttributeCount ( ) ; counter ++ ) { String attributeName = parser . getAttributeName ( counter ) ; String value = parser . getAttributeValue ( counter ) ; ( ( SoapObject ) obj ) . addAttribute ( attributeName , value ) ; } readSerializable ( parser , ( KvmSerializable ) obj ) ; } protected void readSerializable ( XmlPullParser parser , KvmSerializable obj ) throws IOException , XmlPullParserException { int testIndex = - 1 ; int propertyCount = obj . getPropertyCount ( ) ; PropertyInfo info = new PropertyInfo ( ) ; while ( parser . nextTag ( ) != XmlPullParser . END_TAG ) { String name = parser . getName ( ) ; int countdown = propertyCount ; if ( ! implicitTypes || ! ( obj instanceof SoapObject ) ) { while ( true ) { if ( countdown -- == 0 ) { throw new RuntimeException ( "Unknown Property: " + name ) ; } if ( ++ testIndex >= propertyCount ) { testIndex = 0 ; } obj . getPropertyInfo ( testIndex , properties , info ) ; if ( info . namespace == null && name . equals ( info . name ) || info . name == null && testIndex == 0 || name . equals ( info . name ) && parser . getNamespace ( ) . equals ( info . namespace ) ) { break ; } } obj . setProperty ( testIndex , read ( parser , obj , testIndex , null , null , info ) ) ; } else { ( ( SoapObject ) obj ) . addProperty ( parser . getName ( ) , read ( parser , obj , obj . getPropertyCount ( ) , ( ( SoapObject ) obj ) . getNamespace ( ) , name , PropertyInfo . OBJECT_TYPE ) ) ; } } parser . require ( XmlPullParser . END_TAG , null , null ) ; } protected Object readUnknown ( XmlPullParser parser , String typeNamespace , String typeName ) throws IOException , XmlPullParserException { String name = parser . getName ( ) ; String namespace = parser . getNamespace ( ) ; parser . next ( ) ; Object result = null ; String text = null ; if ( parser . getEventType ( ) == XmlPullParser . TEXT ) { text = parser . getText ( ) ; result = new SoapPrimitive ( typeNamespace , typeName , text ) ; parser . next ( ) ; } else if ( parser . getEventType ( ) == XmlPullParser . END_TAG ) { result = new SoapObject ( typeNamespace , typeName ) ; } if ( parser . getEventType ( ) == XmlPullParser . START_TAG ) { if ( text != null && text . trim ( ) . length ( ) != 0 ) { throw new RuntimeException ( "Malformed input: Mixed content" ) ; } SoapObject so = new SoapObject ( typeNamespace , typeName ) ; while ( parser . getEventType ( ) != XmlPullParser . END_TAG ) { so . addProperty ( parser . getName ( ) , read ( parser , so , so . getPropertyCount ( ) , null , null , PropertyInfo . OBJECT_TYPE ) ) ; parser . nextTag ( ) ; } result = so ; } parser . require ( XmlPullParser . END_TAG , namespace , name ) ; return result ; } private int getIndex ( String value , int start , int dflt ) { if ( value == null ) return dflt ; return value . length ( ) - start < 3 ? dflt : Integer . parseInt ( value . substring ( start + 1 , value . length ( ) - 1 ) ) ; } protected void readVector ( XmlPullParser parser , Vector v , PropertyInfo elementType ) throws IOException , XmlPullParserException { String namespace = null ; String name = null ; int size = v . size ( ) ; boolean dynamic = true ; String type = parser . getAttributeValue ( enc , ARRAY_TYPE_LABEL ) ; if ( type != null ) { int cut0 = type . indexOf ( ':' ) ; int cut1 = type . indexOf ( "[" , cut0 ) ; name = type . substring ( cut0 + 1 , cut1 ) ; String prefix = cut0 == - 1 ? "" : type . substring ( 0 , cut0 ) ; namespace = parser . getNamespace ( prefix ) ; size = getIndex ( type , cut1 , - 1 ) ; if ( size != - 1 ) { v . setSize ( size ) ; dynamic = false ; } } if ( elementType == null ) elementType = PropertyInfo . OBJECT_TYPE ; parser . nextTag ( ) ; int position = getIndex ( parser . getAttributeValue ( enc , "offset" ) , 0 , 0 ) ; while ( parser . getEventType ( ) != XmlPullParser . END_TAG ) { position = getIndex ( parser . getAttributeValue ( enc , "position" ) , 0 , position ) ; if ( dynamic && position >= size ) { size = position + 1 ; v . setSize ( size ) ; } v . setElementAt ( read ( parser , v , position , namespace , name , elementType ) , position ) ; position ++ ; parser . nextTag ( ) ; } parser . require ( XmlPullParser . END_TAG , null , null ) ; } public Object read ( XmlPullParser parser , Object owner , int index , String namespace , String name , PropertyInfo expected ) throws IOException , XmlPullParserException { String elementName = parser . getName ( ) ; String href = parser . getAttributeValue ( null , HREF_LABEL ) ; Object obj ; if ( href != null ) { if ( owner == null ) throw new RuntimeException ( "href at root level?!?" ) ; href = href . substring ( 1 ) ; obj = idMap . get ( href ) ; if ( obj == null || obj instanceof FwdRef ) { FwdRef f = new FwdRef ( ) ; f . next = ( FwdRef ) obj ; f . obj = owner ; f . index = index ; idMap . put ( href , f ) ; obj = null ; } parser . nextTag ( ) ; parser . require ( XmlPullParser . END_TAG , null , elementName ) ; } else { String nullAttr = parser . getAttributeValue ( xsi , NIL_LABEL ) ; String id = parser . getAttributeValue ( null , ID_LABEL ) ; if ( nullAttr == null ) nullAttr = parser . getAttributeValue ( xsi , NULL_LABEL ) ; if ( nullAttr != null && SoapEnvelope . stringToBoolean ( nullAttr ) ) { obj = null ; parser . nextTag ( ) ; parser . require ( XmlPullParser . END_TAG , null , elementName ) ; } else { String type = parser . getAttributeValue ( xsi , TYPE_LABEL ) ; if ( type != null ) { int cut = type . indexOf ( ':' ) ; name = type . substring ( cut + 1 ) ; String prefix = cut == - 1 ? "" : type . substring ( 0 , cut ) ; namespace = parser . getNamespace ( prefix ) ; } else if ( name == null && namespace == null ) { if ( parser . getAttributeValue ( enc , ARRAY_TYPE_LABEL ) != null ) { namespace = enc ; name = ARRAY_MAPPING_NAME ; } else { Object [ ] names = getInfo ( expected . type , null ) ; namespace = ( String ) names [ 0 ] ; name = ( String ) names [ 1 ] ; } } if ( type == null ) { implicitTypes = true ; } obj = readInstance ( parser , namespace , name , expected ) ; if ( obj == null ) obj = readUnknown ( parser , namespace , name ) ; } if ( id != null ) { Object hlp = idMap . get ( id ) ; if ( hlp instanceof FwdRef ) { FwdRef f = ( FwdRef ) hlp ; do { if ( f . obj instanceof KvmSerializable ) ( ( KvmSerializable ) f . obj ) . setProperty ( f . index , obj ) ; else ( ( Vector ) f . obj ) . setElementAt ( obj , f . index ) ; f = f . next ; } while ( f != null ) ; } else if ( hlp != null ) throw new RuntimeException ( "double ID" ) ; idMap . put ( id , obj ) ; } } parser . require ( XmlPullParser . END_TAG , null , elementName ) ; return obj ; } public Object readInstance ( XmlPullParser parser , String namespace , String name , PropertyInfo expected ) throws IOException , XmlPullParserException { Object obj = qNameToClass . get ( new SoapPrimitive ( namespace , name , null ) ) ; if ( obj == null ) return null ; if ( obj instanceof Marshal ) return ( ( Marshal ) obj ) . readInstance ( parser , namespace , name , expected ) ; else if ( obj instanceof SoapObject ) { obj = ( ( SoapObject ) obj ) . newInstance ( ) ; } else if ( obj == SoapObject . class ) { obj = new SoapObject ( namespace , name ) ; } else { try { obj = ( ( Class ) obj ) . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e . toString ( ) ) ; } } if ( obj instanceof SoapObject ) readSerializable ( parser , ( SoapObject ) obj ) ; else if ( obj instanceof KvmSerializable ) readSerializable ( parser , ( KvmSerializable ) obj ) ; else if ( obj instanceof Vector ) readVector ( parser , ( Vector ) obj , expected . elementType ) ; else throw new RuntimeException ( "no deserializer for " + obj . getClass ( ) ) ; return obj ; } public Object [ ] getInfo ( Object type , Object instance ) { if ( type == null ) { if ( instance instanceof SoapObject || instance instanceof SoapPrimitive ) type = instance ; else type = instance . getClass ( ) ; } if ( type instanceof SoapObject ) { SoapObject so = ( SoapObject ) type ; return new Object [ ] { so . getNamespace ( ) , so . getName ( ) , null , null } ; } if ( type instanceof SoapPrimitive ) { SoapPrimitive sp = ( SoapPrimitive ) type ; return new Object [ ] { sp . getNamespace ( ) , sp . getName ( ) , null , DEFAULT_MARSHAL } ; } if ( ( type instanceof Class ) && type != PropertyInfo . OBJECT_CLASS ) { Object [ ] tmp = ( Object [ ] ) classToQName . get ( ( ( Class ) type ) . getName ( ) ) ; if ( tmp != null ) return tmp ; } return new Object [ ] { xsd , ANY_TYPE_LABEL , null , null } ; } public void addMapping ( String namespace , String name , Class clazz , Marshal marshal ) { qNameToClass . put ( new SoapPrimitive ( namespace , name , null ) , marshal == null ? ( Object ) clazz : marshal ) ; classToQName . put ( clazz . getName ( ) , new Object [ ] { namespace , name , null , marshal } ) ; } public void addMapping ( String namespace , String name , Class clazz ) { addMapping ( namespace , name , clazz , null ) ; } public void addTemplate ( SoapObject so ) { qNameToClass . put ( new SoapPrimitive ( so . namespace , so . name , null ) , so ) ; } public Object getResponse ( ) throws SoapFault { if ( bodyIn instanceof SoapFault ) { throw ( SoapFault ) bodyIn ; } KvmSerializable ks = ( KvmSerializable ) bodyIn ; return ks . getPropertyCount ( ) == 0 ? null : ks . getProperty ( 0 ) ; } public Object getResult ( ) { KvmSerializable ks = ( KvmSerializable ) bodyIn ; return ks . getPropertyCount ( ) == 0 ? null : ks . getProperty ( 0 ) ; } public void writeBody ( XmlSerializer writer ) throws IOException { multiRef = new Vector ( ) ; multiRef . addElement ( bodyOut ) ; Object [ ] qName = getInfo ( null , bodyOut ) ; writer . startTag ( ( dotNet ) ? "" : ( String ) qName [ QNAME_NAMESPACE ] , ( String ) qName [ QNAME_TYPE ] ) ; if ( dotNet ) { writer . attribute ( null , "xmlns" , ( String ) qName [ QNAME_NAMESPACE ] ) ; } if ( addAdornments ) { writer . attribute ( null , ID_LABEL , qName [ 2 ] == null ? ( "o" + 0 ) : ( String ) qName [ 2 ] ) ; writer . attribute ( enc , ROOT_LABEL , "1" ) ; } writeElement ( writer , bodyOut , null , qName [ QNAME_MARSHAL ] ) ; writer . endTag ( ( dotNet ) ? "" : ( String ) qName [ QNAME_NAMESPACE ] , ( String ) qName [ QNAME_TYPE ] ) ; } public void writeObjectBody ( XmlSerializer writer , SoapObject obj ) throws IOException { SoapObject soapObject = ( SoapObject ) obj ; for ( int counter = 0 ; counter < soapObject . getAttributeCount ( ) ; counter ++ ) { AttributeInfo attributeInfo = new AttributeInfo ( ) ; soapObject . getAttributeInfo ( counter , attributeInfo ) ; writer . attribute ( attributeInfo . getNamespace ( ) , attributeInfo . getName ( ) , attributeInfo . getValue ( ) . toString ( ) ) ; } writeObjectBody ( writer , ( KvmSerializable ) obj ) ; } public void writeObjectBody ( XmlSerializer writer , KvmSerializable obj ) throws IOException { PropertyInfo info = new PropertyInfo ( ) ; int cnt = obj . getPropertyCount ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { obj . getPropertyInfo ( i , properties , info ) ; if ( ( info . flags & PropertyInfo . TRANSIENT ) == 0 ) { writer . startTag ( info . namespace , info . name ) ; writeProperty ( writer , obj . getProperty ( i ) , info ) ; writer . endTag ( info . namespace , info . name ) ; } } } protected void writeProperty ( XmlSerializer writer , Object obj , PropertyInfo type ) throws IOException { if ( obj == null ) { writer . attribute ( xsi , version >= VER12 ? NIL_LABEL : NULL_LABEL , "true" ) ; return ; } Object [ ] qName = getInfo ( null , obj ) ; if ( type . multiRef || qName [ 2 ] != null ) { int i = multiRef . indexOf ( obj ) ; if ( i == - 1 ) { i = multiRef . size ( ) ; multiRef . addElement ( obj ) ; } writer . attribute ( null , HREF_LABEL , qName [ 2 ] == null ? ( "#o" + i ) : "#" + qName [ 2 ] ) ; } else { if ( ! implicitTypes || obj . getClass ( ) != type . type ) { String prefix = writer . getPrefix ( ( String ) qName [ QNAME_NAMESPACE ] , true ) ; writer . attribute ( xsi , TYPE_LABEL , prefix + ":" + qName [ QNAME_TYPE ] ) ; } writeElement ( writer , obj , type , qName [ QNAME_MARSHAL ] ) ; } } private void writeElement ( XmlSerializer writer , Object element , PropertyInfo type , Object marshal ) throws IOException { if ( marshal != null ) ( ( Marshal ) marshal ) . writeInstance ( writer , element ) ; else if ( element instanceof SoapObject ) writeObjectBody ( writer , ( SoapObject ) element ) ; else if ( element instanceof KvmSerializable ) writeObjectBody ( writer , ( KvmSerializable ) element ) ; else if ( element instanceof Vector ) writeVectorBody ( writer , ( Vector ) element , type . elementType ) ; else throw new RuntimeException ( "Cannot serialize: " + element ) ; } protected void writeVectorBody ( XmlSerializer writer , Vector vector , PropertyInfo elementType ) throws IOException { if ( elementType == null ) elementType = PropertyInfo . OBJECT_TYPE ; int cnt = vector . size ( ) ; Object [ ] arrType = getInfo ( elementType . type , null ) ; writer . attribute ( enc , ARRAY_TYPE_LABEL , writer . getPrefix ( ( String ) arrType [ 0 ] , false ) + ":" + arrType [ 1 ] + "[" + cnt + "]" ) ; boolean skipped = false ; for ( int i = 0 ; i < cnt ; i ++ ) { if ( vector . elementAt ( i ) == null ) skipped = true ; else { writer . startTag ( null , ITEM_LABEL ) ; if ( skipped ) { writer . attribute ( enc , "position" , "[" + i + "]" ) ; skipped = false ; } writeProperty ( writer , vector . elementAt ( i ) , elementType ) ; writer . endTag ( null , ITEM_LABEL ) ; } } } } 