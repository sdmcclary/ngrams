public class PostgresModule extends AbstractQuercusModule { private static final Logger log = Log . open ( PostgresModule . class ) ; private static final L10N L = new L10N ( PostgresModule . class ) ; public static final int PGSQL_ASSOC = 0x01 ; public static final int PGSQL_NUM = 0x02 ; public static final int PGSQL_BOTH = 0x03 ; public static final int PGSQL_CONNECT_FORCE_NEW = 0x04 ; public static final int PGSQL_CONNECTION_BAD = 0x05 ; public static final int PGSQL_CONNECTION_OK = 0x06 ; public static final int PGSQL_SEEK_SET = 0x07 ; public static final int PGSQL_SEEK_CUR = 0x08 ; public static final int PGSQL_SEEK_END = 0x09 ; public static final int PGSQL_EMPTY_QUERY = 0x0A ; public static final int PGSQL_COMMAND_OK = 0x0B ; public static final int PGSQL_TUPLES_OK = 0x0C ; public static final int PGSQL_COPY_OUT = 0x0D ; public static final int PGSQL_COPY_IN = 0x0E ; public static final int PGSQL_BAD_RESPONSE = 0x0F ; public static final int PGSQL_NONFATAL_ERROR = 0x10 ; public static final int PGSQL_FATAL_ERROR = 0x11 ; public static final int PGSQL_TRANSACTION_IDLE = 0x12 ; public static final int PGSQL_TRANSACTION_ACTIVE = 0x13 ; public static final int PGSQL_TRANSACTION_INTRANS = 0x14 ; public static final int PGSQL_TRANSACTION_INERROR = 0x15 ; public static final int PGSQL_TRANSACTION_UNKNOWN = 0x16 ; public static final int PGSQL_DIAG_SEVERITY = 0x17 ; public static final int PGSQL_DIAG_SQLSTATE = 0x18 ; public static final int PGSQL_DIAG_MESSAGE_PRIMARY = 0x19 ; public static final int PGSQL_DIAG_MESSAGE_DETAIL = 0x20 ; public static final int PGSQL_DIAG_MESSAGE_HINT = 0x21 ; public static final int PGSQL_DIAG_STATEMENT_POSITION = 0x22 ; public static final int PGSQL_DIAG_INTERNAL_POSITION = 0x23 ; public static final int PGSQL_DIAG_INTERNAL_QUERY = 0x24 ; public static final int PGSQL_DIAG_CONTEXT = 0x25 ; public static final int PGSQL_DIAG_SOURCE_FILE = 0x26 ; public static final int PGSQL_DIAG_SOURCE_LINE = 0x27 ; public static final int PGSQL_DIAG_SOURCE_FUNCTION = 0x28 ; public static final int PGSQL_ERRORS_TERSE = 0x29 ; public static final int PGSQL_ERRORS_DEFAULT = 0x2A ; public static final int PGSQL_ERRORS_VERBOSE = 0x2B ; public static final int PGSQL_STATUS_LONG = 0x2C ; public static final int PGSQL_STATUS_STRING = 0x2D ; public static final int PGSQL_CONV_IGNORE_DEFAULT = 0x2E ; public static final int PGSQL_CONV_FORCE_NULL = 0x2F ; public PostgresModule ( ) { } public String [ ] getLoadedExtensions ( ) { return new String [ ] { "postgres" , "pgsql" } ; } public static int pg_affected_rows ( Env env , @ NotNull PostgresResult result ) { try { if ( result == null ) return - 1 ; return result . getAffectedRows ( ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return 0 ; } } public static int pg_cmdtuples ( Env env , @ NotNull PostgresResult result ) { if ( result == null ) return - 1 ; return pg_affected_rows ( env , result ) ; } public static boolean pg_cancel_query ( Env env , @ NotNull Postgres conn ) { try { if ( conn == null ) return false ; conn . setAsynchronousStatement ( null ) ; conn . setAsynchronousResult ( null ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } @ ReturnNullAsFalse public static String pg_client_encoding ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = getConnection ( env ) ; return conn . getClientEncoding ( ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_close ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) return false ; if ( conn == env . getSpecialValue ( "caucho.postgres" ) ) env . removeSpecialValue ( "caucho.postgres" ) ; conn . close ( env ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return false ; } @ ReturnNullAsFalse public static Postgres pg_connect ( Env env , String connectionString , @ Optional int connectionType ) { try { String host = "localhost" ; int port = 5432 ; String dbName = "" ; String userName = "" ; String password = "" ; HashMap < String , String > nameValueMap = parseConnectionString ( connectionString ) ; String value = nameValueMap . get ( "host" ) ; if ( value != null ) host = nameValueMap . get ( "host" ) ; value = nameValueMap . get ( "port" ) ; if ( value != null ) { port = 0 ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char ch = value . charAt ( i ) ; if ( '0' <= ch && ch <= '9' ) port = port * 10 + value . charAt ( i ) - '0' ; else break ; } } value = nameValueMap . get ( "dbname" ) ; if ( value != null ) dbName = value ; value = nameValueMap . get ( "user" ) ; if ( value != null ) userName = value ; value = nameValueMap . get ( "password" ) ; if ( value != null ) password = value ; String driver = "org.postgresql.Driver" ; String url = "jdbc:postgresql://" + host + ":" + port + "/" + dbName ; Postgres postgres = new Postgres ( env , host , userName , password , dbName , port , driver , url ) ; if ( ! postgres . isConnected ( ) ) return null ; env . setSpecialValue ( "caucho.postgres" , postgres ) ; return postgres ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } private static HashMap < String , String > parseConnectionString ( String s ) { HashMap < String , String > map = new HashMap < String , String > ( ) ; char ch ; int len = s . length ( ) ; int i = 0 ; CharBuffer buffer = new CharBuffer ( ) ; while ( i < len ) { buffer . clear ( ) ; for ( ; i < len && Character . isWhitespace ( ch = s . charAt ( i ) ) ; i ++ ) { } for ( ; i < len && ! Character . isWhitespace ( ch = s . charAt ( i ) ) && ch != '=' ; i ++ ) { buffer . append ( ch ) ; } String name = buffer . toString ( ) ; buffer . clear ( ) ; while ( i < len && ( ch = s . charAt ( i ++ ) ) != '=' ) { } for ( ; i < len && Character . isWhitespace ( ch = s . charAt ( i ) ) ; i ++ ) { } boolean isQuoted = false ; if ( i < len ) { if ( ( ch = s . charAt ( i ++ ) ) == '\'' ) isQuoted = true ; else buffer . append ( ch ) ; } boolean isEscaped = false ; loop : while ( i < len ) { ch = s . charAt ( i ++ ) ; switch ( ch ) { case '\\' : if ( isEscaped ) buffer . append ( ch ) ; isEscaped = ! isEscaped ; break ; case '\'' : if ( isEscaped ) { buffer . append ( ch ) ; isEscaped = false ; break ; } else if ( isQuoted ) break loop ; case ' ' : case '\n' : case '\r' : case '\f' : case '\t' : if ( isQuoted ) { buffer . append ( ch ) ; break ; } else if ( isEscaped ) { buffer . append ( '\\' ) ; break loop ; } else break loop ; default : if ( isEscaped ) { buffer . append ( '\\' ) ; isEscaped = false ; } buffer . append ( ch ) ; } } String value = buffer . toString ( ) ; if ( name . length ( ) > 0 ) map . put ( name , value ) ; } return map ; } public static boolean pg_connection_busy ( Env env , @ NotNull Postgres conn ) { return false ; } public static boolean pg_connection_reset ( Env env , @ NotNull Postgres conn ) { try { if ( conn == null ) return false ; String dbname = conn . getDbName ( ) ; conn . close ( env ) ; conn = new Postgres ( env , conn . getHost ( ) , conn . getUserName ( ) , conn . getPassword ( ) , dbname , conn . getPort ( ) , conn . getDriver ( ) , conn . getUrl ( ) ) ; env . setSpecialValue ( "caucho.postgres" , conn ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static int pg_connection_status ( Env env , @ NotNull Postgres conn ) { try { if ( conn == null ) return PGSQL_CONNECTION_BAD ; boolean ping = pg_ping ( env , conn ) ; return ping ? PGSQL_CONNECTION_OK : PGSQL_CONNECTION_BAD ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return PGSQL_CONNECTION_BAD ; } } @ ReturnNullAsFalse public static ArrayValue pg_convert ( Env env , @ NotNull Postgres conn , String tableName , ArrayValue assocArray , @ Optional ( "0" ) int options ) { try { if ( conn == null ) return null ; if ( options > 0 ) { throw new UnimplementedException ( "pg_convert with options" ) ; } Connection jdbcConn = conn . getJavaConnection ( ) ; DatabaseMetaData dbMetaData = jdbcConn . getMetaData ( ) ; ResultSet rs = dbMetaData . getColumns ( "" , "" , tableName , "" ) ; ResultSetMetaData rsMetaData = rs . getMetaData ( ) ; int n = rsMetaData . getColumnCount ( ) ; if ( n < assocArray . getSize ( ) ) return null ; ArrayValueImpl newArray = new ArrayValueImpl ( ) ; int matches = 0 ; while ( rs . next ( ) ) { String columnName = rs . getString ( "COLUMN_NAME" ) ; Value columnNameV = StringValue . create ( columnName ) ; Value value = assocArray . get ( columnNameV ) ; if ( value == UnsetValue . UNSET ) continue ; matches ++ ; if ( value . isNull ( ) ) { value = StringValue . create ( "NULL" ) ; newArray . put ( columnNameV , value ) ; continue ; } int dataType = rs . getInt ( "DATA_TYPE" ) ; switch ( dataType ) { case Types . BIT : case Types . TINYINT : case Types . SMALLINT : case Types . INTEGER : case Types . BIGINT : if ( value . isLongConvertible ( ) ) { value = LongValue . create ( value . toLong ( ) ) ; } else { StringValue sb = env . createUnicodeBuilder ( ) ; value = sb . append ( "'" ) . append ( value ) . append ( "'" ) ; } break ; case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . NUMERIC : case Types . REAL : if ( value . isDoubleConvertible ( ) ) { value = DoubleValue . create ( value . toDouble ( ) ) ; } else { StringValue sb = env . createUnicodeBuilder ( ) ; value = sb . append ( "'" ) . append ( value ) . append ( "'" ) ; } break ; default : StringValue sb = env . createUnicodeBuilder ( ) ; if ( value . isNumberConvertible ( ) ) { value = sb . append ( value ) ; } else { value = sb . append ( "'" ) . append ( value ) . append ( "'" ) ; } } newArray . put ( columnNameV , value ) ; } rs . close ( ) ; if ( matches < assocArray . getSize ( ) ) { return null ; } return newArray ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_copy_from ( Env env , @ NotNull Postgres conn , String tableName , ArrayValue rows , @ Optional ( "" ) String delimiter , @ Optional ( "" ) String nullAs ) { try { if ( conn == null ) return false ; String delimiterRegex ; if ( delimiter . equals ( "" ) ) { delimiter = "\t" ; delimiterRegex = "\\t" ; } else { throw new UnimplementedException ( "pg_copy_from with non-default delimiter" ) ; } if ( nullAs . equals ( "" ) ) { nullAs = "\\N" ; } else { throw new UnimplementedException ( "pg_copy_from with non-default nullAs" ) ; } ArrayValueImpl array = ( ArrayValueImpl ) rows ; int size = array . size ( ) ; String baseInsert = "INSERT INTO " + tableName + " VALUES(" ; StringBuilder sb = new StringBuilder ( baseInsert ) ; int lenBaseInsert = sb . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String line = array . get ( LongValue . create ( i ) ) . toString ( ) ; line = line . substring ( 0 , line . length ( ) - 1 ) ; sb . setLength ( lenBaseInsert ) ; String cols [ ] = line . split ( delimiterRegex ) ; int len = cols . length ; if ( len > 0 ) { len -- ; for ( int j = 0 ; j < len ; j ++ ) { if ( cols [ j ] . equals ( nullAs ) ) { sb . append ( "NULL, " ) ; } else { sb . append ( "'" ) ; sb . append ( cols [ j ] ) ; sb . append ( "', " ) ; } } if ( cols [ len ] . equals ( nullAs ) ) { sb . append ( "NULL)" ) ; } else { sb . append ( "'" ) ; sb . append ( cols [ len ] ) ; sb . append ( "')" ) ; } pg_query ( env , conn , sb . toString ( ) ) ; } } return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } @ ReturnNullAsFalse public static ArrayValue pg_copy_to ( Env env , @ NotNull Postgres conn , String tableName , @ Optional ( "" ) String delimiter , @ Optional ( "" ) String nullAs ) { try { if ( conn == null ) return null ; if ( delimiter . equals ( "" ) ) { delimiter = "\t" ; } if ( nullAs . equals ( "" ) ) { nullAs = "\\N" ; } PostgresResult result = pg_query ( env , conn , "SELECT * FROM " + tableName ) ; ArrayValueImpl newArray = new ArrayValueImpl ( ) ; Object value ; int curr = 0 ; while ( ( value = result . fetchArray ( env , PGSQL_NUM ) ) != null ) { ArrayValueImpl arr = ( ArrayValueImpl ) value ; int count = arr . size ( ) ; StringValue sb = env . createUnicodeBuilder ( ) ; LongValue currValue = LongValue . create ( curr ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( sb . length ( ) > 0 ) sb . append ( delimiter ) ; newArray . get ( currValue ) ; Value fieldValue = arr . get ( LongValue . create ( i ) ) ; if ( fieldValue instanceof NullValue ) { sb . append ( nullAs ) ; } else { sb . append ( fieldValue . toString ( ) ) ; } } sb . append ( "\n" ) ; newArray . put ( currValue , sb ) ; curr ++ ; } return newArray ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static String pg_dbname ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = getConnection ( env ) ; return conn . getDbName ( ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_delete ( Env env , @ NotNull Postgres conn , String tableName , ArrayValue assocArray , @ Optional ( "-1" ) int options ) { try { if ( conn == null ) return false ; if ( options > 0 ) { throw new UnimplementedException ( "pg_delete with options" ) ; } StringBuilder condition = new StringBuilder ( ) ; boolean isFirst = true ; for ( Map . Entry < Value , Value > entry : assocArray . entrySet ( ) ) { Value k = entry . getKey ( ) ; Value v = entry . getValue ( ) ; if ( isFirst ) { isFirst = false ; } else { condition . append ( " AND " ) ; } condition . append ( k . toString ( ) ) ; condition . append ( "='" ) ; condition . append ( v . toString ( ) ) ; condition . append ( "'" ) ; } StringBuilder query = new StringBuilder ( ) ; query . append ( "DELETE FROM " ) ; query . append ( tableName ) ; query . append ( " WHERE " ) ; query . append ( condition ) ; pg_query ( env , conn , query . toString ( ) ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static boolean pg_end_copy ( Env env , @ Optional Postgres conn ) { env . stub ( "pg_end_copy" ) ; return false ; } @ ReturnNullAsFalse public static StringValue pg_escape_bytea ( Env env , StringValue data ) { if ( data . length ( ) == 0 ) return data ; try { Class < ? > cl = Class . forName ( "org.postgresql.util.PGbytea" ) ; Method method = cl . getDeclaredMethod ( "toPGString" , new Class [ ] { byte [ ] . class } ) ; String s = ( String ) method . invoke ( cl , new Object [ ] { data . toBytes ( ) } ) ; return Postgres . pgRealEscapeString ( env . createString ( s , "UTF-8" ) ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static StringValue pg_escape_bytea ( Env env , @ NotNull Postgres conn , StringValue data ) { return pg_escape_bytea ( env , data ) ; } @ ReturnNullAsFalse public static StringValue pg_escape_string ( Env env , StringValue data ) { try { Postgres conn = getConnection ( env ) ; if ( conn == null ) return null ; return conn . realEscapeString ( data ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static PostgresResult pg_execute ( Env env , @ NotNull Postgres conn , String stmtName , ArrayValue params ) { try { if ( conn == null ) return null ; PostgresStatement pstmt = conn . getStatement ( stmtName ) ; return executeInternal ( env , conn , pstmt , params ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; conn . setResultResource ( null ) ; return null ; } } @ ReturnNullAsFalse public static ArrayValue pg_fetch_all_columns ( Env env , @ NotNull PostgresResult result , @ Optional ( "0" ) int column ) { try { if ( result == null ) return null ; ArrayValueImpl newArray = new ArrayValueImpl ( ) ; int curr = 0 ; for ( ArrayValue row = result . fetchRow ( env ) ; row != null ; row = result . fetchRow ( env ) ) { newArray . put ( LongValue . create ( curr ++ ) , row . get ( LongValue . create ( column ) ) ) ; } if ( newArray . getSize ( ) > 0 ) { return newArray ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return null ; } @ ReturnNullAsFalse public static ArrayValue pg_fetch_all ( Env env , @ NotNull PostgresResult result ) { try { if ( result == null ) return null ; ArrayValueImpl newArray = new ArrayValueImpl ( ) ; int curr = 0 ; for ( ArrayValue row = result . fetchAssoc ( env ) ; row != null ; row = result . fetchAssoc ( env ) ) { newArray . put ( LongValue . create ( curr ++ ) , row ) ; } if ( newArray . getSize ( ) > 0 ) { return newArray ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return null ; } @ ReturnNullAsFalse public static ArrayValue pg_fetch_array ( Env env , @ NotNull PostgresResult result , @ Optional ( "-1" ) Value row , @ Optional ( "PGSQL_BOTH" ) int resultType ) { try { if ( result == null ) return null ; if ( row . isNull ( ) ) { if ( result . getPassedNullRow ( ) ) { result . setPassedNullRow ( ) ; } else { ResultSet rs = result . getResultSet ( ) ; rs . previous ( ) ; } } if ( result == null ) return null ; if ( row . isLongConvertible ( ) && row . toInt ( ) >= 0 ) { if ( ! result . seek ( env , row . toInt ( ) ) ) { env . warning ( L . l ( "Unable to jump to row {0} on PostgreSQL result" , row . toInt ( ) ) ) ; return null ; } } return result . fetchArray ( env , resultType ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static ArrayValue pg_fetch_assoc ( Env env , @ NotNull PostgresResult result , @ Optional ( "-1" ) Value row ) { try { if ( result == null ) return null ; if ( ! row . isNull ( ) && row . toInt ( ) >= 0 ) { result . seek ( env , row . toInt ( ) ) ; } return result . fetchAssoc ( env ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static Value pg_fetch_object ( Env env , @ NotNull PostgresResult result , @ Optional ( "-1" ) Value row , @ Optional int resultType ) { try { if ( result == null ) return null ; if ( ( row != null ) && ( ! row . equals ( NullValue . NULL ) ) && ( row . toInt ( ) >= 0 ) ) { result . seek ( env , row . toInt ( ) ) ; } Value resultValue = result . fetchObject ( env ) ; if ( resultValue . isNull ( ) ) return BooleanValue . FALSE ; else return resultValue ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return BooleanValue . FALSE ; } } public static Value pg_fetch_result ( Env env , @ NotNull PostgresResult result , Value row , @ Optional ( "-1" ) Value fieldNameOrNumber ) { try { if ( result == null ) return null ; int rowNumber = - 1 ; if ( fieldNameOrNumber . isLongConvertible ( ) && ( fieldNameOrNumber . toInt ( ) < 0 ) ) { fieldNameOrNumber = row ; rowNumber = - 1 ; } else { rowNumber = row . toInt ( ) ; } if ( rowNumber >= 0 ) { result . seek ( env , rowNumber ) ; } Value fetchRow = result . fetchRow ( env ) ; int fieldNumber = result . getColumnNumber ( fieldNameOrNumber , 0 ) ; return fetchRow . get ( LongValue . create ( fieldNumber ) ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return BooleanValue . FALSE ; } } public static Value pg_result ( Env env , @ NotNull PostgresResult result , Value row , @ Optional ( "-1" ) Value fieldNameOrNumber ) { return pg_fetch_result ( env , result , row , fieldNameOrNumber ) ; } @ ReturnNullAsFalse public static ArrayValue pg_fetch_row ( Env env , @ NotNull PostgresResult result , @ Optional ( "-1" ) Value row ) { try { if ( result == null ) return null ; if ( row != null && ! row . equals ( NullValue . NULL ) && row . toInt ( ) >= 0 ) { result . seek ( env , row . toInt ( ) ) ; } return result . fetchRow ( env ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static LongValue pg_field_is_null ( Env env , @ NotNull PostgresResult result , Value row , @ Optional ( "-1" ) Value fieldNameOrNumber ) { try { if ( result == null ) return null ; int rowNumber = - 1 ; if ( fieldNameOrNumber . isLongConvertible ( ) && ( fieldNameOrNumber . toInt ( ) == - 1 ) ) { fieldNameOrNumber = row ; rowNumber = - 1 ; } else { rowNumber = row . toInt ( ) ; } if ( rowNumber >= 0 ) { if ( ! result . seek ( env , rowNumber ) ) { env . warning ( L . l ( "Unable to jump to row {0} on PostgreSQL result" , rowNumber ) ) ; return null ; } } int fieldNumber = result . getColumnNumber ( fieldNameOrNumber , 0 ) ; Value field = pg_fetch_result ( env , result , LongValue . MINUS_ONE , LongValue . create ( fieldNumber ) ) ; if ( field == null || field . isNull ( ) ) return LongValue . ONE ; else return LongValue . ZERO ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static LongValue pg_fieldisnull ( Env env , @ NotNull PostgresResult result , Value row , @ Optional ( "-1" ) Value fieldNameOrNumber ) { return pg_field_is_null ( env , result , row , fieldNameOrNumber ) ; } public static Value pg_field_name ( Env env , @ NotNull PostgresResult result , int fieldNumber ) { try { if ( result == null ) return BooleanValue . FALSE ; return result . getFieldName ( env , fieldNumber ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return BooleanValue . FALSE ; } } public static Value pg_fieldname ( Env env , @ NotNull PostgresResult result , int fieldNumber ) { return pg_field_name ( env , result , fieldNumber ) ; } public static int pg_field_num ( Env env , @ NotNull PostgresResult result , String fieldName ) { try { if ( result == null ) return - 1 ; return result . getColumnNumber ( fieldName ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return - 1 ; } } public static int pg_fieldnum ( Env env , @ NotNull PostgresResult result , String fieldName ) { return pg_field_num ( env , result , fieldName ) ; } public static int pg_field_prtlen ( Env env , @ NotNull PostgresResult result , Value rowNumber , @ Optional ( "-1" ) Value fieldNameOrNumber ) { try { if ( result == null ) return - 1 ; int row = rowNumber . toInt ( ) ; if ( fieldNameOrNumber . toString ( ) . equals ( "-1" ) ) { fieldNameOrNumber = rowNumber ; row = - 1 ; } int fieldNumber = result . getColumnNumber ( fieldNameOrNumber , 0 ) ; ResultSetMetaData metaData = result . getMetaData ( ) ; String typeName = metaData . getColumnTypeName ( fieldNumber + 1 ) ; if ( typeName . equals ( "bool" ) ) { return 1 ; } Value value = pg_fetch_result ( env , result , LongValue . create ( row ) , LongValue . create ( fieldNumber ) ) ; result . getResultSet ( ) . previous ( ) ; int len = value . toString ( ) . length ( ) ; return len ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return - 1 ; } } public static int pg_fieldprtlen ( Env env , @ NotNull PostgresResult result , Value rowNumber , @ Optional ( "-1" ) Value fieldNameOrNumber ) { return pg_field_prtlen ( env , result , rowNumber , fieldNameOrNumber ) ; } @ ReturnNullAsFalse public static LongValue pg_field_size ( Env env , @ NotNull PostgresResult result , int fieldNumber ) { try { if ( result == null ) return LongValue . create ( - 1 ) ; ResultSetMetaData metaData = result . getMetaData ( ) ; fieldNumber ++ ; int dataType = metaData . getColumnType ( fieldNumber ) ; int size = - 1 ; switch ( dataType ) { case Types . BIT : { String typeName = metaData . getColumnTypeName ( fieldNumber ) ; if ( typeName . equals ( "bool" ) ) { size = 1 ; } break ; } case Types . TINYINT : size = 1 ; break ; case Types . SMALLINT : size = 2 ; break ; case Types . DATE : case Types . FLOAT : case Types . INTEGER : case Types . REAL : size = 4 ; break ; case Types . BIGINT : case Types . DOUBLE : { size = 8 ; String typeName = metaData . getColumnTypeName ( fieldNumber ) ; if ( typeName . equals ( "money" ) ) { size = 4 ; } } break ; case Types . TIME : case Types . TIMESTAMP : size = 8 ; default : { String typeName = metaData . getColumnTypeName ( fieldNumber ) ; if ( typeName . equals ( "timetz" ) || typeName . equals ( "interval" ) ) { size = 12 ; } else if ( typeName . equals ( "macaddr" ) ) { size = 6 ; } else if ( typeName . equals ( "point" ) ) { size = 16 ; } else if ( typeName . equals ( "circle" ) ) { size = 24 ; } else if ( typeName . equals ( "box" ) || typeName . equals ( "lseg" ) ) { size = 32 ; } } } return LongValue . create ( size ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static LongValue pg_fieldsize ( Env env , @ NotNull PostgresResult result , int fieldNumber ) { return pg_field_size ( env , result , fieldNumber ) ; } @ ReturnNullAsFalse public static String pg_field_table ( Env env , @ NotNull PostgresResult result , int fieldNumber , @ Optional ( "false" ) boolean oidOnly ) { env . stub ( "pg_field_table" ) ; return "" ; } @ ReturnNullAsFalse public static LongValue pg_field_type_oid ( Env env , @ NotNull PostgresResult result , int fieldNumber ) { try { if ( result == null ) return null ; ResultSetMetaData metaData = result . getMetaData ( ) ; String columnTypeName = metaData . getColumnTypeName ( fieldNumber + 1 ) ; String metaQuery = ( "SELECT oid FROM pg_type WHERE typname='" + columnTypeName + "'" ) ; result = pg_query ( env , ( Postgres ) result . getConnection ( ) , metaQuery ) ; Value value = pg_fetch_result ( env , result , LongValue . MINUS_ONE , LongValue . ZERO ) ; if ( value . isLongConvertible ( ) ) { return LongValue . create ( value . toLong ( ) ) ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return null ; } @ ReturnNullAsFalse public static StringValue pg_field_type ( Env env , @ NotNull PostgresResult result , int fieldNumber ) { try { if ( result == null ) return null ; ResultSetMetaData metaData = result . getMetaData ( ) ; fieldNumber ++ ; String typeName = metaData . getColumnTypeName ( fieldNumber ) ; return ( StringValue ) StringValue . create ( typeName ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static StringValue pg_fieldtype ( Env env , @ NotNull PostgresResult result , int fieldNumber ) { return pg_field_type ( env , result , fieldNumber ) ; } public static boolean pg_free_result ( Env env , PostgresResult result ) { try { if ( result == null ) return true ; result . close ( ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return true ; } } public static boolean pg_freeresult ( Env env , PostgresResult result ) { if ( result == null ) return true ; return pg_free_result ( env , result ) ; } @ ReturnNullAsFalse public static ArrayValue pg_get_notify ( Env env , @ NotNull Postgres conn , @ Optional ( "-1" ) int resultType ) { try { if ( conn == null ) return null ; if ( resultType > 0 ) { throw new UnimplementedException ( "pg_get_notify with result type" ) ; } Class < ? > cl = Class . forName ( "org.postgresql.PGConnection" ) ; Method method = cl . getDeclaredMethod ( "getNotifications" ) ; Connection pgconn = conn . getJavaConnection ( ) ; Object notifications [ ] = ( Object [ ] ) method . invoke ( pgconn ) ; cl = Class . forName ( "org.postgresql.PGNotification" ) ; Method methodGetName = cl . getDeclaredMethod ( "getName" ) ; Method methodGetPID = cl . getDeclaredMethod ( "getPID" ) ; ArrayValueImpl arrayValue = new ArrayValueImpl ( ) ; int n = notifications . length ; StringValue k ; LongValue v ; for ( int i = 0 ; i < n ; i ++ ) { k = ( StringValue ) StringValue . create ( methodGetName . invoke ( notifications [ i ] , new Object [ ] { } ) ) ; v = ( LongValue ) LongValue . create ( ( Integer ) methodGetPID . invoke ( notifications [ i ] , new Object [ ] { } ) ) ; arrayValue . put ( k , v ) ; } return arrayValue ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static int pg_get_pid ( Env env , @ NotNull Postgres conn ) { try { if ( conn == null ) return - 1 ; String randomLabel = "caucho_pg_get_pid_random_label" ; pg_query ( env , conn , "LISTEN " + randomLabel ) ; pg_query ( env , conn , "NOTIFY " + randomLabel ) ; ArrayValue arrayValue = pg_get_notify ( env , conn , - 1 ) ; LongValue pid = ( LongValue ) arrayValue . get ( StringValue . create ( randomLabel ) ) ; return pid . toInt ( ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return - 1 ; } } @ ReturnNullAsFalse public static PostgresResult pg_get_result ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = getConnection ( env ) ; PostgresResult result = ( PostgresResult ) conn . getResultResource ( ) ; if ( conn . getAsynchronousStatement ( ) != null ) { if ( conn . getAsynchronousResult ( ) != null ) { conn . setAsynchronousResult ( null ) ; return result ; } return null ; } if ( conn . getAsynchronousResult ( ) != null ) { Statement stmt = result . getJavaStatement ( ) ; if ( stmt . getMoreResults ( ) ) { result = ( PostgresResult ) conn . createResult ( env , stmt , stmt . getResultSet ( ) ) ; } else { conn . setResultResource ( null ) ; } } conn . setAsynchronousResult ( result ) ; return result ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static String pg_host ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = getConnection ( env ) ; return conn . getHost ( ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_insert ( Env env , @ NotNull Postgres conn , String tableName , ArrayValue assocArray , @ Optional ( "-1" ) int options ) { try { if ( conn == null ) return false ; if ( options > 0 ) { throw new UnimplementedException ( "pg_insert with options" ) ; } StringBuilder names = new StringBuilder ( ) ; StringBuilder values = new StringBuilder ( ) ; boolean isFirst = true ; for ( Map . Entry < Value , Value > entry : assocArray . entrySet ( ) ) { Value k = entry . getKey ( ) ; Value v = entry . getValue ( ) ; if ( isFirst ) { isFirst = false ; } else { values . append ( "','" ) ; names . append ( "," ) ; } values . append ( v . toString ( ) ) ; names . append ( k . toString ( ) ) ; } StringBuilder query = new StringBuilder ( ) ; query . append ( "INSERT INTO " ) ; query . append ( tableName ) ; query . append ( "(" ) ; query . append ( names ) ; query . append ( ") VALUES('" ) ; query . append ( values ) ; query . append ( "')" ) ; pg_query ( env , conn , query . toString ( ) ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } @ ReturnNullAsFalse public static StringValue pg_last_error ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = getConnection ( env ) ; return conn . error ( env ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static StringValue pg_errormessage ( Env env , @ Optional Postgres conn ) { return pg_last_error ( env , conn ) ; } @ ReturnNullAsFalse public static String pg_last_notice ( Env env , @ NotNull Postgres conn ) { try { if ( conn == null ) return null ; SQLWarning warning = conn . getWarnings ( ) ; if ( warning != null ) return warning . toString ( ) ; else return null ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static String pg_last_oid ( Env env , PostgresResult result ) { try { Statement stmt = result . getJavaStatement ( ) ; Class < ? > cl = Class . forName ( "org.postgresql.jdbc2.AbstractJdbc2Statement" ) ; Method method = cl . getDeclaredMethod ( "getLastOID" ) ; int oid = Integer . parseInt ( method . invoke ( stmt , new Object [ ] { } ) . toString ( ) ) ; if ( oid > 0 ) return "" + oid ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return null ; } @ ReturnNullAsFalse public static String pg_getlastoid ( Env env , PostgresResult result ) { return pg_last_oid ( env , result ) ; } public static boolean pg_lo_close ( Env env , Object largeObject ) { try { Class < ? > cl = Class . forName ( "org.postgresql.largeobject.LargeObject" ) ; Method method = cl . getDeclaredMethod ( "close" ) ; method . invoke ( largeObject , new Object [ ] { } ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static boolean pg_loclose ( Env env , Object largeObject ) { return pg_lo_close ( env , largeObject ) ; } @ ReturnNullAsFalse public static LongValue pg_lo_create ( Env env , @ Optional Postgres conn ) { try { int oid = - 1 ; if ( conn == null ) conn = getConnection ( env ) ; Object lobManager ; Class < ? > cl = Class . forName ( "org.postgresql.PGConnection" ) ; Method method = cl . getDeclaredMethod ( "getLargeObjectAPI" ) ; Connection pgconn = conn . getJavaConnection ( ) ; pgconn . setAutoCommit ( false ) ; lobManager = method . invoke ( pgconn , new Object [ ] { } ) ; cl = Class . forName ( "org.postgresql.largeobject.LargeObjectManager" ) ; method = cl . getDeclaredMethod ( "create" ) ; Object oidObj = method . invoke ( lobManager , new Object [ ] { } ) ; oid = Integer . parseInt ( oidObj . toString ( ) ) ; return LongValue . create ( oid ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static LongValue pg_locreate ( Env env , @ Optional Postgres conn ) { return pg_lo_create ( env , conn ) ; } public static boolean pg_lo_export ( Env env , @ NotNull Postgres conn , int oid , Path path ) { try { if ( conn == null ) return false ; Object lobManager ; Class < ? > cl = Class . forName ( "org.postgresql.PGConnection" ) ; Method method = cl . getDeclaredMethod ( "getLargeObjectAPI" ) ; Connection pgconn = conn . getJavaConnection ( ) ; lobManager = method . invoke ( pgconn , new Object [ ] { } ) ; cl = Class . forName ( "org.postgresql.largeobject.LargeObjectManager" ) ; method = cl . getDeclaredMethod ( "open" , new Class [ ] { Integer . TYPE } ) ; Object lobj = method . invoke ( lobManager , new Object [ ] { oid } ) ; cl = Class . forName ( "org.postgresql.largeobject.LargeObject" ) ; method = cl . getDeclaredMethod ( "getInputStream" ) ; Object isObj = method . invoke ( lobj , new Object [ ] { } ) ; InputStream is = ( InputStream ) isObj ; WriteStream os = path . openWrite ( ) ; os . writeStream ( is ) ; os . close ( ) ; is . close ( ) ; method = cl . getDeclaredMethod ( "close" ) ; method . invoke ( lobj , new Object [ ] { } ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static boolean pg_loexport ( Env env , @ NotNull Postgres conn , int oid , Path path ) { return pg_lo_export ( env , conn , oid , path ) ; } @ ReturnNullAsFalse public static LongValue pg_lo_import ( Env env , @ NotNull Postgres conn , Path path ) { try { if ( conn == null ) return null ; LongValue value = pg_lo_create ( env , conn ) ; if ( value != null ) { int oid = value . toInt ( ) ; Object largeObject = pg_lo_open ( env , conn , oid , "w" ) ; ReadStream is = path . openRead ( ) ; writeLobInternal ( largeObject , is , Integer . MAX_VALUE ) ; pg_lo_close ( env , largeObject ) ; is . close ( ) ; return LongValue . create ( oid ) ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return null ; } @ ReturnNullAsFalse public static LongValue pg_loimport ( Env env , @ NotNull Postgres conn , Path path ) { return pg_lo_import ( env , conn , path ) ; } @ ReturnNullAsFalse public static Object pg_lo_open ( Env env , @ NotNull Postgres conn , int oid , String mode ) { try { if ( conn == null ) return null ; Object largeObject = null ; Object lobManager ; Class < ? > cl = Class . forName ( "org.postgresql.PGConnection" ) ; Method method = cl . getDeclaredMethod ( "getLargeObjectAPI" ) ; Connection pgconn = conn . getJavaConnection ( ) ; lobManager = method . invoke ( pgconn , new Object [ ] { } ) ; cl = Class . forName ( "org.postgresql.largeobject.LargeObjectManager" ) ; method = cl . getDeclaredMethod ( "open" , new Class [ ] { Integer . TYPE , Integer . TYPE } ) ; boolean write = mode . indexOf ( "w" ) >= 0 ; boolean read = mode . indexOf ( "r" ) >= 0 ; int modeREAD = cl . getDeclaredField ( "READ" ) . getInt ( null ) ; int modeREADWRITE = cl . getDeclaredField ( "READWRITE" ) . getInt ( null ) ; int modeWRITE = cl . getDeclaredField ( "WRITE" ) . getInt ( null ) ; int intMode = modeREAD ; if ( read ) { if ( write ) { intMode = modeREADWRITE ; } } else if ( write ) { intMode = modeWRITE ; } largeObject = method . invoke ( lobManager , new Object [ ] { oid , intMode } ) ; return largeObject ; } catch ( Exception ex ) { env . warning ( L . l ( "Unable to open PostgreSQL large object" ) ) ; log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static Object pg_loopen ( Env env , @ NotNull Postgres conn , int oid , String mode ) { return pg_lo_open ( env , conn , oid , mode ) ; } @ ReturnNullAsFalse public static LongValue pg_lo_read_all ( Env env , Object largeObject ) { try { StringValue contents = pg_lo_read ( env , largeObject , - 1 ) ; if ( contents != null ) { env . getOut ( ) . print ( contents ) ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return null ; } @ ReturnNullAsFalse public static LongValue pg_loreadall ( Env env , Object largeObject ) { return pg_lo_read_all ( env , largeObject ) ; } @ ReturnNullAsFalse public static StringValue pg_lo_read ( Env env , Object largeObject , @ Optional ( "-1" ) int len ) { try { if ( len < 0 ) { len = Integer . MAX_VALUE ; } Class < ? > cl = Class . forName ( "org.postgresql.largeobject.LargeObject" ) ; Method method = cl . getDeclaredMethod ( "getInputStream" ) ; InputStream is = ( InputStream ) method . invoke ( largeObject , new Object [ ] { } ) ; try { StringValue bb = env . createBinaryBuilder ( ) ; bb . appendReadAll ( is , len ) ; return bb ; } finally { is . close ( ) ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static StringValue pg_loread ( Env env , Object largeObject , @ Optional ( "-1" ) int len ) { return pg_lo_read ( env , largeObject , len ) ; } public static boolean pg_lo_seek ( Env env , Object largeObject , int offset , @ Optional int whence ) { try { Class < ? > cl = Class . forName ( "org.postgresql.largeobject.LargeObject" ) ; int seekSET = cl . getDeclaredField ( "SEEK_SET" ) . getInt ( null ) ; int seekEND = cl . getDeclaredField ( "SEEK_END" ) . getInt ( null ) ; int seekCUR = cl . getDeclaredField ( "SEEK_CUR" ) . getInt ( null ) ; switch ( whence ) { case PGSQL_SEEK_SET : whence = seekSET ; break ; case PGSQL_SEEK_END : whence = seekEND ; break ; default : whence = seekCUR ; } Method method = cl . getDeclaredMethod ( "seek" , new Class [ ] { Integer . TYPE , Integer . TYPE } ) ; method . invoke ( largeObject , new Object [ ] { offset , whence } ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static int pg_lo_tell ( Env env , Object largeObject ) { try { Class < ? > cl = Class . forName ( "org.postgresql.largeobject.LargeObject" ) ; Method method = cl . getDeclaredMethod ( "tell" ) ; Object obj = method . invoke ( largeObject , new Object [ ] { } ) ; return Integer . parseInt ( obj . toString ( ) ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return - 1 ; } } public static boolean pg_lo_unlink ( Env env , @ NotNull Postgres conn , int oid ) { try { if ( conn == null ) return false ; Object lobManager ; Class < ? > cl = Class . forName ( "org.postgresql.PGConnection" ) ; Method method = cl . getDeclaredMethod ( "getLargeObjectAPI" ) ; Connection pgconn = conn . getJavaConnection ( ) ; lobManager = method . invoke ( pgconn , new Object [ ] { } ) ; cl = Class . forName ( "org.postgresql.largeobject.LargeObjectManager" ) ; method = cl . getDeclaredMethod ( "unlink" , Integer . TYPE ) ; method . invoke ( lobManager , new Object [ ] { oid } ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static boolean pg_lounlink ( Env env , @ NotNull Postgres conn , int oid ) { return pg_lo_unlink ( env , conn , oid ) ; } @ ReturnNullAsFalse public static LongValue pg_lo_write ( Env env , @ NotNull Object largeObject , String data , @ Optional int len ) { try { if ( largeObject == null ) return null ; if ( len <= 0 ) { len = data . length ( ) ; } int written = len ; Class < ? > cl = Class . forName ( "org.postgresql.largeobject.LargeObject" ) ; Method method = cl . getDeclaredMethod ( "write" , new Class [ ] { byte [ ] . class , Integer . TYPE , Integer . TYPE } ) ; method . invoke ( largeObject , new Object [ ] { data . getBytes ( ) , 0 , len } ) ; return LongValue . create ( written ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static LongValue pg_lowrite ( Env env , @ NotNull Object largeObject , String data , @ Optional int len ) { return pg_lo_write ( env , largeObject , data , len ) ; } @ ReturnNullAsFalse public static ArrayValue pg_meta_data ( Env env , @ NotNull Postgres conn , String tableName ) { env . stub ( "pg_meta_data" ) ; return null ; } public static int pg_num_fields ( Env env , @ NotNull PostgresResult result ) { try { return result . getFieldCount ( ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return - 1 ; } } public static int pg_numfields ( Env env , @ NotNull PostgresResult result ) { return pg_num_fields ( env , result ) ; } public static LongValue pg_num_rows ( Env env , @ NotNull PostgresResult result ) { int numRows = - 1 ; try { if ( result == null ) return LongValue . create ( - 1 ) ; if ( ( result != null ) && ( result . getResultSet ( ) != null ) ) { numRows = result . getNumRows ( ) ; } if ( numRows < 0 ) { env . warning ( L . l ( "supplied argument is not a valid PostgreSQL result resource" ) ) ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return LongValue . create ( numRows ) ; } public static LongValue pg_numrows ( Env env , @ NotNull PostgresResult result ) { return pg_num_rows ( env , result ) ; } public static String pg_options ( Env env , @ Optional Postgres conn ) { throw new UnimplementedException ( "pg_options" ) ; } public static Value pg_parameter_status ( Env env , @ NotNull Postgres conn , @ NotNull StringValue paramName ) { try { if ( conn == null || paramName == null ) return BooleanValue . FALSE ; PostgresResult result = pg_query ( env , conn , "SHOW " + paramName ) ; Value value = pg_fetch_result ( env , result , LongValue . ZERO , LongValue . ZERO ) ; if ( value == null || value . isNull ( ) ) return BooleanValue . FALSE ; if ( paramName . toString ( ) . equals ( "server_encoding" ) ) { if ( value . equals ( env . createString ( "UNICODE" , "UTF-8" ) ) ) value = env . createString ( "UTF8" , "UTF-8" ) ; } return value ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return BooleanValue . FALSE ; } } public static Value pg_parameter_status ( Env env , @ NotNull StringValue paramName ) { Postgres conn = getConnection ( env ) ; return pg_parameter_status ( env , conn , paramName ) ; } @ ReturnNullAsFalse public static Postgres pg_pconnect ( Env env , String connectionString , @ Optional int connectType ) { return pg_connect ( env , connectionString , connectType ) ; } public static boolean pg_ping ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = getConnection ( env ) ; return pg_query ( env , conn , "SELECT 1" ) != null ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } @ ReturnNullAsFalse public static StringValue pg_port ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = getConnection ( env ) ; return ( StringValue ) StringValue . create ( conn . getPort ( ) ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static PostgresStatement pg_prepare ( Env env , @ NotNull Postgres conn , String stmtName , String query ) { try { if ( conn == null ) return null ; PostgresStatement pstmt = conn . prepare ( env , env . createString ( query , "UTF-8" ) ) ; conn . putStatement ( stmtName , pstmt ) ; return pstmt ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_put_line ( Env env , @ NotNull Postgres conn , String data ) { try { if ( conn == null ) return false ; Class < ? > cl = Class . forName ( "org.postgresql.core.PGStream" ) ; Constructor < ? > constructor = cl . getDeclaredConstructor ( new Class [ ] { String . class , Integer . TYPE } ) ; Object object = constructor . newInstance ( new Object [ ] { conn . getHost ( ) , conn . getPort ( ) } ) ; byte dataArray [ ] = data . getBytes ( ) ; Method method = cl . getDeclaredMethod ( "Send" , new Class [ ] { byte [ ] . class } ) ; method . invoke ( object , new Object [ ] { dataArray } ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } @ ReturnNullAsFalse public static PostgresResult pg_query_params ( Env env , @ NotNull Postgres conn , String query , ArrayValue params ) { try { if ( conn == null ) return null ; if ( pg_send_query_params ( env , conn , query , params ) ) { return ( PostgresResult ) conn . getResultResource ( ) ; } return null ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } @ ReturnNullAsFalse public static PostgresResult pg_query ( Env env , @ NotNull String query ) { if ( query == null ) return null ; return pg_query_impl ( env , getConnection ( env ) , query , true ) ; } @ ReturnNullAsFalse public static PostgresResult pg_query ( Env env , @ NotNull Postgres conn , @ NotNull String query ) { if ( conn == null || query == null ) return null ; return pg_query_impl ( env , conn , query , true ) ; } @ ReturnNullAsFalse public static PostgresResult pg_exec ( Env env , @ NotNull Postgres conn , String query ) { if ( conn == null ) return null ; return pg_query ( env , conn , query ) ; } private static PostgresResult pg_query_impl ( Env env , Postgres conn , String query , boolean reportError ) { try { if ( conn == null ) conn = getConnection ( env ) ; PostgresResult result = conn . query ( env , query ) ; StringValue error = conn . error ( env ) ; if ( error . length ( ) != 0 ) { if ( reportError ) env . warning ( L . l ( "Query failed: {0}" , error ) ) ; return null ; } return result ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return null ; } public static Value pg_result_error_field ( Env env , @ NotNull PostgresResult result , int fieldCode ) { try { if ( result == null ) return BooleanValue . FALSE ; Object errorField = null ; Object serverError = ( ( Postgres ) result . getConnection ( ) ) . getServerErrorMessage ( ) ; if ( serverError != null ) { Class < ? > cl = Class . forName ( "org.postgresql.util.ServerErrorMessage" ) ; String methodName ; switch ( fieldCode ) { case PGSQL_DIAG_SEVERITY : methodName = "getSeverity" ; break ; case PGSQL_DIAG_SQLSTATE : methodName = "getSQLState" ; break ; case PGSQL_DIAG_MESSAGE_PRIMARY : methodName = "getMessage" ; break ; case PGSQL_DIAG_MESSAGE_DETAIL : methodName = "getDetail" ; break ; case PGSQL_DIAG_MESSAGE_HINT : methodName = "getHint" ; break ; case PGSQL_DIAG_STATEMENT_POSITION : methodName = "getPosition" ; break ; case PGSQL_DIAG_INTERNAL_POSITION : methodName = "getInternalPosition" ; break ; case PGSQL_DIAG_INTERNAL_QUERY : methodName = "getInternalQuery" ; break ; case PGSQL_DIAG_CONTEXT : methodName = "getWhere" ; break ; case PGSQL_DIAG_SOURCE_FILE : methodName = "getFile" ; break ; case PGSQL_DIAG_SOURCE_LINE : methodName = "getLine" ; break ; case PGSQL_DIAG_SOURCE_FUNCTION : methodName = "getRoutine" ; break ; default : return null ; } Method method = cl . getDeclaredMethod ( methodName ) ; errorField = method . invoke ( serverError ) ; } if ( errorField == null ) { return NullValue . NULL ; } if ( fieldCode == PGSQL_DIAG_STATEMENT_POSITION ) { Integer position = ( Integer ) errorField ; if ( position . intValue ( ) == 0 ) return NullValue . NULL ; } if ( fieldCode == PGSQL_DIAG_INTERNAL_POSITION ) { Integer position = ( Integer ) errorField ; if ( position . intValue ( ) == 0 ) return NullValue . NULL ; } return StringValue . create ( errorField . toString ( ) ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return NullValue . NULL ; } } @ ReturnNullAsFalse public static String pg_result_error ( Env env , @ Optional PostgresResult result ) { try { if ( result != null ) return result . getConnection ( ) . getErrorMessage ( ) ; else return null ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_result_seek ( Env env , @ NotNull PostgresResult result , int offset ) { try { if ( result == null ) return false ; return result . seek ( env , offset ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static int pg_result_status ( Env env , @ NotNull PostgresResult result , @ Optional ( "PGSQL_STATUS_LONG" ) int type ) { try { if ( result == null ) return - 1 ; if ( type == PGSQL_STATUS_STRING ) { throw new UnimplementedException ( "pg_result_status with PGSQL_STATUS_STRING" ) ; } if ( result != null ) { Statement stmt = result . getStatement ( ) ; if ( stmt . getUpdateCount ( ) >= 0 ) { return PGSQL_COMMAND_OK ; } ResultSet rs = result . getResultSet ( ) ; if ( rs == null ) { return PGSQL_EMPTY_QUERY ; } return PGSQL_TUPLES_OK ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return - 1 ; } @ ReturnNullAsFalse public static ArrayValue pg_select ( Env env , @ NotNull Postgres conn , String tableName , ArrayValue assocArray , @ Optional ( "-1" ) int options ) { try { if ( conn == null ) return null ; StringValue whereClause = env . createUnicodeBuilder ( ) ; boolean isFirst = true ; for ( Map . Entry < Value , Value > entry : assocArray . entrySet ( ) ) { Value k = entry . getKey ( ) ; Value v = entry . getValue ( ) ; if ( isFirst ) { isFirst = false ; } else { whereClause . append ( " AND " ) ; } whereClause . append ( k . toString ( ) ) . append ( "='" ) . append ( v . toString ( ) ) . append ( "'" ) ; } StringValue query = env . createUnicodeBuilder ( ) ; query . append ( "SELECT * FROM " ) . append ( tableName ) . append ( " WHERE " ) . append ( whereClause ) ; PostgresResult result = pg_query ( env , conn , query . toString ( ) ) ; return pg_fetch_all ( env , result ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_send_execute ( Env env , @ NotNull Postgres conn , String stmtName , ArrayValue params ) { try { PostgresResult result = pg_execute ( env , conn , stmtName , params ) ; conn . setAsynchronousResult ( result ) ; if ( result != null ) { return true ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return false ; } public static boolean pg_send_prepare ( Env env , @ NotNull Postgres conn , String stmtName , String query ) { try { PostgresStatement stmt = pg_prepare ( env , conn , stmtName , query ) ; conn . setAsynchronousStatement ( stmt ) ; if ( stmt != null ) { return true ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return false ; } public static boolean pg_send_query_params ( Env env , @ NotNull Postgres conn , String query , ArrayValue params ) { try { PostgresStatement pstmt = conn . prepare ( env , env . createString ( query , "UTF-8" ) ) ; return executeInternal ( env , conn , pstmt , params ) != null ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } public static boolean pg_send_query ( Env env , @ NotNull Postgres conn , String query ) { if ( conn == null ) return false ; try { pg_query_impl ( env , conn , query , false ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; } return false ; } public static int pg_set_client_encoding ( Env env , @ NotNull Postgres conn , String encoding ) { if ( conn == null ) conn = getConnection ( env ) ; if ( conn . setClientEncoding ( encoding ) ) return 0 ; else return - 1 ; } public static int pg_set_error_verbosity ( Env env , @ NotNull Postgres conn , int intVerbosity ) { try { String verbosity ; PostgresResult result = pg_query ( env , conn , "SHOW log_error_verbosity" ) ; ArrayValue arr = pg_fetch_row ( env , result , LongValue . ZERO ) ; String prevVerbosity = arr . get ( LongValue . ZERO ) . toString ( ) ; switch ( intVerbosity ) { case PGSQL_ERRORS_TERSE : verbosity = "TERSE" ; break ; case PGSQL_ERRORS_VERBOSE : verbosity = "VERBOSE" ; break ; default : verbosity = "DEFAULT" ; } pg_query ( env , conn , "SET log_error_verbosity TO '" + verbosity + "'" ) ; if ( prevVerbosity . equals ( "TERSE" ) ) { return PGSQL_ERRORS_TERSE ; } else if ( prevVerbosity . equals ( "VERBOSE" ) ) { return PGSQL_ERRORS_VERBOSE ; } else { return PGSQL_ERRORS_DEFAULT ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return - 1 ; } } public static boolean pg_trace ( Env env , Path path , @ Optional String mode , @ Optional Postgres conn ) { env . stub ( "pg_trace" ) ; return false ; } public static int pg_transaction_status ( Env env , @ Optional Postgres conn ) { return PGSQL_TRANSACTION_IDLE ; } public static String pg_tty ( Env env , @ Optional Postgres conn ) { env . stub ( "pg_tty" ) ; return "" ; } @ ReturnNullAsFalse public static String pg_unescape_bytea ( Env env , String data ) { try { byte dataBytes [ ] = data . getBytes ( ) ; Class < ? > cl = Class . forName ( "org.postgresql.util.PGbytea" ) ; Method method = cl . getDeclaredMethod ( "toBytes" , new Class [ ] { byte [ ] . class } ) ; return new String ( ( byte [ ] ) method . invoke ( cl , new Object [ ] { dataBytes } ) ) ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } public static boolean pg_untrace ( Env env , @ Optional Postgres conn ) { env . stub ( "pg_untrace" ) ; return true ; } public static boolean pg_update ( Env env , @ NotNull Postgres conn , String tableName , ArrayValue data , ArrayValue condition , @ Optional int options ) { try { if ( options > 0 ) { throw new UnimplementedException ( "pg_update with options" ) ; } StringBuilder values = new StringBuilder ( ) ; boolean isFirst = true ; for ( Map . Entry < Value , Value > entry : data . entrySet ( ) ) { Value k = entry . getKey ( ) ; Value v = entry . getValue ( ) ; if ( isFirst ) { isFirst = false ; } else { values . append ( ", " ) ; } values . append ( k . toString ( ) ) ; values . append ( "='" ) ; values . append ( v . toString ( ) ) ; values . append ( "'" ) ; } StringBuilder whereClause = new StringBuilder ( ) ; isFirst = true ; for ( Map . Entry < Value , Value > entry : condition . entrySet ( ) ) { Value k = entry . getKey ( ) ; Value v = entry . getValue ( ) ; if ( isFirst ) { isFirst = false ; } else { whereClause . append ( " AND " ) ; } whereClause . append ( k . toString ( ) ) ; whereClause . append ( "='" ) ; whereClause . append ( v . toString ( ) ) ; whereClause . append ( "'" ) ; } StringBuilder query = new StringBuilder ( ) ; query . append ( "UPDATE " ) ; query . append ( tableName ) ; query . append ( " SET " ) ; query . append ( values ) ; query . append ( " WHERE " ) ; query . append ( whereClause ) ; pg_query ( env , conn , query . toString ( ) ) ; return true ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return false ; } } @ ReturnNullAsFalse public static ArrayValue pg_version ( Env env , @ Optional Postgres conn ) { try { if ( conn == null ) conn = ( Postgres ) env . getSpecialValue ( "caucho.postgres" ) ; ArrayValue result = new ArrayValueImpl ( ) ; result . append ( env . createStringOld ( "client" ) , env . createString ( conn . getClientInfo ( ) , "UTF-8" ) ) ; result . append ( env . createStringOld ( "server_version" ) , env . createString ( conn . getServerInfo ( ) , "UTF-8" ) ) ; return result ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } private static Postgres getConnection ( Env env ) { Postgres conn = ( Postgres ) env . getSpecialValue ( "caucho.postgres" ) ; if ( conn != null ) return conn ; String driver = "org.postgresql.Driver" ; String url = "jdbc:postgresql://localhost:5432/" ; conn = new Postgres ( env , "localhost" , "" , "" , "" , 5432 , driver , url ) ; env . setSpecialValue ( "caucho.postgres" , conn ) ; return conn ; } private static PostgresResult executeInternal ( Env env , @ NotNull Postgres conn , PostgresStatement pstmt , ArrayValue params ) { try { StringBuilder stringBuilder = new StringBuilder ( ) ; int size = params . getSize ( ) ; for ( int i = 0 ; i < size ; i ++ ) stringBuilder . append ( 's' ) ; String types = stringBuilder . toString ( ) ; Value value [ ] = params . valuesToArray ( ) ; pstmt . bindParams ( env , types , value ) ; if ( ! pstmt . execute ( env ) ) return null ; if ( pstmt . getStatementType ( ) . equals ( "SELECT" ) ) { PostgresResult result = new PostgresResult ( env , null , pstmt . getResultSet ( ) , null ) ; conn . setResultResource ( result ) ; return result ; } else { return null ; } } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return null ; } } private static int writeLobInternal ( Object largeObject , InputStream is , int len ) { try { Class < ? > cl = Class . forName ( "org.postgresql.largeobject.LargeObject" ) ; Method method = cl . getDeclaredMethod ( "getOutputStream" ) ; OutputStream os = ( OutputStream ) method . invoke ( largeObject , new Object [ ] { } ) ; int written = 0 ; int b ; while ( ( ( b = is . read ( ) ) >= 0 ) && ( written ++ < len ) ) { os . write ( b ) ; } os . close ( ) ; return written ; } catch ( Exception ex ) { log . log ( Level . FINE , ex . toString ( ) , ex ) ; return - 1 ; } } } 