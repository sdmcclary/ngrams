<<<<<<< HEAD
public class TypeDefinition implements IKeyValueConsumer , IApplicable { public static final Integer DEFAULT_DELAY_WEIGHT = 1000 ; public final static Logger logger = LoggerFactory . getLogger ( TypeDefinition . class ) ; public static Integer getDelayedWeight ( ITypeHandler handler , Collection < TypeDefinition > typeDefinitions ) { Integer delayedWeight = 0 ; root : for ( TypeDefinition def : typeDefinitions ) { Map < Class < ? > , Integer > delayedClasses = def . getDelayedTypes ( ) ; for ( Class < ? > delayedClass : delayedClasses . keySet ( ) ) { if ( delayedClass . isAssignableFrom ( handler . getApplicableClass ( ) ) ) { delayedWeight = delayedClasses . get ( delayedClass ) ; break root ; } } } return delayedWeight ; } public static Integer getDelayedWeight ( ITypeHandler handler , String property , Collection < TypeDefinition > typeDefinitions ) { Integer delayedWeight = 0 ; for ( TypeDefinition def : typeDefinitions ) { Map < String , Integer > delayedProperties = def . getDelayedProperties ( ) ; if ( delayedProperties . containsKey ( property ) ) { delayedWeight = delayedProperties . get ( property ) ; break ; } } return delayedWeight ; } public static boolean isLocalizableProperty ( String propertyName , Collection < TypeDefinition > typeDefinitions ) { boolean isLocalizable = false ; for ( TypeDefinition def : typeDefinitions ) { if ( def . isLocalized ( propertyName ) ) { isLocalizable = true ; break ; } } return isLocalizable ; } public static boolean isParentAllowed ( Object parent , Collection < TypeDefinition > typeDefinitions ) { boolean isAllowed = true ; for ( TypeDefinition def : typeDefinitions ) { if ( def . isParentAllowed ( parent ) ) { isAllowed = true ; break ; } } return isAllowed ; } public static Set < Class < ? > > getAllowedParents ( BuilderConfig config , Class < ? > classType ) { Set < Class < ? > > allowed = new HashSet < Class < ? > > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { for ( Class < ? > parentClass : def . getAllowedParents ( ) ) { allowed . add ( parentClass ) ; } } return allowed ; } public static Set < String > getRequiredKeys ( BuilderConfig config , Class < ? > classType ) { Set < String > keys = new HashSet < String > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { keys . addAll ( def . getRequiredKeys ( ) ) ; } return keys ; } public static Set < Class < ? > > getRequiredTypes ( BuilderConfig config , Class < ? > classType ) { Set < Class < ? > > keys = new HashSet < Class < ? > > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { keys . addAll ( def . getRequiredTypes ( ) ) ; } return keys ; } public static Map < String , Object > getDefaults ( BuilderConfig config , Class < ? > classType ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { map . putAll ( def . getDefaults ( ) ) ; } return map ; } public static Set < String > getIgnored ( BuilderConfig config , Class < ? > classType ) { Set < String > ignored = new HashSet < String > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { ignored . addAll ( def . getAllIgnored ( ) ) ; } return ignored ; } public static DefaultResize getDefaultResize ( BuilderConfig config , Class < ? > classType ) { DefaultResize resize = DefaultResize . NONE ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { resize = def . getDefaultResize ( ) ; break ; } return resize ; } public static Method getTypeAsMethod ( BuilderConfig config , Class < ? > parentClassType , Class < ? > classType ) { Method target = null ; Set < TypeDefinition > defs = config . getTypeDefinitions ( parentClassType ) ; root : for ( TypeDefinition def : defs ) { Set < Class < ? > > keySet = def . getTypesAsMethods ( ) . keySet ( ) ; for ( Class < ? > mappedType : keySet ) { if ( mappedType . isAssignableFrom ( classType ) ) { target = def . getTypesAsMethods ( ) . get ( mappedType ) ; break root ; } } } return target ; } public static List < ITypeHandlerFinishProcessor > getFinishProcessors ( BuilderConfig config , Class < ? > classType ) { List < ITypeHandlerFinishProcessor > list = new LinkedList < ITypeHandlerFinishProcessor > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { if ( def . getFinishProcessor ( ) != null ) { list . add ( def . getFinishProcessor ( ) ) ; } } return list ; } public static List < ITypeHandlerAfterCreationProcessor > getAfterCreationProcessors ( BuilderConfig config , Class < ? > classType ) { List < ITypeHandlerAfterCreationProcessor > list = new LinkedList < ITypeHandlerAfterCreationProcessor > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { if ( def . getAfterCreationProcessor ( ) != null ) { list . add ( def . getAfterCreationProcessor ( ) ) ; } } return list ; } public static ITypeHandler getTypeHandler ( BuilderConfig config , Class < ? > classType ) { if ( classType == null ) { throw new NullPointerException ( "classType cannot be null" ) ; } ITypeHandler handler = BuilderConfig . defaultTypeHandler ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { if ( def . getTypeHandler ( ) != null ) { ITypeHandler defHandler = def . getTypeHandler ( ) ; if ( defHandler . isApplicableToSubclasses ( ) ) { handler = defHandler ; } else { if ( classType . equals ( def . getApplicableClass ( ) ) ) { handler = defHandler ; } } break ; } } return handler ; } public static IPropertyHandler getPropertyHandler ( BuilderConfig config , Class < ? > classType , String property ) { if ( classType == null ) { throw new NullPointerException ( "classType cannot be null" ) ; } if ( property == null ) { throw new NullPointerException ( "property cannot be null" ) ; } IPropertyHandler handler = BuilderConfig . defaultPropertyHandler ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { if ( def . getPropertyHandler ( property ) != null ) { handler = def . getPropertyHandler ( property ) ; break ; } } return handler ; } public static ITypeAsValueHandler < ? extends Object > getTypeAsValueHandler ( BuilderConfig config , Class < ? > classType ) { ITypeAsValueHandler < ? extends Object > handler = null ; if ( classType . isEnum ( ) ) { TypeDefinition def = config . getTypeDefinition ( classType ) ; if ( def == null || def . getTypeAsValueHandler ( ) == null ) { config . forType ( classType ) . valueHandler ( createEnumTypeAsValueHandler ( classType ) ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Created ITypeAsValueHandler instance for {}" , classType . getName ( ) ) ; } } } Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { if ( def . getTypeAsValueHandler ( ) != null ) { handler = def . getTypeAsValueHandler ( ) ; break ; } } return handler ; } public static ITypeAsValueHandler < ? extends Object > createEnumTypeAsValueHandler ( final Class < ? > enumClass ) { ITypeAsValueHandler < ? extends Object > handler = null ; if ( enumClass . isEnum ( ) ) { Object [ ] constants = enumClass . getEnumConstants ( ) ; final Map < String , Object > values = new HashMap < String , Object > ( ) ; final StringBuilder regexBuilder = new StringBuilder ( ) ; for ( Object constant : constants ) { values . put ( constant . toString ( ) , constant ) ; String shortConstant = getShortEnumConstant ( constant ) ; values . put ( shortConstant , constant ) ; if ( regexBuilder . length ( ) > 0 ) { regexBuilder . append ( "|" ) ; } regexBuilder . append ( constant ) . append ( "|" ) . append ( shortConstant ) ; } final String regex = regexBuilder . toString ( ) ; handler = new ITypeAsValueHandler < Object > ( ) { public String getInputValueSample ( ) { return values . toString ( ) ; } public String getRegex ( ) { return regex ; } public Object getValue ( BuildProcess process , Node node , String key , Object inputValue ) throws BuildException { return values . get ( inputValue ) ; } public Class < ? > getApplicableClass ( ) { return enumClass ; } } ; } return handler ; } public static String getShortEnumConstant ( Object constant ) { String sConstant = constant . toString ( ) ; StringBuilder builder = new StringBuilder ( sConstant . length ( ) ) ; if ( sConstant . equals ( sConstant . toUpperCase ( ) ) ) { String [ ] parts = sConstant . split ( "_" ) ; for ( int p = 0 ; p < parts . length ; p ++ ) { String part = parts [ p ] ; if ( p == 0 ) { builder . append ( part . toLowerCase ( ) ) ; } else { if ( part . length ( ) > 0 ) { builder . append ( part . substring ( 0 , 1 ) . toUpperCase ( ) ) ; if ( part . length ( ) > 1 ) { builder . append ( part . substring ( 1 ) . toLowerCase ( ) ) ; } } } } } else { builder . append ( sConstant . substring ( 0 , 1 ) . toLowerCase ( ) ) ; builder . append ( sConstant . substring ( 1 ) ) ; } return builder . toString ( ) ; } public static Object getPropertyValue ( BuilderConfig config , Class < ? > classType , String propertyName , Object value ) throws BuildException { Object returnValue = value ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { Map < String , ? extends Object > mappedValues = def . getMappedPropertyValues ( propertyName ) ; if ( mappedValues != null ) { if ( mappedValues . containsKey ( value ) ) { returnValue = mappedValues . get ( value ) ; break ; } else { throw new BuildException ( "Invalid value \"{0}\"  for {1}.{2}. Allowed values are: {3}" , value , classType . getSimpleName ( ) , propertyName , mappedValues . keySet ( ) ) ; } } } return returnValue ; } public static String getPropertyForAlias ( BuilderConfig config , Class < ? > classType , String alias ) { String actual = null ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { actual = def . getPropertyForAlias ( alias ) ; if ( actual != null ) { break ; } } return actual ; } public static Object getCustomProperty ( BuilderConfig config , Class < ? > classType , String propertyName ) { Object value = null ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { if ( def . getCustomProperties ( ) . containsKey ( propertyName ) ) { value = def . getCustomProperties ( ) . get ( propertyName ) ; break ; } } return value ; } public static Object isList ( BuilderConfig config , Class < ? > classType , String propertyName ) { boolean list = false ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { if ( def . isList ( propertyName ) ) { list = true ; break ; } } return list ; } public static Class < ? > getPropertyConstantsClass ( BuilderConfig config , Class < ? > classType , String propertyName ) { Class < ? > constants = null ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { constants = def . getPropertyConstants ( propertyName ) ; if ( constants != null ) { break ; } } return constants ; } public static Map < Class < ? > , int [ ] > getChildrenCardinality ( BuilderConfig config , Class < ? > classType ) { Map < Class < ? > , int [ ] > children = new HashMap < Class < ? > , int [ ] > ( ) ; Set < TypeDefinition > defs = config . getTypeDefinitions ( classType ) ; for ( TypeDefinition def : defs ) { Map < Class < ? > , int [ ] > current = def . getChildrenCardinality ( ) ; boolean override = def . isChildrenCardinalityOverriden ( ) ; if ( override ) { if ( current . size ( ) > 0 ) { children = current ; break ; } } else { for ( Class < ? > type : current . keySet ( ) ) { if ( ! children . containsKey ( type ) ) { children . put ( type , current . get ( type ) ) ; } } } } return children ; } private Class < ? > applicableClass = null ; private Set < String > requiredKeys = new HashSet < String > ( ) ; private Set < Class < ? > > requiredTypes = new HashSet < Class < ? > > ( ) ; private Map < Class < ? > , Integer > delayedTypes = new HashMap < Class < ? > , Integer > ( ) ; private Map < String , Integer > delayedProperties = new HashMap < String , Integer > ( ) ; private Set < String > localizedProperties = new HashSet < String > ( ) ; private Set < Class < ? > > allowedParents = new HashSet < Class < ? > > ( ) ; private Map < String , Object > defaults = new HashMap < String , Object > ( ) ; private Set < String > ignoredProperties = new HashSet < String > ( ) ; private DefaultResize defaultResize = DefaultResize . NONE ; private Map < Class < ? > , Method > typesAsMethods = new HashMap < Class < ? > , Method > ( ) ; private ITypeHandlerFinishProcessor finishProcessor ; private ITypeHandlerAfterCreationProcessor afterCreationProcessor ; private ITypeAsValueHandler < ? extends Object > typeAsValueHandler ; private ITypeHandler typeHandler ; private Map < String , String > propertyAliases = new HashMap < String , String > ( ) ; private Map < String , Map < String , ? extends Object > > mappedProperties = new HashMap < String , Map < String , ? extends Object > > ( ) ; private Map < String , Object > customProperties = new HashMap < String , Object > ( ) ; private List < String > propertiesAsList = new ArrayList < String > ( ) ; private Map < String , Class < ? > > propertyConstants = new HashMap < String , Class < ? > > ( ) ; private Map < String , IPropertyHandler > propertyHandlers = new HashMap < String , IPropertyHandler > ( ) ; private Map < Class < ? > , int [ ] > childrenCardinality = new HashMap < Class < ? > , int [ ] > ( ) ; private boolean childrenCardinalityOverride = false ; public TypeDefinition ( Class < ? > applicableClass ) { if ( applicableClass == null ) { throw new NullPointerException ( "applicableClass cannot be null" ) ; } this . applicableClass = applicableClass ; } public Class < ? > getApplicableClass ( ) { return applicableClass ; } public Set < Class < ? > > getRequiredTypes ( List < TypeDefinition > defs ) { Set < Class < ? > > types = new HashSet < Class < ? > > ( ) ; for ( TypeDefinition def : defs ) { types . addAll ( def . requiredTypes ) ; } return types ; } public Set < String > getRequiredKeys ( ) { return requiredKeys ; } public Set < Class < ? > > getRequiredTypes ( ) { return requiredTypes ; } public TypeDefinition requires ( String ... keys ) { for ( String key : keys ) { getRequiredKeys ( ) . add ( key ) ; } return this ; } public TypeDefinition requires ( Class < ? > ... types ) { for ( Class < ? > type : types ) { getRequiredTypes ( ) . add ( type ) ; } return this ; } public TypeDefinition delay ( int delayWeight , Class < ? > ... types ) { for ( Class < ? > type : types ) { getDelayedTypes ( ) . put ( type , delayWeight ) ; } return this ; } public TypeDefinition delay ( Class < ? > ... types ) { return delay ( DEFAULT_DELAY_WEIGHT , types ) ; } public TypeDefinition delay ( int delayWeight , String ... properties ) { for ( String property : properties ) { getDelayedProperties ( ) . put ( property , delayWeight ) ; } return this ; } public TypeDefinition delay ( String ... properties ) { return delay ( DEFAULT_DELAY_WEIGHT , properties ) ; } public Map < Class < ? > , Integer > getDelayedTypes ( ) { return delayedTypes ; } public Map < String , Integer > getDelayedProperties ( ) { return delayedProperties ; } public Set < String > getConsumedKeys ( ) { return requiredKeys ; } public TypeDefinition localize ( String ... propertyNames ) { for ( String propertyName : propertyNames ) { localize ( propertyName ) ; } return this ; } public TypeDefinition localize ( String propertyName ) { localizedProperties . add ( propertyName ) ; return this ; } public boolean isLocalized ( String propertyName ) { return localizedProperties . contains ( propertyName ) ; } public TypeDefinition ignore ( String ... propertyNames ) { for ( String propertyName : propertyNames ) { ignore ( propertyName ) ; } return this ; } public TypeDefinition ignore ( String propertyName ) { ignoredProperties . add ( propertyName ) ; return this ; } public boolean isIgnored ( String propertyName ) { return ignoredProperties . contains ( propertyName ) ; } public Set < String > getAllIgnored ( ) { return ignoredProperties ; } public TypeDefinition allowParent ( Class < ? > ... parentTypes ) { for ( Class < ? > parentType : parentTypes ) { if ( parentType == null ) { throw new NullPointerException ( "parentType cannot be null" ) ; } allowedParents . add ( parentType ) ; } return this ; } public Set < Class < ? > > getAllowedParents ( ) { return allowedParents ; } public boolean isParentAllowed ( Object parent ) { if ( parent == null ) { throw new NullPointerException ( "parent cannot be null" ) ; } boolean allowed = false ; for ( Class < ? > classType : allowedParents ) { if ( classType . isAssignableFrom ( parent . getClass ( ) ) ) { allowed = true ; break ; } } return allowed ; } public TypeDefinition defaultValue ( String property , Object value ) { if ( property == null ) { throw new NullPointerException ( "property cannot be null" ) ; } if ( value == null ) { defaults . remove ( property ) ; } else { defaults . put ( property , value ) ; } return this ; } public TypeDefinition defaultResize ( DefaultResize resize ) { this . defaultResize = resize ; return this ; } public DefaultResize getDefaultResize ( ) { return this . defaultResize ; } public Map < String , Object > getDefaults ( ) { return defaults ; } public TypeDefinition typeAsMethod ( Class < ? > type , String methodName ) { Set < Method > methods = new HashSet < Method > ( Arrays . asList ( getApplicableClass ( ) . getMethods ( ) ) ) ; methods . addAll ( Arrays . asList ( getApplicableClass ( ) . getDeclaredMethods ( ) ) ) ; Method target = null ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) && method . getParameterTypes ( ) . length == 1 && method . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( type ) ) { target = method ; break ; } } return typeAsMethod ( type , target ) ; } public TypeDefinition typeAsMethod ( Class < ? > type , Method method ) { BuilderUtils . validateNotNullAndNotEmpty ( "method" , method ) ; method . setAccessible ( true ) ; typesAsMethods . put ( type , method ) ; return this ; } public Map < Class < ? > , Method > getTypesAsMethods ( ) { return typesAsMethods ; } public Map < String , ? extends Object > getMappedPropertyValues ( String propertyName ) { return mappedProperties . get ( propertyName ) ; } public TypeDefinition asMapped ( String propertyName , Map < String , ? extends Object > values ) { mappedProperties . put ( propertyName , values ) ; return this ; } @ Override public String toString ( ) { return applicableClass . getName ( ) ; } @ Override public int hashCode ( ) { return applicableClass . hashCode ( ) ; } public ITypeHandlerFinishProcessor getFinishProcessor ( ) { return finishProcessor ; } public TypeDefinition finishProcessor ( ITypeHandlerFinishProcessor finishProcessor ) { this . finishProcessor = finishProcessor ; return this ; } public ITypeHandlerAfterCreationProcessor getAfterCreationProcessor ( ) { return afterCreationProcessor ; } public TypeDefinition afterCreationProcessor ( ITypeHandlerAfterCreationProcessor processor ) { this . afterCreationProcessor = processor ; return this ; } public TypeDefinition typeHandler ( ITypeHandler typeHandler ) { if ( typeHandler == null ) { throw new NullPointerException ( "typeHandler cannot be null" ) ; } if ( typeHandler . getApplicableClass ( ) == null ) { throw new NullPointerException ( "ITypeHandler.getApplicableClass() cannot be null" ) ; } if ( this . applicableClass . isAssignableFrom ( typeHandler . getApplicableClass ( ) ) ) { this . typeHandler = typeHandler ; return this ; } else { throw new BuildException ( "Type handler {0} is not valid to handle type {1}" , typeHandler , applicableClass ) ; } } public ITypeHandler getTypeHandler ( ) { return this . typeHandler ; } public ITypeAsValueHandler < ? extends Object > getTypeAsValueHandler ( ) { return typeAsValueHandler ; } public TypeDefinition valueHandler ( ITypeAsValueHandler < ? extends Object > typeAsValueHandler ) { this . typeAsValueHandler = typeAsValueHandler ; return this ; } public TypeDefinition propertyAlias ( String propertyName , String alias ) { propertyAliases . put ( alias , propertyName ) ; return this ; } public String getPropertyForAlias ( String alias ) { return propertyAliases . get ( alias ) ; } public TypeDefinition customProperty ( String propertyName , Object value ) { getCustomProperties ( ) . put ( propertyName , value ) ; return this ; } public Map < String , Object > getCustomProperties ( ) { return customProperties ; } public TypeDefinition asList ( String ... propertyNames ) { for ( String propertyName : propertyNames ) { propertiesAsList . add ( propertyName ) ; } return this ; } public boolean isList ( String propertyName ) { return propertiesAsList . contains ( propertyName ) ; } public TypeDefinition propertyConstants ( String propertyName , Class < ? > constantsClass ) { propertyConstants . put ( propertyName , constantsClass ) ; return this ; } public Class < ? > getPropertyConstants ( String propertyName ) { return propertyConstants . get ( propertyName ) ; } public TypeDefinition propertyHandler ( IPropertyHandler ... handlers ) { for ( IPropertyHandler handler : handlers ) { if ( handler == null ) { throw new NullPointerException ( "handler cannot be null" ) ; } for ( String key : handler . getConsumedKeys ( ) ) { this . propertyHandlers . put ( key , handler ) ; } } return this ; } public IPropertyHandler getPropertyHandler ( String property ) { return propertyHandlers . get ( property ) ; } public TypeDefinition childrenOverride ( boolean override ) { this . childrenCardinalityOverride = override ; return this ; } public TypeDefinition children ( Class < ? > type , int min , int max ) { int [ ] cardinality = new int [ ] { min , max } ; childrenCardinality . put ( type , cardinality ) ; return this ; } public TypeDefinition children ( Class < ? > type , int exact ) { return children ( type , exact , exact ) ; } public TypeDefinition children ( int min , int max ) { return children ( Object . class , min , max ) ; } public TypeDefinition children ( int exact ) { return children ( Object . class , exact , exact ) ; } public Map < Class < ? > , int [ ] > getChildrenCardinality ( ) { return this . childrenCardinality ; } public boolean isChildrenCardinalityOverriden ( ) { return this . childrenCardinalityOverride ; } } 
=======
class BlankDataDerivType extends DataDerivType { private PatternMemo blankMemo ; private PatternMemo nonBlankMemo ; BlankDataDerivType ( ) { } PatternMemo dataDeriv ( ValidatorPatternBuilder builder , Pattern p , String str , ValidationContext vc , List < DataDerivFailure > fail ) { if ( DataDerivFunction . isBlank ( str ) ) { if ( blankMemo == null || ( fail != null && blankMemo . isNotAllowed ( ) ) ) blankMemo = super . dataDeriv ( builder , p , str , vc , fail ) ; return blankMemo ; } else { if ( nonBlankMemo == null || ( fail != null && nonBlankMemo . isNotAllowed ( ) ) ) nonBlankMemo = super . dataDeriv ( builder , p , str , vc , fail ) ; return nonBlankMemo ; } } DataDerivType copy ( ) { return new BlankDataDerivType ( ) ; } DataDerivType combine ( DataDerivType ddt ) { if ( ddt instanceof BlankDataDerivType || ddt instanceof SingleDataDerivType ) return this ; return InconsistentDataDerivType . getInstance ( ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
