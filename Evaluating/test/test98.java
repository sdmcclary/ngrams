<<<<<<< HEAD
public class EventTableModelTypeHandler extends AbstractTypeHandler implements ITypeChildrenHandler { public static final String SOURCE = "source" ; public static final String HEADER_VALUE = TableColumnTypeHandler . HEADER_VALUE ; public static final String SORT = "sort" ; public static final String SORT_SINGLE = "single" ; public static final String SORT_MULTI = "multi" ; public static final String SORT_BY = "sortBy" ; public static final String COLUMNS = "columns" ; private static final String TEXT_FILTERATOR = "TextFilterator" ; private static final Pattern TEXT_FILTERATOR_REGEX = Pattern . compile ( "(?:[a-zA-Z]+\\()([a-zA-Z0-9]+)=\\[(.*)\\]" ) ; public EventTableModelTypeHandler ( ) { super ( SOURCE , SORT , EDITABLE , COLUMNS , SORT_BY ) ; } @ SuppressWarnings ( "unchecked" ) public Node createNewInstance ( BuilderConfig config , BuildProcess process , Node parent , String key , final Map < String , Object > typeDefinition ) throws BuildException { String source = ( String ) typeDefinition . get ( SOURCE ) ; checkNotNull ( source , "EventTableModel.source property must be specified: {0}" , typeDefinition ) ; List < Map < String , Object > > cols = parent . getParent ( ) . getContentData ( TableColumn . class ) ; JTable table = ( JTable ) parent . getParentObject ( JTable . class ) ; Field field = BuilderUtils . getField ( process . getCaller ( ) , source , EventList . class ) ; checkNotNull ( field , "EventTableModel.source property does not point to a valid instance of GlazedLists EventList: {0}" , typeDefinition ) ; try { EventList list = GlazedListsUtils . getSource ( process . getCaller ( ) , typeDefinition ) . get0 ( ) ; Class < ? > type = BuilderUtils . getGenericsTypeFromCollectionField ( field ) ; if ( type == null ) { throw new BuildException ( "Unable to use generics to find type of object stored in source: {0}" , source ) ; } LinkedHashMap < String , String > columnNames = getColumnNamesAndHeaders ( process , typeDefinition , cols , type ) ; TableFormat tableFormat = createTableFormat ( parent , type , typeDefinition , cols , columnNames ) ; EventTableModel instance = setupModel ( process , typeDefinition , table , list , cols , type , tableFormat , source ) ; return useExistingInstance ( config , process , parent , key , typeDefinition , instance ) ; } catch ( BuildException ex ) { throw ex ; } catch ( Exception e ) { throw new BuildException ( e , "Unable to create instance of EventTableModel: {0}.\n{1}" , typeDefinition , e . getMessage ( ) ) ; } } public Node useExistingInstance ( BuilderConfig config , BuildProcess process , Node parent , String key , Map < String , Object > typeDefinition , Object instance ) throws BuildException { Node node = new Node ( parent , key , typeDefinition , instance ) ; return node ; } @ SuppressWarnings ( "unchecked" ) public Class < EventTableModel > getApplicableClass ( ) { return EventTableModel . class ; } @ SuppressWarnings ( { "rawtypes" , "unchecked" } ) private TableFormat < ? > createTableFormat ( Node parent , Class < ? > type , Map < String , Object > typeDefinition , List < Map < String , Object > > cols , final LinkedHashMap < String , String > columnNames ) { final Integer [ ] editable = getEditableColumnIndexes ( typeDefinition , cols ) ; final String [ ] names = columnNames . keySet ( ) . toArray ( new String [ columnNames . size ( ) ] ) ; final String [ ] headers = columnNames . values ( ) . toArray ( new String [ columnNames . size ( ) ] ) ; final boolean [ ] ed = new boolean [ names . length ] ; for ( Integer i : editable ) { ed [ i ] = true ; } return new BeanTableFormat ( type , names , headers , ed ) ; } @ SuppressWarnings ( "unchecked" ) private LinkedHashMap < String , String > getColumnNamesAndHeaders ( BuildProcess process , Map < String , Object > typeDefinition , List < Map < String , Object > > cols , Class < ? > type ) { LinkedHashMap < String , String > columns = new LinkedHashMap < String , String > ( ) ; final Set < String > props = PropertyUtils . getPropertyNames ( type ) ; List < String > modelColumns = ( List < String > ) typeDefinition . get ( COLUMNS ) ; if ( modelColumns != null ) { for ( String modelColumn : modelColumns ) { columns . put ( modelColumn , JBStringUtils . getDisplayLabel ( process , type , modelColumn ) ) ; } } if ( cols . size ( ) > 0 ) { for ( Map < String , Object > map : cols ) { String name = getColumnName ( map ) ; if ( props . contains ( name ) ) { String headerValue = ( String ) map . get ( HEADER_VALUE ) ; if ( headerValue == null ) { headerValue = JBStringUtils . getDisplayLabel ( process , type , name ) ; } map . put ( TableColumnTypeHandler . INTERNAL_MODEL_INDEX , columns . size ( ) ) ; columns . put ( name , headerValue ) ; } else { throw new BuildException ( "Unable to map column ''{0}'' to any property of type {1}" , name , type ) ; } } } if ( columns . size ( ) == 0 ) { List < String > orderedProps = new ArrayList < String > ( props ) ; Collections . sort ( orderedProps ) ; for ( String name : orderedProps ) { columns . put ( name , JBStringUtils . getDisplayLabel ( process , type , name ) ) ; } } return columns ; } private String getColumnName ( Map < String , Object > map ) { String name = null ; if ( map . containsKey ( SOURCE ) ) { name = String . valueOf ( map . get ( SOURCE ) ) ; } else if ( map . containsKey ( Builder . NAME ) ) { name = String . valueOf ( map . get ( Builder . NAME ) ) ; } else { throw new BuildException ( "TableColumn data does not contain 'source' or 'name' property. Unable to map it to the model: {0}" , map ) ; } return name ; } @ SuppressWarnings ( { "unchecked" , "unused" } ) private EventTableModel setupModel ( BuildProcess process , Map < String , Object > typeDefinition , JTable table , EventList source , List < Map < String , Object > > cols , Class < ? > type , TableFormat format , String sourceName ) { EventList actualSource = source ; SortedList sortedList = null ; Object sortedChooser = null ; EventList filterList = null ; String sort = ( String ) typeDefinition . get ( SORT ) ; List < String > sortedColumns = ( List < String > ) typeDefinition . get ( SORT_BY ) ; if ( SORT_SINGLE . equals ( sort ) || SORT_MULTI . equals ( sort ) ) { String sortedListName = sourceName + "Sorted" ; sortedList = ( SortedList ) BuilderUtils . getExistingInstanceIfAvailable ( process . getCaller ( ) , SortedList . class , process . getConfig ( ) , sortedListName ) ; if ( sortedList == null ) { sortedList = new SortedList ( actualSource ) ; process . getBuildResult ( ) . put ( sortedListName , sortedList ) ; } if ( sortedColumns != null && sortedColumns . size ( ) > 0 ) { Comparator c = CompilerUtils . newComparator ( type , sortedColumns ) ; sortedList . setComparator ( c ) ; } actualSource = sortedList ; sortedChooser = ( SORT_SINGLE . equals ( sort ) ) ? TableComparatorChooser . SINGLE_COLUMN : TableComparatorChooser . MULTIPLE_COLUMN_MOUSE ; } else if ( sort != null ) { throw new BuildException ( "Unknown value of EventTableModel.sort: {0}\n{1}" , sort , typeDefinition ) ; } Map < JComponent , List < String > > filterInfo = getModelFilters ( process , typeDefinition ) ; if ( filterInfo . size ( ) > 0 ) { for ( JComponent filterField : filterInfo . keySet ( ) ) { List < String > filterColumns = filterInfo . get ( filterField ) ; if ( filterField instanceof JTextComponent ) { JTextComponent c = ( JTextComponent ) filterField ; TextFilterator filterator = createTextFilterator ( type , filterColumns ) ; MatcherEditor textMatcherEditor = new TextComponentMatcherEditor ( c , filterator ) ; filterList = new FilterList < Object > ( actualSource , textMatcherEditor ) ; actualSource = filterList ; } else { } } } EventTableModel model = new EventTableModel ( actualSource , format ) ; table . setModel ( model ) ; if ( sortedList != null ) { TableComparatorChooser tableSorter = TableComparatorChooser . install ( table , ( SortedList ) sortedList , sortedChooser ) ; } return model ; } @ SuppressWarnings ( "unchecked" ) private TextFilterator < ? > createTextFilterator ( Class < ? > type , List < String > columns ) { StringBuilder bld = new StringBuilder ( ) ; String fullTypeName = type . getName ( ) ; Map < String , String > getters = new HashMap < String , String > ( ) ; Map < String , Class < ? > > types = new HashMap < String , Class < ? > > ( ) ; for ( String column : columns ) { String getter = "get" + column . substring ( 0 , 1 ) . toUpperCase ( ) + column . substring ( 1 ) ; getters . put ( column , getter ) ; try { Class < ? > returnType = type . getMethod ( getter ) . getReturnType ( ) ; types . put ( column , returnType ) ; } catch ( Exception e ) { throw new BuildException ( "Unable to get setter return value: {0}" , e . getMessage ( ) ) ; } } String fullName = CompilerUtils . generateClassName ( TextFilterator . class ) ; bld . append ( "public void getFilterStrings(java.util.List baseList, Object target) {\n" ) ; bld . append ( "    " ) . append ( fullTypeName ) . append ( " row = (" ) . append ( fullTypeName ) . append ( ")target;\n" ) ; for ( String column : columns ) { if ( types . get ( column ) . equals ( String . class ) ) { bld . append ( "    baseList.add(row." ) . append ( getters . get ( column ) ) . append ( "());\n" ) ; } else { bld . append ( "    baseList.add(String.valueOf(row." ) . append ( getters . get ( column ) ) . append ( "());\n" ) ; } } bld . append ( "}" ) ; try { TextFilterator f = ( TextFilterator ) CompilerUtils . compile ( fullName , bld . toString ( ) , Object . class , TextFilterator . class ) . newInstance ( ) ; return f ; } catch ( Exception e ) { throw new BuildException ( "Failed to compile TextFilterator for GlazedLists filtering: {0}\n{1}" , e . getMessage ( ) , bld . toString ( ) ) ; } } private Integer [ ] getEditableColumnIndexes ( Map < String , Object > typeDefinition , List < Map < String , Object > > cols ) { Set < Integer > indexes = new LinkedHashSet < Integer > ( ) ; Boolean modelEditable = ( Boolean ) BuilderUtils . getValue ( typeDefinition , EDITABLE , Boolean . FALSE ) ; for ( int i = 0 ; i < cols . size ( ) ; i ++ ) { Map < String , Object > col = cols . get ( i ) ; Boolean colEditable = ( Boolean ) BuilderUtils . getValue ( col , EDITABLE , modelEditable ) ; if ( colEditable ) { indexes . add ( i ) ; } } return indexes . toArray ( new Integer [ indexes . size ( ) ] ) ; } @ SuppressWarnings ( "unchecked" ) private Map < JComponent , List < String > > getModelFilters ( BuildProcess process , Map < String , Object > typeDefinition ) { Map < JComponent , List < String > > map = new LinkedHashMap < JComponent , List < String > > ( ) ; ArrayList < String > content = ( ArrayList < String > ) typeDefinition . get ( Builder . CONTENT ) ; if ( content != null && content . size ( ) > 0 ) { for ( String filter : content ) { if ( filter . startsWith ( TEXT_FILTERATOR ) ) { Matcher m = TEXT_FILTERATOR_REGEX . matcher ( filter ) ; if ( m . find ( ) ) { String field = m . group ( 1 ) ; String [ ] columns = m . group ( 2 ) . split ( "," ) ; JComponent c = ( JComponent ) process . getBuildResult ( ) . get ( field ) ; if ( c != null ) { List < String > cols = Arrays . asList ( columns ) ; if ( cols . size ( ) > 0 ) { map . put ( c , cols ) ; } else { throw new BuildException ( "TextFilterator field {0} needs to have at least 1 column" , field ) ; } } else { throw new BuildException ( "TextFilterator field {0} cannot be found" , field ) ; } } } } } return map ; } } 
=======
class CompatibilityDatatypeLibrary implements DatatypeLibrary { private final DatatypeLibraryFactory factory ; private DatatypeLibrary xsdDatatypeLibrary = null ; CompatibilityDatatypeLibrary ( DatatypeLibraryFactory factory ) { this . factory = factory ; } public DatatypeBuilder createDatatypeBuilder ( String type ) throws DatatypeException { if ( type . equals ( "ID" ) || type . equals ( "IDREF" ) || type . equals ( "IDREFS" ) ) { if ( xsdDatatypeLibrary == null ) { xsdDatatypeLibrary = factory . createDatatypeLibrary ( WellKnownNamespaces . XML_SCHEMA_DATATYPES ) ; if ( xsdDatatypeLibrary == null ) throw new DatatypeException ( ) ; } return xsdDatatypeLibrary . createDatatypeBuilder ( type ) ; } throw new DatatypeException ( ) ; } public Datatype createDatatype ( String type ) throws DatatypeException { return createDatatypeBuilder ( type ) . createDatatype ( ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
