public abstract class AbstractConnection extends AbstractDbSession implements Connection { private final Logger logger = LoggerFactory . getLogger ( AbstractConnection . class ) ; private final AbstractConnectionManager connectionManager ; private final ConnectionState connectionState ; private Request < Void > closeRequest ; private volatile int pid ; private volatile int key ; private static final ExecuteMessage DEFAULT_EXECUTE = new ExecuteMessage ( ) ; private static final BindMessage DEFAULT_BIND = new BindMessage ( ) ; private static final DescribeMessage DEFAULT_DESCRIBE = DescribeMessage . createDescribePortalMessage ( null ) ; public AbstractConnection ( AbstractConnectionManager connectionManager ) { super ( connectionManager . isPipeliningEnabled ( ) ) ; this . connectionManager = connectionManager ; this . connectionState = new ConnectionState ( connectionManager . getDatabase ( ) ) ; } public AbstractConnectionManager getConnectionManager ( ) { return connectionManager ; } public DbFuture < Void > ping ( ) { throw new Error ( "ping() is not yet implemented" ) ; } @ Override protected void checkClosed ( ) { if ( isClosed ( ) ) { throw new DbSessionClosedException ( this , "This connection has been closed" ) ; } } public DbSessionFuture < Void > close ( boolean immediate ) throws DbException { synchronized ( lock ) { if ( isClosed ( ) ) { if ( closeRequest == null ) { closeRequest = new Request < Void > ( ) { @ Override public void execute ( ) throws Exception { } @ Override public String toString ( ) { return "Connection closed" ; } } ; closeRequest . setResult ( null ) ; } } else { if ( immediate ) { logger . debug ( "Executing immediate finalizeClose" ) ; cancelPendingRequests ( true ) ; write ( SimpleFrontendMessage . TERMINATE ) ; closeRequest = new Request < Void > ( ) { @ Override protected boolean cancelRequest ( boolean mayInterruptIfRunning ) { return false ; } @ Override public void execute ( ) throws Exception { } @ Override public String toString ( ) { return "Immediate finalizeClose" ; } } ; } else { closeRequest = new Request < Void > ( ) { @ Override public boolean cancelRequest ( boolean mayInterruptIfRunning ) { logger . debug ( "Cancelling finalizeClose" ) ; unclose ( ) ; return true ; } @ Override public void execute ( ) { logger . debug ( "Sending TERMINATE to server (Request queue size: {})" , requestQueue . size ( ) ) ; write ( SimpleFrontendMessage . TERMINATE ) ; } @ Override public boolean isPipelinable ( ) { return false ; } @ Override public String toString ( ) { return "Deferred finalizeClose" ; } } ; enqueueRequest ( closeRequest ) ; } } return closeRequest ; } } private void unclose ( ) { synchronized ( lock ) { logger . debug ( "Unclosing" ) ; this . closeRequest = null ; } } public boolean isClosed ( ) throws DbException { synchronized ( lock ) { return closeRequest != null || isConnectionClosing ( ) ; } } public void finalizeClose ( ) throws DbException { errorPendingRequests ( new DbException ( "Connection closed" ) ) ; synchronized ( lock ) { if ( closeRequest != null ) { closeRequest . setResult ( null ) ; } } } public < T > DbSessionFuture < T > executeQuery ( final String sql , ResultEventHandler < T > eventHandler , T accumulator ) { checkClosed ( ) ; Request < T > request = new Request < T > ( eventHandler , accumulator ) { @ Override public void execute ( ) throws Exception { logger . debug ( "Issuing query: {}" , sql ) ; ParseMessage parse = new ParseMessage ( sql ) ; write ( new AbstractFrontendMessage [ ] { parse , DEFAULT_BIND , DEFAULT_DESCRIBE , DEFAULT_EXECUTE , SimpleFrontendMessage . SYNC , } ) ; } @ Override public String toString ( ) { return "SELECT request: " + sql ; } } ; return enqueueTransactionalRequest ( request ) ; } public DbSessionFuture < Result > executeUpdate ( final String sql ) { checkClosed ( ) ; return enqueueTransactionalRequest ( new Request < Result > ( ) { @ Override public void execute ( ) throws Exception { logger . debug ( "Issuing update query: {}" , sql ) ; ParseMessage parse = new ParseMessage ( sql ) ; write ( new AbstractFrontendMessage [ ] { parse , DEFAULT_BIND , DEFAULT_DESCRIBE , DEFAULT_EXECUTE , SimpleFrontendMessage . SYNC } ) ; } @ Override public String toString ( ) { return "Update request: " + sql ; } } ) ; } public DbSessionFuture < PreparedStatement > prepareStatement ( String sql ) { throw new IllegalStateException ( ) ; } public DbSessionFuture < PreparedStatement > prepareStatement ( Object key , String sql ) { throw new IllegalStateException ( ) ; } private final AtomicLong statementCounter = new AtomicLong ( ) ; private final Map < String , String > statementCache = Collections . synchronizedMap ( new HashMap < String , String > ( ) ) ; @ Override protected void sendBegin ( ) { executeStatement ( "BEGIN" ) ; } @ Override protected void sendCommit ( ) { executeStatement ( "COMMIT" ) ; } @ Override protected void sendRollback ( ) { executeStatement ( "ROLLBACK" ) ; } private void executeStatement ( String statement ) { String statementId = statementCache . get ( statement ) ; if ( statementId == null ) { long id = statementCounter . incrementAndGet ( ) ; statementId = "S_" + id ; ParseMessage parseMessage = new ParseMessage ( statement , statementId ) ; write ( parseMessage ) ; statementCache . put ( statement , statementId ) ; } write ( new AbstractFrontendMessage [ ] { new BindMessage ( statementId ) , DEFAULT_EXECUTE , SimpleFrontendMessage . SYNC } ) ; } @ Override protected < E > void enqueueRequest ( Request < E > request ) { super . enqueueRequest ( request ) ; } @ Override public < E > Request < E > getActiveRequest ( ) { return super . getActiveRequest ( ) ; } public int getPid ( ) { return pid ; } public void setPid ( int pid ) { this . pid = pid ; } public int getKey ( ) { return key ; } public void setKey ( int key ) { this . key = key ; } public ConnectionState getConnectionState ( ) { return connectionState ; } protected abstract void write ( AbstractFrontendMessage message ) ; protected abstract void write ( AbstractFrontendMessage [ ] messages ) ; protected abstract boolean isConnectionClosing ( ) ; public abstract DefaultDbFuture < Connection > getConnectFuture ( ) ; } 