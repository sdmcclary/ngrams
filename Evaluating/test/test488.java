<<<<<<< HEAD
final class CryptoPermissions extends PermissionCollection implements Serializable { private static final long serialVersionUID = 4946547168093391015L ; private Hashtable perms ; CryptoPermissions ( ) { perms = new Hashtable ( 7 ) ; } void load ( InputStream in ) throws IOException , CryptoPolicyParser . ParsingException { CryptoPolicyParser parser = new CryptoPolicyParser ( ) ; parser . read ( new BufferedReader ( new InputStreamReader ( in , "UTF-8" ) ) ) ; CryptoPermission [ ] parsingResult = parser . getPermissions ( ) ; for ( int i = 0 ; i < parsingResult . length ; i ++ ) { this . add ( parsingResult [ i ] ) ; } } boolean isEmpty ( ) { return perms . isEmpty ( ) ; } public void add ( Permission permission ) { if ( isReadOnly ( ) ) throw new SecurityException ( "Attempt to add a Permission " + "to a readonly CryptoPermissions " + "object" ) ; if ( ! ( permission instanceof CryptoPermission ) ) return ; CryptoPermission cryptoPerm = ( CryptoPermission ) permission ; PermissionCollection pc = getPermissionCollection ( cryptoPerm ) ; pc . add ( cryptoPerm ) ; String alg = cryptoPerm . getAlgorithm ( ) ; if ( ! perms . containsKey ( alg ) ) { perms . put ( alg , pc ) ; } } public boolean implies ( Permission permission ) { if ( ! ( permission instanceof CryptoPermission ) ) { return false ; } CryptoPermission cryptoPerm = ( CryptoPermission ) permission ; PermissionCollection pc = getPermissionCollection ( cryptoPerm . getAlgorithm ( ) ) ; return pc . implies ( cryptoPerm ) ; } public Enumeration elements ( ) { return new PermissionsEnumerator ( perms . elements ( ) ) ; } CryptoPermissions getMinimum ( CryptoPermissions other ) { if ( other == null ) { return null ; } if ( this . perms . containsKey ( CryptoAllPermission . ALG_NAME ) ) { return other ; } if ( other . perms . containsKey ( CryptoAllPermission . ALG_NAME ) ) { return this ; } CryptoPermissions ret = new CryptoPermissions ( ) ; PermissionCollection thatWildcard = ( PermissionCollection ) other . perms . get ( CryptoPermission . ALG_NAME_WILDCARD ) ; int maxKeySize = 0 ; if ( thatWildcard != null ) { maxKeySize = ( ( CryptoPermission ) thatWildcard . elements ( ) . nextElement ( ) ) . getMaxKeySize ( ) ; } Enumeration thisKeys = this . perms . keys ( ) ; while ( thisKeys . hasMoreElements ( ) ) { String alg = ( String ) thisKeys . nextElement ( ) ; PermissionCollection thisPc = ( PermissionCollection ) this . perms . get ( alg ) ; PermissionCollection thatPc = ( PermissionCollection ) other . perms . get ( alg ) ; CryptoPermission [ ] partialResult ; if ( thatPc == null ) { if ( thatWildcard == null ) { continue ; } partialResult = getMinimum ( maxKeySize , thisPc ) ; } else { partialResult = getMinimum ( thisPc , thatPc ) ; } for ( int i = 0 ; i < partialResult . length ; i ++ ) { ret . add ( partialResult [ i ] ) ; } } PermissionCollection thisWildcard = ( PermissionCollection ) this . perms . get ( CryptoPermission . ALG_NAME_WILDCARD ) ; if ( thisWildcard == null ) { return ret ; } maxKeySize = ( ( CryptoPermission ) thisWildcard . elements ( ) . nextElement ( ) ) . getMaxKeySize ( ) ; Enumeration thatKeys = other . perms . keys ( ) ; while ( thatKeys . hasMoreElements ( ) ) { String alg = ( String ) thatKeys . nextElement ( ) ; if ( this . perms . containsKey ( alg ) ) { continue ; } PermissionCollection thatPc = ( PermissionCollection ) other . perms . get ( alg ) ; CryptoPermission [ ] partialResult ; partialResult = getMinimum ( maxKeySize , thatPc ) ; for ( int i = 0 ; i < partialResult . length ; i ++ ) { ret . add ( partialResult [ i ] ) ; } } return ret ; } private CryptoPermission [ ] getMinimum ( PermissionCollection thisPc , PermissionCollection thatPc ) { Vector permVector = new Vector ( 2 ) ; Enumeration thisPcPermissions = thisPc . elements ( ) ; while ( thisPcPermissions . hasMoreElements ( ) ) { CryptoPermission thisCp = ( CryptoPermission ) thisPcPermissions . nextElement ( ) ; Enumeration thatPcPermissions = thatPc . elements ( ) ; while ( thatPcPermissions . hasMoreElements ( ) ) { CryptoPermission thatCp = ( CryptoPermission ) thatPcPermissions . nextElement ( ) ; if ( thatCp . implies ( thisCp ) ) { permVector . addElement ( thisCp ) ; break ; } if ( thisCp . implies ( thatCp ) ) { permVector . addElement ( thatCp ) ; } } } CryptoPermission [ ] ret = new CryptoPermission [ permVector . size ( ) ] ; permVector . copyInto ( ret ) ; return ret ; } private CryptoPermission [ ] getMinimum ( int maxKeySize , PermissionCollection pc ) { Vector permVector = new Vector ( 1 ) ; Enumeration enum_ = pc . elements ( ) ; while ( enum_ . hasMoreElements ( ) ) { CryptoPermission cp = ( CryptoPermission ) enum_ . nextElement ( ) ; if ( cp . getMaxKeySize ( ) <= maxKeySize ) { permVector . addElement ( cp ) ; } else { if ( cp . getCheckParam ( ) ) { permVector . addElement ( new CryptoPermission ( cp . getAlgorithm ( ) , maxKeySize , cp . getAlgorithmParameterSpec ( ) , cp . getExemptionMechanism ( ) ) ) ; } else { permVector . addElement ( new CryptoPermission ( cp . getAlgorithm ( ) , maxKeySize , cp . getExemptionMechanism ( ) ) ) ; } } } CryptoPermission [ ] ret = new CryptoPermission [ permVector . size ( ) ] ; permVector . copyInto ( ret ) ; return ret ; } PermissionCollection getPermissionCollection ( String alg ) { if ( perms . containsKey ( CryptoAllPermission . ALG_NAME ) ) { return ( PermissionCollection ) ( perms . get ( CryptoAllPermission . ALG_NAME ) ) ; } PermissionCollection pc = ( PermissionCollection ) perms . get ( alg ) ; if ( pc == null ) { pc = ( PermissionCollection ) perms . get ( CryptoPermission . ALG_NAME_WILDCARD ) ; } return pc ; } private PermissionCollection getPermissionCollection ( CryptoPermission cryptoPerm ) { String alg = cryptoPerm . getAlgorithm ( ) ; PermissionCollection pc = ( PermissionCollection ) perms . get ( alg ) ; if ( pc == null ) { pc = cryptoPerm . newPermissionCollection ( ) ; } return pc ; } } final class PermissionsEnumerator implements Enumeration { private Enumeration perms ; private Enumeration permset ; PermissionsEnumerator ( Enumeration e ) { perms = e ; permset = getNextEnumWithMore ( ) ; } public synchronized boolean hasMoreElements ( ) { if ( permset == null ) return false ; if ( permset . hasMoreElements ( ) ) return true ; permset = getNextEnumWithMore ( ) ; return ( permset != null ) ; } public synchronized Object nextElement ( ) { if ( hasMoreElements ( ) ) { return permset . nextElement ( ) ; } else { throw new NoSuchElementException ( "PermissionsEnumerator" ) ; } } private Enumeration getNextEnumWithMore ( ) { while ( perms . hasMoreElements ( ) ) { PermissionCollection pc = ( PermissionCollection ) perms . nextElement ( ) ; Enumeration next = pc . elements ( ) ; if ( next . hasMoreElements ( ) ) return next ; } return null ; } } 
=======
public final class Refresh extends IriRef { public static final Refresh THE_INSTANCE = new Refresh ( ) ; private Refresh ( ) { super ( ) ; } private enum State { AT_START , DIGIT_SEEN , SEMICOLON_SEEN , SPACE_SEEN , U_SEEN , R_SEEN , L_SEEN , EQUALS_SEEN } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { if ( literal . length ( ) == 0 ) { throw newDatatypeException ( "Empty literal." ) ; } State state = State . AT_START ; for ( int i = 0 ; i < literal . length ( ) ; i ++ ) { char c = literal . charAt ( i ) ; switch ( state ) { case AT_START : if ( isAsciiDigit ( c ) ) { state = State . DIGIT_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit, but saw " , c , " instead." ) ; } case DIGIT_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit or a semicolon, but saw " , c , " instead." ) ; } case SEMICOLON_SEEN : if ( isWhitespace ( c ) ) { state = State . SPACE_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a space character, but saw " , c , " instead." ) ; } case SPACE_SEEN : if ( isWhitespace ( c ) ) { continue ; } else if ( c == 'u' || c == 'U' ) { state = State . U_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a space character or the letter “u”, but saw " , c , " instead." ) ; } case U_SEEN : if ( c == 'r' || c == 'R' ) { state = State . R_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected the letter “r”, but saw " , c , " instead." ) ; } case R_SEEN : if ( c == 'l' || c == 'L' ) { state = State . L_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected the letter “l”, but saw " , c , " instead." ) ; } case L_SEEN : if ( c == '=' ) { state = State . EQUALS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected “=”, but saw " , c , " instead." ) ; } case EQUALS_SEEN : if ( c == '"' || c == '\'' ) { throw newDatatypeException ( "Expected an unquoted IRI reference, but saw " , c , " instead." ) ; } if ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) { throw newDatatypeException ( "Expected an IRI reference, but saw whitespace instead." ) ; } char l = literal . charAt ( literal . length ( ) - 1 ) ; if ( ' ' == l || '\t' == l || '\n' == l || '\f' == l || '\r' == l ) { throw newDatatypeException ( "Trailing whitespace." ) ; } super . checkValid ( literal . subSequence ( i , literal . length ( ) ) ) ; return ; } } switch ( state ) { case AT_START : throw newDatatypeException ( "Expected a digit, but the literal ended." ) ; case DIGIT_SEEN : return ; case SEMICOLON_SEEN : throw newDatatypeException ( "Expected a space character, but the literal ended." ) ; case SPACE_SEEN : throw newDatatypeException ( "Expected a space character or the letter “u”, but the literal ended." ) ; case U_SEEN : throw newDatatypeException ( "Expected the letter “r”, but the literal ended." ) ; case R_SEEN : throw newDatatypeException ( "Expected the letter “l”, but the literal ended." ) ; case L_SEEN : throw newDatatypeException ( "Expected “=”, but the literal ended." ) ; case EQUALS_SEEN : throw newDatatypeException ( "Expected an IRI reference, but the literal ended." ) ; } } @ Override public String getName ( ) { return "refresh" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
