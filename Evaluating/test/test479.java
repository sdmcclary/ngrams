public class WalrusQueryBinding implements QueryBinding { private static Logger LOG = Logger . getLogger ( WalrusQueryBinding . class ) ; public static final String namespace = BindingUtil . sanitizeNamespace ( "http://msgs.eucalyptus.ucsb.edu" ) ; public String getName ( ) { return "2006-03-01" ; } public QueryBinding getInstance ( ) { return new WalrusQueryBinding ( ) ; } public OMElement bind ( UserInfo userId , HttpRequest httpRequest , MessageContext messageContext ) throws QueryBindingException { return bind ( httpRequest . getOperation ( ) , userId , httpRequest . getParameters ( ) , httpRequest . getBindingArguments ( ) , httpRequest . getHeaders ( ) ) ; } public OMElement bind ( final String operationName , final UserInfo user , final Map < String , String > params , Map bindingArguments , final Map < String , String > headers ) throws QueryBindingException { OMElement msg ; EucalyptusMessage eucaMsg ; Map < String , String > fieldMap ; Class targetType ; try { targetType = Class . forName ( "edu.ucsb.eucalyptus.msgs." . concat ( operationName ) . concat ( "Type" ) ) ; fieldMap = this . buildFieldMap ( targetType ) ; eucaMsg = ( EucalyptusMessage ) targetType . newInstance ( ) ; } catch ( Exception e ) { throw new QueryBindingException ( "Failed to construct message of type " + operationName ) ; } CaseInsensitiveMap caseInsensitiveHeaders = new CaseInsensitiveMap ( headers ) ; List < String > failedMappings = populateObject ( eucaMsg , fieldMap , params , bindingArguments ) ; populateObjectFromBindingMap ( eucaMsg , fieldMap , caseInsensitiveHeaders , bindingArguments ) ; setRequiredParams ( eucaMsg , user ) ; if ( ! failedMappings . isEmpty ( ) || ! params . isEmpty ( ) ) { StringBuilder errMsg = new StringBuilder ( "Failed to bind the following fields:\n" ) ; for ( String f : failedMappings ) errMsg . append ( f ) . append ( '\n' ) ; for ( Map . Entry < String , String > f : params . entrySet ( ) ) errMsg . append ( f . getKey ( ) ) . append ( " = " ) . append ( f . getValue ( ) ) . append ( '\n' ) ; throw new QueryBindingException ( errMsg . toString ( ) ) ; } if ( user != null ) { eucaMsg . setUserId ( user . getUserName ( ) ) ; eucaMsg . setEffectiveUserId ( user . isAdministrator ( ) ? "eucalyptus" : user . getUserName ( ) ) ; } LOG . info ( eucaMsg . toString ( ) ) ; try { Binding binding = BindingManager . getBinding ( namespace ) ; msg = binding . toOM ( eucaMsg ) ; } catch ( JiBXException e ) { throw new QueryBindingException ( "Failed to build a valid message: " + e . getMessage ( ) ) ; } return msg ; } private void setRequiredParams ( final GroovyObject msg , UserInfo user ) { if ( user != null ) { msg . setProperty ( "accessKeyID" , user . getQueryId ( ) ) ; } msg . setProperty ( "timeStamp" , new Date ( ) ) ; } private List < String > populateObject ( final GroovyObject obj , final Map < String , String > paramFieldMap , final Map < String , String > params , Map bindingMap ) { List < String > failedMappings = new ArrayList < String > ( ) ; for ( Map . Entry < String , String > e : paramFieldMap . entrySet ( ) ) { try { if ( obj . getClass ( ) . getDeclaredField ( e . getValue ( ) ) . getType ( ) . equals ( ArrayList . class ) ) failedMappings . addAll ( populateObjectList ( obj , e , params , params . size ( ) ) ) ; else if ( params . containsKey ( e . getKey ( ) ) && ! populateObjectField ( obj , e , params ) ) failedMappings . add ( e . getKey ( ) ) ; } catch ( NoSuchFieldException ex ) { failedMappings . add ( e . getKey ( ) ) ; } } return failedMappings ; } private void populateObjectFromBindingMap ( final GroovyObject obj , final Map < String , String > paramFieldMap , final CaseInsensitiveMap headers , final Map bindingMap ) { String aclString = headers . remove ( WalrusProperties . AMZ_ACL ) ; if ( aclString != null ) { addAccessControlList ( obj , paramFieldMap , bindingMap , aclString ) ; } String metaDataString = paramFieldMap . remove ( "MetaData" ) ; if ( metaDataString != null ) { Iterator < String > iterator = headers . keySet ( ) . iterator ( ) ; ArrayList < MetaDataEntry > metaData = new ArrayList < MetaDataEntry > ( ) ; while ( iterator . hasNext ( ) ) { String key = iterator . next ( ) ; if ( key . startsWith ( WalrusProperties . AMZ_META_HEADER_PREFIX ) ) { MetaDataEntry metaDataEntry = new MetaDataEntry ( ) ; metaDataEntry . setName ( key . substring ( WalrusProperties . AMZ_META_HEADER_PREFIX . length ( ) ) ) ; metaDataEntry . setValue ( headers . remove ( key ) ) ; metaData . add ( metaDataEntry ) ; } } obj . setProperty ( metaDataString , metaData ) ; } Iterator bindingMapIterator = bindingMap . keySet ( ) . iterator ( ) ; while ( bindingMapIterator . hasNext ( ) ) { String key = ( String ) bindingMapIterator . next ( ) ; obj . setProperty ( key . substring ( 0 , 1 ) . toLowerCase ( ) . concat ( key . substring ( 1 ) ) , bindingMap . get ( key ) ) ; } } private boolean populateObjectField ( final GroovyObject obj , final Map . Entry < String , String > paramFieldPair , final Map < String , String > params ) { try { Class declaredType = obj . getClass ( ) . getDeclaredField ( paramFieldPair . getValue ( ) ) . getType ( ) ; if ( declaredType . equals ( String . class ) ) obj . setProperty ( paramFieldPair . getValue ( ) , params . remove ( paramFieldPair . getKey ( ) ) ) ; else if ( declaredType . getName ( ) . equals ( "int" ) ) obj . setProperty ( paramFieldPair . getValue ( ) , Integer . parseInt ( params . remove ( paramFieldPair . getKey ( ) ) ) ) ; else return false ; return true ; } catch ( Exception e1 ) { return false ; } } private static void addAccessControlList ( final GroovyObject obj , final Map < String , String > paramFieldMap , Map bindingMap , String cannedACLString ) { AccessControlListType accessControlList ; ArrayList < Grant > grants ; if ( bindingMap . containsKey ( "AccessControlPolicy" ) ) { AccessControlPolicyType accessControlPolicy = ( AccessControlPolicyType ) bindingMap . get ( "AccessControlPolicy" ) ; accessControlList = accessControlPolicy . getAccessControlList ( ) ; grants = accessControlList . getGrants ( ) ; } else { accessControlList = new AccessControlListType ( ) ; grants = new ArrayList < Grant > ( ) ; } CanonicalUserType aws = new CanonicalUserType ( ) ; aws . setDisplayName ( "" ) ; Grant grant = new Grant ( new Grantee ( aws ) , cannedACLString ) ; grants . add ( grant ) ; accessControlList . setGrants ( grants ) ; String acl = paramFieldMap . remove ( "AccessControlList" ) ; if ( acl != null ) { obj . setProperty ( acl , accessControlList ) ; } } private List < String > populateObjectList ( final GroovyObject obj , final Map . Entry < String , String > paramFieldPair , final Map < String , String > params , final int paramSize ) { List < String > failedMappings = new ArrayList < String > ( ) ; try { Field declaredField = obj . getClass ( ) . getDeclaredField ( paramFieldPair . getValue ( ) ) ; ArrayList theList = ( ArrayList ) obj . getProperty ( paramFieldPair . getValue ( ) ) ; Class genericType = ( Class ) ( ( ParameterizedType ) declaredField . getGenericType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; if ( String . class . equals ( genericType ) ) { if ( params . containsKey ( paramFieldPair . getKey ( ) ) ) theList . add ( params . remove ( paramFieldPair . getKey ( ) ) ) ; else for ( int i = 0 ; i < paramSize + 1 ; i ++ ) if ( params . containsKey ( paramFieldPair . getKey ( ) + "." + i ) ) theList . add ( params . remove ( paramFieldPair . getKey ( ) + "." + i ) ) ; } else if ( declaredField . isAnnotationPresent ( HttpEmbedded . class ) ) { HttpEmbedded annoteEmbedded = ( HttpEmbedded ) declaredField . getAnnotation ( HttpEmbedded . class ) ; if ( annoteEmbedded . multiple ( ) ) { String prefix = paramFieldPair . getKey ( ) ; List < String > embeddedListFieldNames = new ArrayList < String > ( ) ; for ( String actualParameterName : params . keySet ( ) ) if ( actualParameterName . matches ( prefix + ".1.*" ) ) embeddedListFieldNames . add ( actualParameterName . replaceAll ( prefix + ".1." , "" ) ) ; for ( int i = 0 ; i < paramSize + 1 ; i ++ ) { boolean foundAll = true ; Map < String , String > embeddedParams = new HashMap < String , String > ( ) ; for ( String fieldName : embeddedListFieldNames ) { String paramName = prefix + "." + i + "." + fieldName ; if ( ! params . containsKey ( paramName ) ) { failedMappings . add ( "Mismatched embedded field: " + paramName ) ; foundAll = false ; } else embeddedParams . put ( fieldName , params . get ( paramName ) ) ; } if ( foundAll ) failedMappings . addAll ( populateEmbedded ( genericType , embeddedParams , theList ) ) ; else break ; } } else failedMappings . addAll ( populateEmbedded ( genericType , params , theList ) ) ; } } catch ( Exception e1 ) { failedMappings . add ( paramFieldPair . getKey ( ) ) ; } return failedMappings ; } private List < String > populateEmbedded ( final Class genericType , final Map < String , String > params , final ArrayList theList ) throws InstantiationException , IllegalAccessException { GroovyObject embedded = ( GroovyObject ) genericType . newInstance ( ) ; Map < String , String > embeddedFields = buildFieldMap ( genericType ) ; int startSize = params . size ( ) ; List < String > embeddedFailures = populateObject ( embedded , embeddedFields , params , null ) ; if ( embeddedFailures . isEmpty ( ) && ! ( params . size ( ) - startSize == 0 ) ) theList . add ( embedded ) ; return embeddedFailures ; } private Map < String , String > buildFieldMap ( final Class targetType ) { Map < String , String > fieldMap = new HashMap < String , String > ( ) ; Field [ ] fields = targetType . getDeclaredFields ( ) ; for ( Field f : fields ) if ( Modifier . isStatic ( f . getModifiers ( ) ) ) continue ; else if ( f . isAnnotationPresent ( HttpParameterMapping . class ) ) fieldMap . put ( f . getAnnotation ( HttpParameterMapping . class ) . parameter ( ) , f . getName ( ) ) ; else fieldMap . put ( f . getName ( ) . substring ( 0 , 1 ) . toUpperCase ( ) . concat ( f . getName ( ) . substring ( 1 ) ) , f . getName ( ) ) ; return fieldMap ; } } 