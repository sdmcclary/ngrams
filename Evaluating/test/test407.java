public class EventList implements EventSequence { private Vector current ; private int smallestIndex = 0 ; private int toPrivate ( int index ) { return index - smallestIndex ; } private int fromPrivate ( int index ) { return index + smallestIndex ; } private boolean coalesceNext ( int index ) { boolean result = false ; if ( index < current . size ( ) - 1 ) { Event curr = ( Event ) current . elementAt ( index ) ; Event next = ( Event ) current . elementAt ( index + 1 ) ; if ( curr . getType ( ) == Event . CONTENT && next . getType ( ) == Event . CONTENT ) { Event ev = Event . createContent ( ( String ) curr . getValue ( ) + ( String ) next . getValue ( ) ) ; current . removeElementAt ( index + 1 ) ; current . setElementAt ( ev , index ) ; result = true ; } } return result ; } public EventList ( ) { current = new Vector ( ) ; } public int size ( ) { return current . size ( ) ; } public boolean isEmpty ( ) { return current . isEmpty ( ) ; } public void clear ( ) { current . removeAllElements ( ) ; } public void reset ( ) { current . removeAllElements ( ) ; smallestIndex = 0 ; } public void add ( Event ev ) { add ( fromPrivate ( current . size ( ) ) , ev ) ; } public void add ( int index , Event ev ) { int i = toPrivate ( index ) ; if ( i < 0 || i > current . size ( ) ) { throw new IndexOutOfBoundsException ( "Index " + index + " out of range" ) ; } if ( ev . getType ( ) == Event . ATTRIBUTE ) { if ( i > 0 ) { Event prev = ( Event ) current . elementAt ( i - 1 ) ; int prevType = prev . getType ( ) ; if ( prevType != Event . START_ELEMENT && prevType != Event . ATTRIBUTE ) { throw new IllegalArgumentException ( "ATTR not allowed " + "after type " + prevType ) ; } } } current . insertElementAt ( ev , i ) ; } public void addAll ( EventSequence es ) { for ( Enumeration e = es . events ( ) ; e . hasMoreElements ( ) ; ) { Event ev = ( Event ) e . nextElement ( ) ; add ( ev ) ; } } public Event remove ( int index ) { index = toPrivate ( index ) ; Event result = ( Event ) current . elementAt ( index ) ; current . removeElementAt ( index ) ; return result ; } public Event get ( int index ) { index = toPrivate ( index ) ; if ( index >= 0 && index < current . size ( ) ) { return ( Event ) current . elementAt ( index ) ; } else { return null ; } } public EventSequence subSequence ( int from ) { return subSequence ( from , current . size ( ) ) ; } public EventSequence subSequence ( int from , int to ) { int f = toPrivate ( from ) ; int t = toPrivate ( to ) ; if ( f < 0 || t > current . size ( ) ) { throw new IllegalArgumentException ( "Out of range: from=" + from + ", to=" + to ) ; } return new SubSequence ( from , to ) ; } public Enumeration events ( ) { return new ListEnumerator ( this , getSmallestActiveIndex ( ) , getLargestActiveIndex ( ) + 1 ) ; } public void forgetUntil ( int index ) { int large = toPrivate ( index ) ; if ( index == smallestIndex ) { return ; } else if ( large == current . size ( ) ) { forget ( ) ; } else if ( index > smallestIndex && large < current . size ( ) ) { int size = current . size ( ) - large ; Vector result = new Vector ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { result . addElement ( current . elementAt ( i + index ) ) ; } current = result ; smallestIndex = index ; } else { throw new IllegalArgumentException ( "Index " + index + " out of range" ) ; } } public void forget ( ) { smallestIndex += current . size ( ) ; current . removeAllElements ( ) ; } public int getSmallestActiveIndex ( ) { return fromPrivate ( 0 ) ; } public int getLargestActiveIndex ( ) { return fromPrivate ( current . size ( ) - 1 ) ; } @ Override public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof EventSequence ) { result = XasUtil . sequenceEquals ( this , ( EventSequence ) o ) ; } return result ; } @ Override public int hashCode ( ) { return XasUtil . sequenceHashCode ( this ) ; } @ Override public String toString ( ) { return current . toString ( ) ; } private class SubSequence implements EventSequence { private EventList parent ; private int originalLow ; private int high ; private int low ; private boolean check ( int index ) { int value = translate ( index ) ; return value >= low && value < high ; } private int translate ( int index ) { return index + originalLow ; } public SubSequence ( int low , int high ) { this . parent = EventList . this ; this . originalLow = this . low = low ; this . high = high ; } public Event get ( int index ) { if ( ! check ( index ) ) { return null ; } return parent . get ( translate ( index ) ) ; } public EventSequence subSequence ( int from , int to ) { if ( ! check ( from ) || ! check ( to - 1 ) ) { throw new IllegalArgumentException ( "Out of range: from=" + from + ",to=" + to ) ; } return parent . subSequence ( translate ( from ) , translate ( to ) ) ; } public Enumeration events ( ) { return new ListEnumerator ( parent , low , high ) ; } public void forgetUntil ( int index ) { low = index ; } public void forget ( ) { low = high ; } public int getSmallestActiveIndex ( ) { return low ; } public int getLargestActiveIndex ( ) { return high - 1 ; } @ Override public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof EventSequence ) { result = XasUtil . sequenceEquals ( this , ( EventSequence ) o ) ; } return result ; } @ Override public int hashCode ( ) { return XasUtil . sequenceHashCode ( this ) ; } @ Override public String toString ( ) { Vector result = new Vector ( high - low ) ; for ( int i = 0 ; i < high - low ; i ++ ) { result . addElement ( get ( i ) ) ; } return result . toString ( ) ; } } private static class ListEnumerator implements Enumeration { private EventSequence seq ; private int index ; private int high ; public ListEnumerator ( EventSequence seq , int low , int high ) { this . seq = seq ; this . index = low ; this . high = high ; } public boolean hasMoreElements ( ) { return index < high ; } public Object nextElement ( ) { if ( index < high ) { return seq . get ( index ++ ) ; } else { throw new NoSuchElementException ( "List exhausted" ) ; } } } } 