<<<<<<< HEAD
class DurationDatatype extends RegexDatatype implements OrderRelation { static private final String PATTERN = "-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?(([0-9]+(\\.[0-9]*)?|\\.[0-9]+)S)?)?" ; DurationDatatype ( ) { super ( PATTERN ) ; } public boolean lexicallyAllows ( String str ) { if ( ! super . lexicallyAllows ( str ) ) return false ; char last = str . charAt ( str . length ( ) - 1 ) ; return last != 'P' && last != 'T' ; } String getLexicalSpaceKey ( ) { return "duration" ; } static private class Duration { private final BigInteger years ; private final BigInteger months ; private final BigInteger days ; private final BigInteger hours ; private final BigInteger minutes ; private final BigDecimal seconds ; Duration ( boolean negative , BigInteger years , BigInteger months , BigInteger days , BigInteger hours , BigInteger minutes , BigDecimal seconds ) { if ( negative ) { this . years = years . negate ( ) ; this . months = months . negate ( ) ; this . days = days . negate ( ) ; this . hours = hours . negate ( ) ; this . minutes = minutes . negate ( ) ; this . seconds = seconds . negate ( ) ; } else { this . years = years ; this . months = months ; this . days = days ; this . hours = hours ; this . minutes = minutes ; this . seconds = seconds ; } } BigInteger getYears ( ) { return years ; } BigInteger getMonths ( ) { return months ; } BigInteger getDays ( ) { return days ; } BigInteger getHours ( ) { return hours ; } BigInteger getMinutes ( ) { return minutes ; } BigDecimal getSeconds ( ) { return seconds ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof Duration ) ) return false ; Duration other = ( Duration ) obj ; return ( this . years . equals ( other . years ) && this . months . equals ( other . months ) && this . days . equals ( other . days ) && this . hours . equals ( other . hours ) && this . minutes . equals ( other . minutes ) && this . seconds . compareTo ( other . seconds ) == 0 ) ; } public int hashCode ( ) { return ( years . hashCode ( ) ^ months . hashCode ( ) ^ days . hashCode ( ) ^ hours . hashCode ( ) ^ minutes . hashCode ( ) ^ seconds . hashCode ( ) ) ; } } Object getValue ( String str , ValidationContext vc ) { int t = str . indexOf ( 'T' ) ; if ( t < 0 ) t = str . length ( ) ; String date = str . substring ( 0 , t ) ; String time = str . substring ( t ) ; return new Duration ( str . charAt ( 0 ) == '-' , getIntegerField ( date , 'Y' ) , getIntegerField ( date , 'M' ) , getIntegerField ( date , 'D' ) , getIntegerField ( time , 'H' ) , getIntegerField ( time , 'M' ) , getDecimalField ( time , 'S' ) ) ; } static private BigInteger getIntegerField ( String str , char code ) { int end = str . indexOf ( code ) ; if ( end < 0 ) return BigInteger . valueOf ( 0 ) ; int start = end ; while ( Character . isDigit ( str . charAt ( start - 1 ) ) ) -- start ; return new BigInteger ( str . substring ( start , end ) ) ; } static private BigDecimal getDecimalField ( String str , char code ) { int end = str . indexOf ( code ) ; if ( end < 0 ) return BigDecimal . valueOf ( 0 ) ; int start = end ; while ( ! Character . isLetter ( str . charAt ( start - 1 ) ) ) -- start ; return new BigDecimal ( str . substring ( start , end ) ) ; } OrderRelation getOrderRelation ( ) { return this ; } private static final int [ ] REF_YEAR_MONTHS = { 1696 , 9 , 1697 , 2 , 1903 , 3 , 1903 , 7 } ; public boolean isLessThan ( Object obj1 , Object obj2 ) { Duration d1 = ( Duration ) obj1 ; Duration d2 = ( Duration ) obj2 ; BigInteger months1 = computeMonths ( d1 ) ; BigInteger months2 = computeMonths ( d2 ) ; BigDecimal seconds1 = computeSeconds ( d1 ) ; BigDecimal seconds2 = computeSeconds ( d2 ) ; switch ( months1 . compareTo ( months2 ) ) { case - 1 : if ( seconds1 . compareTo ( seconds2 ) <= 0 ) return true ; break ; case 0 : return seconds1 . compareTo ( seconds2 ) < 0 ; case 1 : if ( seconds1 . compareTo ( seconds2 ) >= 0 ) return false ; break ; } for ( int i = 0 ; i < REF_YEAR_MONTHS . length ; i += 2 ) { BigDecimal total1 = daysPlusSeconds ( computeDays ( months1 , REF_YEAR_MONTHS [ i ] , REF_YEAR_MONTHS [ i + 1 ] ) , seconds1 ) ; BigDecimal total2 = daysPlusSeconds ( computeDays ( months2 , REF_YEAR_MONTHS [ i ] , REF_YEAR_MONTHS [ i + 1 ] ) , seconds2 ) ; if ( total1 . compareTo ( total2 ) >= 0 ) return false ; } return true ; } private static BigInteger computeDays ( BigInteger months , int refYear , int refMonth ) { switch ( months . signum ( ) ) { case 0 : return BigInteger . valueOf ( 0 ) ; case - 1 : return computeDays ( months . negate ( ) , refYear , refMonth ) . negate ( ) ; } BigInteger [ ] tem = months . divideAndRemainder ( BigInteger . valueOf ( 400 * 12 ) ) ; -- refMonth ; int total = 0 ; for ( int rem = tem [ 1 ] . intValue ( ) ; rem > 0 ; rem -- ) { total += daysInMonth ( refYear , refMonth ) ; if ( ++ refMonth == 12 ) { refMonth = 0 ; refYear ++ ; } } return tem [ 0 ] . multiply ( BigInteger . valueOf ( 365 * 400 + 97 ) ) . add ( BigInteger . valueOf ( total ) ) ; } private static int daysInMonth ( int year , int month ) { switch ( month ) { case Calendar . SEPTEMBER : case Calendar . APRIL : case Calendar . JUNE : case Calendar . NOVEMBER : return 30 ; case Calendar . FEBRUARY : return isLeapYear ( year ) ? 29 : 28 ; } return 31 ; } private static boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } private static BigDecimal daysPlusSeconds ( BigInteger days , BigDecimal seconds ) { return seconds . add ( new BigDecimal ( days . multiply ( BigInteger . valueOf ( 24 * 60 * 60 ) ) ) ) ; } private static BigInteger computeMonths ( Duration d ) { return d . getYears ( ) . multiply ( BigInteger . valueOf ( 12 ) ) . add ( d . getMonths ( ) ) ; } private static BigDecimal computeSeconds ( Duration d ) { return d . getSeconds ( ) . add ( new BigDecimal ( d . getDays ( ) . multiply ( BigInteger . valueOf ( 24 ) ) . add ( d . getHours ( ) ) . multiply ( BigInteger . valueOf ( 60 ) ) . add ( d . getMinutes ( ) ) . multiply ( BigInteger . valueOf ( 60 ) ) ) ) ; } public static void main ( String [ ] args ) { DurationDatatype dt = new DurationDatatype ( ) ; System . err . println ( dt . isLessThan ( dt . getValue ( args [ 0 ] , null ) , dt . getValue ( args [ 1 ] , null ) ) ) ; } } 
=======
public final class Service < T > { private final Class < T > serviceClass ; private final Enumeration < URL > configFiles ; private Iterator < String > classNames = null ; private final List < T > providers = new ArrayList < T > ( ) ; private Loader loader ; private class ProviderIterator implements Iterator < T > { private int nextIndex = 0 ; public boolean hasNext ( ) { return nextIndex < providers . size ( ) || moreProviders ( ) ; } public T next ( ) { try { return providers . get ( nextIndex ++ ) ; } catch ( IndexOutOfBoundsException e ) { throw new NoSuchElementException ( ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private static class Singleton < T > implements Enumeration < T > { private T obj ; private Singleton ( T obj ) { this . obj = obj ; } public boolean hasMoreElements ( ) { return obj != null ; } public T nextElement ( ) { if ( obj == null ) throw new NoSuchElementException ( ) ; T tem = obj ; obj = null ; return tem ; } } private static class Loader { Enumeration < URL > getResources ( String resName ) { ClassLoader cl = Loader . class . getClassLoader ( ) ; URL url ; if ( cl == null ) url = ClassLoader . getSystemResource ( resName ) ; else url = cl . getResource ( resName ) ; return new Singleton < URL > ( url ) ; } Class < ? > loadClass ( String name ) throws ClassNotFoundException { return Class . forName ( name ) ; } } private static class Loader2 extends Loader { private ClassLoader cl ; Loader2 ( ) { cl = Loader2 . class . getClassLoader ( ) ; ClassLoader clt = Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( ClassLoader tem = clt ; tem != null ; tem = tem . getParent ( ) ) if ( tem == cl ) { cl = clt ; break ; } } Enumeration < URL > getResources ( String resName ) { try { Enumeration < URL > resources = cl . getResources ( resName ) ; if ( resources . hasMoreElements ( ) ) return resources ; return new Singleton < URL > ( cl . getResource ( resName ) ) ; } catch ( IOException e ) { return new Singleton < URL > ( null ) ; } } Class < ? > loadClass ( String name ) throws ClassNotFoundException { return Class . forName ( name , true , cl ) ; } } static public < T > Service < T > newInstance ( Class < T > cls ) { return new Service < T > ( cls ) ; } private Service ( Class < T > cls ) { try { loader = new Loader2 ( ) ; } catch ( NoSuchMethodError e ) { loader = new Loader ( ) ; } serviceClass = cls ; String resName = "META-INF/services/" + serviceClass . getName ( ) ; configFiles = loader . getResources ( resName ) ; } public Iterator < T > getProviders ( ) { return new ProviderIterator ( ) ; } synchronized private boolean moreProviders ( ) { for ( ; ; ) { while ( classNames == null ) { if ( ! configFiles . hasMoreElements ( ) ) return false ; classNames = parseConfigFile ( configFiles . nextElement ( ) ) ; } while ( classNames . hasNext ( ) ) { String className = classNames . next ( ) ; try { Class < ? > cls = loader . loadClass ( className ) ; Object obj = cls . newInstance ( ) ; if ( serviceClass . isInstance ( obj ) ) { providers . add ( serviceClass . cast ( obj ) ) ; return true ; } } catch ( ClassNotFoundException e ) { } catch ( InstantiationException e ) { } catch ( IllegalAccessException e ) { } catch ( LinkageError e ) { } } classNames = null ; } } private static final int START = 0 ; private static final int IN_NAME = 1 ; private static final int IN_COMMENT = 2 ; private static Iterator < String > parseConfigFile ( URL url ) { try { InputStream in = url . openStream ( ) ; Reader r ; try { r = new InputStreamReader ( in , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { r = new InputStreamReader ( in , "UTF8" ) ; } r = new BufferedReader ( r ) ; List < String > tokens = new ArrayList < String > ( ) ; StringBuilder tokenBuf = new StringBuilder ( ) ; int state = START ; for ( ; ; ) { int n = r . read ( ) ; if ( n < 0 ) break ; char c = ( char ) n ; switch ( c ) { case '\r' : case '\n' : state = START ; break ; case ' ' : case '\t' : break ; case '#' : state = IN_COMMENT ; break ; default : if ( state != IN_COMMENT ) { state = IN_NAME ; tokenBuf . append ( c ) ; } break ; } if ( tokenBuf . length ( ) != 0 && state != IN_NAME ) { tokens . add ( tokenBuf . toString ( ) ) ; tokenBuf . setLength ( 0 ) ; } } if ( tokenBuf . length ( ) != 0 ) tokens . add ( tokenBuf . toString ( ) ) ; return tokens . iterator ( ) ; } catch ( IOException e ) { return null ; } } public static void main ( String [ ] args ) throws ClassNotFoundException { Service < ? > svc = Service . newInstance ( Class . forName ( args [ 0 ] ) ) ; for ( Iterator < ? > iter = svc . getProviders ( ) ; iter . hasNext ( ) ; ) System . out . println ( iter . next ( ) . getClass ( ) . getName ( ) ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
