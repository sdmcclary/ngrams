<<<<<<< HEAD
public class GrammarNode extends GrammarNodeBase { private static class NodeKey { public int type ; public String name ; public NodeKey ( IGrammarNode node ) { this ( node . getTypeIndex ( ) , node . getName ( ) ) ; } public NodeKey ( int type , String name ) { this . type = type ; this . name = name ; } public boolean equals ( Object obj ) { boolean result = false ; if ( this == obj ) { result = true ; } else if ( obj instanceof NodeKey ) { NodeKey nodeKey = ( NodeKey ) obj ; result = ( this . type == nodeKey . type && this . name == nodeKey . name ) ; } return result ; } public int hashCode ( ) { return this . type ^ this . name . hashCode ( ) ; } } private Map < String , List < ProductionNode > > _productions ; private String _startingName ; private TerminalNode _eofNode ; private IEnumerationMap _terminalMap ; private IEnumerationMap _nonTerminalMap ; private Map < NodeKey , IGrammarNode > _nodeCache ; public GrammarNode ( String name ) { super ( null , GrammarNodeTypes . GRAMMAR , name ) ; this . _terminalMap = new DynamicEnumerationMap ( ) ; this . _nonTerminalMap = new DynamicEnumerationMap ( ) ; this . _terminalMap . getIntValue ( "$" ) ; this . _nodeCache = new HashMap < NodeKey , IGrammarNode > ( ) ; } public void appendChild ( IGrammarNode child ) { super . appendChild ( child ) ; if ( child . getTypeIndex ( ) == GrammarNodeTypes . PRODUCTION ) { ProductionNode production = ( ProductionNode ) child ; String name = production . getName ( ) ; if ( this . _startingName == null ) { this . _startingName = production . getName ( ) ; } if ( this . _productions == null ) { this . _productions = new HashMap < String , List < ProductionNode > > ( ) ; } if ( this . _productions . containsKey ( name ) == false ) { this . _productions . put ( name , new ArrayList < ProductionNode > ( ) ) ; } this . _productions . get ( name ) . add ( production ) ; } } public SequenceNode createSequenceNode ( ) { return new SequenceNode ( this ) ; } public TerminalNode createEOFNode ( ) { if ( this . _eofNode == null ) { this . _eofNode = this . createTerminalNode ( "$" ) ; } return this . _eofNode ; } public EmptyNode createEmptyNode ( ) { return new EmptyNode ( this ) ; } public NonTerminalNode createNonTerminalNode ( String name ) { int index = this . _nonTerminalMap . getIntValue ( name ) ; return new NonTerminalNode ( this , name , index ) ; } public ProductionNode createProductionNode ( String name ) { return new ProductionNode ( this , name ) ; } public TerminalNode createTerminalNode ( String name ) { int index = this . _terminalMap . getIntValue ( name ) ; NodeKey key = new NodeKey ( GrammarNodeTypes . TERMINAL , name ) ; TerminalNode result ; if ( this . _nodeCache . containsKey ( key ) ) { result = ( TerminalNode ) this . _nodeCache . get ( key ) ; } else { result = new TerminalNode ( this , name , index ) ; this . _nodeCache . put ( key , result ) ; } return result ; } public GrammarNode getExpandedGrammar ( ) { GrammarNode result = new GrammarNode ( this . getName ( ) ) ; for ( int i = 0 ; i < this . getChildCount ( ) ; i ++ ) { IGrammarNode child = ( IGrammarNode ) this . getChild ( i ) ; if ( child . getTypeIndex ( ) == GrammarNodeTypes . PRODUCTION ) { ProductionNode production = ( ProductionNode ) child ; String name = production . getName ( ) ; for ( int j = 0 ; j < production . getChildCount ( ) ; j ++ ) { ProductionNode newProduction = result . createProductionNode ( name ) ; newProduction . appendChild ( production . getChild ( j ) ) ; result . appendChild ( newProduction ) ; } } } result . setStartingName ( this . getStartingName ( ) ) ; return result ; } public TerminalList getFirst ( String name ) { ProductionNode [ ] productions = this . getProductionsByName ( name ) ; TerminalList result = new TerminalList ( ) ; for ( int i = 0 ; i < productions . length ; i ++ ) { ProductionNode production = productions [ i ] ; production . getFirst ( result ) ; } return result ; } public TerminalList getFollow ( String name ) { TerminalList terminals = new TerminalList ( ) ; this . getFollow ( name , terminals ) ; return terminals ; } public void getFollow ( String name , TerminalList terminals ) { if ( name . equals ( this . _startingName ) ) { terminals . add ( this . createEOFNode ( ) ) ; } for ( Item item : this . getProductionsWithNonTerminal ( name ) ) { item . getFollow ( terminals ) ; } } private Item [ ] getProductionsWithNonTerminal ( String name ) { List < Item > result = new ArrayList < Item > ( ) ; for ( int i = 0 ; i < this . getChildCount ( ) ; i ++ ) { ProductionNode productionNode = ( ProductionNode ) this . getChild ( i ) ; Item item = productionNode . findNonTerminal ( name ) ; if ( item != null ) { result . add ( item ) ; } } return result . toArray ( new Item [ result . size ( ) ] ) ; } public String [ ] getProductionNames ( ) { List < String > names = new ArrayList < String > ( ) ; for ( int i = 0 ; i < this . getChildCount ( ) ; i ++ ) { IGrammarNode child = ( IGrammarNode ) this . getChild ( i ) ; if ( child . getTypeIndex ( ) == GrammarNodeTypes . PRODUCTION ) { ProductionNode production = ( ProductionNode ) child ; String name = production . getName ( ) ; if ( names . contains ( name ) == false ) { names . add ( name ) ; } } } return names . toArray ( new String [ names . size ( ) ] ) ; } public ProductionNode [ ] getProductionsByName ( String name ) { List < ProductionNode > result ; if ( this . _productions . containsKey ( name ) ) { result = this . _productions . get ( name ) ; } else { result = new ArrayList < ProductionNode > ( ) ; } return result . toArray ( new ProductionNode [ result . size ( ) ] ) ; } public String getStartingName ( ) { return this . _startingName ; } public IGrammarNode [ ] getSymbols ( ) { List < IGrammarNode > symbols = new ArrayList < IGrammarNode > ( ) ; symbols . add ( this . createEOFNode ( ) ) ; for ( int i = 0 ; i < this . getChildCount ( ) ; i ++ ) { IGrammarNode child = ( IGrammarNode ) this . getChild ( i ) ; child . getSymbols ( symbols ) ; } GrammarNodeBase [ ] result = symbols . toArray ( new GrammarNodeBase [ symbols . size ( ) ] ) ; Arrays . sort ( result , new Comparator < GrammarNodeBase > ( ) { public int compare ( GrammarNodeBase o1 , GrammarNodeBase o2 ) { int type1 = o1 . getTypeIndex ( ) ; int type2 = o2 . getTypeIndex ( ) ; int result = 0 ; if ( type1 == type2 ) { if ( type1 == GrammarNodeTypes . TERMINAL ) { int index1 = ( ( TerminalNode ) o1 ) . getIndex ( ) ; int index2 = ( ( TerminalNode ) o2 ) . getIndex ( ) ; result = index1 - index2 ; } else { result = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } else { if ( type1 == GrammarNodeTypes . TERMINAL ) { result = - 1 ; } else { result = 1 ; } } return result ; } } ) ; return result ; } public void setStartingName ( String startingName ) { this . _startingName = startingName ; } public void getSource ( SourceWriter writer ) { if ( this . hasChildren ( ) ) { this . getChild ( 0 ) . getSource ( writer ) ; for ( int i = 1 ; i < this . getChildCount ( ) ; i ++ ) { writer . println ( ) ; this . getChild ( i ) . getSource ( writer ) ; } } } } 
=======
public class MarshalDate implements Marshal { public static Class DATE_CLASS = new Date ( ) . getClass ( ) ; public Object readInstance ( XmlPullParser parser , String namespace , String name , PropertyInfo expected ) throws IOException , XmlPullParserException { return IsoDate . stringToDate ( parser . nextText ( ) , IsoDate . DATE_TIME ) ; } public void writeInstance ( XmlSerializer writer , Object obj ) throws IOException { writer . text ( IsoDate . dateToString ( ( Date ) obj , IsoDate . DATE_TIME ) ) ; } public void register ( SoapSerializationEnvelope cm ) { cm . addMapping ( cm . xsd , "dateTime" , MarshalDate . DATE_CLASS , this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
