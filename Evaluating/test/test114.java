public final class GlobalController implements IIPCListener { private static final Logger LOG = Logger . getLogger ( GlobalController . class . getName ( ) ) ; private static final String AUTO_GUIDE_TITLE = Strings . message ( "automatically.created.guide.title" ) ; private static final String KEY_SELECTED_GUIDE_ID = "selectedGuideId" ; private static final String KEY_SELECTED_FEED_ID = "selectedFeedId" ; private static final int LAST_BACKUPS_TO_KEEP = 10 ; private static final String THREAD_NAME_SEARCH_QUERY = "Run Search Feed Query" ; static final int CHANGE_CHECK_FEEDS_THRESHOLD = 50 ; static final int CHANGE_CHECK_DIFF_TIMES = 3 ; public static final GlobalController SINGLETON = new GlobalController ( ) ; private List < IControllerListener > listeners = new CopyOnWriteArrayList < IControllerListener > ( ) ; private boolean initializationFinished = false ; private GlobalModel model ; private MDManager metaDataManager ; private MDUpdater metaDataUpdater ; private NavigatorAdv navigator ; private NavigatorAdapter navigatorAdapter ; private ScoresCalculator scoresCalculator ; private HighlightsCalculator highlightsCalculator ; private PropertyChangeDispatcher propertyChangeDispatcher ; private BackgroundProccessManager backManager ; private GuideModel navigationModel ; private MainFrame mainFrame ; private SelectedFeedListener selectedFeedListener ; private DeletedObjectsRepository deletedObjectsRepository ; private SearchFeedsManager searchFeedsManager ; private DomainEventsListener domainEventsListener ; private HighlightsCalculator searchHighlightsCalculator ; private String currentSearchKeywords ; private TagsSaver tagsSaver ; private WrappingStorage tagsStorage ; private Poller poller ; private URL hoveredLink ; private SearchEngine searchEngine ; private EventsNotifier eventNotifier ; DockIconUnreadMonitor dockIconUnreadMonitor ; private FeatureManager featureManager ; private GuidesListModel guidesListModel ; private PinTagger pinTagger ; private AutoSaver autoSaver ; private String highlightedArticleLink ; private GlobalController ( ) { if ( LOG . isLoggable ( Level . FINE ) ) LOG . fine ( "Constructing GlobalController" ) ; hoveredLink = null ; AbstractFeed . setFeedVisibilityResolver ( new IFeedVisibilityResolver ( ) { public boolean isVisible ( IFeed feed ) { return feed != null && FeedDisplayModeManager . getInstance ( ) . isVisible ( feed . getClassesMask ( ) ) ; } } ) ; featureManager = new FeatureManager ( Application . getUserPreferences ( ) ) ; if ( NotificationArea . isSupported ( ) ) { eventNotifier = new EventsNotifier ( ) ; eventNotifier . setSoundResourceID ( "sound.new.articles" ) ; } searchEngine = new SearchEngine ( ) ; backManager = new BackgroundProccessManager ( ) ; pinTagger = new PinTagger ( this ) ; autoSaver = new AutoSaver ( ) ; if ( SystemUtils . IS_OS_MAC ) dockIconUnreadMonitor = new DockIconUnreadMonitor ( ) ; selectedFeedListener = new SelectedFeedListener ( ) ; deletedObjectsRepository = new DeletedObjectsRepository ( PersistenceManagerConfig . getManager ( ) ) ; searchHighlightsCalculator = new HighlightsCalculator ( ) ; currentSearchKeywords = "" ; highlightsCalculator = new HighlightsCalculator ( ) ; scoresCalculator = new ScoresCalculator ( ) ; guidesListModel = new GuidesListModel ( ) ; navigationModel = new GuideModel ( scoresCalculator , false , FeedDisplayModeManager . getInstance ( ) ) ; navigator = new NavigatorAdv ( navigationModel , guidesListModel ) ; addControllerListener ( navigator ) ; navigatorAdapter = new NavigatorAdapter ( ) ; propertyChangeDispatcher = new PropertyChangeDispatcher ( this ) ; setupTagsSupport ( ) ; setupMetaDataSupport ( ) ; setupPolling ( ) ; addControllerListener ( ArticleMarker . getInstance ( ) ) ; setModel ( new GlobalModel ( scoresCalculator ) ) ; GlobalModel . setSINGLETON ( model ) ; addDomainListener ( new DomainListener ( ) ) ; } public GuidesListModel getGuidesListModel ( ) { return guidesListModel ; } public FeatureManager getFeatureManager ( ) { return featureManager ; } private void setupStylesUpdater ( ) { backManager . schedule ( StylesheetManager . getUpdater ( ) , 20 , 3600 ) ; } public DeletedObjectsRepository getDeletedFeedsRepository ( ) { return deletedObjectsRepository ; } private void setupFeedReselector ( ) { long delayToTomorrow = DateUtils . getTomorrowTime ( ) - System . currentTimeMillis ( ) ; delayToTomorrow += 1000L ; backManager . schedule ( new Runnable ( ) { public void run ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { IFeed selFeed = getModel ( ) . getSelectedFeed ( ) ; if ( selFeed != null ) { selectFeed ( null ) ; selectFeed ( selFeed , true ) ; } } } ) ; } } , delayToTomorrow / Constants . MILLIS_IN_SECOND , Constants . SECONDS_IN_DAY ) ; } private void setupPolling ( ) { ConnectionState connectionState = getConnectionState ( ) ; poller = new Poller ( connectionState ) ; } public static ConnectionState getConnectionState ( ) { return ApplicationLauncher . getConnectionState ( ) ; } private void setupMetaDataSupport ( ) { ConnectionState connectionState = getConnectionState ( ) ; metaDataManager = new MDManager ( connectionState ) ; metaDataManager . addDiscoveryListener ( new DiscoveryListener ( ) ) ; metaDataUpdater = new MDUpdater ( metaDataManager , connectionState ) ; } private void setupTagsSupport ( ) { tagsStorage = new WrappingStorage ( new EmptyStorage ( ) ) ; tagsSaver = new TagsSaver ( tagsStorage ) ; } public void changeTagsStorage ( int aNewType ) { ITagsStorage storage ; switch ( aNewType ) { case UserPreferences . TAGS_STORAGE_DELICIOUS : storage = new DeliciousStorage ( new UserPreferencesCallback ( ) ) ; break ; case UserPreferences . TAGS_STORAGE_BB_SERVICE : storage = new BBServiceStorage ( new BBServiceCredentialCallback ( ) ) ; break ; default : storage = new EmptyStorage ( ) ; break ; } tagsStorage . setCurrentStorage ( storage ) ; } public ITagsStorage getTagsStorage ( ) { return tagsStorage ; } private void setModel ( GlobalModel aModel ) { if ( model != null ) uninstallModel ( ) ; model = aModel ; if ( model != null ) installModel ( ) ; } public void setMainFrame ( MainFrame aMainFrame ) { if ( mainFrame == aMainFrame ) return ; mainFrame = aMainFrame ; if ( eventNotifier != null ) eventNotifier . setFrame ( aMainFrame ) ; mainFrame . setMinimizeToSystemTray ( model . getUserPreferences ( ) . isMinimizeToSystray ( ) ) ; } private void installModel ( ) { final GuidesSet guidesSet = model . getGuidesSet ( ) ; final StarzPreferences starzPreferences = model . getStarzPreferences ( ) ; final UserPreferences userPreferences = model . getUserPreferences ( ) ; userPreferences . addPropertyChangeListener ( propertyChangeDispatcher ) ; starzPreferences . addPropertyChangeListener ( propertyChangeDispatcher ) ; scoresCalculator . loadPreferences ( starzPreferences ) ; ArticleFilterProtector . init ( ) ; navigator . setViewModel ( model . getGuideModel ( ) ) ; navigator . guideSelected ( model . getSelectedGuide ( ) ) ; navigator . feedSelected ( model . getSelectedFeed ( ) ) ; navigator . setGuidesSet ( guidesSet ) ; domainEventsListener = new DomainEventsListener ( guidesSet ) ; searchFeedsManager = new SearchFeedsManager ( guidesSet ) ; domainEventsListener . addDomainListener ( searchFeedsManager ) ; if ( eventNotifier != null ) domainEventsListener . addDomainListener ( eventNotifier ) ; domainEventsListener . addDomainListener ( deletedObjectsRepository ) ; if ( dockIconUnreadMonitor != null ) { dockIconUnreadMonitor . setSet ( guidesSet ) ; addControllerListener ( dockIconUnreadMonitor . getMonitor ( ) ) ; domainEventsListener . addDomainListener ( dockIconUnreadMonitor ) ; userPreferences . addPropertyChangeListener ( dockIconUnreadMonitor ) ; FeedDisplayModeManager . getInstance ( ) . addListener ( dockIconUnreadMonitor ) ; } guidesListModel . setGuidesSet ( guidesSet ) ; addDomainListener ( guidesListModel . getDomainListener ( ) ) ; userPreferences . addPropertyChangeListener ( guidesListModel . getUserPreferencesListener ( ) ) ; addControllerListener ( guidesListModel . getControllerListener ( ) ) ; pinTagger . setUserPreferences ( userPreferences ) ; addDomainListener ( autoSaver ) ; tagsSaver . setGuidesSet ( guidesSet ) ; changeTagsStorage ( userPreferences . getTagsStorage ( ) ) ; metaDataUpdater . setGuidesSet ( guidesSet ) ; poller . setGuidesSet ( guidesSet ) ; poller . update ( ) ; searchEngine . setGuidesSet ( guidesSet ) ; if ( eventNotifier != null ) eventNotifier . setUserPreferences ( userPreferences ) ; CompositeURLFilter urlFilter = new CompositeURLFilter ( ) ; urlFilter . addFilter ( new ExtensionURLFilter ( ResourceUtils . getString ( ResourceID . NO_DISCOVERY_EXTENSIONS ) ) ) ; urlFilter . addFilter ( new DynamicExtensionURLFilter ( model . getUserPreferences ( ) , UserPreferences . PROP_NO_DISCOVERY_EXTENSIONS ) ) ; MDDiscoveryLogic . setURLFilter ( urlFilter ) ; featureManager . setServicePreferences ( model . getServicePreferences ( ) ) ; } private void uninstallModel ( ) { final StarzPreferences starzPreferences = model . getStarzPreferences ( ) ; final UserPreferences userPreferences = model . getUserPreferences ( ) ; starzPreferences . removePropertyChangeListener ( propertyChangeDispatcher ) ; userPreferences . removePropertyChangeListener ( propertyChangeDispatcher ) ; navigator . setViewModel ( null ) ; navigator . setGuidesSet ( null ) ; navigator . guideSelected ( null ) ; navigator . feedSelected ( null ) ; tagsSaver . setGuidesSet ( null ) ; searchEngine . setGuidesSet ( null ) ; guidesListModel . setGuidesSet ( null ) ; MDDiscoveryLogic . setURLFilter ( null ) ; } public GlobalModel getModel ( ) { return model ; } public SearchEngine getSearchEngine ( ) { return searchEngine ; } public IArticleListNavigationListener getNavigationListener ( ) { return navigatorAdapter ; } GuideModel getNavigationModel ( ) { return navigationModel ; } public BackgroundProccessManager getBackgroundProccessManager ( ) { return backManager ; } public static SearchFeedsManager getSearchFeedsManager ( ) { return SINGLETON . searchFeedsManager ; } public void selectGuideAndFeed ( final IGuide guide ) { selectGuide ( guide , true ) ; } public void selectGuide ( final IGuide guide , final boolean selectFeed ) { final boolean alreadySelected = model . getSelectedGuide ( ) == guide ; if ( ! isInitializationFinished ( ) || ! alreadySelected ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "selectGuide: " + ( guide == null ? "null" : guide . getTitle ( ) ) ) ; } SelectGuideTask task = new SelectGuideTask ( guide , selectFeed , alreadySelected ) ; if ( UifUtilities . isEDT ( ) ) task . run ( ) ; else SwingUtilities . invokeLater ( task ) ; } } public void selectFeed ( IFeed feed ) { selectFeed ( feed , false ) ; } public void selectFeed ( IFeed feed , boolean selectHidden ) { if ( LOG . isLoggable ( Level . FINE ) ) LOG . fine ( "selectFeed: " + feed ) ; highlightedArticleLink = null ; IFeed selectedFeed = model . getSelectedFeed ( ) ; if ( selectedFeed != null ) selectedFeed . removeListener ( selectedFeedListener ) ; GuideModel guideModel = model . getGuideModel ( ) ; if ( ! model . isSelectable ( feed ) || ( ! selectHidden && guideModel . indexOf ( feed ) == - 1 ) ) feed = null ; if ( feed != null ) feed . addListener ( selectedFeedListener ) ; navigationModel . ensureVisibilityOf ( feed ) ; guideModel . ensureVisibilityOf ( feed ) ; if ( mainFrame != null ) mainFrame . selectFeed ( feed ) ; final IFeed oldFeed = model . getSelectedFeed ( ) ; ViewModeValueModel vmvm = model . getViewModeValueModel ( ) ; ViewTypeValueModel vtvm = model . getViewTypeValueModel ( ) ; vmvm . recordValue ( ) ; vtvm . recordValue ( ) ; model . setSelectedFeed ( feed ) ; updateSearchHighlights ( oldFeed , feed ) ; ImageFetcher . clearQueue ( ) ; fireFeedSelected ( feed ) ; vmvm . compareRecordedWithCurrent ( ) ; vtvm . compareRecordedWithCurrent ( ) ; if ( feed == null ) selectArticle ( null ) ; } public void selectArticle ( final IArticle aArticle ) { selectArticle ( aArticle , null ) ; } public void selectArticle ( final IArticle aArticle , final String highlightLink ) { if ( aArticle != null ) { IFeed feed = aArticle . getFeed ( ) ; if ( model . getSelectedFeed ( ) != feed ) { IGuide [ ] guides = feed . getParentGuides ( ) ; boolean guideSelected = false ; IGuide currentGuide = model . getSelectedGuide ( ) ; for ( int i = 0 ; ! guideSelected && i < guides . length ; i ++ ) { IGuide guide = guides [ i ] ; guideSelected = ( guide == currentGuide ) ; } if ( ! guideSelected ) selectGuide ( chooseBestGuide ( guides ) , false ) ; selectFeed ( feed , true ) ; } } this . highlightedArticleLink = highlightLink ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { model . setSelectedArticles ( new IArticle [ ] { aArticle } ) ; model . setSelectedArticle ( aArticle ) ; fireArticleSelected ( aArticle ) ; } } ) ; } public String getHighlightedArticleLink ( ) { return highlightedArticleLink ; } private boolean updateSearchHighlights ( IFeed oldFeed , IFeed newFeed ) { boolean repaintHighlights = false ; if ( newFeed instanceof SearchFeed ) { repaintHighlights = installHighlightsFromSearchFeed ( ( SearchFeed ) newFeed ) ; } else if ( oldFeed != null && oldFeed instanceof SearchFeed ) { resetSearchHighlights ( ) ; repaintHighlights = true ; } return repaintHighlights ; } private void resetSearchHighlights ( ) { searchHighlightsCalculator . keywordsChanged ( Constants . EMPTY_STRING ) ; currentSearchKeywords = Constants . EMPTY_STRING ; } private boolean installHighlightsFromSearchFeed ( SearchFeed aFeed ) { boolean installed = false ; String newKeywords = collectKeywordsFromSearchFeed ( aFeed ) ; if ( ! newKeywords . equalsIgnoreCase ( currentSearchKeywords ) ) { searchHighlightsCalculator . keywordsChanged ( newKeywords ) ; currentSearchKeywords = newKeywords ; installed = true ; } return installed ; } private String collectKeywordsFromSearchFeed ( SearchFeed aFeed ) { StringBuffer keywords = new StringBuffer ( ) ; Query query = aFeed . getQuery ( ) ; int criteriaCount = query . getCriteriaCount ( ) ; for ( int i = 0 ; i < criteriaCount ; i ++ ) { ICriteria criteria = query . getCriteriaAt ( i ) ; if ( isKeywordsSearchCriteria ( criteria ) ) { String keywordsList = criteria . getValue ( ) ; String [ ] keywordsArray = StringUtils . keywordsToArray ( keywordsList ) ; for ( int j = 0 ; j < keywordsArray . length ; j ++ ) { keywordsArray [ j ] = StringUtils . quoteKeywordIfNecessary ( keywordsArray [ j ] ) ; } keywords . append ( "\n" ) . append ( StringUtils . join ( keywordsArray , "\n" ) ) ; } } return keywords . toString ( ) . trim ( ) ; } private static boolean isKeywordsSearchCriteria ( ICriteria aCriteria ) { return ArticleTextProperty . INSTANCE . equals ( aCriteria . getProperty ( ) ) && StringContainsCO . INSTANCE . equals ( aCriteria . getComparisonOperation ( ) ) ; } public MainFrame getMainFrame ( ) { return mainFrame ; } public void reassignChannelsTo ( final StandardGuide srcGuide , final StandardGuide destGuide ) { if ( destGuide == null || destGuide == srcGuide ) return ; IFeed [ ] feeds = null ; synchronized ( srcGuide ) { int srcFeedsCount = srcGuide . getFeedsCount ( ) ; if ( srcFeedsCount > 0 ) { feeds = new IFeed [ srcFeedsCount ] ; for ( int i = srcFeedsCount - 1 ; i >= 0 ; i -- ) { feeds [ i ] = srcGuide . getFeedAt ( i ) ; srcGuide . remove ( feeds [ i ] ) ; } } } if ( feeds != null ) { synchronized ( destGuide ) { for ( IFeed feed : feeds ) destGuide . add ( feed ) ; } } } public void mergeGuides ( final IGuide [ ] aGuides , final StandardGuide aMergeGuide ) { for ( IGuide aGuide : aGuides ) { if ( aGuide instanceof StandardGuide ) { reassignChannelsTo ( ( StandardGuide ) aGuide , aMergeGuide ) ; getModel ( ) . getGuidesSet ( ) . remove ( aGuide ) ; } } selectGuideAndFeed ( aMergeGuide ) ; } private void startBackgroundProcesses ( ) { backManager . schedule ( featureManager . getUpdater ( ) , FeatureManager . UPDATE_PERIOD_SEC ) ; backManager . schedule ( tagsSaver , 60 , 10 ) ; if ( System . getProperty ( "noMetaDataUpdates" ) == null ) backManager . schedule ( metaDataUpdater , 60 , 60 ) ; backManager . schedule ( poller , 30 , 10 ) ; setupFeedReselector ( ) ; setupStylesUpdater ( ) ; backManager . scheduleOnce ( new Runnable ( ) { public void run ( ) { searchFeedsManager . runAllQueries ( ) ; } } , 20 ) ; } public MDManager getMetaDataManager ( ) { return metaDataManager ; } public HighlightsCalculator getHighlightsCalculator ( ) { return highlightsCalculator ; } public HighlightsCalculator getSearchHighlightsCalculator ( ) { return searchHighlightsCalculator ; } public ScoresCalculator getScoreCalculator ( ) { return scoresCalculator ; } public void feedHasGone ( DirectFeed feed ) { if ( ! feed . isDynamic ( ) ) { FeedGoneDialog dialog = new FeedGoneDialog ( getMainFrame ( ) , feed ) ; dialog . open ( ) ; if ( ! dialog . hasBeenCanceled ( ) ) { IGuide [ ] guides = feed . getParentGuides ( ) ; for ( IGuide guide : guides ) guide . remove ( feed ) ; } } } public void feedHasMoved ( DirectFeed feed , URL newLocation ) { if ( feed == null ) throw new IllegalArgumentException ( Strings . error ( "unspecified.feed" ) ) ; if ( newLocation == null ) throw new IllegalArgumentException ( Strings . error ( "unspecified.location" ) ) ; DirectFeed existingFeed = getModel ( ) . getGuidesSet ( ) . findDirectFeed ( newLocation ) ; if ( existingFeed != null ) { GuidesSet . replaceFeed ( feed , existingFeed ) ; } else { feed . setXmlURL ( newLocation ) ; } } public void guideMoved ( IGuide guide , int newPosition ) { GuidesPanel cgp = mainFrame . getGudiesPanel ( ) ; cgp . ensureIndexIsVisible ( newPosition ) ; } public void updateFeed ( IFeed aFeed ) { if ( aFeed instanceof DataFeed ) { DataFeed dFeed = ( DataFeed ) aFeed ; poller . update ( dFeed , true , true ) ; } else if ( aFeed instanceof SearchFeed ) { updateSearchFeed ( ( SearchFeed ) aFeed ) ; } } public void forgetDiscoveries ( FeedMetaDataHolder [ ] holders ) { metaDataManager . forget ( holders ) ; repaintArticlesListHighlights ( ) ; } public Poller getPoller ( ) { return poller ; } public void deleteGuides ( IGuide [ ] guides ) { IGuide currentGuide = model . getSelectedGuide ( ) ; GuidesSet set = model . getGuidesSet ( ) ; int removedIndex = - 1 ; for ( IGuide guide : guides ) { if ( guide == currentGuide ) { removedIndex = set . indexOf ( guide ) ; } set . remove ( guide ) ; } if ( removedIndex != - 1 ) selectGuideAndFeed ( findGuideToSelect ( set , removedIndex ) ) ; } static IGuide findGuideToSelect ( GuidesSet guidesSet , int removedIndex ) { IGuide guideToSelect = null ; if ( removedIndex >= 0 ) { GuideDisplayModeManager gdmm = GuideDisplayModeManager . getInstance ( ) ; int count = guidesSet . getGuidesCount ( ) ; for ( int i = removedIndex ; guideToSelect == null && i < count ; i ++ ) { IGuide g = guidesSet . getGuideAt ( i ) ; if ( gdmm . isVisible ( g ) ) guideToSelect = g ; } for ( int i = removedIndex - 1 ; guideToSelect == null && i >= 0 ; i -- ) { IGuide g = guidesSet . getGuideAt ( i ) ; if ( gdmm . isVisible ( g ) ) guideToSelect = g ; } } return guideToSelect ; } public static void updateReadingList ( ReadingList list , List < DirectFeed > addFeeds , List < DirectFeed > removeFeeds ) { if ( list == null ) throw new NullPointerException ( Strings . error ( "unspecified.reading.list" ) ) ; if ( addFeeds == null ) throw new NullPointerException ( Strings . error ( "unspecified.feeds.to.add" ) ) ; if ( removeFeeds == null ) throw new NullPointerException ( Strings . error ( "unspecified.feeds.to.remove" ) ) ; if ( addFeeds . size ( ) == 0 && removeFeeds . size ( ) == 0 ) return ; int action = SINGLETON . getModel ( ) . getUserPreferences ( ) . getOnReadingListUpdateActions ( ) ; boolean doUpdates = list . getParentGuide ( ) != null && ( action != UserPreferences . RL_UPDATE_CONFIRM || confirmReadingListUpdates ( list , addFeeds , removeFeeds ) ) ; if ( doUpdates ) { GuidesSet set = SINGLETON . getModel ( ) . getGuidesSet ( ) ; for ( DirectFeed feed : addFeeds ) { URL xmlURL = feed . getXmlURL ( ) ; DirectFeed existingFeed = set . findDirectFeed ( xmlURL ) ; if ( existingFeed != null ) { feed = existingFeed ; } else { SINGLETON . getPoller ( ) . update ( feed , false ) ; } list . add ( feed ) ; } for ( DirectFeed removeFeed : removeFeeds ) list . remove ( removeFeed ) ; if ( action == UserPreferences . RL_UPDATE_NOTIFY ) { showReadingListUpdateNotification ( list , addFeeds , removeFeeds ) ; } } } private static void showReadingListUpdateNotification ( ReadingList list , List addFeeds , List removeFeeds ) { String msg = MessageFormat . format ( Strings . message ( "readinglist.updates.message" ) , list . getTitle ( ) , list . getParentGuide ( ) . getTitle ( ) , addFeeds . size ( ) , removeFeeds . size ( ) ) ; JOptionPane . showMessageDialog ( SINGLETON . getMainFrame ( ) , msg , Strings . message ( "readinglist.updates.title" ) , JOptionPane . INFORMATION_MESSAGE ) ; } private static boolean confirmReadingListUpdates ( ReadingList list , List < DirectFeed > addFeeds , List < DirectFeed > removeFeeds ) { ReadingListUpdateConfirmationDialog dialog = new ReadingListUpdateConfirmationDialog ( SINGLETON . getMainFrame ( ) , list , addFeeds , removeFeeds ) ; dialog . open ( ) ; boolean confirmed = false ; if ( ! dialog . hasBeenCanceled ( ) ) { List newAddFeeds = dialog . getAddFeeds ( ) ; addFeeds . clear ( ) ; addFeeds . addAll ( newAddFeeds ) ; List newRemoveFeeds = dialog . getRemoveFeeds ( ) ; removeFeeds . clear ( ) ; removeFeeds . addAll ( newRemoveFeeds ) ; confirmed = true ; } return confirmed ; } public static IGuide chooseBestGuide ( IGuide [ ] guides ) { IGuide guide = null ; IGuide currentGuide = GlobalModel . SINGLETON . getSelectedGuide ( ) ; if ( currentGuide != null ) { for ( int i = 0 ; guide == null && i < guides . length ; i ++ ) { IGuide iguide = guides [ i ] ; if ( currentGuide == iguide ) guide = currentGuide ; } } if ( guide == null ) guide = guides [ 0 ] ; return guide ; } private void autosubscribeIfNecessary ( ) { String urlToOpen = ApplicationLauncher . getURLToOpen ( ) ; if ( StringUtils . isNotEmpty ( urlToOpen ) ) { try { subscribe ( new URL ( urlToOpen ) ) ; } catch ( MalformedURLException e ) { LOG . warning ( "Invalid URL specified for subscription." ) ; } } } public void subscribe ( final URL url ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { subscribe ( url , XMLFormatDetector . detectOrAskFormat ( url , getMainFrame ( ) ) ) ; } } ) ; } public void subscribe ( URL url , XMLFormat fmt ) { if ( fmt != null ) { if ( checkForNewSubscription ( ) ) return ; if ( fmt != XMLFormat . OPML ) { DirectFeed feed = createDirectFeed ( null , url ) ; if ( feed != null ) selectFeed ( feed , true ) ; } else { SubscribeToReadingListAction . subscribe ( url ) ; } } else { JOptionPane . showMessageDialog ( getMainFrame ( ) , "<html><b>Unrecognized format of file.</b>\n\n" + "BlogBridge can't recognize the format of the file.\n" + "Please verify that the file is XML feed (RSS, Atom) or\n" + "Reading List (OPML) and try again." , "Subscribe" , JOptionPane . INFORMATION_MESSAGE ) ; } } private class OpenDBinBackground extends Thread { private static final String THREAD_TITLE = "Load used tags" ; private GlobalModel installationModel ; OpenDBinBackground ( GlobalModel aInstallationModel ) { super ( "OpenDBinBackground" ) ; installationModel = aInstallationModel ; setPriority ( Thread . MIN_PRIORITY ) ; } public void run ( ) { if ( LOG . isLoggable ( Level . FINE ) ) LOG . fine ( "Loading persistent state from DB." ) ; ActivityTicket actTicket = ActivityIndicatorView . startOpeningDatabase ( ) ; getMainFrame ( ) . setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; try { model . loadingStarted ( ) ; final GuidesSet guidesSet = getModel ( ) . getGuidesSet ( ) ; IPersistenceManager manager = PersistenceManagerConfig . getManager ( ) ; manager . loadGuidesSet ( guidesSet ) ; ChangesMonitor changesMonitor = new ChangesMonitor ( guidesSet , manager ) ; domainEventsListener . addDomainListener ( changesMonitor ) ; if ( installationModel != null ) { GuidesSet installerSet = installationModel . getGuidesSet ( ) ; int count = installerSet . getGuidesCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { guidesSet . add ( installerSet . getGuideAt ( i ) ) ; } Preferences appPrefs = Application . getUserPreferences ( ) ; installationModel . storePreferences ( appPrefs ) ; restoreModelPreferencesAndUpdate ( model , appPrefs ) ; } if ( manager . isDatabaseReset ( ) ) { DatabaseRecoverer . performRecovery ( model , ApplicationLauncher . getBackupsPath ( ) ) ; } initMaxViewsAndClickthroughs ( guidesSet ) ; startLoadingUsedTags ( guidesSet ) ; if ( dockIconUnreadMonitor != null ) dockIconUnreadMonitor . update ( ) ; model . loadingFinished ( ) ; if ( ! manager . isDatabaseReset ( ) ) { SyncFull syncFull = new SyncFull ( model ) ; if ( syncFull . isSyncTime ( ) ) SyncFullAction . getInstance ( ) . doSync ( null ) ; } model . initTransientState ( ) ; restoreFeedSelection ( ) ; repaintArticlesListHighlights ( ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "exception.during.opening.db.in.background" ) , e ) ; model . loadingFinished ( ) ; } finally { getMainFrame ( ) . setCursor ( Cursor . getDefaultCursor ( ) ) ; ActivityIndicatorView . finishActivity ( actTicket ) ; ApplicationLauncher . enableIPC ( ) ; fireInitializationFinished ( ) ; checkForWarnings ( ) ; startBackgroundProcesses ( ) ; autosubscribeIfNecessary ( ) ; checkForNewVersion ( ) ; } if ( LOG . isLoggable ( Level . FINE ) ) LOG . fine ( "Done loading persistent state from DB." ) ; ServerService . getStartingPointsURL ( ) ; } private void initMaxViewsAndClickthroughs ( GuidesSet set ) { List < IFeed > feeds = set . getFeeds ( ) ; for ( IFeed feed : feeds ) { ScoresCalculator . registerMaxClickthroughs ( feed . getClickthroughs ( ) ) ; ScoresCalculator . registerMaxFeedViews ( feed . getViews ( ) ) ; } } private void checkForNewVersion ( ) { if ( ! ApplicationLauncher . isAutoUpdatesEnabled ( ) ) return ; UserPreferences prefs = model . getUserPreferences ( ) ; boolean checkForUpdateOnStartup = prefs . isCheckingForUpdatesOnStartup ( ) ; if ( checkForUpdateOnStartup ) { ConnectionState connectionState = getConnectionState ( ) ; connectionState . callWhenServiceIsAvailable ( new CheckForNewVersionTask ( ) ) ; } } private void startLoadingUsedTags ( final GuidesSet aGuidesSet ) { Thread loadUsedTagsThread = new Thread ( THREAD_TITLE ) { public void run ( ) { final TagsRepository repository = TagsRepository . getInstance ( ) ; repository . loadFromGuidesSet ( aGuidesSet ) ; UserPreferences prefs = model . getUserPreferences ( ) ; final String user = prefs . getTagsDeliciousUser ( ) ; final String password = prefs . getTagsDeliciousPassword ( ) ; if ( StringUtils . isNotEmpty ( user ) && StringUtils . isNotEmpty ( password ) ) { try { repository . loadTagsFromDelicious ( user , password ) ; } catch ( IOException e ) { LOG . log ( Level . WARNING , Strings . error ( "failed.to.load.used.tags.from.delicious" ) , e ) ; } } } } ; loadUsedTagsThread . start ( ) ; } private class CheckForNewVersionTask implements Runnable { public void run ( ) { MainFrame mainFrame = getMainFrame ( ) ; String currentVersion = ApplicationLauncher . getCurrentVersion ( ) ; FullCheckCycle checker = new FullCheckCycle ( mainFrame , currentVersion , false ) ; try { checker . check ( ) ; } catch ( Throwable e ) { LOG . log ( Level . WARNING , Strings . error ( "failed.to.finish.updates.check" ) , e ) ; } } } } public boolean canSynchronize ( ) { FeatureManager fm = getFeatureManager ( ) ; boolean can = fm . canSynchronize ( ) ; if ( ! can ) { List < String > warnings = new ArrayList < String > ( ) ; warnings . add ( MessageFormat . format ( Strings . message ( "spw.synlimit" ) , fm . getSynchronizationsCount ( false ) , fm . getSynchronizationLimit ( ) ) ) ; showWarningsDialog ( warnings ) ; } return can ; } public boolean checkForNewSubscription ( ) { return checkForWarnings ( false , true , true ) ; } public void checkForWarnings ( ) { checkForWarnings ( true , true , false ) ; } public boolean checkForWarnings ( boolean pubL , boolean subL , boolean eq ) { final List < String > warnings = new ArrayList < String > ( ) ; final FeatureManager fm = getFeatureManager ( ) ; int pubLimit = fm . getPublicationLimit ( ) ; if ( pubL && pubLimit > - 1 ) { int publications = getModel ( ) . getGuidesSet ( ) . countPublishedGuides ( ) ; if ( publications > pubLimit || ( eq && publications == pubLimit ) ) { warnings . add ( MessageFormat . format ( Strings . message ( "spw.publimit" ) , publications , pubLimit ) ) ; } } int subLimit = fm . getSubscriptionLimit ( ) ; if ( subL && subLimit > - 1 ) { int subscriptions = getModel ( ) . getGuidesSet ( ) . getFeedsList ( ) . getFeedsCount ( ) ; if ( subscriptions > subLimit || ( eq && subscriptions == subLimit ) ) { warnings . add ( MessageFormat . format ( Strings . message ( "spw.sublimit" ) , subscriptions , subLimit ) ) ; } } showWarningsDialog ( warnings ) ; return warnings . size ( ) > 0 ; } private void showWarningsDialog ( final List < String > warnings ) { if ( warnings . size ( ) > 0 ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { PlanWarningsDialog dialog = new PlanWarningsDialog ( getMainFrame ( ) ) ; dialog . open ( getFeatureManager ( ) . getPlanName ( ) , warnings ) ; } } ) ; } } private void restoreFeedSelection ( ) { Preferences prefs = Application . getUserPreferences ( ) ; long guideId = prefs . getLong ( KEY_SELECTED_GUIDE_ID , - 1 ) ; GuidesSet set = model . getGuidesSet ( ) ; IGuide guide = null ; if ( guideId != - 1 ) { synchronized ( set ) { int count = set . getGuidesCount ( ) ; for ( int i = 0 ; guide == null && i < count ; i ++ ) { IGuide guideItem = set . getGuideAt ( i ) ; if ( guideItem . getID ( ) == guideId ) guide = guideItem ; } } } if ( guide == null && set . getGuidesCount ( ) > 0 ) guide = set . getGuideAt ( 0 ) ; if ( guide != null ) { long feedId = prefs . getLong ( KEY_SELECTED_FEED_ID , - 1 ) ; IFeed feed = null ; synchronized ( guide ) { int count = guide . getFeedsCount ( ) ; for ( int i = 0 ; feed == null && i < count ; i ++ ) { IFeed feedItem = guide . getFeedAt ( i ) ; if ( feedItem . getID ( ) == feedId ) feed = feedItem ; } } selectGuide ( guide , false ) ; if ( feed != null ) { final IFeed selectionFeed = feed ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { selectFeed ( selectionFeed ) ; } } ) ; } } } private void storeFeedSelection ( ) { Preferences prefs = Application . getUserPreferences ( ) ; IFeed selectedFeed = model . getSelectedFeed ( ) ; IGuide selectedGuide = model . getSelectedGuide ( ) ; long guideId = selectedGuide == null ? - 1 : selectedGuide . getID ( ) ; long feedId = selectedFeed == null ? - 1 : selectedFeed . getID ( ) ; prefs . putLong ( KEY_SELECTED_GUIDE_ID , guideId ) ; prefs . putLong ( KEY_SELECTED_FEED_ID , feedId ) ; } public void restorePersistentState ( GlobalModel aModel ) { registerAppCloseEventListener ( ) ; new OpenDBinBackground ( aModel ) . start ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) LOG . fine ( "Done loading persistent state..." ) ; } private void registerAppCloseEventListener ( ) { Application . addApplicationListener ( new ApplicationAdapter ( ) { public void applicationClosing ( ApplicationEvent evt ) { prepareToClose ( false ) ; System . exit ( 0 ) ; } } ) ; } public void prepareToClose ( boolean emergencyExit ) { backManager . requestExit ( ) ; if ( initializationFinished ) { storeFeedSelection ( ) ; File backupsDir = new File ( ApplicationLauncher . getBackupsPath ( ) ) ; Backups backups = new Backups ( backupsDir , LAST_BACKUPS_TO_KEEP ) ; try { backups . saveBackup ( model . getGuidesSet ( ) ) ; } catch ( IOException e ) { LOG . log ( Level . SEVERE , Strings . error ( "failed.to.write.backup" ) , e ) ; } if ( ! emergencyExit ) syncOutOnExit ( ) ; model . prepareForApplicationExit ( ) ; storePreferences ( ) ; } } private void syncOutOnExit ( ) { if ( ! getConnectionState ( ) . isServiceAccessible ( ) ) return ; SyncOut syncOut = new SyncOut ( model ) ; if ( syncOut . isSyncTime ( ) ) { GuidesSet set = model . getGuidesSet ( ) ; ServicePreferences servicePreferences = model . getServicePreferences ( ) ; int feedsCount = set . countFeeds ( ) ; int lastSyncOutFeedsCount = servicePreferences . getLastSyncOutFeedsCount ( ) ; boolean synchronizedBefore = servicePreferences . getLastSyncOutDate ( ) != null ; boolean doSync = feedsCount > 0 || synchronizedBefore ; if ( doSync && isSuspiciousDifference ( feedsCount , lastSyncOutFeedsCount ) ) { String message ; if ( feedsCount == 0 ) { message = Strings . message ( "synconexit.clear.the.list.of.your.saved.subscriptions" ) ; } else { message = MessageFormat . format ( Strings . message ( "synconexit.make.a.large.change.0.1" ) , lastSyncOutFeedsCount , feedsCount ) ; } int result = JOptionPane . showConfirmDialog ( getMainFrame ( ) , MessageFormat . format ( Strings . message ( "synconexit.suspicious.sync.text.0" ) , message ) , Strings . message ( "synconexit.suspicious.sync.title" ) , JOptionPane . YES_NO_OPTION , JOptionPane . INFORMATION_MESSAGE ) ; doSync = result == JOptionPane . YES_OPTION ; } if ( doSync && canSynchronize ( ) ) syncOut . doSynchronization ( null , false ) ; } } static boolean isSuspiciousDifference ( int aFeedsCount , int aLastSyncOutFeedsCount ) { return ( aFeedsCount == 0 || ( aLastSyncOutFeedsCount > CHANGE_CHECK_FEEDS_THRESHOLD && aLastSyncOutFeedsCount / aFeedsCount > CHANGE_CHECK_DIFF_TIMES ) ) ; } void restorePreferences ( ) { final Preferences prefs = Application . getUserPreferences ( ) ; overridePreferencesWithPlugins ( prefs ) ; DataFeed . setGlobalUpdatePeriod ( UserPreferences . DEFAULT_RSS_POLL_MIN * Constants . MILLIS_IN_MINUTE ) ; DataFeed . setGlobalPurgeUnread ( ! UserPreferences . DEFAULT_PRESERVE_UNREAD ) ; DataFeed . setGlobalPurgeLimit ( UserPreferences . DEFAULT_PURGE_COUNT ) ; UnreadButton . setShowMenuOnClick ( UserPreferences . DEFAULT_SHOW_UNREAD_BUTTON_MENU ) ; restoreModelPreferencesAndUpdate ( model , prefs ) ; } public static void restoreModelPreferencesAndUpdate ( GlobalModel mdl , Preferences prefs ) { mdl . restorePreferences ( prefs ) ; ImageBlocker . restorePreferences ( prefs ) ; SentimentsConfig . restorePreferences ( prefs ) ; setProxySettings ( mdl . getUserPreferences ( ) ) ; GuideDisplayModeManager . getInstance ( ) . restorePreferences ( prefs ) ; FeedDisplayModeManager . getInstance ( ) . restorePreferences ( prefs ) ; NotificationArea . setAppIconAlwaysVisible ( mdl . getUserPreferences ( ) . isShowAppIconInSystray ( ) ) ; PostToBlogAction . update ( ) ; FeedLinkPostToBlogAction . update ( ) ; } private void overridePreferencesWithPlugins ( Preferences prefs ) { List < com . salas . bb . plugins . domain . Package > pkgs = Manager . getEnabledPackages ( ) ; for ( Package pkg : pkgs ) { for ( IPlugin plugin : pkg ) { if ( plugin instanceof AdvancedPreferencesPlugin ) { AdvancedPreferencesPlugin app = ( AdvancedPreferencesPlugin ) plugin ; app . overridePreferences ( prefs ) ; } } } } static void setProxySettings ( UserPreferences prefs ) { Properties sys = System . getProperties ( ) ; if ( prefs . isProxyEnabled ( ) && StringUtils . isNotEmpty ( prefs . getProxyHost ( ) ) ) { String host = prefs . getProxyHost ( ) . trim ( ) ; String port = Integer . toString ( prefs . getProxyPort ( ) ) ; sys . put ( "http.proxyHost" , host ) ; sys . put ( "http.proxyPort" , port ) ; sys . put ( "https.proxyHost" , host ) ; sys . put ( "https.proxyPort" , port ) ; sys . put ( "ftp.proxyHost" , host ) ; sys . put ( "ftp.proxyPort" , port ) ; } else { sys . remove ( "http.proxyHost" ) ; sys . remove ( "http.proxyPort" ) ; sys . remove ( "https.proxyHost" ) ; sys . remove ( "https.proxyPort" ) ; sys . remove ( "ftp.proxyHost" ) ; sys . remove ( "ftp.proxyPort" ) ; } } private void storePreferences ( ) { final Preferences prefs = Application . getUserPreferences ( ) ; mainFrame . prepareToClose ( ) ; model . storePreferences ( prefs ) ; GuideDisplayModeManager . getInstance ( ) . storePreferences ( prefs ) ; FeedDisplayModeManager . getInstance ( ) . storePreferences ( prefs ) ; ImageBlocker . storePreferences ( prefs ) ; SentimentsConfig . storePreferences ( prefs ) ; } public static void exitApplication ( ) { boolean exitConfirmed = true ; int downloads = NetManager . getDownloadsCount ( ) ; if ( downloads > 0 ) { int res = JOptionPane . showConfirmDialog ( SINGLETON . getMainFrame ( ) , Strings . message ( "exit.downloads.running" ) , Strings . message ( "exit" ) , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , Resources . getLargeApplicationIcon ( ) ) ; exitConfirmed = res == JOptionPane . YES_OPTION ; } if ( exitConfirmed ) Application . close ( ) ; } public void setStatus ( String status ) { MainFrame frame = getMainFrame ( ) ; if ( frame != null ) frame . setStatus ( status ) ; } public void moveFeed ( final IFeed feed , final StandardGuide from , final StandardGuide to , int index ) { if ( feed == null || from == null || to == null ) return ; final UserPreferences prefs = getModel ( ) . getUserPreferences ( ) ; if ( from == to && prefs . isSortingEnabled ( ) ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Map names = FeedsSortOrder . SORTING_CLASS_NAMES ; String firstSortOrder = ( String ) names . get ( prefs . getSortByClass1 ( ) ) ; String secondSortOrder = ( String ) names . get ( prefs . getSortByClass2 ( ) ) ; String title = Strings . message ( "move.feed.title" ) ; String msg = MessageFormat . format ( Strings . message ( "move.feeds.no.effect" ) , firstSortOrder , secondSortOrder ) ; JOptionPane . showMessageDialog ( getMainFrame ( ) , msg , title , JOptionPane . INFORMATION_MESSAGE ) ; } } ) ; } from . moveFeed ( feed , to , index ) ; } public void moveGuide ( final IGuide cg , final int insertPosition ) { if ( cg != null ) { GlobalModel . SINGLETON . getGuidesSet ( ) . relocateGuide ( cg , insertPosition ) ; } } public static void pinArticles ( boolean pinned , IGuide guide , IFeed feed , IArticle ... articles ) { if ( articles == null || articles . length == 0 ) return ; int cnt = 0 ; for ( IArticle article : articles ) { if ( article . isPinned ( ) != pinned ) cnt ++ ; article . setPinned ( pinned ) ; } if ( pinned && cnt > 0 ) { IPersistenceManager pm = PersistenceManagerConfig . getManager ( ) ; pm . getStatisticsManager ( ) . articlesPinned ( guide , feed , cnt ) ; } } public static void readArticles ( boolean read , IGuide guide , IFeed feed , IArticle ... articles ) { if ( articles == null || articles . length == 0 ) return ; int cnt = 0 ; for ( IArticle article : articles ) { if ( article . isRead ( ) != read ) cnt ++ ; article . setRead ( read ) ; } if ( read && cnt > 0 ) { IPersistenceManager pm = PersistenceManagerConfig . getManager ( ) ; pm . getStatisticsManager ( ) . articlesRead ( guide , feed , cnt ) ; } } public static void readFeeds ( boolean read , IGuide guide , IFeed ... feeds ) { if ( feeds == null || feeds . length == 0 ) return ; for ( IFeed feed : feeds ) { int cnt = 0 ; synchronized ( feed ) { if ( read ) cnt = feed . getUnreadArticlesCount ( ) ; feed . setRead ( read ) ; } if ( cnt > 0 ) { IPersistenceManager pm = PersistenceManagerConfig . getManager ( ) ; pm . getStatisticsManager ( ) . articlesRead ( guide , feed , cnt ) ; } } } public static void readGuides ( boolean read , IGuide ... guides ) { if ( guides == null || guides . length == 0 ) return ; for ( IGuide guide : guides ) { IFeed [ ] feeds = GlobalModel . SINGLETON . getVisibleFeeds ( guide ) ; readFeeds ( read , guide , feeds ) ; } } public void addDomainListener ( final IDomainListener l ) { domainEventsListener . addDomainListener ( l ) ; } public void removeDomainListener ( IDomainListener l ) { domainEventsListener . removeDomainListener ( l ) ; } public void addControllerListener ( final IControllerListener l ) { listeners . add ( l ) ; } public void removeControllerListener ( final IControllerListener l ) { listeners . remove ( l ) ; } public void fireArticleSelected ( IArticle article ) { for ( IControllerListener listener : listeners ) { try { listener . articleSelected ( article ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "unhandled.exception" ) , e ) ; } } } public void fireFeedSelected ( final IFeed feed ) { for ( IControllerListener listener : listeners ) { try { listener . feedSelected ( feed ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "unhandled.exception" ) , e ) ; } } } public void fireGuideSelected ( final IGuide guide ) { for ( IControllerListener listener : listeners ) { try { listener . guideSelected ( guide ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "unhandled.exception" ) , e ) ; } } } public void fireInitializationFinished ( ) { this . initializationFinished = true ; for ( IControllerListener listener : listeners ) { try { listener . initializationFinished ( ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "unhandled.exception" ) , e ) ; } } } public boolean isInitializationFinished ( ) { return initializationFinished ; } public StandardGuide createStandardGuide ( String title , String iconKey , boolean autoFeedDiscovery ) { StandardGuide cg = new StandardGuide ( ) ; cg . setTitle ( title ) ; cg . setIconKey ( iconKey ) ; cg . setAutoFeedsDiscovery ( autoFeedDiscovery ) ; final GuidesSet guidesSet = getModel ( ) . getGuidesSet ( ) ; IGuide selectedGuide = getModel ( ) . getSelectedGuide ( ) ; guidesSet . add ( selectedGuide == null ? - 1 : guidesSet . indexOf ( selectedGuide ) , cg ) ; return cg ; } public DirectFeed createDirectFeed ( String url , boolean forceQuery ) { DirectFeed feed = null ; IGuide guide = model . getSelectedGuide ( ) ; if ( guide == null || guide instanceof StandardGuide ) { if ( url == null || forceQuery ) { ValueHolder urlHolder = new ValueHolder ( url ) ; AddDirectFeedDialog dialog = new AddDirectFeedDialog ( getMainFrame ( ) , urlHolder ) ; dialog . open ( ) ; url = dialog . hasBeenCanceled ( ) ? null : ( String ) urlHolder . getValue ( ) ; } Set < String > urls = parseMultiURL ( url ) ; DirectFeed [ ] feeds = createDirectFeeds ( urls , ( StandardGuide ) guide ) ; if ( feeds . length > 0 ) feed = feeds [ 0 ] ; } return feed ; } static Set < String > parseMultiURL ( String multiURL ) { Set < String > urls = new HashSet < String > ( ) ; if ( multiURL != null ) { StringTokenizer st = new StringTokenizer ( multiURL , Constants . URL_SEPARATOR ) ; while ( st . hasMoreTokens ( ) ) urls . add ( StringUtils . fixURL ( st . nextToken ( ) ) ) ; } return urls ; } public DirectFeed [ ] createDirectFeeds ( Set < String > urls , StandardGuide guide ) { DirectFeed [ ] feeds ; if ( urls == null ) { feeds = new DirectFeed [ 0 ] ; } else { int count = urls . size ( ) ; feeds = new DirectFeed [ count ] ; int i = 0 ; for ( String url : urls ) { try { feeds [ i ++ ] = createDirectFeed ( guide , StringUtils . fixURL ( url ) ) ; } catch ( MalformedURLException e ) { JOptionPane . showMessageDialog ( getMainFrame ( ) , Strings . message ( "invalid.url.message" ) , Strings . message ( "invalid.url" ) , JOptionPane . WARNING_MESSAGE ) ; LOG . warning ( MessageFormat . format ( Strings . error ( "invalid.url" ) , url ) ) ; } } } return feeds ; } public DirectFeed createDirectFeed ( IGuide guide , String reference ) throws MalformedURLException { return createDirectFeed ( guide , new URL ( reference ) ) ; } public DirectFeed createDirectFeed ( IGuide guide , URL aUrl ) { if ( aUrl == null ) return null ; String reference = aUrl . toString ( ) ; if ( guide == null ) guide = chooseOrMakeGuideForNewFeed ( ) ; DirectFeed feed ; boolean proceed = true ; boolean existing = false ; DirectFeed otherFeed = model . getGuidesSet ( ) . getFeedsList ( ) . findDirectFeed ( aUrl , true ) ; if ( otherFeed != null && otherFeed . isInitialized ( ) ) { feed = otherFeed ; if ( guide . indexOf ( feed ) == - 1 ) guide . add ( feed ) ; return feed ; } else { feed = new DirectFeed ( ) ; feed . setBaseTitle ( reference ) ; FeedMetaDataHolder metaData = metaDataManager . lookupOrDiscover ( aUrl ) ; feed . setMetaData ( metaData ) ; if ( metaData . isComplete ( ) || metaData . isDiscoveredInvalid ( ) ) { if ( metaData . isDiscoveredInvalid ( ) ) { proceed = ! processInvalidDiscovery ( metaData , feed , aUrl ) ; } if ( metaData . isDiscoveredValid ( ) ) { URL xmlURL = metaData . getXmlURL ( ) ; GuidesSet set = getModel ( ) . getGuidesSet ( ) ; DirectFeed existingFeed = set . findDirectFeed ( xmlURL ) ; if ( existingFeed != null ) { feed = existingFeed ; existing = true ; } else feed . setXmlURL ( xmlURL ) ; } if ( proceed && ! existing ) repaintArticlesListHighlights ( ) ; } } if ( proceed ) guide . add ( feed ) ; if ( ! existing ) { if ( proceed ) { poller . update ( feed , true , true ) ; } else feed = null ; } else checkForDuplicates ( feed ) ; return feed ; } private void checkForDuplicates ( DirectFeed aFeed ) { IGuide [ ] allGuides = aFeed . getParentGuides ( ) ; if ( allGuides . length > 1 ) { ShowDuplicateFeeds dialog = new ShowDuplicateFeeds ( mainFrame , aFeed ) ; dialog . open ( ) ; IGuide [ ] removals = dialog . getRemovals ( ) ; if ( removals != null ) { for ( IGuide removal : removals ) removal . remove ( aFeed ) ; } } } static String findBestTitle ( NetworkFeed [ ] feeds ) { String title = null ; for ( NetworkFeed nfeed : feeds ) { String ntitle = nfeed . getTitle ( ) ; if ( title == null || ( ntitle != null && ! ntitle . matches ( "^[^:]{3,5}://.+" ) ) ) { title = ntitle ; } } return title ; } public QueryFeed createQueryFeed ( StandardGuide guide , String title , int queryType , String parameter , int purgeLimit ) { if ( guide == null ) guide = chooseOrMakeGuideForNewFeed ( ) ; GuidesSet set = getModel ( ) . getGuidesSet ( ) ; QueryType type = QueryType . getQueryType ( queryType ) ; QueryFeed queryFeed = set . findQueryFeed ( type , parameter ) ; if ( queryFeed == null ) { queryFeed = new QueryFeed ( ) ; queryFeed . setBaseTitle ( title ) ; queryFeed . setQueryType ( type ) ; queryFeed . setParameter ( parameter ) ; queryFeed . setPurgeLimit ( purgeLimit ) ; } else { } guide . add ( queryFeed ) ; poller . update ( queryFeed , true , true ) ; return queryFeed ; } public SearchFeed createSearchFeed ( StandardGuide aGuide , String aTitle , Query aSearchQuery , int aPurgeLimit ) { if ( aGuide == null ) aGuide = chooseOrMakeGuideForNewFeed ( ) ; GuidesSet set = getModel ( ) . getGuidesSet ( ) ; SearchFeed searchFeed = set . findSearchFeed ( aSearchQuery ) ; if ( searchFeed == null ) { searchFeed = new SearchFeed ( ) ; searchFeed . setBaseTitle ( aTitle ) ; searchFeed . setArticlesLimit ( aPurgeLimit ) ; searchFeed . setQuery ( aSearchQuery ) ; } else { } aGuide . add ( searchFeed ) ; return searchFeed ; } public void updateSearchFeed ( final SearchFeed sfeed ) { if ( sfeed == null ) return ; new Thread ( THREAD_NAME_SEARCH_QUERY ) { public void run ( ) { searchFeedsManager . runQuery ( sfeed ) ; } } . start ( ) ; } private StandardGuide chooseOrMakeGuideForNewFeed ( ) { IGuide guide = model . getSelectedGuide ( ) ; if ( guide == null ) { GuidesSet guidesSet = getModel ( ) . getGuidesSet ( ) ; if ( guidesSet . getGuidesCount ( ) == 0 ) { guide = createStandardGuide ( AUTO_GUIDE_TITLE , null , false ) ; if ( guide == null ) LOG . severe ( Strings . error ( "failed.to.automatically.create.a.new.guide" ) ) ; } else { guide = guidesSet . getGuideAt ( 0 ) ; } } if ( guide == null ) throw new RuntimeException ( Strings . error ( "failed.to.create.new.guide" ) ) ; return ( StandardGuide ) guide ; } public void repaintArticlesListHighlights ( ) { MainFrame frame = getMainFrame ( ) ; if ( frame != null ) frame . repaintArticlesListHighlights ( ) ; } public DirectFeed addDirectFeed ( StandardGuide guide , URL dataUrl , ReadingList aList ) { if ( dataUrl == null ) throw new NullPointerException ( Strings . error ( "unspecified.data.url" ) ) ; DirectFeed feed = getModel ( ) . getGuidesSet ( ) . findDirectFeed ( dataUrl ) ; if ( feed == null ) { feed = new DirectFeed ( ) ; feed . setXmlURL ( dataUrl ) ; } if ( aList != null ) aList . add ( feed ) ; else guide . add ( feed ) ; return feed ; } public void updateIfDiscovered ( DirectFeed feed ) { FeedMetaDataHolder md = feed . getMetaDataHolder ( ) ; if ( md != null && md . isDiscoveredValid ( ) ) { poller . update ( feed , false ) ; } } public void deleteNonPersistentFeed ( IFeed feed ) { IGuide [ ] guides = feed . getParentGuides ( ) ; if ( guides . length != 0 ) { if ( feed instanceof DirectFeed ) ( ( DirectFeed ) feed ) . setMetaData ( null ) ; for ( IGuide guide : guides ) guide . remove ( feed ) ; } } public FeedMetaDataHolder discoverLinkFromArticle ( URL url ) { return metaDataManager . lookup ( url ) ; } public FeedMetaDataHolder discover ( URL link ) { return metaDataManager . lookupOrDiscover ( link ) ; } public void discoverFeedsIn ( IGuide guide ) { IFeed [ ] feeds = guide . getFeeds ( ) ; for ( IFeed feed : feeds ) discoverFeedsIn ( feed ) ; } public void discoverFeedsIn ( IFeed feed ) { if ( feed == null ) return ; IArticle [ ] articles = feed . getArticles ( ) ; for ( IArticle article : articles ) discoverFeedsIn ( article , feed ) ; } public static String prepareRequestedByFromFeed ( IFeed feed ) { StringBuffer buf = new StringBuffer ( ) ; IGuide [ ] guides = feed . getParentGuides ( ) ; if ( guides . length > 0 ) buf . append ( GuidesUtils . getGuidesNames ( guides ) ) . append ( " / " ) ; buf . append ( feed . getTitle ( ) ) ; return buf . toString ( ) ; } public void discoverFeedsIn ( IArticle article , IFeed feed ) { String requestedBy = prepareRequestedByFromFeed ( feed ) ; URL baseUrl = article . getLink ( ) ; if ( baseUrl == null && feed instanceof DirectFeed ) baseUrl = ( ( DirectFeed ) feed ) . getXmlURL ( ) ; Collection < String > links = article . getLinks ( ) ; if ( links == null ) return ; for ( String link : links ) { try { FeedMetaDataHolder cmd = discover ( new URL ( baseUrl , link ) ) ; if ( cmd . getRequestedBy ( ) == null ) cmd . setRequestedBy ( requestedBy ) ; } catch ( MalformedURLException e ) { } } } private boolean processInvalidDiscovery ( FeedMetaDataHolder holder , final DirectFeed feed , URL originalURL ) { feed . setInvalidnessReason ( Strings . message ( "feed.invalidness.reason.undiscovered" ) ) ; boolean processingDone = false ; if ( feed . getReadingLists ( ) . length > 0 ) return processingDone ; InvalidDiscoveryDialog dialog = createDialog ( ) ; dialog . setTitle ( Strings . message ( "subscription.error.dialog.title" ) ) ; URL newDiscoveryUrl = originalURL ; String suggestedUrl = null ; boolean localReference = MDDiscoveryRequest . isLocalURL ( originalURL ) ; boolean inputAccepted = false ; while ( ! inputAccepted ) { GlobalController . IDDResult res = openDialog ( dialog , newDiscoveryUrl , suggestedUrl , localReference ) ; int option = res . option ; inputAccepted = true ; if ( ! res . hasBeenCanceled ) { newDiscoveryUrl = res . newDiscoveryURL ; suggestedUrl = res . newSuggestionURL ; if ( option == InvalidDiscoveryDialog . OPTION_NEW_DISCOVERY ) { inputAccepted = false ; if ( newDiscoveryUrl != null ) { processingDone = true ; inputAccepted = true ; IGuide [ ] guides = feed . getParentGuides ( ) ; deleteNonPersistentFeed ( feed ) ; if ( guides != null && guides . length > 0 ) { DirectFeed newFeed = null ; for ( IGuide guide : guides ) { if ( newFeed == null ) { newFeed = createDirectFeed ( guide , newDiscoveryUrl ) ; } else { guide . add ( newFeed ) ; } } } else { createDirectFeed ( getModel ( ) . getSelectedGuide ( ) , newDiscoveryUrl ) ; } } } else if ( option == InvalidDiscoveryDialog . OPTION_SUGGEST_URL ) { try { URL url = new URL ( StringUtils . fixURL ( suggestedUrl ) ) ; DirectDiscoverer dd = new DirectDiscoverer ( ) ; DiscoveryResult result = dd . discover ( url ) ; if ( result != null ) { ServerService . metaSuggestFeedUrl ( originalURL . toString ( ) , suggestedUrl ) ; holder . setXmlURL ( url ) ; holder . setInvalid ( false ) ; processingDone = false ; } else { inputAccepted = false ; } } catch ( MalformedURLException e ) { inputAccepted = false ; } catch ( UrlDiscovererException e ) { inputAccepted = false ; } } else if ( option == InvalidDiscoveryDialog . OPTION_CANCEL ) { processingDone = true ; deleteNonPersistentFeed ( feed ) ; } } } return processingDone ; } private static class IDDResult { private int option ; private boolean hasBeenCanceled ; private URL newDiscoveryURL ; private String newSuggestionURL ; } private static IDDResult openDialog ( final InvalidDiscoveryDialog dialog , final URL newDiscoveryUrl , final String suggestedUrl , final boolean localReference ) { final IDDResult result = new IDDResult ( ) ; Runnable task = new Runnable ( ) { public void run ( ) { result . option = dialog . open ( newDiscoveryUrl , suggestedUrl , ! localReference ) ; result . hasBeenCanceled = dialog . hasBeenCanceled ( ) ; result . newDiscoveryURL = dialog . getNewDiscoveryUrl ( ) ; result . newSuggestionURL = dialog . getSuggestedFeedUrl ( ) ; } } ; UifUtilities . invokeAndWait ( task , "Failed to open dialog." , Level . SEVERE ) ; return result ; } private InvalidDiscoveryDialog createDialog ( ) { final ValueHolder vh = new ValueHolder ( ) ; Runnable task = new Runnable ( ) { public void run ( ) { InvalidDiscoveryDialog dialog = new InvalidDiscoveryDialog ( getMainFrame ( ) ) ; synchronized ( vh ) { vh . setValue ( dialog ) ; } } } ; UifUtilities . invokeAndWait ( task , "Failed to create invalid discovery dialog." , Level . SEVERE ) ; return ( InvalidDiscoveryDialog ) vh . getValue ( ) ; } public void setHoveredHyperLink ( URL link ) { if ( hoveredLink != link ) { hoveredLink = link ; setStatus ( link == null ? "" : link . toString ( ) ) ; } } public URL getHoveredHyperLink ( ) { return hoveredLink ; } public NetworkFeed getFeedByHoveredHyperLink ( ) { final URL url = getHoveredHyperLink ( ) ; NetworkFeed feed = null ; if ( url != null ) { FeedMetaDataHolder metaData = discoverLinkFromArticle ( url ) ; if ( metaData != null ) { URL xmlURL = metaData . getXmlURL ( ) ; feed = getModel ( ) . getGuidesSet ( ) . findDirectFeed ( xmlURL ) ; } } return feed ; } public IGuide [ ] getSelectedGuides ( ) { GuidesList guidesList = getMainFrame ( ) . getGudiesPanel ( ) . getGuidesList ( ) ; Object [ ] guidesO = guidesList . getSelectedValues ( ) ; IGuide [ ] guides = new IGuide [ guidesO . length ] ; for ( int i = 0 ; i < guidesO . length ; i ++ ) { guides [ i ] = ( IGuide ) guidesO [ i ] ; } return guides ; } public IFeed [ ] getSelectedFeeds ( ) { JList feedsList = getMainFrame ( ) . getFeedsPanel ( ) . getFeedsList ( ) ; Object [ ] feedsO = feedsList . getSelectedValues ( ) ; IFeed [ ] feeds = new IFeed [ feedsO . length ] ; for ( int i = 0 ; i < feedsO . length ; i ++ ) { feeds [ i ] = ( IFeed ) feedsO [ i ] ; } return feeds ; } public void showNewPublishingDialog ( ) { UserPreferences prefs = model . getUserPreferences ( ) ; if ( prefs . isShowingNewPubAlert ( ) ) { NewPublicationDialog newPublicationDialog = new NewPublicationDialog ( getMainFrame ( ) ) ; newPublicationDialog . open ( ) ; prefs . setShowingNewPubAlert ( ! newPublicationDialog . isDoNotShowAgain ( ) ) ; if ( ! newPublicationDialog . hasBeenCanceled ( ) ) { SyncFullAction . getInstance ( ) . actionPerformed ( null ) ; } } } private class NavigatorAdapter implements IArticleListNavigationListener { public void nextFeed ( int mode ) { NavigatorAdv . NavigationInfoKey key ; switch ( mode ) { case INavigationModes . MODE_NORMAL : key = NavigatorAdv . NavigationInfoKey . NEXT ; break ; case INavigationModes . MODE_UNREAD : key = NavigatorAdv . NavigationInfoKey . NEXT_UNREAD ; break ; default : key = null ; break ; } if ( key == null ) { LOG . severe ( MessageFormat . format ( Strings . error ( "invalid.next.mode" ) , mode ) ) ; } else { NavigatorAdv . Destination dest = navigator . getDestination ( key ) ; selectDestination ( dest , true , mode ) ; } } public void prevFeed ( int mode ) { NavigatorAdv . NavigationInfoKey key ; switch ( mode ) { case INavigationModes . MODE_NORMAL : key = NavigatorAdv . NavigationInfoKey . PREV ; break ; case INavigationModes . MODE_UNREAD : key = NavigatorAdv . NavigationInfoKey . PREV_UNREAD ; break ; default : key = null ; break ; } if ( key == null ) { LOG . severe ( MessageFormat . format ( Strings . error ( "invalid.prev.mode" ) , mode ) ) ; } else { NavigatorAdv . Destination dest = navigator . getDestination ( key ) ; selectDestination ( dest , false , mode ) ; } } private void selectDestination ( final NavigatorAdv . Destination dest , final boolean next , final int mode ) { if ( dest == null ) { if ( getModel ( ) . getUserPreferences ( ) . isSoundOnNoUnread ( ) ) Sound . play ( "sound.no.unread" ) ; return ; } final IGuide guide = dest . guide ; final IFeed feed = dest . feed ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Next: Guide=" + guide . getTitle ( ) + " Feed=" + feed . getTitle ( ) ) ; } Runnable task = new Runnable ( ) { public void run ( ) { selectGuide ( guide , false ) ; selectFeed ( feed ) ; final MainFrame frame = getMainFrame ( ) ; final IFeedDisplay feedDisplay = frame . getArticlesListPanel ( ) . getFeedView ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( next ) { feedDisplay . selectFirstArticle ( mode ) ; } else { feedDisplay . selectLastArticle ( mode ) ; } } } ) ; } } ; if ( UifUtilities . isEDT ( ) ) task . run ( ) ; else SwingUtilities . invokeLater ( task ) ; } } private class DiscoveryListener implements IDiscoveryListener { private static final int MAX_CHARS_IN_TOOLTIP_REFERENCE = 40 ; private Map < URL , ActivityTicket > wrapperToTicket = new IdentityHashMap < URL , ActivityTicket > ( ) ; public void discoveryStarted ( URL url ) { String urlString = url . toString ( ) ; if ( urlString . length ( ) > MAX_CHARS_IN_TOOLTIP_REFERENCE ) { urlString = urlString . substring ( 0 , MAX_CHARS_IN_TOOLTIP_REFERENCE ) + "" ; } wrapperToTicket . put ( url , ActivityIndicatorView . startDiscovery ( urlString ) ) ; } public void discoveryFinished ( URL url , boolean complete ) { finishDiscoveryIndication ( url ) ; if ( ! complete ) return ; FeedMetaDataHolder holder = metaDataManager . lookup ( url ) ; DirectFeed [ ] feeds = findFeedsWatchingMetaData ( holder ) ; if ( feeds . length > 0 ) { URL xmlUrl = holder . getXmlURL ( ) ; DirectFeed existingFeed = xmlUrl == null ? null : getModel ( ) . getGuidesSet ( ) . findDirectFeed ( xmlUrl ) ; for ( DirectFeed feed : feeds ) { boolean proceed = true ; boolean existing = false ; if ( ( existingFeed == null || existingFeed == feed ) && feed . isInitialized ( ) ) { existingFeed = feed ; continue ; } if ( holder . isDiscoveredInvalid ( ) && ! feed . isInitialized ( ) ) { proceed = ! processInvalidDiscovery ( holder , feed , url ) ; } if ( holder . isDiscoveredValid ( ) ) { if ( existingFeed != null ) { if ( existingFeed != feed ) { IFeed selectedFeed = getModel ( ) . getSelectedFeed ( ) ; boolean thisFeedSelected = feed == selectedFeed ; GuidesSet . replaceFeed ( feed , existingFeed ) ; if ( thisFeedSelected ) { final IFeed selectFeed = existingFeed ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { selectFeed ( selectFeed ) ; } } ) ; } existing = true ; } } else { existingFeed = feed ; feed . setXmlURL ( xmlUrl ) ; } } if ( existing && ! feed . isInitialized ( ) ) checkForDuplicates ( feed ) ; if ( ! existing && proceed ) updateIfDiscovered ( feed ) ; } } if ( holder . isDiscoveredValid ( ) ) repaintArticlesListHighlights ( ) ; } private DirectFeed [ ] findFeedsWatchingMetaData ( FeedMetaDataHolder aHolder ) { List < DirectFeed > watchers = new ArrayList < DirectFeed > ( ) ; List < IFeed > feeds = model . getGuidesSet ( ) . getFeeds ( ) ; for ( IFeed feed : feeds ) { if ( feed instanceof DirectFeed ) { DirectFeed dfeed = ( DirectFeed ) feed ; if ( dfeed . getMetaDataHolder ( ) == aHolder ) watchers . add ( dfeed ) ; } } return watchers . toArray ( new DirectFeed [ watchers . size ( ) ] ) ; } public void discoveryFailed ( URL url ) { finishDiscoveryIndication ( url ) ; } private void finishDiscoveryIndication ( URL url ) { final ActivityTicket ticket = wrapperToTicket . get ( url ) ; if ( ticket != null ) { ActivityIndicatorView . finishActivity ( ticket ) ; wrapperToTicket . remove ( url ) ; } } } private class SelectedFeedListener extends FeedAdapter { public void articleAdded ( IFeed feed , IArticle article ) { for ( IControllerListener listener : listeners ) { try { listener . articleAdded ( article , feed ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "unhandled.exception" ) , e ) ; } } } public void articleRemoved ( IFeed feed , IArticle article ) { for ( IControllerListener listener : listeners ) { try { listener . articleRemoved ( article , feed ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "unhandled.exception" ) , e ) ; } } } public void propertyChanged ( final IFeed feed , String property , Object oldValue , Object newValue ) { if ( IFeed . PROP_TITLE . equals ( property ) ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { getMainFrame ( ) . updateTitle ( feed ) ; } } ) ; } else if ( SearchFeed . PROP_QUERY . equals ( property ) && model . getSelectedFeed ( ) == feed ) { if ( updateSearchHighlights ( feed , feed ) ) repaintArticlesListHighlights ( ) ; } } } private class BBServiceCredentialCallback implements ICredentialsCallback { public String getUserName ( ) { String userName = null ; if ( model != null ) { userName = model . getServicePreferences ( ) . getEmail ( ) ; if ( StringUtils . isEmpty ( userName ) ) userName = null ; } return userName ; } public String getUserPassword ( ) { String password = null ; if ( model != null ) { password = model . getServicePreferences ( ) . getPassword ( ) ; if ( StringUtils . isEmpty ( password ) ) password = null ; } return password ; } } private class UserPreferencesCallback implements ICredentialsCallback { public String getUserName ( ) { String userName = null ; if ( model != null ) { userName = model . getUserPreferences ( ) . getTagsDeliciousUser ( ) ; if ( StringUtils . isEmpty ( userName ) ) userName = null ; } return userName ; } public String getUserPassword ( ) { String password = null ; if ( model != null ) { password = model . getUserPreferences ( ) . getTagsDeliciousPassword ( ) ; if ( StringUtils . isEmpty ( password ) ) password = null ; } return password ; } } private class SelectGuideTask implements Runnable { private final IGuide guide ; private final boolean selectFeed ; private final boolean alreadySelected ; public SelectGuideTask ( IGuide aGuide , boolean aSelectFeed , boolean aAlreadySelected ) { guide = aGuide ; selectFeed = aSelectFeed ; alreadySelected = aAlreadySelected ; } public void run ( ) { if ( ! alreadySelected ) model . setSelectedGuide ( guide ) ; fireGuideSelected ( guide ) ; if ( ! alreadySelected ) { IFeed feed = null ; int gsm = model . getUserPreferences ( ) . getGuideSelectionMode ( ) ; if ( selectFeed && gsm != UserPreferences . GSM_NO_FEED ) { feed = gsm == UserPreferences . GSM_FIRST_FEED ? model . getGuideModel ( ) . getSize ( ) == 0 ? null : ( IFeed ) model . getGuideModel ( ) . getElementAt ( 0 ) : model . getSelectedFeed ( ) ; } selectFeed ( feed ) ; } PersistenceManagerConfig . getManager ( ) . getStatisticsManager ( ) . guideVisited ( guide ) ; } } } 