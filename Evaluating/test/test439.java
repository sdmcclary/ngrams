<<<<<<< HEAD
public class ForkJoinWorkerThread extends Thread { private static final int INITIAL_QUEUE_CAPACITY = 1 << 13 ; private static final int MAXIMUM_QUEUE_CAPACITY = 1 << 28 ; final ForkJoinPool pool ; private ForkJoinTask < ? > [ ] queue ; private volatile int sp ; private volatile int base ; private boolean active ; private volatile int runState ; private int seed ; private int stealCount ; int poolIndex ; long lastEventCount ; protected ForkJoinWorkerThread ( ForkJoinPool pool ) { if ( pool == null ) throw new NullPointerException ( ) ; this . pool = pool ; } public ForkJoinPool getPool ( ) { return pool ; } public int getPoolIndex ( ) { return poolIndex ; } private static final int RUNNING = 0 ; private static final int SHUTDOWN = 1 ; private static final int TERMINATING = 2 ; private static final int TERMINATED = 3 ; final boolean isShutdown ( ) { return runState >= SHUTDOWN ; } final boolean isTerminating ( ) { return runState >= TERMINATING ; } final boolean isTerminated ( ) { return runState == TERMINATED ; } final boolean shutdown ( ) { return transitionRunStateTo ( SHUTDOWN ) ; } final boolean shutdownNow ( ) { return transitionRunStateTo ( TERMINATING ) ; } private boolean transitionRunStateTo ( int state ) { for ( ; ; ) { int s = runState ; if ( s >= state ) return false ; if ( _unsafe . compareAndSwapInt ( this , runStateOffset , s , state ) ) return true ; } } private boolean tryActivate ( ) { if ( ! active ) { if ( ! pool . tryIncrementActiveCount ( ) ) return false ; active = true ; } return true ; } private boolean tryInactivate ( ) { if ( active ) { if ( ! pool . tryDecrementActiveCount ( ) ) return false ; active = false ; } return true ; } private static int xorShift ( int r ) { r ^= r << 1 ; r ^= r > > > 3 ; r ^= r << 10 ; return r ; } public void run ( ) { Throwable exception = null ; try { onStart ( ) ; pool . sync ( this ) ; mainLoop ( ) ; } catch ( Throwable ex ) { exception = ex ; } finally { onTermination ( exception ) ; } } private void mainLoop ( ) { while ( ! isShutdown ( ) ) { ForkJoinTask < ? > t = pollTask ( ) ; if ( t != null || ( t = pollSubmission ( ) ) != null ) t . quietlyExec ( ) ; else if ( tryInactivate ( ) ) pool . sync ( this ) ; } } protected void onStart ( ) { queue = new ForkJoinTask < ? > [ INITIAL_QUEUE_CAPACITY ] ; int p = poolIndex + 1 ; seed = p + ( p << 8 ) + ( p << 16 ) + ( p << 24 ) ; } protected void onTermination ( Throwable exception ) { while ( exception == null && ! pool . isTerminating ( ) && base != sp ) { try { ForkJoinTask < ? > t = popTask ( ) ; if ( t != null ) t . quietlyExec ( ) ; } catch ( Throwable ex ) { exception = ex ; } } try { do ; while ( ! tryInactivate ( ) ) ; cancelTasks ( ) ; runState = TERMINATED ; pool . workerTerminated ( this ) ; } catch ( Throwable ex ) { if ( exception == null ) exception = ex ; } finally { if ( exception != null ) ForkJoinTask . rethrowException ( exception ) ; } } private static void setSlot ( ForkJoinTask < ? > [ ] q , int i , ForkJoinTask < ? > t ) { _unsafe . putOrderedObject ( q , ( i << qShift ) + qBase , t ) ; } private static boolean casSlotNull ( ForkJoinTask < ? > [ ] q , int i , ForkJoinTask < ? > t ) { return _unsafe . compareAndSwapObject ( q , ( i << qShift ) + qBase , t , null ) ; } private void storeSp ( int s ) { _unsafe . putOrderedInt ( this , spOffset , s ) ; } final void pushTask ( ForkJoinTask < ? > t ) { ForkJoinTask < ? > [ ] q = queue ; int mask = q . length - 1 ; int s = sp ; setSlot ( q , s & mask , t ) ; storeSp ( ++ s ) ; if ( ( s -= base ) == 1 ) pool . signalWork ( ) ; else if ( s >= mask ) growQueue ( ) ; } private ForkJoinTask < ? > deqTask ( ) { ForkJoinTask < ? > t ; ForkJoinTask < ? > [ ] q ; int i ; int b ; if ( sp != ( b = base ) && ( q = queue ) != null && ( t = q [ i = ( q . length - 1 ) & b ] ) != null && casSlotNull ( q , i , t ) ) { base = b + 1 ; return t ; } return null ; } final ForkJoinTask < ? > popTask ( ) { int s = sp ; while ( s != base ) { if ( tryActivate ( ) ) { ForkJoinTask < ? > [ ] q = queue ; int mask = q . length - 1 ; int i = ( s - 1 ) & mask ; ForkJoinTask < ? > t = q [ i ] ; if ( t == null || ! casSlotNull ( q , i , t ) ) break ; storeSp ( s - 1 ) ; return t ; } } return null ; } final boolean unpushTask ( ForkJoinTask < ? > t ) { ForkJoinTask < ? > [ ] q = queue ; int mask = q . length - 1 ; int s = sp - 1 ; if ( casSlotNull ( q , s & mask , t ) ) { storeSp ( s ) ; return true ; } return false ; } final ForkJoinTask < ? > peekTask ( ) { ForkJoinTask < ? > [ ] q = queue ; return q == null ? null : q [ ( sp - 1 ) & ( q . length - 1 ) ] ; } private void growQueue ( ) { ForkJoinTask < ? > [ ] oldQ = queue ; int oldSize = oldQ . length ; int newSize = oldSize << 1 ; if ( newSize > MAXIMUM_QUEUE_CAPACITY ) throw new RejectedExecutionException ( "Queue capacity exceeded" ) ; ForkJoinTask < ? > [ ] newQ = queue = new ForkJoinTask < ? > [ newSize ] ; int b = base ; int bf = b + oldSize ; int oldMask = oldSize - 1 ; int newMask = newSize - 1 ; do { int oldIndex = b & oldMask ; ForkJoinTask < ? > t = oldQ [ oldIndex ] ; if ( t != null && ! casSlotNull ( oldQ , oldIndex , t ) ) t = null ; setSlot ( newQ , b & newMask , t ) ; } while ( ++ b != bf ) ; pool . signalWork ( ) ; } private ForkJoinTask < ? > scan ( ) { ForkJoinTask < ? > t = null ; int r = seed ; ForkJoinWorkerThread [ ] ws ; int mask ; outer : do { if ( ( ws = pool . workers ) != null && ( mask = ws . length - 1 ) > 0 ) { int idx = r ; int probes = ~ mask ; for ( ; ; ) { r = xorShift ( r ) ; ForkJoinWorkerThread v = ws [ mask & idx ] ; if ( v == null || v . sp == v . base ) { if ( probes <= mask ) idx = ( probes ++ < 0 ) ? r : ( idx + 1 ) ; else break ; } else if ( ! tryActivate ( ) || ( t = v . deqTask ( ) ) == null ) continue outer ; else break outer ; } } } while ( pool . hasNewSyncEvent ( this ) ) ; seed = r ; return t ; } final ForkJoinTask < ? > pollTask ( ) { ForkJoinTask < ? > t = popTask ( ) ; if ( t == null && ( t = scan ( ) ) != null ) ++ stealCount ; return t ; } private ForkJoinTask < ? > pollSubmission ( ) { ForkJoinPool p = pool ; while ( p . hasQueuedSubmissions ( ) ) { ForkJoinTask < ? > t ; if ( tryActivate ( ) && ( t = p . pollSubmission ( ) ) != null ) return t ; } return null ; } final void cancelTasks ( ) { ForkJoinTask < ? > t ; while ( base != sp && ( t = deqTask ( ) ) != null ) t . cancelIgnoringExceptions ( ) ; } final int getAndClearStealCount ( ) { int sc = stealCount ; stealCount = 0 ; return sc ; } static boolean hasQueuedTasks ( ForkJoinWorkerThread [ ] ws ) { if ( ws != null ) { int len = ws . length ; for ( int j = 0 ; j < 2 ; ++ j ) { for ( int i = 0 ; i < len ; ++ i ) { ForkJoinWorkerThread w = ws [ i ] ; if ( w != null && w . sp != w . base ) return true ; } } } return false ; } final int getQueueSize ( ) { int n = sp - base ; return n < 0 ? 0 : n ; } final int getEstimatedSurplusTaskCount ( ) { return ( sp - base ) - ( pool . getIdleThreadCount ( ) > > > 1 ) ; } final ForkJoinTask < ? > scanWhileJoining ( ForkJoinTask < ? > joinMe ) { ForkJoinTask < ? > t = pollTask ( ) ; if ( t != null && joinMe . status < 0 && sp == base ) { pushTask ( t ) ; t = null ; } return t ; } final void helpQuiescePool ( ) { for ( ; ; ) { ForkJoinTask < ? > t = pollTask ( ) ; if ( t != null ) t . quietlyExec ( ) ; else if ( tryInactivate ( ) && pool . isQuiescent ( ) ) break ; } do ; while ( ! tryActivate ( ) ) ; } private static Unsafe getUnsafe ( ) throws Throwable { try { return Unsafe . getUnsafe ( ) ; } catch ( SecurityException se ) { try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < Unsafe > ( ) { public Unsafe run ( ) throws Exception { return getUnsafePrivileged ( ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw e . getCause ( ) ; } } } private static Unsafe getUnsafePrivileged ( ) throws NoSuchFieldException , IllegalAccessException { Field f = Unsafe . class . getDeclaredField ( "theUnsafe" ) ; f . setAccessible ( true ) ; return ( Unsafe ) f . get ( null ) ; } private static long fieldOffset ( String fieldName ) throws NoSuchFieldException { return _unsafe . objectFieldOffset ( ForkJoinWorkerThread . class . getDeclaredField ( fieldName ) ) ; } static final Unsafe _unsafe ; static final long baseOffset ; static final long spOffset ; static final long runStateOffset ; static final long qBase ; static final int qShift ; static { try { _unsafe = getUnsafe ( ) ; baseOffset = fieldOffset ( "base" ) ; spOffset = fieldOffset ( "sp" ) ; runStateOffset = fieldOffset ( "runState" ) ; qBase = _unsafe . arrayBaseOffset ( ForkJoinTask [ ] . class ) ; int s = _unsafe . arrayIndexScale ( ForkJoinTask [ ] . class ) ; if ( ( s & ( s - 1 ) ) != 0 ) throw new Error ( "data type scale not a power of two" ) ; qShift = 31 - Integer . numberOfLeadingZeros ( s ) ; } catch ( Throwable e ) { throw new RuntimeException ( "Could not initialize intrinsics" , e ) ; } } } 
=======
abstract class AbstractRel extends AbstractDatatype { @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { Set < String > tokensSeen = new HashSet < String > ( ) ; StringBuilder builder = new StringBuilder ( ) ; int len = literal . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = literal . charAt ( i ) ; if ( isWhitespace ( c ) && builder . length ( ) > 0 ) { checkToken ( builder , i , tokensSeen ) ; builder . setLength ( 0 ) ; } else { builder . append ( toAsciiLowerCase ( c ) ) ; } } if ( builder . length ( ) > 0 ) { checkToken ( builder , len , tokensSeen ) ; } } private void checkToken ( StringBuilder builder , int i , Set < String > tokensSeen ) throws DatatypeException { String token = builder . toString ( ) ; if ( tokensSeen . contains ( token ) ) { throw newDatatypeException ( i - 1 , "Duplicate keyword " , token , "." ) ; } tokensSeen . add ( token ) ; if ( ! isRegistered ( token ) ) { try { Html5DatatypeLibrary dl = new Html5DatatypeLibrary ( ) ; Iri iri = ( Iri ) dl . createDatatype ( "iri" ) ; iri . checkValid ( token ) ; } catch ( DatatypeException e ) { throw newDatatypeException ( i - 1 , "The string " , token , " is not a registered keyword or absolute URL." ) ; } } } protected abstract boolean isRegistered ( String token ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
