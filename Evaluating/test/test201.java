<<<<<<< HEAD
public class BasicMessageConsumer extends Closeable implements MessageConsumer { private static final Logger _logger = LoggerFactory . getLogger ( BasicMessageConsumer . class ) ; private AMQConnection _connection ; private String _messageSelector ; private boolean _noLocal ; private AMQDestination _destination ; private final AtomicBoolean _receiving = new AtomicBoolean ( false ) ; private final AtomicReference _messageListener = new AtomicReference ( ) ; private String _consumerTag ; private int _channelId ; private final SynchronousQueue _synchronousQueue = new SynchronousQueue ( true ) ; private MessageFactoryRegistry _messageFactory ; private AMQSession _session ; private AMQProtocolHandler _protocolHandler ; private FieldTable _rawSelectorFieldTable ; private int _prefetch ; private boolean _exclusive ; private int _acknowledgeMode ; private int _outstanding ; private long _lastDeliveryTag ; BasicMessageConsumer ( int channelId , AMQConnection connection , AMQDestination destination , String messageSelector , boolean noLocal , MessageFactoryRegistry messageFactory , AMQSession session , AMQProtocolHandler protocolHandler , FieldTable rawSelectorFieldTable , int prefetch , boolean exclusive , int acknowledgeMode ) { _channelId = channelId ; _connection = connection ; _messageSelector = messageSelector ; _noLocal = noLocal ; _destination = destination ; _messageFactory = messageFactory ; _session = session ; _protocolHandler = protocolHandler ; _rawSelectorFieldTable = rawSelectorFieldTable ; _prefetch = prefetch ; _exclusive = exclusive ; _acknowledgeMode = acknowledgeMode ; } public AMQDestination getDestination ( ) { return _destination ; } public String getMessageSelector ( ) throws JMSException { return _messageSelector ; } public MessageListener getMessageListener ( ) throws JMSException { return ( MessageListener ) _messageListener . get ( ) ; } public int getAcknowledgeMode ( ) { return _acknowledgeMode ; } private boolean isMessageListenerSet ( ) { return _messageListener . get ( ) != null ; } public void setMessageListener ( MessageListener messageListener ) throws JMSException { checkNotClosed ( ) ; if ( _session . isStopped ( ) ) { _messageListener . set ( messageListener ) ; _logger . debug ( "Message listener set for destination " + _destination ) ; } else { if ( _receiving . get ( ) ) { throw new javax . jms . IllegalStateException ( "Another thread is already receiving synchronously." ) ; } if ( ! _messageListener . compareAndSet ( null , messageListener ) ) { throw new javax . jms . IllegalStateException ( "Attempt to alter listener while session is started." ) ; } _logger . debug ( "Message listener set for destination " + _destination ) ; if ( messageListener != null ) { Object msg = _synchronousQueue . poll ( ) ; if ( msg != null ) { AbstractJMSMessage jmsMsg = ( AbstractJMSMessage ) msg ; messageListener . onMessage ( jmsMsg ) ; postDeliver ( jmsMsg ) ; } } } } private void acquireReceiving ( ) throws JMSException { if ( ! _receiving . compareAndSet ( false , true ) ) { throw new javax . jms . IllegalStateException ( "Another thread is already receiving." ) ; } if ( isMessageListenerSet ( ) ) { throw new javax . jms . IllegalStateException ( "A listener has already been set." ) ; } } private void releaseReceiving ( ) { _receiving . set ( false ) ; } public FieldTable getRawSelectorFieldTable ( ) { return _rawSelectorFieldTable ; } public int getPrefetch ( ) { return _prefetch ; } public boolean isNoLocal ( ) { return _noLocal ; } public boolean isExclusive ( ) { return _exclusive ; } public Message receive ( ) throws JMSException { return receive ( 0 ) ; } public Message receive ( long l ) throws JMSException { checkNotClosed ( ) ; acquireReceiving ( ) ; try { Object o = null ; if ( l > 0 ) { o = _synchronousQueue . poll ( l , TimeUnit . MILLISECONDS ) ; } else { o = _synchronousQueue . take ( ) ; } final AbstractJMSMessage m = returnMessageOrThrow ( o ) ; postDeliver ( m ) ; return m ; } catch ( InterruptedException e ) { return null ; } finally { releaseReceiving ( ) ; } } public Message receiveNoWait ( ) throws JMSException { checkNotClosed ( ) ; acquireReceiving ( ) ; try { Object o = _synchronousQueue . poll ( ) ; final AbstractJMSMessage m = returnMessageOrThrow ( o ) ; postDeliver ( m ) ; return m ; } finally { releaseReceiving ( ) ; } } private AbstractJMSMessage returnMessageOrThrow ( Object o ) throws JMSException { if ( o instanceof Throwable ) { JMSException e = new JMSException ( "Message consumer forcibly closed due to error: " + o ) ; if ( o instanceof Exception ) { e . setLinkedException ( ( Exception ) o ) ; } throw e ; } else { return ( AbstractJMSMessage ) o ; } } public void close ( ) throws JMSException { synchronized ( _connection . getFailoverMutex ( ) ) { if ( ! _closed . getAndSet ( true ) ) { final AMQFrame cancelFrame = BasicCancelBody . createAMQFrame ( _channelId , _consumerTag , false ) ; try { _protocolHandler . writeCommandFrameAndWaitForReply ( cancelFrame , new SpecificMethodFrameListener ( _channelId , BasicCancelOkBody . class ) ) ; } catch ( AMQException e ) { _logger . error ( "Error closing consumer: " + e , e ) ; throw new JMSException ( "Error closing consumer: " + e ) ; } deregisterConsumer ( ) ; } } } void markClosed ( ) { _closed . set ( true ) ; deregisterConsumer ( ) ; } void notifyMessage ( UnprocessedMessage messageFrame , int channelId ) { if ( _logger . isDebugEnabled ( ) ) { _logger . debug ( "notifyMessage called with message number " + messageFrame . deliverBody . deliveryTag ) ; } try { AbstractJMSMessage jmsMessage = _messageFactory . createMessage ( messageFrame . deliverBody . deliveryTag , messageFrame . deliverBody . redelivered , messageFrame . contentHeader , messageFrame . bodies ) ; _logger . debug ( "Message is of type: " + jmsMessage . getClass ( ) . getName ( ) ) ; preDeliver ( jmsMessage ) ; if ( isMessageListenerSet ( ) ) { getMessageListener ( ) . onMessage ( jmsMessage ) ; postDeliver ( jmsMessage ) ; } else { _synchronousQueue . put ( jmsMessage ) ; } } catch ( Exception e ) { _logger . error ( "Caught exception (dump follows) - ignoring..." , e ) ; } } private void preDeliver ( AbstractJMSMessage msg ) { switch ( _acknowledgeMode ) { case Session . PRE_ACKNOWLEDGE : _session . acknowledgeMessage ( msg . getDeliveryTag ( ) , false ) ; break ; case Session . CLIENT_ACKNOWLEDGE : msg . setAMQSession ( _session ) ; break ; } } private void postDeliver ( AbstractJMSMessage msg ) { switch ( _acknowledgeMode ) { case Session . DUPS_OK_ACKNOWLEDGE : if ( ++ _outstanding >= _prefetch ) { _session . acknowledgeMessage ( msg . getDeliveryTag ( ) , true ) ; } break ; case Session . AUTO_ACKNOWLEDGE : _session . acknowledgeMessage ( msg . getDeliveryTag ( ) , false ) ; break ; case Session . SESSION_TRANSACTED : _lastDeliveryTag = msg . getDeliveryTag ( ) ; break ; } } void commit ( ) { if ( _lastDeliveryTag >= 0 ) { _session . acknowledgeMessage ( _lastDeliveryTag , true ) ; _lastDeliveryTag = - 1 ; } } void notifyError ( Throwable cause ) { _closed . set ( true ) ; if ( ! isMessageListenerSet ( ) ) { if ( _synchronousQueue . offer ( cause ) ) { _logger . debug ( "Passed exception to synchronous queue for propagation to receive()" ) ; } } deregisterConsumer ( ) ; } private void deregisterConsumer ( ) { _session . deregisterConsumer ( _consumerTag ) ; } public String getConsumerTag ( ) { return _consumerTag ; } public void setConsumerTag ( String consumerTag ) { _consumerTag = consumerTag ; } } 
=======
public class LS { private static final String XML_TYPE = "http://www.w3.org/TR/REC-xml" ; private static final String IANA_MEDIA_TYPE_URI = "http://www.iana.org/assignments/media-types/" ; private LS ( ) { } public static Resolver createResolver ( final LSResourceResolver resourceResolver ) { return new AbstractResolver ( ) { public void resolve ( Identifier id , Input input ) throws IOException , ResolverException { if ( input . isResolved ( ) ) return ; String base = id . getBase ( ) ; String publicId = null ; String type = null ; if ( id instanceof ExternalIdentifier ) { publicId = ( ( ExternalIdentifier ) id ) . getPublicId ( ) ; type = XML_TYPE ; } else if ( id instanceof XMLDocumentIdentifier ) type = ( ( XMLDocumentIdentifier ) id ) . getNamespaceUri ( ) ; if ( type == null ) { String mediaType = id . getMediaType ( ) ; if ( mediaType . indexOf ( '*' ) < 0 ) type = IANA_MEDIA_TYPE_URI + mediaType ; } String targetNamespace = null ; if ( id instanceof TargetNamespaceIdentifier ) targetNamespace = ( ( TargetNamespaceIdentifier ) id ) . getTargetNamespace ( ) ; LSInput lsInput = resourceResolver . resolveResource ( type , targetNamespace , publicId , id . getUriReference ( ) , base ) ; if ( lsInput == null ) return ; input . setEncoding ( lsInput . getEncoding ( ) ) ; input . setUri ( lsInput . getSystemId ( ) ) ; final Reader characterStream = lsInput . getCharacterStream ( ) ; if ( characterStream != null ) { input . setCharacterStream ( characterStream ) ; return ; } final InputStream byteStream = lsInput . getByteStream ( ) ; if ( byteStream != null ) { input . setByteStream ( byteStream ) ; return ; } final String stringData = lsInput . getStringData ( ) ; if ( stringData != null ) { input . setCharacterStream ( new StringReader ( stringData ) ) ; return ; } } } ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
