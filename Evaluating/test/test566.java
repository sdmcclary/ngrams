<<<<<<< HEAD
public class JSDebugTarget extends JSDebugElement implements IJSDebugTarget , IBreakpointManagerListener , IDetailFormattersChangeListener , DebugConnection . IHandler { private static final String UPDATE = "update" ; private static final String VERSION = "version" ; private static final String JAVASCRIPT = "javascript" ; private static final String JAVASCRIPT_SCHEME = "javascript:" ; private static final String OPENED = "opened" ; private static final String HTTP = "http" ; private static final String FILE = "file" ; private static final String EXCEPTION_0_1 = "exception*{0}*{1}" ; private static final String BREAKPOINT_0_1_2_3 = "breakpoint*{0}*{1}*{2}{3}" ; private static final String WATCHPOINT_0_1_2 = "watchpoint*{0}*{1}*{2}" ; private static final String DETAILS_0 = "details*{0}" ; private static final String SET_VALUE_0_1 = "setValue*{0}*{1}" ; private static final String EVAL_0 = "eval[{0}]" ; private static final String EVAL_0_1 = "eval*{0}*{1}" ; private static final String RESULT = "result" ; private static final String FRAME_0 = "frame[{0}]" ; private static final String VARIABLES_0 = "variables*{0}" ; private static final String OPEN_URL_0 = "openUrl*{0}" ; private static final String OPTION_0_1 = "option*{0}*{1}" ; private static final String ENABLE = "enable" ; private static final String STEP_FILTERS = "stepFilters" ; private static final String MONITOR_XHR = "monitorXHR" ; private static final String DETAIL_FORMATTERS = "detailFormatters" ; private static final String DISABLE = "disable" ; private static final String CHANGE = "change" ; private static final String REMOVE = "remove" ; private static final String CREATE = "create" ; private static final String RESOLVED = "resolved" ; private static final String DESTROYED = "destroyed" ; private static final String ARGS_SPLIT = "\\*" ; private static final String SUBARGS_SPLIT = "\\|" ; private static final String CREATED = "created" ; private static final String TERMINATE = "terminate" ; private static final String SUSPEND = "suspend" ; private static final String ERROR = "error" ; private static final String COMPLETED = "completed" ; private static final String LOADED = "loaded" ; private static final String SEND = "send" ; private static final String HEADERS = "headers" ; private static final String AUTH = "auth" ; private static final String OPEN = "open" ; private static final String START = "start" ; private static final String LOAD = "load" ; private static final String EXCEPTION = "exception" ; private static final String ERR = "err" ; private static final String TRACE = "trace" ; private static final String SRC = "src" ; private static final String BREAKPOINT = "breakpoint" ; private static final String SCRIPTS = "scripts" ; private static final String CLIENT = "client" ; private static final String XHR = "xhr" ; private static final String LOG = "log" ; private static final String SUCCESS = "success" ; private static final String GET_SOURCE_0 = "getSource*{0}" ; private static final int PROTOCOL_VERSION_MIN = 0 ; private static final int PROTOCOL_VERSION_MAX = 1 ; private static final int STEP_FILTERS_ENABLED = 0x001 ; private static final int FILTER_CONSTRUCTORS = 0x002 ; private static final int XOR_MASK = 0xFFF ; private static boolean checkUpdate = true ; private DebugConnection connection ; private int stepFilterMask = 0 ; private String [ ] stepFilters = null ; private ILaunch launch ; private String label ; private IProcess process ; private OutputStream out ; private OutputStream err ; private LocalResourceMapper resourceMapper ; private JSDebugThread [ ] threads = new JSDebugThread [ 0 ] ; private IFileContentRetriever fileContentRetriever ; private XHRService xhrService ; private Map < String , IJSScriptElement > topScriptElements = new HashMap < String , IJSScriptElement > ( ) ; private Map < Integer , IJSScriptElement > scripts = new HashMap < Integer , IJSScriptElement > ( ) ; private List < IBreakpoint > runToLineBreakpoints = new ArrayList < IBreakpoint > ( ) ; private Map < String , String > sourceResolveCache = new HashMap < String , String > ( 64 ) ; private String mainFile = null ; private IBreakpoint skipOperationOnBreakpoint = null ; private boolean ignoreBreakpointCreation = false ; private boolean contentChanged = false ; private Job updateContentJob = new Job ( "Debugger Content Update" ) { { setPriority ( Job . INTERACTIVE ) ; setSystem ( true ) ; } @ Override protected IStatus run ( IProgressMonitor monitor ) { if ( monitor . isCanceled ( ) ) { return Status . CANCEL_STATUS ; } if ( connection == null || ! connection . isConnected ( ) ) { return Status . OK_STATUS ; } try { boolean changed = false ; synchronized ( this ) { if ( contentChanged ) { changed = true ; contentChanged = false ; } } if ( changed ) { fireChangeEvent ( DebugEvent . CONTENT ) ; } return Status . OK_STATUS ; } finally { schedule ( 1000 ) ; } } } ; public JSDebugTarget ( ILaunch launch , IProcess process , HttpServerProcess httpServer , LocalResourceMapper resourceMapper , DebugConnection connection , boolean debugMode ) throws CoreException { this ( launch , null , process , httpServer , resourceMapper , connection , debugMode ) ; } public JSDebugTarget ( ILaunch launch , String label , IProcess process , HttpServerProcess httpServer , LocalResourceMapper resourceMapper , DebugConnection connection , boolean debugMode ) throws CoreException { super ( null ) ; this . launch = launch ; this . label = label ; this . process = process ; this . resourceMapper = resourceMapper ; this . connection = connection ; try { if ( debugMode ) { launch . addDebugTarget ( this ) ; } else { if ( process instanceof JSDebugProcess ) { ( ( JSDebugProcess ) process ) . setDebugTarget ( this ) ; } if ( httpServer != null ) { httpServer . setDebugTarget ( this ) ; } } init ( debugMode ) ; } catch ( CoreException e ) { shutdown ( ) ; throw e ; } catch ( Exception e ) { shutdown ( ) ; throwDebugException ( e ) ; } } DebugConnection getConnection ( ) { return connection ; } public Object getAdapter ( Class adapter ) { if ( adapter == IFileContentRetriever . class ) { return getFileContentRetriever ( ) ; } if ( adapter == IXHRService . class ) { return xhrService ; } return super . getAdapter ( adapter ) ; } private IFileContentRetriever getFileContentRetriever ( ) { if ( fileContentRetriever == null ) { fileContentRetriever = new IFileContentRetriever ( ) { public InputStream getContents ( URI uri ) throws CoreException { String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( GET_SOURCE_0 , Util . encodeData ( uri . toString ( ) ) ) ) ; if ( args != null && SUCCESS . equals ( args [ 1 ] ) ) { return new ByteArrayInputStream ( Util . decodeData ( args [ 2 ] ) . getBytes ( ) ) ; } return null ; } } ; } return fileContentRetriever ; } public void handleMessage ( String message ) { String [ ] args = message . split ( ARGS_SPLIT ) ; int j = 0 ; String action = args [ j ++ ] ; if ( LOG . equals ( action ) ) { handleLog ( args ) ; return ; } else if ( XHR . equals ( action ) ) { handleXHR ( args ) ; return ; } else if ( CLIENT . equals ( action ) ) { handleClientAction ( args ) ; return ; } else if ( SCRIPTS . equals ( action ) ) { handleScripts ( args ) ; return ; } else if ( BREAKPOINT . equals ( action ) ) { action = args [ j ++ ] ; String sourceFile = resolveSourceFile ( Util . decodeData ( args [ j ++ ] ) ) ; int lineNumber = - 1 ; try { lineNumber = Integer . parseInt ( args [ j ++ ] ) ; } catch ( NumberFormatException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } try { IBreakpoint breakpoint = findBreakpointAt ( sourceFile , lineNumber ) ; if ( CREATE . equals ( action ) || CHANGE . equals ( action ) ) { boolean enabled = "1" . equals ( args [ j ++ ] ) ; int hitCount = - 1 ; try { hitCount = Integer . parseInt ( args [ j ++ ] ) ; } catch ( NumberFormatException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } String condition = Util . decodeData ( args [ j ++ ] ) ; boolean conditionOnTrue = "1" . equals ( args [ j ++ ] ) ; if ( breakpoint == null ) { Map < String , Object > attributes = new HashMap < String , Object > ( ) ; attributes . put ( IBreakpoint . ENABLED , Boolean . valueOf ( enabled ) ) ; if ( hitCount != - 1 ) { attributes . put ( IDebugConstants . BREAKPOINT_HIT_COUNT , new Integer ( hitCount ) ) ; } if ( condition . length ( ) != 0 ) { attributes . put ( IDebugConstants . BREAKPOINT_CONDITION , condition ) ; attributes . put ( IDebugConstants . BREAKPOINT_CONDITION_ENABLED , Boolean . TRUE ) ; attributes . put ( IDebugConstants . BREAKPOINT_CONDITION_SUSPEND_ON_TRUE , Boolean . valueOf ( conditionOnTrue ) ) ; } Object resource = findSourceResource ( sourceFile ) ; if ( resource instanceof IResource ) { try { ignoreBreakpointCreation = true ; breakpoint = JSDebugModel . createLineBreakpoint ( ( IResource ) resource , lineNumber , attributes , true ) ; } finally { ignoreBreakpointCreation = false ; } } else if ( resource instanceof IUniformResource ) { try { ignoreBreakpointCreation = true ; breakpoint = JSDebugModel . createLineBreakpoint ( ( IUniformResource ) resource , lineNumber , attributes , true ) ; } finally { ignoreBreakpointCreation = false ; } } } else if ( CHANGE . equals ( action ) ) { if ( breakpoint . isEnabled ( ) != enabled ) { skipOperationOnBreakpoint = breakpoint ; breakpoint . setEnabled ( enabled ) ; } if ( breakpoint instanceof IJSLineBreakpoint ) { IJSLineBreakpoint lineBreakpoint = ( IJSLineBreakpoint ) breakpoint ; if ( lineBreakpoint . getHitCount ( ) != hitCount ) { skipOperationOnBreakpoint = breakpoint ; lineBreakpoint . setHitCount ( hitCount ) ; } if ( ! condition . equals ( lineBreakpoint . getCondition ( ) ) ) { skipOperationOnBreakpoint = breakpoint ; lineBreakpoint . setCondition ( condition ) ; lineBreakpoint . setConditionEnabled ( condition . length ( ) != 0 ) ; } if ( lineBreakpoint . isConditionSuspendOnTrue ( ) != conditionOnTrue ) { skipOperationOnBreakpoint = breakpoint ; lineBreakpoint . setConditionSuspendOnTrue ( conditionOnTrue ) ; } } } } else if ( REMOVE . equals ( action ) && breakpoint != null ) { skipOperationOnBreakpoint = breakpoint ; breakpoint . delete ( ) ; } } catch ( CoreException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } return ; } else if ( OPENED . equals ( action ) ) { mainFile = resolveSourceFile ( Util . decodeData ( args [ 1 ] ) ) ; DebugEvent event = new DebugEvent ( this , DebugEvent . MODEL_SPECIFIC , IDebugConstants . DEBUG_EVENT_URL_OPENED ) ; event . setData ( mainFile ) ; fireEvent ( event ) ; return ; } if ( threads . length > 0 ) { threads [ 0 ] . handleMessage ( args ) ; } } private void handleLog ( String [ ] args ) { String log = args [ 1 ] ; String text = Util . decodeData ( args [ 2 ] ) ; if ( args . length >= 4 ) { StringBuffer sb = new StringBuffer ( text ) ; String type = args [ 3 ] ; if ( SRC . equals ( type ) && args . length >= 6 ) { String fileName = resolveSourceFile ( Util . decodeData ( args [ 4 ] ) ) ; IFile file = PathUtils . findWorkspaceFile ( fileName ) ; if ( file != null ) { fileName = file . getFullPath ( ) . makeRelative ( ) . toString ( ) ; } sb . append ( StringUtils . format ( " ({0}:{1})" , new String [ ] { fileName , args [ 5 ] } ) ) ; } else if ( TRACE . equals ( type ) ) { sb . append ( '\n' ) ; for ( int i = 4 ; i < args . length ; ++ i ) { String [ ] subargs = args [ i ] . split ( SUBARGS_SPLIT ) ; if ( subargs [ 0 ] . length ( ) == 0 ) { subargs [ 0 ] = StringUtils . format ( "[{0}]" , i == args . length - 1 ? Messages . JSDebugTarget_TopLevelScript : Messages . JSDebugTarget_EvalScript ) ; } String fileName = resolveSourceFile ( Util . decodeData ( subargs [ 2 ] ) ) ; IFile file = PathUtils . findWorkspaceFile ( fileName ) ; if ( file != null ) { fileName = file . getFullPath ( ) . makeRelative ( ) . toString ( ) ; } sb . append ( StringUtils . format ( "\tat {0}({1}) ({2}:{3})\n" , new String [ ] { Util . decodeData ( subargs [ 0 ] ) , Util . decodeData ( subargs [ 1 ] ) , fileName , subargs [ 3 ] } ) ) ; } } text = sb . toString ( ) ; } if ( ! text . endsWith ( "\n" ) ) { text += "\n" ; } try { if ( ERR . equals ( log ) || EXCEPTION . equals ( log ) ) { if ( err != null ) { err . write ( text . getBytes ( ) ) ; } } else { if ( out != null ) { out . write ( text . getBytes ( ) ) ; } } } catch ( IOException e ) { JSDebugPlugin . log ( e ) ; } } private void handleXHR ( String [ ] args ) { int j = 1 ; String rid = args [ j ++ ] ; String cmd = args [ j ++ ] ; if ( START . equals ( cmd ) ) { String method = args [ j ++ ] ; String url = Util . decodeData ( args [ j ++ ] ) ; String [ ] [ ] headers = getXHRHeaders ( Util . decodeData ( args [ j ++ ] ) ) ; String body = Util . decodeData ( args [ j ++ ] ) ; xhrService . openRequest ( rid , method , url , false ) ; xhrService . setRequestHeaders ( rid , headers ) ; xhrService . setRequestBody ( rid , body ) ; } else if ( LOAD . equals ( cmd ) ) { int statusCode = - 1 ; try { statusCode = Integer . parseInt ( args [ j ++ ] ) ; } catch ( NumberFormatException e ) { } String statusText = Util . decodeData ( args [ j ++ ] ) ; String [ ] [ ] headers = getXHRHeaders ( Util . decodeData ( args [ j ++ ] ) ) ; String response = Util . decodeData ( args [ j ++ ] ) ; xhrService . setResponseStatus ( rid , statusCode , statusText ) ; xhrService . setResponseHeaders ( rid , headers ) ; xhrService . setResponseBody ( rid , response ) ; } else if ( OPEN . equals ( cmd ) ) { String method = args [ j ++ ] ; String url = Util . decodeData ( args [ j ++ ] ) ; String auth = args [ j ++ ] ; xhrService . openRequest ( rid , method , url , AUTH . equals ( auth ) ) ; } else if ( HEADERS . equals ( cmd ) ) { String [ ] [ ] headers = getXHRHeaders ( Util . decodeData ( args [ j ++ ] ) ) ; xhrService . setRequestHeaders ( rid , headers ) ; } else if ( SEND . equals ( cmd ) ) { String body = Util . decodeData ( args [ j ++ ] ) ; xhrService . setRequestBody ( rid , body ) ; } else if ( LOADED . equals ( cmd ) ) { int statusCode = - 1 ; try { statusCode = Integer . parseInt ( args [ j ++ ] ) ; } catch ( NumberFormatException e ) { } String statusText = Util . decodeData ( args [ j ++ ] ) ; String [ ] [ ] headers = getXHRHeaders ( Util . decodeData ( args [ j ++ ] ) ) ; xhrService . setResponseHeaders ( rid , headers ) ; xhrService . setResponseStatus ( rid , statusCode , statusText ) ; } else if ( COMPLETED . equals ( cmd ) ) { String response = Util . decodeData ( args [ j ++ ] ) ; xhrService . setResponseBody ( rid , response ) ; } else if ( ERROR . equals ( cmd ) ) { xhrService . setError ( rid ) ; } } private static String [ ] [ ] getXHRHeaders ( String string ) { String [ ] headers = string . split ( "\\n" ) ; List < String [ ] > list = new ArrayList < String [ ] > ( headers . length ) ; for ( int i = 0 ; i < headers . length ; ++ i ) { String header = headers [ i ] ; String value = StringUtils . EMPTY ; int pos = header . indexOf ( ": " ) ; if ( pos != - 1 ) { value = header . substring ( pos + 2 ) ; header = header . substring ( 0 , pos ) ; } list . add ( new String [ ] { header , value } ) ; } return ( String [ ] [ ] ) list . toArray ( new String [ list . size ( ) ] [ ] ) ; } private void handleClientAction ( String [ ] args ) { int j = 1 ; String action = args [ j ++ ] ; if ( SUSPEND . equals ( action ) ) { try { if ( canSuspend ( ) ) { suspend ( ) ; } } catch ( DebugException ignore ) { } } else if ( TERMINATE . equals ( action ) ) { try { if ( canTerminate ( ) ) { terminate ( ) ; } } catch ( DebugException ignore ) { } } else if ( OPEN . equals ( action ) ) { String fileName = resolveSourceFile ( Util . decodeData ( args [ j ++ ] ) ) ; if ( fileName != null ) { Object sourceElement = null ; ISourceLocator locator = launch . getSourceLocator ( ) ; if ( locator instanceof ISourceLookupDirector ) { sourceElement = ( ( ISourceLookupDirector ) locator ) . getSourceElement ( fileName ) ; } if ( sourceElement != null ) { JSDebugPlugin . getDefault ( ) . openInEditor ( sourceElement ) ; } } } } private void handleScripts ( String [ ] args ) { String action = args [ 1 ] ; if ( CREATED . equals ( action ) ) { for ( int i = 2 ; i < args . length ; ++ i ) { int j = 0 ; String [ ] subargs = args [ i ] . split ( SUBARGS_SPLIT ) ; if ( subargs . length < 5 ) { IdeLog . logInfo ( JSDebugPlugin . getDefault ( ) , StringUtils . format ( "Missing fields in response: <{0}>" , args [ i ] ) ) ; continue ; } int scriptTag = - 1 ; try { scriptTag = Integer . parseInt ( subargs [ j ++ ] ) ; } catch ( NumberFormatException e ) { } String fileName = Util . decodeData ( subargs [ j ++ ] ) ; if ( fileName . length ( ) == 0 || "[Eval-script]" . equals ( fileName ) || fileName . startsWith ( "javascript:" ) ) { continue ; } fileName = resolveSourceFile ( fileName ) ; String scriptName = Util . decodeData ( subargs [ j ++ ] ) ; int baseLine = - 1 ; int lineExtent = - 1 ; try { baseLine = Integer . parseInt ( subargs [ j ++ ] ) ; lineExtent = Integer . parseInt ( subargs [ j ++ ] ) ; } catch ( NumberFormatException e ) { } if ( scriptName . length ( ) == 0 ) { continue ; } JSDebugScriptElement topScriptElement = ( JSDebugScriptElement ) topScriptElements . get ( fileName ) ; if ( topScriptElement == null ) { String name = fileName ; IFile file = PathUtils . findWorkspaceFile ( fileName ) ; if ( file != null ) { name = file . getFullPath ( ) . toString ( ) ; } topScriptElement = new JSDebugTopScriptElement ( this , name , fileName ) ; topScriptElements . put ( fileName , topScriptElement ) ; } JSDebugScriptElement scriptElement = new JSDebugScriptElement ( this , scriptName , baseLine , lineExtent ) ; topScriptElement . insertElement ( scriptElement ) ; if ( scriptTag > 0 ) { scripts . put ( new Integer ( scriptTag ) , scriptElement ) ; } } synchronized ( updateContentJob ) { contentChanged = true ; } ; } else if ( DESTROYED . equals ( action ) ) { int j = 0 ; String [ ] subargs = args [ 2 ] . split ( SUBARGS_SPLIT ) ; int scriptTag = - 1 ; try { scriptTag = Integer . parseInt ( subargs [ j ++ ] ) ; } catch ( NumberFormatException e ) { } String fileName = resolveSourceFile ( Util . decodeData ( subargs [ j ++ ] ) ) ; JSDebugScriptElement topScriptElement = ( JSDebugScriptElement ) topScriptElements . get ( fileName ) ; if ( scriptTag > 0 ) { JSDebugScriptElement scriptElement = ( JSDebugScriptElement ) scripts . remove ( new Integer ( scriptTag ) ) ; if ( topScriptElement != null && scriptElement != null ) { topScriptElement . removeElement ( scriptElement ) ; } } } else if ( RESOLVED . equals ( action ) ) { for ( int i = 2 ; i < args . length ; ++ i ) { int j = 0 ; String [ ] subargs = args [ i ] . split ( SUBARGS_SPLIT ) ; int scriptTag = - 1 ; try { scriptTag = Integer . parseInt ( subargs [ j ++ ] ) ; } catch ( NumberFormatException e ) { } String scriptName = Util . decodeData ( subargs [ j ++ ] ) ; if ( scriptTag < 0 || scriptName . length ( ) == 0 ) { continue ; } JSDebugScriptElement scriptElement = ( JSDebugScriptElement ) scripts . get ( new Integer ( scriptTag ) ) ; if ( scriptElement != null ) { scriptElement . setName ( scriptName ) ; scriptElement . fireChangeEvent ( DebugEvent . STATE ) ; } } } } public ILaunch getLaunch ( ) { return launch ; } public IDebugTarget getDebugTarget ( ) { return this ; } public IProcess getProcess ( ) { return process ; } public IThread [ ] getThreads ( ) throws DebugException { return threads ; } public boolean hasThreads ( ) throws DebugException { return threads . length > 0 ; } public String getName ( ) throws DebugException { return label != null ? label : Messages . JSDebugTarget_JSDebugger ; } public boolean supportsBreakpoint ( IBreakpoint breakpoint ) { if ( breakpoint . getModelIdentifier ( ) . equals ( getModelIdentifier ( ) ) ) { return true ; } return false ; } public boolean canTerminate ( ) { return ! isTerminated ( ) ; } public boolean isTerminated ( ) { return connection . isTerminated ( ) ; } public void terminate ( ) throws DebugException { if ( isTerminated ( ) ) { return ; } connection . sendCommand ( TERMINATE ) ; } public boolean canResume ( ) { return isSuspended ( ) ; } public boolean canSuspend ( ) { return ! isSuspended ( ) ; } public boolean isSuspended ( ) { return threads . length > 0 ? threads [ 0 ] . isSuspended ( ) : false ; } public void resume ( ) throws DebugException { threads [ 0 ] . resume ( ) ; } public void suspend ( ) throws DebugException { if ( isDisconnected ( ) ) { return ; } threads [ 0 ] . suspend ( ) ; } public void breakpointAdded ( IBreakpoint breakpoint ) { if ( supportsBreakpoint ( breakpoint ) && breakpoint instanceof IJSLineBreakpoint ) { try { if ( ( ( IJSLineBreakpoint ) breakpoint ) . isRunToLine ( ) ) { runToLineBreakpoints . add ( breakpoint ) ; } } catch ( CoreException e ) { } } handleBreakpoint ( breakpoint , CREATE ) ; } public void breakpointRemoved ( IBreakpoint breakpoint , IMarkerDelta delta ) { if ( supportsBreakpoint ( breakpoint ) && breakpoint instanceof IJSLineBreakpoint ) { try { if ( ( ( IJSLineBreakpoint ) breakpoint ) . isRunToLine ( ) ) { runToLineBreakpoints . remove ( breakpoint ) ; } } catch ( CoreException e ) { } } handleBreakpoint ( breakpoint , REMOVE ) ; } public void breakpointChanged ( IBreakpoint breakpoint , IMarkerDelta delta ) { handleBreakpoint ( breakpoint , CHANGE ) ; } public boolean canDisconnect ( ) { return ! isDisconnected ( ) ; } public void disconnect ( ) throws DebugException { connection . sendCommandAndWait ( DISABLE ) ; stopDebug ( ) ; } public boolean isDisconnected ( ) { return ! connection . isConnected ( ) ; } public boolean supportsStorageRetrieval ( ) { return false ; } public IMemoryBlock getMemoryBlock ( long startAddress , long length ) throws DebugException { throwNotImplemented ( ) ; return null ; } public boolean isFilterConstructors ( ) { return ( stepFilterMask & FILTER_CONSTRUCTORS ) > 0 ; } public void setFilterConstructors ( boolean filter ) { if ( filter ) { stepFilterMask = stepFilterMask | FILTER_CONSTRUCTORS ; } else { stepFilterMask = stepFilterMask & ( FILTER_CONSTRUCTORS ^ XOR_MASK ) ; } } public boolean isStepFiltersEnabled ( ) { return ( stepFilterMask & STEP_FILTERS_ENABLED ) > 0 ; } public void setStepFiltersEnabled ( boolean enabled ) { if ( enabled ) { stepFilterMask = stepFilterMask | STEP_FILTERS_ENABLED ; } else { stepFilterMask = stepFilterMask & ( STEP_FILTERS_ENABLED ^ XOR_MASK ) ; } try { setOption ( "stepFiltersEnabled" , Boolean . toString ( isStepFiltersEnabled ( ) ) ) ; } catch ( DebugException e ) { } } public boolean supportsStepFilters ( ) { return ! isTerminated ( ) && ! isDisconnected ( ) ; } public String [ ] getStepFilters ( ) { return stepFilters ; } public void setStepFilters ( String [ ] list ) { stepFilters = list ; } public String getAttribute ( String key ) { return getLaunch ( ) . getAttribute ( key ) ; } public void setAttribute ( String key , String value ) { getLaunch ( ) . setAttribute ( key , value ) ; try { handleAttribute ( key ) ; } catch ( DebugException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } private void handleAttribute ( String key ) throws DebugException { String value = getAttribute ( key ) ; boolean boolValue = Boolean . valueOf ( value ) . booleanValue ( ) ; if ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_FIRST_LINE . equals ( key ) ) { setOption ( "suspendOnFirstLine" , Boolean . toString ( boolValue ) ) ; } else if ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_EXCEPTIONS . equals ( key ) ) { setOption ( "suspendOnExceptions" , Boolean . toString ( boolValue ) ) ; } else if ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_ERRORS . equals ( key ) ) { setOption ( "suspendOnErrors" , Boolean . toString ( boolValue ) ) ; } else if ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_DEBUGGER_KEYWORDS . equals ( key ) ) { setOption ( "suspendOnKeywords" , Boolean . toString ( boolValue ) ) ; } } public void detailFormattersChanged ( ) { try { handleDetailFormattersChange ( ) ; } catch ( DebugException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } private void handleDetailFormattersChange ( ) throws DebugException { Collection detailformatters = JSDetailFormattersManager . getDefault ( ) . getDetailFormatters ( ) ; StringBuffer sb = new StringBuffer ( DETAIL_FORMATTERS ) ; if ( ! detailformatters . isEmpty ( ) ) { for ( Iterator i = detailformatters . iterator ( ) ; i . hasNext ( ) ; ) { DetailFormatter detailFormatter = ( DetailFormatter ) i . next ( ) ; if ( ! detailFormatter . isEnabled ( ) ) { continue ; } sb . append ( StringUtils . format ( "*{0}|{1}" , new String [ ] { detailFormatter . getTypeName ( ) , Util . encodeData ( detailFormatter . getSnippet ( ) ) } ) ) ; } } connection . sendCommandAndWait ( sb . toString ( ) ) ; } private void init ( boolean debugMode ) throws CoreException { synchronized ( this ) { connection . start ( this ) ; updateContentJob . schedule ( ) ; checkVersion ( ) ; } if ( true ) { xhrService = new XHRService ( ) ; setOption ( MONITOR_XHR , Boolean . toString ( true ) ) ; if ( process instanceof JSDebugProcess ) { ( ( JSDebugProcess ) process ) . setXHRService ( xhrService ) ; } } if ( debugMode ) { fireCreationEvent ( ) ; JSDebugThread thread = new JSDebugThread ( this ) ; threads = new JSDebugThread [ ] { thread } ; for ( int i = 0 ; i < threads . length ; ++ i ) { threads [ i ] . fireCreationEvent ( ) ; } fireChangeEvent ( DebugEvent . CONTENT ) ; handleAttribute ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_FIRST_LINE ) ; handleAttribute ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_EXCEPTIONS ) ; handleAttribute ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_ERRORS ) ; handleAttribute ( ILaunchConfigurationConstants . CONFIGURATION_SUSPEND_ON_DEBUGGER_KEYWORDS ) ; setOption ( "bypassConstructors" , Boolean . toString ( isFilterConstructors ( ) ) ) ; setOption ( "stepFiltersEnabled" , Boolean . toString ( isStepFiltersEnabled ( ) ) ) ; if ( stepFilters != null && stepFilters . length > 0 ) { StringBuffer sb = new StringBuffer ( STEP_FILTERS ) ; for ( int i = 0 ; i < stepFilters . length ; ++ i ) { sb . append ( i != 0 ? '|' : '*' ) . append ( Util . encodeData ( stepFilters [ i ] ) ) ; } connection . sendCommandAndWait ( sb . toString ( ) ) ; } handleDetailFormattersChange ( ) ; JSDetailFormattersManager . getDefault ( ) . addChangeListener ( this ) ; IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( getModelIdentifier ( ) ) ; for ( int i = 0 ; i < breakpoints . length ; ++ i ) { breakpointAdded ( breakpoints [ i ] ) ; } DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . addBreakpointManagerListener ( this ) ; DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . addBreakpointListener ( this ) ; connection . sendCommandAndWait ( ENABLE ) ; } if ( process instanceof JSDebugProcess ) { out = ( ( JSDebugProcess ) process ) . getOutputStream ( ) ; err = ( ( JSDebugProcess ) process ) . getErrorStream ( ) ; } } private void checkVersion ( ) throws DebugException { int protoVersion = 0 ; String version = null ; String [ ] args = connection . sendCommandAndWait ( VERSION ) ; if ( args != null && args . length >= 3 && args [ 1 ] . charAt ( 0 ) != '!' ) { IdeLog . logInfo ( JSDebugPlugin . getDefault ( ) , StringUtils . format ( "Extension version: {0}; protocol v{1}" , new String [ ] { args [ 2 ] , args [ 1 ] } ) ) ; try { protoVersion = Integer . parseInt ( args [ 1 ] ) ; } catch ( NumberFormatException e ) { } version = args [ 2 ] ; } if ( ( protoVersion < PROTOCOL_VERSION_MIN ) || ( protoVersion > PROTOCOL_VERSION_MAX ) ) { throwDebugException ( StringUtils . format ( "Incompatible debugger extension protocol version {0} for [{1},{2}]" , new String [ ] { Integer . toString ( protoVersion ) , Integer . toString ( PROTOCOL_VERSION_MIN ) , Integer . toString ( PROTOCOL_VERSION_MAX ) } ) ) ; } if ( checkUpdate ) { boolean update = false ; if ( version != null ) { String pluginVersion = ( String ) Platform . getBundle ( JSDebugPlugin . ID ) . getHeaders ( ) . get ( Constants . BUNDLE_VERSION ) ; int index = pluginVersion . lastIndexOf ( '.' ) ; if ( index != - 1 ) { if ( index >= version . length ( ) || ! pluginVersion . substring ( 0 , index ) . equals ( version . substring ( 0 , index ) ) ) { update = true ; } else if ( ! pluginVersion . substring ( index + 1 ) . equals ( version . substring ( index + 1 ) ) ) { try { if ( Integer . parseInt ( pluginVersion . substring ( index + 1 ) ) > Integer . parseInt ( version . substring ( index + 1 ) ) ) { update = true ; } } catch ( NumberFormatException e ) { } } } if ( update ) { args = connection . sendCommandAndWait ( UPDATE ) ; if ( args != null && args . length >= 2 ) { IdeLog . logInfo ( JSDebugPlugin . getDefault ( ) , StringUtils . format ( "Extension update available: {0}" , new String [ ] { args [ 1 ] } ) ) ; } } } checkUpdate = false ; } } private synchronized void setOption ( String option , String value ) throws DebugException { if ( connection . isConnected ( ) ) { connection . sendCommandAndWait ( StringUtils . format ( OPTION_0_1 , new String [ ] { option , value } ) ) ; } } public void openURL ( URL url ) throws DebugException { if ( connection . isConnected ( ) ) { try { DebugEvent event = new DebugEvent ( this , DebugEvent . MODEL_SPECIFIC , IDebugConstants . DEBUG_EVENT_URL_OPEN ) ; URL fileUrl = new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , url . getPath ( ) ) ; event . setData ( resolveSourceFile ( fileUrl . toExternalForm ( ) ) ) ; fireEvent ( event ) ; } catch ( MalformedURLException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } mainFile = null ; connection . sendCommandAndWait ( StringUtils . format ( OPEN_URL_0 , Util . encodeData ( url . toString ( ) ) ) ) ; } } private void stopDebug ( ) throws DebugException { if ( connection == null || ! connection . isConnected ( ) ) { return ; } connection . stop ( ) ; updateContentJob . cancel ( ) ; if ( threads . length > 0 ) { for ( int i = 0 ; i < threads . length ; ++ i ) { threads [ i ] . fireTerminateEvent ( ) ; } threads = new JSDebugThread [ 0 ] ; topScriptElements . clear ( ) ; scripts . clear ( ) ; fireChangeEvent ( DebugEvent . CONTENT ) ; JSDetailFormattersManager . getDefault ( ) . removeChangeListener ( this ) ; DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . removeBreakpointListener ( this ) ; DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . removeBreakpointManagerListener ( this ) ; } } public void handleShutdown ( ) { try { shutdown ( ) ; } catch ( DebugException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } private void shutdown ( ) throws DebugException { try { stopDebug ( ) ; if ( connection != null ) { connection . dispose ( ) ; } } catch ( IOException e ) { throwDebugException ( e ) ; } finally { if ( DebugPlugin . getDefault ( ) != null ) { fireTerminateEvent ( ) ; } } } public void breakpointManagerEnablementChanged ( boolean enabled ) { IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( getModelIdentifier ( ) ) ; for ( int i = 0 ; i < breakpoints . length ; i ++ ) { IBreakpoint breakpoint = breakpoints [ i ] ; if ( enabled ) { breakpointAdded ( breakpoint ) ; } else { breakpointRemoved ( breakpoint , null ) ; } } } protected IVariable [ ] loadVariables ( String qualifier ) throws DebugException { if ( ! isSuspended ( ) ) { return new IVariable [ 0 ] ; } List < IVariable > list = new ArrayList < IVariable > ( ) ; String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( VARIABLES_0 , Util . encodeData ( qualifier ) ) ) ; if ( args != null ) { for ( int i = 1 ; i < args . length ; ++ i ) { int j = 0 ; String varData = args [ i ] ; if ( varData . length ( ) == 0 ) { break ; } if ( varData . endsWith ( "|" ) ) { varData += "| " ; } String [ ] subargs = varData . split ( SUBARGS_SPLIT ) ; String name = Util . decodeData ( subargs [ j ++ ] ) ; String type = Util . decodeData ( subargs [ j ++ ] ) ; String flags = subargs [ j ++ ] ; String stringValue = Util . decodeData ( subargs [ j ++ ] ) ; boolean complex = flags . indexOf ( 'o' ) != - 1 ; IValue ivalue ; String q = StringUtils . format ( "{0}.{1}" , new String [ ] { qualifier , name } ) ; ivalue = new JSDebugValue ( this , q , type , complex , stringValue ) ; list . add ( new JSDebugVariable ( this , q , name , ivalue , convertVariableFlags ( flags ) ) ) ; } } return ( IVariable [ ] ) list . toArray ( new IVariable [ list . size ( ) ] ) ; } protected Object evaluateExpression ( String expression , IDebugElement context ) throws DebugException { if ( ! isSuspended ( ) ) { return null ; } String qualifier ; Object result = null ; if ( context instanceof JSDebugStackFrame ) { qualifier = StringUtils . format ( FRAME_0 , ( ( JSDebugStackFrame ) context ) . getFrameId ( ) ) ; } else if ( context instanceof JSDebugVariable ) { qualifier = ( ( JSDebugVariable ) context ) . getQualifier ( ) ; } else { return result ; } String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( EVAL_0_1 , new String [ ] { Util . encodeData ( qualifier ) , Util . encodeData ( expression ) } ) ) ; String status = args != null && args . length > 1 ? args [ 1 ] : null ; if ( RESULT . equals ( status ) ) { String evalId = args [ 2 ] ; String varData = args [ 3 ] ; if ( varData . endsWith ( "|" ) ) { varData += "| " ; } String [ ] subargs = varData . split ( SUBARGS_SPLIT ) ; int j = 0 ; String type = subargs [ j ++ ] ; String flags = subargs [ j ++ ] ; String stringValue = Util . decodeData ( subargs [ j ++ ] ) ; boolean complex = flags . indexOf ( 'o' ) != - 1 ; result = new JSDebugValue ( this , StringUtils . format ( EVAL_0 , evalId ) , type , complex , stringValue ) ; } else if ( EXCEPTION . equals ( status ) ) { result = new String [ ] { args [ 2 ] } ; } return result ; } protected Object setValue ( IVariable variable , IValue newValue ) throws DebugException { if ( ! isSuspended ( ) ) { return null ; } String qualifier ; String vqualifier ; Object result = null ; if ( variable instanceof JSDebugVariable ) { qualifier = ( ( JSDebugVariable ) variable ) . getQualifier ( ) ; } else { return result ; } if ( newValue instanceof JSDebugValue ) { vqualifier = ( ( JSDebugValue ) newValue ) . getQualifier ( ) ; } else { return result ; } String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( SET_VALUE_0_1 , new String [ ] { Util . encodeData ( qualifier ) , vqualifier } ) ) ; if ( args != null && args . length >= 3 ) { String status = args [ 1 ] ; if ( RESULT . equals ( status ) ) { String [ ] subargs = args [ 2 ] . split ( SUBARGS_SPLIT ) ; int j = 0 ; String type = subargs [ j ++ ] ; String flags = subargs [ j ++ ] ; String stringValue = Util . decodeData ( subargs [ j ++ ] ) ; boolean complex = flags . indexOf ( 'o' ) != - 1 ; result = new JSDebugValue ( this , qualifier , type , complex , stringValue ) ; } else if ( EXCEPTION . equals ( status ) ) { result = new String [ ] { args [ 2 ] } ; } } return result ; } public String computeValueDetails ( IValue value ) throws DebugException { if ( ! isSuspended ( ) ) { return StringUtils . EMPTY ; } String qualifier ; String result = null ; if ( value instanceof JSDebugValue ) { qualifier = ( ( JSDebugValue ) value ) . getQualifier ( ) ; } else { return value . getValueString ( ) ; } String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( DETAILS_0 , Util . encodeData ( qualifier ) ) ) ; if ( args != null && args . length >= 3 ) { String status = args [ 1 ] ; if ( RESULT . equals ( status ) ) { result = Util . decodeData ( args [ 2 ] ) ; } } if ( result == null ) { result = value . getValueString ( ) ; } if ( result == null ) { return StringUtils . EMPTY ; } return result ; } protected IVariable findVariable ( String variableName , IDebugElement context ) throws DebugException { if ( Util . checkVariable ( variableName ) ) { Object result = evaluateExpression ( variableName , context ) ; if ( result instanceof IValue ) { return new JSDebugVariable ( this , null , variableName , ( IValue ) result ) ; } } return null ; } private void handleBreakpoint ( IBreakpoint breakpoint , String operation ) { if ( isDisconnected ( ) ) { return ; } if ( breakpoint . equals ( skipOperationOnBreakpoint ) ) { skipOperationOnBreakpoint = null ; return ; } if ( CREATE . equals ( operation ) && ignoreBreakpointCreation ) { return ; } if ( supportsBreakpoint ( breakpoint ) ) { if ( breakpoint instanceof IJSLineBreakpoint ) { handleLineBreakpoint ( ( IJSLineBreakpoint ) breakpoint , operation ) ; } else if ( breakpoint instanceof IJSExceptionBreakpoint ) { handleExceptionBreakpoint ( ( IJSExceptionBreakpoint ) breakpoint , operation ) ; } else if ( breakpoint instanceof IJSWatchpoint ) { handleWatchpoint ( ( IJSWatchpoint ) breakpoint , operation ) ; } } } private void handleLineBreakpoint ( IJSLineBreakpoint breakpoint , String operation ) { IMarker marker = breakpoint . getMarker ( ) ; URL url = null ; String properties = StringUtils . EMPTY ; try { URI uri = null ; if ( marker instanceof IUniformResourceMarker ) { uri = ( ( IUniformResourceMarker ) marker ) . getUniformResource ( ) . getURI ( ) ; } else { IResource resource = marker . getResource ( ) ; if ( resource instanceof IWorkspaceRoot ) { uri = URI . create ( ( String ) marker . getAttribute ( IDebugConstants . BREAKPOINT_LOCATION ) ) ; } else { uri = resource . getLocation ( ) . makeAbsolute ( ) . toFile ( ) . toURI ( ) ; } } if ( uri != null && resourceMapper != null ) { uri = resourceMapper . resolveLocalURI ( uri ) ; } if ( uri != null ) { if ( "dbgsource" . equals ( uri . getScheme ( ) ) ) { url = new URL ( null , uri . toString ( ) , DbgSourceURLStreamHandler . getDefault ( ) ) ; } else { url = uri . toURL ( ) ; } } } catch ( MalformedURLException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } catch ( CoreException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } int lineNumber = marker . getAttribute ( IMarker . LINE_NUMBER , - 1 ) ; if ( lineNumber == - 1 ) { return ; } boolean remove = REMOVE . equals ( operation ) ; if ( ! remove ) { boolean enabled = false ; try { enabled = breakpoint . isEnabled ( ) ; } catch ( CoreException ignore ) { } int hitCount = marker . getAttribute ( IDebugConstants . BREAKPOINT_HIT_COUNT , 0 ) ; boolean conditionEnabled = marker . getAttribute ( IDebugConstants . BREAKPOINT_CONDITION_ENABLED , false ) ; String condition = conditionEnabled ? marker . getAttribute ( IDebugConstants . BREAKPOINT_CONDITION , StringUtils . EMPTY ) : StringUtils . EMPTY ; String suspendOnTrue = marker . getAttribute ( IDebugConstants . BREAKPOINT_CONDITION_SUSPEND_ON_TRUE , true ) ? "1" : "0" ; properties = StringUtils . format ( "*{0}*{1}*{2}*{3}" , new String [ ] { enabled ? "1" : "0" , Integer . toString ( hitCount ) , Util . encodeData ( condition ) , suspendOnTrue } ) ; } try { String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( BREAKPOINT_0_1_2_3 , new String [ ] { operation , Util . encodeData ( url . toString ( ) ) , Integer . toString ( lineNumber ) , properties } ) ) ; if ( ! remove && ( args == null || args . length < 2 || ! ( operation + 'd' ) . equals ( args [ 1 ] ) ) ) { breakpoint . setEnabled ( false ) ; } } catch ( CoreException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } private void handleExceptionBreakpoint ( IJSExceptionBreakpoint breakpoint , String operation ) { IMarker marker = breakpoint . getMarker ( ) ; String exceptionTypeName = marker . getAttribute ( IDebugConstants . EXCEPTION_TYPE_NAME , StringUtils . EMPTY ) ; if ( exceptionTypeName == null || exceptionTypeName . length ( ) == 0 ) { return ; } boolean enabled = false ; try { enabled = breakpoint . isEnabled ( ) ; } catch ( CoreException ignore ) { } if ( ! enabled ) { operation = REMOVE ; } enabled = ! REMOVE . equals ( operation ) ; try { String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( EXCEPTION_0_1 , new String [ ] { operation , exceptionTypeName } ) ) ; if ( enabled && ( args == null || ! ( operation + 'd' ) . equals ( args [ 1 ] ) ) ) { breakpoint . setEnabled ( false ) ; } } catch ( CoreException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } private void handleWatchpoint ( IJSWatchpoint watchpoint , String operation ) { IMarker marker = watchpoint . getMarker ( ) ; String variableName = marker . getAttribute ( IDebugConstants . WATCHPOINT_VARIABLE_ACCESSOR , StringUtils . EMPTY ) ; boolean enabled = false ; try { enabled = watchpoint . isEnabled ( ) ; } catch ( CoreException ignore ) { } if ( ! enabled ) { if ( CREATE . equals ( operation ) ) { return ; } operation = REMOVE ; } enabled = ! REMOVE . equals ( operation ) ; String kind = StringUtils . EMPTY ; if ( enabled ) { try { if ( watchpoint . isAccess ( ) ) { kind += 'r' ; } if ( watchpoint . isModification ( ) ) { kind += 'w' ; } } catch ( CoreException ignore ) { } } try { String [ ] args = connection . sendCommandAndWait ( StringUtils . format ( WATCHPOINT_0_1_2 , new String [ ] { operation , Util . encodeData ( variableName ) , kind } ) ) ; if ( enabled && ( args == null || args . length < 2 || ! ( operation + 'd' ) . equals ( args [ 1 ] ) ) ) { watchpoint . setEnabled ( false ) ; } } catch ( CoreException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } protected IBreakpoint findBreakpointAt ( String filename , int lineNumber ) { IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( getModelIdentifier ( ) ) ; IBreakpoint breakpoint = findBreakpointIn ( filename , lineNumber , breakpoints ) ; if ( breakpoint != null ) { return breakpoint ; } if ( ! runToLineBreakpoints . isEmpty ( ) ) { return findBreakpointIn ( filename , lineNumber , ( IBreakpoint [ ] ) runToLineBreakpoints . toArray ( new IBreakpoint [ runToLineBreakpoints . size ( ) ] ) ) ; } return null ; } protected IBreakpoint findBreakpointIn ( String filename , int lineNumber , IBreakpoint [ ] breakpoints ) { for ( int i = 0 ; i < breakpoints . length ; ++ i ) { IBreakpoint breakpoint = breakpoints [ i ] ; if ( getDebugTarget ( ) . supportsBreakpoint ( breakpoint ) ) { if ( breakpoint instanceof ILineBreakpoint ) { try { IMarker marker = breakpoint . getMarker ( ) ; boolean fileMatched = false ; if ( marker instanceof IUniformResourceMarker ) { URI breakpointURI = ( ( IUniformResourceMarker ) marker ) . getUniformResource ( ) . getURI ( ) ; fileMatched = new URI ( Util . fixupURI ( filename ) ) . equals ( breakpointURI ) ; } else if ( marker . getResource ( ) instanceof IWorkspaceRoot ) { URI breakpointURI = URI . create ( ( String ) marker . getAttribute ( IDebugConstants . BREAKPOINT_LOCATION ) ) ; fileMatched = new URI ( Util . fixupURI ( filename ) ) . equals ( breakpointURI ) ; } else { IFile file = PathUtils . findWorkspaceFile ( filename ) ; if ( file != null ) { fileMatched = file . equals ( marker . getResource ( ) ) ; } else { File breakpointFile = marker . getResource ( ) . getLocation ( ) . toFile ( ) ; fileMatched = new File ( filename ) . equals ( breakpointFile ) ; } } if ( fileMatched && ( ( ILineBreakpoint ) breakpoint ) . getLineNumber ( ) == lineNumber ) { return breakpoint ; } } catch ( CoreException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } catch ( URISyntaxException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } } } } return null ; } protected String resolveSourceFile ( String sourceFile ) { String resolved = ( String ) sourceResolveCache . get ( sourceFile ) ; if ( resolved != null ) { return resolved ; } try { URI uri = new URI ( sourceFile ) ; String scheme = uri . getScheme ( ) ; if ( FILE . equals ( scheme ) ) { try { File osFile = new File ( uri . getSchemeSpecificPart ( ) ) ; IPath canonicalPath = new Path ( osFile . getCanonicalPath ( ) ) ; IFile file = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFileForLocation ( canonicalPath ) ; if ( file != null ) { resolved = file . getLocation ( ) . toString ( ) ; } else { resolved = osFile . getAbsolutePath ( ) ; } } catch ( IOException e ) { } } else if ( HTTP . equals ( scheme ) && resourceMapper != null ) { File osFile = resourceMapper . resolveServerURL ( uri . toURL ( ) ) ; if ( osFile != null ) { resolved = osFile . getAbsolutePath ( ) ; } } else if ( JAVASCRIPT . equals ( scheme ) ) { if ( mainFile != null ) { return mainFile ; } } if ( resolved != null ) { sourceResolveCache . put ( sourceFile , resolved ) ; return resolved ; } } catch ( URISyntaxException e ) { if ( sourceFile . startsWith ( JAVASCRIPT_SCHEME ) ) { if ( mainFile != null ) { return mainFile ; } } IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } catch ( MalformedURLException e ) { IdeLog . logError ( JSDebugPlugin . getDefault ( ) , StringUtils . EMPTY , e ) ; } return sourceFile ; } private Object findSourceResource ( String sourceFile ) throws CoreException { ISourceLocator locator = launch . getSourceLocator ( ) ; if ( locator instanceof ISourceLookupDirector ) { ISourceLookupDirector lookupDirector = ( ISourceLookupDirector ) locator ; Object [ ] result = lookupDirector . findSourceElements ( sourceFile ) ; if ( result != null && result . length > 0 ) { Object resource = result [ 0 ] ; if ( resource instanceof IResource ) { return resource ; } if ( ! ( resource instanceof IUniformResource ) && resource instanceof IAdaptable ) { Object adopted = ( ( IAdaptable ) resource ) . getAdapter ( IUniformResource . class ) ; if ( adopted != null ) { resource = adopted ; } } return resource ; } } return null ; } private static int convertVariableFlags ( String string ) { int flags = 0 ; char [ ] chars = string . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; ++ i ) { switch ( chars [ i ] ) { case 'w' : flags |= JSDebugVariable . FLAGS_MODIFIABLE ; break ; case 'c' : flags |= JSDebugVariable . FLAGS_CONST ; break ; case 'l' : flags |= JSDebugVariable . FLAGS_LOCAL ; break ; case 'a' : flags |= JSDebugVariable . FLAGS_ARGUMENT ; break ; case 'e' : flags |= JSDebugVariable . FLAGS_EXCEPTION ; break ; default : break ; } } return flags ; } public IJSScriptElement [ ] getTopScriptElements ( ) { return ( IJSScriptElement [ ] ) topScriptElements . values ( ) . toArray ( new IJSScriptElement [ topScriptElements . size ( ) ] ) ; } } 
=======
public final class Time extends AbstractDatetime { public static final Time THE_INSTANCE = new Time ( ) ; private static final Pattern THE_PATTERN = Pattern . compile ( "^([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\.[0-9]{1,3})?)?$" ) ; private Time ( ) { super ( ) ; } public void checkValid ( CharSequence literal ) throws DatatypeException { Matcher m = getPattern ( ) . matcher ( literal ) ; if ( m . matches ( ) ) { checkHour ( m . group ( 1 ) ) ; checkMinute ( m . group ( 2 ) ) ; String seconds = m . group ( 3 ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } } else { throw newDatatypeException ( "The literal did not satisfy the format for time." ) ; } } protected final Pattern getPattern ( ) { return THE_PATTERN ; } @ Override public String getName ( ) { return "time" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
