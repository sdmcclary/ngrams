<<<<<<< HEAD
public class TCPSession { private enum State { START , SYN_RCVD , SYNACK_ONLY , ESTABLISHED , ESTABLISHED_CLIENTONLY , ESTABLISHED_SERVER_ONLY , CLIENT_CLOSED , SERVER_CLOSED , CLOSED } ; private final TCPSessionKey key ; private TCPAssembler clientToServer ; private TCPAssembler serverToClient ; private final TCPBlockManager blockManager ; private final TCPStreamManager streamManager ; private final TCPReassemblyConfig config ; private final ILogger logger ; private TCP savedSYN ; private State state = State . START ; private long lastActivityTimestamp = 0 ; private final Object sessionTag ; public TCPSession ( TCPSessionKey key , TCPReassemblyConfig config , ILogger logger , long timestamp , Object tag , Collection < IStreamSnifferHandle > streamHandles , Collection < IBlockSnifferHandle > blockHandles ) { this . key = key ; this . config = config ; this . logger = logger ; this . lastActivityTimestamp = timestamp ; this . sessionTag = tag ; if ( blockHandles != null && blockHandles . size ( ) > 0 ) { this . blockManager = new TCPBlockManager ( key , sessionTag , blockHandles ) ; } else { this . blockManager = null ; } if ( streamHandles != null && streamHandles . size ( ) > 0 ) { this . streamManager = new TCPStreamManager ( key , sessionTag , streamHandles ) ; } else { this . streamManager = null ; } } public void unregisterStreamHandle ( IStreamSnifferHandle handle ) { logger . debug ( "Unregister with state = " + state + " for key " + key ) ; if ( streamManager != null ) { streamManager . unregisterHandle ( handle ) ; } } public void unregisterBlockHandle ( IBlockSnifferHandle handle ) { logger . debug ( "Unregister (block) with state = " + state + " for key " + key ) ; if ( blockManager != null ) { blockManager . unregisterHandle ( handle ) ; } } public boolean isClosedOnTimeout ( long currentTimestamp ) { return hasHandshakeTimeoutExpired ( currentTimestamp ) || hasIdleLimitExpired ( currentTimestamp ) || hasReassemblyTimeoutExpired ( currentTimestamp ) || hasClosedTimeoutExpired ( currentTimestamp ) ; } private boolean hasIdleLimitExpired ( long currentTimestamp ) { final int timeout = config . getSessionIdleTimeout ( ) ; if ( timeout == TCPReassemblyConfig . NO_LIMIT ) { return false ; } if ( ( currentTimestamp - lastActivityTimestamp ) > timeout ) { logger . debug ( "Idle timeout expired for " + key ) ; return true ; } else { return false ; } } private boolean hasHandshakeTimeoutExpired ( long currentTimestamp ) { final int timeout = config . getSessionHandshakeTimeout ( ) ; if ( timeout == TCPReassemblyConfig . NO_LIMIT || isHandshakeCompleted ( ) ) return false ; else { if ( ( currentTimestamp - lastActivityTimestamp ) > timeout ) { logger . debug ( "Handshake timeout expired for " + key ) ; return true ; } else { return false ; } } } private boolean isHandshakeCompleted ( ) { return ! ( state == State . START || state == State . SYN_RCVD || state == State . SYNACK_ONLY ) ; } private boolean hasReassemblyTimeoutExpired ( long timestamp ) { switch ( state ) { case ESTABLISHED : return checkEstablishedReassemblyExpired ( timestamp ) ; case ESTABLISHED_CLIENTONLY : return checkOneSidedReassemblyExpired ( clientToServer , timestamp ) ; case ESTABLISHED_SERVER_ONLY : return checkOneSidedReassemblyExpired ( serverToClient , timestamp ) ; } return false ; } private boolean checkEstablishedReassemblyExpired ( long timestamp ) { if ( clientToServer . hasReassemblyExpired ( timestamp ) ) { logger . debug ( "Client side reassembly timed out for " + key ) ; shutdownSession ( ) ; return true ; } else if ( serverToClient . hasReassemblyExpired ( timestamp ) ) { logger . debug ( "Server side reassembly timed out for " + key ) ; shutdownSession ( ) ; return true ; } else { return false ; } } private boolean checkOneSidedReassemblyExpired ( TCPAssembler assembler , long timestamp ) { if ( assembler . hasReassemblyExpired ( timestamp ) ) { logger . debug ( "Reassembly timed out for " + key ) ; shutdownSession ( ) ; return true ; } return false ; } private boolean hasClosedTimeoutExpired ( long currentTimeout ) { final int timeout = config . getSessionCloseTimeout ( ) ; if ( timeout == TCPReassemblyConfig . NO_LIMIT || ! isHalfClosed ( ) ) return false ; else { if ( ( currentTimeout - lastActivityTimestamp ) > timeout ) { logger . debug ( "Closed timeout expired for " + key ) ; return true ; } else { return false ; } } } private boolean isHalfClosed ( ) { return state == State . CLIENT_CLOSED || state == State . SERVER_CLOSED ; } public boolean addSegment ( TCP tcp , long currentTimestamp ) { if ( isClosed ( ) ) { return false ; } if ( tcp . getSourcePort ( ) == key . getClientPort ( ) ) { addClientSegment ( tcp , currentTimestamp ) ; } else if ( tcp . getSourcePort ( ) == key . getServerPort ( ) ) { addServerSegment ( tcp , currentTimestamp ) ; } else { throw new IllegalArgumentException ( "TCP segment does not match this session" ) ; } if ( detectClosed ( ) ) { handleClose ( ) ; } lastActivityTimestamp = currentTimestamp ; return state == State . CLOSED ; } private void addClientSegment ( TCP tcp , long timestamp ) { switch ( state ) { case ESTABLISHED : case ESTABLISHED_CLIENTONLY : case SERVER_CLOSED : clientToServer . addSegment ( tcp , timestamp ) ; while ( ! isClosed ( ) && clientToServer . isDataAvailable ( ) ) { handleClientData ( ) ; } if ( ! isClosed ( ) && clientToServer . isClosed ( ) ) { if ( state == State . ESTABLISHED ) { state = State . CLIENT_CLOSED ; } else { state = State . CLOSED ; } } break ; case SYNACK_ONLY : case CLIENT_CLOSED : break ; case ESTABLISHED_SERVER_ONLY : if ( ( tcp . getFIN ( ) || tcp . getRST ( ) ) && config . canProccessPeerFinForHalfSessions ( ) ) { shutdownSession ( ) ; } break ; case START : if ( tcp . getSYN ( ) && ! tcp . getACK ( ) ) { state = State . SYN_RCVD ; tcp . persist ( ) ; savedSYN = tcp ; } break ; case SYN_RCVD : if ( tcp . getRST ( ) ) { shutdownSession ( ) ; } else if ( ! tcp . getSYN ( ) ) { clientToServer = new TCPAssembler ( savedSYN , config , logger ) ; savedSYN = null ; state = State . ESTABLISHED_CLIENTONLY ; handleEstablished ( SessionType . CLIENT_ONLY ) ; clientToServer . addSegment ( tcp , timestamp ) ; while ( ! isClosed ( ) && clientToServer . isDataAvailable ( ) ) { handleClientData ( ) ; } } break ; default : throw new IllegalStateException ( "Unexpected TCPSession state: " + state ) ; } } private void addServerSegment ( TCP tcp , long timestamp ) { switch ( state ) { case ESTABLISHED : case ESTABLISHED_SERVER_ONLY : case CLIENT_CLOSED : serverToClient . addSegment ( tcp , timestamp ) ; while ( ! isClosed ( ) && serverToClient . isDataAvailable ( ) ) { handleServerData ( ) ; } if ( ! isClosed ( ) && serverToClient . isClosed ( ) ) { if ( state == State . ESTABLISHED ) { state = State . SERVER_CLOSED ; } else { state = State . CLOSED ; } } break ; case ESTABLISHED_CLIENTONLY : if ( ( tcp . getFIN ( ) || tcp . getRST ( ) ) && config . canProccessPeerFinForHalfSessions ( ) ) { shutdownSession ( ) ; } break ; case START : if ( tcp . getSYN ( ) && tcp . getACK ( ) ) { state = State . SYNACK_ONLY ; tcp . persist ( ) ; savedSYN = tcp ; } break ; case SYN_RCVD : if ( tcp . getSYN ( ) && tcp . getACK ( ) ) { clientToServer = new TCPAssembler ( savedSYN , config , logger ) ; savedSYN = null ; serverToClient = new TCPAssembler ( tcp , config , logger ) ; state = State . ESTABLISHED ; handleEstablished ( SessionType . FULL_SESSION ) ; } else if ( tcp . getRST ( ) ) { state = State . CLOSED ; } break ; case SYNACK_ONLY : if ( tcp . getRST ( ) ) { state = State . CLOSED ; } else if ( ! tcp . getSYN ( ) ) { serverToClient = new TCPAssembler ( savedSYN , config , logger ) ; savedSYN = null ; state = State . ESTABLISHED_SERVER_ONLY ; handleEstablished ( SessionType . SERVER_ONLY ) ; serverToClient . addSegment ( tcp , timestamp ) ; while ( ! isClosed ( ) && serverToClient . isDataAvailable ( ) ) { handleServerData ( ) ; } } break ; case SERVER_CLOSED : break ; default : throw new IllegalStateException ( "Unexpected TCPSession state: " + state ) ; } } private void handleEstablished ( IStreamSniffer . SessionType sessionType ) { if ( streamManager != null ) { streamManager . handleEstablished ( sessionType ) ; } if ( ! hasActiveHandlers ( ) ) { shutdownSession ( ) ; } } private void handleClientData ( ) { final ByteBuffer data = clientToServer . getAvailableData ( ) . asReadOnlyBuffer ( ) ; if ( streamManager != null ) { streamManager . handleClientData ( data ) ; } if ( blockManager != null ) { blockManager . addClientData ( data ) ; } if ( ! hasActiveHandlers ( ) || isOverSessionByteLimit ( ) ) { shutdownSession ( ) ; } } private void handleServerData ( ) { final ByteBuffer data = serverToClient . getAvailableData ( ) . asReadOnlyBuffer ( ) ; if ( streamManager != null ) { streamManager . handleServerData ( data ) ; } if ( blockManager != null ) { blockManager . addServerData ( data ) ; } if ( ! hasActiveHandlers ( ) || isOverSessionByteLimit ( ) ) { if ( isOverSessionByteLimit ( ) ) { logger . debug ( "Exceeded session byte limit for " + key ) ; } shutdownSession ( ) ; } } private boolean isOverSessionByteLimit ( ) { final long limit = config . getMaximumSessionBytes ( ) ; if ( limit == TCPReassemblyConfig . NO_LIMIT ) return false ; switch ( state ) { case ESTABLISHED : return clientToServer . getAssembledByteCount ( ) + serverToClient . getAssembledByteCount ( ) >= limit ; case ESTABLISHED_CLIENTONLY : return clientToServer . getAssembledByteCount ( ) >= limit ; case ESTABLISHED_SERVER_ONLY : return serverToClient . getAssembledByteCount ( ) >= limit ; default : return false ; } } private void handleClose ( ) { if ( streamManager != null ) { streamManager . handleClose ( ) ; } shutdownSession ( ) ; } private void shutdownSession ( ) { state = State . CLOSED ; clientToServer = null ; serverToClient = null ; if ( blockManager != null ) { blockManager . shutdown ( ) ; } if ( streamManager != null ) { streamManager . shutdown ( ) ; } } private boolean hasActiveHandlers ( ) { if ( blockManager != null && blockManager . isClosed ( ) == false ) { return true ; } if ( streamManager != null && streamManager . isActive ( ) ) { return true ; } return false ; } public boolean isClosed ( ) { return state == State . CLOSED ; } public TCPSessionKey getSessionKey ( ) { return key ; } private boolean detectClosed ( ) { switch ( state ) { case ESTABLISHED : return ( serverToClient . isClosed ( ) && clientToServer . isClosed ( ) ) || ( serverToClient . isReset ( ) ) || ( clientToServer . isReset ( ) ) ; case ESTABLISHED_CLIENTONLY : return clientToServer . isClosed ( ) ; case ESTABLISHED_SERVER_ONLY : return serverToClient . isClosed ( ) ; } return false ; } } 
=======
class ContextMap { private Object rootValue ; private Object otherValue ; private final Hashtable nameTable = new Hashtable ( ) ; Object get ( Vector context ) { return get ( context , context . size ( ) ) ; } boolean put ( boolean isRoot , Vector names , Object value ) { return put ( isRoot , names , names . size ( ) , value ) ; } private Object get ( Vector context , int len ) { if ( len > 0 ) { ContextMap nestedMap = ( ContextMap ) nameTable . get ( context . elementAt ( len - 1 ) ) ; if ( nestedMap != null ) { Object value = nestedMap . get ( context , len - 1 ) ; if ( value != null ) return value ; } } if ( rootValue != null && len == 0 ) return rootValue ; return otherValue ; } private boolean put ( boolean isRoot , Vector names , int len , Object value ) { if ( len == 0 ) { if ( isRoot ) { if ( rootValue != null ) return false ; rootValue = value ; } else { if ( otherValue != null ) return false ; otherValue = value ; } return true ; } else { Object name = names . elementAt ( len - 1 ) ; ContextMap nestedMap = ( ContextMap ) nameTable . get ( name ) ; if ( nestedMap == null ) { nestedMap = new ContextMap ( ) ; nameTable . put ( name , nestedMap ) ; } return nestedMap . put ( isRoot , names , len - 1 , value ) ; } } public boolean equals ( Object obj ) { if ( ! ( obj instanceof ContextMap ) ) return false ; ContextMap other = ( ContextMap ) obj ; if ( ! Equal . equal ( this . rootValue , other . rootValue ) || ! Equal . equal ( this . otherValue , other . otherValue ) ) return false ; if ( this . nameTable . size ( ) != other . nameTable . size ( ) ) return false ; for ( Enumeration e = nameTable . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; if ( ! nameTable . get ( key ) . equals ( other . nameTable . get ( key ) ) ) return false ; } return true ; } public int hashCode ( ) { int hc = 0 ; if ( rootValue != null ) hc ^= rootValue . hashCode ( ) ; if ( otherValue != null ) hc ^= otherValue . hashCode ( ) ; for ( Enumeration e = nameTable . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; hc ^= key . hashCode ( ) ; hc ^= nameTable . get ( key ) . hashCode ( ) ; } return hc ; } static private class Enumerator implements Enumeration { private Object rootValue ; private Object otherValue ; private Enumeration subMapValues ; private final Enumeration subMaps ; private Enumerator ( ContextMap map ) { rootValue = map . rootValue ; otherValue = map . otherValue ; subMaps = map . nameTable . elements ( ) ; } private void prep ( ) { while ( ( subMapValues == null || ! subMapValues . hasMoreElements ( ) ) && subMaps . hasMoreElements ( ) ) subMapValues = ( ( ContextMap ) subMaps . nextElement ( ) ) . values ( ) ; } public boolean hasMoreElements ( ) { prep ( ) ; return rootValue != null || otherValue != null || ( subMapValues != null && subMapValues . hasMoreElements ( ) ) ; } public Object nextElement ( ) { if ( rootValue != null ) { Object tem = rootValue ; rootValue = null ; return tem ; } if ( otherValue != null ) { Object tem = otherValue ; otherValue = null ; return tem ; } prep ( ) ; if ( subMapValues == null ) throw new NoSuchElementException ( ) ; return subMapValues . nextElement ( ) ; } } Enumeration values ( ) { return new Enumerator ( this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
