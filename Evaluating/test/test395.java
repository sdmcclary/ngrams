<<<<<<< HEAD
public class UseCases extends BenchMark { int ok = 0 , improv = 0 , worse = 0 , fail = 0 ; public UseCases ( ) { this ( new String [ ] { } ) ; } public UseCases ( String [ ] args ) { super ( args , "usecases" ) ; } public void testUseCases ( ) throws IOException { start ( ) ; } public void start ( ) throws IOException { Map dirs = new TreeMap ( ) ; File dbase = new File ( workDir , "b.xml" ) ; File dnew = new File ( workDir , "n.xml" ) ; File ddelta = new File ( workDir , getSetProperty ( "deltafile" , "d.xml" ) ) ; String initer = getSetProperty ( "initer" , null ) ; System . out . println ( "Running " + getClass ( ) . getName ( ) + " test..." ) ; scanDataSets ( dirs , new File ( getSetProperty ( "root" , "." ) ) , getSetProperty ( "dirfilter" , ".*(\\.|\\./tests).*" ) , getSetProperty ( "conffile" , "faxma\\.benchmark\\.UseCases" ) ) ; for ( Iterator i = dirs . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; List l = ( List ) e . getValue ( ) ; if ( l . size ( ) < 1 ) continue ; File dir = ( File ) e . getKey ( ) ; System . setProperty ( "caseroot" , dir . toString ( ) ) ; File conffile = new File ( dir , ( String ) l . get ( 0 ) ) ; Properties p = new Properties ( ) ; FileInputStream cin = new FileInputStream ( conffile ) ; p . load ( cin ) ; cin . close ( ) ; for ( int test = 0 ; test < Integer . MAX_VALUE ; test ++ ) { String pfx = test == 0 ? "" : String . valueOf ( test ) + "." ; if ( p . getProperty ( pfx + "basec" ) == null && p . getProperty ( pfx + "base" ) == null ) break ; if ( p . getProperty ( pfx + "base" ) == null ) { Log . warning ( "Skipping compressed case " + ( test + 1 ) + " in " + dir ) ; continue ; } System . setProperty ( "name" , p . getProperty ( pfx + "name" ) ) ; int laps = getSetProperty ( "laps" , 1 ) ; getFile ( p , pfx + "basec" , dir , new File ( "" ) , "basecfile" ) ; getFile ( p , pfx + "newc" , dir , new File ( "" ) , "newcfile" ) ; File basef = getFile ( p , pfx + "base" , dir , dbase , "basefile" ) ; File newf = getFile ( p , pfx + "new" , dir , dnew , "newfile" ) ; File deltaf = getFile ( p , pfx + "delta" , dir , ddelta , "deltafile" ) ; if ( initer != null ) { System . setProperty ( "mode" , "init" ) ; exec ( initer , new String [ ] { } , false , null , Long . MAX_VALUE ) ; } for ( int lap = 0 ; lap < laps ; lap ++ ) { System . setProperty ( "lap" , "" + lap ) ; doDiff ( basef , newf , deltaf ) ; } } } System . out . println ( "--------------------------------------------------" ) ; System . out . println ( "Better\tOK\tWorse\tFail" ) ; System . out . println ( "" + improv + "\t" + ok + "\t" + worse + "\t" + fail ) ; if ( worse > 0 || fail > 0 ) System . out . println ( "Result became worse, please do not check in." ) ; if ( fail > 0 ) Assert . fail ( "Test failed due to new failures." ) ; } protected File getFile ( Properties p , String prop , File propRoot , File defaultFile , String sysprop ) { String name = p . getProperty ( prop ) ; File f = name == null ? defaultFile : new File ( propRoot , name . trim ( ) ) ; if ( f != null && sysprop != null ) System . setProperty ( sysprop , f . toString ( ) ) ; return f ; } protected void doDiff ( File basef , File newf , File deltaf ) throws IOException { String reporter = getSetProperty ( "reporter" , null ) ; long now = System . currentTimeMillis ( ) ; try { exec ( getSetProperty ( "differ" , "!fc.xml.diff.Diff" ) , new String [ ] { basef . toString ( ) , newf . toString ( ) , deltaf . toString ( ) } , true , getSetProperty ( "logfile" , null ) , ( long ) ( 1000 * getSetProperty ( "timeout" , 1000000000.0 ) ) ) ; } catch ( Exception ex ) { fail ++ ; Log . log ( "FAILED: " , LogLevels . ERROR , ex ) ; return ; } System . setProperty ( "lap.time" , String . valueOf ( System . currentTimeMillis ( ) - now ) ) ; if ( reporter != null ) { System . setProperty ( "mode" , "report" ) ; exec ( reporter , new String [ ] { } , false , null , Long . MAX_VALUE ) ; } ok ++ ; } public static void scanDataSets ( Map dirs , File root , String df , String ff ) { if ( root . isDirectory ( ) ) { File e [ ] = root . listFiles ( ) ; for ( int i = 0 ; i < e . length ; i ++ ) { if ( e [ i ] . getPath ( ) . matches ( df ) ) scanDataSets ( dirs , e [ i ] , df , ff ) ; } } else if ( root . getName ( ) . matches ( ff ) ) { File dir = root . getParentFile ( ) ; List l = ( List ) dirs . get ( dir ) ; if ( l == null ) { l = new LinkedList ( ) ; dirs . put ( dir , l ) ; } l . add ( root . getName ( ) ) ; Collections . sort ( l ) ; } } public static void main ( String [ ] args ) throws IOException { new UseCases ( args ) . start ( ) ; } } 
=======
public final class Name { final private String namespaceUri ; final private String localName ; final private int hc ; public Name ( String namespaceUri , String localName ) { this . namespaceUri = namespaceUri ; this . localName = localName ; this . hc = namespaceUri . hashCode ( ) ^ localName . hashCode ( ) ; } public String getNamespaceUri ( ) { return namespaceUri ; } public String getLocalName ( ) { return localName ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof Name ) ) return false ; Name other = ( Name ) obj ; return ( this . hc == other . hc && this . namespaceUri . equals ( other . namespaceUri ) && this . localName . equals ( other . localName ) ) ; } public int hashCode ( ) { return hc ; } static public int compare ( Name n1 , Name n2 ) { int ret = n1 . namespaceUri . compareTo ( n2 . namespaceUri ) ; if ( ret != 0 ) return ret ; return n1 . localName . compareTo ( n2 . localName ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
