<<<<<<< HEAD
public class GitCommand { public static RepositoryRevision . Walk getLogMessages ( String rootPath , Set < File > files , String fromRevision , String toRevision , boolean showMerges , OutputLogger logger ) { File root = new File ( rootPath ) ; Repository repo = Git . getInstance ( ) . getRepository ( root ) ; RepositoryRevision . Walk walk = new RepositoryRevision . Walk ( repo ) ; try { if ( fromRevision == null ) { fromRevision = Constants . HEAD ; } ObjectId from = repo . resolve ( fromRevision ) ; if ( from == null ) { return null ; } walk . markStart ( walk . parseCommit ( from ) ) ; ObjectId to = toRevision != null ? repo . resolve ( toRevision ) : null ; if ( to != null ) { walk . markUninteresting ( walk . parseCommit ( to ) ) ; } List < PathFilter > paths = new ArrayList < PathFilter > ( ) ; for ( File file : files ) { String path = getRelative ( root , file ) ; if ( ! ( path . length ( ) == 0 ) ) { paths . add ( PathFilter . create ( path ) ) ; } } if ( ! paths . isEmpty ( ) ) { walk . setTreeFilter ( PathFilterGroup . create ( paths ) ) ; } if ( ! showMerges ) { walk . setRevFilter ( RevFilter . NO_MERGES ) ; } } catch ( IOException ioe ) { return null ; } return walk ; } public static List < String [ ] > getRevisions ( File root , int limit ) { return getRevisionsForFile ( root , null , limit ) ; } public static List < String [ ] > getRevisionsForFile ( File root , File [ ] files , int limit ) { Repository repo = Git . getInstance ( ) . getRepository ( root ) ; RevWalk walk = new RevWalk ( repo ) ; List < String [ ] > revs = new ArrayList < String [ ] > ( ) ; try { ObjectId from = repo . resolve ( Constants . HEAD ) ; if ( from == null ) { return null ; } walk . markStart ( walk . parseCommit ( from ) ) ; if ( files != null ) { List < PathFilter > paths = new ArrayList < PathFilter > ( ) ; for ( File file : files ) { String path = getRelative ( root , file ) ; if ( ! ( path . length ( ) == 0 ) ) { paths . add ( PathFilter . create ( path ) ) ; } } if ( ! paths . isEmpty ( ) ) { walk . setTreeFilter ( PathFilterGroup . create ( paths ) ) ; } } for ( RevCommit rev : walk ) { revs . add ( new String [ ] { rev . getShortMessage ( ) , rev . getId ( ) . name ( ) } ) ; if ( -- limit <= 0 ) { break ; } } } catch ( IOException ioe ) { } return revs ; } private static String getRelative ( File root , File dir ) { return getRelative ( root . getAbsolutePath ( ) , dir . getAbsolutePath ( ) ) ; } private static String getRelative ( String root , String dir ) { if ( dir . equals ( root ) ) { return "" ; } return dir . replace ( root + File . separator , "" ) ; } private static void put ( Set < String > set , String relPath , Map < File , StatusInfo > files , File root , int status ) { for ( String path : set ) { if ( relPath . length ( ) > 0 && ! path . startsWith ( relPath ) ) { continue ; } File file = new File ( root , path ) ; files . put ( file , new StatusInfo ( status , null , false ) ) ; } } public static Map < File , StatusInfo > getAllStatus ( File root , File dir ) throws IOException { String relPath = getRelative ( root , dir ) ; Repository repo = Git . getInstance ( ) . getRepository ( root ) ; Map < File , StatusInfo > files = new HashMap < File , StatusInfo > ( ) ; try { IndexDiff index = new IndexDiff ( repo ) ; index . diff ( ) ; put ( index . getAdded ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_ADDEDLOCALLY ) ; put ( index . getRemoved ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_REMOVEDLOCALLY ) ; put ( index . getMissing ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_DELETEDLOCALLY ) ; put ( index . getChanged ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY ) ; put ( index . getModified ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY ) ; final FileTreeIterator workTree = new FileTreeIterator ( repo . getWorkDir ( ) ) ; final TreeWalk walk = new TreeWalk ( repo ) ; DirCache cache = DirCache . read ( repo ) ; walk . reset ( ) ; walk . setRecursive ( true ) ; walk . addTree ( workTree ) ; int share = SharabilityQuery . getSharability ( dir ) ; if ( share == SharabilityQuery . NOT_SHARABLE ) { return files ; } while ( walk . next ( ) ) { String path = walk . getPathString ( ) ; if ( relPath . length ( ) > 0 && ! path . startsWith ( relPath ) ) { continue ; } if ( index . getAdded ( ) . contains ( path ) || index . getRemoved ( ) . contains ( path ) || index . getMissing ( ) . contains ( path ) || index . getChanged ( ) . contains ( path ) || index . getModified ( ) . contains ( path ) ) { continue ; } DirCacheEntry entry = cache . getEntry ( path ) ; File file = new File ( root , path ) ; int status ; if ( entry != null ) { status = StatusInfo . STATUS_VERSIONED_UPTODATE ; } else { if ( share == SharabilityQuery . MIXED && SharabilityQuery . getSharability ( file ) == SharabilityQuery . NOT_SHARABLE ) { continue ; } status = StatusInfo . STATUS_NOTVERSIONED_NEWLOCALLY ; } files . put ( file , new StatusInfo ( status , null , false ) ) ; } } catch ( IOException ex ) { Exceptions . printStackTrace ( ex ) ; } return files ; } public static Map < File , StatusInfo > getInterestingStatus ( File root , File dir ) { String relPath = getRelative ( root , dir ) ; Repository repo = Git . getInstance ( ) . getRepository ( root ) ; IndexDiff index ; Map < File , StatusInfo > files = new HashMap < File , StatusInfo > ( ) ; try { index = new IndexDiff ( repo ) ; index . diff ( ) ; put ( index . getAdded ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_ADDEDLOCALLY ) ; put ( index . getRemoved ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_REMOVEDLOCALLY ) ; put ( index . getMissing ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_DELETEDLOCALLY ) ; put ( index . getChanged ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY ) ; put ( index . getModified ( ) , relPath , files , root , StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY ) ; final FileTreeIterator workTree = new FileTreeIterator ( repo . getWorkDir ( ) ) ; final TreeWalk walk = new TreeWalk ( repo ) ; walk . reset ( ) ; walk . setRecursive ( true ) ; walk . addTree ( workTree ) ; DirCache cache = DirCache . read ( repo ) ; while ( walk . next ( ) ) { String path = walk . getPathString ( ) ; if ( relPath . length ( ) > 0 && ! path . startsWith ( relPath ) ) { continue ; } if ( index . getAdded ( ) . contains ( path ) || index . getRemoved ( ) . contains ( path ) || index . getMissing ( ) . contains ( path ) || index . getChanged ( ) . contains ( path ) || index . getModified ( ) . contains ( path ) ) { continue ; } DirCacheEntry entry = cache . getEntry ( path ) ; if ( entry != null ) { continue ; } int status = StatusInfo . STATUS_NOTVERSIONED_NEWLOCALLY ; File file = new File ( root , path ) ; files . put ( file , new StatusInfo ( status , null , false ) ) ; } } catch ( IOException ex ) { Exceptions . printStackTrace ( ex ) ; } return files ; } public static StatusInfo getSingleStatus ( File root , File file ) { Repository repo = Git . getInstance ( ) . getRepository ( root ) ; IndexDiff index ; int share = SharabilityQuery . getSharability ( file . getParentFile ( ) ) ; if ( share == SharabilityQuery . NOT_SHARABLE || ( share == SharabilityQuery . MIXED && SharabilityQuery . getSharability ( file ) == SharabilityQuery . NOT_SHARABLE ) ) { return new StatusInfo ( StatusInfo . STATUS_NOTVERSIONED_EXCLUDED , null , false ) ; } int status = StatusInfo . STATUS_UNKNOWN ; String name = getRelative ( root , file ) ; try { index = new IndexDiff ( repo ) ; index . diff ( ) ; } catch ( IOException ex ) { Exceptions . printStackTrace ( ex ) ; return new StatusInfo ( status , null , false ) ; } if ( index . getAdded ( ) . contains ( name ) ) { status = StatusInfo . STATUS_VERSIONED_ADDEDLOCALLY ; } else if ( index . getRemoved ( ) . contains ( name ) ) { status = StatusInfo . STATUS_VERSIONED_REMOVEDLOCALLY ; } else if ( index . getMissing ( ) . contains ( name ) ) { status = StatusInfo . STATUS_VERSIONED_DELETEDLOCALLY ; } else if ( index . getChanged ( ) . contains ( name ) ) { status = StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY ; } else if ( index . getModified ( ) . contains ( name ) ) { status = StatusInfo . STATUS_VERSIONED_MODIFIEDLOCALLY ; } else { status = StatusInfo . STATUS_VERSIONED_UPTODATE ; } StatusInfo info = new StatusInfo ( status , null , false ) ; return info ; } } 
=======
public class RegexSyntaxException extends Exception { private final int position ; static public final int UNKNOWN_POSITION = - 1 ; public RegexSyntaxException ( String detail ) { this ( detail , UNKNOWN_POSITION ) ; } public RegexSyntaxException ( String detail , int position ) { super ( detail ) ; this . position = position ; } public int getPosition ( ) { return position ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
