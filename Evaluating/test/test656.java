public class AWSAuthConnection { public static final String LOCATION_DEFAULT = null ; public static final String LOCATION_EU = "EU" ; private String awsAccessKeyId ; private String awsSecretAccessKey ; private boolean isSecure ; private String server ; private int port ; private CallingFormat callingFormat ; public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey ) { this ( awsAccessKeyId , awsSecretAccessKey , true ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , Utils . DEFAULT_HOST ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , server , isSecure ? Utils . SECURE_PORT : Utils . INSECURE_PORT ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server , int port ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , server , port , CallingFormat . getSubdomainCallingFormat ( ) ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server , CallingFormat format ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , server , isSecure ? Utils . SECURE_PORT : Utils . INSECURE_PORT , format ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server , int port , CallingFormat format ) { this . awsAccessKeyId = awsAccessKeyId ; this . awsSecretAccessKey = awsSecretAccessKey ; this . isSecure = isSecure ; this . server = server ; this . port = port ; this . callingFormat = format ; } public Response createBucket ( String bucket , Map headers ) throws MalformedURLException , IOException { return createBucket ( bucket , null , headers ) ; } public Response createBucket ( String bucket , String location , Map headers ) throws MalformedURLException , IOException { String body ; if ( location == null ) { body = null ; } else if ( LOCATION_EU . equals ( location ) ) { if ( ! callingFormat . supportsLocatedBuckets ( ) ) throw new IllegalArgumentException ( "Creating location-constrained bucket with unsupported calling-format" ) ; body = "<CreateBucketConstraint><LocationConstraint>" + location + "</LocationConstraint></CreateBucketConstraint>" ; } else throw new IllegalArgumentException ( "Invalid Location: " + location ) ; if ( ! Utils . validateBucketName ( bucket , callingFormat , location != null ) ) throw new IllegalArgumentException ( "Invalid Bucket Name: " + bucket ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , "" , null , headers ) ; if ( body != null ) { request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( body . getBytes ( "UTF-8" ) ) ; } return new Response ( request ) ; } public boolean checkBucketExists ( String bucket ) throws MalformedURLException , IOException { HttpURLConnection response = makeRequest ( "HEAD" , bucket , "" , null , null ) ; int httpCode = response . getResponseCode ( ) ; return httpCode >= 200 && httpCode < 300 ; } public ListBucketResponse listBucket ( String bucket , String prefix , String marker , Integer maxKeys , Map headers ) throws MalformedURLException , IOException { return listBucket ( bucket , prefix , marker , maxKeys , null , headers ) ; } public ListBucketResponse listBucket ( String bucket , String prefix , String marker , Integer maxKeys , String delimiter , Map headers ) throws MalformedURLException , IOException { Map pathArgs = Utils . paramsForListOptions ( prefix , marker , maxKeys , delimiter ) ; return new ListBucketResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , headers ) ) ; } public Response deleteBucket ( String bucket , Map headers ) throws MalformedURLException , IOException { return new Response ( makeRequest ( "DELETE" , bucket , "" , null , headers ) ) ; } public Response put ( String bucket , String key , S3Object object , Map headers ) throws MalformedURLException , IOException { HttpURLConnection request = makeRequest ( "PUT" , bucket , Utils . urlencode ( key ) , null , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public HttpURLConnection putRaw ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { HttpURLConnection request = makeRequest ( "PUT" , bucket , Utils . urlencode ( key ) , null , headers ) ; request . setDoOutput ( true ) ; return request ; } public Response copy ( String sourceBucket , String sourceKey , String destinationBucket , String destinationKey , Map headers ) throws MalformedURLException , IOException { S3Object object = new S3Object ( new byte [ ] { } , new HashMap ( ) ) ; headers = headers == null ? new HashMap ( ) : new HashMap ( headers ) ; headers . put ( "x-amz-copy-source" , Arrays . asList ( new String [ ] { sourceBucket + "/" + sourceKey } ) ) ; headers . put ( "x-amz-metadata-directive" , Arrays . asList ( new String [ ] { "COPY" } ) ) ; return verifyCopy ( put ( destinationBucket , destinationKey , object , headers ) ) ; } public Response copy ( String sourceBucket , String sourceKey , String destinationBucket , String destinationKey , Map metadata , Map headers ) throws MalformedURLException , IOException { S3Object object = new S3Object ( new byte [ ] { } , metadata ) ; headers = headers == null ? new HashMap ( ) : new HashMap ( headers ) ; headers . put ( "x-amz-copy-source" , Arrays . asList ( new String [ ] { sourceBucket + "/" + sourceKey } ) ) ; headers . put ( "x-amz-metadata-directive" , Arrays . asList ( new String [ ] { "REPLACE" } ) ) ; return verifyCopy ( put ( destinationBucket , destinationKey , object , headers ) ) ; } private Response verifyCopy ( Response response ) throws IOException { if ( response . connection . getResponseCode ( ) < 400 ) { byte [ ] body = GetResponse . slurpInputStream ( response . connection . getInputStream ( ) ) ; String message = new String ( body ) ; if ( message . indexOf ( "<Error" ) != - 1 ) { throw new IOException ( message . substring ( message . indexOf ( "<Error" ) ) ) ; } else if ( message . indexOf ( "</CopyObjectResult>" ) != - 1 ) { } else { throw new IOException ( "Unexpected response: " + message ) ; } } return response ; } public GetResponse get ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return new GetResponse ( makeRequest ( "GET" , bucket , Utils . urlencode ( key ) , null , headers ) ) ; } public HttpURLConnection getRaw ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return makeRequest ( "GET" , bucket , Utils . urlencode ( key ) , null , headers ) ; } public HttpURLConnection head ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return makeRequest ( "HEAD" , bucket , Utils . urlencode ( key ) , null , headers ) ; } public Response delete ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return new Response ( makeRequest ( "DELETE" , bucket , Utils . urlencode ( key ) , null , headers ) ) ; } public GetResponse getBucketRequestPayment ( String bucket , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "requestPayment" , null ) ; return new GetResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , headers ) ) ; } public Response putBucketRequestPayment ( String bucket , String requestPaymentXMLDoc , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "requestPayment" , null ) ; S3Object object = new S3Object ( requestPaymentXMLDoc . getBytes ( ) , null ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , "" , pathArgs , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public GetResponse getBucketLogging ( String bucket , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "logging" , null ) ; return new GetResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , headers ) ) ; } public Response putBucketLogging ( String bucket , String loggingXMLDoc , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "logging" , null ) ; S3Object object = new S3Object ( loggingXMLDoc . getBytes ( ) , null ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , "" , pathArgs , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public GetResponse getBucketACL ( String bucket , Map headers ) throws MalformedURLException , IOException { return getACL ( bucket , "" , headers ) ; } public GetResponse getACL ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { if ( key == null ) key = "" ; Map pathArgs = new HashMap ( ) ; pathArgs . put ( "acl" , null ) ; return new GetResponse ( makeRequest ( "GET" , bucket , Utils . urlencode ( key ) , pathArgs , headers ) ) ; } public Response putBucketACL ( String bucket , String aclXMLDoc , Map headers ) throws MalformedURLException , IOException { return putACL ( bucket , "" , aclXMLDoc , headers ) ; } public Response putACL ( String bucket , String key , String aclXMLDoc , Map headers ) throws MalformedURLException , IOException { S3Object object = new S3Object ( aclXMLDoc . getBytes ( ) , null ) ; Map pathArgs = new HashMap ( ) ; pathArgs . put ( "acl" , null ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , Utils . urlencode ( key ) , pathArgs , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public LocationResponse getBucketLocation ( String bucket ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "location" , null ) ; return new LocationResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , null ) ) ; } public ListAllMyBucketsResponse listAllMyBuckets ( Map headers ) throws MalformedURLException , IOException { return new ListAllMyBucketsResponse ( makeRequest ( "GET" , "" , "" , null , headers ) ) ; } private HttpURLConnection makeRequest ( String method , String bucketName , String key , Map pathArgs , Map headers ) throws MalformedURLException , IOException { return makeRequest ( method , bucketName , key , pathArgs , headers , null ) ; } private HttpURLConnection makeRequest ( String method , String bucket , String key , Map pathArgs , Map headers , S3Object object ) throws MalformedURLException , IOException { CallingFormat callingFormat = Utils . getCallingFormatForBucket ( this . callingFormat , bucket ) ; if ( isSecure && callingFormat != CallingFormat . getPathCallingFormat ( ) && bucket . indexOf ( "." ) != - 1 ) { System . err . println ( "You are making an SSL connection, however, the bucket contains periods and the wildcard certificate will not match by default.  Please consider using HTTP." ) ; } URL url = callingFormat . getURL ( isSecure , server , this . port , bucket , key , pathArgs ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( method ) ; if ( ! connection . getInstanceFollowRedirects ( ) && callingFormat . supportsLocatedBuckets ( ) ) throw new RuntimeException ( "HTTP redirect support required." ) ; addHeaders ( connection , headers ) ; if ( object != null ) addMetadataHeaders ( connection , object . metadata ) ; addAuthHeader ( connection , method , bucket , key , pathArgs ) ; return connection ; } private void addHeaders ( HttpURLConnection connection , Map headers ) { addHeaders ( connection , headers , "" ) ; } private void addMetadataHeaders ( HttpURLConnection connection , Map metadata ) { addHeaders ( connection , metadata , Utils . METADATA_PREFIX ) ; } private void addHeaders ( HttpURLConnection connection , Map headers , String prefix ) { if ( headers != null ) { for ( Iterator i = headers . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; for ( Iterator j = ( ( List ) headers . get ( key ) ) . iterator ( ) ; j . hasNext ( ) ; ) { String value = ( String ) j . next ( ) ; connection . addRequestProperty ( prefix + key , value ) ; } } } } private void addAuthHeader ( HttpURLConnection connection , String method , String bucket , String key , Map pathArgs ) { if ( connection . getRequestProperty ( "Date" ) == null ) { connection . setRequestProperty ( "Date" , httpDate ( ) ) ; } if ( connection . getRequestProperty ( "Content-Type" ) == null ) { connection . setRequestProperty ( "Content-Type" , "" ) ; } String canonicalString = Utils . makeCanonicalString ( method , bucket , key , pathArgs , connection . getRequestProperties ( ) ) ; String encodedCanonical = Utils . encode ( this . awsSecretAccessKey , canonicalString , false ) ; connection . setRequestProperty ( "Authorization" , "AWS " + this . awsAccessKeyId + ":" + encodedCanonical ) ; } public static String httpDate ( ) { final String DateFormat = "EEE, dd MMM yyyy HH:mm:ss " ; SimpleDateFormat format = new SimpleDateFormat ( DateFormat , Locale . US ) ; format . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return format . format ( new Date ( ) ) + "GMT" ; } } 