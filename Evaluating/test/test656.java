<<<<<<< HEAD
public class AWSAuthConnection { public static final String LOCATION_DEFAULT = null ; public static final String LOCATION_EU = "EU" ; private String awsAccessKeyId ; private String awsSecretAccessKey ; private boolean isSecure ; private String server ; private int port ; private CallingFormat callingFormat ; public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey ) { this ( awsAccessKeyId , awsSecretAccessKey , true ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , Utils . DEFAULT_HOST ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , server , isSecure ? Utils . SECURE_PORT : Utils . INSECURE_PORT ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server , int port ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , server , port , CallingFormat . getSubdomainCallingFormat ( ) ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server , CallingFormat format ) { this ( awsAccessKeyId , awsSecretAccessKey , isSecure , server , isSecure ? Utils . SECURE_PORT : Utils . INSECURE_PORT , format ) ; } public AWSAuthConnection ( String awsAccessKeyId , String awsSecretAccessKey , boolean isSecure , String server , int port , CallingFormat format ) { this . awsAccessKeyId = awsAccessKeyId ; this . awsSecretAccessKey = awsSecretAccessKey ; this . isSecure = isSecure ; this . server = server ; this . port = port ; this . callingFormat = format ; } public Response createBucket ( String bucket , Map headers ) throws MalformedURLException , IOException { return createBucket ( bucket , null , headers ) ; } public Response createBucket ( String bucket , String location , Map headers ) throws MalformedURLException , IOException { String body ; if ( location == null ) { body = null ; } else if ( LOCATION_EU . equals ( location ) ) { if ( ! callingFormat . supportsLocatedBuckets ( ) ) throw new IllegalArgumentException ( "Creating location-constrained bucket with unsupported calling-format" ) ; body = "<CreateBucketConstraint><LocationConstraint>" + location + "</LocationConstraint></CreateBucketConstraint>" ; } else throw new IllegalArgumentException ( "Invalid Location: " + location ) ; if ( ! Utils . validateBucketName ( bucket , callingFormat , location != null ) ) throw new IllegalArgumentException ( "Invalid Bucket Name: " + bucket ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , "" , null , headers ) ; if ( body != null ) { request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( body . getBytes ( "UTF-8" ) ) ; } return new Response ( request ) ; } public boolean checkBucketExists ( String bucket ) throws MalformedURLException , IOException { HttpURLConnection response = makeRequest ( "HEAD" , bucket , "" , null , null ) ; int httpCode = response . getResponseCode ( ) ; return httpCode >= 200 && httpCode < 300 ; } public ListBucketResponse listBucket ( String bucket , String prefix , String marker , Integer maxKeys , Map headers ) throws MalformedURLException , IOException { return listBucket ( bucket , prefix , marker , maxKeys , null , headers ) ; } public ListBucketResponse listBucket ( String bucket , String prefix , String marker , Integer maxKeys , String delimiter , Map headers ) throws MalformedURLException , IOException { Map pathArgs = Utils . paramsForListOptions ( prefix , marker , maxKeys , delimiter ) ; return new ListBucketResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , headers ) ) ; } public Response deleteBucket ( String bucket , Map headers ) throws MalformedURLException , IOException { return new Response ( makeRequest ( "DELETE" , bucket , "" , null , headers ) ) ; } public Response put ( String bucket , String key , S3Object object , Map headers ) throws MalformedURLException , IOException { HttpURLConnection request = makeRequest ( "PUT" , bucket , Utils . urlencode ( key ) , null , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public HttpURLConnection putRaw ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { HttpURLConnection request = makeRequest ( "PUT" , bucket , Utils . urlencode ( key ) , null , headers ) ; request . setDoOutput ( true ) ; return request ; } public Response copy ( String sourceBucket , String sourceKey , String destinationBucket , String destinationKey , Map headers ) throws MalformedURLException , IOException { S3Object object = new S3Object ( new byte [ ] { } , new HashMap ( ) ) ; headers = headers == null ? new HashMap ( ) : new HashMap ( headers ) ; headers . put ( "x-amz-copy-source" , Arrays . asList ( new String [ ] { sourceBucket + "/" + sourceKey } ) ) ; headers . put ( "x-amz-metadata-directive" , Arrays . asList ( new String [ ] { "COPY" } ) ) ; return verifyCopy ( put ( destinationBucket , destinationKey , object , headers ) ) ; } public Response copy ( String sourceBucket , String sourceKey , String destinationBucket , String destinationKey , Map metadata , Map headers ) throws MalformedURLException , IOException { S3Object object = new S3Object ( new byte [ ] { } , metadata ) ; headers = headers == null ? new HashMap ( ) : new HashMap ( headers ) ; headers . put ( "x-amz-copy-source" , Arrays . asList ( new String [ ] { sourceBucket + "/" + sourceKey } ) ) ; headers . put ( "x-amz-metadata-directive" , Arrays . asList ( new String [ ] { "REPLACE" } ) ) ; return verifyCopy ( put ( destinationBucket , destinationKey , object , headers ) ) ; } private Response verifyCopy ( Response response ) throws IOException { if ( response . connection . getResponseCode ( ) < 400 ) { byte [ ] body = GetResponse . slurpInputStream ( response . connection . getInputStream ( ) ) ; String message = new String ( body ) ; if ( message . indexOf ( "<Error" ) != - 1 ) { throw new IOException ( message . substring ( message . indexOf ( "<Error" ) ) ) ; } else if ( message . indexOf ( "</CopyObjectResult>" ) != - 1 ) { } else { throw new IOException ( "Unexpected response: " + message ) ; } } return response ; } public GetResponse get ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return new GetResponse ( makeRequest ( "GET" , bucket , Utils . urlencode ( key ) , null , headers ) ) ; } public HttpURLConnection getRaw ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return makeRequest ( "GET" , bucket , Utils . urlencode ( key ) , null , headers ) ; } public HttpURLConnection head ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return makeRequest ( "HEAD" , bucket , Utils . urlencode ( key ) , null , headers ) ; } public Response delete ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return new Response ( makeRequest ( "DELETE" , bucket , Utils . urlencode ( key ) , null , headers ) ) ; } public GetResponse getBucketRequestPayment ( String bucket , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "requestPayment" , null ) ; return new GetResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , headers ) ) ; } public Response putBucketRequestPayment ( String bucket , String requestPaymentXMLDoc , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "requestPayment" , null ) ; S3Object object = new S3Object ( requestPaymentXMLDoc . getBytes ( ) , null ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , "" , pathArgs , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public GetResponse getBucketLogging ( String bucket , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "logging" , null ) ; return new GetResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , headers ) ) ; } public Response putBucketLogging ( String bucket , String loggingXMLDoc , Map headers ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "logging" , null ) ; S3Object object = new S3Object ( loggingXMLDoc . getBytes ( ) , null ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , "" , pathArgs , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public GetResponse getBucketACL ( String bucket , Map headers ) throws MalformedURLException , IOException { return getACL ( bucket , "" , headers ) ; } public GetResponse getACL ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { if ( key == null ) key = "" ; Map pathArgs = new HashMap ( ) ; pathArgs . put ( "acl" , null ) ; return new GetResponse ( makeRequest ( "GET" , bucket , Utils . urlencode ( key ) , pathArgs , headers ) ) ; } public Response putBucketACL ( String bucket , String aclXMLDoc , Map headers ) throws MalformedURLException , IOException { return putACL ( bucket , "" , aclXMLDoc , headers ) ; } public Response putACL ( String bucket , String key , String aclXMLDoc , Map headers ) throws MalformedURLException , IOException { S3Object object = new S3Object ( aclXMLDoc . getBytes ( ) , null ) ; Map pathArgs = new HashMap ( ) ; pathArgs . put ( "acl" , null ) ; HttpURLConnection request = makeRequest ( "PUT" , bucket , Utils . urlencode ( key ) , pathArgs , headers , object ) ; request . setDoOutput ( true ) ; request . getOutputStream ( ) . write ( object . data == null ? new byte [ ] { } : object . data ) ; return new Response ( request ) ; } public LocationResponse getBucketLocation ( String bucket ) throws MalformedURLException , IOException { Map pathArgs = new HashMap ( ) ; pathArgs . put ( "location" , null ) ; return new LocationResponse ( makeRequest ( "GET" , bucket , "" , pathArgs , null ) ) ; } public ListAllMyBucketsResponse listAllMyBuckets ( Map headers ) throws MalformedURLException , IOException { return new ListAllMyBucketsResponse ( makeRequest ( "GET" , "" , "" , null , headers ) ) ; } private HttpURLConnection makeRequest ( String method , String bucketName , String key , Map pathArgs , Map headers ) throws MalformedURLException , IOException { return makeRequest ( method , bucketName , key , pathArgs , headers , null ) ; } private HttpURLConnection makeRequest ( String method , String bucket , String key , Map pathArgs , Map headers , S3Object object ) throws MalformedURLException , IOException { CallingFormat callingFormat = Utils . getCallingFormatForBucket ( this . callingFormat , bucket ) ; if ( isSecure && callingFormat != CallingFormat . getPathCallingFormat ( ) && bucket . indexOf ( "." ) != - 1 ) { System . err . println ( "You are making an SSL connection, however, the bucket contains periods and the wildcard certificate will not match by default.  Please consider using HTTP." ) ; } URL url = callingFormat . getURL ( isSecure , server , this . port , bucket , key , pathArgs ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( method ) ; if ( ! connection . getInstanceFollowRedirects ( ) && callingFormat . supportsLocatedBuckets ( ) ) throw new RuntimeException ( "HTTP redirect support required." ) ; addHeaders ( connection , headers ) ; if ( object != null ) addMetadataHeaders ( connection , object . metadata ) ; addAuthHeader ( connection , method , bucket , key , pathArgs ) ; return connection ; } private void addHeaders ( HttpURLConnection connection , Map headers ) { addHeaders ( connection , headers , "" ) ; } private void addMetadataHeaders ( HttpURLConnection connection , Map metadata ) { addHeaders ( connection , metadata , Utils . METADATA_PREFIX ) ; } private void addHeaders ( HttpURLConnection connection , Map headers , String prefix ) { if ( headers != null ) { for ( Iterator i = headers . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; for ( Iterator j = ( ( List ) headers . get ( key ) ) . iterator ( ) ; j . hasNext ( ) ; ) { String value = ( String ) j . next ( ) ; connection . addRequestProperty ( prefix + key , value ) ; } } } } private void addAuthHeader ( HttpURLConnection connection , String method , String bucket , String key , Map pathArgs ) { if ( connection . getRequestProperty ( "Date" ) == null ) { connection . setRequestProperty ( "Date" , httpDate ( ) ) ; } if ( connection . getRequestProperty ( "Content-Type" ) == null ) { connection . setRequestProperty ( "Content-Type" , "" ) ; } String canonicalString = Utils . makeCanonicalString ( method , bucket , key , pathArgs , connection . getRequestProperties ( ) ) ; String encodedCanonical = Utils . encode ( this . awsSecretAccessKey , canonicalString , false ) ; connection . setRequestProperty ( "Authorization" , "AWS " + this . awsAccessKeyId + ":" + encodedCanonical ) ; } public static String httpDate ( ) { final String DateFormat = "EEE, dd MMM yyyy HH:mm:ss " ; SimpleDateFormat format = new SimpleDateFormat ( DateFormat , Locale . US ) ; format . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return format . format ( new Date ( ) ) + "GMT" ; } } 
=======
public class ReverseHttpServer extends HttpServer { private String label ; private URL nextReq ; private URL location ; private URL serverAddress ; private String token ; private int leaseSeconds ; private int failureDelay ; private PropertyChangeSupport support ; public ReverseHttpServer ( String label , URL serverAddress , RequestHandler handler ) { super ( handler ) ; this . label = label ; this . nextReq = null ; this . location = null ; this . serverAddress = serverAddress ; this . handler = handler ; this . token = "-" ; this . leaseSeconds = 30 ; this . support = new PropertyChangeSupport ( this ) ; } public int getFailureDelay ( ) { return failureDelay ; } public void setFailureDelay ( int failureDelay ) { this . failureDelay = failureDelay ; } protected URL getNextReq ( ) { return nextReq ; } public String getToken ( ) { return token ; } public void setToken ( String token ) { this . token = token ; } public int getLeaseSeconds ( ) { return leaseSeconds ; } public void setLeaseSeconds ( int leaseSeconds ) { this . leaseSeconds = leaseSeconds ; } @ Override public void pollOnce ( ) throws IOException { this . failureDelay = 2000 ; while ( true ) { try { pollOnceNoRetry ( ) ; break ; } catch ( IOException ioe ) { debugLog ( "IOException from pollOnceNoRetry: " + ioe ) ; if ( ! shouldRetry ( ioe ) ) { break ; } else { try { Thread . sleep ( this . failureDelay ) ; } catch ( InterruptedException e ) { break ; } incrementFailureDelay ( ) ; } } } } protected void incrementFailureDelay ( ) { if ( this . failureDelay < 30000 ) { this . failureDelay = this . failureDelay * 2 ; } } protected boolean shouldRetry ( IOException ioe ) { return isRunning ( ) ; } public void pollOnceNoRetry ( ) throws IOException { boolean declareMode = ( this . nextReq == null ) ; HttpURLConnection conn ; if ( declareMode ) { String params = "name=" + this . label + "&token=" + this . token ; conn = openServerConnection ( this . serverAddress ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "content-type" , "application/x-www-form-urlencoded" ) ; conn . setDoOutput ( true ) ; OutputStream os = conn . getOutputStream ( ) ; os . write ( params . getBytes ( "ASCII" ) ) ; os . flush ( ) ; os . close ( ) ; debugLog ( "Registering " + this . label + " at " + this . serverAddress ) ; } else { conn = openServerConnection ( this . nextReq ) ; debugLog ( "Polling " + this . nextReq ) ; } conn . connect ( ) ; int pollResponseCode = conn . getResponseCode ( ) ; if ( pollResponseCode < 200 || pollResponseCode >= 300 ) { throw new IOException ( "Unexpected response code: " + pollResponseCode ) ; } if ( declareMode ) { Map < String , URL > linkHeaders = parseLinkHeaders ( conn ) ; setNextReq ( linkHeaders . get ( "first" ) ) ; if ( linkHeaders . containsKey ( "related" ) ) { setLocation ( linkHeaders . get ( "related" ) ) ; } return ; } if ( pollResponseCode == 204 ) { return ; } URL replyUrl = this . nextReq ; setNextReq ( parseLinkHeaders ( conn ) . get ( "next" ) ) ; String clientHost ; int clientPort ; String clientHostAndPort = conn . getHeaderField ( "requesting-client" ) ; if ( clientHostAndPort != null ) { String [ ] pieces = clientHostAndPort . split ( ":" , 2 ) ; clientHost = ( pieces . length > 0 ) ? pieces [ 0 ] : "" ; clientPort = ( pieces . length > 1 ) ? Integer . parseInt ( pieces [ 1 ] ) : 0 ; } else { clientHost = "" ; clientPort = - 1 ; } InputStream rawInput = conn . getInputStream ( ) ; BufferedInputStream s = new BufferedInputStream ( rawInput ) ; List < HttpResponse > responses = new ArrayList < HttpResponse > ( ) ; while ( true ) { HttpRequest req = new HttpRequest ( ) ; req . setClientHost ( clientHost ) ; req . setClientPort ( clientPort ) ; if ( ! req . readFrom ( s ) ) { break ; } debugLog ( req . toString ( ) ) ; handleRequest ( req ) ; HttpResponse resp = req . getResponse ( ) ; if ( resp != null ) { debugLog ( resp . toString ( ) ) ; responses . add ( resp ) ; } } if ( ! responses . isEmpty ( ) ) { conn . disconnect ( ) ; conn = openServerConnection ( replyUrl ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "content-type" , "message/http" ) ; conn . setDoOutput ( true ) ; debugLog ( "Sending replies..." ) ; OutputStream o = new BufferedOutputStream ( conn . getOutputStream ( ) ) ; for ( HttpMessage resp : responses ) { resp . writeOn ( o ) ; } o . flush ( ) ; o . close ( ) ; conn . connect ( ) ; int replyResponseCode = conn . getResponseCode ( ) ; if ( replyResponseCode < 200 || replyResponseCode >= 300 ) { complain ( "Posting replies failed with code " + replyResponseCode + " and message \"" + conn . getResponseMessage ( ) + "\"" ) ; } } conn . disconnect ( ) ; debugLog ( "Poll complete." ) ; } private void setNextReq ( URL u ) throws IOException { if ( u == null ) { throw new IOException ( "Missing link header; is this really a reversehttp service?" ) ; } this . nextReq = u ; } private Map < String , URL > parseLinkHeaders ( HttpURLConnection conn ) { HashMap < String , URL > result = new HashMap < String , URL > ( ) ; List < String > values = conn . getHeaderFields ( ) . get ( "Link" ) ; if ( values != null ) { for ( String value : values ) { for ( String linkHeader : value . split ( ", " ) ) { parseLinkHeader ( result , linkHeader ) ; } } } return result ; } private void parseLinkHeader ( Map < String , URL > result , String linkHeader ) { String rel = null ; URL url = null ; for ( String piece : linkHeader . split ( ";" ) ) { piece = piece . trim ( ) ; if ( piece . charAt ( 0 ) == '<' ) { try { url = new URL ( piece . substring ( 1 , piece . length ( ) - 1 ) ) ; } catch ( MalformedURLException e ) { } } else if ( piece . toLowerCase ( ) . startsWith ( "rel=\"" ) ) { rel = piece . substring ( 5 , piece . length ( ) - 1 ) ; } } if ( rel != null && url != null ) { result . put ( rel , url ) ; } } public void addPropertyChangeListener ( PropertyChangeListener listener ) { support . addPropertyChangeListener ( listener ) ; } public void removePropertyChangeListener ( PropertyChangeListener listener ) { support . removePropertyChangeListener ( listener ) ; } protected void setLocation ( URL url ) { URL oldLoc = location ; location = url ; support . firePropertyChange ( "location" , oldLoc , url ) ; } private HttpURLConnection openServerConnection ( URL loc ) throws IOException { return ( HttpURLConnection ) loc . openConnection ( ) ; } private void debugLog ( String msg ) { Logger . getLogger ( ReverseHttpServer . class . getName ( ) ) . fine ( msg ) ; } public String getLabel ( ) { return label ; } public URL getServerAddress ( ) { return serverAddress ; } public URL getLocation ( ) { return location ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
