<<<<<<< HEAD
public class TypeInferrer implements JVMConstants { public static String getJLSType ( String jvmType , boolean flagQualifyArray ) { char firstChar = jvmType . charAt ( 0 ) ; if ( jvmType . length ( ) == 1 ) { switch ( firstChar ) { case JVM_TYPE_BYTE : return language . getTypeBoolean ( ) ; case JVM_TYPE_CHAR : return language . getTypeChar ( ) ; case JVM_TYPE_DOUBLE : return language . getTypeDouble ( ) ; case JVM_TYPE_FLOAT : return language . getTypeFloat ( ) ; case JVM_TYPE_INT : return language . getTypeInt ( ) ; case JVM_TYPE_LONG : return language . getTypeLong ( ) ; case JVM_TYPE_SHORT : return language . getTypeShort ( ) ; case JVM_TYPE_VOID : return language . getTypeVoid ( ) ; case JVM_TYPE_BOOLEAN : return language . getTypeBoolean ( ) ; default : throw new JVMTypeException ( "Unknown JVM Type " + firstChar ) ; } } else if ( firstChar == JVM_TYPE_ARRAY ) { String type = getJLSType ( jvmType . substring ( 1 ) , flagQualifyArray ) ; if ( ! flagQualifyArray ) { return type + language . getArrayTypeSuffix ( ) ; } else { return type ; } } else if ( firstChar == JVM_TYPE_CLASS ) { int len = jvmType . length ( ) ; if ( jvmType . indexOf ( JVM_TYPE_DELIMITER ) == - 1 ) { return jvmType . substring ( 1 ) ; } else { return jvmType . substring ( 1 , len - 1 ) ; } } return jvmType ; } public static int getSignTokenLength ( String aDataType ) { char ch = aDataType . charAt ( 0 ) ; switch ( ch ) { case JVM_TYPE_BYTE : case JVM_TYPE_CHAR : case JVM_TYPE_DOUBLE : case JVM_TYPE_FLOAT : case JVM_TYPE_INT : case JVM_TYPE_LONG : case JVM_TYPE_SHORT : case JVM_TYPE_VOID : case JVM_TYPE_BOOLEAN : return 1 ; case JVM_TYPE_ARRAY : return ( getSignTokenLength ( aDataType . substring ( 1 ) ) + 1 ) ; case JVM_TYPE_CLASS : int semiColon = aDataType . indexOf ( JVM_TYPE_DELIMITER ) ; if ( semiColon == - 1 ) { return aDataType . length ( ) ; } else { return ( semiColon + 1 ) ; } default : throw new JVMTypeException ( "Unknown JVM Type " + ch ) ; } } private static LanguageContext language = new JLSLanguageContext ( ) ; public static List < String > getArguments ( String methodSignature ) { List < String > args = new ArrayList < String > ( ) ; int argBeginIndex = methodSignature . indexOf ( JVM_METHOD_ARG_BEGIN_DELIMITER ) ; if ( argBeginIndex == - 1 ) { throw new RuntimeException ( "Method Signature " + methodSignature + " does not have " + JVM_METHOD_ARG_BEGIN_DELIMITER ) ; } int endIndex = methodSignature . indexOf ( JVM_METHOD_ARG_END_DELIMITER ) ; if ( endIndex > ( argBeginIndex + 1 ) ) { methodSignature = methodSignature . substring ( argBeginIndex + 1 , endIndex ) ; String origStr = methodSignature ; int length = origStr . length ( ) ; int curIndex = 0 ; while ( curIndex < length ) { methodSignature = origStr . substring ( curIndex ) ; int tokenLength = getSignTokenLength ( methodSignature ) ; String tokenString = methodSignature . substring ( 0 , tokenLength ) ; int semiColon = tokenString . indexOf ( JVM_TYPE_DELIMITER ) ; if ( semiColon != - 1 ) { tokenString = tokenString . substring ( 0 , semiColon ) ; } args . add ( tokenString ) ; curIndex += tokenLength ; } } return args ; } public static String getReturnType ( String aSignature ) { int index = aSignature . indexOf ( JVM_METHOD_ARG_END_DELIMITER ) ; return aSignature . substring ( index + 1 ) ; } public static boolean isBasicType ( String type ) { boolean flag = type . length ( ) == 1 ; if ( flag ) { char ch = type . charAt ( 0 ) ; flag = ( ch == JVM_TYPE_INT || ch == JVM_TYPE_BOOLEAN || ch == JVM_TYPE_BYTE || ch == JVM_TYPE_CHAR || ch == JVM_TYPE_SHORT || ch == JVM_TYPE_FLOAT || ch == JVM_TYPE_LONG || ch == JVM_TYPE_DOUBLE ) ; } return flag ; } public static String getAtomicValue ( String value , String jvmType ) { value = value . trim ( ) ; if ( jvmType . equals ( Character . valueOf ( JVM_TYPE_BOOLEAN ) . toString ( ) ) ) { if ( value . compareTo ( JVM_BOOLEAN_TRUE ) == 0 ) { return JLSConstants . BOOLEAN_TRUE ; } else if ( value . compareTo ( JVM_BOOLEAN_FALSE ) == 0 ) { return JLSConstants . BOOLEAN_FALSE ; } else { return value ; } } else if ( jvmType . equals ( Character . valueOf ( JVM_TYPE_CHAR ) . toString ( ) ) ) { try { int intvalue = Integer . parseInt ( value ) ; return String . format ( "'%c'" , ( char ) intvalue ) ; } catch ( NumberFormatException _ex ) { return value ; } } return value ; } public static String getValue ( String value , String jvmType ) { if ( jvmType == null ) { return value ; } int lastQIndex = value . lastIndexOf ( '?' ) ; int lastColonIndex = value . lastIndexOf ( ":" ) ; if ( lastQIndex == - 1 || lastColonIndex == - 1 || lastQIndex > lastColonIndex ) { return getAtomicValue ( value , jvmType ) ; } String condition = value . substring ( 0 , lastQIndex ) ; String val1 = value . substring ( lastQIndex + 1 , lastColonIndex ) ; String val2 = value . substring ( lastColonIndex + 1 ) ; StringBuilder result = new StringBuilder ( condition ) ; result . append ( "? " + getAtomicValue ( val1 , jvmType ) ) ; result . append ( ": " + getAtomicValue ( val2 , jvmType ) ) ; return result . toString ( ) ; } public static String getArrayMemberType ( String type ) { int firstArrayIndex = type . indexOf ( JVM_TYPE_ARRAY ) ; if ( firstArrayIndex == - 1 ) { throw new IllegalArgumentException ( "Type " + type + " not an array type to begin with" ) ; } return type . substring ( firstArrayIndex + 1 ) ; } public static boolean doesTypeOccupy2EntriesInVariableTable ( String jvmType ) { return Character . toString ( JVMConstants . JVM_TYPE_LONG ) . equals ( jvmType ) || Character . toString ( JVMConstants . JVM_TYPE_DOUBLE ) . equals ( jvmType ) ; } } 
=======
class AnyNameExceptNameClass implements NameClass { private final NameClass nameClass ; AnyNameExceptNameClass ( NameClass nameClass ) { this . nameClass = nameClass ; } public boolean contains ( Name name ) { return ! nameClass . contains ( name ) ; } public int containsSpecificity ( Name name ) { return contains ( name ) ? SPECIFICITY_ANY_NAME : SPECIFICITY_NONE ; } public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof AnyNameExceptNameClass ) ) return false ; return nameClass . equals ( ( ( AnyNameExceptNameClass ) obj ) . nameClass ) ; } public int hashCode ( ) { return ~ nameClass . hashCode ( ) ; } public void accept ( NameClassVisitor visitor ) { visitor . visitAnyNameExcept ( nameClass ) ; } public boolean isOpen ( ) { return true ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
