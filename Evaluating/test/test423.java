<<<<<<< HEAD
public class Field implements TBase , java . io . Serializable , Cloneable { private static final TStruct STRUCT_DESC = new TStruct ( "Field" ) ; private static final TField KEY_FIELD_DESC = new TField ( "key" , TType . STRING , ( short ) 1 ) ; private static final TField VALUE_FIELD_DESC = new TField ( "value" , TType . STRING , ( short ) 2 ) ; private static final TField STORE_FIELD_DESC = new TField ( "store" , TType . BOOL , ( short ) 3 ) ; private static final TField WEIGHT_FIELD_DESC = new TField ( "weight" , TType . I32 , ( short ) 4 ) ; private static final TField SORTABLE_FIELD_DESC = new TField ( "sortable" , TType . BOOL , ( short ) 5 ) ; private static final TField ANALYZER_FIELD_DESC = new TField ( "analyzer" , TType . I32 , ( short ) 6 ) ; public String key ; public static final int KEY = 1 ; public String value ; public static final int VALUE = 2 ; public boolean store ; public static final int STORE = 3 ; public int weight ; public static final int WEIGHT = 4 ; public boolean sortable ; public static final int SORTABLE = 5 ; public int analyzer ; public static final int ANALYZER = 6 ; private final Isset __isset = new Isset ( ) ; private static final class Isset implements java . io . Serializable { public boolean store = false ; public boolean weight = false ; public boolean sortable = false ; public boolean analyzer = false ; } public static final Map < Integer , FieldMetaData > metaDataMap = Collections . unmodifiableMap ( new HashMap < Integer , FieldMetaData > ( ) { { put ( KEY , new FieldMetaData ( "key" , TFieldRequirementType . DEFAULT , new FieldValueMetaData ( TType . STRING ) ) ) ; put ( VALUE , new FieldMetaData ( "value" , TFieldRequirementType . DEFAULT , new FieldValueMetaData ( TType . STRING ) ) ) ; put ( STORE , new FieldMetaData ( "store" , TFieldRequirementType . DEFAULT , new FieldValueMetaData ( TType . BOOL ) ) ) ; put ( WEIGHT , new FieldMetaData ( "weight" , TFieldRequirementType . DEFAULT , new FieldValueMetaData ( TType . I32 ) ) ) ; put ( SORTABLE , new FieldMetaData ( "sortable" , TFieldRequirementType . DEFAULT , new FieldValueMetaData ( TType . BOOL ) ) ) ; put ( ANALYZER , new FieldMetaData ( "analyzer" , TFieldRequirementType . DEFAULT , new FieldValueMetaData ( TType . I32 ) ) ) ; } } ) ; static { FieldMetaData . addStructMetaDataMap ( Field . class , metaDataMap ) ; } public Field ( ) { this . store = true ; this . weight = 1 ; this . sortable = false ; this . analyzer = 1 ; } public Field ( String key , String value , boolean store , int weight , boolean sortable , int analyzer ) { this ( ) ; this . key = key ; this . value = value ; this . store = store ; this . __isset . store = true ; this . weight = weight ; this . __isset . weight = true ; this . sortable = sortable ; this . __isset . sortable = true ; this . analyzer = analyzer ; this . __isset . analyzer = true ; } public Field ( Field other ) { if ( other . isSetKey ( ) ) { this . key = other . key ; } if ( other . isSetValue ( ) ) { this . value = other . value ; } __isset . store = other . __isset . store ; this . store = other . store ; __isset . weight = other . __isset . weight ; this . weight = other . weight ; __isset . sortable = other . __isset . sortable ; this . sortable = other . sortable ; __isset . analyzer = other . __isset . analyzer ; this . analyzer = other . analyzer ; } @ Override public Field clone ( ) { return new Field ( this ) ; } public String getKey ( ) { return this . key ; } public void setKey ( String key ) { this . key = key ; } public void unsetKey ( ) { this . key = null ; } public boolean isSetKey ( ) { return this . key != null ; } public void setKeyIsSet ( boolean value ) { if ( ! value ) { this . key = null ; } } public String getValue ( ) { return this . value ; } public void setValue ( String value ) { this . value = value ; } public void unsetValue ( ) { this . value = null ; } public boolean isSetValue ( ) { return this . value != null ; } public void setValueIsSet ( boolean value ) { if ( ! value ) { this . value = null ; } } public boolean isStore ( ) { return this . store ; } public void setStore ( boolean store ) { this . store = store ; this . __isset . store = true ; } public void unsetStore ( ) { this . __isset . store = false ; } public boolean isSetStore ( ) { return this . __isset . store ; } public void setStoreIsSet ( boolean value ) { this . __isset . store = value ; } public int getWeight ( ) { return this . weight ; } public void setWeight ( int weight ) { this . weight = weight ; this . __isset . weight = true ; } public void unsetWeight ( ) { this . __isset . weight = false ; } public boolean isSetWeight ( ) { return this . __isset . weight ; } public void setWeightIsSet ( boolean value ) { this . __isset . weight = value ; } public boolean isSortable ( ) { return this . sortable ; } public void setSortable ( boolean sortable ) { this . sortable = sortable ; this . __isset . sortable = true ; } public void unsetSortable ( ) { this . __isset . sortable = false ; } public boolean isSetSortable ( ) { return this . __isset . sortable ; } public void setSortableIsSet ( boolean value ) { this . __isset . sortable = value ; } public int getAnalyzer ( ) { return this . analyzer ; } public void setAnalyzer ( int analyzer ) { this . analyzer = analyzer ; this . __isset . analyzer = true ; } public void unsetAnalyzer ( ) { this . __isset . analyzer = false ; } public boolean isSetAnalyzer ( ) { return this . __isset . analyzer ; } public void setAnalyzerIsSet ( boolean value ) { this . __isset . analyzer = value ; } public void setFieldValue ( int fieldID , Object value ) { switch ( fieldID ) { case KEY : if ( value == null ) { unsetKey ( ) ; } else { setKey ( ( String ) value ) ; } break ; case VALUE : if ( value == null ) { unsetValue ( ) ; } else { setValue ( ( String ) value ) ; } break ; case STORE : if ( value == null ) { unsetStore ( ) ; } else { setStore ( ( Boolean ) value ) ; } break ; case WEIGHT : if ( value == null ) { unsetWeight ( ) ; } else { setWeight ( ( Integer ) value ) ; } break ; case SORTABLE : if ( value == null ) { unsetSortable ( ) ; } else { setSortable ( ( Boolean ) value ) ; } break ; case ANALYZER : if ( value == null ) { unsetAnalyzer ( ) ; } else { setAnalyzer ( ( Integer ) value ) ; } break ; default : throw new IllegalArgumentException ( "Field " + fieldID + " doesn't exist!" ) ; } } public Object getFieldValue ( int fieldID ) { switch ( fieldID ) { case KEY : return getKey ( ) ; case VALUE : return getValue ( ) ; case STORE : return new Boolean ( isStore ( ) ) ; case WEIGHT : return new Integer ( getWeight ( ) ) ; case SORTABLE : return new Boolean ( isSortable ( ) ) ; case ANALYZER : return getAnalyzer ( ) ; default : throw new IllegalArgumentException ( "Field " + fieldID + " doesn't exist!" ) ; } } public boolean isSet ( int fieldID ) { switch ( fieldID ) { case KEY : return isSetKey ( ) ; case VALUE : return isSetValue ( ) ; case STORE : return isSetStore ( ) ; case WEIGHT : return isSetWeight ( ) ; case SORTABLE : return isSetSortable ( ) ; case ANALYZER : return isSetAnalyzer ( ) ; default : throw new IllegalArgumentException ( "Field " + fieldID + " doesn't exist!" ) ; } } @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof Field ) return this . equals ( ( Field ) that ) ; return false ; } public boolean equals ( Field that ) { if ( that == null ) return false ; boolean this_present_key = true && this . isSetKey ( ) ; boolean that_present_key = true && that . isSetKey ( ) ; if ( this_present_key || that_present_key ) { if ( ! ( this_present_key && that_present_key ) ) return false ; if ( ! this . key . equals ( that . key ) ) return false ; } boolean this_present_value = true && this . isSetValue ( ) ; boolean that_present_value = true && that . isSetValue ( ) ; if ( this_present_value || that_present_value ) { if ( ! ( this_present_value && that_present_value ) ) return false ; if ( ! this . value . equals ( that . value ) ) return false ; } boolean this_present_store = true ; boolean that_present_store = true ; if ( this_present_store || that_present_store ) { if ( ! ( this_present_store && that_present_store ) ) return false ; if ( this . store != that . store ) return false ; } boolean this_present_weight = true ; boolean that_present_weight = true ; if ( this_present_weight || that_present_weight ) { if ( ! ( this_present_weight && that_present_weight ) ) return false ; if ( this . weight != that . weight ) return false ; } boolean this_present_sortable = true ; boolean that_present_sortable = true ; if ( this_present_sortable || that_present_sortable ) { if ( ! ( this_present_sortable && that_present_sortable ) ) return false ; if ( this . sortable != that . sortable ) return false ; } boolean this_present_analyzer = true ; boolean that_present_analyzer = true ; if ( this_present_analyzer || that_present_analyzer ) { if ( ! ( this_present_analyzer && that_present_analyzer ) ) return false ; if ( this . analyzer != that . analyzer ) return false ; } return true ; } @ Override public int hashCode ( ) { return 0 ; } public void read ( TProtocol iprot ) throws TException { TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == TType . STOP ) { break ; } switch ( field . id ) { case KEY : if ( field . type == TType . STRING ) { this . key = iprot . readString ( ) ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case VALUE : if ( field . type == TType . STRING ) { this . value = iprot . readString ( ) ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case STORE : if ( field . type == TType . BOOL ) { this . store = iprot . readBool ( ) ; this . __isset . store = true ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case WEIGHT : if ( field . type == TType . I32 ) { this . weight = iprot . readI32 ( ) ; this . __isset . weight = true ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case SORTABLE : if ( field . type == TType . BOOL ) { this . sortable = iprot . readBool ( ) ; this . __isset . sortable = true ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case ANALYZER : if ( field . type == TType . I32 ) { this . analyzer = iprot . readI32 ( ) ; this . __isset . analyzer = true ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : TProtocolUtil . skip ( iprot , field . type ) ; break ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; } public void write ( TProtocol oprot ) throws TException { validate ( ) ; oprot . writeStructBegin ( STRUCT_DESC ) ; if ( this . key != null ) { oprot . writeFieldBegin ( KEY_FIELD_DESC ) ; oprot . writeString ( this . key ) ; oprot . writeFieldEnd ( ) ; } if ( this . value != null ) { oprot . writeFieldBegin ( VALUE_FIELD_DESC ) ; oprot . writeString ( this . value ) ; oprot . writeFieldEnd ( ) ; } oprot . writeFieldBegin ( STORE_FIELD_DESC ) ; oprot . writeBool ( this . store ) ; oprot . writeFieldEnd ( ) ; oprot . writeFieldBegin ( WEIGHT_FIELD_DESC ) ; oprot . writeI32 ( this . weight ) ; oprot . writeFieldEnd ( ) ; oprot . writeFieldBegin ( SORTABLE_FIELD_DESC ) ; oprot . writeBool ( this . sortable ) ; oprot . writeFieldEnd ( ) ; oprot . writeFieldBegin ( ANALYZER_FIELD_DESC ) ; oprot . writeI32 ( this . analyzer ) ; oprot . writeFieldEnd ( ) ; oprot . writeFieldStop ( ) ; oprot . writeStructEnd ( ) ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( "Field(" ) ; boolean first = true ; sb . append ( "key:" ) ; if ( this . key == null ) { sb . append ( "null" ) ; } else { sb . append ( this . key ) ; } first = false ; if ( ! first ) sb . append ( ", " ) ; sb . append ( "value:" ) ; if ( this . value == null ) { sb . append ( "null" ) ; } else { sb . append ( this . value ) ; } first = false ; if ( ! first ) sb . append ( ", " ) ; sb . append ( "store:" ) ; sb . append ( this . store ) ; first = false ; if ( ! first ) sb . append ( ", " ) ; sb . append ( "weight:" ) ; sb . append ( this . weight ) ; first = false ; if ( ! first ) sb . append ( ", " ) ; sb . append ( "sortable:" ) ; sb . append ( this . sortable ) ; first = false ; if ( ! first ) sb . append ( ", " ) ; sb . append ( "analyzer:" ) ; String analyzer_name = Analyzer . VALUES_TO_NAMES . get ( this . analyzer ) ; if ( analyzer_name != null ) { sb . append ( analyzer_name ) ; sb . append ( " (" ) ; } sb . append ( this . analyzer ) ; if ( analyzer_name != null ) { sb . append ( ")" ) ; } first = false ; sb . append ( ")" ) ; return sb . toString ( ) ; } public void validate ( ) throws TException { if ( isSetAnalyzer ( ) && ! Analyzer . VALID_VALUES . contains ( analyzer ) ) { throw new TProtocolException ( "The field 'analyzer' has been assigned the invalid value " + analyzer ) ; } } } 
=======
public class XmlPiChecker extends Checker implements LexicalHandler { private static final char [ ] [ ] NAMES = { "amp;" . toCharArray ( ) , "lt;" . toCharArray ( ) , "gt;" . toCharArray ( ) , "quot;" . toCharArray ( ) , "apos;" . toCharArray ( ) , } ; private static final char [ ] [ ] VALUES = { { '&' } , { '<' } , { '>' } , { '"' } , { '\'' } , } ; private static final int DATA_AND_RCDATA_MASK = ~ 1 ; private static final int BEFORE_ATTRIBUTE_NAME = 0 ; private static final int ATTRIBUTE_NAME = 1 ; private static final int AFTER_ATTRIBUTE_NAME = 2 ; private static final int BEFORE_ATTRIBUTE_VALUE = 3 ; private static final int ATTRIBUTE_VALUE_DOUBLE_QUOTED = 4 ; private static final int ATTRIBUTE_VALUE_SINGLE_QUOTED = 5 ; private static final int ATTRIBUTE_VALUE_UNQUOTED = 6 ; private static final int AFTER_ATTRIBUTE_VALUE_QUOTED = 7 ; private static final int CONSUME_CHARACTER_REFERENCE = 8 ; private static final int CONSUME_NCR = 9 ; private static final int CHARACTER_REFERENCE_LOOP = 10 ; private static final int HEX_NCR_LOOP = 11 ; private static final int DECIMAL_NRC_LOOP = 12 ; private static final int HANDLE_NCR_VALUE = 13 ; private static final int BUFFER_GROW_BY = 1024 ; private static final char [ ] REPLACEMENT_CHARACTER = { '�' } ; private static final int LEAD_OFFSET = ( 0xD800 - ( 0x10000 > > 10 ) ) ; private char [ ] strBuf = new char [ 64 ] ; private int strBufLen ; private char [ ] longStrBuf = new char [ 1024 ] ; private int longStrBufLen ; private final char [ ] bmpChar = new char [ 1 ] ; private final char [ ] astralChar = new char [ 2 ] ; private int entCol ; private int lo ; private int hi ; private int candidate ; private int strBufMark ; private int prevValue ; private int value ; private boolean seenDigits ; private char additional ; private boolean alreadyWarnedAboutPrivateUseCharacters ; private AttributesImpl attributes ; private String attributeName ; private boolean inDoctype ; private boolean alreadyHasElement ; private String piTarget = null ; private boolean hasXsltPi ; private enum PseudoAttrName { HREF , TYPE , TITLE , MEDIA , CHARSET , ALTERNATE , INVALID ; private static PseudoAttrName toCaps ( String str ) { try { if ( ! str . toLowerCase ( ) . equals ( str ) ) { return INVALID ; } return valueOf ( newAsciiUpperCaseStringFromString ( str ) ) ; } catch ( Exception ex ) { return INVALID ; } } } public XmlPiChecker ( ) { super ( ) ; inDoctype = false ; hasXsltPi = false ; alreadyHasElement = false ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { inDoctype = true ; } public void endDTD ( ) throws SAXException { inDoctype = false ; } public void startEntity ( String name ) throws SAXException { } public void endEntity ( String name ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void endCDATA ( ) throws SAXException { } public void comment ( char [ ] ch , int start , int len ) throws SAXException { } @ Override public void startDocument ( ) throws SAXException { inDoctype = false ; hasXsltPi = false ; alreadyHasElement = false ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { alreadyHasElement = true ; } @ Override public void processingInstruction ( String target , String data ) throws SAXException { piTarget = target ; if ( "xml-stylesheet" . equals ( piTarget ) ) { checkXmlStylesheetPiData ( data ) ; } } private void errBadPseudoAttrDatatype ( DatatypeException e , Class < ? > datatypeClass , String attrName , String attrValue ) throws SAXException , ClassNotFoundException { if ( getErrorHandler ( ) != null ) { Html5DatatypeException ex5 = ( Html5DatatypeException ) e ; boolean warning = ex5 . isWarning ( ) ? true : false ; DatatypeMismatchException bpe = new DatatypeMismatchException ( "Bad value “" + attrValue + "” for “" + piTarget + "” pseudo-attribute “" + attrName + "”. " + e . getMessage ( ) , getDocumentLocator ( ) , datatypeClass , warning ) ; getErrorHandler ( ) . error ( bpe ) ; } } private void errAttributeWithNoValue ( ) throws SAXException { err ( "Found “" + piTarget + "” pseudo-attribute “" + attributeName + "” without a value. All pseudo-attributes in “" + piTarget + "” instructions must have values." ) ; } private void errAttributeValueContainsLt ( ) throws SAXException { err ( "Found “" + piTarget + "” pseudo-attribute “" + attributeName + "” with the character “<” in its value. All pseudo-attribute values in “" + piTarget + "” instructions must not contain the character “<”." ) ; } private void errUpperCaseXinHexNcr ( ) throws SAXException { err ( "In XML documents, a hexadecimal character reference must begin with " + "“&#x” (lowercase “x”), not “&#X” (uppercase “X”)." ) ; } private void checkXmlStylesheetPiData ( String data ) throws SAXException { boolean hasHref = false ; boolean hasTitle = false ; boolean hasMedia = false ; boolean hasCharset = false ; boolean hasAlternate = false ; boolean hasNonEmptyTitle = false ; boolean alternateIsYes = false ; boolean badDatatype = false ; if ( inDoctype ) { warn ( "An “xml-stylesheet” instruction should not be used within a “DOCTYPE” declaration." ) ; } if ( alreadyHasElement ) { err ( "Any “xml-stylesheet” instruction in a document must occur before any elements in the document. " + "Suppressing any further errors for this “xml-stylesheet” instruction." ) ; return ; } if ( ! "" . equals ( data ) ) { Html5DatatypeLibrary dl = new Html5DatatypeLibrary ( ) ; AttributesImpl patts = getPseudoAttributesFromPiData ( data ) ; String attrName ; String attrValue ; for ( int i = 0 ; i < patts . getLength ( ) ; i ++ ) { attrName = patts . getQName ( i ) ; attrValue = patts . getValue ( i ) ; switch ( PseudoAttrName . toCaps ( attrName ) ) { case HREF : hasHref = true ; if ( attrValue == null ) { break ; } try { IriRef ir = ( IriRef ) dl . createDatatype ( "iri-ref" ) ; ir . checkValid ( attrValue ) ; } catch ( DatatypeException e ) { try { errBadPseudoAttrDatatype ( e , IriRef . class , "href" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } break ; case TYPE : if ( attrValue == null ) { break ; } try { MimeType mt = ( MimeType ) dl . createDatatype ( "mime-type" ) ; mt . checkValid ( attrValue ) ; attrValue = newAsciiLowerCaseStringFromString ( attrValue ) ; } catch ( DatatypeException e ) { badDatatype = true ; try { errBadPseudoAttrDatatype ( e , MimeType . class , "type" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } if ( ! badDatatype ) { if ( attrValue . matches ( "application/xml(;.*)?" ) || attrValue . matches ( "text/xml(;.*)?" ) || attrValue . matches ( "application/xslt+xml(;.*)?" ) || attrValue . matches ( "text/xsl(;.*)?" ) || attrValue . matches ( "text/xslt(;.*)?" ) ) { if ( ! attrValue . matches ( "text/xsl(;.*)?" ) ) { warn ( "For indicating XSLT, “text/xsl” is the only MIME type for the " + "“xml-stylesheet” pseudo-attribute “type” that is supported across browsers." ) ; } if ( hasXsltPi ) { warn ( "Browsers do not support multiple “xml-stylesheet” instructions with a " + "“type” value that indicates XSLT." ) ; } hasXsltPi = true ; } else if ( ! attrValue . matches ( "^text/css(;.*)?$" ) ) { warn ( "“text/css” and “text/xsl” are the only MIME types for the " + "“xml-stylesheet” pseudo-attribute “type” that are supported across browsers." ) ; } } break ; case TITLE : hasTitle = true ; if ( attrValue == null ) { break ; } if ( ! "" . equals ( attrValue ) ) { hasNonEmptyTitle = true ; } break ; case MEDIA : hasMedia = true ; if ( attrValue == null ) { break ; } try { MediaQuery mq = ( MediaQuery ) dl . createDatatype ( "media-query" ) ; mq . checkValid ( attrValue ) ; } catch ( DatatypeException e ) { try { errBadPseudoAttrDatatype ( e , MediaQuery . class , "media" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } break ; case CHARSET : hasCharset = true ; if ( attrValue == null ) { break ; } try { Charset c = ( Charset ) dl . createDatatype ( "charset" ) ; c . checkValid ( attrValue ) ; } catch ( DatatypeException e ) { try { errBadPseudoAttrDatatype ( e , Charset . class , "charset" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } break ; case ALTERNATE : hasAlternate = true ; if ( attrValue == null ) { break ; } if ( "yes" . equals ( attrValue ) ) { alternateIsYes = true ; } else if ( ! "no" . equals ( attrValue ) ) { err ( "The value of the “xml-stylesheet” pseudo-attribute “alternate” " + "must be either “yes” or “no”." ) ; } break ; default : err ( "Pseudo-attribute “" + attrName + "” not allowed in “xml-stylesheet” instruction." ) ; break ; } } if ( alternateIsYes && ! hasNonEmptyTitle ) { err ( "An “xml-stylesheet” instruction with an “alternate” pseudo-attribute " + "whose value is “yes” must also have a “title” pseudo-attribute with a non-empty value." ) ; } } if ( ! hasHref ) { err ( "“xml-stylesheet” instruction lacks “href” pseudo-attribute. " + "The “href” pseudo-attribute is required in all “xml-stylesheet” instructions." ) ; } if ( hasXsltPi && ( hasTitle || hasMedia || hasCharset || hasAlternate ) ) { warn ( "When processing “xml-stylesheet” instructions, browsers ignore the pseudo-attributes " + "“title”, “media”, “charset”, and “alternate”." ) ; } else if ( hasCharset ) { warn ( "Some browsers ignore the value of the “xml-stylesheet” pseudo-attribute “charset”." ) ; } } private AttributesImpl getPseudoAttributesFromPiData ( String buf ) throws SAXException { int state = BEFORE_ATTRIBUTE_NAME ; int returnState = BEFORE_ATTRIBUTE_NAME ; char c = ' ' ; int pos = - 1 ; int endPos = buf . length ( ) ; boolean reconsume = false ; attributes = null ; attributeName = null ; stateloop : for ( ; ; ) { switch ( state ) { case BEFORE_ATTRIBUTE_NAME : beforeattributenameloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '\n' : case ' ' : case '\t' : continue ; case '/' : case '>' : case '\"' : case '\'' : case '<' : case '=' : errBadCharBeforeAttributeNameOrNull ( c ) ; default : clearStrBufAndAppendCurrentC ( c ) ; state = ATTRIBUTE_NAME ; break beforeattributenameloop ; } } case ATTRIBUTE_NAME : attributenameloop : for ( ; ; ) { if ( ++ pos == endPos ) { attributeNameComplete ( ) ; addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : attributeNameComplete ( ) ; state = AFTER_ATTRIBUTE_NAME ; continue stateloop ; case '=' : attributeNameComplete ( ) ; state = BEFORE_ATTRIBUTE_VALUE ; break attributenameloop ; case '\"' : case '\'' : case '<' : errQuoteOrLtInAttributeNameOrNull ( c ) ; default : appendStrBuf ( c ) ; continue ; } } case BEFORE_ATTRIBUTE_VALUE : beforeattributevalueloop : for ( ; ; ) { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : continue ; case '"' : clearLongStrBufForNextState ( ) ; state = ATTRIBUTE_VALUE_DOUBLE_QUOTED ; break beforeattributevalueloop ; case '&' : clearLongStrBuf ( ) ; state = ATTRIBUTE_VALUE_UNQUOTED ; reconsume = true ; continue stateloop ; case '\'' : clearLongStrBufForNextState ( ) ; state = ATTRIBUTE_VALUE_SINGLE_QUOTED ; continue stateloop ; case '<' : case '=' : case '`' : errLtOrEqualsOrGraveInUnquotedAttributeOrNull ( c ) ; default : clearLongStrBufAndAppendCurrentC ( c ) ; state = ATTRIBUTE_VALUE_UNQUOTED ; continue stateloop ; } } case ATTRIBUTE_VALUE_DOUBLE_QUOTED : attributevaluedoublequotedloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '"' : addAttributeWithValue ( ) ; state = AFTER_ATTRIBUTE_VALUE_QUOTED ; break attributevaluedoublequotedloop ; case '&' : clearStrBufAndAppendCurrentC ( c ) ; returnState = state ; state = CONSUME_CHARACTER_REFERENCE ; continue stateloop ; case '\n' : appendLongStrBufLineFeed ( ) ; continue ; default : appendLongStrBuf ( c ) ; continue ; } } case AFTER_ATTRIBUTE_VALUE_QUOTED : for ( ; ; ) { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : state = BEFORE_ATTRIBUTE_NAME ; continue stateloop ; default : errNoSpaceBetweenAttributes ( ) ; state = BEFORE_ATTRIBUTE_NAME ; reconsume = true ; continue stateloop ; } } case ATTRIBUTE_VALUE_UNQUOTED : errUnquotedAttributeValOrNull ( ) ; for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { addAttributeWithValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '\n' : case ' ' : case '\t' : addAttributeWithValue ( ) ; state = BEFORE_ATTRIBUTE_NAME ; continue stateloop ; case '&' : clearStrBufAndAppendCurrentC ( c ) ; returnState = state ; state = CONSUME_CHARACTER_REFERENCE ; continue stateloop ; case '>' : continue stateloop ; case '<' : case '\"' : case '\'' : case '=' : case '`' : default : appendLongStrBuf ( c ) ; continue ; } } case AFTER_ATTRIBUTE_NAME : for ( ; ; ) { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : continue ; case '=' : state = BEFORE_ATTRIBUTE_VALUE ; continue stateloop ; case '\"' : case '\'' : case '<' : errQuoteOrLtInAttributeNameOrNull ( c ) ; default : addAttributeWithoutValue ( ) ; clearStrBufAndAppendCurrentC ( c ) ; state = ATTRIBUTE_NAME ; continue stateloop ; } } case ATTRIBUTE_VALUE_SINGLE_QUOTED : attributevaluesinglequotedloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '\'' : addAttributeWithValue ( ) ; state = AFTER_ATTRIBUTE_VALUE_QUOTED ; continue stateloop ; case '&' : clearStrBufAndAppendCurrentC ( c ) ; returnState = state ; state = CONSUME_CHARACTER_REFERENCE ; break attributevaluesinglequotedloop ; case '\n' : appendLongStrBufLineFeed ( ) ; continue ; default : appendLongStrBuf ( c ) ; continue ; } } case CONSUME_CHARACTER_REFERENCE : if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '#' : appendStrBuf ( '#' ) ; state = CONSUME_NCR ; continue stateloop ; default : if ( c == additional ) { emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } entCol = - 1 ; lo = 0 ; hi = ( NAMES . length - 1 ) ; candidate = - 1 ; strBufMark = 0 ; state = CHARACTER_REFERENCE_LOOP ; reconsume = true ; } case CHARACTER_REFERENCE_LOOP : outer : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; } entCol ++ ; hiloop : for ( ; ; ) { if ( hi == - 1 ) { break hiloop ; } if ( entCol == NAMES [ hi ] . length ) { break hiloop ; } if ( entCol > NAMES [ hi ] . length ) { break outer ; } else if ( c < NAMES [ hi ] [ entCol ] ) { hi -- ; } else { break hiloop ; } } loloop : for ( ; ; ) { if ( hi < lo ) { break outer ; } if ( entCol == NAMES [ lo ] . length ) { candidate = lo ; strBufMark = strBufLen ; lo ++ ; } else if ( entCol > NAMES [ lo ] . length ) { break outer ; } else if ( c > NAMES [ lo ] [ entCol ] ) { lo ++ ; } else { break loloop ; } } if ( hi < lo ) { break outer ; } appendStrBuf ( c ) ; continue ; } if ( candidate == - 1 ) { errNoNamedCharacterMatch ( ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } else { char [ ] candidateArr = NAMES [ candidate ] ; if ( candidateArr [ candidateArr . length - 1 ] != ';' ) { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { char ch ; if ( strBufMark == strBufLen ) { ch = c ; } else { ch = strBuf [ strBufMark ] ; } if ( ( ch >= '0' && ch <= '9' ) || ( ch >= 'A' && ch <= 'Z' ) || ( ch >= 'a' && ch <= 'z' ) ) { errNoNamedCharacterMatch ( ) ; appendStrBufToLongStrBuf ( ) ; state = returnState ; reconsume = true ; continue stateloop ; } } if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { errUnescapedAmpersandInterpretedAsCharacterReference ( ) ; } } char [ ] val = VALUES [ candidate ] ; emitOrAppend ( val , returnState ) ; if ( strBufMark < strBufLen ) { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { for ( int i = strBufMark ; i < strBufLen ; i ++ ) { appendLongStrBuf ( strBuf [ i ] ) ; } } } state = returnState ; reconsume = true ; continue stateloop ; } case CONSUME_NCR : if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; prevValue = - 1 ; value = 0 ; seenDigits = false ; switch ( c ) { case 'x' : appendStrBuf ( c ) ; state = HEX_NCR_LOOP ; continue stateloop ; case 'X' : errUpperCaseXinHexNcr ( ) ; appendStrBuf ( c ) ; state = HEX_NCR_LOOP ; continue stateloop ; default : state = DECIMAL_NRC_LOOP ; reconsume = true ; } case DECIMAL_NRC_LOOP : decimalloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; } if ( value < prevValue ) { value = 0x110000 ; } prevValue = value ; if ( c >= '0' && c <= '9' ) { seenDigits = true ; value *= 10 ; value += c - '0' ; continue ; } else if ( c == ';' ) { if ( seenDigits ) { state = HANDLE_NCR_VALUE ; break decimalloop ; } else { errNoDigitsInNCR ( ) ; appendStrBuf ( ';' ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; continue stateloop ; } } else { if ( ! seenDigits ) { errNoDigitsInNCR ( ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } else { errCharRefLacksSemicolon ( ) ; state = HANDLE_NCR_VALUE ; reconsume = true ; break decimalloop ; } } } case HANDLE_NCR_VALUE : handleNcrValue ( returnState ) ; state = returnState ; continue stateloop ; case HEX_NCR_LOOP : for ( ; ; ) { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; if ( value < prevValue ) { value = 0x110000 ; } prevValue = value ; if ( c >= '0' && c <= '9' ) { seenDigits = true ; value *= 16 ; value += c - '0' ; continue ; } else if ( c >= 'A' && c <= 'F' ) { seenDigits = true ; value *= 16 ; value += c - 'A' + 10 ; continue ; } else if ( c >= 'a' && c <= 'f' ) { seenDigits = true ; value *= 16 ; value += c - 'a' + 10 ; continue ; } else if ( c == ';' ) { if ( seenDigits ) { state = HANDLE_NCR_VALUE ; continue stateloop ; } else { errNoDigitsInNCR ( ) ; appendStrBuf ( ';' ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; continue stateloop ; } } else { if ( ! seenDigits ) { errNoDigitsInNCR ( ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } else { errCharRefLacksSemicolon ( ) ; state = HANDLE_NCR_VALUE ; reconsume = true ; continue stateloop ; } } } } } return attributes ; } private void appendStrBufToLongStrBuf ( ) { appendLongStrBuf ( strBuf , 0 , strBufLen ) ; } private void appendLongStrBuf ( char [ ] buffer , int offset , int length ) { int reqLen = longStrBufLen + length ; if ( longStrBuf . length < reqLen ) { char [ ] newBuf = new char [ reqLen + ( reqLen > > 1 ) ] ; System . arraycopy ( longStrBuf , 0 , newBuf , 0 , longStrBuf . length ) ; longStrBuf = newBuf ; } System . arraycopy ( buffer , offset , longStrBuf , longStrBufLen , length ) ; longStrBufLen = reqLen ; } private void appendLongStrBuf ( char [ ] arr ) { appendLongStrBuf ( arr , 0 , arr . length ) ; } private void appendLongStrBuf ( char c ) { if ( longStrBufLen == longStrBuf . length ) { char [ ] newBuf = new char [ longStrBufLen + ( longStrBufLen > > 1 ) ] ; System . arraycopy ( longStrBuf , 0 , newBuf , 0 , longStrBuf . length ) ; longStrBuf = newBuf ; } longStrBuf [ longStrBufLen ++ ] = c ; } private void appendLongStrBufLineFeed ( ) { appendLongStrBuf ( '\n' ) ; } private void appendStrBuf ( char c ) { if ( strBufLen == strBuf . length ) { char [ ] newBuf = new char [ strBuf . length + BUFFER_GROW_BY ] ; System . arraycopy ( strBuf , 0 , newBuf , 0 , strBuf . length ) ; strBuf = newBuf ; } strBuf [ strBufLen ++ ] = c ; } private void clearLongStrBufForNextState ( ) { longStrBufLen = 0 ; } private void clearLongStrBuf ( ) { longStrBufLen = 0 ; } private void clearLongStrBufAndAppendCurrentC ( char c ) { longStrBuf [ 0 ] = c ; longStrBufLen = 1 ; } private void clearStrBufAndAppendCurrentC ( char c ) { strBuf [ 0 ] = c ; strBufLen = 1 ; } private void emitOrAppend ( char [ ] val , int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendLongStrBuf ( val ) ; } } private void emitOrAppendOne ( char [ ] val , int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendLongStrBuf ( val [ 0 ] ) ; } } private void emitOrAppendTwo ( char [ ] val , int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendLongStrBuf ( val [ 0 ] ) ; appendLongStrBuf ( val [ 1 ] ) ; } } private void emitOrAppendStrBuf ( int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendStrBufToLongStrBuf ( ) ; } } private String longStrBufToString ( ) { return new String ( longStrBuf , 0 , longStrBufLen ) ; } private void attributeNameComplete ( ) throws SAXException { attributeName = new String ( strBuf , 0 , strBufLen ) . intern ( ) ; if ( attributes == null ) { attributes = new AttributesImpl ( ) ; } for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { if ( attributes . getQName ( i ) . equals ( attributeName ) ) { errDuplicateAttribute ( ) ; attributeName = null ; return ; } } } private void addAttributeWithValue ( ) throws SAXException { if ( attributeName != null ) { String value = longStrBufToString ( ) ; if ( value . indexOf ( "<" ) != - 1 ) { errAttributeValueContainsLt ( ) ; return ; } if ( badCharInCandidateAttributeName ( ) ) { return ; } attributes . addAttribute ( "" , "" , attributeName , "" , value ) ; attributeName = null ; } } private void addAttributeWithoutValue ( ) throws SAXException { if ( attributeName != null ) { if ( badCharInCandidateAttributeName ( ) ) { return ; } attributes . addAttribute ( "" , "" , attributeName , "" , null ) ; errAttributeWithNoValue ( ) ; attributeName = null ; } } private boolean badCharInCandidateAttributeName ( ) { return attributeName . indexOf ( "/" ) != - 1 || attributeName . indexOf ( ">" ) != - 1 || attributeName . indexOf ( "\"" ) != - 1 || attributeName . indexOf ( "\'" ) != - 1 || attributeName . indexOf ( "<" ) != - 1 || attributeName . indexOf ( "=" ) != - 1 ; } private void handleNcrValue ( int returnState ) throws SAXException { if ( ! isLegalXmlCharValue ( value ) ) { errNcrIllegalValueForXml ( ) ; } else { if ( value <= 0xFFFF ) { if ( ( value & 0xF800 ) == 0xD800 ) { errNcrSurrogate ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } else { char ch = ( char ) value ; if ( value >= 0xFDD0 && value <= 0xFDEF ) { errNcrUnassigned ( ) ; } else if ( ( value & 0xFFFE ) == 0xFFFE ) { ch = errNcrNonCharacter ( ch ) ; } else if ( value >= 0x007F && value <= 0x009F ) { errNcrControlChar ( ) ; } else { maybeWarnPrivateUse ( ch ) ; } bmpChar [ 0 ] = ch ; emitOrAppendOne ( bmpChar , returnState ) ; } } else if ( value <= 0x10FFFF ) { maybeWarnPrivateUseAstral ( ) ; if ( ( value & 0xFFFE ) == 0xFFFE ) { errAstralNonCharacter ( value ) ; } astralChar [ 0 ] = ( char ) ( LEAD_OFFSET + ( value > > 10 ) ) ; astralChar [ 1 ] = ( char ) ( 0xDC00 + ( value & 0x3FF ) ) ; emitOrAppendTwo ( astralChar , returnState ) ; } else { errNcrOutOfRange ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } if ( ( value & 0xF800 ) == 0xD800 ) { errNcrSurrogate ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } else if ( value <= 0xFFFF ) { char ch = ( char ) value ; if ( value >= 0xFDD0 && value <= 0xFDEF ) { errNcrUnassigned ( ) ; } else if ( ( value & 0xFFFE ) == 0xFFFE ) { ch = errNcrNonCharacter ( ch ) ; } else if ( value >= 0x007F && value <= 0x009F ) { errNcrControlChar ( ) ; } else { maybeWarnPrivateUse ( ch ) ; } bmpChar [ 0 ] = ch ; emitOrAppendOne ( bmpChar , returnState ) ; } else if ( value <= 0x10FFFF ) { maybeWarnPrivateUseAstral ( ) ; astralChar [ 0 ] = ( char ) ( LEAD_OFFSET + ( value > > 10 ) ) ; astralChar [ 1 ] = ( char ) ( 0xDC00 + ( value & 0x3FF ) ) ; emitOrAppend ( astralChar , returnState ) ; } else { errNcrOutOfRange ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } } } private String toUPlusString ( char c ) { String hexString = Integer . toHexString ( c ) ; switch ( hexString . length ( ) ) { case 1 : return "U+000" + hexString ; case 2 : return "U+00" + hexString ; case 3 : return "U+0" + hexString ; case 4 : return "U+" + hexString ; default : throw new RuntimeException ( "Unreachable." ) ; } } private boolean isLegalXmlCharValue ( int charval ) { return charval == 0x0009 || charval == 0x000A || charval == 0x000D || ( charval >= 0x0020 && charval <= 0xD7FF ) || ( charval >= 0xE000 && charval <= 0xFFFD ) || ( charval >= 0x10000 && charval <= 0x10FFFF ) ; } private boolean isPrivateUse ( char c ) { return c >= '' && c <= '' ; } private boolean isAstralPrivateUse ( int c ) { return ( c >= 0xF0000 && c <= 0xFFFFD ) || ( c >= 0x100000 && c <= 0x10FFFD ) ; } private void warnAboutPrivateUseChar ( ) throws SAXException { if ( ! alreadyWarnedAboutPrivateUseCharacters ) { warn ( "Document uses the Unicode Private Use Area(s), which should not be used in publicly exchanged documents. (Charmod C073)" ) ; alreadyWarnedAboutPrivateUseCharacters = true ; } } private void errBadCharBeforeAttributeNameOrNull ( char c ) throws SAXException { if ( c == '=' ) { errEqualsSignBeforeAttributeName ( ) ; } else if ( c != '�' ) { errQuoteBeforeAttributeName ( c ) ; } else { err ( "The character “" + c + "” is not allowed in “" + piTarget + "” pseudo-attribute names." ) ; } } private void errCharRefLacksSemicolon ( ) throws SAXException { err ( "Character reference was not terminated by a semicolon." ) ; } private void errDuplicateAttribute ( ) throws SAXException { err ( "Duplicate “" + piTarget + "” pseudo-attribute “" + attributeName + "”." ) ; } private void errEqualsSignBeforeAttributeName ( ) throws SAXException { err ( "Saw “=” when expecting “" + piTarget + "” pseudo-attribute name. Probable cause: Pseudo-attribute name missing." ) ; } private void errLtOrEqualsOrGraveInUnquotedAttributeOrNull ( char c ) throws SAXException { switch ( c ) { case '=' : err ( "“=” at the start of an unquoted “" + piTarget + "” pseudo-attribute value. Probable cause: Stray duplicate equals sign." ) ; return ; case '<' : return ; case '`' : err ( "“`” at the start of an unquoted “" + piTarget + "” pseudo-attribute value. Probable cause: Using the wrong character as a quote." ) ; return ; } } private void errNoSpaceBetweenAttributes ( ) throws SAXException { err ( "Space is required between “" + piTarget + "” pseudo-attributes." ) ; } private void errQuoteBeforeAttributeName ( char c ) throws SAXException { err ( "Saw “" + c + "” when expecting a pseudo-attribute name. Probable cause: “=” missing immediately before." ) ; } private void errQuoteOrLtInAttributeNameOrNull ( char c ) throws SAXException { if ( c == '<' ) { } else if ( c != '�' ) { err ( "Quote “" + c + "” in pseudo-attribute name. Probable cause: Matching quote missing somewhere earlier." ) ; } } private void errUnquotedAttributeValOrNull ( ) throws SAXException { err ( "Found unquoted value for “" + piTarget + "” pseudo-attribute “" + attributeName + "”. The value of all pseudo-attributes in “" + piTarget + "” instructions must be quoted." ) ; } private void errNoNamedCharacterMatch ( ) throws SAXException { if ( getErrorHandler ( ) == null ) { return ; } SAXParseException spe = new SAXParseException ( "“&” did not start a character reference. (“&” probably should have been escaped as “&amp;”.)" , getDocumentLocator ( ) ) ; getErrorHandler ( ) . error ( spe ) ; } private void errNcrControlChar ( ) throws SAXException { warn ( "Character reference expands to a control character (" + toUPlusString ( ( char ) value ) + ")." ) ; } private void errNcrIllegalValueForXml ( ) throws SAXException { err ( "Character reference expands to a character that is not legal in XML (" + toUPlusString ( ( char ) value ) + ")." ) ; } private void errNcrSurrogate ( ) throws SAXException { err ( "Character reference expands to a surrogate." ) ; } private void errNcrUnassigned ( ) throws SAXException { err ( "Character reference expands to a permanently unassigned code point." ) ; } private char errNcrNonCharacter ( char ch ) throws SAXException { err ( "Character reference expands to a non-character (" + toUPlusString ( ( char ) value ) + ")." ) ; return ch ; } private void errNcrOutOfRange ( ) throws SAXException { err ( "Character reference outside the permissible Unicode range." ) ; } private void errNoDigitsInNCR ( ) throws SAXException { err ( "No digits after “" + new String ( strBuf , 0 , strBufLen ) + "”." ) ; } private void errUnescapedAmpersandInterpretedAsCharacterReference ( ) throws SAXException { if ( getErrorHandler ( ) == null ) { return ; } SAXParseException spe = new SAXParseException ( "The string following “&” was interpreted as a character reference. (“&” probably should have been escaped as “&amp;”.)" , getDocumentLocator ( ) ) ; getErrorHandler ( ) . error ( spe ) ; } private void maybeWarnPrivateUse ( char ch ) throws SAXException { if ( getErrorHandler ( ) != null && isPrivateUse ( ch ) ) { warnAboutPrivateUseChar ( ) ; } } private void maybeWarnPrivateUseAstral ( ) throws SAXException { if ( getErrorHandler ( ) != null && isAstralPrivateUse ( value ) ) { warnAboutPrivateUseChar ( ) ; } } private void errAstralNonCharacter ( int ch ) throws SAXException { err ( "Character reference expands to an astral non-character (" + toUPlusString ( ( char ) value ) + ")." ) ; } private static String newAsciiLowerCaseStringFromString ( String str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' ) { c += 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } private static String newAsciiUpperCaseStringFromString ( String str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'a' && c <= 'z' ) { c -= 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
