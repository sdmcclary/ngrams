public class XmlPiChecker extends Checker implements LexicalHandler { private static final char [ ] [ ] NAMES = { "amp;" . toCharArray ( ) , "lt;" . toCharArray ( ) , "gt;" . toCharArray ( ) , "quot;" . toCharArray ( ) , "apos;" . toCharArray ( ) , } ; private static final char [ ] [ ] VALUES = { { '&' } , { '<' } , { '>' } , { '"' } , { '\'' } , } ; private static final int DATA_AND_RCDATA_MASK = ~ 1 ; private static final int BEFORE_ATTRIBUTE_NAME = 0 ; private static final int ATTRIBUTE_NAME = 1 ; private static final int AFTER_ATTRIBUTE_NAME = 2 ; private static final int BEFORE_ATTRIBUTE_VALUE = 3 ; private static final int ATTRIBUTE_VALUE_DOUBLE_QUOTED = 4 ; private static final int ATTRIBUTE_VALUE_SINGLE_QUOTED = 5 ; private static final int ATTRIBUTE_VALUE_UNQUOTED = 6 ; private static final int AFTER_ATTRIBUTE_VALUE_QUOTED = 7 ; private static final int CONSUME_CHARACTER_REFERENCE = 8 ; private static final int CONSUME_NCR = 9 ; private static final int CHARACTER_REFERENCE_LOOP = 10 ; private static final int HEX_NCR_LOOP = 11 ; private static final int DECIMAL_NRC_LOOP = 12 ; private static final int HANDLE_NCR_VALUE = 13 ; private static final int BUFFER_GROW_BY = 1024 ; private static final char [ ] REPLACEMENT_CHARACTER = { '�' } ; private static final int LEAD_OFFSET = ( 0xD800 - ( 0x10000 > > 10 ) ) ; private char [ ] strBuf = new char [ 64 ] ; private int strBufLen ; private char [ ] longStrBuf = new char [ 1024 ] ; private int longStrBufLen ; private final char [ ] bmpChar = new char [ 1 ] ; private final char [ ] astralChar = new char [ 2 ] ; private int entCol ; private int lo ; private int hi ; private int candidate ; private int strBufMark ; private int prevValue ; private int value ; private boolean seenDigits ; private char additional ; private boolean alreadyWarnedAboutPrivateUseCharacters ; private AttributesImpl attributes ; private String attributeName ; private boolean inDoctype ; private boolean alreadyHasElement ; private String piTarget = null ; private boolean hasXsltPi ; private enum PseudoAttrName { HREF , TYPE , TITLE , MEDIA , CHARSET , ALTERNATE , INVALID ; private static PseudoAttrName toCaps ( String str ) { try { if ( ! str . toLowerCase ( ) . equals ( str ) ) { return INVALID ; } return valueOf ( newAsciiUpperCaseStringFromString ( str ) ) ; } catch ( Exception ex ) { return INVALID ; } } } public XmlPiChecker ( ) { super ( ) ; inDoctype = false ; hasXsltPi = false ; alreadyHasElement = false ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { inDoctype = true ; } public void endDTD ( ) throws SAXException { inDoctype = false ; } public void startEntity ( String name ) throws SAXException { } public void endEntity ( String name ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void endCDATA ( ) throws SAXException { } public void comment ( char [ ] ch , int start , int len ) throws SAXException { } @ Override public void startDocument ( ) throws SAXException { inDoctype = false ; hasXsltPi = false ; alreadyHasElement = false ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { alreadyHasElement = true ; } @ Override public void processingInstruction ( String target , String data ) throws SAXException { piTarget = target ; if ( "xml-stylesheet" . equals ( piTarget ) ) { checkXmlStylesheetPiData ( data ) ; } } private void errBadPseudoAttrDatatype ( DatatypeException e , Class < ? > datatypeClass , String attrName , String attrValue ) throws SAXException , ClassNotFoundException { if ( getErrorHandler ( ) != null ) { Html5DatatypeException ex5 = ( Html5DatatypeException ) e ; boolean warning = ex5 . isWarning ( ) ? true : false ; DatatypeMismatchException bpe = new DatatypeMismatchException ( "Bad value “" + attrValue + "” for “" + piTarget + "” pseudo-attribute “" + attrName + "”. " + e . getMessage ( ) , getDocumentLocator ( ) , datatypeClass , warning ) ; getErrorHandler ( ) . error ( bpe ) ; } } private void errAttributeWithNoValue ( ) throws SAXException { err ( "Found “" + piTarget + "” pseudo-attribute “" + attributeName + "” without a value. All pseudo-attributes in “" + piTarget + "” instructions must have values." ) ; } private void errAttributeValueContainsLt ( ) throws SAXException { err ( "Found “" + piTarget + "” pseudo-attribute “" + attributeName + "” with the character “<” in its value. All pseudo-attribute values in “" + piTarget + "” instructions must not contain the character “<”." ) ; } private void errUpperCaseXinHexNcr ( ) throws SAXException { err ( "In XML documents, a hexadecimal character reference must begin with " + "“&#x” (lowercase “x”), not “&#X” (uppercase “X”)." ) ; } private void checkXmlStylesheetPiData ( String data ) throws SAXException { boolean hasHref = false ; boolean hasTitle = false ; boolean hasMedia = false ; boolean hasCharset = false ; boolean hasAlternate = false ; boolean hasNonEmptyTitle = false ; boolean alternateIsYes = false ; boolean badDatatype = false ; if ( inDoctype ) { warn ( "An “xml-stylesheet” instruction should not be used within a “DOCTYPE” declaration." ) ; } if ( alreadyHasElement ) { err ( "Any “xml-stylesheet” instruction in a document must occur before any elements in the document. " + "Suppressing any further errors for this “xml-stylesheet” instruction." ) ; return ; } if ( ! "" . equals ( data ) ) { Html5DatatypeLibrary dl = new Html5DatatypeLibrary ( ) ; AttributesImpl patts = getPseudoAttributesFromPiData ( data ) ; String attrName ; String attrValue ; for ( int i = 0 ; i < patts . getLength ( ) ; i ++ ) { attrName = patts . getQName ( i ) ; attrValue = patts . getValue ( i ) ; switch ( PseudoAttrName . toCaps ( attrName ) ) { case HREF : hasHref = true ; if ( attrValue == null ) { break ; } try { IriRef ir = ( IriRef ) dl . createDatatype ( "iri-ref" ) ; ir . checkValid ( attrValue ) ; } catch ( DatatypeException e ) { try { errBadPseudoAttrDatatype ( e , IriRef . class , "href" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } break ; case TYPE : if ( attrValue == null ) { break ; } try { MimeType mt = ( MimeType ) dl . createDatatype ( "mime-type" ) ; mt . checkValid ( attrValue ) ; attrValue = newAsciiLowerCaseStringFromString ( attrValue ) ; } catch ( DatatypeException e ) { badDatatype = true ; try { errBadPseudoAttrDatatype ( e , MimeType . class , "type" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } if ( ! badDatatype ) { if ( attrValue . matches ( "application/xml(;.*)?" ) || attrValue . matches ( "text/xml(;.*)?" ) || attrValue . matches ( "application/xslt+xml(;.*)?" ) || attrValue . matches ( "text/xsl(;.*)?" ) || attrValue . matches ( "text/xslt(;.*)?" ) ) { if ( ! attrValue . matches ( "text/xsl(;.*)?" ) ) { warn ( "For indicating XSLT, “text/xsl” is the only MIME type for the " + "“xml-stylesheet” pseudo-attribute “type” that is supported across browsers." ) ; } if ( hasXsltPi ) { warn ( "Browsers do not support multiple “xml-stylesheet” instructions with a " + "“type” value that indicates XSLT." ) ; } hasXsltPi = true ; } else if ( ! attrValue . matches ( "^text/css(;.*)?$" ) ) { warn ( "“text/css” and “text/xsl” are the only MIME types for the " + "“xml-stylesheet” pseudo-attribute “type” that are supported across browsers." ) ; } } break ; case TITLE : hasTitle = true ; if ( attrValue == null ) { break ; } if ( ! "" . equals ( attrValue ) ) { hasNonEmptyTitle = true ; } break ; case MEDIA : hasMedia = true ; if ( attrValue == null ) { break ; } try { MediaQuery mq = ( MediaQuery ) dl . createDatatype ( "media-query" ) ; mq . checkValid ( attrValue ) ; } catch ( DatatypeException e ) { try { errBadPseudoAttrDatatype ( e , MediaQuery . class , "media" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } break ; case CHARSET : hasCharset = true ; if ( attrValue == null ) { break ; } try { Charset c = ( Charset ) dl . createDatatype ( "charset" ) ; c . checkValid ( attrValue ) ; } catch ( DatatypeException e ) { try { errBadPseudoAttrDatatype ( e , Charset . class , "charset" , attrValue ) ; } catch ( ClassNotFoundException ce ) { } } break ; case ALTERNATE : hasAlternate = true ; if ( attrValue == null ) { break ; } if ( "yes" . equals ( attrValue ) ) { alternateIsYes = true ; } else if ( ! "no" . equals ( attrValue ) ) { err ( "The value of the “xml-stylesheet” pseudo-attribute “alternate” " + "must be either “yes” or “no”." ) ; } break ; default : err ( "Pseudo-attribute “" + attrName + "” not allowed in “xml-stylesheet” instruction." ) ; break ; } } if ( alternateIsYes && ! hasNonEmptyTitle ) { err ( "An “xml-stylesheet” instruction with an “alternate” pseudo-attribute " + "whose value is “yes” must also have a “title” pseudo-attribute with a non-empty value." ) ; } } if ( ! hasHref ) { err ( "“xml-stylesheet” instruction lacks “href” pseudo-attribute. " + "The “href” pseudo-attribute is required in all “xml-stylesheet” instructions." ) ; } if ( hasXsltPi && ( hasTitle || hasMedia || hasCharset || hasAlternate ) ) { warn ( "When processing “xml-stylesheet” instructions, browsers ignore the pseudo-attributes " + "“title”, “media”, “charset”, and “alternate”." ) ; } else if ( hasCharset ) { warn ( "Some browsers ignore the value of the “xml-stylesheet” pseudo-attribute “charset”." ) ; } } private AttributesImpl getPseudoAttributesFromPiData ( String buf ) throws SAXException { int state = BEFORE_ATTRIBUTE_NAME ; int returnState = BEFORE_ATTRIBUTE_NAME ; char c = ' ' ; int pos = - 1 ; int endPos = buf . length ( ) ; boolean reconsume = false ; attributes = null ; attributeName = null ; stateloop : for ( ; ; ) { switch ( state ) { case BEFORE_ATTRIBUTE_NAME : beforeattributenameloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '\n' : case ' ' : case '\t' : continue ; case '/' : case '>' : case '\"' : case '\'' : case '<' : case '=' : errBadCharBeforeAttributeNameOrNull ( c ) ; default : clearStrBufAndAppendCurrentC ( c ) ; state = ATTRIBUTE_NAME ; break beforeattributenameloop ; } } case ATTRIBUTE_NAME : attributenameloop : for ( ; ; ) { if ( ++ pos == endPos ) { attributeNameComplete ( ) ; addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : attributeNameComplete ( ) ; state = AFTER_ATTRIBUTE_NAME ; continue stateloop ; case '=' : attributeNameComplete ( ) ; state = BEFORE_ATTRIBUTE_VALUE ; break attributenameloop ; case '\"' : case '\'' : case '<' : errQuoteOrLtInAttributeNameOrNull ( c ) ; default : appendStrBuf ( c ) ; continue ; } } case BEFORE_ATTRIBUTE_VALUE : beforeattributevalueloop : for ( ; ; ) { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : continue ; case '"' : clearLongStrBufForNextState ( ) ; state = ATTRIBUTE_VALUE_DOUBLE_QUOTED ; break beforeattributevalueloop ; case '&' : clearLongStrBuf ( ) ; state = ATTRIBUTE_VALUE_UNQUOTED ; reconsume = true ; continue stateloop ; case '\'' : clearLongStrBufForNextState ( ) ; state = ATTRIBUTE_VALUE_SINGLE_QUOTED ; continue stateloop ; case '<' : case '=' : case '`' : errLtOrEqualsOrGraveInUnquotedAttributeOrNull ( c ) ; default : clearLongStrBufAndAppendCurrentC ( c ) ; state = ATTRIBUTE_VALUE_UNQUOTED ; continue stateloop ; } } case ATTRIBUTE_VALUE_DOUBLE_QUOTED : attributevaluedoublequotedloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '"' : addAttributeWithValue ( ) ; state = AFTER_ATTRIBUTE_VALUE_QUOTED ; break attributevaluedoublequotedloop ; case '&' : clearStrBufAndAppendCurrentC ( c ) ; returnState = state ; state = CONSUME_CHARACTER_REFERENCE ; continue stateloop ; case '\n' : appendLongStrBufLineFeed ( ) ; continue ; default : appendLongStrBuf ( c ) ; continue ; } } case AFTER_ATTRIBUTE_VALUE_QUOTED : for ( ; ; ) { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : state = BEFORE_ATTRIBUTE_NAME ; continue stateloop ; default : errNoSpaceBetweenAttributes ( ) ; state = BEFORE_ATTRIBUTE_NAME ; reconsume = true ; continue stateloop ; } } case ATTRIBUTE_VALUE_UNQUOTED : errUnquotedAttributeValOrNull ( ) ; for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { addAttributeWithValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '\n' : case ' ' : case '\t' : addAttributeWithValue ( ) ; state = BEFORE_ATTRIBUTE_NAME ; continue stateloop ; case '&' : clearStrBufAndAppendCurrentC ( c ) ; returnState = state ; state = CONSUME_CHARACTER_REFERENCE ; continue stateloop ; case '>' : continue stateloop ; case '<' : case '\"' : case '\'' : case '=' : case '`' : default : appendLongStrBuf ( c ) ; continue ; } } case AFTER_ATTRIBUTE_NAME : for ( ; ; ) { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '\n' : case ' ' : case '\t' : continue ; case '=' : state = BEFORE_ATTRIBUTE_VALUE ; continue stateloop ; case '\"' : case '\'' : case '<' : errQuoteOrLtInAttributeNameOrNull ( c ) ; default : addAttributeWithoutValue ( ) ; clearStrBufAndAppendCurrentC ( c ) ; state = ATTRIBUTE_NAME ; continue stateloop ; } } case ATTRIBUTE_VALUE_SINGLE_QUOTED : attributevaluesinglequotedloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { addAttributeWithoutValue ( ) ; break stateloop ; } c = buf . charAt ( pos ) ; } switch ( c ) { case '\'' : addAttributeWithValue ( ) ; state = AFTER_ATTRIBUTE_VALUE_QUOTED ; continue stateloop ; case '&' : clearStrBufAndAppendCurrentC ( c ) ; returnState = state ; state = CONSUME_CHARACTER_REFERENCE ; break attributevaluesinglequotedloop ; case '\n' : appendLongStrBufLineFeed ( ) ; continue ; default : appendLongStrBuf ( c ) ; continue ; } } case CONSUME_CHARACTER_REFERENCE : if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; switch ( c ) { case '#' : appendStrBuf ( '#' ) ; state = CONSUME_NCR ; continue stateloop ; default : if ( c == additional ) { emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } entCol = - 1 ; lo = 0 ; hi = ( NAMES . length - 1 ) ; candidate = - 1 ; strBufMark = 0 ; state = CHARACTER_REFERENCE_LOOP ; reconsume = true ; } case CHARACTER_REFERENCE_LOOP : outer : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; } entCol ++ ; hiloop : for ( ; ; ) { if ( hi == - 1 ) { break hiloop ; } if ( entCol == NAMES [ hi ] . length ) { break hiloop ; } if ( entCol > NAMES [ hi ] . length ) { break outer ; } else if ( c < NAMES [ hi ] [ entCol ] ) { hi -- ; } else { break hiloop ; } } loloop : for ( ; ; ) { if ( hi < lo ) { break outer ; } if ( entCol == NAMES [ lo ] . length ) { candidate = lo ; strBufMark = strBufLen ; lo ++ ; } else if ( entCol > NAMES [ lo ] . length ) { break outer ; } else if ( c > NAMES [ lo ] [ entCol ] ) { lo ++ ; } else { break loloop ; } } if ( hi < lo ) { break outer ; } appendStrBuf ( c ) ; continue ; } if ( candidate == - 1 ) { errNoNamedCharacterMatch ( ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } else { char [ ] candidateArr = NAMES [ candidate ] ; if ( candidateArr [ candidateArr . length - 1 ] != ';' ) { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { char ch ; if ( strBufMark == strBufLen ) { ch = c ; } else { ch = strBuf [ strBufMark ] ; } if ( ( ch >= '0' && ch <= '9' ) || ( ch >= 'A' && ch <= 'Z' ) || ( ch >= 'a' && ch <= 'z' ) ) { errNoNamedCharacterMatch ( ) ; appendStrBufToLongStrBuf ( ) ; state = returnState ; reconsume = true ; continue stateloop ; } } if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { errUnescapedAmpersandInterpretedAsCharacterReference ( ) ; } } char [ ] val = VALUES [ candidate ] ; emitOrAppend ( val , returnState ) ; if ( strBufMark < strBufLen ) { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { for ( int i = strBufMark ; i < strBufLen ; i ++ ) { appendLongStrBuf ( strBuf [ i ] ) ; } } } state = returnState ; reconsume = true ; continue stateloop ; } case CONSUME_NCR : if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; prevValue = - 1 ; value = 0 ; seenDigits = false ; switch ( c ) { case 'x' : appendStrBuf ( c ) ; state = HEX_NCR_LOOP ; continue stateloop ; case 'X' : errUpperCaseXinHexNcr ( ) ; appendStrBuf ( c ) ; state = HEX_NCR_LOOP ; continue stateloop ; default : state = DECIMAL_NRC_LOOP ; reconsume = true ; } case DECIMAL_NRC_LOOP : decimalloop : for ( ; ; ) { if ( reconsume ) { reconsume = false ; } else { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; } if ( value < prevValue ) { value = 0x110000 ; } prevValue = value ; if ( c >= '0' && c <= '9' ) { seenDigits = true ; value *= 10 ; value += c - '0' ; continue ; } else if ( c == ';' ) { if ( seenDigits ) { state = HANDLE_NCR_VALUE ; break decimalloop ; } else { errNoDigitsInNCR ( ) ; appendStrBuf ( ';' ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; continue stateloop ; } } else { if ( ! seenDigits ) { errNoDigitsInNCR ( ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } else { errCharRefLacksSemicolon ( ) ; state = HANDLE_NCR_VALUE ; reconsume = true ; break decimalloop ; } } } case HANDLE_NCR_VALUE : handleNcrValue ( returnState ) ; state = returnState ; continue stateloop ; case HEX_NCR_LOOP : for ( ; ; ) { if ( ++ pos == endPos ) { break stateloop ; } c = buf . charAt ( pos ) ; if ( value < prevValue ) { value = 0x110000 ; } prevValue = value ; if ( c >= '0' && c <= '9' ) { seenDigits = true ; value *= 16 ; value += c - '0' ; continue ; } else if ( c >= 'A' && c <= 'F' ) { seenDigits = true ; value *= 16 ; value += c - 'A' + 10 ; continue ; } else if ( c >= 'a' && c <= 'f' ) { seenDigits = true ; value *= 16 ; value += c - 'a' + 10 ; continue ; } else if ( c == ';' ) { if ( seenDigits ) { state = HANDLE_NCR_VALUE ; continue stateloop ; } else { errNoDigitsInNCR ( ) ; appendStrBuf ( ';' ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; continue stateloop ; } } else { if ( ! seenDigits ) { errNoDigitsInNCR ( ) ; emitOrAppendStrBuf ( returnState ) ; state = returnState ; reconsume = true ; continue stateloop ; } else { errCharRefLacksSemicolon ( ) ; state = HANDLE_NCR_VALUE ; reconsume = true ; continue stateloop ; } } } } } return attributes ; } private void appendStrBufToLongStrBuf ( ) { appendLongStrBuf ( strBuf , 0 , strBufLen ) ; } private void appendLongStrBuf ( char [ ] buffer , int offset , int length ) { int reqLen = longStrBufLen + length ; if ( longStrBuf . length < reqLen ) { char [ ] newBuf = new char [ reqLen + ( reqLen > > 1 ) ] ; System . arraycopy ( longStrBuf , 0 , newBuf , 0 , longStrBuf . length ) ; longStrBuf = newBuf ; } System . arraycopy ( buffer , offset , longStrBuf , longStrBufLen , length ) ; longStrBufLen = reqLen ; } private void appendLongStrBuf ( char [ ] arr ) { appendLongStrBuf ( arr , 0 , arr . length ) ; } private void appendLongStrBuf ( char c ) { if ( longStrBufLen == longStrBuf . length ) { char [ ] newBuf = new char [ longStrBufLen + ( longStrBufLen > > 1 ) ] ; System . arraycopy ( longStrBuf , 0 , newBuf , 0 , longStrBuf . length ) ; longStrBuf = newBuf ; } longStrBuf [ longStrBufLen ++ ] = c ; } private void appendLongStrBufLineFeed ( ) { appendLongStrBuf ( '\n' ) ; } private void appendStrBuf ( char c ) { if ( strBufLen == strBuf . length ) { char [ ] newBuf = new char [ strBuf . length + BUFFER_GROW_BY ] ; System . arraycopy ( strBuf , 0 , newBuf , 0 , strBuf . length ) ; strBuf = newBuf ; } strBuf [ strBufLen ++ ] = c ; } private void clearLongStrBufForNextState ( ) { longStrBufLen = 0 ; } private void clearLongStrBuf ( ) { longStrBufLen = 0 ; } private void clearLongStrBufAndAppendCurrentC ( char c ) { longStrBuf [ 0 ] = c ; longStrBufLen = 1 ; } private void clearStrBufAndAppendCurrentC ( char c ) { strBuf [ 0 ] = c ; strBufLen = 1 ; } private void emitOrAppend ( char [ ] val , int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendLongStrBuf ( val ) ; } } private void emitOrAppendOne ( char [ ] val , int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendLongStrBuf ( val [ 0 ] ) ; } } private void emitOrAppendTwo ( char [ ] val , int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendLongStrBuf ( val [ 0 ] ) ; appendLongStrBuf ( val [ 1 ] ) ; } } private void emitOrAppendStrBuf ( int returnState ) throws SAXException { if ( ( returnState & DATA_AND_RCDATA_MASK ) != 0 ) { appendStrBufToLongStrBuf ( ) ; } } private String longStrBufToString ( ) { return new String ( longStrBuf , 0 , longStrBufLen ) ; } private void attributeNameComplete ( ) throws SAXException { attributeName = new String ( strBuf , 0 , strBufLen ) . intern ( ) ; if ( attributes == null ) { attributes = new AttributesImpl ( ) ; } for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { if ( attributes . getQName ( i ) . equals ( attributeName ) ) { errDuplicateAttribute ( ) ; attributeName = null ; return ; } } } private void addAttributeWithValue ( ) throws SAXException { if ( attributeName != null ) { String value = longStrBufToString ( ) ; if ( value . indexOf ( "<" ) != - 1 ) { errAttributeValueContainsLt ( ) ; return ; } if ( badCharInCandidateAttributeName ( ) ) { return ; } attributes . addAttribute ( "" , "" , attributeName , "" , value ) ; attributeName = null ; } } private void addAttributeWithoutValue ( ) throws SAXException { if ( attributeName != null ) { if ( badCharInCandidateAttributeName ( ) ) { return ; } attributes . addAttribute ( "" , "" , attributeName , "" , null ) ; errAttributeWithNoValue ( ) ; attributeName = null ; } } private boolean badCharInCandidateAttributeName ( ) { return attributeName . indexOf ( "/" ) != - 1 || attributeName . indexOf ( ">" ) != - 1 || attributeName . indexOf ( "\"" ) != - 1 || attributeName . indexOf ( "\'" ) != - 1 || attributeName . indexOf ( "<" ) != - 1 || attributeName . indexOf ( "=" ) != - 1 ; } private void handleNcrValue ( int returnState ) throws SAXException { if ( ! isLegalXmlCharValue ( value ) ) { errNcrIllegalValueForXml ( ) ; } else { if ( value <= 0xFFFF ) { if ( ( value & 0xF800 ) == 0xD800 ) { errNcrSurrogate ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } else { char ch = ( char ) value ; if ( value >= 0xFDD0 && value <= 0xFDEF ) { errNcrUnassigned ( ) ; } else if ( ( value & 0xFFFE ) == 0xFFFE ) { ch = errNcrNonCharacter ( ch ) ; } else if ( value >= 0x007F && value <= 0x009F ) { errNcrControlChar ( ) ; } else { maybeWarnPrivateUse ( ch ) ; } bmpChar [ 0 ] = ch ; emitOrAppendOne ( bmpChar , returnState ) ; } } else if ( value <= 0x10FFFF ) { maybeWarnPrivateUseAstral ( ) ; if ( ( value & 0xFFFE ) == 0xFFFE ) { errAstralNonCharacter ( value ) ; } astralChar [ 0 ] = ( char ) ( LEAD_OFFSET + ( value > > 10 ) ) ; astralChar [ 1 ] = ( char ) ( 0xDC00 + ( value & 0x3FF ) ) ; emitOrAppendTwo ( astralChar , returnState ) ; } else { errNcrOutOfRange ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } if ( ( value & 0xF800 ) == 0xD800 ) { errNcrSurrogate ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } else if ( value <= 0xFFFF ) { char ch = ( char ) value ; if ( value >= 0xFDD0 && value <= 0xFDEF ) { errNcrUnassigned ( ) ; } else if ( ( value & 0xFFFE ) == 0xFFFE ) { ch = errNcrNonCharacter ( ch ) ; } else if ( value >= 0x007F && value <= 0x009F ) { errNcrControlChar ( ) ; } else { maybeWarnPrivateUse ( ch ) ; } bmpChar [ 0 ] = ch ; emitOrAppendOne ( bmpChar , returnState ) ; } else if ( value <= 0x10FFFF ) { maybeWarnPrivateUseAstral ( ) ; astralChar [ 0 ] = ( char ) ( LEAD_OFFSET + ( value > > 10 ) ) ; astralChar [ 1 ] = ( char ) ( 0xDC00 + ( value & 0x3FF ) ) ; emitOrAppend ( astralChar , returnState ) ; } else { errNcrOutOfRange ( ) ; emitOrAppendOne ( REPLACEMENT_CHARACTER , returnState ) ; } } } private String toUPlusString ( char c ) { String hexString = Integer . toHexString ( c ) ; switch ( hexString . length ( ) ) { case 1 : return "U+000" + hexString ; case 2 : return "U+00" + hexString ; case 3 : return "U+0" + hexString ; case 4 : return "U+" + hexString ; default : throw new RuntimeException ( "Unreachable." ) ; } } private boolean isLegalXmlCharValue ( int charval ) { return charval == 0x0009 || charval == 0x000A || charval == 0x000D || ( charval >= 0x0020 && charval <= 0xD7FF ) || ( charval >= 0xE000 && charval <= 0xFFFD ) || ( charval >= 0x10000 && charval <= 0x10FFFF ) ; } private boolean isPrivateUse ( char c ) { return c >= '' && c <= '' ; } private boolean isAstralPrivateUse ( int c ) { return ( c >= 0xF0000 && c <= 0xFFFFD ) || ( c >= 0x100000 && c <= 0x10FFFD ) ; } private void warnAboutPrivateUseChar ( ) throws SAXException { if ( ! alreadyWarnedAboutPrivateUseCharacters ) { warn ( "Document uses the Unicode Private Use Area(s), which should not be used in publicly exchanged documents. (Charmod C073)" ) ; alreadyWarnedAboutPrivateUseCharacters = true ; } } private void errBadCharBeforeAttributeNameOrNull ( char c ) throws SAXException { if ( c == '=' ) { errEqualsSignBeforeAttributeName ( ) ; } else if ( c != '�' ) { errQuoteBeforeAttributeName ( c ) ; } else { err ( "The character “" + c + "” is not allowed in “" + piTarget + "” pseudo-attribute names." ) ; } } private void errCharRefLacksSemicolon ( ) throws SAXException { err ( "Character reference was not terminated by a semicolon." ) ; } private void errDuplicateAttribute ( ) throws SAXException { err ( "Duplicate “" + piTarget + "” pseudo-attribute “" + attributeName + "”." ) ; } private void errEqualsSignBeforeAttributeName ( ) throws SAXException { err ( "Saw “=” when expecting “" + piTarget + "” pseudo-attribute name. Probable cause: Pseudo-attribute name missing." ) ; } private void errLtOrEqualsOrGraveInUnquotedAttributeOrNull ( char c ) throws SAXException { switch ( c ) { case '=' : err ( "“=” at the start of an unquoted “" + piTarget + "” pseudo-attribute value. Probable cause: Stray duplicate equals sign." ) ; return ; case '<' : return ; case '`' : err ( "“`” at the start of an unquoted “" + piTarget + "” pseudo-attribute value. Probable cause: Using the wrong character as a quote." ) ; return ; } } private void errNoSpaceBetweenAttributes ( ) throws SAXException { err ( "Space is required between “" + piTarget + "” pseudo-attributes." ) ; } private void errQuoteBeforeAttributeName ( char c ) throws SAXException { err ( "Saw “" + c + "” when expecting a pseudo-attribute name. Probable cause: “=” missing immediately before." ) ; } private void errQuoteOrLtInAttributeNameOrNull ( char c ) throws SAXException { if ( c == '<' ) { } else if ( c != '�' ) { err ( "Quote “" + c + "” in pseudo-attribute name. Probable cause: Matching quote missing somewhere earlier." ) ; } } private void errUnquotedAttributeValOrNull ( ) throws SAXException { err ( "Found unquoted value for “" + piTarget + "” pseudo-attribute “" + attributeName + "”. The value of all pseudo-attributes in “" + piTarget + "” instructions must be quoted." ) ; } private void errNoNamedCharacterMatch ( ) throws SAXException { if ( getErrorHandler ( ) == null ) { return ; } SAXParseException spe = new SAXParseException ( "“&” did not start a character reference. (“&” probably should have been escaped as “&amp;”.)" , getDocumentLocator ( ) ) ; getErrorHandler ( ) . error ( spe ) ; } private void errNcrControlChar ( ) throws SAXException { warn ( "Character reference expands to a control character (" + toUPlusString ( ( char ) value ) + ")." ) ; } private void errNcrIllegalValueForXml ( ) throws SAXException { err ( "Character reference expands to a character that is not legal in XML (" + toUPlusString ( ( char ) value ) + ")." ) ; } private void errNcrSurrogate ( ) throws SAXException { err ( "Character reference expands to a surrogate." ) ; } private void errNcrUnassigned ( ) throws SAXException { err ( "Character reference expands to a permanently unassigned code point." ) ; } private char errNcrNonCharacter ( char ch ) throws SAXException { err ( "Character reference expands to a non-character (" + toUPlusString ( ( char ) value ) + ")." ) ; return ch ; } private void errNcrOutOfRange ( ) throws SAXException { err ( "Character reference outside the permissible Unicode range." ) ; } private void errNoDigitsInNCR ( ) throws SAXException { err ( "No digits after “" + new String ( strBuf , 0 , strBufLen ) + "”." ) ; } private void errUnescapedAmpersandInterpretedAsCharacterReference ( ) throws SAXException { if ( getErrorHandler ( ) == null ) { return ; } SAXParseException spe = new SAXParseException ( "The string following “&” was interpreted as a character reference. (“&” probably should have been escaped as “&amp;”.)" , getDocumentLocator ( ) ) ; getErrorHandler ( ) . error ( spe ) ; } private void maybeWarnPrivateUse ( char ch ) throws SAXException { if ( getErrorHandler ( ) != null && isPrivateUse ( ch ) ) { warnAboutPrivateUseChar ( ) ; } } private void maybeWarnPrivateUseAstral ( ) throws SAXException { if ( getErrorHandler ( ) != null && isAstralPrivateUse ( value ) ) { warnAboutPrivateUseChar ( ) ; } } private void errAstralNonCharacter ( int ch ) throws SAXException { err ( "Character reference expands to an astral non-character (" + toUPlusString ( ( char ) value ) + ")." ) ; } private static String newAsciiLowerCaseStringFromString ( String str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' ) { c += 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } private static String newAsciiUpperCaseStringFromString ( String str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'a' && c <= 'z' ) { c -= 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } } 