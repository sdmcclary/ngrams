<<<<<<< HEAD
public class FileSystemSearchPage extends AbstractTextSearchViewPage implements IAdaptable { public Integer getElementLimit1 ( ) { if ( Compatibility . isTableLimited ( ) ) { return new Integer ( Compatibility . getTableLimit ( ) ) ; } return new Integer ( - 1 ) ; } public static class DecoratorIgnoringViewerSorter extends ViewerComparator { private final ILabelProvider fLabelProvider ; public DecoratorIgnoringViewerSorter ( ILabelProvider labelProvider ) { fLabelProvider = labelProvider ; } public int category ( Object element ) { File fl = null ; if ( element instanceof File ) { fl = ( File ) element ; } else { fl = ( ( AptanaFileSystemMatch ) element ) . getFile ( ) ; } if ( fl . isDirectory ( ) ) { return 1 ; } return 2 ; } public int compare ( Viewer viewer , Object e1 , Object e2 ) { int cat1 = category ( e1 ) ; int cat2 = category ( e2 ) ; if ( cat1 != cat2 ) { return cat1 - cat2 ; } String name1 = fLabelProvider . getText ( e1 ) ; String name2 = fLabelProvider . getText ( e2 ) ; if ( name1 == null ) { name1 = "" ; } if ( name2 == null ) { name2 = "" ; } return getComparator ( ) . compare ( name1 , name2 ) ; } } private static final String KEY_SORTING = "org.eclipse.search.resultpage.sorting" ; private ActionGroup fActionGroup ; private IFileSearchContentProvider fContentProvider ; private int fCurrentSortOrder ; private SortAction fSortByNameAction ; private SortAction fSortByPathAction ; private EditorOpener fEditorOpener = new EditorOpener ( ) ; private static final String [ ] SHOW_IN_TARGETS = new String [ ] { IPageLayout . ID_RES_NAV } ; private static final IShowInTargetList SHOW_IN_TARGET_LIST = new IShowInTargetList ( ) { public String [ ] getShowInTargetIds ( ) { return FileSystemSearchPage . SHOW_IN_TARGETS ; } } ; private IPropertyChangeListener fPropertyChangeListener ; public FileSystemSearchPage ( ) { fSortByNameAction = new SortAction ( SearchMessages . FileSearchPage_sort_name_label , this , FileLabelProvider . SHOW_LABEL_PATH ) ; fSortByPathAction = new SortAction ( SearchMessages . FileSearchPage_sort_path_label , this , FileLabelProvider . SHOW_PATH_LABEL ) ; fPropertyChangeListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { if ( Compatibility . ORG_ECLIPSE_SEARCH_LIMIT_TABLE . equals ( event . getProperty ( ) ) || Compatibility . ORG_ECLIPSE_SEARCH_LIMIT_TABLE_TO . equals ( event . getProperty ( ) ) ) { if ( getViewer ( ) instanceof TableViewer ) { getViewPart ( ) . updateLabel ( ) ; getViewer ( ) . refresh ( ) ; } } } } ; SearchPlugin . getDefault ( ) . getPreferenceStore ( ) . addPropertyChangeListener ( fPropertyChangeListener ) ; } private void addDragAdapters ( StructuredViewer viewer ) { Transfer [ ] transfers = new Transfer [ ] { ResourceTransfer . getInstance ( ) } ; int ops = DND . DROP_COPY | DND . DROP_LINK ; DelegatingDragAdapter adapter = new DelegatingDragAdapter ( ) ; adapter . addDragSourceListener ( new com . aptana . ide . search . epl . ResourceTransferDragAdapter ( viewer ) ) ; viewer . addDragSupport ( ops , transfers , adapter ) ; } public StructuredViewer getViewer ( ) { return super . getViewer ( ) ; } protected void configureTableViewer ( TableViewer viewer ) { viewer . setUseHashlookup ( true ) ; FileLabelProvider innerLabelProvider = new FileLabelProvider ( this , fCurrentSortOrder ) ; viewer . setLabelProvider ( new DecoratingLabelProvider ( innerLabelProvider , PlatformUI . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ) ; viewer . setContentProvider ( new FileTableContentProvider ( this ) ) ; viewer . setComparator ( new DecoratorIgnoringViewerSorter ( innerLabelProvider ) ) ; fContentProvider = ( IFileSearchContentProvider ) viewer . getContentProvider ( ) ; addDragAdapters ( viewer ) ; } protected void configureTreeViewer ( TreeViewer viewer ) { viewer . setUseHashlookup ( true ) ; FileLabelProvider innerLabelProvider = new FileLabelProvider ( this , FileLabelProvider . SHOW_LABEL ) ; viewer . setLabelProvider ( new DecoratingLabelProvider ( innerLabelProvider , PlatformUI . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ) ; viewer . setContentProvider ( new FileTreeContentProvider ( this , viewer ) ) ; viewer . setComparator ( new DecoratorIgnoringViewerSorter ( innerLabelProvider ) ) ; fContentProvider = ( IFileSearchContentProvider ) viewer . getContentProvider ( ) ; addDragAdapters ( viewer ) ; } protected void showMatch ( Match match , int offset , int length , boolean activate ) throws PartInitException { File file = ( File ) match . getElement ( ) ; IEditorPart editor = fEditorOpener . open ( file , activate ) ; if ( ( offset != 0 ) || ( length != 0 ) ) { if ( editor instanceof ITextEditor ) { ITextEditor textEditor = ( ITextEditor ) editor ; textEditor . selectAndReveal ( offset , length ) ; } else if ( editor != null ) { showWithMarker ( editor , file , offset , length ) ; } } } protected boolean canRemoveMatchesWith ( ISelection selection ) { if ( selection . isEmpty ( ) ) { StructuredViewer viewer = getViewer ( ) ; if ( ( viewer != null ) && ( viewer instanceof TableViewer ) ) { TableViewer tv = ( TableViewer ) viewer ; tv . getTable ( ) . getParent ( ) . setFocus ( ) ; tv . getTable ( ) . deselectAll ( ) ; } if ( ( viewer != null ) && ( viewer instanceof TreeViewer ) ) { TreeViewer tv = ( TreeViewer ) viewer ; tv . getTree ( ) . deselectAll ( ) ; } } return ! selection . isEmpty ( ) ; } private void showWithMarker ( IEditorPart editor , File file , int offset , int length ) throws PartInitException { IMarker marker = null ; try { Map < String , Integer > attributes = new HashMap < String , Integer > ( 4 ) ; attributes . put ( IMarker . CHAR_START , new Integer ( offset ) ) ; attributes . put ( IMarker . CHAR_END , new Integer ( offset + length ) ) ; } finally { if ( marker != null ) { try { marker . delete ( ) ; } catch ( CoreException e ) { } } } } protected void fillContextMenu ( IMenuManager mgr ) { super . fillContextMenu ( mgr ) ; addSortActions ( mgr ) ; fActionGroup . setContext ( new ActionContext ( getSite ( ) . getSelectionProvider ( ) . getSelection ( ) ) ) ; fActionGroup . fillContextMenu ( mgr ) ; } private void addSortActions ( IMenuManager mgr ) { if ( getLayout ( ) != AbstractTextSearchViewPage . FLAG_LAYOUT_FLAT ) { return ; } MenuManager sortMenu = new MenuManager ( SearchMessages . FileSearchPage_sort_by_label ) ; sortMenu . add ( fSortByNameAction ) ; sortMenu . add ( fSortByPathAction ) ; fSortByNameAction . setChecked ( fCurrentSortOrder == fSortByNameAction . getSortOrder ( ) ) ; fSortByPathAction . setChecked ( fCurrentSortOrder == fSortByPathAction . getSortOrder ( ) ) ; mgr . appendToGroup ( IContextMenuConstants . GROUP_VIEWER_SETUP , sortMenu ) ; } public void setInput ( ISearchResult newSearch , Object viewState ) { super . setInput ( newSearch , viewState ) ; getViewer ( ) . setSelection ( new StructuredSelection ( ) ) ; } public void setViewPart ( ISearchResultViewPart part ) { super . setViewPart ( part ) ; fActionGroup = new NewTextSearchActionGroup ( part ) ; } public void init ( IPageSite site ) { super . init ( site ) ; IMenuManager menuManager = site . getActionBars ( ) . getMenuManager ( ) ; menuManager . appendToGroup ( IContextMenuConstants . GROUP_PROPERTIES , new OpenSearchPreferencesAction ( ) ) ; } public void dispose ( ) { fActionGroup . dispose ( ) ; SearchPlugin . getDefault ( ) . getPreferenceStore ( ) . removePropertyChangeListener ( fPropertyChangeListener ) ; super . dispose ( ) ; } protected void elementsChanged ( Object [ ] objects ) { if ( fContentProvider != null ) { fContentProvider . elementsChanged ( objects ) ; } } protected void clear ( ) { if ( fContentProvider != null ) { fContentProvider . clear ( ) ; } } public void setSortOrder ( int sortOrder ) { fCurrentSortOrder = sortOrder ; DecoratingLabelProvider lpWrapper = ( DecoratingLabelProvider ) getViewer ( ) . getLabelProvider ( ) ; ( ( FileLabelProvider ) lpWrapper . getLabelProvider ( ) ) . setOrder ( sortOrder ) ; getViewer ( ) . refresh ( ) ; getSettings ( ) . put ( FileSystemSearchPage . KEY_SORTING , fCurrentSortOrder ) ; } public void restoreState ( IMemento memento ) { super . restoreState ( memento ) ; try { fCurrentSortOrder = getSettings ( ) . getInt ( FileSystemSearchPage . KEY_SORTING ) ; } catch ( NumberFormatException e ) { fCurrentSortOrder = fSortByNameAction . getSortOrder ( ) ; } if ( memento != null ) { Integer value = memento . getInteger ( FileSystemSearchPage . KEY_SORTING ) ; if ( value != null ) { fCurrentSortOrder = value . intValue ( ) ; } } } public void saveState ( IMemento memento ) { super . saveState ( memento ) ; memento . putInteger ( FileSystemSearchPage . KEY_SORTING , fCurrentSortOrder ) ; } public Object getAdapter ( Class adapter ) { if ( IShowInTargetList . class . equals ( adapter ) ) { return FileSystemSearchPage . SHOW_IN_TARGET_LIST ; } return null ; } public String getLabel ( ) { String label = super . getLabel ( ) ; StructuredViewer viewer = getViewer ( ) ; if ( viewer instanceof TableViewer ) { TableViewer tv = ( TableViewer ) viewer ; AbstractTextSearchResult result = getInput ( ) ; if ( result != null ) { int itemCount = ( ( IStructuredContentProvider ) tv . getContentProvider ( ) ) . getElements ( getInput ( ) ) . length ; int fileCount = getInput ( ) . getElements ( ) . length ; if ( itemCount < fileCount ) { return Messages . format ( SearchMessages . AptanaFileSearchPage_NOT_ALL_MATCHES , new Object [ ] { label , new Integer ( itemCount ) , new Integer ( fileCount ) } ) ; } } } return label ; } } 
=======
public class HttpTransport extends Transport { ServiceConnection connection ; OutputStream os ; InputStream is ; private boolean connected = false ; public HttpTransport ( String url ) { super ( url ) ; } public void call ( String soapAction , SoapEnvelope envelope ) throws IOException , XmlPullParserException { if ( soapAction == null ) soapAction = "\"\"" ; byte [ ] requestData = createRequestData ( envelope ) ; requestDump = debug ? new String ( requestData ) : null ; responseDump = null ; try { connected = true ; connection = getServiceConnection ( ) ; connection . setRequestProperty ( "SOAPAction" , soapAction ) ; connection . setRequestProperty ( "Content-Type" , "text/xml" ) ; connection . setRequestProperty ( "Content-Length" , "" + requestData . length ) ; connection . setRequestProperty ( "User-Agent" , "kSOAP/2.0" ) ; connection . setRequestMethod ( HttpConnection . POST ) ; os = connection . openOutputStream ( ) ; os . write ( requestData , 0 , requestData . length ) ; os . close ( ) ; requestData = null ; is = connection . openInputStream ( ) ; if ( debug ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ 256 ] ; while ( true ) { int rd = is . read ( buf , 0 , 256 ) ; if ( rd == - 1 ) break ; bos . write ( buf , 0 , rd ) ; } bos . flush ( ) ; buf = bos . toByteArray ( ) ; responseDump = new String ( buf ) ; is . close ( ) ; is = new ByteArrayInputStream ( buf ) ; } parseResponse ( envelope , is ) ; } finally { if ( ! connected ) throw new InterruptedIOException ( ) ; reset ( ) ; } if ( envelope . bodyIn instanceof SoapFault ) throw ( ( SoapFault ) envelope . bodyIn ) ; } public void reset ( ) { connected = false ; if ( is != null ) { try { is . close ( ) ; } catch ( Throwable e ) { } is = null ; } if ( connection != null ) { try { connection . disconnect ( ) ; } catch ( Throwable e ) { } connection = null ; } } protected ServiceConnection getServiceConnection ( ) throws IOException { return new ServiceConnectionMidp ( url ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
