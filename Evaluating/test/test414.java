public class ReplicationTask extends CouchTask { static Log log = LogFactory . getLog ( Document . class ) ; public static final String TASK_TYPE = "Replication" ; private static final String DELIMITER = " " ; private static final String SOURCE_KEY = "source" ; private static final String TARGET_KEY = "target" ; private static final String CREATE_TARGET_KEY = "create_target" ; private static final String CONTINUOUS_KEY = "continuous" ; private static final String CANCEL_KEY = "cancel" ; private ReplicationTarget source ; private ReplicationTarget destination ; private boolean continuous ; private boolean createTarget ; private boolean cancel ; public ReplicationTask ( final String task , final String status , final String pid ) { super ( TASK_TYPE , task , status , pid ) ; source = null ; destination = null ; continuous = false ; createTarget = false ; cancel = false ; } public ReplicationTask ( ReplicationTarget source , ReplicationTarget destination ) { super ( TASK_TYPE , null , null , null ) ; this . source = source ; this . destination = destination ; } public boolean loadDetailsFromTask ( ) { if ( task == null ) { return false ; } String [ ] parts = task . split ( DELIMITER ) ; if ( parts . length < 4 ) { log . error ( "Unable to parse replication task: " + task ) ; return false ; } source = ReplicationTarget . fromUrl ( parts [ 1 ] ) ; destination = ReplicationTarget . fromUrl ( parts [ 3 ] ) ; if ( source == null || destination == null ) { log . error ( "Unable to extract source and destination details from replication task: " + task ) ; return false ; } return true ; } public ReplicationTarget getSource ( ) { return source ; } public ReplicationTarget getDestination ( ) { return destination ; } public boolean isContinuous ( ) { return continuous ; } public JSONObject getCreateRequest ( ) { final JSONObject object = new JSONObject ( ) ; final String source = this . source . buildUrl ( ) ; final String destination = this . destination . buildUrl ( ) ; if ( source == null || destination == null ) { log . error ( "Unable to build source or destination URL" ) ; return null ; } object . put ( SOURCE_KEY , source ) ; object . put ( TARGET_KEY , destination ) ; if ( createTarget ) { object . put ( CREATE_TARGET_KEY , Boolean . TRUE ) ; } if ( continuous ) { object . put ( CONTINUOUS_KEY , Boolean . TRUE ) ; } if ( cancel ) { object . put ( CANCEL_KEY , Boolean . TRUE ) ; } return object ; } public void setContinuous ( ) { continuous = true ; } public void setCreateTarget ( ) { createTarget = true ; } public void setCancel ( ) { cancel = true ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof ReplicationTask ) { final ReplicationTask other = ( ReplicationTask ) obj ; if ( source . equals ( other . source ) && destination . equals ( other . destination ) ) { return true ; } } return false ; } @ Override public int hashCode ( ) { throw new RuntimeException ( "hashCode() is not supported yet." ) ; } public static class ReplicationTarget { private final static String FULL_URL_PREFIX = "http" ; private final static String PATH_SEPARATOR = "/" ; private final static int PORT_NOT_USED = - 1 ; private String replicatedEntity ; private String server ; private int port ; private boolean isRemote ; private ReplicationTarget ( ) { } public ReplicationTarget ( final String replicatedEntry ) { this ( replicatedEntry , null , PORT_NOT_USED ) ; } public ReplicationTarget ( final String replicatedEntry , final String server , final int port ) { this . replicatedEntity = replicatedEntry ; this . server = server ; this . port = port ; isRemote = ( server != null ) ; } public String buildUrl ( ) { final StringBuffer buffer = new StringBuffer ( ) ; if ( isRemote == false ) { buffer . append ( replicatedEntity ) ; } else { buffer . append ( FULL_URL_PREFIX + "://" + server + ":" + port + "/" + replicatedEntity ) ; } return buffer . toString ( ) ; } static private ReplicationTarget fromUrl ( final String url ) { if ( url . startsWith ( FULL_URL_PREFIX ) == false ) { final ReplicationTarget target = new ReplicationTarget ( ) ; target . isRemote = false ; target . port = PORT_NOT_USED ; target . replicatedEntity = url ; target . server = null ; return target ; } try { final URL asUrl = new URL ( url ) ; final ReplicationTarget target = new ReplicationTarget ( ) ; target . server = asUrl . getHost ( ) ; target . port = asUrl . getPort ( ) ; target . replicatedEntity = asUrl . getPath ( ) ; if ( target . replicatedEntity . startsWith ( PATH_SEPARATOR ) ) { target . replicatedEntity = target . replicatedEntity . substring ( PATH_SEPARATOR . length ( ) ) ; } if ( target . replicatedEntity . endsWith ( PATH_SEPARATOR ) ) { target . replicatedEntity = target . replicatedEntity . substring ( 0 , target . replicatedEntity . length ( ) - PATH_SEPARATOR . length ( ) ) ; } target . isRemote = false ; if ( target . server != null ) { final InetAddress tempAddress = InetAddress . getByName ( target . server ) ; target . isRemote = ! ( tempAddress . isLoopbackAddress ( ) ) ; } log . debug ( target . toString ( ) ) ; return target ; } catch ( final Exception e ) { log . debug ( "Failed to create target due to exception, " + e ) ; } return null ; } @ Override public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Host: " ) ; if ( server != null ) { buffer . append ( server + ", " ) ; } else { buffer . append ( "Not set, " ) ; } buffer . append ( "Port = " + port + ", " ) ; buffer . append ( "Path = " + replicatedEntity + ", isRemote = " + isRemote ) ; return buffer . toString ( ) ; } public String getReplicatedEntity ( ) { return replicatedEntity ; } public String getServer ( ) { return server ; } public int getPort ( ) { return port ; } public boolean isRemote ( ) { return isRemote ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof ReplicationTarget ) { final ReplicationTarget other = ( ReplicationTarget ) obj ; if ( ( ( replicatedEntity == null && other . replicatedEntity == null ) || replicatedEntity . equals ( other . replicatedEntity ) ) && ( ( server == null && other . server == null ) || server . equals ( other . server ) ) && port == other . port ) { return true ; } } return false ; } @ Override public int hashCode ( ) { throw new RuntimeException ( "hashCode() is not supported yet." ) ; } } } 