<<<<<<< HEAD
@ Path ( "/" ) public class WebTweetService { protected final Log log = LogFactory . getLog ( getClass ( ) ) ; private TweetService tweetService ; private UserService userService ; @ GET @ Path ( "/users/{user}" ) @ Produces ( "application/json" ) public Response getTweets ( @ PathParam ( "user" ) String user , @ QueryParam ( "start" ) int start , @ QueryParam ( "count" ) int count ) { try { return Response . ok ( ) . entity ( toWeb ( tweetService . getTweets ( user , start , count ) ) ) . build ( ) ; } catch ( UserNotFoundException e ) { return Response . status ( 404 ) . entity ( "Invalid user " + user ) . build ( ) ; } } @ GET @ Produces ( "application/json" ) @ Path ( "/friendsTimeline" ) public Response getFriendsTimeline ( @ QueryParam ( "start" ) int start , @ QueryParam ( "count" ) int count ) { String user = getCurrentUser ( ) ; try { return Response . ok ( ) . entity ( toWeb ( tweetService . getFriendsTimeline ( user , start , count ) ) ) . build ( ) ; } catch ( UserNotFoundException e ) { return Response . status ( 404 ) . entity ( "Invalid user " + user ) . build ( ) ; } } @ GET @ Produces ( "application/json" ) @ Path ( "/followers" ) public Response getFollowers ( @ QueryParam ( "user" ) String user ) { if ( StringUtils . isEmpty ( user ) ) { user = getCurrentUser ( ) ; } try { return Response . ok ( ) . entity ( tweetService . getFollowers ( user ) ) . build ( ) ; } catch ( UserNotFoundException e ) { return Response . status ( 404 ) . entity ( "Invalid user " + user ) . build ( ) ; } } @ GET @ Produces ( "application/json" ) @ Path ( "/following" ) public Response getFollowing ( @ QueryParam ( "user" ) String user ) { if ( StringUtils . isEmpty ( user ) ) { user = getCurrentUser ( ) ; } try { return Response . ok ( ) . entity ( tweetService . getFollowing ( user ) ) . build ( ) ; } catch ( UserNotFoundException e ) { return Response . status ( 404 ) . entity ( "Invalid user " + user ) . build ( ) ; } } @ POST @ Path ( "/startFollowing" ) @ Consumes ( "application/json" ) @ Produces ( "application/json" ) public Response startFollowing ( FollowRequest req ) { try { tweetService . startFollowing ( getCurrentUser ( ) , req . getUser ( ) ) ; return Response . ok ( ) . build ( ) ; } catch ( UserNotFoundException e ) { return Response . status ( 404 ) . entity ( "Invalid user " + req . getUser ( ) ) . build ( ) ; } catch ( BackendException e ) { log . error ( e ) ; return Response . status ( 500 ) . entity ( e . getMessage ( ) ) . build ( ) ; } } @ POST @ Path ( "/stopFollowing" ) @ Consumes ( "application/json" ) @ Produces ( "application/json" ) public Response stopFollowing ( FollowRequest req ) { try { tweetService . stopFollowing ( getCurrentUser ( ) , req . getUser ( ) ) ; return Response . ok ( ) . build ( ) ; } catch ( UserNotFoundException e ) { return Response . status ( 404 ) . entity ( "Invalid user " + req . getUser ( ) ) . build ( ) ; } catch ( BackendException e ) { log . error ( e ) ; return Response . status ( 500 ) . entity ( e . getMessage ( ) ) . build ( ) ; } } @ POST @ Path ( "/register" ) @ Consumes ( "application/json" ) @ Produces ( "application/json" ) public Response register ( WebUser req ) { if ( req == null ) { Response . status ( 400 ) . entity ( "request cannot be empty." ) ; } if ( StringUtils . isEmpty ( req . getUsername ( ) ) ) { Response . status ( 400 ) . entity ( "Username cannot be empty." ) ; } if ( StringUtils . isEmpty ( req . getPassword ( ) ) ) { Response . status ( 400 ) . entity ( "Password cannot be empty." ) ; } if ( StringUtils . isEmpty ( req . getName ( ) ) ) { Response . status ( 400 ) . entity ( "Name cannot be empty." ) ; } User user = new User ( ) ; user . setUsername ( req . getUsername ( ) ) ; user . setPassword ( req . getPassword ( ) ) ; user . setName ( req . getName ( ) ) ; try { userService . newUser ( user ) ; return Response . ok ( ) . build ( ) ; } catch ( AlreadyExistsException e ) { return Response . status ( 409 ) . build ( ) ; } } @ POST @ Path ( "/tweet" ) @ Consumes ( "application/json" ) @ Produces ( "application/json" ) public Response tweet ( TweetRequest req ) { if ( req == null || req . getTweet ( ) == null ) { Response . status ( 400 ) . entity ( "Tweet text cannot be empty." ) ; } Tweet tweet = new Tweet ( ) ; tweet . setText ( req . getTweet ( ) ) ; tweet . setUser ( getCurrentUser ( ) ) ; try { tweetService . tweet ( tweet ) ; return Response . ok ( ) . entity ( new WebTweet ( tweet ) ) . build ( ) ; } catch ( UserNotFoundException e ) { return Response . status ( 401 ) . build ( ) ; } catch ( BackendException e ) { log . error ( e ) ; return Response . status ( 500 ) . build ( ) ; } } private List < WebTweet > toWeb ( List < Tweet > tweets ) { List < WebTweet > webTweets = new ArrayList < WebTweet > ( ) ; for ( Tweet t : tweets ) { webTweets . add ( new WebTweet ( t ) ) ; } return webTweets ; } public static String getCurrentUser ( ) { SecurityContext ctx = SecurityContextHolder . getContext ( ) ; if ( ctx == null ) { return null ; } Authentication auth = ctx . getAuthentication ( ) ; if ( auth == null ) { return null ; } UserDetailsWrapper wrapper = ( UserDetailsWrapper ) auth . getPrincipal ( ) ; if ( wrapper == null ) { return null ; } return wrapper . getUsername ( ) ; } public void setTweetService ( TweetService tweetService ) { this . tweetService = tweetService ; } public void setUserService ( UserService userService ) { this . userService = userService ; } } 
=======
class SchemaReceiverImpl implements SchemaReceiver { private static final String NVDL_SCHEMA = "nvdl.rng" ; private static final String RNC_MEDIA_TYPE = "application/relax-ng-compact-syntax" ; static final String LEGACY_RNC_MEDIA_TYPE = "application/x-rnc" ; private final PropertyMap properties ; private final Name attributeOwner ; private final SchemaReader autoSchemaReader ; private Schema nvdlSchema = null ; private static final PropertyId subSchemaProperties [ ] = { ValidateProperty . ERROR_HANDLER , ValidateProperty . XML_READER_CREATOR , ValidateProperty . ENTITY_RESOLVER , ValidateProperty . URI_RESOLVER , ValidateProperty . RESOLVER , SchemaReceiverFactory . PROPERTY , } ; public SchemaReceiverImpl ( PropertyMap properties ) { this . attributeOwner = properties . get ( WrapProperty . ATTRIBUTE_OWNER ) ; PropertyMapBuilder builder = new PropertyMapBuilder ( ) ; for ( int i = 0 ; i < subSchemaProperties . length ; i ++ ) { Object value = properties . get ( subSchemaProperties [ i ] ) ; if ( value != null ) builder . put ( subSchemaProperties [ i ] , value ) ; } this . properties = builder . toPropertyMap ( ) ; this . autoSchemaReader = new AutoSchemaReader ( properties . get ( SchemaReceiverFactory . PROPERTY ) ) ; } public SchemaFuture installHandlers ( XMLReader xr ) { PropertyMapBuilder builder = new PropertyMapBuilder ( properties ) ; if ( attributeOwner != null ) builder . put ( WrapProperty . ATTRIBUTE_OWNER , attributeOwner ) ; return new SchemaImpl ( builder . toPropertyMap ( ) ) . installHandlers ( xr , this ) ; } Schema getNvdlSchema ( ) throws IOException , IncorrectSchemaException , SAXException { if ( nvdlSchema == null ) { String className = SchemaReceiverImpl . class . getName ( ) ; String resourceName = className . substring ( 0 , className . lastIndexOf ( '.' ) ) . replace ( '.' , '/' ) + "/resources/" + NVDL_SCHEMA ; URL nvdlSchemaUrl = getResource ( resourceName ) ; InputStream stream = nvdlSchemaUrl . openStream ( ) ; InputSource inputSource = new InputSource ( nvdlSchemaUrl . toString ( ) ) ; inputSource . setByteStream ( stream ) ; nvdlSchema = SAXSchemaReader . getInstance ( ) . createSchema ( inputSource , properties ) ; } return nvdlSchema ; } private static URL getResource ( String resourceName ) { ClassLoader cl = SchemaReceiverImpl . class . getClassLoader ( ) ; if ( cl == null ) return ClassLoader . getSystemResource ( resourceName ) ; else return cl . getResource ( resourceName ) ; } PropertyMap getProperties ( ) { return properties ; } Schema createChildSchema ( SAXSource source , String schemaType , PropertyMap options , boolean isAttributesSchema ) throws IOException , IncorrectSchemaException , SAXException { SchemaReader reader = isRnc ( schemaType ) ? CompactSchemaReader . getInstance ( ) : autoSchemaReader ; PropertyMapBuilder builder = new PropertyMapBuilder ( properties ) ; if ( isAttributesSchema ) builder . put ( WrapProperty . ATTRIBUTE_OWNER , ValidatorImpl . OWNER_NAME ) ; builder . add ( options ) ; return reader . createSchema ( source , builder . toPropertyMap ( ) ) ; } Option getOption ( String uri ) { Option option = autoSchemaReader . getOption ( uri ) ; if ( option != null ) return option ; return CompactSchemaReader . getInstance ( ) . getOption ( uri ) ; } private static boolean isRnc ( String schemaType ) { if ( schemaType == null ) return false ; schemaType = schemaType . trim ( ) ; return schemaType . equals ( RNC_MEDIA_TYPE ) || schemaType . equals ( LEGACY_RNC_MEDIA_TYPE ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
