<<<<<<< HEAD
@ SuppressWarnings ( "restriction" ) class WorkspaceFile extends FileStore { private static final IWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; private IResource resource ; private final IPath path ; private IFileStore localFileStore ; private static boolean refreshed = false ; public WorkspaceFile ( IResource resource ) { this ( resource , resource . getFullPath ( ) ) ; } public WorkspaceFile ( IPath path ) { this ( null , path ) ; } private WorkspaceFile ( IResource resource , IPath path ) { this . resource = resource ; this . path = path ; } @ SuppressWarnings ( "unchecked" ) @ Override public Object getAdapter ( Class adapter ) { if ( IResource . class == adapter ) { try { ensureResource ( ) ; } catch ( CoreException e ) { } return resource ; } return super . getAdapter ( adapter ) ; } @ Override public String [ ] childNames ( int options , IProgressMonitor monitor ) throws CoreException { ensureResource ( ) ; if ( resource instanceof IContainer ) { IContainer container = ( IContainer ) resource ; if ( ! container . isSynchronized ( IResource . DEPTH_ONE ) ) { container . refreshLocal ( IResource . DEPTH_ONE , new NullProgressMonitor ( ) ) ; } final List < String > childNames = new ArrayList < String > ( ) ; final boolean [ ] skipSelf = new boolean [ ] { true } ; container . accept ( new IResourceProxyVisitor ( ) { public boolean visit ( IResourceProxy proxy ) throws CoreException { if ( skipSelf [ 0 ] ) { skipSelf [ 0 ] = false ; return true ; } childNames . add ( proxy . getName ( ) ) ; return false ; } } , IContainer . INCLUDE_HIDDEN ) ; return childNames . toArray ( new String [ childNames . size ( ) ] ) ; } return EMPTY_STRING_ARRAY ; } @ Override public IFileInfo fetchInfo ( int options , IProgressMonitor monitor ) throws CoreException { ensureLocalFileStore ( ) ; if ( localFileStore != null ) { return localFileStore . fetchInfo ( options , monitor ) ; } FileInfo info = new FileInfo ( path . lastSegment ( ) ) ; info . setExists ( false ) ; return info ; } @ Override public IFileStore getChild ( String name ) { return new WorkspaceFile ( path . append ( name ) ) ; } @ Override public String getName ( ) { return path . lastSegment ( ) ; } @ Override public IFileStore getParent ( ) { if ( path . equals ( Path . ROOT ) ) { return null ; } return new WorkspaceFile ( path . removeLastSegments ( 1 ) ) ; } @ Override public InputStream openInputStream ( int options , IProgressMonitor monitor ) throws CoreException { ensureLocalFileStore ( ) ; if ( localFileStore != null ) { return localFileStore . openInputStream ( options , monitor ) ; } Policy . error ( EFS . ERROR_READ , NLS . bind ( Messages . fileNotFound , path ) ) ; return null ; } @ Override public URI toURI ( ) { try { return new URI ( WorkspaceFileSystem . SCHEME_WORKSPACE , path . toPortableString ( ) , null ) ; } catch ( URISyntaxException e ) { IdeLog . logError ( CoreIOPlugin . getDefault ( ) , e . getLocalizedMessage ( ) , e ) ; } return null ; } @ Override public void copy ( IFileStore destination , int options , IProgressMonitor monitor ) throws CoreException { if ( CloakingUtils . isFileCloaked ( this ) ) { return ; } ensureLocalFileStore ( ) ; if ( localFileStore != null ) { localFileStore . copy ( destination , options , monitor ) ; } else { super . copy ( destination , options , monitor ) ; } } @ Override public void delete ( int options , IProgressMonitor monitor ) throws CoreException { ensureLocalFileStore ( ) ; if ( localFileStore != null ) { localFileStore . delete ( options , monitor ) ; } } @ Override public IFileStore getFileStore ( IPath path ) { return new WorkspaceFile ( this . path . append ( path ) ) ; } @ Override public IFileSystem getFileSystem ( ) { return WorkspaceFileSystem . getInstance ( ) ; } @ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof WorkspaceFile ) ) { return false ; } return path . equals ( ( ( WorkspaceFile ) obj ) . path ) ; } @ Override public int hashCode ( ) { return path . hashCode ( ) ; } @ Override public IFileStore mkdir ( int options , IProgressMonitor monitor ) throws CoreException { ensureLocalFileStore ( true ) ; if ( localFileStore != null ) { try { localFileStore . mkdir ( options , monitor ) ; } finally { localFileStore = null ; } } return this ; } @ Override public void move ( IFileStore destination , int options , IProgressMonitor monitor ) throws CoreException { if ( ! ( destination instanceof WorkspaceFile ) ) { ensureLocalFileStore ( ) ; if ( localFileStore != null ) { localFileStore . move ( destination , options , monitor ) ; return ; } Policy . error ( EFS . ERROR_NOT_EXISTS , NLS . bind ( Messages . fileNotFound , path ) ) ; } monitor = Policy . monitorFor ( monitor ) ; monitor . beginTask ( NLS . bind ( Messages . moving , destination . toString ( ) ) , 100 ) ; WorkspaceFile destinationFile = ( WorkspaceFile ) destination ; try { ensureResource ( ) ; if ( resource == null ) { Policy . error ( EFS . ERROR_NOT_EXISTS , NLS . bind ( Messages . fileNotFound , path ) ) ; } IResource destinationResource = ( IResource ) destinationFile . getAdapter ( IResource . class ) ; if ( destinationResource == null ) { if ( resource instanceof IContainer ) { destinationResource = workspaceRoot . getFolder ( destinationFile . path ) ; } else { destinationResource = workspaceRoot . getFile ( destinationFile . path ) ; } } boolean sourceEqualsDest = resource . equals ( destinationResource ) ; boolean overwrite = ( options & EFS . OVERWRITE ) != 0 ; if ( ! sourceEqualsDest && ! overwrite && destinationResource . exists ( ) ) { Policy . error ( EFS . ERROR_EXISTS , NLS . bind ( Messages . fileExists , destinationResource . getFullPath ( ) ) ) ; } try { resource . move ( destinationResource . getFullPath ( ) , true , Policy . subMonitorFor ( monitor , 100 ) ) ; } catch ( CoreException e ) { Policy . error ( EFS . ERROR_WRITE , NLS . bind ( Messages . failedMove , toString ( ) , destination . toString ( ) ) , e ) ; } } finally { monitor . done ( ) ; } } @ Override public void putInfo ( IFileInfo info , int options , IProgressMonitor monitor ) throws CoreException { ensureLocalFileStore ( true ) ; if ( localFileStore != null ) { localFileStore . putInfo ( info , options , monitor ) ; } else { Policy . error ( EFS . ERROR_NOT_EXISTS , NLS . bind ( Messages . fileNotFound , path ) ) ; } } public File toLocalFile ( int options , IProgressMonitor monitor ) throws CoreException { ensureLocalFileStore ( ) ; if ( localFileStore != null ) { return localFileStore . toLocalFile ( options , monitor ) ; } return null ; } @ Override public OutputStream openOutputStream ( int options , IProgressMonitor monitor ) throws CoreException { ensureLocalFileStore ( true ) ; if ( localFileStore != null ) { return localFileStore . openOutputStream ( options , monitor ) ; } return null ; } @ Override public String toString ( ) { return path . toString ( ) ; } private void ensureResource ( ) throws CoreException { if ( ! refreshed ) { workspaceRoot . refreshLocal ( IResource . DEPTH_INFINITE , null ) ; refreshed = true ; } if ( resource != null && ( ! resource . isSynchronized ( IResource . DEPTH_ZERO ) || ! resource . exists ( ) ) ) { resource = null ; localFileStore = null ; } if ( resource == null ) { IResource res = workspaceRoot ; for ( String name : path . segments ( ) ) { if ( res instanceof IContainer ) { IContainer container = ( IContainer ) res ; res = container . findMember ( name ) ; } else { res = null ; break ; } } resource = res ; } } private void ensureLocalFileStore ( ) throws CoreException { ensureLocalFileStore ( false ) ; } private void ensureLocalFileStore ( boolean force ) throws CoreException { ensureResource ( ) ; if ( localFileStore == null ) { if ( resource != null && resource . exists ( ) ) { localFileStore = new LocalFile ( resource . getLocation ( ) . toFile ( ) ) ; } else if ( force ) { IResource parent = workspaceRoot ; IPath relativePath = null ; for ( int i = 0 ; i < path . segmentCount ( ) ; ++ i ) { if ( parent instanceof IContainer ) { IResource member = ( ( IContainer ) parent ) . findMember ( path . segment ( i ) ) ; if ( member != null ) { parent = member ; } else { relativePath = path . removeFirstSegments ( i ) ; break ; } } else { parent = null ; break ; } } if ( parent != null & relativePath != null ) { localFileStore = new LocalFile ( parent . getLocation ( ) . toFile ( ) ) . getFileStore ( relativePath ) ; } } } } public static IFileStore fromLocalFile ( File file ) { IResource resource = null ; if ( file . isDirectory ( ) ) { resource = workspaceRoot . getContainerForLocation ( Path . fromOSString ( file . getAbsolutePath ( ) ) ) ; } else if ( file . isFile ( ) ) { resource = workspaceRoot . getFileForLocation ( Path . fromOSString ( file . getAbsolutePath ( ) ) ) ; } if ( resource != null ) { return new WorkspaceFile ( resource ) ; } return null ; } } 
=======
public class Int extends AbstractInt { public static final Int THE_INSTANCE = new Int ( ) ; private Int ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { checkInt ( literal , 0 ) ; } @ Override public String getName ( ) { return "integer" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
