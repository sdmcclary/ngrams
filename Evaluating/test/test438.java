public class ForkJoinPool extends AbstractExecutorService { private static final int shortMask = 0xffff ; private static final int MAX_THREADS = 0x7FFF ; public static interface ForkJoinWorkerThreadFactory { public ForkJoinWorkerThread newThread ( ForkJoinPool pool ) ; } static class DefaultForkJoinWorkerThreadFactory implements ForkJoinWorkerThreadFactory { public ForkJoinWorkerThread newThread ( ForkJoinPool pool ) { try { return new ForkJoinWorkerThread ( pool ) ; } catch ( OutOfMemoryError oom ) { return null ; } } } public static final ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory = new DefaultForkJoinWorkerThreadFactory ( ) ; private static final RuntimePermission modifyThreadPermission = new RuntimePermission ( "modifyThread" ) ; private static void checkPermission ( ) { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) security . checkPermission ( modifyThreadPermission ) ; } private static final AtomicInteger poolNumberGenerator = new AtomicInteger ( ) ; volatile ForkJoinWorkerThread [ ] workers ; private final ReentrantLock workerLock ; private final Condition termination ; private Thread . UncaughtExceptionHandler ueh ; private final ForkJoinWorkerThreadFactory factory ; private volatile WaitQueueNode spareStack ; private final AtomicLong stealCount ; private final LinkedTransferQueue < ForkJoinTask < ? > > submissionQueue ; private volatile WaitQueueNode syncStack ; private volatile long eventCount ; private final int poolNumber ; private volatile int maxPoolSize ; private volatile int parallelism ; private volatile int workerCounts ; private static int totalCountOf ( int s ) { return s > > > 16 ; } private static int runningCountOf ( int s ) { return s & shortMask ; } private static int workerCountsFor ( int t , int r ) { return ( t << 16 ) + r ; } final void updateRunningCount ( int delta ) { int s ; do ; while ( ! casWorkerCounts ( s = workerCounts , s + delta ) ) ; } private void updateWorkerCount ( int delta ) { int d = delta + ( delta << 16 ) ; int s ; do ; while ( ! casWorkerCounts ( s = workerCounts , s + d ) ) ; } private volatile int runControl ; private static final int RUNNING = 0 ; private static final int SHUTDOWN = 1 ; private static final int TERMINATING = 2 ; private static final int TERMINATED = 3 ; private static int runStateOf ( int c ) { return c > > > 16 ; } private static int activeCountOf ( int c ) { return c & shortMask ; } private static int runControlFor ( int r , int a ) { return ( r << 16 ) + a ; } final boolean tryIncrementActiveCount ( ) { int c = runControl ; return casRunControl ( c , c + 1 ) ; } final boolean tryDecrementActiveCount ( ) { int c = runControl ; int nextc = c - 1 ; if ( ! casRunControl ( c , nextc ) ) return false ; if ( canTerminateOnShutdown ( nextc ) ) terminateOnShutdown ( ) ; return true ; } private static boolean canTerminateOnShutdown ( int c ) { return ( ( c & - c ) > > > 16 ) != 0 ; } private boolean transitionRunStateTo ( int state ) { for ( ; ; ) { int c = runControl ; if ( runStateOf ( c ) >= state ) return false ; if ( casRunControl ( c , runControlFor ( state , activeCountOf ( c ) ) ) ) return true ; } } private volatile boolean maintainsParallelism ; public ForkJoinPool ( ) { this ( Runtime . getRuntime ( ) . availableProcessors ( ) , defaultForkJoinWorkerThreadFactory ) ; } public ForkJoinPool ( int parallelism ) { this ( parallelism , defaultForkJoinWorkerThreadFactory ) ; } public ForkJoinPool ( ForkJoinWorkerThreadFactory factory ) { this ( Runtime . getRuntime ( ) . availableProcessors ( ) , factory ) ; } public ForkJoinPool ( int parallelism , ForkJoinWorkerThreadFactory factory ) { if ( parallelism <= 0 || parallelism > MAX_THREADS ) throw new IllegalArgumentException ( ) ; if ( factory == null ) throw new NullPointerException ( ) ; checkPermission ( ) ; this . factory = factory ; this . parallelism = parallelism ; this . maxPoolSize = MAX_THREADS ; this . maintainsParallelism = true ; this . poolNumber = poolNumberGenerator . incrementAndGet ( ) ; this . workerLock = new ReentrantLock ( ) ; this . termination = workerLock . newCondition ( ) ; this . stealCount = new AtomicLong ( ) ; this . submissionQueue = new LinkedTransferQueue < ForkJoinTask < ? > > ( ) ; createAndStartInitialWorkers ( parallelism ) ; } private ForkJoinWorkerThread createWorker ( int index ) { Thread . UncaughtExceptionHandler h = ueh ; ForkJoinWorkerThread w = factory . newThread ( this ) ; if ( w != null ) { w . poolIndex = index ; w . setDaemon ( true ) ; w . setName ( "ForkJoinPool-" + poolNumber + "-worker-" + index ) ; if ( h != null ) w . setUncaughtExceptionHandler ( h ) ; } return w ; } private static int arraySizeFor ( int ps ) { return ps <= 1 ? 1 : ( 1 << ( 32 - Integer . numberOfLeadingZeros ( ps - 1 ) ) ) ; } private ForkJoinWorkerThread [ ] ensureWorkerArrayCapacity ( int newLength ) { ForkJoinWorkerThread [ ] ws = workers ; if ( ws == null ) return workers = new ForkJoinWorkerThread [ arraySizeFor ( newLength ) ] ; else if ( newLength > ws . length ) return workers = Arrays . copyOf ( ws , arraySizeFor ( newLength ) ) ; else return ws ; } private void tryShrinkWorkerArray ( ) { ForkJoinWorkerThread [ ] ws = workers ; int len = ws . length ; int last = len - 1 ; while ( last >= 0 && ws [ last ] == null ) -- last ; int newLength = arraySizeFor ( last + 1 ) ; if ( newLength < len ) workers = Arrays . copyOf ( ws , newLength ) ; } private void createAndStartInitialWorkers ( int ps ) { final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { ForkJoinWorkerThread [ ] ws = ensureWorkerArrayCapacity ( ps ) ; for ( int i = 0 ; i < ps ; ++ i ) { ForkJoinWorkerThread w = createWorker ( i ) ; if ( w != null ) { ws [ i ] = w ; w . start ( ) ; updateWorkerCount ( 1 ) ; } } } finally { lock . unlock ( ) ; } } private void createAndStartAddedWorkers ( ) { resumeAllSpares ( ) ; int ps = parallelism ; ForkJoinWorkerThread [ ] ws = ensureWorkerArrayCapacity ( ps ) ; int len = ws . length ; int k = 0 ; while ( k < len ) { if ( ws [ k ] != null ) { ++ k ; continue ; } int s = workerCounts ; int tc = totalCountOf ( s ) ; int rc = runningCountOf ( s ) ; if ( rc >= ps || tc >= ps ) break ; if ( casWorkerCounts ( s , workerCountsFor ( tc + 1 , rc + 1 ) ) ) { ForkJoinWorkerThread w = createWorker ( k ) ; if ( w != null ) { ws [ k ++ ] = w ; w . start ( ) ; } else { updateWorkerCount ( - 1 ) ; break ; } } } } private < T > void doSubmit ( ForkJoinTask < T > task ) { if ( isShutdown ( ) ) throw new RejectedExecutionException ( ) ; submissionQueue . offer ( task ) ; signalIdleWorkers ( ) ; } public < T > T invoke ( ForkJoinTask < T > task ) { doSubmit ( task ) ; return task . join ( ) ; } public < T > void execute ( ForkJoinTask < T > task ) { doSubmit ( task ) ; } public void execute ( Runnable task ) { doSubmit ( new AdaptedRunnable < Void > ( task , null ) ) ; } public < T > ForkJoinTask < T > submit ( Callable < T > task ) { ForkJoinTask < T > job = new AdaptedCallable < T > ( task ) ; doSubmit ( job ) ; return job ; } public < T > ForkJoinTask < T > submit ( Runnable task , T result ) { ForkJoinTask < T > job = new AdaptedRunnable < T > ( task , result ) ; doSubmit ( job ) ; return job ; } public ForkJoinTask < ? > submit ( Runnable task ) { ForkJoinTask < Void > job = new AdaptedRunnable < Void > ( task , null ) ; doSubmit ( job ) ; return job ; } static final class AdaptedRunnable < T > extends ForkJoinTask < T > implements RunnableFuture < T > { final Runnable runnable ; final T resultOnCompletion ; T result ; AdaptedRunnable ( Runnable runnable , T result ) { if ( runnable == null ) throw new NullPointerException ( ) ; this . runnable = runnable ; this . resultOnCompletion = result ; } public T getRawResult ( ) { return result ; } public void setRawResult ( T v ) { result = v ; } public boolean exec ( ) { runnable . run ( ) ; result = resultOnCompletion ; return true ; } public void run ( ) { invoke ( ) ; } } static final class AdaptedCallable < T > extends ForkJoinTask < T > implements RunnableFuture < T > { final Callable < T > callable ; T result ; AdaptedCallable ( Callable < T > callable ) { if ( callable == null ) throw new NullPointerException ( ) ; this . callable = callable ; } public T getRawResult ( ) { return result ; } public void setRawResult ( T v ) { result = v ; } public boolean exec ( ) { try { result = callable . call ( ) ; return true ; } catch ( Error err ) { throw err ; } catch ( RuntimeException rex ) { throw rex ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } public void run ( ) { invoke ( ) ; } } public < T > List < Future < T > > invokeAll ( Collection < ? extends Callable < T > > tasks ) { ArrayList < ForkJoinTask < T > > ts = new ArrayList < ForkJoinTask < T > > ( tasks . size ( ) ) ; for ( Callable < T > c : tasks ) ts . add ( new AdaptedCallable < T > ( c ) ) ; invoke ( new InvokeAll < T > ( ts ) ) ; return ( List < Future < T > > ) ( List ) ts ; } static final class InvokeAll < T > extends RecursiveAction { final ArrayList < ForkJoinTask < T > > tasks ; InvokeAll ( ArrayList < ForkJoinTask < T > > tasks ) { this . tasks = tasks ; } public void compute ( ) { try { invokeAll ( tasks ) ; } catch ( Exception ignore ) { } } } public ForkJoinWorkerThreadFactory getFactory ( ) { return factory ; } public Thread . UncaughtExceptionHandler getUncaughtExceptionHandler ( ) { Thread . UncaughtExceptionHandler h ; final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { h = ueh ; } finally { lock . unlock ( ) ; } return h ; } public Thread . UncaughtExceptionHandler setUncaughtExceptionHandler ( Thread . UncaughtExceptionHandler h ) { checkPermission ( ) ; Thread . UncaughtExceptionHandler old = null ; final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { old = ueh ; ueh = h ; ForkJoinWorkerThread [ ] ws = workers ; for ( int i = 0 ; i < ws . length ; ++ i ) { ForkJoinWorkerThread w = ws [ i ] ; if ( w != null ) w . setUncaughtExceptionHandler ( h ) ; } } finally { lock . unlock ( ) ; } return old ; } public void setParallelism ( int parallelism ) { checkPermission ( ) ; if ( parallelism <= 0 || parallelism > maxPoolSize ) throw new IllegalArgumentException ( ) ; final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { if ( ! isTerminating ( ) ) { int p = this . parallelism ; this . parallelism = parallelism ; if ( parallelism > p ) createAndStartAddedWorkers ( ) ; else trimSpares ( ) ; } } finally { lock . unlock ( ) ; } signalIdleWorkers ( ) ; } public int getParallelism ( ) { return parallelism ; } public int getPoolSize ( ) { return totalCountOf ( workerCounts ) ; } public int getMaximumPoolSize ( ) { return maxPoolSize ; } public void setMaximumPoolSize ( int newMax ) { if ( newMax < 0 || newMax > MAX_THREADS ) throw new IllegalArgumentException ( ) ; maxPoolSize = newMax ; } public boolean getMaintainsParallelism ( ) { return maintainsParallelism ; } public void setMaintainsParallelism ( boolean enable ) { maintainsParallelism = enable ; } public int getRunningThreadCount ( ) { return runningCountOf ( workerCounts ) ; } public int getActiveThreadCount ( ) { return activeCountOf ( runControl ) ; } final int getIdleThreadCount ( ) { int c = runningCountOf ( workerCounts ) - activeCountOf ( runControl ) ; return ( c <= 0 ) ? 0 : c ; } public boolean isQuiescent ( ) { return activeCountOf ( runControl ) == 0 ; } public long getStealCount ( ) { return stealCount . get ( ) ; } private void updateStealCount ( ForkJoinWorkerThread w ) { int sc = w . getAndClearStealCount ( ) ; if ( sc != 0 ) stealCount . addAndGet ( sc ) ; } public long getQueuedTaskCount ( ) { long count = 0 ; ForkJoinWorkerThread [ ] ws = workers ; for ( int i = 0 ; i < ws . length ; ++ i ) { ForkJoinWorkerThread t = ws [ i ] ; if ( t != null ) count += t . getQueueSize ( ) ; } return count ; } public int getQueuedSubmissionCount ( ) { return submissionQueue . size ( ) ; } public boolean hasQueuedSubmissions ( ) { return ! submissionQueue . isEmpty ( ) ; } protected ForkJoinTask < ? > pollSubmission ( ) { return submissionQueue . poll ( ) ; } public String toString ( ) { int ps = parallelism ; int wc = workerCounts ; int rc = runControl ; long st = getStealCount ( ) ; long qt = getQueuedTaskCount ( ) ; long qs = getQueuedSubmissionCount ( ) ; return super . toString ( ) + "[" + runStateToString ( runStateOf ( rc ) ) + ", parallelism = " + ps + ", size = " + totalCountOf ( wc ) + ", active = " + activeCountOf ( rc ) + ", running = " + runningCountOf ( wc ) + ", steals = " + st + ", tasks = " + qt + ", submissions = " + qs + "]" ; } private static String runStateToString ( int rs ) { switch ( rs ) { case RUNNING : return "Running" ; case SHUTDOWN : return "Shutting down" ; case TERMINATING : return "Terminating" ; case TERMINATED : return "Terminated" ; default : throw new Error ( "Unknown run state" ) ; } } public void shutdown ( ) { checkPermission ( ) ; transitionRunStateTo ( SHUTDOWN ) ; if ( canTerminateOnShutdown ( runControl ) ) terminateOnShutdown ( ) ; } public List < Runnable > shutdownNow ( ) { checkPermission ( ) ; terminate ( ) ; return Collections . emptyList ( ) ; } public boolean isTerminated ( ) { return runStateOf ( runControl ) == TERMINATED ; } public boolean isTerminating ( ) { return runStateOf ( runControl ) >= TERMINATING ; } public boolean isShutdown ( ) { return runStateOf ( runControl ) >= SHUTDOWN ; } public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { long nanos = unit . toNanos ( timeout ) ; final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { for ( ; ; ) { if ( isTerminated ( ) ) return true ; if ( nanos <= 0 ) return false ; nanos = termination . awaitNanos ( nanos ) ; } } finally { lock . unlock ( ) ; } } final void workerTerminated ( ForkJoinWorkerThread w ) { updateStealCount ( w ) ; updateWorkerCount ( - 1 ) ; final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { ForkJoinWorkerThread [ ] ws = workers ; int idx = w . poolIndex ; if ( idx >= 0 && idx < ws . length && ws [ idx ] == w ) ws [ idx ] = null ; if ( totalCountOf ( workerCounts ) == 0 ) { terminate ( ) ; transitionRunStateTo ( TERMINATED ) ; termination . signalAll ( ) ; } else if ( ! isTerminating ( ) ) { tryShrinkWorkerArray ( ) ; tryResumeSpare ( true ) ; } } finally { lock . unlock ( ) ; } signalIdleWorkers ( ) ; } private void terminate ( ) { if ( transitionRunStateTo ( TERMINATING ) ) { stopAllWorkers ( ) ; resumeAllSpares ( ) ; signalIdleWorkers ( ) ; cancelQueuedSubmissions ( ) ; cancelQueuedWorkerTasks ( ) ; interruptUnterminatedWorkers ( ) ; signalIdleWorkers ( ) ; } } private void terminateOnShutdown ( ) { if ( ! hasQueuedSubmissions ( ) && canTerminateOnShutdown ( runControl ) ) terminate ( ) ; } private void cancelQueuedSubmissions ( ) { ForkJoinTask < ? > task ; while ( ( task = pollSubmission ( ) ) != null ) task . cancel ( false ) ; } private void cancelQueuedWorkerTasks ( ) { final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { ForkJoinWorkerThread [ ] ws = workers ; for ( int i = 0 ; i < ws . length ; ++ i ) { ForkJoinWorkerThread t = ws [ i ] ; if ( t != null ) t . cancelTasks ( ) ; } } finally { lock . unlock ( ) ; } } private void stopAllWorkers ( ) { final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { ForkJoinWorkerThread [ ] ws = workers ; for ( int i = 0 ; i < ws . length ; ++ i ) { ForkJoinWorkerThread t = ws [ i ] ; if ( t != null ) t . shutdownNow ( ) ; } } finally { lock . unlock ( ) ; } } private void interruptUnterminatedWorkers ( ) { final ReentrantLock lock = this . workerLock ; lock . lock ( ) ; try { ForkJoinWorkerThread [ ] ws = workers ; for ( int i = 0 ; i < ws . length ; ++ i ) { ForkJoinWorkerThread t = ws [ i ] ; if ( t != null && ! t . isTerminated ( ) ) { try { t . interrupt ( ) ; } catch ( SecurityException ignore ) { } } } } finally { lock . unlock ( ) ; } } static final class WaitQueueNode { WaitQueueNode next ; volatile ForkJoinWorkerThread thread ; final long count ; WaitQueueNode ( long c , ForkJoinWorkerThread w ) { count = c ; thread = w ; } boolean signal ( ) { ForkJoinWorkerThread t = thread ; if ( t == null ) return false ; thread = null ; LockSupport . unpark ( t ) ; return true ; } void awaitSyncRelease ( ForkJoinPool p ) { while ( thread != null && ! p . syncIsReleasable ( this ) ) LockSupport . park ( this ) ; } void awaitSpareRelease ( ) { while ( thread != null ) { if ( ! Thread . interrupted ( ) ) LockSupport . park ( this ) ; } } } final long ensureSync ( ) { long c = eventCount ; WaitQueueNode q ; while ( ( q = syncStack ) != null && q . count < c ) { if ( casBarrierStack ( q , null ) ) { do { q . signal ( ) ; } while ( ( q = q . next ) != null ) ; break ; } } return c ; } private void signalIdleWorkers ( ) { long c ; do ; while ( ! casEventCount ( c = eventCount , c + 1 ) ) ; ensureSync ( ) ; } final void signalWork ( ) { long c ; WaitQueueNode q ; if ( syncStack != null && casEventCount ( c = eventCount , c + 1 ) && ( ( ( q = syncStack ) != null && q . count <= c ) && ( ! casBarrierStack ( q , q . next ) || ! q . signal ( ) ) ) ) ensureSync ( ) ; } final void sync ( ForkJoinWorkerThread w ) { updateStealCount ( w ) ; while ( ! w . isShutdown ( ) && ! isTerminating ( ) && ! suspendIfSpare ( w ) ) { long prev = w . lastEventCount ; WaitQueueNode node = null ; WaitQueueNode h ; while ( eventCount == prev && ( ( h = syncStack ) == null || h . count == prev ) ) { if ( node == null ) node = new WaitQueueNode ( prev , w ) ; if ( casBarrierStack ( node . next = h , node ) ) { node . awaitSyncRelease ( this ) ; break ; } } long ec = ensureSync ( ) ; if ( ec != prev ) { w . lastEventCount = ec ; break ; } } } final boolean syncIsReleasable ( WaitQueueNode node ) { long prev = node . count ; if ( ! Thread . interrupted ( ) && node . thread != null && ( node . next != null || ! ForkJoinWorkerThread . hasQueuedTasks ( workers ) ) && eventCount == prev ) return false ; if ( node . thread != null ) { node . thread = null ; long ec = eventCount ; if ( prev <= ec ) casEventCount ( ec , ec + 1 ) ; } return true ; } final boolean hasNewSyncEvent ( ForkJoinWorkerThread w ) { long lc = w . lastEventCount ; long ec = ensureSync ( ) ; if ( ec == lc ) return false ; w . lastEventCount = ec ; return true ; } final boolean preJoin ( ForkJoinTask < ? > joinMe , boolean maintainParallelism ) { maintainParallelism &= maintainsParallelism ; boolean dec = false ; while ( spareStack == null || ! tryResumeSpare ( dec ) ) { int counts = workerCounts ; if ( dec || ( dec = casWorkerCounts ( counts , -- counts ) ) ) { if ( ! needSpare ( counts , maintainParallelism ) ) break ; if ( joinMe . status < 0 ) return true ; if ( tryAddSpare ( counts ) ) break ; } } return false ; } final boolean preBlock ( ManagedBlocker blocker , boolean maintainParallelism ) { maintainParallelism &= maintainsParallelism ; boolean dec = false ; while ( spareStack == null || ! tryResumeSpare ( dec ) ) { int counts = workerCounts ; if ( dec || ( dec = casWorkerCounts ( counts , -- counts ) ) ) { if ( ! needSpare ( counts , maintainParallelism ) ) break ; if ( blocker . isReleasable ( ) ) return true ; if ( tryAddSpare ( counts ) ) break ; } } return false ; } private boolean needSpare ( int counts , boolean maintainParallelism ) { int ps = parallelism ; int rc = runningCountOf ( counts ) ; int tc = totalCountOf ( counts ) ; int runningDeficit = ps - rc ; int totalSurplus = tc - ps ; return ( tc < maxPoolSize && ( rc == 0 || totalSurplus < 0 || ( maintainParallelism && runningDeficit > totalSurplus && ForkJoinWorkerThread . hasQueuedTasks ( workers ) ) ) ) ; } private boolean tryAddSpare ( int expectedCounts ) { final ReentrantLock lock = this . workerLock ; int expectedRunning = runningCountOf ( expectedCounts ) ; int expectedTotal = totalCountOf ( expectedCounts ) ; boolean success = false ; boolean locked = false ; try { for ( ; ; ) { int s = workerCounts ; int tc = totalCountOf ( s ) ; int rc = runningCountOf ( s ) ; if ( rc > expectedRunning || tc > expectedTotal ) break ; if ( ! locked && ! ( locked = lock . tryLock ( ) ) ) break ; if ( casWorkerCounts ( s , workerCountsFor ( tc + 1 , rc + 1 ) ) ) { createAndStartSpare ( tc ) ; success = true ; break ; } } } finally { if ( locked ) lock . unlock ( ) ; } return success ; } private void createAndStartSpare ( int k ) { ForkJoinWorkerThread w = null ; ForkJoinWorkerThread [ ] ws = ensureWorkerArrayCapacity ( k + 1 ) ; int len = ws . length ; if ( k < len && ws [ k ] != null ) { for ( k = 0 ; k < len && ws [ k ] != null ; ++ k ) ; } if ( k < len && ! isTerminating ( ) && ( w = createWorker ( k ) ) != null ) { ws [ k ] = w ; w . start ( ) ; } else updateWorkerCount ( - 1 ) ; signalIdleWorkers ( ) ; } private boolean suspendIfSpare ( ForkJoinWorkerThread w ) { WaitQueueNode node = null ; int s ; while ( parallelism < runningCountOf ( s = workerCounts ) ) { if ( node == null ) node = new WaitQueueNode ( 0 , w ) ; if ( casWorkerCounts ( s , s - 1 ) ) { do ; while ( ! casSpareStack ( node . next = spareStack , node ) ) ; node . awaitSpareRelease ( ) ; return true ; } } return false ; } private boolean tryResumeSpare ( boolean updateCount ) { WaitQueueNode q ; while ( ( q = spareStack ) != null ) { if ( casSpareStack ( q , q . next ) ) { if ( updateCount ) updateRunningCount ( 1 ) ; q . signal ( ) ; return true ; } } return false ; } private boolean resumeAllSpares ( ) { WaitQueueNode q ; while ( ( q = spareStack ) != null ) { if ( casSpareStack ( q , null ) ) { do { updateRunningCount ( 1 ) ; q . signal ( ) ; } while ( ( q = q . next ) != null ) ; return true ; } } return false ; } private void trimSpares ( ) { int surplus = totalCountOf ( workerCounts ) - parallelism ; WaitQueueNode q ; while ( surplus > 0 && ( q = spareStack ) != null ) { if ( casSpareStack ( q , null ) ) { do { updateRunningCount ( 1 ) ; ForkJoinWorkerThread w = q . thread ; if ( w != null && surplus > 0 && runningCountOf ( workerCounts ) > 0 && w . shutdown ( ) ) -- surplus ; q . signal ( ) ; } while ( ( q = q . next ) != null ) ; } } } public static interface ManagedBlocker { boolean block ( ) throws InterruptedException ; boolean isReleasable ( ) ; } public static void managedBlock ( ManagedBlocker blocker , boolean maintainParallelism ) throws InterruptedException { Thread t = Thread . currentThread ( ) ; ForkJoinPool pool = ( t instanceof ForkJoinWorkerThread ? ( ( ForkJoinWorkerThread ) t ) . pool : null ) ; if ( ! blocker . isReleasable ( ) ) { try { if ( pool == null || ! pool . preBlock ( blocker , maintainParallelism ) ) awaitBlocker ( blocker ) ; } finally { if ( pool != null ) pool . updateRunningCount ( 1 ) ; } } } private static void awaitBlocker ( ManagedBlocker blocker ) throws InterruptedException { do ; while ( ! blocker . isReleasable ( ) && ! blocker . block ( ) ) ; } protected < T > RunnableFuture < T > newTaskFor ( Runnable runnable , T value ) { return new AdaptedRunnable ( runnable , value ) ; } protected < T > RunnableFuture < T > newTaskFor ( Callable < T > callable ) { return new AdaptedCallable ( callable ) ; } private static Unsafe getUnsafe ( ) throws Throwable { try { return Unsafe . getUnsafe ( ) ; } catch ( SecurityException se ) { try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < Unsafe > ( ) { public Unsafe run ( ) throws Exception { return getUnsafePrivileged ( ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw e . getCause ( ) ; } } } private static Unsafe getUnsafePrivileged ( ) throws NoSuchFieldException , IllegalAccessException { Field f = Unsafe . class . getDeclaredField ( "theUnsafe" ) ; f . setAccessible ( true ) ; return ( Unsafe ) f . get ( null ) ; } private static long fieldOffset ( String fieldName ) throws NoSuchFieldException { return _unsafe . objectFieldOffset ( ForkJoinPool . class . getDeclaredField ( fieldName ) ) ; } static final Unsafe _unsafe ; static final long eventCountOffset ; static final long workerCountsOffset ; static final long runControlOffset ; static final long syncStackOffset ; static final long spareStackOffset ; static { try { _unsafe = getUnsafe ( ) ; eventCountOffset = fieldOffset ( "eventCount" ) ; workerCountsOffset = fieldOffset ( "workerCounts" ) ; runControlOffset = fieldOffset ( "runControl" ) ; syncStackOffset = fieldOffset ( "syncStack" ) ; spareStackOffset = fieldOffset ( "spareStack" ) ; } catch ( Throwable e ) { throw new RuntimeException ( "Could not initialize intrinsics" , e ) ; } } private boolean casEventCount ( long cmp , long val ) { return _unsafe . compareAndSwapLong ( this , eventCountOffset , cmp , val ) ; } private boolean casWorkerCounts ( int cmp , int val ) { return _unsafe . compareAndSwapInt ( this , workerCountsOffset , cmp , val ) ; } private boolean casRunControl ( int cmp , int val ) { return _unsafe . compareAndSwapInt ( this , runControlOffset , cmp , val ) ; } private boolean casSpareStack ( WaitQueueNode cmp , WaitQueueNode val ) { return _unsafe . compareAndSwapObject ( this , spareStackOffset , cmp , val ) ; } private boolean casBarrierStack ( WaitQueueNode cmp , WaitQueueNode val ) { return _unsafe . compareAndSwapObject ( this , syncStackOffset , cmp , val ) ; } } 