public class Phaser { private volatile long state ; private static final int ushortBits = 16 ; private static final int ushortMask = 0xffff ; private static final int phaseMask = 0x7fffffff ; private static int unarrivedOf ( long s ) { return ( int ) ( s & ushortMask ) ; } private static int partiesOf ( long s ) { return ( ( int ) s ) > > > 16 ; } private static int phaseOf ( long s ) { return ( int ) ( s > > > 32 ) ; } private static int arrivedOf ( long s ) { return partiesOf ( s ) - unarrivedOf ( s ) ; } private static long stateFor ( int phase , int parties , int unarrived ) { return ( ( ( ( long ) phase ) << 32 ) | ( ( ( long ) parties ) << 16 ) | ( long ) unarrived ) ; } private static long trippedStateFor ( int phase , int parties ) { long lp = ( long ) parties ; return ( ( ( long ) phase ) << 32 ) | ( lp << 16 ) | lp ; } private static String badBounds ( int parties , int unarrived ) { return ( "Attempt to set " + unarrived + " unarrived of " + parties + " parties" ) ; } private final Phaser parent ; private final Phaser root ; private final AtomicReference < QNode > evenQ = new AtomicReference < QNode > ( ) ; private final AtomicReference < QNode > oddQ = new AtomicReference < QNode > ( ) ; private AtomicReference < QNode > queueFor ( int phase ) { return ( phase & 1 ) == 0 ? evenQ : oddQ ; } private long getReconciledState ( ) { return parent == null ? state : reconcileState ( ) ; } private long reconcileState ( ) { Phaser p = parent ; long s = state ; if ( p != null ) { while ( unarrivedOf ( s ) == 0 && phaseOf ( s ) != phaseOf ( root . state ) ) { long parentState = p . getReconciledState ( ) ; int parentPhase = phaseOf ( parentState ) ; int phase = phaseOf ( s = state ) ; if ( phase != parentPhase ) { long next = trippedStateFor ( parentPhase , partiesOf ( s ) ) ; if ( casState ( s , next ) ) { releaseWaiters ( phase ) ; s = next ; } } } } return s ; } public Phaser ( ) { this ( null ) ; } public Phaser ( int parties ) { this ( null , parties ) ; } public Phaser ( Phaser parent ) { int phase = 0 ; this . parent = parent ; if ( parent != null ) { this . root = parent . root ; phase = parent . register ( ) ; } else this . root = this ; this . state = trippedStateFor ( phase , 0 ) ; } public Phaser ( Phaser parent , int parties ) { if ( parties < 0 || parties > ushortMask ) throw new IllegalArgumentException ( "Illegal number of parties" ) ; int phase = 0 ; this . parent = parent ; if ( parent != null ) { this . root = parent . root ; phase = parent . register ( ) ; } else this . root = this ; this . state = trippedStateFor ( phase , parties ) ; } public int register ( ) { return doRegister ( 1 ) ; } public int bulkRegister ( int parties ) { if ( parties < 0 ) throw new IllegalArgumentException ( ) ; if ( parties == 0 ) return getPhase ( ) ; return doRegister ( parties ) ; } private int doRegister ( int registrations ) { int phase ; for ( ; ; ) { long s = getReconciledState ( ) ; phase = phaseOf ( s ) ; int unarrived = unarrivedOf ( s ) + registrations ; int parties = partiesOf ( s ) + registrations ; if ( phase < 0 ) break ; if ( parties > ushortMask || unarrived > ushortMask ) throw new IllegalStateException ( badBounds ( parties , unarrived ) ) ; if ( phase == phaseOf ( root . state ) && casState ( s , stateFor ( phase , parties , unarrived ) ) ) break ; } return phase ; } public int arrive ( ) { int phase ; for ( ; ; ) { long s = state ; phase = phaseOf ( s ) ; if ( phase < 0 ) break ; int parties = partiesOf ( s ) ; int unarrived = unarrivedOf ( s ) - 1 ; if ( unarrived > 0 ) { if ( casState ( s , s - 1 ) ) break ; } else if ( unarrived == 0 ) { Phaser par = parent ; if ( par == null ) { if ( casState ( s , trippedStateFor ( onAdvance ( phase , parties ) ? - 1 : ( ( phase + 1 ) & phaseMask ) , parties ) ) ) { releaseWaiters ( phase ) ; break ; } } else { if ( casState ( s , s - 1 ) ) { par . arrive ( ) ; reconcileState ( ) ; break ; } } } else if ( phase != phaseOf ( root . state ) ) reconcileState ( ) ; else throw new IllegalStateException ( badBounds ( parties , unarrived ) ) ; } return phase ; } public int arriveAndDeregister ( ) { Phaser par = parent ; int phase ; for ( ; ; ) { long s = state ; phase = phaseOf ( s ) ; if ( phase < 0 ) break ; int parties = partiesOf ( s ) - 1 ; int unarrived = unarrivedOf ( s ) - 1 ; if ( parties >= 0 ) { if ( unarrived > 0 || ( unarrived == 0 && par != null ) ) { if ( casState ( s , stateFor ( phase , parties , unarrived ) ) ) { if ( unarrived == 0 ) { par . arriveAndDeregister ( ) ; reconcileState ( ) ; } break ; } continue ; } if ( unarrived == 0 ) { if ( casState ( s , trippedStateFor ( onAdvance ( phase , parties ) ? - 1 : ( ( phase + 1 ) & phaseMask ) , parties ) ) ) { releaseWaiters ( phase ) ; break ; } continue ; } if ( par != null && phase != phaseOf ( root . state ) ) { reconcileState ( ) ; continue ; } } throw new IllegalStateException ( badBounds ( parties , unarrived ) ) ; } return phase ; } public int arriveAndAwaitAdvance ( ) { return awaitAdvance ( arrive ( ) ) ; } public int awaitAdvance ( int phase ) { if ( phase < 0 ) return phase ; long s = getReconciledState ( ) ; int p = phaseOf ( s ) ; if ( p != phase ) return p ; if ( unarrivedOf ( s ) == 0 && parent != null ) parent . awaitAdvance ( phase ) ; return untimedWait ( phase ) ; } public int awaitAdvanceInterruptibly ( int phase ) throws InterruptedException { if ( phase < 0 ) return phase ; long s = getReconciledState ( ) ; int p = phaseOf ( s ) ; if ( p != phase ) return p ; if ( unarrivedOf ( s ) == 0 && parent != null ) parent . awaitAdvanceInterruptibly ( phase ) ; return interruptibleWait ( phase ) ; } public int awaitAdvanceInterruptibly ( int phase , long timeout , TimeUnit unit ) throws InterruptedException , TimeoutException { if ( phase < 0 ) return phase ; long s = getReconciledState ( ) ; int p = phaseOf ( s ) ; if ( p != phase ) return p ; if ( unarrivedOf ( s ) == 0 && parent != null ) parent . awaitAdvanceInterruptibly ( phase , timeout , unit ) ; return timedWait ( phase , unit . toNanos ( timeout ) ) ; } public void forceTermination ( ) { for ( ; ; ) { long s = getReconciledState ( ) ; int phase = phaseOf ( s ) ; int parties = partiesOf ( s ) ; int unarrived = unarrivedOf ( s ) ; if ( phase < 0 || casState ( s , stateFor ( - 1 , parties , unarrived ) ) ) { releaseWaiters ( 0 ) ; releaseWaiters ( 1 ) ; if ( parent != null ) parent . forceTermination ( ) ; return ; } } } public final int getPhase ( ) { return phaseOf ( getReconciledState ( ) ) ; } public final boolean hasPhase ( int phase ) { return phaseOf ( getReconciledState ( ) ) == phase ; } public int getRegisteredParties ( ) { return partiesOf ( state ) ; } public int getArrivedParties ( ) { return arrivedOf ( state ) ; } public int getUnarrivedParties ( ) { return unarrivedOf ( state ) ; } public Phaser getParent ( ) { return parent ; } public Phaser getRoot ( ) { return root ; } public boolean isTerminated ( ) { return getPhase ( ) < 0 ; } protected boolean onAdvance ( int phase , int registeredParties ) { return registeredParties <= 0 ; } public String toString ( ) { long s = getReconciledState ( ) ; return super . toString ( ) + "[phase = " + phaseOf ( s ) + " parties = " + partiesOf ( s ) + " arrived = " + arrivedOf ( s ) + "]" ; } static final class QNode implements ForkJoinPool . ManagedBlocker { final Phaser phaser ; final int phase ; final long startTime ; final long nanos ; final boolean timed ; final boolean interruptible ; volatile boolean wasInterrupted = false ; volatile Thread thread ; QNode next ; QNode ( Phaser phaser , int phase , boolean interruptible , boolean timed , long startTime , long nanos ) { this . phaser = phaser ; this . phase = phase ; this . timed = timed ; this . interruptible = interruptible ; this . startTime = startTime ; this . nanos = nanos ; thread = Thread . currentThread ( ) ; } public boolean isReleasable ( ) { return ( thread == null || phaser . getPhase ( ) != phase || ( interruptible && wasInterrupted ) || ( timed && ( nanos - ( System . nanoTime ( ) - startTime ) ) <= 0 ) ) ; } public boolean block ( ) { if ( Thread . interrupted ( ) ) { wasInterrupted = true ; if ( interruptible ) return true ; } if ( ! timed ) LockSupport . park ( this ) ; else { long waitTime = nanos - ( System . nanoTime ( ) - startTime ) ; if ( waitTime <= 0 ) return true ; LockSupport . parkNanos ( this , waitTime ) ; } return isReleasable ( ) ; } void signal ( ) { Thread t = thread ; if ( t != null ) { thread = null ; LockSupport . unpark ( t ) ; } } boolean doWait ( ) { if ( thread != null ) { try { ForkJoinPool . managedBlock ( this , false ) ; } catch ( InterruptedException ie ) { } } return wasInterrupted ; } } private void releaseWaiters ( int phase ) { AtomicReference < QNode > head = queueFor ( phase ) ; QNode q ; while ( ( q = head . get ( ) ) != null ) { if ( head . compareAndSet ( q , q . next ) ) q . signal ( ) ; } } private boolean tryEnqueue ( QNode node ) { AtomicReference < QNode > head = queueFor ( node . phase ) ; return head . compareAndSet ( node . next = head . get ( ) , node ) ; } private int untimedWait ( int phase ) { QNode node = null ; boolean queued = false ; boolean interrupted = false ; int p ; while ( ( p = getPhase ( ) ) == phase ) { if ( Thread . interrupted ( ) ) interrupted = true ; else if ( node == null ) node = new QNode ( this , phase , false , false , 0 , 0 ) ; else if ( ! queued ) queued = tryEnqueue ( node ) ; else interrupted = node . doWait ( ) ; } if ( node != null ) node . thread = null ; releaseWaiters ( phase ) ; if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; return p ; } private int interruptibleWait ( int phase ) throws InterruptedException { QNode node = null ; boolean queued = false ; boolean interrupted = false ; int p ; while ( ( p = getPhase ( ) ) == phase && ! interrupted ) { if ( Thread . interrupted ( ) ) interrupted = true ; else if ( node == null ) node = new QNode ( this , phase , true , false , 0 , 0 ) ; else if ( ! queued ) queued = tryEnqueue ( node ) ; else interrupted = node . doWait ( ) ; } if ( node != null ) node . thread = null ; if ( p != phase || ( p = getPhase ( ) ) != phase ) releaseWaiters ( phase ) ; if ( interrupted ) throw new InterruptedException ( ) ; return p ; } private int timedWait ( int phase , long nanos ) throws InterruptedException , TimeoutException { long startTime = System . nanoTime ( ) ; QNode node = null ; boolean queued = false ; boolean interrupted = false ; int p ; while ( ( p = getPhase ( ) ) == phase && ! interrupted ) { if ( Thread . interrupted ( ) ) interrupted = true ; else if ( nanos - ( System . nanoTime ( ) - startTime ) <= 0 ) break ; else if ( node == null ) node = new QNode ( this , phase , true , true , startTime , nanos ) ; else if ( ! queued ) queued = tryEnqueue ( node ) ; else interrupted = node . doWait ( ) ; } if ( node != null ) node . thread = null ; if ( p != phase || ( p = getPhase ( ) ) != phase ) releaseWaiters ( phase ) ; if ( interrupted ) throw new InterruptedException ( ) ; if ( p == phase ) throw new TimeoutException ( ) ; return p ; } private static Unsafe getUnsafe ( ) throws Throwable { try { return Unsafe . getUnsafe ( ) ; } catch ( SecurityException se ) { try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < Unsafe > ( ) { public Unsafe run ( ) throws Exception { return getUnsafePrivileged ( ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw e . getCause ( ) ; } } } private static Unsafe getUnsafePrivileged ( ) throws NoSuchFieldException , IllegalAccessException { Field f = Unsafe . class . getDeclaredField ( "theUnsafe" ) ; f . setAccessible ( true ) ; return ( Unsafe ) f . get ( null ) ; } private static long fieldOffset ( String fieldName ) throws NoSuchFieldException { return _unsafe . objectFieldOffset ( Phaser . class . getDeclaredField ( fieldName ) ) ; } static final Unsafe _unsafe ; static final long stateOffset ; static { try { _unsafe = getUnsafe ( ) ; stateOffset = fieldOffset ( "state" ) ; } catch ( Throwable e ) { throw new RuntimeException ( "Could not initialize intrinsics" , e ) ; } } final boolean casState ( long cmp , long val ) { return _unsafe . compareAndSwapLong ( this , stateOffset , cmp , val ) ; } } 