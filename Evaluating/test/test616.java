<<<<<<< HEAD
public class XMLEditor extends UnifiedEditor { private boolean isDisposing = false ; private boolean _isMarkingBothTags ; public XMLEditor ( ) { super ( ) ; addPluginToPreferenceStore ( XMLPlugin . getDefault ( ) ) ; _isMarkingBothTags = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . XMLEDITOR_HIGHLIGHT_START_END_TAGS ) ; } protected IUnifiedEditorContributor createLocalContributor ( ) { return new XMLContributor ( ) ; } public IFileServiceFactory getFileServiceFactory ( ) { return XMLFileServiceFactory . getInstance ( ) ; } public String getDefaultFileExtension ( ) { return "xml" ; } public void dispose ( ) { if ( isDisposing ) { return ; } isDisposing = true ; super . dispose ( ) ; } protected boolean isNewInput ( IEditorInput input ) { XMLFileInfo cuInfo = getXMLFileInfo ( input ) ; if ( cuInfo == null ) { throw new RuntimeException ( Messages . XMLEditor_cuInfo_Null_At_DoSetInput ) ; } XMLDocumentProvider dp = ( XMLDocumentProvider ) getDocumentProvider ( ) ; IDocument document = dp . getDocument ( input ) ; DocumentSourceProvider provider = new DocumentSourceProvider ( document , input ) ; if ( provider == null ) { throw new RuntimeException ( Messages . XMLEditor_Provider_Null ) ; } return ( cuInfo . sourceProvider == null || cuInfo . sourceProvider . equals ( provider ) == false ) ; } private XMLFileInfo getXMLFileInfo ( IEditorInput input ) { XMLDocumentProvider dp = ( XMLDocumentProvider ) getDocumentProvider ( ) ; if ( dp == null ) { throw new RuntimeException ( Messages . XMLEditor_Document_Provider_Null ) ; } return ( XMLFileInfo ) dp . getFileInfoPublic ( input ) ; } protected void updateFileInfo ( IEditorInput input , DocumentSourceProvider provider , IDocument document ) { super . updateFileInfo ( input , provider , document ) ; if ( isNewInput ( input ) ) { getXMLFileInfo ( input ) . sourceProvider = provider ; } } private ToolbarWidget toolbar ; private Composite displayArea ; public void createPartControl ( Composite parent ) { displayArea = new Composite ( parent , SWT . NONE ) ; GridLayout daLayout = new GridLayout ( 1 , true ) ; daLayout . marginHeight = 0 ; daLayout . marginWidth = 0 ; displayArea . setLayout ( daLayout ) ; displayArea . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; boolean show = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . SHOW_XML_TOOLBAR ) ; if ( show ) { toolbar = new ToolbarWidget ( new String [ ] { XMLMimeType . MimeType } , new String [ ] { "XML" } , getPreferenceStore ( ) , IPreferenceConstants . SHOW_XML_TOOLBAR , this ) ; toolbar . createControl ( displayArea ) ; } Composite editorArea = new Composite ( displayArea , SWT . NONE ) ; editorArea . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; GridLayout eaLayout = new GridLayout ( 1 , true ) ; eaLayout . marginHeight = 0 ; eaLayout . marginWidth = 0 ; editorArea . setLayout ( new FillLayout ( ) ) ; super . createPartControl ( editorArea ) ; } public boolean canMarkOccurrences ( Lexeme lexeme ) { IToken token = lexeme . getToken ( ) ; int typeIndex = token . getTypeIndex ( ) ; if ( typeIndex == XMLTokenTypes . WHITESPACE || typeIndex == XMLTokenTypes . COMMENT || typeIndex == XMLTokenTypes . TEXT ) { return false ; } return true ; } protected void markOccurences ( LexemeList lexemeList , Lexeme selectedLexeme ) { boolean deferToParent = true ; if ( _isMarkingBothTags && ( selectedLexeme . typeIndex == XMLTokenTypes . START_TAG || selectedLexeme . typeIndex == XMLTokenTypes . END_TAG ) ) { deferToParent = false ; String selectedText = selectedLexeme . getText ( ) ; String normalizedSelectedText = selectedText ; if ( selectedLexeme . typeIndex == XMLTokenTypes . END_TAG ) { if ( selectedLexeme . length >= 3 ) { normalizedSelectedText = selectedText . substring ( 0 , 1 ) + selectedText . substring ( 2 ) ; } } for ( int i = 0 ; i < lexemeList . size ( ) ; i ++ ) { Lexeme lexeme = lexemeList . get ( i ) ; if ( lexeme != null ) { if ( lexeme . isHighlighted ( ) ) { lexeme . setHighlighted ( false ) ; } if ( lexeme . typeIndex == XMLTokenTypes . START_TAG || lexeme . typeIndex == XMLTokenTypes . END_TAG ) { if ( lexeme . typeIndex == selectedLexeme . typeIndex && lexeme . length == selectedLexeme . length ) { if ( selectedText . equals ( lexeme . getText ( ) ) ) { lexeme . setHighlighted ( true ) ; } } else if ( ( lexeme . length - selectedLexeme . length ) == 1 ) { if ( lexeme . typeIndex == XMLTokenTypes . END_TAG ) { if ( lexeme . length >= 3 ) { String normalizedText = lexeme . getText ( ) . substring ( 0 , 1 ) + lexeme . getText ( ) . substring ( 2 ) ; if ( normalizedText . equals ( selectedText ) ) { lexeme . setHighlighted ( true ) ; } } } } else if ( ( selectedLexeme . length - lexeme . length ) == 1 ) { if ( normalizedSelectedText . equals ( lexeme . getText ( ) ) ) { lexeme . setHighlighted ( true ) ; } } } } } } if ( deferToParent ) { super . markOccurences ( lexemeList , selectedLexeme ) ; } } public IDocumentProvider createDocumentProvider ( ) { return XMLDocumentProvider . getInstance ( ) ; } protected String [ ] collectContextMenuPreferencePages ( ) { return new String [ ] { "com.aptana.ide.editor.xml.preferences.GeneralPreferencePage" , "com.aptana.ide.editor.xml.preferences.ColorizationPreferencePage" , "com.aptana.ide.editor.xml.preferences.FoldingPreferencePage" , "com.aptana.ide.editor.xml.preferences.ProblemsPreferencePage" , "com.aptana.ide.editor.xml.preferences.FormattingPreferencePage" , "com.aptana.ide.editor.xml.preferences.CodeAssistPreferencePage" , "com.aptana.ide.editor.xml.preferences.TypingPreferencePage" , "org.eclipse.ui.preferencePages.GeneralTextEditor" , "org.eclipse.ui.editors.preferencePages.Annotations" , "org.eclipse.ui.editors.preferencePages.QuickDiff" , "org.eclipse.ui.editors.preferencePages.Accessibility" , "org.eclipse.ui.editors.preferencePages.Spelling" , "org.eclipse.ui.editors.preferencePages.LinkedModePreferencePage" , } ; } protected void handlePreferenceStoreChanged ( PropertyChangeEvent event ) { String property = event . getProperty ( ) ; if ( IPreferenceConstants . XMLEDITOR_HIGHLIGHT_START_END_TAGS . equals ( property ) ) { _isMarkingBothTags = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . XMLEDITOR_HIGHLIGHT_START_END_TAGS ) ; } else { super . handlePreferenceStoreChanged ( event ) ; } } } 
=======
public final class Language extends AbstractDatatype { public static final Language THE_INSTANCE = new Language ( ) ; private static final Pattern HYPHEN = Pattern . compile ( "-" ) ; private static final boolean WARN = System . getProperty ( "org.whattf.datatype.warn" , "" ) . equals ( "true" ) ? true : false ; private static String [ ] languages = null ; private static String [ ] extlangs = null ; private static String [ ] scripts = null ; private static String [ ] regions = null ; private static String [ ] variants = null ; private static String [ ] grandfathered = null ; private static String [ ] redundant = null ; private static String [ ] deprecated = null ; private static String [ ] deprecatedLang = null ; private static int [ ] suppressedScriptByLanguage = null ; private static Map < String , String > preferredValueByLanguageMap = new HashMap < String , String > ( ) ; private static String [ ] [ ] [ ] prefixesByVariant = null ; private static int [ ] prefixByExtlang = null ; static { try { LanguageData data = new LanguageData ( ) ; languages = data . getLanguages ( ) ; extlangs = data . getExtlangs ( ) ; scripts = data . getScripts ( ) ; regions = data . getRegions ( ) ; variants = data . getVariants ( ) ; grandfathered = data . getGrandfathered ( ) ; redundant = data . getRedundant ( ) ; deprecated = data . getDeprecated ( ) ; deprecatedLang = data . getDeprecatedLang ( ) ; suppressedScriptByLanguage = data . getSuppressedScriptByLanguage ( ) ; prefixByExtlang = data . getPrefixByExtlang ( ) ; preferredValueByLanguageMap = data . getPreferredValueByLanguageMap ( ) ; prefixesByVariant = data . getPrefixesByVariant ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } private Language ( ) { super ( ) ; } public void checkValid ( CharSequence lit ) throws DatatypeException { String literal = lit . toString ( ) ; if ( literal . length ( ) == 0 ) { throw newDatatypeException ( "The empty string is not a valid language tag." ) ; } literal = toAsciiLowerCase ( literal ) ; if ( isGrandfathered ( literal ) ) { if ( isDeprecated ( literal ) && WARN ) { throw newDatatypeException ( "The grandfathered language tag " , literal , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } return ; } if ( isRedundant ( literal ) ) { if ( isDeprecated ( literal ) && WARN ) { throw newDatatypeException ( "The language tag " , lit . toString ( ) , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } return ; } if ( literal . startsWith ( "-" ) ) { throw newDatatypeException ( "Language tag must not start with HYPHEN-MINUS." ) ; } if ( literal . endsWith ( "-" ) ) { throw newDatatypeException ( "Language tag must not end with HYPHEN-MINUS." ) ; } String [ ] subtags = HYPHEN . split ( literal ) ; for ( int j = 0 ; j < subtags . length ; j ++ ) { int len = subtags [ j ] . length ( ) ; if ( len == 0 ) { throw newDatatypeException ( "Zero-length subtag." ) ; } else if ( len > 8 ) { throw newDatatypeException ( "Subtags must not exceed 8 characters in length." ) ; } } int i = 0 ; String subtag = subtags [ i ] ; int len = subtag . length ( ) ; if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( ( len == 2 || len == 3 ) && isLowerCaseAlpha ( subtag ) ) { if ( ! isLanguage ( subtag ) ) { throw newDatatypeException ( "The language subtag " , subtag , " is not a valid ISO language part of a language tag." ) ; } if ( isDeprecatedLang ( subtag ) && WARN ) { throw newDatatypeException ( "The language subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } else if ( len == 4 && isLowerCaseAlpha ( subtag ) ) { throw newDatatypeException ( "Found reserved language tag: " , subtag , "." ) ; } else if ( len >= 5 && isLowerCaseAlpha ( subtag ) ) { if ( ! isLanguage ( subtag ) ) { throw newDatatypeException ( "The language subtag " , subtag , " is not a valid IANA language part of a language tag." ) ; } if ( isDeprecatedLang ( subtag ) && WARN ) { throw newDatatypeException ( "The language subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } else { throw newDatatypeException ( "The language subtag " , subtag , " is not a valid language subtag." ) ; } if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( subtag . length ( ) == 3 && isLowerCaseAlpha ( subtag ) ) { if ( ! isExtlang ( subtag ) ) { throw newDatatypeException ( "Bad extlang subtag " , subtag , "." ) ; } if ( ! usesPrefixByExtlang ( subtags [ 0 ] , subtag ) ) { throw newDatatypeException ( "Extlang subtag " , subtag , " has an incorrect prefix." ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( subtag . length ( ) == 4 & isLowerCaseAlpha ( subtag ) ) { if ( ! isScript ( subtag ) ) { throw newDatatypeException ( "Bad script subtag." ) ; } if ( isDeprecated ( subtag ) && WARN ) { throw newDatatypeException ( "The script subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } if ( shouldSuppressScript ( subtags [ 0 ] , subtag ) ) { throw newDatatypeException ( "Language tag should omit the default script for the language." ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } if ( ( len == 3 && isDigit ( subtag ) ) || ( len == 2 && isLowerCaseAlpha ( subtag ) ) ) { if ( ! isRegion ( subtag ) ) { throw newDatatypeException ( "Bad region subtag." ) ; } if ( isDeprecated ( subtag ) && WARN ) { throw newDatatypeException ( "The region subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } for ( ; ; ) { if ( "x" . equals ( subtag ) ) { checkPrivateUse ( i , subtags ) ; return ; } if ( len == 1 && isLowerCaseAlphaNumeric ( subtag ) ) { throw newDatatypeException ( "Unknown extension " , subtag , "." ) ; } else if ( ( len == 4 && isDigit ( subtag . charAt ( 0 ) ) && isLowerCaseAlphaNumeric ( subtag ) ) || ( len >= 5 && isLowerCaseAlphaNumeric ( subtag ) ) ) { if ( ! isVariant ( subtag ) ) { throw newDatatypeException ( "Bad variant subtag " , subtag , "." ) ; } if ( isDeprecated ( subtag ) && WARN ) { throw newDatatypeException ( "The variant subtag " , subtag , " is deprecated." + " Use “" + preferredValueByLanguageMap . get ( literal ) + "” instead." , WARN ) ; } checkForValidPrefix ( subtag , subtags , i ) ; } else { throw newDatatypeException ( "The subtag " , subtag , " does not match the format for any permissible subtag type." ) ; } i ++ ; if ( i == subtags . length ) { return ; } subtag = subtags [ i ] ; len = subtag . length ( ) ; } } private void checkForValidPrefix ( String subtag , String [ ] subtags , int i ) throws DatatypeException { String variant = subtags [ i ] ; int index = Arrays . binarySearch ( variants , variant ) ; assert index >= 0 ; String [ ] [ ] prefixes = prefixesByVariant [ index ] ; if ( prefixes . length == 0 ) { return ; } List < String > recommendedPrefixes = new ArrayList < String > ( ) ; for ( int j = 0 ; j < prefixes . length ; j ++ ) { String [ ] prefix = prefixes [ j ] ; for ( int k = 0 ; k < prefix . length ; k ++ ) { String prefixComponent = prefix [ k ] ; if ( ! subtagsContainPrefixComponent ( prefixComponent , subtags , i ) ) { recommendedPrefixes . add ( prefixComponent ) ; } } if ( prefixMatches ( prefix , subtags , i ) ) { return ; } } if ( recommendedPrefixes . size ( ) == 0 ) { return ; } int count = recommendedPrefixes . size ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( recommendedPrefixes . size ( ) > 1 ) { sb . append ( " one of " ) ; } for ( String prefix : recommendedPrefixes ) { if ( count != recommendedPrefixes . size ( ) ) { sb . append ( ", " ) ; if ( count == 1 ) { sb . append ( " or " ) ; } } sb . append ( "“" ) ; sb . append ( prefix ) ; sb . append ( '”' ) ; count -- ; } throw newDatatypeException ( "Variant " , subtag , " lacks recommended prefix. Use " + sb + " instead." ) ; } private boolean prefixMatches ( String [ ] prefix , String [ ] subtags , int limit ) { for ( int i = 0 ; i < prefix . length ; i ++ ) { String prefixComponent = prefix [ i ] ; if ( ! subtagsContainPrefixComponent ( prefixComponent , subtags , limit ) ) { return false ; } } return true ; } private boolean subtagsContainPrefixComponent ( String prefixComponent , String [ ] subtags , int limit ) { for ( int i = 0 ; i < limit ; i ++ ) { String subtag = subtags [ i ] ; if ( subtag . equals ( prefixComponent ) ) { return true ; } } return false ; } private boolean usesPrefixByExtlang ( String language , String extlang ) { int langIndex = Arrays . binarySearch ( languages , language ) ; int extlangIndex = Arrays . binarySearch ( extlangs , extlang ) ; assert langIndex > - 1 ; int prefixExpected = prefixByExtlang [ extlangIndex ] ; return prefixExpected == langIndex ; } private boolean shouldSuppressScript ( String language , String script ) { int langIndex = Arrays . binarySearch ( languages , language ) ; assert langIndex > - 1 ; int scriptIndex = suppressedScriptByLanguage [ langIndex ] ; if ( scriptIndex < 0 ) { return false ; } else { return scripts [ scriptIndex ] . equals ( script ) ; } } private boolean isVariant ( String subtag ) { return ( Arrays . binarySearch ( variants , subtag ) > - 1 ) ; } private boolean isRegion ( String subtag ) { return ( Arrays . binarySearch ( regions , subtag ) > - 1 ) || "aa" . equals ( subtag ) || ( "qm" . compareTo ( subtag ) <= 0 && "qz" . compareTo ( subtag ) >= 0 ) || ( "xa" . compareTo ( subtag ) <= 0 && "xz" . compareTo ( subtag ) >= 0 ) || "zz" . equals ( subtag ) ; } private boolean isScript ( String subtag ) { return ( Arrays . binarySearch ( scripts , subtag ) > - 1 ) || ( "qaaa" . compareTo ( subtag ) <= 0 && "qabx" . compareTo ( subtag ) >= 0 ) ; } private boolean isExtlang ( String subtag ) { return ( Arrays . binarySearch ( extlangs , subtag ) > - 1 ) ; } private boolean isLanguage ( String subtag ) { return ( Arrays . binarySearch ( languages , subtag ) > - 1 ) || ( "qaa" . compareTo ( subtag ) <= 0 && "qtz" . compareTo ( subtag ) >= 0 ) ; } private void checkPrivateUse ( int i , String [ ] subtags ) throws DatatypeException { int len = subtags . length ; i ++ ; if ( i == len ) { throw newDatatypeException ( "No subtags in private use sequence." ) ; } while ( i < len ) { String subtag = subtags [ i ] ; if ( subtag . length ( ) < 2 ) { throw newDatatypeException ( "Private use subtag " , subtag , " is too short." ) ; } if ( ! isLowerCaseAlphaNumeric ( subtag ) ) { throw newDatatypeException ( "Bad character in private use subtag " , subtag , "." ) ; } i ++ ; } } private final boolean isLowerCaseAlphaNumeric ( char c ) { return isLowerCaseAlpha ( c ) || isDigit ( c ) ; } private final boolean isLowerCaseAlphaNumeric ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isLowerCaseAlphaNumeric ( str . charAt ( i ) ) ) { return false ; } } return true ; } private final boolean isDigit ( char c ) { return ( c >= '0' && c <= '9' ) ; } private final boolean isDigit ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isDigit ( str . charAt ( i ) ) ) { return false ; } } return true ; } private final boolean isLowerCaseAlpha ( char c ) { return ( c >= 'a' && c <= 'z' ) ; } private final boolean isLowerCaseAlpha ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isLowerCaseAlpha ( str . charAt ( i ) ) ) { return false ; } } return true ; } private boolean isGrandfathered ( String literal ) { return Arrays . binarySearch ( grandfathered , literal ) > - 1 ; } private boolean isRedundant ( String literal ) { return Arrays . binarySearch ( redundant , literal ) > - 1 ; } private boolean isDeprecated ( String subtag ) { return Arrays . binarySearch ( deprecated , subtag ) > - 1 ; } private boolean isDeprecatedLang ( String subtag ) { return Arrays . binarySearch ( deprecatedLang , subtag ) > - 1 ; } @ Override public String getName ( ) { return "language tag" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
