<<<<<<< HEAD
abstract public class JavaAdapter < T > extends ArrayValue implements Serializable { private static final Logger log = Logger . getLogger ( JavaAdapter . class . getName ( ) ) ; private WeakReference < Env > _envRef ; protected T _object ; private JavaClassDef _classDef ; private HashMap < Value , Value > _refs ; protected JavaAdapter ( Env env , T object , JavaClassDef def ) { if ( env != null ) _envRef = new WeakReference < Env > ( env ) ; _object = object ; _classDef = def ; } public JavaClassDef getClassDef ( ) { return _classDef ; } public Env getEnv ( ) { return _envRef . get ( ) ; } public Value wrapJava ( Object obj ) { return _envRef . get ( ) . wrapJava ( obj ) ; } public T toObject ( ) { return null ; } @ Override public Object toJavaObject ( ) { return _object ; } @ SuppressWarnings ( "unchecked" ) @ Override public < TT > TT toJavaObjectNotNull ( Env env , Class < TT > type ) { if ( type . isAssignableFrom ( _object . getClass ( ) ) ) { return ( TT ) _object ; } else { env . warning ( L . l ( "Can't assign {0} to {1}" , _object . getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } } public Value toObject ( Env env ) { Value obj = env . createObject ( ) ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { Value key = entry . getKey ( ) ; if ( key instanceof StringValue ) { obj . putField ( env , key . toString ( ) , entry . getValue ( ) ) ; } } return obj ; } @ SuppressWarnings ( "unchecked" ) @ Override public < TT > Collection < TT > toJavaCollection ( Env env , Class < ? extends Collection < TT > > type ) { Collection < TT > coll = null ; if ( type . isAssignableFrom ( HashSet . class ) ) { coll = new HashSet < TT > ( ) ; } else if ( type . isAssignableFrom ( TreeSet . class ) ) { coll = new TreeSet < TT > ( ) ; } else { try { coll = type . newInstance ( ) ; } catch ( Throwable e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; env . warning ( L . l ( "Can't assign array to {0}" , type . getName ( ) ) ) ; return null ; } } for ( Map . Entry entry : objectEntrySet ( ) ) { coll . add ( ( TT ) entry . getValue ( ) ) ; } return coll ; } @ Override public < TT > List < TT > toJavaList ( Env env , Class < ? extends List < TT > > type ) { List < TT > list = null ; if ( type . isAssignableFrom ( ArrayList . class ) ) { list = new ArrayList < TT > ( ) ; } else if ( type . isAssignableFrom ( LinkedList . class ) ) { list = new LinkedList < TT > ( ) ; } else if ( type . isAssignableFrom ( Vector . class ) ) { list = new Vector < TT > ( ) ; } else { try { list = type . newInstance ( ) ; } catch ( Throwable e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; env . warning ( L . l ( "Can't assign array to {0}" , type . getName ( ) ) ) ; return null ; } } for ( Map . Entry < ? , TT > entry : objectEntrySet ( ) ) { list . add ( entry . getValue ( ) ) ; } return list ; } @ Override public < K , V > Map < K , V > toJavaMap ( Env env , Class < ? extends Map < K , V > > type ) { Map < K , V > map = null ; if ( type . isAssignableFrom ( TreeMap . class ) ) { map = new TreeMap < K , V > ( ) ; } else if ( type . isAssignableFrom ( LinkedHashMap . class ) ) { map = new LinkedHashMap < K , V > ( ) ; } else { try { map = type . newInstance ( ) ; } catch ( Throwable e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; env . warning ( L . l ( "Can't assign array to {0}" , type . getName ( ) ) ) ; return null ; } } for ( Map . Entry < K , V > entry : objectEntrySet ( ) ) { map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return map ; } abstract public Value copy ( ) ; abstract public Value copy ( Env env , IdentityHashMap < Value , Value > map ) ; abstract public int getSize ( ) ; abstract public void clear ( ) ; public final Value put ( Value value ) { return put ( createTailKey ( ) , value ) ; } public final Value put ( Value key , Value value ) { Value retValue = putImpl ( key , value ) ; if ( _refs == null ) _refs = new HashMap < Value , Value > ( ) ; if ( value instanceof Var ) { Var var = ( Var ) value ; var . setReference ( ) ; _refs . put ( key , var ) ; } else { Value ref = _refs . get ( key ) ; if ( ref != null ) ref . set ( value ) ; } return retValue ; } abstract public Value putImpl ( Value key , Value value ) ; public ArrayValue unshift ( Value value ) { throw new UnsupportedOperationException ( ) ; } public ArrayValue splice ( int begin , int end , ArrayValue replace ) { throw new UnsupportedOperationException ( ) ; } @ Override public Value getArg ( Value index , boolean isTop ) { return get ( index ) ; } public Var putRef ( ) { throw new UnsupportedOperationException ( ) ; } abstract public Value createTailKey ( ) ; public Collection < Value > getIndices ( ) { throw new UnsupportedOperationException ( ) ; } abstract public Value get ( Value key ) ; abstract public Value remove ( Value key ) ; public Var getRef ( Value index ) { Var var = new Var ( new JavaAdapterVar ( this , index ) ) ; if ( _refs == null ) _refs = new HashMap < Value , Value > ( ) ; _refs . put ( index , var ) ; return var ; } @ Override public Set < Value > keySet ( ) { return new KeySet ( getEnv ( ) ) ; } abstract public Set < Map . Entry < Value , Value > > entrySet ( ) ; abstract public Set < Map . Entry > objectEntrySet ( ) ; public Collection < Value > values ( ) { throw new UnimplementedException ( ) ; } public ArrayValue append ( Value key , Value value ) { put ( key , value ) ; return this ; } public Value pop ( ) { throw new UnsupportedOperationException ( ) ; } public void shuffle ( ) { throw new UnsupportedOperationException ( ) ; } protected Entry getHead ( ) { throw new UnsupportedOperationException ( ) ; } protected Entry getTail ( ) { throw new UnsupportedOperationException ( ) ; } public Value current ( ) { throw new UnsupportedOperationException ( ) ; } public Value key ( ) { throw new UnsupportedOperationException ( ) ; } public boolean hasCurrent ( ) { throw new UnsupportedOperationException ( ) ; } public Value next ( ) { throw new UnsupportedOperationException ( ) ; } public Value prev ( ) { throw new UnsupportedOperationException ( ) ; } public Value each ( ) { throw new UnsupportedOperationException ( ) ; } public Value reset ( ) { throw new UnsupportedOperationException ( ) ; } public Value end ( ) { throw new UnsupportedOperationException ( ) ; } public Value contains ( Value value ) { for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { if ( entry . getValue ( ) . equals ( value ) ) return entry . getKey ( ) ; } return NullValue . NULL ; } public Value containsStrict ( Value value ) { for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { if ( entry . getValue ( ) . eql ( value ) ) return entry . getKey ( ) ; } return NullValue . NULL ; } public Value containsKey ( Value key ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public Map . Entry < Value , Value > [ ] toEntryArray ( ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( "unchecked" ) public void sort ( Comparator < Map . Entry < Value , Value > > comparator , boolean resetKeys , boolean strict ) { Map . Entry < Value , Value > [ ] entries = ( Map . Entry < Value , Value > [ ] ) new Map . Entry [ getSize ( ) ] ; int i = 0 ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { entries [ i ++ ] = entry ; } Arrays . sort ( entries , comparator ) ; clear ( ) ; long base = 0 ; if ( ! resetKeys ) strict = false ; for ( int j = 0 ; j < entries . length ; j ++ ) { Value key = entries [ j ] . getKey ( ) ; if ( resetKeys && ( ! ( key instanceof StringValue ) || strict ) ) put ( LongValue . create ( base ++ ) , entries [ j ] . getValue ( ) ) ; else put ( entries [ j ] . getKey ( ) , entries [ j ] . getValue ( ) ) ; } } public void serialize ( Env env , StringBuilder sb ) { throw new UnsupportedOperationException ( ) ; } public void varExport ( StringBuilder sb ) { throw new UnsupportedOperationException ( ) ; } public boolean keyReset ( long base , boolean strict ) { throw new UnsupportedOperationException ( ) ; } public Value [ ] valuesToArray ( ) { Value [ ] values = new Value [ getSize ( ) ] ; int i = 0 ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { values [ i ++ ] = entry . getValue ( ) ; } return values ; } @ Override public < TT > TT [ ] valuesToArray ( Env env , Class < TT > elementType ) { int size = getSize ( ) ; TT [ ] array = TT [ ] . class . cast ( Array . newInstance ( elementType , size ) ) ; MarshalFactory factory = env . getModuleContext ( ) . getMarshalFactory ( ) ; Marshal elementMarshal = factory . create ( elementType ) ; int i = 0 ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { Array . set ( array , i ++ , elementMarshal . marshal ( env , entry . getValue ( ) , elementType ) ) ; } return array ; } @ Override public Value getField ( Env env , StringValue name ) { return _classDef . getField ( env , this , name ) ; } @ Override public Value putField ( Env env , StringValue name , Value value ) { return _classDef . putField ( env , this , name , value ) ; } public String getName ( ) { return _classDef . getName ( ) ; } public boolean isA ( String name ) { return _classDef . isA ( name ) ; } public AbstractFunction findFunction ( String methodName ) { return _classDef . findFunction ( methodName ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Expr [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen ) { return _classDef . callMethod ( env , this , hash , name , nameLen ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 , Value a5 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 , a5 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Expr [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen ) { return _classDef . callMethod ( env , this , hash , name , nameLen ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 , Value a5 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 , a5 ) ; } @ Override public void varDumpImpl ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { out . println ( "array(" + getSize ( ) + ") {" ) ; int nestedDepth = depth + 1 ; for ( Map . Entry < Value , Value > mapEntry : entrySet ( ) ) { printDepth ( out , nestedDepth * 2 ) ; out . print ( "[" ) ; Value key = mapEntry . getKey ( ) ; if ( key . isString ( ) ) { out . print ( "\"" ) ; out . print ( key ) ; out . print ( "\"" ) ; } else { out . print ( key ) ; } out . println ( "]=>" ) ; printDepth ( out , nestedDepth * 2 ) ; if ( _refs != null && _refs . get ( key ) != null ) out . print ( '&' ) ; mapEntry . getValue ( ) . varDump ( env , out , nestedDepth , valueSet ) ; out . println ( ) ; } printDepth ( out , 2 * depth ) ; out . print ( "}" ) ; } @ Override protected void printRImpl ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { out . println ( "Array" ) ; printDepth ( out , 8 * depth ) ; out . println ( "(" ) ; for ( Map . Entry < Value , Value > mapEntry : entrySet ( ) ) { printDepth ( out , 8 * depth ) ; out . print ( "    [" ) ; out . print ( mapEntry . getKey ( ) ) ; out . print ( "] => " ) ; Value value = mapEntry . getValue ( ) ; if ( value != null ) value . printR ( env , out , depth + 1 , valueSet ) ; out . println ( ) ; } printDepth ( out , 8 * depth ) ; out . println ( ")" ) ; } private void writeObject ( ObjectOutputStream out ) throws IOException { out . writeObject ( _object ) ; out . writeObject ( _classDef . getName ( ) ) ; } @ SuppressWarnings ( "unchecked" ) private void readObject ( ObjectInputStream in ) throws ClassNotFoundException , IOException { _envRef = new WeakReference < Env > ( Env . getInstance ( ) ) ; _object = ( T ) in . readObject ( ) ; _classDef = getEnv ( ) . getJavaClassDefinition ( ( String ) in . readObject ( ) ) ; } public String toString ( ) { return String . valueOf ( _object ) ; } public class KeySet extends AbstractSet < Value > { Env _env ; KeySet ( Env env ) { _env = env ; } @ Override public int size ( ) { return getSize ( ) ; } @ Override public Iterator < Value > iterator ( ) { return getKeyIterator ( _env ) ; } } } 
=======
class ValidatorImpl extends DefaultHandler implements Validator { static final Name OWNER_NAME = new Name ( "http://purl.oclc.org/dsdl/nvdl/ns/instance/1.0" , "virtualElement" ) ; private static final String NO_NS = "\0" ; private final ErrorHandler eh ; private final PropertyMap properties ; private final List triggers ; private Locator locator ; private Section currentSection ; private PrefixMapping prefixMapping = null ; private final Hashtable validatorHandlerCache = new Hashtable ( ) ; private final Localizer localizer = new Localizer ( ValidatorImpl . class ) ; private final Hashset noResultActions = new Hashset ( ) ; private final Hashtable attributeNamespaceIndexSets = new Hashtable ( ) ; private final Vector activeHandlersAttributeIndexSets = new Vector ( ) ; private final Hashset attributeSchemas = new Hashset ( ) ; private boolean attributeNamespaceRejected ; private Attributes filteredAttributes ; private final Mode startMode ; private final Stack elementsLocalNameStack ; static private class PrefixMapping { final String prefix ; final String uri ; final PrefixMapping parent ; PrefixMapping ( String prefix , String uri , PrefixMapping parent ) { this . prefix = prefix ; this . uri = uri ; this . parent = parent ; } } private class Section implements SectionState { final Section parent ; final String ns ; int depth = 0 ; final Vector validators = new Vector ( ) ; final Vector schemas = new Vector ( ) ; final Vector activeHandlers = new Vector ( ) ; final Vector activeHandlersAttributeModeUsage = new Vector ( ) ; final Vector attributeValidationModeUsages = new Vector ( ) ; final Vector childPrograms = new Vector ( ) ; final Stack context = new Stack ( ) ; boolean contextDependent = false ; int attributeProcessing = Mode . ATTRIBUTE_PROCESSING_NONE ; final Vector placeholderHandlers = new Vector ( ) ; final Vector placeholderModeUsages = new Vector ( ) ; Section ( String ns , Section parent ) { this . ns = ns ; this . parent = parent ; } public void addChildMode ( ModeUsage modeUsage , ContentHandler handler ) { childPrograms . addElement ( new Program ( modeUsage , handler ) ) ; if ( modeUsage . isContextDependent ( ) ) contextDependent = true ; } public void addValidator ( Schema schema , ModeUsage modeUsage ) { schemas . addElement ( schema ) ; Validator validator = createValidator ( schema ) ; validators . addElement ( validator ) ; activeHandlers . addElement ( validator . getContentHandler ( ) ) ; activeHandlersAttributeModeUsage . addElement ( modeUsage ) ; attributeProcessing = Math . max ( attributeProcessing , modeUsage . getAttributeProcessing ( ) ) ; childPrograms . addElement ( new Program ( modeUsage , validator . getContentHandler ( ) ) ) ; if ( modeUsage . isContextDependent ( ) ) contextDependent = true ; } public void addActiveHandler ( ContentHandler handler , ModeUsage attributeModeUsage ) { activeHandlers . addElement ( handler ) ; activeHandlersAttributeModeUsage . addElement ( attributeModeUsage ) ; attributeProcessing = Math . max ( attributeProcessing , attributeModeUsage . getAttributeProcessing ( ) ) ; if ( attributeModeUsage . isContextDependent ( ) ) contextDependent = true ; } public void addAttributeValidationModeUsage ( ModeUsage modeUsage ) { int ap = modeUsage . getAttributeProcessing ( ) ; if ( ap != Mode . ATTRIBUTE_PROCESSING_NONE ) { attributeValidationModeUsages . addElement ( modeUsage ) ; attributeProcessing = Math . max ( ap , attributeProcessing ) ; if ( modeUsage . isContextDependent ( ) ) contextDependent = true ; } } public void reject ( ) throws SAXException { if ( eh != null ) eh . error ( new SAXParseException ( localizer . message ( "reject_element" , ns ) , locator ) ) ; } public void attachPlaceholder ( ModeUsage modeUsage , ContentHandler handler ) { placeholderHandlers . add ( handler ) ; placeholderModeUsages . add ( modeUsage ) ; } } static private class Program { final ModeUsage modeUsage ; final ContentHandler handler ; Program ( ModeUsage modeUsage , ContentHandler handler ) { this . modeUsage = modeUsage ; this . handler = handler ; } } ValidatorImpl ( Mode mode , List triggers , PropertyMap properties ) { this . properties = properties ; this . triggers = triggers ; this . eh = properties . get ( ValidateProperty . ERROR_HANDLER ) ; this . startMode = mode ; this . elementsLocalNameStack = new Stack ( ) ; initCurrentSection ( ) ; } private void initCurrentSection ( ) { currentSection = new Section ( NO_NS , null ) ; currentSection . addChildMode ( new ModeUsage ( startMode , startMode ) , null ) ; } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) ( ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ) . characters ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) ( ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ) . ignorableWhitespace ( ch , start , length ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( ! uri . equals ( currentSection . ns ) || trigger ( uri , localName , ( String ) elementsLocalNameStack . peek ( ) ) ) startSection ( uri ) ; elementsLocalNameStack . push ( localName ) ; currentSection . depth ++ ; if ( currentSection . contextDependent ) currentSection . context . push ( localName ) ; boolean transformAttributes = processAttributes ( attributes ) ; for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) { ContentHandler handler = ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ; handler . startElement ( uri , localName , qName , transformAttributes ? filterAttributes ( ( IntSet ) activeHandlersAttributeIndexSets . elementAt ( i ) , attributes ) : attributes ) ; } if ( currentSection . depth == 1 && currentSection . placeholderHandlers . size ( ) > 0 ) { AttributesImpl atts = new AttributesImpl ( ) ; atts . addAttribute ( "" , "ns" , "ns" , "" , uri ) ; atts . addAttribute ( "" , "localName" , "localName" , "" , localName ) ; for ( int i = 0 , len = currentSection . placeholderHandlers . size ( ) ; i < len ; i ++ ) { ContentHandler handler = ( ContentHandler ) ( currentSection . placeholderHandlers . elementAt ( i ) ) ; handler . startPrefixMapping ( "" , "http://purl.oclc.org/dsdl/nvdl/ns/instance/1.0" ) ; handler . startElement ( "http://purl.oclc.org/dsdl/nvdl/ns/instance/1.0" , "placeholder" , "placeholder" , atts ) ; } } } private boolean trigger ( String namespace , String name , String parent ) { Iterator i = triggers . iterator ( ) ; while ( i . hasNext ( ) ) { Trigger t = ( Trigger ) i . next ( ) ; if ( ( t . namespace . equals ( namespace ) && t . elementNames . contains ( name ) && ! t . elementNames . contains ( parent ) ) ) { return true ; } } return false ; } private static Attributes filterAttributes ( IntSet indexSet , Attributes attributes ) { if ( indexSet . size ( ) == attributes . getLength ( ) ) return attributes ; return new FilteredAttributes ( indexSet , attributes ) ; } private boolean processAttributes ( Attributes attributes ) throws SAXException { if ( currentSection . attributeProcessing == Mode . ATTRIBUTE_PROCESSING_NONE || attributes . getLength ( ) == 0 ) return false ; attributeNamespaceIndexSets . clear ( ) ; for ( int i = 0 , len = attributes . getLength ( ) ; i < len ; i ++ ) { String ns = attributes . getURI ( i ) ; IntSet indexSet = ( IntSet ) attributeNamespaceIndexSets . get ( ns ) ; if ( indexSet == null ) { indexSet = new IntSet ( ) ; attributeNamespaceIndexSets . put ( ns , indexSet ) ; } indexSet . add ( i ) ; } if ( currentSection . attributeProcessing == Mode . ATTRIBUTE_PROCESSING_QUALIFIED && attributeNamespaceIndexSets . size ( ) == 1 && attributeNamespaceIndexSets . get ( "" ) != null ) return false ; Vector handlerModes = currentSection . activeHandlersAttributeModeUsage ; activeHandlersAttributeIndexSets . setSize ( handlerModes . size ( ) ) ; for ( int i = 0 , len = handlerModes . size ( ) ; i < len ; i ++ ) activeHandlersAttributeIndexSets . setElementAt ( new IntSet ( ) , i ) ; boolean transform = false ; Vector validationModes = currentSection . attributeValidationModeUsages ; for ( Enumeration e = attributeNamespaceIndexSets . keys ( ) ; e . hasMoreElements ( ) ; ) { String ns = ( String ) e . nextElement ( ) ; IntSet indexSet = ( IntSet ) attributeNamespaceIndexSets . get ( ns ) ; attributeSchemas . clear ( ) ; filteredAttributes = null ; attributeNamespaceRejected = false ; for ( int i = 0 , len = handlerModes . size ( ) ; i < len ; i ++ ) { ModeUsage modeUsage = ( ModeUsage ) handlerModes . elementAt ( i ) ; AttributeActionSet actions = processAttributeSection ( modeUsage , ns , indexSet , attributes ) ; if ( actions . getAttach ( ) ) ( ( IntSet ) activeHandlersAttributeIndexSets . get ( i ) ) . addAll ( indexSet ) ; else transform = true ; } for ( int i = 0 , len = validationModes . size ( ) ; i < len ; i ++ ) { ModeUsage modeUsage = ( ModeUsage ) validationModes . elementAt ( i ) ; processAttributeSection ( modeUsage , ns , indexSet , attributes ) ; } } return transform ; } private AttributeActionSet processAttributeSection ( ModeUsage modeUsage , String ns , IntSet indexSet , Attributes attributes ) throws SAXException { Mode mode = modeUsage . getMode ( currentSection . context ) ; AttributeActionSet actions = mode . getAttributeActions ( ns ) ; if ( actions . getReject ( ) && ! attributeNamespaceRejected ) { attributeNamespaceRejected = true ; if ( eh != null ) eh . error ( new SAXParseException ( localizer . message ( "reject_attribute" , ns ) , locator ) ) ; } Schema [ ] schemas = actions . getSchemas ( ) ; for ( int j = 0 ; j < schemas . length ; j ++ ) { if ( attributeSchemas . contains ( schemas [ j ] ) ) continue ; attributeSchemas . add ( schemas [ j ] ) ; if ( filteredAttributes == null ) filteredAttributes = filterAttributes ( indexSet , attributes ) ; validateAttributes ( schemas [ j ] , filteredAttributes ) ; } return actions ; } private void validateAttributes ( Schema schema , Attributes attributes ) throws SAXException { Validator validator = createValidator ( schema ) ; ContentHandler ch = validator . getContentHandler ( ) ; initHandler ( ch ) ; ch . startElement ( OWNER_NAME . getNamespaceUri ( ) , OWNER_NAME . getLocalName ( ) , OWNER_NAME . getLocalName ( ) , attributes ) ; ch . endElement ( OWNER_NAME . getNamespaceUri ( ) , OWNER_NAME . getLocalName ( ) , OWNER_NAME . getLocalName ( ) ) ; cleanupHandler ( ch ) ; releaseValidator ( schema , validator ) ; } private void startSection ( String uri ) throws SAXException { Section section = new Section ( uri , currentSection ) ; Vector childPrograms = currentSection . childPrograms ; noResultActions . clear ( ) ; for ( int i = 0 , len = childPrograms . size ( ) ; i < len ; i ++ ) { Program program = ( Program ) childPrograms . elementAt ( i ) ; ActionSet actions = program . modeUsage . getMode ( currentSection . context ) . getElementActions ( uri ) ; ResultAction resultAction = actions . getResultAction ( ) ; if ( resultAction != null ) resultAction . perform ( program . handler , section ) ; NoResultAction [ ] nra = actions . getNoResultActions ( ) ; for ( int j = 0 ; j < nra . length ; j ++ ) { NoResultAction tem = nra [ j ] ; if ( ! noResultActions . contains ( tem ) ) { nra [ j ] . perform ( section ) ; noResultActions . add ( tem ) ; } } } for ( int i = 0 , len = section . validators . size ( ) ; i < len ; i ++ ) initHandler ( ( ( Validator ) section . validators . elementAt ( i ) ) . getContentHandler ( ) ) ; currentSection = section ; } private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { elementsLocalNameStack . pop ( ) ; for ( int i = 0 , len = currentSection . activeHandlers . size ( ) ; i < len ; i ++ ) ( ( ContentHandler ) ( currentSection . activeHandlers . elementAt ( i ) ) ) . endElement ( uri , localName , qName ) ; currentSection . depth -- ; if ( currentSection . contextDependent ) currentSection . context . pop ( ) ; if ( currentSection . depth == 0 ) { for ( int i = 0 , len = currentSection . placeholderHandlers . size ( ) ; i < len ; i ++ ) { ContentHandler handler = ( ContentHandler ) ( currentSection . placeholderHandlers . elementAt ( i ) ) ; handler . endPrefixMapping ( "" ) ; handler . endElement ( "http://purl.oclc.org/dsdl/nvdl/ns/instance/1.0" , "placeholder" , "placeholder" ) ; } endSection ( ) ; } } private void endSection ( ) throws SAXException { for ( int i = 0 , len = currentSection . validators . size ( ) ; i < len ; i ++ ) { Validator validator = ( Validator ) currentSection . validators . elementAt ( i ) ; cleanupHandler ( validator . getContentHandler ( ) ) ; releaseValidator ( ( Schema ) currentSection . schemas . elementAt ( i ) , validator ) ; currentSection . validators . setElementAt ( null , i ) ; } currentSection = currentSection . parent ; } private void cleanupHandler ( ContentHandler vh ) throws SAXException { for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) vh . endPrefixMapping ( pm . prefix ) ; vh . endDocument ( ) ; } public void endDocument ( ) throws SAXException { } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { super . startPrefixMapping ( prefix , uri ) ; prefixMapping = new PrefixMapping ( prefix , uri , prefixMapping ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { super . endPrefixMapping ( prefix ) ; prefixMapping = prefixMapping . parent ; } private Validator createValidator ( Schema schema ) { Stack stack = ( Stack ) validatorHandlerCache . get ( schema ) ; if ( stack == null ) { stack = new Stack ( ) ; validatorHandlerCache . put ( schema , stack ) ; } if ( stack . empty ( ) ) return schema . createValidator ( properties ) ; return ( Validator ) stack . pop ( ) ; } private void releaseValidator ( Schema schema , Validator vh ) { if ( vh == null ) return ; vh . reset ( ) ; ( ( Stack ) validatorHandlerCache . get ( schema ) ) . push ( vh ) ; } public void reset ( ) { for ( ; currentSection != null ; currentSection = currentSection . parent ) { for ( int i = 0 , len = currentSection . validators . size ( ) ; i < len ; i ++ ) releaseValidator ( ( Schema ) currentSection . schemas . elementAt ( i ) , ( Validator ) currentSection . validators . elementAt ( i ) ) ; } initCurrentSection ( ) ; } public ContentHandler getContentHandler ( ) { return this ; } public DTDHandler getDTDHandler ( ) { return this ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
