abstract public class JavaAdapter < T > extends ArrayValue implements Serializable { private static final Logger log = Logger . getLogger ( JavaAdapter . class . getName ( ) ) ; private WeakReference < Env > _envRef ; protected T _object ; private JavaClassDef _classDef ; private HashMap < Value , Value > _refs ; protected JavaAdapter ( Env env , T object , JavaClassDef def ) { if ( env != null ) _envRef = new WeakReference < Env > ( env ) ; _object = object ; _classDef = def ; } public JavaClassDef getClassDef ( ) { return _classDef ; } public Env getEnv ( ) { return _envRef . get ( ) ; } public Value wrapJava ( Object obj ) { return _envRef . get ( ) . wrapJava ( obj ) ; } public T toObject ( ) { return null ; } @ Override public Object toJavaObject ( ) { return _object ; } @ SuppressWarnings ( "unchecked" ) @ Override public < TT > TT toJavaObjectNotNull ( Env env , Class < TT > type ) { if ( type . isAssignableFrom ( _object . getClass ( ) ) ) { return ( TT ) _object ; } else { env . warning ( L . l ( "Can't assign {0} to {1}" , _object . getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } } public Value toObject ( Env env ) { Value obj = env . createObject ( ) ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { Value key = entry . getKey ( ) ; if ( key instanceof StringValue ) { obj . putField ( env , key . toString ( ) , entry . getValue ( ) ) ; } } return obj ; } @ SuppressWarnings ( "unchecked" ) @ Override public < TT > Collection < TT > toJavaCollection ( Env env , Class < ? extends Collection < TT > > type ) { Collection < TT > coll = null ; if ( type . isAssignableFrom ( HashSet . class ) ) { coll = new HashSet < TT > ( ) ; } else if ( type . isAssignableFrom ( TreeSet . class ) ) { coll = new TreeSet < TT > ( ) ; } else { try { coll = type . newInstance ( ) ; } catch ( Throwable e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; env . warning ( L . l ( "Can't assign array to {0}" , type . getName ( ) ) ) ; return null ; } } for ( Map . Entry entry : objectEntrySet ( ) ) { coll . add ( ( TT ) entry . getValue ( ) ) ; } return coll ; } @ Override public < TT > List < TT > toJavaList ( Env env , Class < ? extends List < TT > > type ) { List < TT > list = null ; if ( type . isAssignableFrom ( ArrayList . class ) ) { list = new ArrayList < TT > ( ) ; } else if ( type . isAssignableFrom ( LinkedList . class ) ) { list = new LinkedList < TT > ( ) ; } else if ( type . isAssignableFrom ( Vector . class ) ) { list = new Vector < TT > ( ) ; } else { try { list = type . newInstance ( ) ; } catch ( Throwable e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; env . warning ( L . l ( "Can't assign array to {0}" , type . getName ( ) ) ) ; return null ; } } for ( Map . Entry < ? , TT > entry : objectEntrySet ( ) ) { list . add ( entry . getValue ( ) ) ; } return list ; } @ Override public < K , V > Map < K , V > toJavaMap ( Env env , Class < ? extends Map < K , V > > type ) { Map < K , V > map = null ; if ( type . isAssignableFrom ( TreeMap . class ) ) { map = new TreeMap < K , V > ( ) ; } else if ( type . isAssignableFrom ( LinkedHashMap . class ) ) { map = new LinkedHashMap < K , V > ( ) ; } else { try { map = type . newInstance ( ) ; } catch ( Throwable e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; env . warning ( L . l ( "Can't assign array to {0}" , type . getName ( ) ) ) ; return null ; } } for ( Map . Entry < K , V > entry : objectEntrySet ( ) ) { map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return map ; } abstract public Value copy ( ) ; abstract public Value copy ( Env env , IdentityHashMap < Value , Value > map ) ; abstract public int getSize ( ) ; abstract public void clear ( ) ; public final Value put ( Value value ) { return put ( createTailKey ( ) , value ) ; } public final Value put ( Value key , Value value ) { Value retValue = putImpl ( key , value ) ; if ( _refs == null ) _refs = new HashMap < Value , Value > ( ) ; if ( value instanceof Var ) { Var var = ( Var ) value ; var . setReference ( ) ; _refs . put ( key , var ) ; } else { Value ref = _refs . get ( key ) ; if ( ref != null ) ref . set ( value ) ; } return retValue ; } abstract public Value putImpl ( Value key , Value value ) ; public ArrayValue unshift ( Value value ) { throw new UnsupportedOperationException ( ) ; } public ArrayValue splice ( int begin , int end , ArrayValue replace ) { throw new UnsupportedOperationException ( ) ; } @ Override public Value getArg ( Value index , boolean isTop ) { return get ( index ) ; } public Var putRef ( ) { throw new UnsupportedOperationException ( ) ; } abstract public Value createTailKey ( ) ; public Collection < Value > getIndices ( ) { throw new UnsupportedOperationException ( ) ; } abstract public Value get ( Value key ) ; abstract public Value remove ( Value key ) ; public Var getRef ( Value index ) { Var var = new Var ( new JavaAdapterVar ( this , index ) ) ; if ( _refs == null ) _refs = new HashMap < Value , Value > ( ) ; _refs . put ( index , var ) ; return var ; } @ Override public Set < Value > keySet ( ) { return new KeySet ( getEnv ( ) ) ; } abstract public Set < Map . Entry < Value , Value > > entrySet ( ) ; abstract public Set < Map . Entry > objectEntrySet ( ) ; public Collection < Value > values ( ) { throw new UnimplementedException ( ) ; } public ArrayValue append ( Value key , Value value ) { put ( key , value ) ; return this ; } public Value pop ( ) { throw new UnsupportedOperationException ( ) ; } public void shuffle ( ) { throw new UnsupportedOperationException ( ) ; } protected Entry getHead ( ) { throw new UnsupportedOperationException ( ) ; } protected Entry getTail ( ) { throw new UnsupportedOperationException ( ) ; } public Value current ( ) { throw new UnsupportedOperationException ( ) ; } public Value key ( ) { throw new UnsupportedOperationException ( ) ; } public boolean hasCurrent ( ) { throw new UnsupportedOperationException ( ) ; } public Value next ( ) { throw new UnsupportedOperationException ( ) ; } public Value prev ( ) { throw new UnsupportedOperationException ( ) ; } public Value each ( ) { throw new UnsupportedOperationException ( ) ; } public Value reset ( ) { throw new UnsupportedOperationException ( ) ; } public Value end ( ) { throw new UnsupportedOperationException ( ) ; } public Value contains ( Value value ) { for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { if ( entry . getValue ( ) . equals ( value ) ) return entry . getKey ( ) ; } return NullValue . NULL ; } public Value containsStrict ( Value value ) { for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { if ( entry . getValue ( ) . eql ( value ) ) return entry . getKey ( ) ; } return NullValue . NULL ; } public Value containsKey ( Value key ) { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) ) ; } public Map . Entry < Value , Value > [ ] toEntryArray ( ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( "unchecked" ) public void sort ( Comparator < Map . Entry < Value , Value > > comparator , boolean resetKeys , boolean strict ) { Map . Entry < Value , Value > [ ] entries = ( Map . Entry < Value , Value > [ ] ) new Map . Entry [ getSize ( ) ] ; int i = 0 ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { entries [ i ++ ] = entry ; } Arrays . sort ( entries , comparator ) ; clear ( ) ; long base = 0 ; if ( ! resetKeys ) strict = false ; for ( int j = 0 ; j < entries . length ; j ++ ) { Value key = entries [ j ] . getKey ( ) ; if ( resetKeys && ( ! ( key instanceof StringValue ) || strict ) ) put ( LongValue . create ( base ++ ) , entries [ j ] . getValue ( ) ) ; else put ( entries [ j ] . getKey ( ) , entries [ j ] . getValue ( ) ) ; } } public void serialize ( Env env , StringBuilder sb ) { throw new UnsupportedOperationException ( ) ; } public void varExport ( StringBuilder sb ) { throw new UnsupportedOperationException ( ) ; } public boolean keyReset ( long base , boolean strict ) { throw new UnsupportedOperationException ( ) ; } public Value [ ] valuesToArray ( ) { Value [ ] values = new Value [ getSize ( ) ] ; int i = 0 ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { values [ i ++ ] = entry . getValue ( ) ; } return values ; } @ Override public < TT > TT [ ] valuesToArray ( Env env , Class < TT > elementType ) { int size = getSize ( ) ; TT [ ] array = TT [ ] . class . cast ( Array . newInstance ( elementType , size ) ) ; MarshalFactory factory = env . getModuleContext ( ) . getMarshalFactory ( ) ; Marshal elementMarshal = factory . create ( elementType ) ; int i = 0 ; for ( Map . Entry < Value , Value > entry : entrySet ( ) ) { Array . set ( array , i ++ , elementMarshal . marshal ( env , entry . getValue ( ) , elementType ) ) ; } return array ; } @ Override public Value getField ( Env env , StringValue name ) { return _classDef . getField ( env , this , name ) ; } @ Override public Value putField ( Env env , StringValue name , Value value ) { return _classDef . putField ( env , this , name , value ) ; } public String getName ( ) { return _classDef . getName ( ) ; } public boolean isA ( String name ) { return _classDef . isA ( name ) ; } public AbstractFunction findFunction ( String methodName ) { return _classDef . findFunction ( methodName ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Expr [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen ) { return _classDef . callMethod ( env , this , hash , name , nameLen ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 ) ; } @ Override public Value callMethod ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 , Value a5 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 , a5 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Expr [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value [ ] args ) { return _classDef . callMethod ( env , this , hash , name , nameLen , args ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen ) { return _classDef . callMethod ( env , this , hash , name , nameLen ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 ) ; } @ Override public Value callMethodRef ( Env env , int hash , char [ ] name , int nameLen , Value a1 , Value a2 , Value a3 , Value a4 , Value a5 ) { return _classDef . callMethod ( env , this , hash , name , nameLen , a1 , a2 , a3 , a4 , a5 ) ; } @ Override public void varDumpImpl ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { out . println ( "array(" + getSize ( ) + ") {" ) ; int nestedDepth = depth + 1 ; for ( Map . Entry < Value , Value > mapEntry : entrySet ( ) ) { printDepth ( out , nestedDepth * 2 ) ; out . print ( "[" ) ; Value key = mapEntry . getKey ( ) ; if ( key . isString ( ) ) { out . print ( "\"" ) ; out . print ( key ) ; out . print ( "\"" ) ; } else { out . print ( key ) ; } out . println ( "]=>" ) ; printDepth ( out , nestedDepth * 2 ) ; if ( _refs != null && _refs . get ( key ) != null ) out . print ( '&' ) ; mapEntry . getValue ( ) . varDump ( env , out , nestedDepth , valueSet ) ; out . println ( ) ; } printDepth ( out , 2 * depth ) ; out . print ( "}" ) ; } @ Override protected void printRImpl ( Env env , WriteStream out , int depth , IdentityHashMap < Value , String > valueSet ) throws IOException { out . println ( "Array" ) ; printDepth ( out , 8 * depth ) ; out . println ( "(" ) ; for ( Map . Entry < Value , Value > mapEntry : entrySet ( ) ) { printDepth ( out , 8 * depth ) ; out . print ( "    [" ) ; out . print ( mapEntry . getKey ( ) ) ; out . print ( "] => " ) ; Value value = mapEntry . getValue ( ) ; if ( value != null ) value . printR ( env , out , depth + 1 , valueSet ) ; out . println ( ) ; } printDepth ( out , 8 * depth ) ; out . println ( ")" ) ; } private void writeObject ( ObjectOutputStream out ) throws IOException { out . writeObject ( _object ) ; out . writeObject ( _classDef . getName ( ) ) ; } @ SuppressWarnings ( "unchecked" ) private void readObject ( ObjectInputStream in ) throws ClassNotFoundException , IOException { _envRef = new WeakReference < Env > ( Env . getInstance ( ) ) ; _object = ( T ) in . readObject ( ) ; _classDef = getEnv ( ) . getJavaClassDefinition ( ( String ) in . readObject ( ) ) ; } public String toString ( ) { return String . valueOf ( _object ) ; } public class KeySet extends AbstractSet < Value > { Env _env ; KeySet ( Env env ) { _env = env ; } @ Override public int size ( ) { return getSize ( ) ; } @ Override public Iterator < Value > iterator ( ) { return getKeyIterator ( _env ) ; } } } 