<<<<<<< HEAD
public abstract class JSParserBase extends UnifiedParser { private static final String NESTED_LANGUAGE_ID = "nested_languages" ; private static final String DOCUMENTATION_DELIMITER_GROUP = "documentation-delimiter" ; private static final String LINE_DELIMITER_GROUP = "line-delimiter" ; private static final String DEFAULT_GROUP = "default" ; protected IParseNode _currentParentNode ; protected JSLanguageRegistry _languageRegistry ; protected String _piLanguage ; private boolean _fastScan ; public JSParserBase ( ) throws ParserInitializationException { this ( JSMimeType . MimeType ) ; } public JSParserBase ( String language ) throws ParserInitializationException { super ( language ) ; this . _fastScan = UnifiedEditorsPlugin . getDefault ( ) . useFastScan ( ) ; } protected void addChildParsers ( ) throws ParserInitializationException { super . addChildParsers ( ) ; if ( this . _languageRegistry == null ) { this . _languageRegistry = new JSLanguageRegistry ( ) ; IExtensionRegistry registry = Platform . getExtensionRegistry ( ) ; if ( registry != null ) { IExtensionPoint extensionPoint = registry . getExtensionPoint ( JSPlugin . ID , NESTED_LANGUAGE_ID ) ; IExtension [ ] extensions = extensionPoint . getExtensions ( ) ; for ( IExtension extension : extensions ) { IParser [ ] parsers ; if ( this . isScanner ( ) ) { parsers = this . _languageRegistry . loadScannersFromExtension ( extension ) ; } else { parsers = this . _languageRegistry . loadParsersFromExtension ( extension ) ; } for ( IParser parser : parsers ) { this . addChildParser ( parser ) ; } } } } } protected void advance ( ) throws LexerException { ILexer lexer = this . getLexer ( ) ; Lexeme currentLexeme = EOS ; if ( this . _currentParentNode != null && this . currentLexeme != null && this . currentLexeme != EOS ) { this . _currentParentNode . includeLexemeInRange ( this . currentLexeme ) ; } if ( lexer . isEOS ( ) == false ) { boolean inWhitespace = true ; boolean lastWasEOL = false ; while ( inWhitespace ) { if ( lexer . isEOS ( ) == false ) { currentLexeme = this . getNextLexemeInLanguage ( ) ; if ( currentLexeme != null && currentLexeme != EOS ) { if ( currentLexeme . typeIndex != JSTokenTypes . LINE_TERMINATOR ) { this . addLexeme ( currentLexeme ) ; } if ( currentLexeme . getCategoryIndex ( ) == TokenCategories . WHITESPACE ) { if ( currentLexeme . typeIndex == JSTokenTypes . CDC || currentLexeme . typeIndex == JSTokenTypes . CDO ) { GenericCommentNode node = new GenericCommentNode ( currentLexeme . getStartingOffset ( ) , currentLexeme . getEndingOffset ( ) , "HTMLCOMMENT" , JSMimeType . MimeType ) ; this . getParseState ( ) . addCommentRegion ( node ) ; } lastWasEOL = ( currentLexeme . typeIndex == JSTokenTypes . LINE_TERMINATOR ) ; } else { inWhitespace = false ; if ( lastWasEOL ) { currentLexeme . setAfterEOL ( ) ; } } } else { currentLexeme = EOS ; inWhitespace = false ; } } else { currentLexeme = EOS ; inWhitespace = false ; } } } this . currentLexeme = currentLexeme ; } private Lexeme checkForLanguageTransition ( Lexeme lexeme ) throws LexerException { Lexeme result = lexeme ; if ( lexeme != null && lexeme != EOS ) { String terminator = null ; String mimeType = null ; switch ( lexeme . typeIndex ) { case JSTokenTypes . PI_OPEN : this . onPIOpen ( ) ; this . advance ( ) ; break ; case JSTokenTypes . PI_CLOSE : this . advance ( ) ; break ; case JSTokenTypes . START_DOCUMENTATION : terminator = DOCUMENTATION_DELIMITER_GROUP ; mimeType = ScriptDocMimeType . MimeType ; break ; case JSTokenTypes . START_MULTILINE_COMMENT : terminator = DOCUMENTATION_DELIMITER_GROUP ; mimeType = JSCommentMimeType . MimeType ; break ; case JSTokenTypes . COMMENT : terminator = LINE_DELIMITER_GROUP ; mimeType = JSCommentMimeType . MimeType ; break ; default : break ; } if ( terminator != null && mimeType != null ) { ILexer lexer = this . getLexer ( ) ; lexer . setCurrentOffset ( lexeme . offset ) ; Range range = lexer . find ( terminator ) ; int offset = ( lexeme . typeIndex == JSTokenTypes . COMMENT ) ? range . getStartingOffset ( ) : range . getEndingOffset ( ) ; if ( range . isEmpty ( ) ) { offset = lexer . getSourceLength ( ) ; } try { this . changeLanguage ( mimeType , offset , this . _currentParentNode ) ; } catch ( LexerException e ) { } catch ( ParseException e ) { } this . advance ( ) ; result = this . currentLexeme ; } } return result ; } public IParseState createParseState ( IParseState parent ) { IParseState result ; IParseState root = parent ; if ( parent == null ) { result = new JSParseState ( ) ; root = result . getRoot ( ) ; } else { result = new JSParseState ( root ) ; } IParser jsCommentParser = this . getParserForMimeType ( JSCommentMimeType . MimeType ) ; IParser scriptDocParser = this . getParserForMimeType ( ScriptDocMimeType . MimeType ) ; if ( jsCommentParser != null ) { result . addChildState ( jsCommentParser . createParseState ( root ) ) ; } if ( scriptDocParser != null ) { result . addChildState ( scriptDocParser . createParseState ( root ) ) ; } return result ; } protected Lexeme getNextLexemeInLanguage ( ) throws LexerException { if ( this . _fastScan == false ) { Lexeme result = super . getNextLexemeInLanguage ( ) ; result = this . checkForLanguageTransition ( result ) ; return result ; } ILexer lexer = this . getLexer ( ) ; Lexeme result = null ; while ( result == null && lexer . isEOS ( ) == false ) { result = lexer . getNextLexeme ( ) ; if ( result != null && result != EOS ) { String terminator = null ; String mimeType = null ; String text = result . getText ( ) ; int textLength = text . length ( ) ; int offset = 0 ; if ( textLength >= 2 ) { char [ ] source ; int eof ; switch ( text . charAt ( 0 ) ) { case '/' : switch ( text . charAt ( 1 ) ) { case '*' : if ( textLength == 3 && text . charAt ( 2 ) == '*' ) { terminator = DOCUMENTATION_DELIMITER_GROUP ; mimeType = ScriptDocMimeType . MimeType ; } else { terminator = DOCUMENTATION_DELIMITER_GROUP ; mimeType = JSCommentMimeType . MimeType ; } source = lexer . getSourceUnsafe ( ) ; eof = lexer . getEOFOffset ( ) ; for ( offset = result . getEndingOffset ( ) ; offset < eof ; offset ++ ) { if ( source [ offset ] == '*' ) { if ( offset + 1 < eof && source [ offset + 1 ] == '/' ) { offset += 2 ; break ; } } } break ; case '/' : terminator = LINE_DELIMITER_GROUP ; mimeType = JSCommentMimeType . MimeType ; source = lexer . getSourceUnsafe ( ) ; eof = lexer . getEOFOffset ( ) ; for ( offset = result . getEndingOffset ( ) ; offset < eof ; offset ++ ) { char current = source [ offset ] ; if ( current == '\r' || current == '\n' ) { break ; } } break ; } break ; case '<' : if ( text . charAt ( 1 ) == '?' ) { this . onPIOpen ( ) ; this . advance ( ) ; } break ; case '?' : if ( text . charAt ( 1 ) == '>' ) { this . advance ( ) ; } break ; } } if ( terminator != null && mimeType != null ) { lexer . setCurrentOffset ( result . offset ) ; try { this . changeLanguage ( mimeType , offset , this . _currentParentNode ) ; } catch ( LexerException e ) { } catch ( ParseException e ) { } this . advance ( ) ; result = this . currentLexeme ; } else if ( result . getLanguage ( ) . equals ( this . getLanguage ( ) ) == false ) { LexemeList lexemes = this . getLexemeList ( ) ; lexemes . getAffectedRegion ( ) . includeInRange ( result ) ; this . removeLexeme ( result ) ; lexer . setCurrentOffset ( result . offset ) ; result = lexer . getNextLexeme ( ) ; } } if ( result == null && lexer . isEOS ( ) == false ) { if ( "error" . equals ( lexer . getGroup ( ) ) ) { break ; } lexer . setGroup ( "error" ) ; result = lexer . getNextLexeme ( ) ; if ( result == null && "error" . equals ( lexer . getGroup ( ) ) ) { break ; } } } return result ; } public void initializeLexer ( ) throws LexerException { ILexer lexer = this . getLexer ( ) ; String language = this . getLanguage ( ) ; lexer . setIgnoreSet ( language , new int [ ] { JSTokenTypes . WHITESPACE } ) ; lexer . setLanguageAndGroup ( language , DEFAULT_GROUP ) ; } public boolean isScanner ( ) { return false ; } protected void onPIOpen ( ) { try { if ( this . _piLanguage != null ) { this . changeLanguage ( this . _piLanguage , Integer . MAX_VALUE , this . _currentParentNode ) ; } } catch ( LexerException e ) { IdeLog . logError ( JSPlugin . getDefault ( ) , "Lexing exception" , e ) ; } catch ( ParseException e ) { IdeLog . logError ( JSPlugin . getDefault ( ) , "Parsing exception" , e ) ; } } } 
=======
public class HashName extends AbstractDatatype { public static final HashName THE_INSTANCE = new HashName ( ) ; private HashName ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { if ( literal . length ( ) == 0 ) { throw newDatatypeException ( "The empty string is not a valid hash-name reference." ) ; } else if ( literal . charAt ( 0 ) != '#' ) { throw newDatatypeException ( "A hash-name reference must start with “#”." ) ; } else if ( literal . length ( ) == 1 ) { throw newDatatypeException ( "A hash-name reference must have at least one character after “#”." ) ; } } @ Override public String getName ( ) { return "hash-name reference" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
