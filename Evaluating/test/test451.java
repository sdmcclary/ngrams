<<<<<<< HEAD
public class LinkedBlockingDeque < E > extends AbstractQueue < E > implements BlockingDeque < E > , java . io . Serializable { private static final long serialVersionUID = - 387911632671998426L ; static final class Node < E > { E item ; Node < E > prev ; Node < E > next ; Node ( E x , Node < E > p , Node < E > n ) { item = x ; prev = p ; next = n ; } } private transient Node < E > first ; private transient Node < E > last ; private transient int count ; private final int capacity ; private final ReentrantLock lock = new ReentrantLock ( ) ; private final Condition notEmpty = lock . newCondition ( ) ; private final Condition notFull = lock . newCondition ( ) ; public LinkedBlockingDeque ( ) { this ( Integer . MAX_VALUE ) ; } public LinkedBlockingDeque ( int capacity ) { if ( capacity <= 0 ) throw new IllegalArgumentException ( ) ; this . capacity = capacity ; } public LinkedBlockingDeque ( Collection < ? extends E > c ) { this ( Integer . MAX_VALUE ) ; for ( E e : c ) add ( e ) ; } private boolean linkFirst ( E e ) { if ( count >= capacity ) return false ; ++ count ; Node < E > f = first ; Node < E > x = new Node < E > ( e , null , f ) ; first = x ; if ( last == null ) last = x ; else f . prev = x ; notEmpty . signal ( ) ; return true ; } private boolean linkLast ( E e ) { if ( count >= capacity ) return false ; ++ count ; Node < E > l = last ; Node < E > x = new Node < E > ( e , l , null ) ; last = x ; if ( first == null ) first = x ; else l . next = x ; notEmpty . signal ( ) ; return true ; } private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; f . next = null ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return f . item ; } private E unlinkLast ( ) { Node < E > l = last ; if ( l == null ) return null ; Node < E > p = l . prev ; l . prev = null ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; notFull . signal ( ) ; return l . item ; } private void unlink ( Node < E > x ) { Node < E > p = x . prev ; Node < E > n = x . next ; if ( p == null ) { if ( n == null ) first = last = null ; else { n . prev = null ; first = n ; } } else if ( n == null ) { p . next = null ; last = p ; } else { p . next = n ; n . prev = p ; } -- count ; notFull . signalAll ( ) ; } public void addFirst ( E e ) { if ( ! offerFirst ( e ) ) throw new IllegalStateException ( "Deque full" ) ; } public void addLast ( E e ) { if ( ! offerLast ( e ) ) throw new IllegalStateException ( "Deque full" ) ; } public boolean offerFirst ( E e ) { if ( e == null ) throw new NullPointerException ( ) ; lock . lock ( ) ; try { return linkFirst ( e ) ; } finally { lock . unlock ( ) ; } } public boolean offerLast ( E e ) { if ( e == null ) throw new NullPointerException ( ) ; lock . lock ( ) ; try { return linkLast ( e ) ; } finally { lock . unlock ( ) ; } } public void putFirst ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; lock . lock ( ) ; try { while ( ! linkFirst ( e ) ) notFull . await ( ) ; } finally { lock . unlock ( ) ; } } public void putLast ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; lock . lock ( ) ; try { while ( ! linkLast ( e ) ) notFull . await ( ) ; } finally { lock . unlock ( ) ; } } public boolean offerFirst ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; long nanos = unit . toNanos ( timeout ) ; lock . lockInterruptibly ( ) ; try { for ( ; ; ) { if ( linkFirst ( e ) ) return true ; if ( nanos <= 0 ) return false ; nanos = notFull . awaitNanos ( nanos ) ; } } finally { lock . unlock ( ) ; } } public boolean offerLast ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; long nanos = unit . toNanos ( timeout ) ; lock . lockInterruptibly ( ) ; try { for ( ; ; ) { if ( linkLast ( e ) ) return true ; if ( nanos <= 0 ) return false ; nanos = notFull . awaitNanos ( nanos ) ; } } finally { lock . unlock ( ) ; } } public E removeFirst ( ) { E x = pollFirst ( ) ; if ( x == null ) throw new NoSuchElementException ( ) ; return x ; } public E removeLast ( ) { E x = pollLast ( ) ; if ( x == null ) throw new NoSuchElementException ( ) ; return x ; } public E pollFirst ( ) { lock . lock ( ) ; try { return unlinkFirst ( ) ; } finally { lock . unlock ( ) ; } } public E pollLast ( ) { lock . lock ( ) ; try { return unlinkLast ( ) ; } finally { lock . unlock ( ) ; } } public E takeFirst ( ) throws InterruptedException { lock . lock ( ) ; try { E x ; while ( ( x = unlinkFirst ( ) ) == null ) notEmpty . await ( ) ; return x ; } finally { lock . unlock ( ) ; } } public E takeLast ( ) throws InterruptedException { lock . lock ( ) ; try { E x ; while ( ( x = unlinkLast ( ) ) == null ) notEmpty . await ( ) ; return x ; } finally { lock . unlock ( ) ; } } public E pollFirst ( long timeout , TimeUnit unit ) throws InterruptedException { long nanos = unit . toNanos ( timeout ) ; lock . lockInterruptibly ( ) ; try { for ( ; ; ) { E x = unlinkFirst ( ) ; if ( x != null ) return x ; if ( nanos <= 0 ) return null ; nanos = notEmpty . awaitNanos ( nanos ) ; } } finally { lock . unlock ( ) ; } } public E pollLast ( long timeout , TimeUnit unit ) throws InterruptedException { long nanos = unit . toNanos ( timeout ) ; lock . lockInterruptibly ( ) ; try { for ( ; ; ) { E x = unlinkLast ( ) ; if ( x != null ) return x ; if ( nanos <= 0 ) return null ; nanos = notEmpty . awaitNanos ( nanos ) ; } } finally { lock . unlock ( ) ; } } public E getFirst ( ) { E x = peekFirst ( ) ; if ( x == null ) throw new NoSuchElementException ( ) ; return x ; } public E getLast ( ) { E x = peekLast ( ) ; if ( x == null ) throw new NoSuchElementException ( ) ; return x ; } public E peekFirst ( ) { lock . lock ( ) ; try { return ( first == null ) ? null : first . item ; } finally { lock . unlock ( ) ; } } public E peekLast ( ) { lock . lock ( ) ; try { return ( last == null ) ? null : last . item ; } finally { lock . unlock ( ) ; } } public boolean removeFirstOccurrence ( Object o ) { if ( o == null ) return false ; lock . lock ( ) ; try { for ( Node < E > p = first ; p != null ; p = p . next ) { if ( o . equals ( p . item ) ) { unlink ( p ) ; return true ; } } return false ; } finally { lock . unlock ( ) ; } } public boolean removeLastOccurrence ( Object o ) { if ( o == null ) return false ; lock . lock ( ) ; try { for ( Node < E > p = last ; p != null ; p = p . prev ) { if ( o . equals ( p . item ) ) { unlink ( p ) ; return true ; } } return false ; } finally { lock . unlock ( ) ; } } public boolean add ( E e ) { addLast ( e ) ; return true ; } public boolean offer ( E e ) { return offerLast ( e ) ; } public void put ( E e ) throws InterruptedException { putLast ( e ) ; } public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { return offerLast ( e , timeout , unit ) ; } public E remove ( ) { return removeFirst ( ) ; } public E poll ( ) { return pollFirst ( ) ; } public E take ( ) throws InterruptedException { return takeFirst ( ) ; } public E poll ( long timeout , TimeUnit unit ) throws InterruptedException { return pollFirst ( timeout , unit ) ; } public E element ( ) { return getFirst ( ) ; } public E peek ( ) { return peekFirst ( ) ; } public int remainingCapacity ( ) { lock . lock ( ) ; try { return capacity - count ; } finally { lock . unlock ( ) ; } } public int drainTo ( Collection < ? super E > c ) { if ( c == null ) throw new NullPointerException ( ) ; if ( c == this ) throw new IllegalArgumentException ( ) ; lock . lock ( ) ; try { for ( Node < E > p = first ; p != null ; p = p . next ) c . add ( p . item ) ; int n = count ; count = 0 ; first = last = null ; notFull . signalAll ( ) ; return n ; } finally { lock . unlock ( ) ; } } public int drainTo ( Collection < ? super E > c , int maxElements ) { if ( c == null ) throw new NullPointerException ( ) ; if ( c == this ) throw new IllegalArgumentException ( ) ; lock . lock ( ) ; try { int n = 0 ; while ( n < maxElements && first != null ) { c . add ( first . item ) ; first . prev = null ; first = first . next ; -- count ; ++ n ; } if ( first == null ) last = null ; notFull . signalAll ( ) ; return n ; } finally { lock . unlock ( ) ; } } public void push ( E e ) { addFirst ( e ) ; } public E pop ( ) { return removeFirst ( ) ; } public boolean remove ( Object o ) { return removeFirstOccurrence ( o ) ; } public int size ( ) { lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } } public boolean contains ( Object o ) { if ( o == null ) return false ; lock . lock ( ) ; try { for ( Node < E > p = first ; p != null ; p = p . next ) if ( o . equals ( p . item ) ) return true ; return false ; } finally { lock . unlock ( ) ; } } boolean removeNode ( Node < E > e ) { lock . lock ( ) ; try { for ( Node < E > p = first ; p != null ; p = p . next ) { if ( p == e ) { unlink ( p ) ; return true ; } } return false ; } finally { lock . unlock ( ) ; } } public Object [ ] toArray ( ) { lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = 0 ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } } public < T > T [ ] toArray ( T [ ] a ) { lock . lock ( ) ; try { if ( a . length < count ) a = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , count ) ; int k = 0 ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = ( T ) p . item ; if ( a . length > k ) a [ k ] = null ; return a ; } finally { lock . unlock ( ) ; } } public String toString ( ) { lock . lock ( ) ; try { return super . toString ( ) ; } finally { lock . unlock ( ) ; } } public void clear ( ) { lock . lock ( ) ; try { first = last = null ; count = 0 ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } } public Iterator < E > iterator ( ) { return new Itr ( ) ; } public Iterator < E > descendingIterator ( ) { return new DescendingItr ( ) ; } private abstract class AbstractItr implements Iterator < E > { Node < E > next ; E nextItem ; private Node < E > lastRet ; AbstractItr ( ) { advance ( ) ; } abstract void advance ( ) ; public boolean hasNext ( ) { return next != null ; } public E next ( ) { if ( next == null ) throw new NoSuchElementException ( ) ; lastRet = next ; E x = nextItem ; advance ( ) ; return x ; } public void remove ( ) { Node < E > n = lastRet ; if ( n == null ) throw new IllegalStateException ( ) ; lastRet = null ; removeNode ( n ) ; } } private class Itr extends AbstractItr { void advance ( ) { final ReentrantLock lock = LinkedBlockingDeque . this . lock ; lock . lock ( ) ; try { next = ( next == null ) ? first : next . next ; nextItem = ( next == null ) ? null : next . item ; } finally { lock . unlock ( ) ; } } } private class DescendingItr extends AbstractItr { void advance ( ) { final ReentrantLock lock = LinkedBlockingDeque . this . lock ; lock . lock ( ) ; try { next = ( next == null ) ? last : next . prev ; nextItem = ( next == null ) ? null : next . item ; } finally { lock . unlock ( ) ; } } } private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { lock . lock ( ) ; try { s . defaultWriteObject ( ) ; for ( Node < E > p = first ; p != null ; p = p . next ) s . writeObject ( p . item ) ; s . writeObject ( null ) ; } finally { lock . unlock ( ) ; } } private void readObject ( java . io . ObjectInputStream s ) throws java . io . IOException , ClassNotFoundException { s . defaultReadObject ( ) ; count = 0 ; first = null ; last = null ; for ( ; ; ) { E item = ( E ) s . readObject ( ) ; if ( item == null ) break ; add ( item ) ; } } } 
=======
public final class Datetime extends AbstractDatetime { public static final Datetime THE_INSTANCE = new Datetime ( ) ; private static final Pattern THE_PATTERN = Pattern . compile ( "^([0-9]{4,})-([0-9]{2})-([0-9]{2})[T ]([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\.[0-9]{1,3})?)?Z$" ) ; private Datetime ( ) { super ( ) ; } protected final Pattern getPattern ( ) { return THE_PATTERN ; } @ Override public String getName ( ) { return "datetime" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
