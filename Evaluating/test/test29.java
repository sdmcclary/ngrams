public abstract class AbstractDbSession implements DbSession { private final Logger logger = LoggerFactory . getLogger ( AbstractDbSession . class ) ; protected final Object lock = this ; protected final Queue < Request < ? > > requestQueue = new ConcurrentLinkedQueue < Request < ? > > ( ) ; private Request < ? > activeRequest ; private Transaction transaction ; private final boolean pipelined ; private boolean pipelining = false ; protected AbstractDbSession ( boolean pipelined ) { this . pipelined = pipelined ; } protected < E > void enqueueRequest ( final Request < E > request ) { synchronized ( lock ) { if ( request . isPipelinable ( ) ) { if ( pipelining ) { invokeExecuteWithCatch ( request ) ; if ( request . isDone ( ) ) { return ; } } } else { pipelining = false ; } requestQueue . add ( request ) ; if ( activeRequest == null ) { makeNextRequestActive ( ) ; } } } @ SuppressWarnings ( "unchecked" ) protected final < E > Request < E > makeNextRequestActive ( ) { Request < E > request ; boolean executePipelining = false ; synchronized ( lock ) { if ( activeRequest != null && ! activeRequest . isDone ( ) ) { throw new ActiveRequestIncomplete ( this , "Active request is not done: " + activeRequest ) ; } request = ( Request < E > ) requestQueue . poll ( ) ; if ( pipelined && request != null ) { if ( request . isPipelinable ( ) ) { executePipelining = ! pipelining ; } else { pipelining = false ; } } activeRequest = request ; } if ( request != null ) { invokeExecuteWithCatch ( request ) ; } if ( executePipelining ) { synchronized ( lock ) { Iterator < Request < ? > > iterator = requestQueue . iterator ( ) ; while ( iterator . hasNext ( ) ) { Request < ? > next = iterator . next ( ) ; if ( next . isPipelinable ( ) ) { invokeExecuteWithCatch ( next ) ; if ( ! iterator . hasNext ( ) ) { pipelining = true ; } } else { break ; } } } } return request ; } private < E > void invokeExecuteWithCatch ( Request < E > request ) { try { request . invokeExecute ( ) ; } catch ( Throwable e ) { request . error ( DbException . wrap ( this , e ) ) ; } } @ SuppressWarnings ( "unchecked" ) protected < E > Request < E > getActiveRequest ( ) { synchronized ( lock ) { return ( Request < E > ) activeRequest ; } } protected void cancelPendingRequests ( boolean mayInterruptIfRunning ) { for ( Iterator < Request < ? > > i = requestQueue . iterator ( ) ; i . hasNext ( ) ; ) { Request < ? > request = i . next ( ) ; request . cancel ( mayInterruptIfRunning ) ; } } public void errorPendingRequests ( Throwable exception ) { synchronized ( lock ) { if ( activeRequest != null && ! activeRequest . isDone ( ) ) { activeRequest . setException ( exception ) ; } } for ( Iterator < Request < ? > > i = requestQueue . iterator ( ) ; i . hasNext ( ) ; ) { Request < ? > request = i . next ( ) ; if ( ! request . isDone ( ) ) { try { request . setException ( exception ) ; } catch ( IllegalStateException e ) { } } } } protected abstract void checkClosed ( ) throws DbSessionClosedException ; public DbSessionFuture < ResultSet > executeQuery ( String sql ) { ResultEventHandler < DefaultResultSet > eventHandler = new ResultEventHandler < DefaultResultSet > ( ) { private Value [ ] currentRow ; public void startFields ( DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: startFields" ) ; } public void field ( Field field , DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: field" ) ; accumulator . addField ( field ) ; } public void endFields ( DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: endFields" ) ; } public void startResults ( DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: startResults" ) ; } public void startRow ( DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: startRow" ) ; int columnCount = accumulator . getFields ( ) . size ( ) ; currentRow = new Value [ columnCount ] ; } public void value ( Value value , DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: value" ) ; currentRow [ value . getField ( ) . getIndex ( ) ] = value ; } public void endRow ( DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: endRow" ) ; DefaultRow row = new DefaultRow ( accumulator , currentRow ) ; accumulator . addResult ( row ) ; currentRow = null ; } public void endResults ( DefaultResultSet accumulator ) { logger . trace ( "ResultSetEventHandler: endResults" ) ; } public void exception ( Throwable t , DefaultResultSet accumulator ) { } } ; DefaultResultSet resultSet = new DefaultResultSet ( this ) ; return executeQuery0 ( sql , eventHandler , resultSet ) ; } @ SuppressWarnings ( "unchecked" ) private < T extends ResultSet > DbSessionFuture < ResultSet > executeQuery0 ( String sql , ResultEventHandler < T > eventHandler , T accumulator ) { return ( DbSessionFuture < ResultSet > ) executeQuery ( sql , eventHandler , accumulator ) ; } public boolean isInTransaction ( ) { checkClosed ( ) ; synchronized ( lock ) { return transaction != null ; } } public void beginTransaction ( ) { checkClosed ( ) ; synchronized ( lock ) { if ( isInTransaction ( ) ) { throw new DbException ( this , "Cannot begin new transaction.  Current transaction needs to be committed or rolled back" ) ; } transaction = new Transaction ( ) ; } } public DbSessionFuture < Void > commit ( ) { checkClosed ( ) ; if ( ! isInTransaction ( ) ) { throw new DbException ( this , "Not currently in a transaction, cannot commit" ) ; } DbSessionFuture < Void > future ; synchronized ( lock ) { if ( transaction . isBeginScheduled ( ) ) { future = enqueueCommit ( transaction ) ; return future ; } else { future = DefaultDbSessionFuture . createCompletedFuture ( this , null ) ; } transaction = null ; } return future ; } public DbSessionFuture < Void > rollback ( ) { checkClosed ( ) ; if ( ! isInTransaction ( ) ) { throw new DbException ( this , "Not currently in a transaction, cannot rollback" ) ; } DbSessionFuture < Void > future ; synchronized ( lock ) { if ( transaction . isBeginScheduled ( ) ) { transaction . cancelPendingRequests ( ) ; future = enqueueRollback ( transaction ) ; } else { future = DefaultDbSessionFuture . createCompletedFuture ( this , null ) ; } transaction = null ; } return future ; } protected < E > DbSessionFuture < E > enqueueTransactionalRequest ( Request < E > request ) { synchronized ( lock ) { if ( transaction != null ) { if ( transaction . isCanceled ( ) ) { return DefaultDbSessionFuture . createCompletedErrorFuture ( this , new DbException ( this , "Could not execute request; transaction is in failed state" ) ) ; } if ( ! transaction . isBeginScheduled ( ) ) { enqueueStartTransaction ( transaction ) ; transaction . setBeginScheduled ( true ) ; } transaction . addRequest ( request ) ; } } enqueueRequest ( request ) ; return request ; } private Request < Void > enqueueStartTransaction ( final Transaction transaction ) { Request < Void > request = createBeginRequest ( transaction ) ; enqueueTransactionalRequest ( transaction , request ) ; return request ; } private Request < Void > enqueueCommit ( final Transaction transaction ) { Request < Void > request = createCommitRequest ( transaction ) ; enqueueTransactionalRequest ( transaction , request ) ; return request ; } private Request < Void > enqueueRollback ( Transaction transaction ) { Request < Void > request = createRollbackRequest ( ) ; enqueueTransactionalRequest ( transaction , request ) ; return request ; } private void enqueueTransactionalRequest ( final Transaction transaction , Request < Void > request ) { enqueueRequest ( request ) ; transaction . addRequest ( request ) ; } protected Request < Void > createRollbackRequest ( ) { return new RollbackRequest ( ) ; } protected abstract void sendBegin ( ) throws Exception ; protected abstract void sendCommit ( ) throws Exception ; protected abstract void sendRollback ( ) throws Exception ; protected Request < Void > createBeginRequest ( final Transaction transaction ) { return new BeginRequest ( transaction ) ; } protected Request < Void > createCommitRequest ( final Transaction transaction ) { return new CommitRequest ( transaction ) ; } protected class BeginRequest extends Request < Void > { private final Transaction transaction ; private BeginRequest ( Transaction transaction ) { if ( transaction == null ) { throw new IllegalArgumentException ( "transaction can NOT be null" ) ; } this . transaction = transaction ; } @ Override public void execute ( ) throws Exception { transaction . setStarted ( true ) ; sendBegin ( ) ; } } protected class CommitRequest extends Request < Void > { private final Transaction transaction ; private CommitRequest ( Transaction transaction ) { if ( transaction == null ) { throw new IllegalArgumentException ( "transaction can NOT be null" ) ; } this . transaction = transaction ; } public void execute ( ) throws Exception { if ( isCancelled ( ) ) { if ( transaction . isStarted ( ) ) { sendRollback ( ) ; } } else { sendCommit ( ) ; } } @ Override public boolean cancelRequest ( boolean mayInterruptIfRunning ) { transaction . cancelPendingRequests ( ) ; return true ; } @ Override public boolean canRemove ( ) { return false ; } @ Override public boolean isPipelinable ( ) { return false ; } } protected class RollbackRequest extends Request < Void > { @ Override public void execute ( ) throws Exception { sendRollback ( ) ; } @ Override public boolean cancelRequest ( boolean mayInterruptIfRunning ) { return false ; } } public abstract class Request < T > extends DefaultDbSessionFuture < T > { private final ResultEventHandler < T > eventHandler ; private final T accumulator ; private volatile Object payload ; private volatile Transaction transaction ; private boolean cancelled ; private boolean executed ; public Request ( ) { this ( null , null ) ; } public Request ( ResultEventHandler < T > eventHandler , T accumulator ) { super ( AbstractDbSession . this ) ; this . eventHandler = eventHandler ; this . accumulator = accumulator ; } public final synchronized void invokeExecute ( ) throws Exception { if ( cancelled || executed ) { synchronized ( lock ) { if ( isDone ( ) && activeRequest == this ) { makeNextRequestActive ( ) ; } } } else { executed = true ; execute ( ) ; } } public final synchronized boolean doCancel ( boolean mayInterruptIfRunning ) { if ( executed ) { return false ; } cancelled = cancelRequest ( mayInterruptIfRunning ) ; if ( cancelled && canRemove ( ) ) { if ( canRemove ( ) && requestQueue . remove ( this ) ) { synchronized ( lock ) { if ( this == activeRequest ) { makeNextRequestActive ( ) ; } } } } return cancelled ; } protected abstract void execute ( ) throws Exception ; protected boolean cancelRequest ( boolean mayInterruptIfRunning ) { return true ; } public boolean canRemove ( ) { return true ; } public boolean isPipelinable ( ) { return true ; } public Object getPayload ( ) { return payload ; } public void setPayload ( Object payload ) { this . payload = payload ; } public T getAccumulator ( ) { return accumulator ; } public ResultEventHandler < T > getEventHandler ( ) { return eventHandler ; } public Transaction getTransaction ( ) { return transaction ; } public void setTransaction ( Transaction transaction ) { this . transaction = transaction ; } public void complete ( T result ) { setResult ( result ) ; synchronized ( lock ) { if ( activeRequest == this ) { makeNextRequestActive ( ) ; } } } public void error ( DbException exception ) { super . setException ( exception ) ; if ( transaction != null ) { transaction . cancelPendingRequests ( ) ; } synchronized ( lock ) { if ( activeRequest == this ) { makeNextRequestActive ( ) ; } } } } public static class Transaction { private volatile boolean started = false ; private volatile boolean beginScheduled = false ; private volatile boolean canceled = false ; private List < Request < ? > > requests = new LinkedList < Request < ? > > ( ) ; public boolean isStarted ( ) { return started ; } public void setStarted ( boolean started ) { this . started = started ; } public boolean isBeginScheduled ( ) { return beginScheduled ; } public void setBeginScheduled ( boolean beginScheduled ) { this . beginScheduled = beginScheduled ; } public void addRequest ( Request < ? > request ) { request . setTransaction ( this ) ; synchronized ( requests ) { requests . add ( request ) ; } } public boolean isCanceled ( ) { return canceled ; } public void cancelPendingRequests ( ) { canceled = true ; synchronized ( requests ) { for ( Request < ? > request : requests ) { request . cancel ( false ) ; } } } } } 