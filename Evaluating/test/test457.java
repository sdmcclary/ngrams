<<<<<<< HEAD
public class ModelBootstrap { private static Context mContext ; private static HashMap < Integer , Form > formIdCache = new HashMap < Integer , Form > ( ) ; private static HashMap < Integer , Vector < Field > > fieldToFormHash = new HashMap < Integer , Vector < Field > > ( ) ; private static HashMap < Integer , SimpleFieldType > fieldTypeHash = new HashMap < Integer , SimpleFieldType > ( ) ; public static void InitApplicationDatabase ( Context context ) { mContext = context ; if ( isFieldTypeTableEmpty ( ) ) { applicationInitialFormFieldTypesBootstrap ( ) ; } MessageTranslator . updateMonitorHash ( context ) ; } private static boolean isFieldTypeTableEmpty ( ) { Uri fieldtypeUri = RapidSmsDBConstants . FieldType . CONTENT_URI ; Cursor fieldtypecheck = mContext . getContentResolver ( ) . query ( fieldtypeUri , null , null , null , null ) ; if ( fieldtypecheck . getCount ( ) == 0 ) { fieldtypecheck . close ( ) ; return true ; } else { fieldtypecheck . close ( ) ; return false ; } } private static String loadAssetFile ( String filename ) { try { InputStream is = mContext . getAssets ( ) . open ( filename ) ; int size = is . available ( ) ; byte [ ] buffer = new byte [ size ] ; is . read ( buffer ) ; is . close ( ) ; String text = new String ( buffer ) ; return text ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } private static void applicationInitialFormFieldTypesBootstrap ( ) { loadFieldTypesFromAssets ( ) ; insertFieldTypesIntoDBIfNecessary ( ) ; loadInitialFormsFromAssets ( ) ; checkIfFormTablesExistCreateIfNecessary ( ) ; } private static void insertFieldTypesIntoDBIfNecessary ( ) { Iterator < ? > it = fieldTypeHash . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < Integer , SimpleFieldType > pairs = ( Map . Entry < Integer , SimpleFieldType > ) it . next ( ) ; SimpleFieldType thetype = pairs . getValue ( ) ; Uri fieldtypeUri = Uri . parse ( RapidSmsDBConstants . FieldType . CONTENT_URI_STRING + thetype . getId ( ) ) ; Cursor typeCursor = mContext . getContentResolver ( ) . query ( fieldtypeUri , null , null , null , null ) ; if ( typeCursor . getCount ( ) == 0 ) { ContentValues typecv = new ContentValues ( ) ; typecv . put ( BaseColumns . _ID , thetype . getId ( ) ) ; typecv . put ( RapidSmsDBConstants . FieldType . DATATYPE , thetype . getDataType ( ) ) ; typecv . put ( RapidSmsDBConstants . FieldType . NAME , thetype . getReadableName ( ) ) ; typecv . put ( RapidSmsDBConstants . FieldType . REGEX , thetype . getRegex ( ) ) ; Log . d ( "dimagi" , "InsertFieldType: " + thetype . getId ( ) ) ; Log . d ( "dimagi" , "InsertFieldType: " + thetype . getDataType ( ) ) ; Log . d ( "dimagi" , "InsertFieldType: " + thetype . getReadableName ( ) ) ; Log . d ( "dimagi" , "InsertFieldType: " + thetype . getRegex ( ) ) ; Uri insertedTypeUri = mContext . getContentResolver ( ) . insert ( RapidSmsDBConstants . FieldType . CONTENT_URI , typecv ) ; Log . d ( "dimagi" , "********** Inserted SimpleFieldType into db: " + insertedTypeUri ) ; } typeCursor . close ( ) ; } } private static void loadFieldTypesFromAssets ( ) { String types = loadAssetFile ( "definitions/fieldtypes.json" ) ; try { JSONArray typesarray = new JSONArray ( types ) ; int arrlength = typesarray . length ( ) ; for ( int i = 0 ; i < arrlength ; i ++ ) { try { JSONObject obj = typesarray . getJSONObject ( i ) ; Log . d ( "dimagi" , "type loop: " + i + " model: " + obj . getString ( "model" ) ) ; if ( ! obj . getString ( "model" ) . equals ( "rapidandroid.fieldtype" ) ) { Log . d ( "dimagi" , "###" + obj . getString ( "model" ) + "###" ) ; throw new IllegalArgumentException ( "Error in parsing fieldtypes.json" ) ; } int pk = obj . getInt ( "pk" ) ; JSONObject jsonfields = obj . getJSONObject ( "fields" ) ; Log . d ( "dimagi" , "#### Regex from file: " + jsonfields . getString ( "name" ) + " [" + jsonfields . getString ( "regex" ) + "]" ) ; SimpleFieldType newtype = new SimpleFieldType ( pk , jsonfields . getString ( "datatype" ) , jsonfields . getString ( "regex" ) , jsonfields . getString ( "name" ) ) ; fieldTypeHash . put ( new Integer ( pk ) , newtype ) ; } catch ( JSONException e ) { } } } catch ( JSONException e ) { } } private static void loadInitialFormsFromAssets ( ) { parseFieldsFromAssets ( ) ; parseFormsFromAssets ( ) ; } private static void parseFieldsFromAssets ( ) { String fields = loadAssetFile ( "definitions/fields.json" ) ; try { JSONArray fieldsarray = new JSONArray ( fields ) ; int arrlength = fieldsarray . length ( ) ; for ( int i = 0 ; i < arrlength ; i ++ ) { try { JSONObject obj = fieldsarray . getJSONObject ( i ) ; if ( ! obj . getString ( "model" ) . equals ( "rapidandroid.field" ) ) { } int pk = obj . getInt ( "pk" ) ; JSONObject jsonfields = obj . getJSONObject ( "fields" ) ; int form_id = jsonfields . getInt ( "form" ) ; Field newfield = new Field ( pk , jsonfields . getInt ( "sequence" ) , jsonfields . getString ( "name" ) , jsonfields . getString ( "prompt" ) , fieldTypeHash . get ( new Integer ( jsonfields . getInt ( "fieldtype" ) ) ) ) ; Integer formInt = Integer . valueOf ( form_id ) ; if ( ! fieldToFormHash . containsKey ( formInt ) ) { fieldToFormHash . put ( formInt , new Vector < Field > ( ) ) ; Log . d ( "dimagi" , "### adding a key again?!" + formInt ) ; } fieldToFormHash . get ( formInt ) . add ( newfield ) ; Log . d ( "dimagi" , "#### Parsed field: " + newfield . getFieldId ( ) + " [" + newfield . getName ( ) + "] newlength: " + fieldToFormHash . get ( formInt ) . size ( ) ) ; } catch ( JSONException e ) { Log . d ( "dimagi" , e . getMessage ( ) ) ; } } } catch ( JSONException e ) { } } private static void parseFormsFromAssets ( ) { String forms = loadAssetFile ( "definitions/forms.json" ) ; try { JSONArray formarray = new JSONArray ( forms ) ; int arrlength = formarray . length ( ) ; for ( int i = 0 ; i < arrlength ; i ++ ) { try { JSONObject obj = formarray . getJSONObject ( i ) ; if ( ! obj . getString ( "model" ) . equals ( "rapidandroid.form" ) ) { } int pk = obj . getInt ( "pk" ) ; Integer pkInt = new Integer ( pk ) ; JSONObject jsonfields = obj . getJSONObject ( "fields" ) ; Field [ ] fieldarr = new Field [ fieldToFormHash . get ( pkInt ) . size ( ) ] ; for ( int q = 0 ; q < fieldarr . length ; q ++ ) { fieldarr [ q ] = fieldToFormHash . get ( pkInt ) . get ( q ) ; } Form newform = new Form ( pk , jsonfields . getString ( "formname" ) , jsonfields . getString ( "prefix" ) , jsonfields . getString ( "description" ) , fieldarr , ParserType . SIMPLEREGEX ) ; formIdCache . put ( pkInt , newform ) ; } catch ( JSONException e ) { Log . d ( "dimagi" , e . getMessage ( ) ) ; } } } catch ( JSONException e ) { } } private static void checkIfFormTablesExistCreateIfNecessary ( ) { Iterator < ? > it = formIdCache . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < Integer , Form > pairs = ( Map . Entry < Integer , Form > ) it . next ( ) ; Form f = pairs . getValue ( ) ; Log . d ( "dimagi" , "**** inserting form " + f . getFormName ( ) ) ; Uri formUri = Uri . parse ( RapidSmsDBConstants . Form . CONTENT_URI_STRING + f . getFormId ( ) ) ; Cursor crform = mContext . getContentResolver ( ) . query ( formUri , null , null , null , null ) ; boolean newFormInserted = false ; if ( crform . getCount ( ) == 0 ) { ModelTranslator . addFormToDatabase ( f ) ; } crform . close ( ) ; } } } 
=======
public class FloatingPointExponentNonNegative extends AbstractDatatype { public static final FloatingPointExponentNonNegative THE_INSTANCE = new FloatingPointExponentNonNegative ( ) ; private enum State { AT_START , AT_START_MINUS_SEEN , IN_INTEGER_PART_DIGITS_SEEN , IN_INTEGER_PART_DIGITS_SEEN_ZERO , DOT_SEEN , DOT_SEEN_ZERO , E_SEEN , IN_DECIMAL_PART_DIGITS_SEEN , IN_DECIMAL_PART_DIGITS_SEEN_ZERO , IN_EXPONENT_SIGN_SEEN , IN_EXPONENT_DIGITS_SEEN } private FloatingPointExponentNonNegative ( ) { super ( ) ; } @ Override public void checkValid ( CharSequence literal ) throws DatatypeException { State state = State . AT_START ; for ( int i = 0 ; i < literal . length ( ) ; i ++ ) { char c = literal . charAt ( i ) ; switch ( state ) { case AT_START : if ( c == '-' ) { state = State . AT_START_MINUS_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { state = State . IN_INTEGER_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a minus sign or a digit but saw " , c , " instead." ) ; } case AT_START_MINUS_SEEN : if ( c == '0' ) { state = State . IN_INTEGER_PART_DIGITS_SEEN_ZERO ; continue ; } else { throw newDatatypeException ( i , "Expected a zero but saw " , c , " instead." ) ; } case IN_INTEGER_PART_DIGITS_SEEN : if ( c == '.' ) { state = State . DOT_SEEN ; continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a decimal point, “e”, “E” or a digit but saw " , c , " instead." ) ; } case IN_INTEGER_PART_DIGITS_SEEN_ZERO : if ( c == '.' ) { state = State . DOT_SEEN_ZERO ; continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else if ( c == '0' ) { continue ; } else { throw newDatatypeException ( i , "Expected a decimal point, “e”, “E” or a zero but saw " , c , " instead." ) ; } case DOT_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_DECIMAL_PART_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit after the decimal point but saw " , c , " instead." ) ; } case DOT_SEEN_ZERO : if ( c == '0' ) { state = State . IN_DECIMAL_PART_DIGITS_SEEN_ZERO ; continue ; } else { throw newDatatypeException ( i , "Expected a zero after the decimal point but saw " , c , " instead." ) ; } case IN_DECIMAL_PART_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected “e”, “E” or a digit but saw " , c , " instead." ) ; } case IN_DECIMAL_PART_DIGITS_SEEN_ZERO : if ( c == '0' ) { continue ; } else if ( c == 'e' || c == 'E' ) { state = State . E_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected “e”, “E” or a zero but saw " , c , " instead." ) ; } case E_SEEN : if ( c == '-' || c == '+' ) { state = State . IN_EXPONENT_SIGN_SEEN ; continue ; } else if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a minus sign, a plus sign or a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_SIGN_SEEN : if ( isAsciiDigit ( c ) ) { state = State . IN_EXPONENT_DIGITS_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } case IN_EXPONENT_DIGITS_SEEN : if ( isAsciiDigit ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a digit but saw " , c , " instead." ) ; } } } switch ( state ) { case IN_INTEGER_PART_DIGITS_SEEN : case IN_DECIMAL_PART_DIGITS_SEEN : case IN_INTEGER_PART_DIGITS_SEEN_ZERO : case IN_DECIMAL_PART_DIGITS_SEEN_ZERO : case IN_EXPONENT_DIGITS_SEEN : return ; case AT_START : throw newDatatypeException ( "The empty string is not a valid non-negative floating point number." ) ; case AT_START_MINUS_SEEN : throw newDatatypeException ( "The minus sign alone is not a valid non-negative floating point number." ) ; case DOT_SEEN : case DOT_SEEN_ZERO : throw newDatatypeException ( "A non-negative floating point number must not end with the decimal point." ) ; case E_SEEN : throw newDatatypeException ( "A non-negative floating point number must not end with the exponent “e”." ) ; case IN_EXPONENT_SIGN_SEEN : throw newDatatypeException ( "A non-negative floating point number must not end with only a sign in the exponent." ) ; } } @ Override public String getName ( ) { return "non-negative floating point number" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
