<<<<<<< HEAD
public class ThrudocHandler implements Iface { private Logger logger = Logger . getLogger ( getClass ( ) ) ; private volatile Map < String , TokyoCabinetDB > bucketMap = new HashMap < String , TokyoCabinetDB > ( ) ; private String docRoot ; public ThrudocHandler ( String docRoot ) { this . docRoot = docRoot ; } public boolean isValidBucket ( String bucketName ) throws TException { if ( bucketMap . containsKey ( bucketName ) ) return true ; synchronized ( bucketMap ) { if ( bucketMap . containsKey ( bucketName ) ) return true ; String dbFileName = docRoot + File . separatorChar + bucketName + ".tcb" ; File dbFile = new File ( dbFileName ) ; if ( dbFile . isFile ( ) && dbFile . canWrite ( ) ) { bucketMap . put ( bucketName , new TokyoCabinetDB ( docRoot , bucketName ) ) ; return true ; } else { return false ; } } } public String admin ( String op , String data ) throws ThrudocException , TException { return "ok" ; } public int decr ( String bucket , String key , int amount ) throws InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return 0 ; } public byte [ ] get ( String bucket , String key ) throws InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; byte [ ] value = bucketMap . get ( bucket ) . get ( key ) ; if ( value == null ) value = new byte [ ] { } ; return value ; } public void create_bucket ( String bucket ) throws ThrudocException , TException { if ( bucketMap . containsKey ( bucket ) ) return ; bucketMap . put ( bucket , new TokyoCabinetDB ( docRoot , bucket ) ) ; } public void delete_bucket ( String bucket ) throws ThrudocException , TException { if ( ! isValidBucket ( bucket ) ) this . create_bucket ( bucket ) ; TokyoCabinetDB db = bucketMap . get ( bucket ) ; if ( db == null ) return ; db . erase ( ) ; bucketMap . remove ( bucket ) ; } public Set < String > get_bucket_list ( ) throws ThrudocException , TException { return bucketMap . keySet ( ) ; } public int incr ( String bucket , String key , int amount ) throws TException , InvalidBucketException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . incr ( key , amount ) ; } public int length ( String bucket , String key ) throws TException , InvalidBucketException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . length ( key ) ; } public byte [ ] pop_back ( String bucket , String key ) throws TException , InvalidBucketException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . pop_back ( key ) ; } public byte [ ] pop_front ( String bucket , String key ) throws TException , InvalidBucketException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . pop_front ( key ) ; } public void push_back ( String bucket , String key , byte [ ] value ) throws ThrudocException , InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; bucketMap . get ( bucket ) . push_back ( key , value ) ; } public void push_front ( String bucket , String key , byte [ ] value ) throws ThrudocException , TException , InvalidBucketException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; bucketMap . get ( bucket ) . push_front ( key , value ) ; } public void put ( String bucket , String key , byte [ ] value ) throws InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; bucketMap . get ( bucket ) . put ( key , value ) ; } public List < byte [ ] > range ( String bucket , String key , int start , int end ) throws TException , InvalidBucketException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . range ( key , start , end ) ; } public byte [ ] remove_at ( String bucket , String key , int pos ) throws TException , InvalidBucketException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . remove_at ( key , pos ) ; } public void remove ( String bucket , String key ) throws InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; bucketMap . get ( bucket ) . remove ( key ) ; } public void insert_at ( String bucket , String key , byte [ ] value , int pos ) throws ThrudocException , InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; bucketMap . get ( bucket ) . insert_at ( key , value , pos ) ; } public void replace_at ( String bucket , String key , byte [ ] value , int pos ) throws ThrudocException , InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; bucketMap . get ( bucket ) . replace_at ( key , value , pos ) ; } public byte [ ] retrieve_at ( String bucket , String key , int pos ) throws ThrudocException , InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . retrieve_at ( key , pos ) ; } public List < String > scan ( String bucket , String seed , int count ) throws InvalidBucketException , TException { if ( ! isValidBucket ( bucket ) ) throw new InvalidBucketException ( ) ; return bucketMap . get ( bucket ) . scan ( seed , count ) ; } } 
=======
public class Html4Assertions extends Checker { private static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString ( String lowerCaseLiteral , String string ) { if ( string == null ) { return false ; } if ( lowerCaseLiteral . length ( ) != string . length ( ) ) { return false ; } for ( int i = 0 ; i < lowerCaseLiteral . length ( ) ; i ++ ) { char c0 = lowerCaseLiteral . charAt ( i ) ; char c1 = string . charAt ( i ) ; if ( c1 >= 'A' && c1 <= 'Z' ) { c1 += 0x20 ; } if ( c0 != c1 ) { return false ; } } return true ; } private static boolean equalsIgnoreAsciiCase ( String one , String other ) { if ( other == null ) { if ( one == null ) { return true ; } else { return false ; } } if ( one . length ( ) != other . length ( ) ) { return false ; } for ( int i = 0 ; i < one . length ( ) ; i ++ ) { char c0 = one . charAt ( i ) ; char c1 = other . charAt ( i ) ; if ( c0 >= 'A' && c0 <= 'Z' ) { c0 += 0x20 ; } if ( c1 >= 'A' && c1 <= 'Z' ) { c1 += 0x20 ; } if ( c0 != c1 ) { return false ; } } return true ; } private static final String [ ] SPECIAL_ANCESTORS = { "a" , "button" , "form" , "label" , "pre" } ; private static int specialAncestorNumber ( String name ) { for ( int i = 0 ; i < SPECIAL_ANCESTORS . length ; i ++ ) { if ( name == SPECIAL_ANCESTORS [ i ] ) { return i ; } } return - 1 ; } private static Map < String , Integer > ANCESTOR_MASK_BY_DESCENDANT = new HashMap < String , Integer > ( ) ; private static void registerProhibitedAncestor ( String ancestor , String descendant ) { int number = specialAncestorNumber ( ancestor ) ; if ( number == - 1 ) { throw new IllegalStateException ( "Ancestor not found in array: " + ancestor ) ; } Integer maskAsObject = ANCESTOR_MASK_BY_DESCENDANT . get ( descendant ) ; int mask = 0 ; if ( maskAsObject != null ) { mask = maskAsObject . intValue ( ) ; } mask |= ( 1 << number ) ; ANCESTOR_MASK_BY_DESCENDANT . put ( descendant , new Integer ( mask ) ) ; } static { registerProhibitedAncestor ( "a" , "a" ) ; registerProhibitedAncestor ( "button" , "a" ) ; registerProhibitedAncestor ( "button" , "button" ) ; registerProhibitedAncestor ( "button" , "fieldset" ) ; registerProhibitedAncestor ( "button" , "form" ) ; registerProhibitedAncestor ( "button" , "iframe" ) ; registerProhibitedAncestor ( "button" , "input" ) ; registerProhibitedAncestor ( "button" , "isindex" ) ; registerProhibitedAncestor ( "button" , "select" ) ; registerProhibitedAncestor ( "button" , "textarea" ) ; registerProhibitedAncestor ( "form" , "form" ) ; registerProhibitedAncestor ( "label" , "label" ) ; registerProhibitedAncestor ( "pre" , "pre" ) ; registerProhibitedAncestor ( "pre" , "img" ) ; registerProhibitedAncestor ( "pre" , "object" ) ; registerProhibitedAncestor ( "pre" , "applet" ) ; registerProhibitedAncestor ( "pre" , "big" ) ; registerProhibitedAncestor ( "pre" , "small" ) ; registerProhibitedAncestor ( "pre" , "sub" ) ; registerProhibitedAncestor ( "pre" , "sup" ) ; registerProhibitedAncestor ( "pre" , "font" ) ; } private static final int BUTTON_MASK = ( 1 << specialAncestorNumber ( "button" ) ) ; private static final int LABEL_FOR_MASK = ( 1 << 28 ) ; private class IdrefLocator { private final Locator locator ; private final String idref ; public IdrefLocator ( Locator locator , String idref ) { this . locator = new LocatorImpl ( locator ) ; this . idref = idref ; } public Locator getLocator ( ) { return locator ; } public String getIdref ( ) { return idref ; } } private class StackNode { private final int ancestorMask ; private boolean selectedOptions = false ; private boolean optionFound = false ; public StackNode ( int ancestorMask , String name , String role , String activeDescendant , String forAttr ) { this . ancestorMask = ancestorMask ; } public int getAncestorMask ( ) { return ancestorMask ; } public boolean isSelectedOptions ( ) { return selectedOptions ; } public void setSelectedOptions ( ) { this . selectedOptions = true ; } public boolean hasOption ( ) { return optionFound ; } public void setOptionFound ( ) { this . optionFound = true ; } } private StackNode [ ] stack ; private int currentPtr ; public Html4Assertions ( ) { super ( ) ; } private void push ( StackNode node ) { currentPtr ++ ; if ( currentPtr == stack . length ) { StackNode [ ] newStack = new StackNode [ stack . length + 64 ] ; System . arraycopy ( stack , 0 , newStack , 0 , stack . length ) ; stack = newStack ; } stack [ currentPtr ] = node ; } private StackNode pop ( ) { return stack [ currentPtr -- ] ; } private StackNode peek ( ) { return stack [ currentPtr ] ; } private Map < StackNode , Locator > openSingleSelects = new HashMap < StackNode , Locator > ( ) ; private LinkedHashSet < IdrefLocator > formControlReferences = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > formControlIds = new HashSet < String > ( ) ; private LinkedHashSet < IdrefLocator > listReferences = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > listIds = new HashSet < String > ( ) ; private Set < String > allIds = new HashSet < String > ( ) ; @ Override public void endDocument ( ) throws SAXException { for ( IdrefLocator idrefLocator : formControlReferences ) { if ( ! formControlIds . contains ( idrefLocator . getIdref ( ) ) ) { err ( "The “for” attribute of the " + "“label” element must refer to " + "a form control." , idrefLocator . getLocator ( ) ) ; } } reset ( ) ; stack = null ; } @ Override public void endElement ( String uri , String localName , String name ) throws SAXException { StackNode node = pop ( ) ; openSingleSelects . remove ( node ) ; if ( "http://www.w3.org/1999/xhtml" == uri ) { if ( "option" == localName && ! stack [ currentPtr ] . hasOption ( ) ) { stack [ currentPtr ] . setOptionFound ( ) ; } } } @ Override public void startDocument ( ) throws SAXException { reset ( ) ; stack = new StackNode [ 32 ] ; currentPtr = 0 ; stack [ 0 ] = null ; } public void reset ( ) { openSingleSelects . clear ( ) ; formControlReferences . clear ( ) ; formControlIds . clear ( ) ; listReferences . clear ( ) ; listIds . clear ( ) ; allIds . clear ( ) ; } @ Override public void startElement ( String uri , String localName , String name , Attributes atts ) throws SAXException { Set < String > ids = new HashSet < String > ( ) ; String role = null ; String activeDescendant = null ; String forAttr = null ; boolean href = false ; boolean hreflang = false ; StackNode parent = peek ( ) ; int ancestorMask = 0 ; if ( parent != null ) { ancestorMask = parent . getAncestorMask ( ) ; } if ( "http://www.w3.org/1999/xhtml" == uri ) { boolean hidden = false ; boolean usemap = false ; boolean selected = false ; String xmlLang = null ; String lang = null ; int len = atts . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { String attUri = atts . getURI ( i ) ; if ( attUri . length ( ) == 0 ) { String attLocal = atts . getLocalName ( i ) ; if ( "href" == attLocal ) { href = true ; } else if ( "hreflang" == attLocal ) { hreflang = true ; } else if ( "lang" == attLocal ) { lang = atts . getValue ( i ) ; } else if ( "for" == attLocal && "label" == localName ) { forAttr = atts . getValue ( i ) ; ancestorMask |= LABEL_FOR_MASK ; } else if ( "selected" == attLocal ) { selected = true ; } else if ( "usemap" == attLocal && "input" != localName ) { usemap = true ; } } else if ( "http://www.w3.org/XML/1998/namespace" == attUri ) { if ( "lang" == atts . getLocalName ( i ) ) { xmlLang = atts . getValue ( i ) ; } } if ( atts . getType ( i ) == "ID" ) { String attVal = atts . getValue ( i ) ; if ( attVal . length ( ) != 0 ) { ids . add ( attVal ) ; } } } Integer maskAsObject ; int mask = 0 ; String descendantUiString = "" ; if ( ( maskAsObject = ANCESTOR_MASK_BY_DESCENDANT . get ( localName ) ) != null ) { mask = maskAsObject . intValue ( ) ; descendantUiString = localName ; } else if ( "img" == localName && usemap ) { mask = BUTTON_MASK ; descendantUiString = "img” with the attribute “usemap" ; } if ( mask != 0 ) { int maskHit = ancestorMask & mask ; if ( maskHit != 0 ) { for ( int j = 0 ; j < SPECIAL_ANCESTORS . length ; j ++ ) { if ( ( maskHit & 1 ) != 0 ) { err ( "The element “" + descendantUiString + "” must not appear as a descendant " + "of the element “" + SPECIAL_ANCESTORS [ j ] + "”." ) ; } maskHit >>= 1 ; } } } if ( lang != null && ( xmlLang == null || ! equalsIgnoreAsciiCase ( lang , xmlLang ) ) ) { err ( "When attribute “lang” in no namespace " + "is specified, attribute “lang” in the XML " + "namespace must also be specified, and both " + "attributes must have the same value." ) ; } if ( "label" == localName ) { String forVal = atts . getValue ( "" , "for" ) ; if ( forVal != null ) { formControlReferences . add ( new IdrefLocator ( new LocatorImpl ( getDocumentLocator ( ) ) , forVal ) ) ; } } if ( ( "input" == localName && ! hidden ) || "textarea" == localName || "select" == localName || "button" == localName ) { formControlIds . addAll ( ids ) ; } if ( "input" == localName && ( lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "radio" , atts . getValue ( "" , "type" ) ) || lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "checkbox" , atts . getValue ( "" , "type" ) ) ) ) { if ( atts . getValue ( "" , "value" ) == null || "" . equals ( atts . getValue ( "" , "value" ) ) ) { err ( "Element “input” with attribute " + "“type” whose value is “radio” " + "or “checkbox” " + "must have non-empty attribute “value”." ) ; } } if ( "option" == localName && selected ) { for ( Map . Entry < StackNode , Locator > entry : openSingleSelects . entrySet ( ) ) { StackNode node = entry . getKey ( ) ; if ( node . isSelectedOptions ( ) ) { err ( "The “select” element must not have more " + "than one selected “option” descendant " + "unless the “multiple” attribute is specified." ) ; } else { node . setSelectedOptions ( ) ; } } } } if ( "http://www.w3.org/1999/xhtml" == uri ) { int number = specialAncestorNumber ( localName ) ; if ( number > - 1 ) { ancestorMask |= ( 1 << number ) ; } if ( "a" == localName && hreflang && ! href ) { err ( "Element “a” with attribute " + "“hreflang” must have " + "“href” attribute." ) ; } StackNode child = new StackNode ( ancestorMask , localName , role , activeDescendant , forAttr ) ; if ( "select" == localName && atts . getIndex ( "" , "multiple" ) == - 1 ) { openSingleSelects . put ( child , getDocumentLocator ( ) ) ; } push ( child ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
