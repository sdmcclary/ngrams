public class Html4Assertions extends Checker { private static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString ( String lowerCaseLiteral , String string ) { if ( string == null ) { return false ; } if ( lowerCaseLiteral . length ( ) != string . length ( ) ) { return false ; } for ( int i = 0 ; i < lowerCaseLiteral . length ( ) ; i ++ ) { char c0 = lowerCaseLiteral . charAt ( i ) ; char c1 = string . charAt ( i ) ; if ( c1 >= 'A' && c1 <= 'Z' ) { c1 += 0x20 ; } if ( c0 != c1 ) { return false ; } } return true ; } private static boolean equalsIgnoreAsciiCase ( String one , String other ) { if ( other == null ) { if ( one == null ) { return true ; } else { return false ; } } if ( one . length ( ) != other . length ( ) ) { return false ; } for ( int i = 0 ; i < one . length ( ) ; i ++ ) { char c0 = one . charAt ( i ) ; char c1 = other . charAt ( i ) ; if ( c0 >= 'A' && c0 <= 'Z' ) { c0 += 0x20 ; } if ( c1 >= 'A' && c1 <= 'Z' ) { c1 += 0x20 ; } if ( c0 != c1 ) { return false ; } } return true ; } private static final String [ ] SPECIAL_ANCESTORS = { "a" , "button" , "form" , "label" , "pre" } ; private static int specialAncestorNumber ( String name ) { for ( int i = 0 ; i < SPECIAL_ANCESTORS . length ; i ++ ) { if ( name == SPECIAL_ANCESTORS [ i ] ) { return i ; } } return - 1 ; } private static Map < String , Integer > ANCESTOR_MASK_BY_DESCENDANT = new HashMap < String , Integer > ( ) ; private static void registerProhibitedAncestor ( String ancestor , String descendant ) { int number = specialAncestorNumber ( ancestor ) ; if ( number == - 1 ) { throw new IllegalStateException ( "Ancestor not found in array: " + ancestor ) ; } Integer maskAsObject = ANCESTOR_MASK_BY_DESCENDANT . get ( descendant ) ; int mask = 0 ; if ( maskAsObject != null ) { mask = maskAsObject . intValue ( ) ; } mask |= ( 1 << number ) ; ANCESTOR_MASK_BY_DESCENDANT . put ( descendant , new Integer ( mask ) ) ; } static { registerProhibitedAncestor ( "a" , "a" ) ; registerProhibitedAncestor ( "button" , "a" ) ; registerProhibitedAncestor ( "button" , "button" ) ; registerProhibitedAncestor ( "button" , "fieldset" ) ; registerProhibitedAncestor ( "button" , "form" ) ; registerProhibitedAncestor ( "button" , "iframe" ) ; registerProhibitedAncestor ( "button" , "input" ) ; registerProhibitedAncestor ( "button" , "isindex" ) ; registerProhibitedAncestor ( "button" , "select" ) ; registerProhibitedAncestor ( "button" , "textarea" ) ; registerProhibitedAncestor ( "form" , "form" ) ; registerProhibitedAncestor ( "label" , "label" ) ; registerProhibitedAncestor ( "pre" , "pre" ) ; registerProhibitedAncestor ( "pre" , "img" ) ; registerProhibitedAncestor ( "pre" , "object" ) ; registerProhibitedAncestor ( "pre" , "applet" ) ; registerProhibitedAncestor ( "pre" , "big" ) ; registerProhibitedAncestor ( "pre" , "small" ) ; registerProhibitedAncestor ( "pre" , "sub" ) ; registerProhibitedAncestor ( "pre" , "sup" ) ; registerProhibitedAncestor ( "pre" , "font" ) ; } private static final int BUTTON_MASK = ( 1 << specialAncestorNumber ( "button" ) ) ; private static final int LABEL_FOR_MASK = ( 1 << 28 ) ; private class IdrefLocator { private final Locator locator ; private final String idref ; public IdrefLocator ( Locator locator , String idref ) { this . locator = new LocatorImpl ( locator ) ; this . idref = idref ; } public Locator getLocator ( ) { return locator ; } public String getIdref ( ) { return idref ; } } private class StackNode { private final int ancestorMask ; private boolean selectedOptions = false ; private boolean optionFound = false ; public StackNode ( int ancestorMask , String name , String role , String activeDescendant , String forAttr ) { this . ancestorMask = ancestorMask ; } public int getAncestorMask ( ) { return ancestorMask ; } public boolean isSelectedOptions ( ) { return selectedOptions ; } public void setSelectedOptions ( ) { this . selectedOptions = true ; } public boolean hasOption ( ) { return optionFound ; } public void setOptionFound ( ) { this . optionFound = true ; } } private StackNode [ ] stack ; private int currentPtr ; public Html4Assertions ( ) { super ( ) ; } private void push ( StackNode node ) { currentPtr ++ ; if ( currentPtr == stack . length ) { StackNode [ ] newStack = new StackNode [ stack . length + 64 ] ; System . arraycopy ( stack , 0 , newStack , 0 , stack . length ) ; stack = newStack ; } stack [ currentPtr ] = node ; } private StackNode pop ( ) { return stack [ currentPtr -- ] ; } private StackNode peek ( ) { return stack [ currentPtr ] ; } private Map < StackNode , Locator > openSingleSelects = new HashMap < StackNode , Locator > ( ) ; private LinkedHashSet < IdrefLocator > formControlReferences = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > formControlIds = new HashSet < String > ( ) ; private LinkedHashSet < IdrefLocator > listReferences = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > listIds = new HashSet < String > ( ) ; private Set < String > allIds = new HashSet < String > ( ) ; @ Override public void endDocument ( ) throws SAXException { for ( IdrefLocator idrefLocator : formControlReferences ) { if ( ! formControlIds . contains ( idrefLocator . getIdref ( ) ) ) { err ( "The “for” attribute of the " + "“label” element must refer to " + "a form control." , idrefLocator . getLocator ( ) ) ; } } reset ( ) ; stack = null ; } @ Override public void endElement ( String uri , String localName , String name ) throws SAXException { StackNode node = pop ( ) ; openSingleSelects . remove ( node ) ; if ( "http://www.w3.org/1999/xhtml" == uri ) { if ( "option" == localName && ! stack [ currentPtr ] . hasOption ( ) ) { stack [ currentPtr ] . setOptionFound ( ) ; } } } @ Override public void startDocument ( ) throws SAXException { reset ( ) ; stack = new StackNode [ 32 ] ; currentPtr = 0 ; stack [ 0 ] = null ; } public void reset ( ) { openSingleSelects . clear ( ) ; formControlReferences . clear ( ) ; formControlIds . clear ( ) ; listReferences . clear ( ) ; listIds . clear ( ) ; allIds . clear ( ) ; } @ Override public void startElement ( String uri , String localName , String name , Attributes atts ) throws SAXException { Set < String > ids = new HashSet < String > ( ) ; String role = null ; String activeDescendant = null ; String forAttr = null ; boolean href = false ; boolean hreflang = false ; StackNode parent = peek ( ) ; int ancestorMask = 0 ; if ( parent != null ) { ancestorMask = parent . getAncestorMask ( ) ; } if ( "http://www.w3.org/1999/xhtml" == uri ) { boolean hidden = false ; boolean usemap = false ; boolean selected = false ; String xmlLang = null ; String lang = null ; int len = atts . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { String attUri = atts . getURI ( i ) ; if ( attUri . length ( ) == 0 ) { String attLocal = atts . getLocalName ( i ) ; if ( "href" == attLocal ) { href = true ; } else if ( "hreflang" == attLocal ) { hreflang = true ; } else if ( "lang" == attLocal ) { lang = atts . getValue ( i ) ; } else if ( "for" == attLocal && "label" == localName ) { forAttr = atts . getValue ( i ) ; ancestorMask |= LABEL_FOR_MASK ; } else if ( "selected" == attLocal ) { selected = true ; } else if ( "usemap" == attLocal && "input" != localName ) { usemap = true ; } } else if ( "http://www.w3.org/XML/1998/namespace" == attUri ) { if ( "lang" == atts . getLocalName ( i ) ) { xmlLang = atts . getValue ( i ) ; } } if ( atts . getType ( i ) == "ID" ) { String attVal = atts . getValue ( i ) ; if ( attVal . length ( ) != 0 ) { ids . add ( attVal ) ; } } } Integer maskAsObject ; int mask = 0 ; String descendantUiString = "" ; if ( ( maskAsObject = ANCESTOR_MASK_BY_DESCENDANT . get ( localName ) ) != null ) { mask = maskAsObject . intValue ( ) ; descendantUiString = localName ; } else if ( "img" == localName && usemap ) { mask = BUTTON_MASK ; descendantUiString = "img” with the attribute “usemap" ; } if ( mask != 0 ) { int maskHit = ancestorMask & mask ; if ( maskHit != 0 ) { for ( int j = 0 ; j < SPECIAL_ANCESTORS . length ; j ++ ) { if ( ( maskHit & 1 ) != 0 ) { err ( "The element “" + descendantUiString + "” must not appear as a descendant " + "of the element “" + SPECIAL_ANCESTORS [ j ] + "”." ) ; } maskHit >>= 1 ; } } } if ( lang != null && ( xmlLang == null || ! equalsIgnoreAsciiCase ( lang , xmlLang ) ) ) { err ( "When attribute “lang” in no namespace " + "is specified, attribute “lang” in the XML " + "namespace must also be specified, and both " + "attributes must have the same value." ) ; } if ( "label" == localName ) { String forVal = atts . getValue ( "" , "for" ) ; if ( forVal != null ) { formControlReferences . add ( new IdrefLocator ( new LocatorImpl ( getDocumentLocator ( ) ) , forVal ) ) ; } } if ( ( "input" == localName && ! hidden ) || "textarea" == localName || "select" == localName || "button" == localName ) { formControlIds . addAll ( ids ) ; } if ( "input" == localName && ( lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "radio" , atts . getValue ( "" , "type" ) ) || lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "checkbox" , atts . getValue ( "" , "type" ) ) ) ) { if ( atts . getValue ( "" , "value" ) == null || "" . equals ( atts . getValue ( "" , "value" ) ) ) { err ( "Element “input” with attribute " + "“type” whose value is “radio” " + "or “checkbox” " + "must have non-empty attribute “value”." ) ; } } if ( "option" == localName && selected ) { for ( Map . Entry < StackNode , Locator > entry : openSingleSelects . entrySet ( ) ) { StackNode node = entry . getKey ( ) ; if ( node . isSelectedOptions ( ) ) { err ( "The “select” element must not have more " + "than one selected “option” descendant " + "unless the “multiple” attribute is specified." ) ; } else { node . setSelectedOptions ( ) ; } } } } if ( "http://www.w3.org/1999/xhtml" == uri ) { int number = specialAncestorNumber ( localName ) ; if ( number > - 1 ) { ancestorMask |= ( 1 << number ) ; } if ( "a" == localName && hreflang && ! href ) { err ( "Element “a” with attribute " + "“hreflang” must have " + "“href” attribute." ) ; } StackNode child = new StackNode ( ancestorMask , localName , role , activeDescendant , forAttr ) ; if ( "select" == localName && atts . getIndex ( "" , "multiple" ) == - 1 ) { openSingleSelects . put ( child , getDocumentLocator ( ) ) ; } push ( child ) ; } } } 