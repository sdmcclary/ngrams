public final class ToolBarContributionRegistryImpl { private static final String TOOLBAR_ID = "com.aptana.ide.editors.toolbarContribution" ; private static final Object TAG_ELEMENT = "element" ; private static final String ATTR_CLASS = "class" ; private static final String ATTR_LANGUAGE = "language" ; private static final Object TAG_CONTRIBUTOR = "contributor" ; private static Map toolBarContributions = new HashMap ( ) ; private static Map toolBarContributionNames = new HashMap ( ) ; static WeakHashMap map = new WeakHashMap ( ) ; static WeakHashMap mapListener = new WeakHashMap ( ) ; private static IToolbarContributionRegistry toolbarContributionRegistry = new IToolbarContributionRegistry ( ) { public void addContribution ( String language , ToolBarContribution tc ) { ToolBarContributionRegistryImpl . addContribution ( language , tc ) ; } public void removeContribution ( String language , ToolBarContribution cont ) { ToolBarContributionRegistryImpl . removeContribution ( language , cont ) ; } public List getContributions ( String language ) { return ToolBarContributionRegistryImpl . getContributions ( language ) ; } } ; public static IToolbarContributionRegistry getInstance ( ) { return toolbarContributionRegistry ; } private static List getContributions ( String language ) { List list = ( List ) toolBarContributions . get ( language ) ; if ( list == null ) { list = new ArrayList ( ) ; } return list ; } static { loadToolBarContributions ( ) ; } private static final class ContextListener implements ISelectionChangedListener { private final IToolBarManager toolBarManager ; private final TextViewer tv ; private final IUnifiedEditor activeEditor ; private ContextListener ( IToolBarManager toolBarManager , TextViewer tv , IUnifiedEditor activeEditor ) { this . toolBarManager = toolBarManager ; this . tv = tv ; this . activeEditor = activeEditor ; } public void selectionChanged ( SelectionChangedEvent event ) { ITextSelection ts = ( ITextSelection ) event . getSelection ( ) ; int offset = ts . getOffset ( ) ; try { String type = TextUtilities . getContentType ( tv . getDocument ( ) , UnifiedConfiguration . UNIFIED_PARTITIONING , offset , true ) ; doUpdate ( type ) ; } catch ( BadLocationException e ) { return ; } } public void updateIfNeeded ( String chType ) { if ( tv . getTextWidget ( ) . isDisposed ( ) ) { return ; } ITextSelection ts = ( ITextSelection ) tv . getSelection ( ) ; int offset = ts . getOffset ( ) ; try { String type = TextUtilities . getContentType ( tv . getDocument ( ) , UnifiedConfiguration . UNIFIED_PARTITIONING , offset , true ) ; if ( chType . equals ( type ) ) { updateToolbar ( toolBarManager , type , activeEditor ) ; toolBarManager . update ( false ) ; } } catch ( BadLocationException e ) { return ; } } private void doUpdate ( String type ) { if ( type != null && ! type . equals ( map . get ( activeEditor ) ) ) { map . put ( activeEditor , type ) ; updateToolbar ( toolBarManager , type , activeEditor ) ; toolBarManager . update ( false ) ; WorkbenchWindow activeWorkbenchWindow = ( WorkbenchWindow ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; activeWorkbenchWindow . getCoolBarManager2 ( ) . update ( true ) ; } } } private ToolBarContributionRegistryImpl ( ) { } static void initToolBar ( final IUnifiedEditor activeEditor , final IToolBarManager toolBarManager ) { String defaultLanguage = activeEditor . getFileContext ( ) . getDefaultLanguage ( ) ; ISourceViewer viewer = activeEditor . getViewer ( ) ; String cLang = ( String ) map . get ( activeEditor ) ; if ( viewer instanceof TextViewer && cLang == null ) { final TextViewer tv = ( TextViewer ) viewer ; map . put ( activeEditor , defaultLanguage ) ; final ContextListener selectionChangedListener = new ContextListener ( toolBarManager , tv , activeEditor ) ; tv . addPostSelectionChangedListener ( selectionChangedListener ) ; mapListener . put ( activeEditor , selectionChangedListener ) ; tv . getTextWidget ( ) . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { tv . removePostSelectionChangedListener ( selectionChangedListener ) ; mapListener . remove ( activeEditor ) ; } } ) ; tv . getTextWidget ( ) . addFocusListener ( new FocusListener ( ) { public void focusGained ( FocusEvent e ) { map . remove ( activeEditor ) ; selectionChangedListener . selectionChanged ( new SelectionChangedEvent ( tv , tv . getSelection ( ) ) ) ; } public void focusLost ( FocusEvent e ) { } } ) ; } if ( cLang != null ) { defaultLanguage = cLang ; } updateToolbar ( toolBarManager , defaultLanguage , activeEditor ) ; } private static void updateToolbar ( final IToolBarManager toolBarManager , String defaultLanguage , final IUnifiedEditor editor ) { toolBarManager . removeAll ( ) ; ArrayList contributions = ( ArrayList ) toolBarContributions . get ( defaultLanguage ) ; if ( contributions != null ) { for ( Iterator iterator = contributions . iterator ( ) ; iterator . hasNext ( ) ; ) { final ToolBarContribution name = ( ToolBarContribution ) iterator . next ( ) ; Action action = new Action ( name . getText ( ) , Action . AS_PUSH_BUTTON ) { public void run ( ) { IToolBarMember member = ( IToolBarMember ) name . getInstance ( ) ; member . execute ( editor , name . getText ( ) ) ; } } ; action . setImageDescriptor ( name . getIcon ( ) ) ; action . setToolTipText ( name . getTooltipText ( ) ) ; toolBarManager . add ( action ) ; } } } private static void loadToolBarContributions ( ) { IExtensionRegistry registry = Platform . getExtensionRegistry ( ) ; IExtensionPoint ep = registry . getExtensionPoint ( TOOLBAR_ID ) ; if ( ep != null ) { IExtension [ ] extensions = ep . getExtensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { IExtension extension = extensions [ i ] ; IConfigurationElement [ ] elements = extension . getConfigurationElements ( ) ; for ( int j = 0 ; j < elements . length ; j ++ ) { try { IConfigurationElement element = elements [ j ] ; String elementName = element . getName ( ) ; if ( elementName . equals ( TAG_CONTRIBUTOR ) ) { IToolbarRegistryContributor contributor = ( IToolbarRegistryContributor ) element . createExecutableExtension ( ATTR_CLASS ) ; contributor . contributeToToolbarRegistry ( toolbarContributionRegistry ) ; } } catch ( Exception e ) { IdeLog . log ( UnifiedEditorsPlugin . getDefault ( ) , IStatus . ERROR , "Exception while initializing toolbar contribution registry" , e ) ; } } for ( int j = 0 ; j < elements . length ; j ++ ) { IConfigurationElement element = elements [ j ] ; String elementName = element . getName ( ) ; try { if ( elementName . equals ( TAG_ELEMENT ) ) { String parserClass = element . getAttribute ( ATTR_CLASS ) ; String language = element . getAttribute ( ATTR_LANGUAGE ) ; String icon = element . getAttribute ( "icon" ) ; String text = element . getAttribute ( "name" ) ; String tooltip = element . getAttribute ( "tooltip" ) ; InstanceCreator creator = null ; if ( parserClass != null && language != null && language . length ( ) > 0 ) { creator = new InstanceCreator ( element , ATTR_CLASS ) ; } String namespaceIdentifier = extension . getNamespaceIdentifier ( ) ; ImageDescriptor desc = null ; if ( icon != null && icon . length ( ) > 0 ) { desc = ImageDescriptor . createFromURL ( Platform . getBundle ( namespaceIdentifier ) . getEntry ( icon ) ) ; } ToolBarContribution tc = new ToolBarContribution ( text , tooltip , desc , creator ) ; addContribution ( language , tc ) ; } } catch ( Exception e ) { IdeLog . log ( UnifiedEditorsPlugin . getDefault ( ) , IStatus . ERROR , "Exception while initializing toolbar contribution registry" , e ) ; } } } } } private static void addContribution ( String language , ToolBarContribution tc ) { HashSet set = ( HashSet ) toolBarContributionNames . get ( language ) ; if ( set == null ) { set = new HashSet ( ) ; toolBarContributionNames . put ( language , set ) ; } if ( set . contains ( tc . getText ( ) ) ) { return ; } set . add ( tc . getText ( ) ) ; ArrayList list = ( ArrayList ) toolBarContributions . get ( language ) ; if ( list == null ) { list = new ArrayList ( ) ; toolBarContributions . put ( language , list ) ; } list . add ( tc ) ; update ( language ) ; } private static void removeContribution ( String language , ToolBarContribution cont ) { ArrayList list = ( ArrayList ) toolBarContributions . get ( language ) ; HashSet set = ( HashSet ) toolBarContributionNames . get ( language ) ; if ( list == null ) { return ; } boolean remove = list . remove ( cont ) ; if ( remove ) { set . remove ( cont . getText ( ) ) ; update ( language ) ; } } private static void update ( String language ) { for ( Iterator iterator = mapListener . values ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { ContextListener name = ( ContextListener ) iterator . next ( ) ; name . updateIfNeeded ( language ) ; } } } 