<<<<<<< HEAD
public final class ActivityIndicatorView extends JPanel { private static ActivityIndicatorView INSTANCE ; private static final int BLINK_PERIOD = 400 ; private NetworkActivityIndicator indNetwork ; private ActivityIndicatorBox indDisk ; private List ticketsWebStats = new Vector ( ) ; private List ticketsDisk = new Vector ( ) ; private List ticketsCommon = new Vector ( ) ; public ActivityIndicatorView ( ConnectionState connectionState , MouseListener connectionMouseListener ) { indDisk = new ActivityIndicatorBox ( ResourceUtils . getIcon ( ResourceID . ICON_ACTIVITY_DISK_ACTIVE ) , ResourceUtils . getIcon ( ResourceID . ICON_ACTIVITY_DISK_PASSIVE ) ) ; indNetwork = new NetworkActivityIndicator ( connectionState , ResourceUtils . getIcon ( ResourceID . ICON_CONNECTED ) , ResourceUtils . getIcon ( ResourceID . ICON_DISCONNECTED ) , ResourceUtils . getIcon ( ResourceID . ICON_ACTIVITY_NETWORK_ACTIVE ) , ResourceUtils . getIcon ( ResourceID . ICON_ACTIVITY_NETWORK_PASSIVE ) ) ; indNetwork . addMouseListener ( connectionMouseListener ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; add ( indDisk ) ; add ( indNetwork ) ; java . util . Timer blinker = new java . util . Timer ( true ) ; blinker . scheduleAtFixedRate ( new Blinker ( ) , 0 , BLINK_PERIOD ) ; INSTANCE = this ; } public static synchronized ActivityTicket startDiscovery ( String link ) { return INSTANCE . startActivity ( ActivityTicket . TYPE_NETWORK , MessageFormat . format ( Strings . message ( "activity.discovering" ) , new Object [ ] { link } ) ) ; } public static synchronized ActivityTicket startPolling ( String feed ) { return INSTANCE . startActivity ( ActivityTicket . TYPE_NETWORK , MessageFormat . format ( Strings . message ( "activity.polling" ) , new Object [ ] { feed } ) ) ; } public static synchronized ActivityTicket startOpeningDatabase ( ) { return INSTANCE . startActivity ( ActivityTicket . TYPE_DISK , Strings . message ( "activity.opening.database" ) ) ; } private ActivityTicket startActivity ( final int type , String title ) { ActivityTicket ticket ; ticket = new ActivityTicket ( type , title ) ; List tickets = getTicketsByType ( type ) ; if ( tickets . add ( ticket ) ) updateBox ( type ) ; return ticket ; } public static synchronized void finishActivity ( ActivityTicket ticket ) { final int type = ticket . getType ( ) ; List tickets = INSTANCE . getTicketsByType ( type ) ; if ( tickets . remove ( ticket ) ) INSTANCE . updateBox ( type ) ; } private void updateBox ( final int aType ) { List ticketsL = getTicketsByType ( aType ) ; final String [ ] tasks = new String [ ticketsL . size ( ) ] ; for ( int i = 0 ; i < ticketsL . size ( ) ; i ++ ) { ActivityTicket ticket = ( ActivityTicket ) ticketsL . get ( i ) ; tasks [ i ] = ticket . getDisplayInfo ( ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( aType == ActivityTicket . TYPE_NETWORK ) { indNetwork . setTasks ( tasks ) ; } else { indDisk . setTasksList ( tasks ) ; } } } ) ; } private List getTicketsByType ( int type ) { List tickets ; switch ( type ) { case ActivityTicket . TYPE_NETWORK : tickets = ticketsWebStats ; break ; case ActivityTicket . TYPE_DISK : tickets = ticketsDisk ; break ; default : tickets = ticketsCommon ; break ; } return tickets ; } static int getNumberOfTasks ( int aType ) { return INSTANCE . getTicketsByType ( aType ) . size ( ) ; } private class Blinker extends TimerTask { private final Blink active = new Blink ( true ) ; private final Blink passive = new Blink ( false ) ; private int count = 0 ; public void run ( ) { boolean activeState = count ++ % 2 == 0 ; SwingUtilities . invokeLater ( activeState ? active : passive ) ; } } private class Blink implements Runnable { private final boolean activeState ; public Blink ( boolean aActiveState ) { activeState = aActiveState ; } public void run ( ) { indDisk . blink ( activeState ) ; indNetwork . blink ( ) ; } } private static class NetworkActivityIndicator extends JLabel { private static final String OFFLINE = Strings . message ( "activity.offline" ) ; private static final String ONLINE = Strings . message ( "activity.online" ) ; private final ConnectionState conState ; private final Icon connected ; private final Icon disconnected ; private final Icon active ; private final Icon inactive ; private String tasksList ; public NetworkActivityIndicator ( ConnectionState conState , Icon connected , Icon disconnected , Icon active , Icon inactive ) { this . conState = conState ; this . connected = connected ; this . disconnected = disconnected ; this . active = active ; this . inactive = inactive ; setHorizontalAlignment ( SwingConstants . CENTER ) ; Dimension size = new Dimension ( 0 , 0 ) ; size = findMaxSize ( size , connected ) ; size = findMaxSize ( size , disconnected ) ; size = findMaxSize ( size , active ) ; size = findMaxSize ( size , inactive ) ; setMinimumSize ( size ) ; setMaximumSize ( size ) ; setPreferredSize ( size ) ; } private static Dimension findMaxSize ( Dimension size , Icon icon ) { size . width = Math . max ( size . width , icon . getIconWidth ( ) ) ; size . height = Math . max ( size . height , icon . getIconHeight ( ) ) ; return size ; } private void updateIconAndTooltip ( ) { Icon icon ; String tooltip ; if ( ! conState . isOnline ( ) ) { icon = disconnected ; tooltip = OFFLINE ; } else { if ( tasksList == null ) { icon = connected ; tooltip = ONLINE ; } else { long time = System . currentTimeMillis ( ) ; boolean activeIcon = ( time / BLINK_PERIOD ) % 2 == 0 ; icon = activeIcon ? active : inactive ; tooltip = tasksList ; } } setIcon ( icon ) ; setToolTipText ( tooltip ) ; } public void setTasks ( String [ ] tasks ) { tasksList = tasks == null || tasks . length == 0 ? null : "<html>" + StringUtils . join ( tasks , "<br>" ) ; updateIconAndTooltip ( ) ; } public void blink ( ) { updateIconAndTooltip ( ) ; } } } 
=======
class StartTagOpenDerivFunction extends AbstractPatternFunction < Pattern > { private final Name name ; private final ValidatorPatternBuilder builder ; StartTagOpenDerivFunction ( Name name , ValidatorPatternBuilder builder ) { this . name = name ; this . builder = builder ; } public Pattern caseChoice ( ChoicePattern p ) { return builder . makeChoice ( memoApply ( p . getOperand1 ( ) ) , memoApply ( p . getOperand2 ( ) ) ) ; } public Pattern caseGroup ( GroupPattern p ) { final Pattern p1 = p . getOperand1 ( ) ; final Pattern p2 = p . getOperand2 ( ) ; Pattern tem = memoApply ( p1 ) . apply ( new ApplyAfterFunction ( builder ) { Pattern apply ( Pattern x ) { return builder . makeGroup ( x , p2 ) ; } } ) ; return p1 . isNullable ( ) ? builder . makeChoice ( tem , memoApply ( p2 ) ) : tem ; } public Pattern caseInterleave ( InterleavePattern p ) { final Pattern p1 = p . getOperand1 ( ) ; final Pattern p2 = p . getOperand2 ( ) ; return builder . makeChoice ( memoApply ( p1 ) . apply ( new ApplyAfterFunction ( builder ) { Pattern apply ( Pattern x ) { return builder . makeInterleave ( x , p2 ) ; } } ) , memoApply ( p2 ) . apply ( new ApplyAfterFunction ( builder ) { Pattern apply ( Pattern x ) { return builder . makeInterleave ( p1 , x ) ; } } ) ) ; } public Pattern caseAfter ( AfterPattern p ) { final Pattern p1 = p . getOperand1 ( ) ; final Pattern p2 = p . getOperand2 ( ) ; return memoApply ( p1 ) . apply ( new ApplyAfterFunction ( builder ) { Pattern apply ( Pattern x ) { return builder . makeAfter ( x , p2 ) ; } } ) ; } public Pattern caseOneOrMore ( final OneOrMorePattern p ) { final Pattern p1 = p . getOperand ( ) ; return memoApply ( p1 ) . apply ( new ApplyAfterFunction ( builder ) { Pattern apply ( Pattern x ) { return builder . makeGroup ( x , builder . makeOptional ( p ) ) ; } } ) ; } public Pattern caseElement ( ElementPattern p ) { if ( ! p . getNameClass ( ) . contains ( name ) ) return builder . makeNotAllowed ( ) ; return builder . makeAfter ( p . getContent ( ) , builder . makeEmpty ( ) ) ; } public Pattern caseOther ( Pattern p ) { return builder . makeNotAllowed ( ) ; } final Pattern memoApply ( Pattern p ) { return apply ( builder . getPatternMemo ( p ) ) . getPattern ( ) ; } PatternMemo apply ( PatternMemo memo ) { return memo . startTagOpenDeriv ( this ) ; } Name getName ( ) { return name ; } ValidatorPatternBuilder getPatternBuilder ( ) { return builder ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
