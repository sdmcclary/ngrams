<<<<<<< HEAD
public class FeedsPanel extends CoolInternalFrame { private static final Logger LOG = Logger . getLogger ( FeedsPanel . class . getName ( ) ) ; protected static final int INITIAL_VISIBLE_ROWS = 15 ; protected static final int FIXED_CHAN_CELL_WIDTH = 185 ; protected static final int FIXED_CHAN_CELL_HEIGHT = 35 ; private static final int PROGRESS_ICON_FRAME_PAUSE = 750 ; protected DNDList feedsList ; protected JScrollPane scrollPane ; private FeedsListCellRenderer cellRenderer ; private UnreadActivityController activityController ; private JLabel lbNoGuideSelected ; private Action onDoubleClickAction ; public FeedsPanel ( ) { super ( Strings . message ( "panel.feeds" ) ) ; lbNoGuideSelected = new JLabel ( Strings . message ( "panel.feeds.no.guide.selected" ) ) ; lbNoGuideSelected . setHorizontalAlignment ( SwingUtilities . CENTER ) ; setHeaderControl ( createSubtoolbar ( ) ) ; GlobalModel globalModel = GlobalModel . SINGLETON ; GuideModel model = globalModel . getGuideModel ( ) ; feedsList = new DNDList ( model ) ; model . setListComponent ( feedsList ) ; setBackground ( feedsList . getBackground ( ) ) ; final ControllerListener l = new ControllerListener ( ) ; GlobalController . SINGLETON . addControllerListener ( l ) ; setPreferredSize ( new Dimension ( FIXED_CHAN_CELL_WIDTH , FIXED_CHAN_CELL_HEIGHT ) ) ; UserPreferences prefs = globalModel . getUserPreferences ( ) ; long delay = prefs . getFeedSelectionDelay ( ) ; FeedSelectionListener selListener = new FeedSelectionListener ( delay ) ; prefs . addPropertyChangeListener ( UserPreferences . PROP_FEED_SELECTION_DELAY , selListener ) ; feedsList . addListSelectionListener ( selListener ) ; feedsList . addMouseListener ( selListener ) ; RenderingManager . addPropertyChangeListener ( new RenderSettingsChangeListener ( ) ) ; new LoadingIconRepainter ( feedsList , PROGRESS_ICON_FRAME_PAUSE ) . start ( ) ; cellRenderer = new FeedsListCellRenderer ( ) ; onListColorsUpdate ( ) ; feedsList . setCellRenderer ( cellRenderer ) ; feedsList . setSelectionMode ( ListSelectionModel . MULTIPLE_INTERVAL_SELECTION ) ; feedsList . setVisibleRowCount ( INITIAL_VISIBLE_ROWS ) ; Dimension cellSize = cellRenderer . getFixedCellSize ( ) ; feedsList . setFixedCellWidth ( cellSize . width ) ; feedsList . setFixedCellHeight ( cellSize . height ) ; scrollPane = UIFactory . createStrippedScrollPane ( feedsList ) ; scrollPane . setMinimumSize ( new Dimension ( cellSize . width + 55 , cellSize . height ) ) ; scrollPane . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setViewportView ( feedsList ) ; add ( scrollPane ) ; final MainFrame mainFrame = GlobalController . SINGLETON . getMainFrame ( ) ; feedsList . addMouseListener ( mainFrame . getFeedsListPopupAdapter ( ) ) ; addMouseListener ( mainFrame . getFeedsListPopupAdapter ( ) ) ; final FeedsListListener listener = new FeedsListListener ( this ) ; feedsList . addMouseListener ( listener ) ; feedsList . addMouseMotionListener ( listener ) ; feedsList . addPropertyChangeListener ( DNDList . PROP_DRAGGING , new DraggingListListener ( ) ) ; feedsList . setDropTarget ( new URLDropTarget ( new URLDropListener ( ) ) ) ; activityController = new UnreadActivityController ( this ) ; FeedDisplayModeManager . getInstance ( ) . addListener ( new IDisplayModeManagerListener ( ) { public void onClassColorChanged ( int feedClass , Color oldColor , Color newColor ) { feedsList . repaint ( ) ; } } ) ; l . guideSelected ( null ) ; } public void setOnDoubleClickAction ( Action action ) { this . onDoubleClickAction = action ; } private JComponent createSubtoolbar ( ) { UserPreferences uPrefs = GlobalModel . SINGLETON . getUserPreferences ( ) ; String propName = UserPreferences . PROP_GOOD_CHANNEL_STARZ ; PropertyAdapter propertyAdapter = new PropertyAdapter ( uPrefs , propName , true ) ; BoundedRangeAdapter model = new BoundedRangeAdapter ( propertyAdapter , 0 , 1 , 5 ) ; StarsSelectionComponent starsSelector = new StarsSelectionComponent ( model ) ; starsSelector . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; MouseListener tipAdapter = new TipOfTheDay . TipMouseAdapter ( TipOfTheDay . TIP_STARZ_FILTER , true ) ; starsSelector . addMouseListener ( tipAdapter ) ; JPanel pnl = new JPanel ( new BorderLayout ( ) ) ; pnl . add ( starsSelector , BorderLayout . CENTER ) ; return pnl ; } private void updateMainListArea ( IGuide selectedGuide ) { if ( selectedGuide == null ) { remove ( scrollPane ) ; add ( lbNoGuideSelected ) ; } else { remove ( lbNoGuideSelected ) ; add ( scrollPane ) ; } revalidate ( ) ; repaint ( ) ; } public void selectListItem ( final IFeed feed ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { selectListItem0 ( feed ) ; } else { SwingUtilities . invokeLater ( new SelectFeed ( feed ) ) ; } } private void selectListItem0 ( IFeed feed ) { GuideModel model = ( GuideModel ) feedsList . getModel ( ) ; synchronized ( model ) { int index = model . indexOf ( feed ) ; if ( index > - 1 ) { if ( ! feedsList . isSelectedIndex ( index ) ) { feedsList . setSelectedIndex ( index ) ; feedsList . ensureIndexIsVisible ( index ) ; } } else { feedsList . clearSelection ( ) ; } } } public JList getFeedsList ( ) { return feedsList ; } public UnreadActivityController getUnreadActivityController ( ) { return activityController ; } public Component returnFocusableComponent ( ) { return feedsList ; } private void onListColorsUpdate ( ) { Color background = RenderingManager . getFeedsListBackground ( false ) ; feedsList . setBackground ( background ) ; feedsList . repaint ( ) ; } private void updateFeedsListLayout ( ) { cellRenderer . initLayout ( ) ; Dimension size = cellRenderer . getFixedCellSize ( ) ; feedsList . setFixedCellWidth ( size . width ) ; feedsList . setFixedCellHeight ( size . height ) ; feedsList . repaint ( ) ; activityController . resetAttachment ( ) ; } private class URLDropListener implements IURLDropTargetListener { public void urlDropped ( URL url , Point location ) { if ( GlobalController . SINGLETON . checkForNewSubscription ( ) ) return ; final GlobalController controller = GlobalController . SINGLETON ; final IFeed feed = controller . createDirectFeed ( url . toString ( ) , false ) ; if ( feed != null ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { controller . selectFeed ( feed ) ; } } ) ; } } } private class DraggingListListener implements PropertyChangeListener { public void propertyChange ( final PropertyChangeEvent evt ) { final IGuide sourceGuide = GlobalModel . SINGLETON . getSelectedGuide ( ) ; boolean isDraggingFinished = ! ( Boolean ) evt . getNewValue ( ) ; if ( isDraggingFinished && sourceGuide instanceof StandardGuide ) { final DNDList source = DNDListContext . getSource ( ) ; IDNDObject object = DNDListContext . getObject ( ) ; int insertPosition = source . getInsertPosition ( ) ; final Object [ ] feedsI = object . getItems ( ) ; StandardGuide guide = ( StandardGuide ) sourceGuide ; if ( feedsList . isDraggingInternal ( ) ) { final GuideModel model = ( GuideModel ) feedsList . getModel ( ) ; final IFeed currentSelection = GlobalModel . SINGLETON . getSelectedFeed ( ) ; int index = insertPosition ; for ( int i = 0 ; i < feedsI . length ; i ++ ) { IFeed feed = ( IFeed ) feedsI [ feedsI . length - i - 1 ] ; int currentIndex = model . indexOf ( feed ) ; if ( currentIndex < index ) index -- ; GlobalController . SINGLETON . moveFeed ( feed , guide , guide , index ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { int curSelNewIndex = model . indexOf ( currentSelection ) ; boolean curSelIsOnTheList = false ; int [ ] newIndices = new int [ feedsI . length ] ; for ( int i = 0 ; i < feedsI . length ; i ++ ) { newIndices [ i ] = model . indexOf ( ( IFeed ) feedsI [ i ] ) ; curSelIsOnTheList |= newIndices [ i ] == curSelNewIndex ; } ListSelectionModel selModel = source . getSelectionModel ( ) ; if ( ! curSelIsOnTheList ) { selModel . setSelectionInterval ( curSelNewIndex , curSelNewIndex ) ; } else { source . setSelectedIndices ( newIndices ) ; } selModel . setLeadSelectionIndex ( curSelNewIndex ) ; GlobalController . SINGLETON . fireGuideSelected ( sourceGuide ) ; } } ) ; } else { Object destination = DNDListContext . getDestination ( ) ; boolean isCopying = DNDListContext . isFinishedCopying ( ) ; if ( destination instanceof StandardGuide && destination != sourceGuide ) { StandardGuide destGuide = ( StandardGuide ) destination ; for ( Object f : feedsI ) { IFeed feed = ( IFeed ) f ; if ( isCopying ) { destGuide . add ( feed ) ; } else { GlobalController . SINGLETON . moveFeed ( feed , guide , destGuide , destGuide . getFeedsCount ( ) ) ; } } GlobalController . SINGLETON . fireGuideSelected ( guide ) ; if ( guide . getFeedsCount ( ) > 0 ) { GlobalController . SINGLETON . selectFeed ( guide . getFeedAt ( 0 ) ) ; } } } } } } static class UnreadActivityController extends ComponentAdapter implements ListDataListener , ActionListener { private static final String TOOLTIP_MSG_SINGLE = Strings . message ( "panel.feeds.unread.one" ) ; private static final String TOOLTIP_MSG_MANY = Strings . message ( "panel.feeds.unread.many" ) ; private JList feedsList ; private ArticleActivityMeter activityMeter ; private UnreadButton unreadButton ; private int attachedRow ; private IFeed attachedFeed ; UnreadActivityController ( FeedsPanel thePanel ) { feedsList = thePanel . getFeedsList ( ) ; activityMeter = new ArticleActivityMeter ( ) ; unreadButton = new UnreadButton ( ) ; unreadButton . initToolTipMessage ( TOOLTIP_MSG_SINGLE , TOOLTIP_MSG_MANY ) ; attachedRow = - 1 ; attachListeners ( ) ; } void attachListeners ( ) { GlobalModel . SINGLETON . getGuideModel ( ) . addListDataListener ( this ) ; unreadButton . addActionListener ( this ) ; feedsList . addComponentListener ( this ) ; } static UnreadStats calcUnreadStats ( IFeed feed ) { UnreadStats stats = new UnreadStats ( ) ; IArticle [ ] articles = feed . getArticles ( ) ; for ( IArticle art : articles ) { stats . increment ( art . getPublicationDate ( ) , art . isRead ( ) ) ; } return stats ; } void attachButtons ( int row , boolean forceUpdate ) { boolean showUnread = RenderingManager . isShowUnreadInFeeds ( ) ; boolean showActivity = RenderingManager . isShowActivityChart ( ) ; boolean showStarz = RenderingManager . isShowStarz ( ) ; boolean showOneRow = ! ( showActivity || showStarz ) ; IFeed feed = ( IFeed ) feedsList . getModel ( ) . getElementAt ( row ) ; boolean sameButton = ( row == attachedRow && feed == attachedFeed ) ; if ( sameButton && ! forceUpdate ) return ; attachedFeed = feed ; attachedRow = row ; UnreadStats stats = calcUnreadStats ( attachedFeed ) ; activityMeter . init ( stats ) ; Rectangle cellBounds = feedsList . getCellBounds ( row , row ) ; Rectangle r = new Rectangle ( cellBounds ) ; r . x = r . width - 2 ; r . y += SystemUtils . IS_OS_MAC ? 3 : 1 ; if ( showActivity ) { r . x -= activityMeter . getSize ( ) . width ; r . setSize ( activityMeter . getSize ( ) ) ; activityMeter . setBounds ( r ) ; feedsList . add ( activityMeter ) ; } else { feedsList . remove ( activityMeter ) ; if ( showOneRow ) r . x += 1 ; } if ( showUnread ) { Dimension unreadButtonSize = unreadButton . getSize ( ) ; r . x -= unreadButtonSize . width ; r . setSize ( unreadButtonSize ) ; r . y = cellBounds . y + ( SystemUtils . IS_OS_MAC ? 3 : 1 ) ; if ( showOneRow ) r . y += 1 ; int unreadCount = stats . getTotalCount ( ) . getUnread ( ) ; Rectangle oldBounds = unreadButton . getBounds ( ) ; if ( sameButton && oldBounds . equals ( r ) ) { unreadButton . update ( unreadCount ) ; } else { unreadButton . setBounds ( r ) ; unreadButton . init ( stats . getTotalCount ( ) . getUnread ( ) ) ; } feedsList . add ( unreadButton ) ; unreadButton . setAttachedToObject ( attachedFeed ) ; } else { feedsList . remove ( unreadButton ) ; } } void detachButtons ( ) { if ( activityMeter . getParent ( ) != null ) { Rectangle r = activityMeter . getBounds ( ) ; feedsList . remove ( activityMeter ) ; feedsList . repaint ( r ) ; } if ( unreadButton . getParent ( ) != null ) { Rectangle r = unreadButton . getBounds ( ) ; feedsList . remove ( unreadButton ) ; feedsList . repaint ( r ) ; } attachedFeed = null ; attachedRow = - 1 ; } void resetAttachment ( ) { if ( attachedRow >= 0 ) { int row = attachedRow ; IFeed feed = attachedFeed ; ListModel model = feedsList . getModel ( ) ; if ( model . getSize ( ) > row && model . getElementAt ( row ) == feed ) attachButtons ( row , true ) ; else detachButtons ( ) ; } } public void contentsChanged ( ListDataEvent e ) { resetAttachment ( ) ; } public void intervalAdded ( ListDataEvent e ) { resetAttachment ( ) ; } public void intervalRemoved ( ListDataEvent e ) { resetAttachment ( ) ; } public void componentResized ( ComponentEvent e ) { resetAttachment ( ) ; } public void actionPerformed ( ActionEvent e ) { GlobalModel model = GlobalModel . SINGLETON ; IFeed feed = ( IFeed ) e . getSource ( ) ; GlobalController . readFeeds ( true , model . getSelectedGuide ( ) , feed ) ; } } class FeedsListListener extends MouseAdapter implements MouseMotionListener { private static final int ICON_STARS_WIDTH = 64 ; private FeedsPanel feedsPanel ; private JList feedsList ; private GuideModel model ; private MouseListener starzSettingTipAdapter ; private int insetsTop ; FeedsListListener ( final FeedsPanel thePanel ) { feedsPanel = thePanel ; feedsList = thePanel . getFeedsList ( ) ; model = ( GuideModel ) feedsList . getModel ( ) ; insetsTop = feedsList . getInsets ( ) . top ; starzSettingTipAdapter = new TipOfTheDay . TipMouseAdapter ( TipOfTheDay . TIP_STARZ_SETTINGS , true ) ; } public void mousePressed ( final MouseEvent e ) { Point point = e . getPoint ( ) ; int row = feedsList . locationToIndex ( point ) ; if ( row != - 1 && feedsList . getCellBounds ( row , row ) . contains ( point ) ) { if ( SwingUtilities . isRightMouseButton ( e ) ) { if ( ! feedsList . isSelectedIndex ( row ) ) feedsList . setSelectedIndex ( row ) ; } else if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( FeedsListCellRenderer . getHoveredStar ( ) != - 1 ) { starzSettingTipAdapter . mousePressed ( e ) ; IFeed feed = ( IFeed ) model . getElementAt ( row ) ; int rating = ( e . getModifiers ( ) & InputEvent . SHIFT_MASK ) != 0 ? - 1 : FeedsListCellRenderer . getHoveredStar ( ) ; if ( feed . getRating ( ) != rating ) { feed . setRating ( rating ) ; if ( ! model . isPresent ( feed ) ) { GlobalController . SINGLETON . selectFeed ( null ) ; } } } } } } private Point convertToCellCoords ( Point point ) { final Rectangle rect = feedsList . getCellBounds ( 0 , 0 ) ; int y = ( point . y - insetsTop ) % rect . height ; int x = point . x - feedsList . getInsets ( ) . left ; return new Point ( x , y ) ; } private int locationToStar ( Point point ) { return ( int ) ( ( point . x - 3 ) / ( ICON_STARS_WIDTH / 5.0 ) ) ; } public void mouseEntered ( final MouseEvent e ) { checkHover ( e . getPoint ( ) ) ; } public void mouseDragged ( final MouseEvent e ) { checkHover ( e . getPoint ( ) ) ; } public void mouseMoved ( final MouseEvent e ) { checkHover ( e . getPoint ( ) ) ; } private void checkHover ( final Point point ) { int cursor = Cursor . DEFAULT_CURSOR ; int row = feedsList . locationToIndex ( point ) ; int star = - 1 ; IFeed hoveredFeed = null ; if ( row > - 1 && feedsList . getCellBounds ( row , row ) . contains ( point ) ) { hoveredFeed = ( IFeed ) feedsList . getModel ( ) . getElementAt ( row ) ; final Point convertedPoint = convertToCellCoords ( point ) ; if ( cellRenderer . isStarzHovered ( convertedPoint ) && ( ( hoveredFeed instanceof DataFeed && ( ( DataFeed ) hoveredFeed ) . isInitialized ( ) ) || ( hoveredFeed instanceof SearchFeed ) ) ) { boolean selectedCell = feedsList . getSelectedIndex ( ) == row ; if ( selectedCell ) { star = locationToStar ( convertedPoint ) ; cursor = Cursor . HAND_CURSOR ; } } feedsPanel . getUnreadActivityController ( ) . attachButtons ( row , false ) ; } FeedsListCellRenderer . setHoveredStar ( star ) ; FeedsListCellRenderer . setHoveredFeed ( hoveredFeed ) ; if ( feedsList . getCursor ( ) . getType ( ) != cursor ) { feedsList . setCursor ( Cursor . getPredefinedCursor ( cursor ) ) ; } } public void mouseClicked ( MouseEvent e ) { if ( onDoubleClickAction != null && e . getClickCount ( ) == 2 && SwingUtilities . isLeftMouseButton ( e ) ) { onDoubleClickAction . actionPerformed ( new ActionEvent ( feedsList , 0 , null ) ) ; } } } private final class ControllerListener extends ControllerAdapter { public void guideSelected ( final IGuide guide ) { final String text = ( guide == null ? Strings . message ( "panel.feeds.no.guide.selected" ) : guide . getTitle ( ) ) ; setSubtitle ( MessageFormat . format ( Strings . message ( "panel.in" ) , text ) ) ; updateMainListArea ( guide ) ; } } private static class LoadingIconRepainter extends Thread { private JList list ; private long intervals ; public LoadingIconRepainter ( JList aList , long aIntervals ) { super ( LoadingIconRepainter . class . getName ( ) ) ; setDaemon ( true ) ; list = aList ; intervals = aIntervals ; } private synchronized void repaintFeedsRows ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { ListModel model = list . getModel ( ) ; int firstVisibleIndex = list . getFirstVisibleIndex ( ) ; int lastVisibleIndex = list . getLastVisibleIndex ( ) ; if ( firstVisibleIndex >= 0 && lastVisibleIndex >= 0 ) { for ( int i = firstVisibleIndex ; i <= lastVisibleIndex ; i ++ ) { IFeed feed = ( IFeed ) model . getElementAt ( i ) ; if ( FeedsListCellRenderer . needsProgressIcon ( feed ) ) { list . repaint ( list . getCellBounds ( i , i ) ) ; } } } } } ) ; } public void run ( ) { while ( true ) { try { repaintFeedsRows ( ) ; try { Thread . sleep ( intervals ) ; } catch ( InterruptedException e ) { LOG . log ( Level . WARNING , Strings . error ( "interrupted" ) , e ) ; } } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "unhandled.exception" ) , e ) ; } } } } private static class FeedsListCellRenderer extends JPanel implements ListCellRenderer { private static final Logger LOG = Logger . getLogger ( FeedsListCellRenderer . class . getName ( ) ) ; private static final Color COLOR_DRAG_SOURCE = Color . LIGHT_GRAY ; private static final Border BORDER_NO_FOCUS = BorderFactory . createEmptyBorder ( 1 , 1 , 1 , 1 ) ; private JLabel lbStars ; private JLabel lbLoading ; private JLabel lbTitle ; private JLabel lbIcon ; private ArticleActivityMeter activityMeter ; private UnreadButton unreadButton ; private static int hoveredStar = - 1 ; private static IFeed hoveredFeed ; public FeedsListCellRenderer ( ) { super ( ) ; lbTitle = new JLabel ( ) ; activityMeter = new ArticleActivityMeter ( ) ; unreadButton = new UnreadButton ( ) ; lbStars = new JLabel ( ) ; lbLoading = new JLabel ( ) ; lbIcon = new JLabel ( ) ; lbIcon . setHorizontalAlignment ( SwingConstants . CENTER ) ; lbIcon . setPreferredSize ( new Dimension ( 18 , 16 ) ) ; setOpaque ( true ) ; setBorder ( BORDER_NO_FOCUS ) ; initLayout ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) LOG . fine ( "Completed construction" ) ; } public void initLayout ( ) { boolean showStarz = RenderingManager . isShowStarz ( ) ; boolean showUnread = RenderingManager . isShowUnreadInFeeds ( ) ; boolean showActivity = RenderingManager . isShowActivityChart ( ) ; boolean showOneRow = ! ( showStarz || showActivity ) ; boolean mac = SystemUtils . IS_OS_MAC ; CellConstraints cc = new CellConstraints ( ) ; String spacing = mac ? "2px" : "0" ; if ( showOneRow ) { String cols = "1px, left:64px:grow, 1px, 12px, 2px, p, 1px, center:21px, 1px" ; String rows = spacing + ", max(16px;pref), " + spacing ; setLayout ( new FormLayout ( cols , rows ) ) ; add ( lbTitle , cc . xy ( 2 , 2 ) ) ; add ( lbLoading , cc . xy ( 4 , 2 ) ) ; add ( lbIcon , cc . xy ( 6 , 2 ) ) ; manageComponent ( unreadButton , showUnread , cc . xy ( 8 , 2 ) ) ; remove ( lbStars ) ; remove ( activityMeter ) ; } else { String cols = "1px, left:64px:grow, 1px, 12px, 2px, center:21px, 1px, pref, 1px" ; String rows = spacing + ", max(12px;p), 1px, max(16px;pref), " + spacing ; setLayout ( new FormLayout ( cols , rows ) ) ; add ( lbTitle , cc . xyw ( 2 , 4 , 3 ) ) ; add ( lbLoading , cc . xy ( 4 , 2 ) ) ; add ( lbIcon , cc . xy ( 6 , 4 ) ) ; manageComponent ( unreadButton , showUnread , cc . xy ( 6 , 2 ) ) ; manageComponent ( lbStars , showStarz , cc . xy ( 2 , 2 ) ) ; manageComponent ( activityMeter , showActivity , cc . xywh ( 8 , 2 , 1 , 3 , "right, top" ) ) ; } Font textFont = mac ? new Font ( "Lucida Grande" , Font . BOLD , 10 ) : lbTitle . getFont ( ) . deriveFont ( Font . BOLD ) ; lbTitle . setFont ( textFont ) ; } private void manageComponent ( JComponent component , boolean show , Object constr ) { if ( show ) { add ( component , constr ) ; } else { remove ( component ) ; } } public Dimension getFixedCellSize ( ) { lbTitle . setText ( "<dummy>" ) ; validate ( ) ; return getPreferredSize ( ) ; } public static void setHoveredFeed ( IFeed aHoveredFeed ) { hoveredFeed = aHoveredFeed ; } public static void setHoveredStar ( int aStar ) { hoveredStar = aStar ; } public static int getHoveredStar ( ) { return hoveredStar ; } public Component getListCellRendererComponent ( final JList list , final Object value , final int index , final boolean isSelected , final boolean cellHasFocus ) { IFeed currentFeed = ( IFeed ) value ; if ( currentFeed == null ) return null ; Color backround = ( index != - 1 && isBeingDragged ( value ) ) ? COLOR_DRAG_SOURCE : isSelected ? RenderingManager . getFeedsListSelectedBackground ( ) : RenderingManager . getFeedsListBackground ( index % 2 == 0 ) ; Color foreground = FeedDisplayModeManager . getInstance ( ) . getColor ( currentFeed , isSelected ) ; if ( foreground == null || isSelected ) { foreground = RenderingManager . getFeedsListForeground ( isSelected ) ; } setForeground ( foreground ) ; setBackground ( backround ) ; lbTitle . setForeground ( foreground ) ; lbTitle . setBackground ( backround ) ; lbStars . setForeground ( Color . RED ) ; lbStars . setBackground ( Color . RED ) ; setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "List.focusCellHighlightBorder" ) : BORDER_NO_FOCUS ) ; FeedFormatter formatter = new FeedFormatter ( currentFeed ) ; String title = currentFeed . getTitle ( ) ; String type = null ; if ( currentFeed . isDynamic ( ) ) { type = "feed.from.reading.list.icon" ; } else if ( currentFeed instanceof QueryFeed ) { type = "feed.query.icon" ; } else if ( currentFeed instanceof SearchFeed ) { type = "feed.search.icon" ; } Icon icon = type == null ? null : IconSource . getIcon ( type ) ; if ( title . length ( ) == 0 ) title = Strings . message ( "panel.feeds.no.title" ) ; lbTitle . setText ( title ) ; lbIcon . setIcon ( icon ) ; UnreadStats stats = UnreadActivityController . calcUnreadStats ( currentFeed ) ; activityMeter . init ( stats ) ; unreadButton . init ( stats . getTotalCount ( ) . getUnread ( ) ) ; Icon iconStars = null ; Icon iconLoading = null ; if ( ( currentFeed instanceof DataFeed && ( ( DataFeed ) currentFeed ) . isInitialized ( ) ) || currentFeed instanceof SearchFeed ) { iconStars = formatter . getStarsIcon ( ) ; } if ( needsProgressIcon ( currentFeed ) ) { long time = System . currentTimeMillis ( ) ; int frames = FeedFormatter . getLoadingIconFrames ( ) ; int frame = ( int ) ( ( time / PROGRESS_ICON_FRAME_PAUSE ) % frames ) ; iconLoading = FeedFormatter . getLoadingIcon ( frame ) ; } lbStars . setIcon ( iconStars ) ; lbLoading . setIcon ( iconLoading ) ; Font fnt = this . lbTitle . getFont ( ) ; int style = currentFeed . isRead ( ) ? Font . PLAIN : Font . BOLD ; this . lbTitle . setFont ( fnt . deriveFont ( style ) ) ; return this ; } private boolean isBeingDragged ( Object aValue ) { boolean found = false ; if ( DNDListContext . isDragging ( ) ) { Object [ ] items = DNDListContext . getObject ( ) . getItems ( ) ; for ( int i = 0 ; ! found && i < items . length ; i ++ ) { found = aValue == items [ i ] ; } } return found ; } static boolean needsProgressIcon ( IFeed feed ) { if ( ! GlobalController . getConnectionState ( ) . isOnline ( ) ) return false ; boolean repaint = feed . isProcessing ( ) ; if ( ! repaint && feed instanceof DirectFeed ) { FeedMetaDataHolder holder = ( ( DirectFeed ) feed ) . getMetaDataHolder ( ) ; repaint = holder == null || ! holder . isComplete ( ) ; } return repaint ; } public String getToolTipText ( final MouseEvent event ) { if ( hoveredFeed == null ) return null ; String text = null ; Rectangle bounds = getBounds ( ) ; setSize ( - bounds . x , - bounds . y ) ; Component comp = getComponentAt ( event . getPoint ( ) ) ; if ( comp == lbStars ) { GlobalModel model = GlobalModel . SINGLETON ; int rating = hoveredFeed . getRating ( ) ; int score = model . getScoreCalculator ( ) . calcBlogStarzScore ( hoveredFeed ) ; String name = covertToResources ( FeedFormatter . getStarzFileName ( score , true ) ) ; String userRatingName = null ; boolean userRatingSet = rating != - 1 ; if ( userRatingSet ) { userRatingName = FeedFormatter . getStarzFileName ( rating , false ) ; userRatingName = covertToResources ( userRatingName ) ; } text = "<html><table border='0'><tr>" + "<td>" + Strings . message ( "panel.feeds.starz.recommendation" ) + "</td>" + "<td><img src='" + name + "'></td></tr>" + "<tr><td>" + Strings . message ( "panel.feeds.starz.your.rating" ) + "</td>" + "<td>" + ( userRatingSet ? "<img src='" + userRatingName + "'>" : Strings . message ( "panel.feeds.starz.not.set" ) ) + "</td></tr></table></html>" ; } else if ( comp == lbIcon && hoveredFeed . isDynamic ( ) ) { DirectFeed dFeed = ( DirectFeed ) hoveredFeed ; ReadingList [ ] readingLists = dFeed . getReadingLists ( ) ; String [ ] names = new String [ readingLists . length ] ; for ( int i = 0 ; i < readingLists . length ; i ++ ) { ReadingList list = readingLists [ i ] ; names [ i ] = list . getTitle ( ) ; if ( names [ i ] == null ) names [ i ] = list . getURL ( ) . toString ( ) ; names [ i ] += " (" + list . getParentGuide ( ) . getTitle ( ) + ")" ; } text = MessageFormat . format ( Strings . message ( "panel.feeds.readinglists" ) , StringUtils . join ( names , "," ) ) ; } else if ( comp == lbTitle ) { text = hoveredFeed . getTitle ( ) ; } else { if ( hoveredFeed != null && hoveredFeed . isInvalid ( ) ) { text = MessageFormat . format ( Strings . message ( "panel.feeds.error" ) , hoveredFeed . getInvalidnessReason ( ) ) ; } } return text ; } private String covertToResources ( String path ) { if ( path == null ) return null ; return path . startsWith ( File . separator ) ? "/" + path : path ; } public boolean isStarzHovered ( Point aPoint ) { return lbStars . contains ( aPoint ) ; } } private class RenderSettingsChangeListener implements PropertyChangeListener { public void propertyChange ( PropertyChangeEvent evt ) { String prop = evt . getPropertyName ( ) ; if ( prop . equals ( RenderingSettingsNames . THEME ) ) { onListColorsUpdate ( ) ; } else if ( prop . equals ( RenderingSettingsNames . IS_STARZ_SHOWING ) || prop . equals ( RenderingSettingsNames . IS_UNREAD_IN_FEEDS_SHOWING ) || prop . equals ( RenderingSettingsNames . IS_ACTIVITY_CHART_SHOWING ) ) { updateFeedsListLayout ( ) ; } } } private class SelectFeed implements Runnable { private final IFeed feed ; public SelectFeed ( IFeed aFeed ) { feed = aFeed ; } public void run ( ) { selectListItem0 ( feed ) ; } } } class FeedSelectionListener extends MouseAdapter implements ListSelectionListener , PropertyChangeListener { private java . util . Timer timer ; private FeedSelector task ; private final Object eventLock ; private volatile IFeed eventFeed ; private volatile long eventTime ; private volatile int eventIndex ; private boolean feedSelectionDelayed ; public FeedSelectionListener ( long aFeedSelectionDelay ) { eventLock = new Object ( ) ; timer = new java . util . Timer ( true ) ; setFeedSelectionDelay ( aFeedSelectionDelay ) ; } private void setFeedSelectionDelay ( long aDelay ) { if ( task != null ) task . cancel ( ) ; feedSelectionDelayed = ( aDelay != 0 ) ; if ( feedSelectionDelayed ) { task = new FeedSelector ( aDelay ) ; timer . schedule ( task , 1 , aDelay ) ; } } public void propertyChange ( PropertyChangeEvent evt ) { Integer value = ( Integer ) evt . getNewValue ( ) ; setFeedSelectionDelay ( value . longValue ( ) ) ; } public void valueChanged ( final ListSelectionEvent e ) { if ( e . getValueIsAdjusting ( ) ) return ; JList list = ( JList ) e . getSource ( ) ; ListModel model = list . getModel ( ) ; GlobalModel globalModel = GlobalModel . SINGLETON ; IFeed prevFeed = globalModel == null ? null : globalModel . getSelectedFeed ( ) ; int oldIndex = prevFeed == null ? - 1 : ( ( GuideModel ) model ) . indexOf ( prevFeed ) ; int selIndex = ListSelectionManager . evaluateSelectionIndex ( list , oldIndex ) ; final IFeed feed ; feed = ( selIndex == - 1 ) ? null : ( IFeed ) model . getElementAt ( selIndex ) ; if ( feedSelectionDelayed ) { synchronized ( eventLock ) { eventTime = System . currentTimeMillis ( ) ; eventFeed = feed ; eventIndex = selIndex ; } } else if ( selIndex != oldIndex ) { selectFeed ( feed ) ; } } public void mousePressed ( MouseEvent e ) { synchronized ( eventLock ) { Point point = e . getPoint ( ) ; JList list = ( JList ) e . getSource ( ) ; int index = list . locationToIndex ( point ) ; if ( index != eventIndex ) { eventIndex = - 1 ; eventTime = - 1 ; eventFeed = null ; } } } protected void selectFeed ( final IFeed feed ) { if ( feed != GlobalModel . SINGLETON . getSelectedFeed ( ) && feed != null ) { if ( UifUtilities . isEDT ( ) ) { GlobalController . SINGLETON . selectFeed ( feed ) ; } else { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { GlobalController . SINGLETON . selectFeed ( feed ) ; } } ) ; } } } private class FeedSelector extends TimerTask { private long lastProcessedTime ; private long feedSelectionDelay ; public FeedSelector ( long aFeedSelectionDelay ) { lastProcessedTime = 0 ; feedSelectionDelay = aFeedSelectionDelay ; } public void run ( ) { long time ; IFeed feed ; synchronized ( eventLock ) { time = eventTime ; feed = eventFeed ; } if ( time > lastProcessedTime && System . currentTimeMillis ( ) - time > feedSelectionDelay ) { selectFeed ( feed ) ; lastProcessedTime = time ; } } } } 
=======
class TokenDatatype extends StringDatatype { public Object createValue ( String str , ValidationContext vc ) { return StringNormalizer . normalize ( str ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
