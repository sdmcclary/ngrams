<<<<<<< HEAD
public class RegexMatcherHandler extends AbstractHandler { private boolean _caseInsensitive ; public RegexMatcherHandler ( ) { this ( false ) ; } public RegexMatcherHandler ( boolean caseInsensitive ) { this . _caseInsensitive = caseInsensitive ; } public Object onAddAndExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; INode node1 = ( INode ) nodes [ 0 ] ; INode node2 = ( INode ) nodes [ 2 ] ; Object result ; if ( node1 instanceof OrMatcher ) { OrMatcher orMatcher = ( OrMatcher ) node1 ; orMatcher . appendChild ( node2 ) ; result = orMatcher ; } else { OrMatcher matcher = new OrMatcher ( ) ; matcher . appendChild ( node1 ) ; matcher . appendChild ( node2 ) ; result = matcher ; } return result ; } public Object onAddCCExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassMatcher matcher = ( CharacterClassMatcher ) nodes [ 0 ] ; CharacterClassMatcher rhs = ( CharacterClassMatcher ) nodes [ 1 ] ; matcher . addCharacters ( rhs . getCharacters ( ) ) ; return matcher ; } public Object onAddFactor ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; INode node1 = ( INode ) nodes [ 0 ] ; INode node2 = ( INode ) nodes [ 1 ] ; Object result ; if ( node1 instanceof AndMatcher ) { AndMatcher and1 = ( AndMatcher ) node1 ; and1 . appendChild ( node2 ) ; result = and1 ; } else { AndMatcher matcher = new AndMatcher ( ) ; matcher . appendChild ( node1 ) ; matcher . appendChild ( node2 ) ; result = matcher ; } return result ; } public Object onCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 1 ] ; } public Object onCharacter ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; char c = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) . charAt ( 0 ) ; ITextMatcher result ; if ( this . _caseInsensitive && Character . isLetter ( c ) ) { CharacterClassMatcher ccMatcher = new CharacterClassMatcher ( ) ; ccMatcher . addCharacter ( Character . toLowerCase ( c ) ) ; ccMatcher . addCharacter ( Character . toUpperCase ( c ) ) ; result = ccMatcher ; } else { result = new CharacterMatcher ( c ) ; } return result ; } public Object onCharacterClass ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onCharacterExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassMatcher matcher = new CharacterClassMatcher ( ) ; char c = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) . charAt ( 0 ) ; if ( this . _caseInsensitive && Character . isLetter ( c ) ) { matcher . addCharacter ( Character . toLowerCase ( c ) ) ; matcher . addCharacter ( Character . toUpperCase ( c ) ) ; } else { matcher . addCharacter ( c ) ; } return matcher ; } public Object onCharacterRangeExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassMatcher matcher = new CharacterClassMatcher ( ) ; char c1 = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) . charAt ( 0 ) ; char c2 = ( ( Lexeme ) nodes [ 2 ] ) . getText ( ) . charAt ( 0 ) ; if ( c1 > c2 ) { char tmp = c1 ; c1 = c2 ; c2 = tmp ; } if ( this . _caseInsensitive && Character . isLetter ( c1 ) && Character . isLetter ( c2 ) ) { for ( char c = Character . toLowerCase ( c1 ) ; c <= Character . toLowerCase ( c2 ) ; c ++ ) { matcher . addCharacter ( c ) ; } for ( char c = Character . toUpperCase ( c1 ) ; c <= Character . toUpperCase ( c2 ) ; c ++ ) { matcher . addCharacter ( c ) ; } } else { for ( char c = c1 ; c <= c2 ; c ++ ) { matcher . addCharacter ( c ) ; } } return matcher ; } public Object onDot ( IReductionContext context ) { CharacterClassMatcher matcher = new CharacterClassMatcher ( ) ; matcher . setNegate ( true ) ; matcher . addCharacters ( new char [ ] { '\r' , '\n' } ) ; return matcher ; } public Object onEmptyCC ( IReductionContext context ) { return new CharacterClassMatcher ( ) ; } public Object onEndOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; AndMatcher matcher = new AndMatcher ( ) ; EndOfLineMatcher endLine = new EndOfLineMatcher ( ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; matcher . appendChild ( endLine ) ; return matcher ; } public Object onEscapedCharacter ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; Object result ; char c = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) . charAt ( 1 ) ; switch ( c ) { case 'A' : result = new StartOfFileMatcher ( ) ; break ; case 'b' : result = new WordBoundaryMatcher ( ) ; break ; case 'B' : WordBoundaryMatcher wordBoundary = new WordBoundaryMatcher ( ) ; wordBoundary . setNegate ( true ) ; result = wordBoundary ; break ; case 'D' : DigitMatcher noDigits = new DigitMatcher ( ) ; noDigits . setNegate ( true ) ; result = noDigits ; break ; case 'd' : result = new DigitMatcher ( ) ; break ; case 'f' : result = new CharacterMatcher ( '\f' ) ; break ; case 'n' : result = new CharacterMatcher ( '\n' ) ; break ; case 'r' : result = new CharacterMatcher ( '\r' ) ; break ; case 'S' : WhitespaceMatcher noWhitespace = new WhitespaceMatcher ( ) ; noWhitespace . setNegate ( true ) ; result = noWhitespace ; break ; case 's' : result = new WhitespaceMatcher ( ) ; break ; case 't' : result = new CharacterMatcher ( '\t' ) ; break ; case 'v' : result = new CharacterMatcher ( '' ) ; break ; case 'W' : WordMatcher wordMatcher = new WordMatcher ( ) ; wordMatcher . setNegate ( true ) ; result = wordMatcher ; break ; case 'w' : result = new WordMatcher ( ) ; break ; case 'z' : result = new EndOfFileMatcher ( ) ; break ; default : result = new CharacterMatcher ( c ) ; break ; } return result ; } public Object onFirstAndExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onFirstCCExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onFirstFactor ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onMinusCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassMatcher matcher = ( CharacterClassMatcher ) nodes [ 2 ] ; matcher . addCharacter ( '-' ) ; return matcher ; } public Object onMinusOnlyCC ( IReductionContext context ) { CharacterClassMatcher matcher = new CharacterClassMatcher ( ) ; matcher . addCharacter ( '-' ) ; return matcher ; } public Object onNegatedCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassMatcher matcher = ( CharacterClassMatcher ) nodes [ 2 ] ; matcher . setNegate ( true ) ; return matcher ; } public Object onNegatedEmptyCC ( IReductionContext context ) { CharacterClassMatcher matcher = new CharacterClassMatcher ( ) ; matcher . setNegate ( true ) ; return matcher ; } public Object onNegativeLookahead ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; LookaheadMatcher matcher = new LookaheadMatcher ( ) ; matcher . setNegate ( true ) ; matcher . appendChild ( ( INode ) nodes [ 1 ] ) ; return matcher ; } public Object onNegatedMinusCC ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; CharacterClassMatcher matcher = ( CharacterClassMatcher ) nodes [ 3 ] ; matcher . setNegate ( true ) ; matcher . addCharacter ( '-' ) ; return matcher ; } public Object onNegatedMinusOnlyCC ( IReductionContext context ) { CharacterClassMatcher matcher = new CharacterClassMatcher ( ) ; matcher . setNegate ( true ) ; matcher . addCharacter ( '-' ) ; return matcher ; } public Object onOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onOrExprGroup ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 1 ] ; } public Object onPositiveLookahead ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; LookaheadMatcher matcher = new LookaheadMatcher ( ) ; matcher . appendChild ( ( INode ) nodes [ 1 ] ) ; return matcher ; } public Object onStartAndEndOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; AndMatcher matcher = new AndMatcher ( ) ; StartOfLineMatcher startLine = new StartOfLineMatcher ( ) ; EndOfLineMatcher endLine = new EndOfLineMatcher ( ) ; matcher . appendChild ( startLine ) ; matcher . appendChild ( ( INode ) nodes [ 1 ] ) ; matcher . appendChild ( endLine ) ; return matcher ; } public Object onStartOrExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; AndMatcher matcher = new AndMatcher ( ) ; StartOfLineMatcher startLine = new StartOfLineMatcher ( ) ; matcher . appendChild ( startLine ) ; matcher . appendChild ( ( INode ) nodes [ 1 ] ) ; return matcher ; } public Object onTerm ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; return nodes [ 0 ] ; } public Object onTermPlus ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; OneOrMoreMatcher matcher = new OneOrMoreMatcher ( ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; return matcher ; } public Object onTermQuestion ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; OptionalMatcher matcher = new OptionalMatcher ( ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; return matcher ; } public Object onTermRepeat ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; String repeatString = ( ( Lexeme ) nodes [ 2 ] ) . getText ( ) ; int repeatCount = Integer . parseInt ( repeatString ) ; RepetitionMatcher matcher = new RepetitionMatcher ( repeatCount , repeatCount ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; return matcher ; } public Object onTermRepeatLowerBound ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; String lowerBoundString = ( ( Lexeme ) nodes [ 2 ] ) . getText ( ) ; int lowerBound = Integer . parseInt ( lowerBoundString ) ; RepetitionMatcher matcher = new RepetitionMatcher ( lowerBound , Integer . MAX_VALUE ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; return matcher ; } public Object onTermRepeatUpperBound ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; String upperBoundString = ( ( Lexeme ) nodes [ 3 ] ) . getText ( ) ; int upperBound = Integer . parseInt ( upperBoundString ) ; RepetitionMatcher matcher = new RepetitionMatcher ( 0 , upperBound ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; return matcher ; } public Object onTermRepeatRange ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; String lowerBoundString = ( ( Lexeme ) nodes [ 2 ] ) . getText ( ) ; String upperBoundString = ( ( Lexeme ) nodes [ 4 ] ) . getText ( ) ; int lowerBound = Integer . parseInt ( lowerBoundString ) ; int upperBound = Integer . parseInt ( upperBoundString ) ; RepetitionMatcher matcher = new RepetitionMatcher ( lowerBound , upperBound ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; return matcher ; } public Object onTermStar ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; ZeroOrMoreMatcher matcher = new ZeroOrMoreMatcher ( ) ; matcher . appendChild ( ( INode ) nodes [ 0 ] ) ; return matcher ; } public Object onWhitespace ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; String whitespace = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) ; Object result ; if ( whitespace . length ( ) > 1 ) { result = new StringMatcher ( whitespace ) ; } else { result = new CharacterMatcher ( whitespace . charAt ( 0 ) ) ; } return result ; } public Object onWhitespaceExpression ( IReductionContext context ) { Object [ ] nodes = context . getNodes ( ) ; String whitespace = ( ( Lexeme ) nodes [ 0 ] ) . getText ( ) ; return new CharacterClassMatcher ( whitespace ) ; } } 
=======
class DM implements Marshal { public Object readInstance ( XmlPullParser parser , String namespace , String name , PropertyInfo expected ) throws IOException , XmlPullParserException { String text = parser . nextText ( ) ; switch ( name . charAt ( 0 ) ) { case 's' : return text ; case 'i' : return new Integer ( Integer . parseInt ( text ) ) ; case 'l' : return new Long ( Long . parseLong ( text ) ) ; case 'b' : return new Boolean ( SoapEnvelope . stringToBoolean ( text ) ) ; default : throw new RuntimeException ( ) ; } } public void writeInstance ( XmlSerializer writer , Object instance ) throws IOException { writer . text ( instance . toString ( ) ) ; } public void register ( SoapSerializationEnvelope cm ) { cm . addMapping ( cm . xsd , "int" , PropertyInfo . INTEGER_CLASS , this ) ; cm . addMapping ( cm . xsd , "long" , PropertyInfo . LONG_CLASS , this ) ; cm . addMapping ( cm . xsd , "string" , PropertyInfo . STRING_CLASS , this ) ; cm . addMapping ( cm . xsd , "boolean" , PropertyInfo . BOOLEAN_CLASS , this ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
