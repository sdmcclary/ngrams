@ Mojo ( name = "enforce" , defaultPhase = LifecyclePhase . VALIDATE , requiresDependencyCollection = ResolutionScope . TEST , threadSafe = true ) public class EnforceMojo extends AbstractMojo { protected static Hashtable < String , EnforcerRule > cache = new Hashtable < > ( ) ; @ Parameter ( defaultValue = "${mojoExecution}" , readonly = true , required = true ) protected MojoExecution mojoExecution ; @ Parameter ( defaultValue = "${session}" , readonly = true , required = true ) protected MavenSession session ; @ Parameter ( defaultValue = "${project}" , readonly = true , required = true ) protected MavenProject project ; @ Parameter ( property = "enforcer.skip" , defaultValue = "false" ) protected boolean skip = false ; @ Parameter ( property = "enforcer.fail" , defaultValue = "true" ) private boolean fail = true ; @ Parameter ( property = "enforcer.failFast" , defaultValue = "false" ) private boolean failFast = false ; @ Parameter ( property = "enforcer.failIfNoRules" , defaultValue = "true" ) private boolean failIfNoRules = true ; @ Parameter private PlexusConfiguration rules ; @ Parameter ( required = false , property = "enforcer.skipRules" ) private List < String > rulesToSkip ; @ Parameter ( property = "enforcer.ignoreCache" , defaultValue = "false" ) protected boolean ignoreCache = false ; @ Component private PlexusContainer container ; @ Component private EnforcerRuleManager enforcerRuleManager ; @ Component private EnforcerRuleCache ruleCache ; private List < String > rulesToExecute ; @ Parameter ( required = false , property = "enforcer.rules" ) public void setRulesToExecute ( List < String > rulesToExecute ) throws MojoExecutionException { if ( rulesToExecute != null && ! rulesToExecute . isEmpty ( ) ) { if ( this . rulesToExecute != null && ! this . rulesToExecute . isEmpty ( ) ) { throw new MojoExecutionException ( "Detected the usage of both '-Drules' (which is deprecated) " + "and '-Denforcer.rules'. Please use only one of them, preferably '-Denforcer.rules'." ) ; } this . rulesToExecute = rulesToExecute ; } } @ Parameter ( required = false , property = "rules" ) @ Deprecated public void setCommandLineRules ( List < String > rulesToExecute ) throws MojoExecutionException { if ( rulesToExecute != null && ! rulesToExecute . isEmpty ( ) ) { getLog ( ) . warn ( "Detected the usage of property '-Drules' which is deprecated. Use '-Denforcer.rules' instead." ) ; } setRulesToExecute ( rulesToExecute ) ; } @ Override public void execute ( ) throws MojoExecutionException { Log log = this . getLog ( ) ; if ( skip ) { log . info ( "Skipping Rule Enforcement." ) ; return ; } Optional < PlexusConfiguration > rulesFromCommandLine = createRulesFromCommandLineOptions ( ) ; List < EnforcerRuleDesc > rulesList ; List < EnforcerRuleDesc > allRules = enforcerRuleManager . createRules ( rulesFromCommandLine . orElse ( rules ) , log ) ; rulesList = filterOutSkippedRules ( allRules ) ; List < EnforcerRuleDesc > additionalRules = processRuleConfigProviders ( rulesList ) ; rulesList = filterOutRuleConfigProviders ( rulesList ) ; rulesList . addAll ( additionalRules ) ; if ( rulesList . isEmpty ( ) ) { if ( failIfNoRules ) { throw new MojoExecutionException ( "No rules are configured. Use the skip flag if you want to disable execution." ) ; } else { log . warn ( "No rules are configured." ) ; return ; } } PluginParameterExpressionEvaluator evaluator = new PluginParameterExpressionEvaluator ( session , mojoExecution ) ; EnforcerRuleHelper helper = new DefaultEnforcementRuleHelper ( session , evaluator , log , container ) ; if ( ! fail ) { failFast = false ; } List < String > errorMessages = new ArrayList < > ( ) ; for ( int ruleIndex = 0 ; ruleIndex < rulesList . size ( ) ; ruleIndex ++ ) { EnforcerRuleDesc ruleDesc = rulesList . get ( ruleIndex ) ; EnforcerLevel level = ruleDesc . getLevel ( ) ; try { executeRule ( ruleIndex , ruleDesc , helper ) ; } catch ( EnforcerRuleError e ) { String ruleMessage = createRuleMessage ( ruleIndex , ruleDesc , EnforcerLevel . ERROR , e ) ; throw new MojoExecutionException ( System . lineSeparator ( ) + ruleMessage , e ) ; } catch ( EnforcerRuleException e ) { String ruleMessage = createRuleMessage ( ruleIndex , ruleDesc , level , e ) ; if ( failFast && level == EnforcerLevel . ERROR ) { throw new MojoExecutionException ( System . lineSeparator ( ) + ruleMessage , e ) ; } if ( level == EnforcerLevel . ERROR ) { errorMessages . add ( ruleMessage ) ; } else { log . warn ( ruleMessage ) ; } } } if ( ! errorMessages . isEmpty ( ) ) { if ( fail ) { throw new MojoExecutionException ( System . lineSeparator ( ) + String . join ( System . lineSeparator ( ) , errorMessages ) ) ; } else { errorMessages . forEach ( log :: warn ) ; } } } private List < EnforcerRuleDesc > processRuleConfigProviders ( List < EnforcerRuleDesc > rulesList ) { return rulesList . stream ( ) . filter ( Objects :: nonNull ) . filter ( rd -> rd . getRule ( ) instanceof AbstractEnforcerRuleConfigProvider ) . map ( this :: executeRuleConfigProvider ) . flatMap ( xml -> enforcerRuleManager . createRules ( xml , getLog ( ) ) . stream ( ) ) . collect ( Collectors . toList ( ) ) ; } private List < EnforcerRuleDesc > filterOutRuleConfigProviders ( List < EnforcerRuleDesc > rulesList ) { return rulesList . stream ( ) . filter ( Objects :: nonNull ) . filter ( rd -> ! ( rd . getRule ( ) instanceof AbstractEnforcerRuleConfigProvider ) ) . collect ( Collectors . toList ( ) ) ; } private XmlPlexusConfiguration executeRuleConfigProvider ( EnforcerRuleDesc ruleDesc ) { AbstractEnforcerRuleConfigProvider ruleProducer = ( AbstractEnforcerRuleConfigProvider ) ruleDesc . getRule ( ) ; if ( getLog ( ) . isDebugEnabled ( ) ) { getLog ( ) . debug ( String . format ( "Executing Rule Config Provider %s" , ruleDesc . getRule ( ) ) ) ; } XmlPlexusConfiguration configuration = null ; try { configuration = new XmlPlexusConfiguration ( ruleProducer . getRulesConfig ( ) ) ; } catch ( EnforcerRuleException e ) { throw new EnforcerRuleManagerException ( "Rules Provider error for: " + getRuleName ( ruleDesc ) , e ) ; } getLog ( ) . info ( String . format ( "Rule Config Provider %s executed" , getRuleName ( ruleDesc ) ) ) ; return configuration ; } private void executeRule ( int ruleIndex , EnforcerRuleDesc ruleDesc , EnforcerRuleHelper helper ) throws EnforcerRuleException { if ( getLog ( ) . isDebugEnabled ( ) ) { getLog ( ) . debug ( String . format ( "Executing Rule %d: %s" , ruleIndex , ruleDesc ) ) ; } long startTime = System . currentTimeMillis ( ) ; try { if ( ruleDesc . getRule ( ) instanceof EnforcerRule ) { executeRuleOld ( ruleIndex , ruleDesc , helper ) ; } else if ( ruleDesc . getRule ( ) instanceof AbstractEnforcerRule ) { executeRuleNew ( ruleIndex , ruleDesc ) ; } } finally { if ( getLog ( ) . isDebugEnabled ( ) ) { long workTime = System . currentTimeMillis ( ) - startTime ; getLog ( ) . debug ( String . format ( "Finish Rule %d: %s takes %d ms" , ruleIndex , getRuleName ( ruleDesc ) , workTime ) ) ; } } } private void executeRuleOld ( int ruleIndex , EnforcerRuleDesc ruleDesc , EnforcerRuleHelper helper ) throws EnforcerRuleException { EnforcerRule rule = ( EnforcerRule ) ruleDesc . getRule ( ) ; if ( ignoreCache || shouldExecute ( rule ) ) { rule . execute ( helper ) ; getLog ( ) . info ( String . format ( "Rule %d: %s passed" , ruleIndex , getRuleName ( ruleDesc ) ) ) ; } } private void executeRuleNew ( int ruleIndex , EnforcerRuleDesc ruleDesc ) throws EnforcerRuleException { AbstractEnforcerRule rule = ( AbstractEnforcerRule ) ruleDesc . getRule ( ) ; if ( ignoreCache || ! ruleCache . isCached ( rule ) ) { rule . execute ( ) ; getLog ( ) . info ( String . format ( "Rule %d: %s passed" , ruleIndex , getRuleName ( ruleDesc ) ) ) ; } } private Optional < PlexusConfiguration > createRulesFromCommandLineOptions ( ) { if ( rulesToExecute == null || rulesToExecute . isEmpty ( ) ) { return Optional . empty ( ) ; } PlexusConfiguration configuration = new DefaultPlexusConfiguration ( "rules" ) ; for ( String rule : rulesToExecute ) { configuration . addChild ( new DefaultPlexusConfiguration ( rule ) ) ; } return Optional . of ( configuration ) ; } private List < EnforcerRuleDesc > filterOutSkippedRules ( List < EnforcerRuleDesc > allRules ) { if ( rulesToSkip == null || rulesToSkip . isEmpty ( ) ) { return allRules ; } return allRules . stream ( ) . filter ( ruleDesc -> ! rulesToSkip . contains ( ruleDesc . getName ( ) ) ) . collect ( Collectors . toList ( ) ) ; } protected boolean shouldExecute ( EnforcerRule rule ) { if ( rule . isCacheable ( ) ) { Log log = this . getLog ( ) ; log . debug ( "Rule " + rule . getClass ( ) . getName ( ) + " is cacheable." ) ; String key = rule . getClass ( ) . getName ( ) + " " + rule . getCacheId ( ) ; if ( EnforceMojo . cache . containsKey ( key ) ) { log . debug ( "Key " + key + " was found in the cache" ) ; if ( rule . isResultValid ( cache . get ( key ) ) ) { log . debug ( "The cached results are still valid. Skipping the rule: " + rule . getClass ( ) . getName ( ) ) ; return false ; } } EnforceMojo . cache . put ( key , rule ) ; } return true ; } public void setRulesToSkip ( List < String > rulesToSkip ) { if ( rulesToSkip == null ) { return ; } this . rulesToSkip = rulesToSkip . stream ( ) . filter ( Objects :: nonNull ) . map ( StringUtils :: lowercaseFirstLetter ) . collect ( Collectors . toList ( ) ) ; } public void setFail ( boolean theFail ) { this . fail = theFail ; } public void setFailFast ( boolean theFailFast ) { this . failFast = theFailFast ; } private String createRuleMessage ( int ruleIndex , EnforcerRuleDesc ruleDesc , EnforcerLevel level , EnforcerRuleException e ) { StringBuilder result = new StringBuilder ( ) ; result . append ( "Rule " ) . append ( ruleIndex ) . append ( ": " ) . append ( getRuleName ( ruleDesc ) ) ; if ( level == EnforcerLevel . ERROR ) { result . append ( " failed" ) ; } else { result . append ( " warned" ) ; } if ( e . getMessage ( ) != null ) { result . append ( " with message:" ) . append ( System . lineSeparator ( ) ) . append ( e . getMessage ( ) ) ; } else { result . append ( " without a message" ) ; } return result . toString ( ) ; } private String getRuleName ( EnforcerRuleDesc ruleDesc ) { Class < ? extends EnforcerRuleBase > ruleClass = ruleDesc . getRule ( ) . getClass ( ) ; String ruleName = ruleClass . getName ( ) ; if ( ! ruleClass . getSimpleName ( ) . equalsIgnoreCase ( ruleDesc . getName ( ) ) ) { ruleName += "(" + ruleDesc . getName ( ) + ")" ; } return ruleName ; } public void setFailIfNoRules ( boolean thefailIfNoRules ) { this . failIfNoRules = thefailIfNoRules ; } } 