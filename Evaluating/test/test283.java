<<<<<<< HEAD
public class LinuxPcapOpen { private final static int BACKDOOR_COOKED_SOCKET = 0 ; private final static int BACKDOOR_RAW_SOCKET = 1 ; private final LinuxPacketCapture pcap ; private final ISystemService system ; private final ILogger logger ; private final LinuxArpMap arpMap ; LinuxPcapOpen ( LinuxPacketCapture pcap , ISystemService system , ILogger logger ) { this . pcap = pcap ; this . system = system ; this . logger = logger ; arpMap = new LinuxArpMap ( pcap ) ; } boolean socketOpenLive ( String device , boolean promiscuous ) { if ( device == null || device . length ( ) == 0 ) { pcap . fail ( "No device specified" ) ; return false ; } if ( ! openRaw ( device ) ) { return false ; } int idx = getInterfaceIndex ( "lo" ) ; pcap . setLoopbackIndex ( idx ) ; idx = getInterfaceIndex ( device ) ; if ( idx == - 1 ) { pcap . fail ( "Interface index lookup failed" ) ; return false ; } pcap . setInterfaceIndex ( idx ) ; if ( ! bindInterface ( ) ) { return false ; } if ( promiscuous ) { enablePromiscuous ( device ) ; } return true ; } @ SuppressWarnings ( "incomplete-switch" ) private boolean openRaw ( String device ) { if ( ! openSocket ( false ) ) { return false ; } pcap . setCooked ( false ) ; pcap . setOffset ( 0 ) ; int arptype = getInterfaceArpType ( device ) ; if ( arptype == - 1 ) { return false ; } if ( ! arpMap . mapToDlt ( arptype , true ) ) { pcap . setLinkType ( Datalink . DLT_NULL ) ; } switch ( pcap . getLinkType ( ) ) { case DLT_NULL : case DLT_LINUX_SLL : case DLT_LINUX_IRDA : case DLT_LINUX_LAPD : return openCooked ( device ) ; } return true ; } private boolean openCooked ( String device ) { if ( ! openSocket ( true ) ) { return false ; } pcap . setCooked ( true ) ; pcap . dltListClear ( ) ; if ( pcap . getLinkType ( ) != Datalink . DLT_LINUX_IRDA && pcap . getLinkType ( ) != Datalink . DLT_LINUX_LAPD ) { pcap . setLinkType ( Datalink . DLT_LINUX_SLL ) ; } return true ; } private boolean openSocket ( boolean cooked ) { if ( pcap . getSocket ( ) != - 1 ) { pcap . close ( ) ; } final int type = cooked ? ( Constants . SOCK_DGRAM ) : ( Constants . SOCK_RAW ) ; final int s = system . syscall_socket ( Constants . PF_PACKET , type , system . htons ( Constants . ETH_P_ALL ) ) ; if ( s < 0 ) { final int errno = system . getErrno ( ) ; if ( errno == Constants . EPERM ) { return backdoorOpenSocket ( cooked ) ; } pcap . fail ( "Error opening capture socket" , errno ) ; return false ; } pcap . setSocket ( s ) ; return true ; } private boolean backdoorOpenSocket ( boolean cooked ) { final int request = cooked ? ( BACKDOOR_COOKED_SOCKET ) : ( BACKDOOR_RAW_SOCKET ) ; final int s = system . backdoor_request ( request ) ; if ( s < 0 ) { final int errno = system . getErrno ( ) ; if ( errno == Constants . EPERM ) { pcap . fail ( "Permission error opening socket with backdoor.  (Is backdoor setuid?)" ) ; return false ; } pcap . fail ( "Error attempting to open capture socket with backdoor" , errno ) ; return false ; } pcap . setSocket ( s ) ; return true ; } private byte [ ] deviceNameToStruct ( String device ) { if ( device . length ( ) >= Constants . IFNAMSIZ ) { pcap . fail ( "Device name too long " + device ) ; return null ; } final byte [ ] ifreq = new byte [ 40 ] ; for ( int i = 0 ; i < device . length ( ) ; i ++ ) { ifreq [ i ] = ( byte ) device . charAt ( i ) ; } return ifreq ; } private int getInterfaceArpType ( String device ) { final byte [ ] data = deviceNameToStruct ( device ) ; if ( data == null ) { return - 1 ; } if ( system . syscall_ioctl ( pcap . getSocket ( ) , Constants . SIOCGIFHWADDR , data , 40 , 40 ) < 0 ) { if ( system . getErrno ( ) == Constants . ENODEV ) { pcap . fail ( "Could not open device '" + device + "'" ) ; return - 1 ; } pcap . fail ( "ioctl SIOCGIFHWADDR failed" , system . getErrno ( ) ) ; return - 1 ; } return system . unpack16 ( data , Constants . IFNAMSIZ ) ; } private int getInterfaceIndex ( String device ) { final byte [ ] data = deviceNameToStruct ( device ) ; if ( system . syscall_ioctl ( pcap . getSocket ( ) , Constants . SIOCGIFINDEX , data , 40 , 40 ) < 0 ) { pcap . fail ( "ioctl SIOCGIFINDEX failed" , system . getErrno ( ) ) ; return - 1 ; } return system . unpack32 ( data , Constants . IFNAMSIZ ) ; } private boolean bindInterface ( ) { final int s = pcap . getSocket ( ) ; final int idx = pcap . getInterfaceIndex ( ) ; if ( ( s == - 1 ) || ( idx == - 1 ) ) { pcap . fail ( "Socket or interface invalid" ) ; return false ; } final byte [ ] sockaddr_ll = new byte [ 20 ] ; system . pack16 ( sockaddr_ll , 0 , Constants . PF_PACKET ) ; system . pack32 ( sockaddr_ll , 4 , idx ) ; system . pack16 ( sockaddr_ll , 2 , system . htons ( Constants . ETH_P_ALL ) ) ; if ( system . syscall_bind ( s , sockaddr_ll , 20 ) < 0 ) { pcap . fail ( "bind() interface failed" , system . getErrno ( ) ) ; return false ; } final byte [ ] errbuf = new byte [ 4 ] ; if ( system . syscall_getsockopt ( s , Constants . SOL_SOCKET , Constants . SO_ERROR , errbuf , 4 ) < 0 ) { pcap . fail ( "getsockopt() failed" , system . getErrno ( ) ) ; return false ; } int errno = system . unpack32 ( errbuf , 0 ) ; if ( errno != 0 ) { pcap . fail ( "SO_ERROR after bind()" , errno ) ; return false ; } return true ; } private void enablePromiscuous ( String device ) { byte [ ] data = new byte [ 16 ] ; system . pack32 ( data , 0 , pcap . getInterfaceIndex ( ) ) ; system . pack16 ( data , 4 , Constants . PACKET_MR_PROMISC ) ; if ( system . syscall_setsockopt ( pcap . getSocket ( ) , Constants . SOL_PACKET , Constants . PACKET_ADD_MEMBERSHIP , data , 16 ) < 0 ) { logger . warning ( "enablePromiscuous() failed for " + device + ": " + system . getErrorMessage ( system . getErrno ( ) ) ) ; } } } 
=======
class Path { private final boolean root ; private final Vector names ; Path ( boolean root , Vector names ) { this . root = root ; this . names = names ; } boolean isRoot ( ) { return root ; } Vector getNames ( ) { return names ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( root ) buf . append ( '/' ) ; for ( int i = 0 , len = names . size ( ) ; i < len ; i ++ ) { if ( i != 0 ) buf . append ( '/' ) ; buf . append ( ( String ) names . elementAt ( i ) ) ; } return buf . toString ( ) ; } static class ParseException extends Exception { private final String messageKey ; ParseException ( String messageKey ) { super ( messageKey ) ; this . messageKey = messageKey ; } public String getMessageKey ( ) { return messageKey ; } } private static final int START = 0 ; private static final int IN_NAME = 1 ; private static final int AFTER_NAME = 2 ; private static final int AFTER_SLASH = 3 ; static Vector parse ( String str ) throws ParseException { int state = START ; int nameStartIndex = - 1 ; Vector paths = new Vector ( ) ; Vector names = new Vector ( ) ; boolean root = false ; for ( int i = 0 , len = str . length ( ) ; i < len ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case ' ' : case '\r' : case '\n' : case '\t' : if ( state == IN_NAME ) { names . addElement ( makeName ( str , nameStartIndex , i ) ) ; state = AFTER_NAME ; } break ; case '/' : switch ( state ) { case IN_NAME : names . addElement ( makeName ( str , nameStartIndex , i ) ) ; break ; case START : root = true ; break ; case AFTER_SLASH : throw new ParseException ( "unexpected_slash" ) ; } state = AFTER_SLASH ; break ; case '|' : switch ( state ) { case START : throw new ParseException ( "empty_path" ) ; case AFTER_NAME : break ; case AFTER_SLASH : throw new ParseException ( "expected_name" ) ; case IN_NAME : names . addElement ( makeName ( str , nameStartIndex , i ) ) ; break ; } paths . addElement ( new Path ( root , names ) ) ; root = false ; names = new Vector ( ) ; state = START ; break ; default : switch ( state ) { case AFTER_NAME : throw new ParseException ( "expected_slash" ) ; case AFTER_SLASH : case START : nameStartIndex = i ; state = IN_NAME ; break ; case IN_NAME : break ; } break ; } } switch ( state ) { case START : throw new ParseException ( "empty_path" ) ; case AFTER_NAME : break ; case AFTER_SLASH : throw new ParseException ( "expected_name" ) ; case IN_NAME : names . addElement ( makeName ( str , nameStartIndex , str . length ( ) ) ) ; break ; } paths . addElement ( new Path ( root , names ) ) ; return paths ; } private static String makeName ( String str , int start , int end ) throws ParseException { String name = str . substring ( start , end ) ; if ( ! Naming . isNcname ( name ) ) throw new ParseException ( "invalid_name" ) ; return name ; } static public void main ( String [ ] args ) throws ParseException { Vector paths = parse ( args [ 0 ] ) ; for ( int i = 0 ; i < paths . size ( ) ; i ++ ) { if ( i != 0 ) System . out . println ( "---" ) ; Path path = ( Path ) paths . elementAt ( i ) ; if ( path . isRoot ( ) ) System . out . println ( "/" ) ; for ( int j = 0 ; j < path . getNames ( ) . size ( ) ; j ++ ) System . out . println ( path . getNames ( ) . elementAt ( j ) ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
