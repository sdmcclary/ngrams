<<<<<<< HEAD
public class RCommand extends RGeomElem { public int type = RGeomElem . COMMAND ; public RPoint [ ] controlPoints ; public RPoint startPoint ; public RPoint endPoint ; int commandType ; RPoint [ ] curvePoints ; public static final int LINETO = 0 ; public static final int QUADBEZIERTO = 1 ; public static final int CUBICBEZIERTO = 2 ; public static final int ADAPTATIVE = 0 ; public static final int UNIFORMLENGTH = 1 ; public static final int UNIFORMSTEP = 2 ; public static int segmentType = UNIFORMLENGTH ; static final int segmentRecursionLimit = 32 ; static final float segmentDistanceEpsilon = 1.192092896e-07F ; static final float segmentCollinearityEpsilon = 1.192092896e-07F ; static final float segmentAngleTolEpsilon = 0.01F ; static float segmentGfxStrokeWeight = 1.0F ; static float segmentGfxScale = 1.0F ; static float segmentApproxScale = 1.0F ; static float segmentDistTolSqr = 0.25F ; static float segmentDistTolMnhttn = 4.0F ; public static float segmentAngleTol = 0.0F ; static float segmentCuspLimit = 0.0F ; static float segmentLength = 4.0F ; static float segmentOffset = 0.0F ; static float segmentAccOffset = 0.0F ; static int segmentSteps = 0 ; static boolean segmentLines = false ; int oldSegmentType = UNIFORMLENGTH ; float oldSegmentCollinearityEpsilon = 1.192092896e-07F ; float oldSegmentAngleTolEpsilon = 0.01F ; float oldSegmentGfxStrokeWeight = 1.0F ; float oldSegmentGfxScale = 1.0F ; float oldSegmentApproxScale = 1.0F ; float oldSegmentDistTolSqr = 0.25F ; float oldSegmentDistTolMnhttn = 4.0F ; float oldSegmentAngleTol = 0.0F ; float oldSegmentCuspLimit = 0.0F ; float oldSegmentLength = 4.0F ; float oldSegmentOffset = 0.0F ; float oldSegmentAccOffset = 0.0F ; int oldSegmentSteps = 0 ; boolean oldSegmentLines = false ; static RCommand createLine ( RPoint start , RPoint end ) { RCommand result = new RCommand ( ) ; result . startPoint = start ; result . endPoint = end ; result . commandType = LINETO ; return result ; } static RCommand createLine ( float startx , float starty , float endx , float endy ) { return createLine ( new RPoint ( startx , starty ) , new RPoint ( endx , endy ) ) ; } static RCommand createBezier3 ( RPoint start , RPoint cp1 , RPoint end ) { RCommand result = new RCommand ( ) ; result . startPoint = start ; result . append ( cp1 ) ; result . endPoint = end ; result . commandType = QUADBEZIERTO ; return result ; } static RCommand createBezier3 ( float startx , float starty , float cp1x , float cp1y , float endx , float endy ) { return createBezier3 ( new RPoint ( startx , starty ) , new RPoint ( cp1x , cp1y ) , new RPoint ( endx , endy ) ) ; } static RCommand createBezier4 ( RPoint start , RPoint cp1 , RPoint cp2 , RPoint end ) { RCommand result = new RCommand ( ) ; result . startPoint = start ; result . append ( cp1 ) ; result . append ( cp2 ) ; result . endPoint = end ; result . commandType = CUBICBEZIERTO ; return result ; } static RCommand createBezier4 ( float startx , float starty , float cp1x , float cp1y , float cp2x , float cp2y , float endx , float endy ) { return createBezier4 ( new RPoint ( startx , starty ) , new RPoint ( cp1x , cp1y ) , new RPoint ( cp2x , cp2y ) , new RPoint ( endx , endy ) ) ; } public RCommand ( ) { controlPoints = null ; } public RCommand ( RCommand c ) { this . startPoint = new RPoint ( c . startPoint ) ; for ( int i = 0 ; i < c . countControlPoints ( ) ; i ++ ) { this . append ( new RPoint ( c . controlPoints [ i ] ) ) ; } this . endPoint = new RPoint ( c . endPoint ) ; this . commandType = c . commandType ; } public RCommand ( RCommand c , RPoint sp ) { this . startPoint = sp ; for ( int i = 0 ; i < c . countControlPoints ( ) ; i ++ ) { this . append ( new RPoint ( c . controlPoints [ i ] ) ) ; } this . endPoint = new RPoint ( c . endPoint ) ; this . commandType = c . commandType ; } public RCommand ( RPoint sp , RPoint ep ) { this . startPoint = sp ; this . endPoint = ep ; this . commandType = LINETO ; } public RCommand ( float spx , float spy , float epx , float epy ) { this ( new RPoint ( spx , spy ) , new RPoint ( epx , epy ) ) ; } public RCommand ( RPoint sp , RPoint cp1 , RPoint ep ) { this . startPoint = sp ; this . append ( cp1 ) ; this . endPoint = ep ; this . commandType = QUADBEZIERTO ; } public RCommand ( float spx , float spy , float cp1x , float cp1y , float epx , float epy ) { this ( new RPoint ( spx , spy ) , new RPoint ( cp1x , cp1y ) , new RPoint ( epx , epy ) ) ; } public RCommand ( RPoint sp , RPoint cp1 , RPoint cp2 , RPoint ep ) { this . startPoint = sp ; this . append ( cp1 ) ; this . append ( cp2 ) ; this . endPoint = ep ; this . commandType = CUBICBEZIERTO ; } public RCommand ( float spx , float spy , float cp1x , float cp1y , float cp2x , float cp2y , float epx , float epy ) { this ( new RPoint ( spx , spy ) , new RPoint ( cp1x , cp1y ) , new RPoint ( cp2x , cp2y ) , new RPoint ( epx , epy ) ) ; } public RShape toShape ( ) { return new RShape ( new RPath ( this ) ) ; } public int getType ( ) { return this . type ; } public static void setSegmentator ( int segmentatorType ) { segmentType = segmentatorType ; } public static void setSegmentGraphic ( PGraphics g ) { segmentApproxScale = 1.0F ; segmentDistTolSqr = 0.5F / segmentApproxScale ; segmentDistTolSqr *= segmentDistTolSqr ; segmentDistTolMnhttn = 4.0F / segmentApproxScale ; segmentAngleTol = 0.0F ; if ( g . stroke && ( g . strokeWeight * segmentApproxScale > 1.0F ) ) { segmentAngleTol = 0.1F ; } } public static void setSegmentAngle ( float segmentAngleTolerance ) { segmentAngleTol = segmentAngleTolerance ; } public static void setSegmentLength ( float segmentLngth ) { if ( segmentLngth >= 1 ) { segmentLength = segmentLngth ; } else { segmentLength = 4 ; } } public static void setSegmentOffset ( float segmentOffst ) { if ( segmentOffst >= 0 ) { segmentOffset = segmentOffst ; } else { segmentOffset = 0 ; } } public static void setSegmentStep ( float segmentStps ) { if ( segmentStps == - 1F ) { segmentLines = false ; segmentStps = 0F ; } else { segmentLines = true ; } segmentStps = Math . abs ( segmentStps ) ; if ( segmentStps > 0.0F && segmentStps < 1.0F ) { segmentSteps = ( int ) ( 1F / segmentStps ) ; } else { segmentSteps = ( int ) segmentStps ; } } protected void saveSegmentatorContext ( ) { oldSegmentType = RCommand . segmentType ; oldSegmentGfxStrokeWeight = RCommand . segmentGfxStrokeWeight ; oldSegmentGfxScale = RCommand . segmentGfxScale ; oldSegmentApproxScale = RCommand . segmentApproxScale ; oldSegmentDistTolSqr = RCommand . segmentDistTolSqr ; oldSegmentDistTolMnhttn = RCommand . segmentDistTolMnhttn ; oldSegmentAngleTol = RCommand . segmentAngleTol ; oldSegmentCuspLimit = RCommand . segmentCuspLimit ; oldSegmentLength = RCommand . segmentLength ; oldSegmentOffset = RCommand . segmentOffset ; oldSegmentAccOffset = RCommand . segmentAccOffset ; oldSegmentSteps = RCommand . segmentSteps ; oldSegmentLines = RCommand . segmentLines ; } protected void restoreSegmentatorContext ( ) { RCommand . segmentType = oldSegmentType ; RCommand . segmentGfxStrokeWeight = oldSegmentGfxStrokeWeight ; RCommand . segmentGfxScale = oldSegmentGfxScale ; RCommand . segmentApproxScale = oldSegmentApproxScale ; RCommand . segmentDistTolSqr = oldSegmentDistTolSqr ; RCommand . segmentDistTolMnhttn = oldSegmentDistTolMnhttn ; RCommand . segmentAngleTol = oldSegmentAngleTol ; RCommand . segmentCuspLimit = oldSegmentCuspLimit ; RCommand . segmentLength = oldSegmentLength ; RCommand . segmentOffset = oldSegmentOffset ; RCommand . segmentAccOffset = oldSegmentAccOffset ; RCommand . segmentSteps = oldSegmentSteps ; RCommand . segmentLines = oldSegmentLines ; } public int countControlPoints ( ) { if ( controlPoints == null ) { return 0 ; } return controlPoints . length ; } public int getCommandType ( ) { return commandType ; } RPoint getStartPoint ( ) { return startPoint ; } RPoint getEndPoint ( ) { return endPoint ; } RPoint [ ] getControlPoints ( ) { return controlPoints ; } public RPoint [ ] getPoints ( ) { return getPoints ( true ) ; } protected RPoint [ ] getPoints ( boolean resetSegmentator ) { if ( resetSegmentator ) { saveSegmentatorContext ( ) ; RCommand . segmentOffset = 0F ; RCommand . segmentAccOffset = 0F ; } RPoint [ ] result = null ; switch ( segmentType ) { case ADAPTATIVE : switch ( commandType ) { case LINETO : result = new RPoint [ 2 ] ; result [ 0 ] = startPoint ; result [ 1 ] = endPoint ; break ; case QUADBEZIERTO : quadBezierAdaptative ( ) ; result = curvePoints ; curvePoints = null ; break ; case CUBICBEZIERTO : cubicBezierAdaptative ( ) ; result = curvePoints ; curvePoints = null ; break ; } break ; case UNIFORMLENGTH : switch ( commandType ) { case LINETO : lineUniformLength ( ) ; result = curvePoints ; curvePoints = null ; break ; case QUADBEZIERTO : quadBezierUniformLength ( ) ; result = curvePoints ; curvePoints = null ; break ; case CUBICBEZIERTO : cubicBezierUniformLength ( ) ; result = curvePoints ; curvePoints = null ; break ; } break ; case UNIFORMSTEP : switch ( commandType ) { case LINETO : if ( segmentLines ) { lineUniformStep ( ) ; result = curvePoints ; curvePoints = null ; } else { result = new RPoint [ 2 ] ; result [ 0 ] = startPoint ; result [ 1 ] = endPoint ; } break ; case QUADBEZIERTO : quadBezierUniformStep ( ) ; result = curvePoints ; curvePoints = null ; break ; case CUBICBEZIERTO : cubicBezierUniformStep ( ) ; result = curvePoints ; curvePoints = null ; break ; } break ; } if ( resetSegmentator ) { restoreSegmentatorContext ( ) ; } return result ; } public RPoint getPoint ( float t ) { t = ( t > 1F ) ? 1F : t ; t = ( t < 0F ) ? 0F : t ; float ax , bx , cx ; float ay , by , cy ; float tSquared , tDoubled , tCubed ; float dx , dy ; switch ( commandType ) { case LINETO : dx = endPoint . x - startPoint . x ; dy = endPoint . y - startPoint . y ; return new RPoint ( startPoint . x + dx * t , startPoint . y + dy * t ) ; case QUADBEZIERTO : bx = controlPoints [ 0 ] . x - startPoint . x ; ax = endPoint . x - controlPoints [ 0 ] . x - bx ; by = controlPoints [ 0 ] . y - startPoint . y ; ay = endPoint . y - controlPoints [ 0 ] . y - by ; tSquared = t * t ; tDoubled = 2F * t ; return new RPoint ( ( ax * tSquared ) + ( bx * tDoubled ) + startPoint . x , ( ay * tSquared ) + ( by * tDoubled ) + startPoint . y ) ; case CUBICBEZIERTO : cx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) ; bx = 3F * ( controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ) - cx ; ax = endPoint . x - startPoint . x - cx - bx ; cy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) ; by = 3F * ( controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ) - cy ; ay = endPoint . y - startPoint . y - cy - by ; tSquared = t * t ; tCubed = tSquared * t ; return new RPoint ( ( ax * tCubed ) + ( bx * tSquared ) + ( cx * t ) + startPoint . x , ( ay * tCubed ) + ( by * tSquared ) + ( cy * t ) + startPoint . y ) ; } return new RPoint ( ) ; } public RPoint [ ] getTangents ( int segments ) { RPoint [ ] result ; float dt , t ; switch ( commandType ) { case LINETO : result = new RPoint [ 2 ] ; result [ 0 ] = startPoint ; result [ 1 ] = endPoint ; return result ; case QUADBEZIERTO : case CUBICBEZIERTO : result = new RPoint [ segments ] ; dt = 1F / segments ; t = 0F ; for ( int i = 0 ; i < segments ; i ++ ) { result [ i ] = getTangent ( t ) ; t += dt ; } return result ; } return null ; } public RPoint [ ] getTangents ( ) { return getTangents ( 100 ) ; } public RPoint getTangent ( float t ) { t = ( t > 1F ) ? 1F : t ; t = ( t < 0F ) ? 0F : t ; float dx , dy , tx , ty , t2 , t_1 , t_12 ; switch ( commandType ) { case LINETO : dx = endPoint . x - startPoint . x ; dy = endPoint . y - startPoint . y ; return new RPoint ( dx , dy ) ; case QUADBEZIERTO : tx = 2F * ( ( startPoint . x - 2 * controlPoints [ 0 ] . x + endPoint . x ) * t + ( controlPoints [ 0 ] . x - startPoint . x ) ) ; ty = 2F * ( ( startPoint . y - 2 * controlPoints [ 0 ] . y + endPoint . y ) * t + ( controlPoints [ 0 ] . y - startPoint . y ) ) ; return new RPoint ( tx , ty ) ; case CUBICBEZIERTO : t2 = t * t ; t_1 = 1 - t ; t_12 = t_1 * t_1 ; return new RPoint ( - 3F * t_12 * startPoint . x + 3F * ( 3F * t2 - 4F * t + 1F ) * controlPoints [ 0 ] . x + 3F * t * ( 2F - 3F * t ) * controlPoints [ 1 ] . x + 3F * t2 * endPoint . x , - 3F * t_12 * startPoint . y + 3F * ( 3F * t2 - 4F * t + 1F ) * controlPoints [ 0 ] . y + 3F * t * ( 2F - 3F * t ) * controlPoints [ 1 ] . y + 3F * t2 * endPoint . y ) ; } return new RPoint ( ) ; } public float getCurveLength ( float t ) { t = ( t > 1F ) ? 1F : t ; t = ( t < 0F ) ? 0F : t ; float dx , dy , dx2 , dy2 , t2 ; switch ( commandType ) { case LINETO : dx = endPoint . x - startPoint . x ; dy = endPoint . y - startPoint . y ; dx2 = dx * dx ; dy2 = dy * dy ; t2 = t * t ; return ( float ) Math . sqrt ( dx2 * t2 + dy2 * t2 ) ; case QUADBEZIERTO : return quadBezierLength ( ) ; case CUBICBEZIERTO : return cubicBezierLength ( ) ; } return - 1F ; } public float getCurveLength ( ) { return getCurveLength ( 1F ) ; } public RPoint [ ] [ ] getPointsInPaths ( ) { PApplet . println ( "Feature not yet implemented for this class." ) ; return null ; } public RPoint [ ] [ ] getHandlesInPaths ( ) { PApplet . println ( "Feature not yet implemented for this class." ) ; return null ; } public RPoint [ ] [ ] getTangentsInPaths ( ) { PApplet . println ( "Feature not yet implemented for this class." ) ; return null ; } public boolean contains ( RPoint p ) { PApplet . println ( "Feature not yet implemented for this class." ) ; return false ; } public void draw ( PGraphics g ) { RPoint [ ] points = getPoints ( ) ; if ( points == null ) { return ; } g . beginShape ( ) ; for ( int i = 0 ; i < points . length ; i ++ ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; } public void draw ( PApplet a ) { RPoint [ ] points = getPoints ( ) ; if ( points == null ) { return ; } a . beginShape ( ) ; for ( int i = 0 ; i < points . length ; i ++ ) { a . vertex ( points [ i ] . x , points [ i ] . y ) ; } a . endShape ( ) ; } public RPoint [ ] getHandles ( ) { RPoint [ ] result ; if ( controlPoints == null ) { result = new RPoint [ 2 ] ; result [ 0 ] = startPoint ; result [ 1 ] = endPoint ; } else { result = new RPoint [ controlPoints . length + 2 ] ; result [ 0 ] = startPoint ; System . arraycopy ( controlPoints , 0 , result , 1 , controlPoints . length ) ; result [ result . length - 1 ] = endPoint ; } return result ; } public RCommand [ ] split ( float t ) { switch ( commandType ) { case LINETO : return splitLine ( t ) ; case QUADBEZIERTO : return splitQuadBezier ( t ) ; case CUBICBEZIERTO : return splitCubicBezier ( t ) ; } return null ; } private RCommand [ ] splitCubicBezier ( float t ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 4 ] [ 4 ] ; for ( int i = 0 ; i <= 3 ; i ++ ) { for ( int j = 0 ; j <= 3 ; j ++ ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; for ( int i = 0 ; i <= 3 ; i ++ ) { triangleMatrix [ 0 ] [ i ] . x = ctrlPoints [ i ] . x ; triangleMatrix [ 0 ] [ i ] . y = ctrlPoints [ i ] . y ; } for ( int i = 1 ; i <= 3 ; i ++ ) { for ( int j = 0 ; j <= 3 - i ; j ++ ) { triangleMatrix [ i ] [ j ] . x = ( 1 - t ) * triangleMatrix [ i - 1 ] [ j ] . x + t * triangleMatrix [ i - 1 ] [ j + 1 ] . x ; triangleMatrix [ i ] [ j ] . y = ( 1 - t ) * triangleMatrix [ i - 1 ] [ j ] . y + t * triangleMatrix [ i - 1 ] [ j + 1 ] . y ; } } RCommand [ ] result = new RCommand [ 2 ] ; result [ 0 ] = createBezier4 ( startPoint , triangleMatrix [ 1 ] [ 0 ] , triangleMatrix [ 2 ] [ 0 ] , triangleMatrix [ 3 ] [ 0 ] ) ; result [ 1 ] = createBezier4 ( triangleMatrix [ 3 ] [ 0 ] , triangleMatrix [ 2 ] [ 1 ] , triangleMatrix [ 1 ] [ 2 ] , endPoint ) ; return result ; } private RCommand [ ] splitQuadBezier ( float t ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 3 ] [ 3 ] ; for ( int i = 0 ; i <= 2 ; i ++ ) { for ( int j = 0 ; j <= 2 ; j ++ ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; for ( int i = 0 ; i <= 2 ; i ++ ) { triangleMatrix [ 0 ] [ i ] = ctrlPoints [ i ] ; } for ( int i = 1 ; i <= 2 ; i ++ ) { for ( int j = 0 ; j <= 2 - i ; j ++ ) { triangleMatrix [ i ] [ j ] . x = ( 1 - t ) * triangleMatrix [ i - 1 ] [ j ] . x + t * triangleMatrix [ i - 1 ] [ j + 1 ] . x ; triangleMatrix [ i ] [ j ] . y = ( 1 - t ) * triangleMatrix [ i - 1 ] [ j ] . y + t * triangleMatrix [ i - 1 ] [ j + 1 ] . y ; } } RCommand [ ] result = new RCommand [ 2 ] ; result [ 0 ] = createBezier3 ( startPoint , triangleMatrix [ 1 ] [ 0 ] , triangleMatrix [ 2 ] [ 0 ] ) ; result [ 1 ] = createBezier3 ( triangleMatrix [ 2 ] [ 0 ] , triangleMatrix [ 1 ] [ 1 ] , endPoint ) ; return result ; } private RCommand [ ] splitLine ( float t ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 2 ] [ 2 ] ; for ( int i = 0 ; i <= 1 ; i ++ ) { for ( int j = 0 ; j <= 1 ; j ++ ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; for ( int i = 0 ; i <= 1 ; i ++ ) { triangleMatrix [ 0 ] [ i ] = ctrlPoints [ i ] ; } for ( int i = 1 ; i <= 1 ; i ++ ) { for ( int j = 0 ; j <= 1 - i ; j ++ ) { triangleMatrix [ i ] [ j ] . x = ( 1 - t ) * triangleMatrix [ i - 1 ] [ j ] . x + t * triangleMatrix [ i - 1 ] [ j + 1 ] . x ; triangleMatrix [ i ] [ j ] . y = ( 1 - t ) * triangleMatrix [ i - 1 ] [ j ] . y + t * triangleMatrix [ i - 1 ] [ j + 1 ] . y ; } } RCommand [ ] result = new RCommand [ 2 ] ; result [ 0 ] = createLine ( startPoint , triangleMatrix [ 1 ] [ 0 ] ) ; result [ 1 ] = createLine ( triangleMatrix [ 1 ] [ 0 ] , endPoint ) ; return result ; } private void quadBezierAdaptative ( ) { addCurvePoint ( new RPoint ( startPoint ) ) ; quadBezierAdaptativeRecursive ( startPoint . x , startPoint . y , controlPoints [ 0 ] . x , controlPoints [ 0 ] . y , endPoint . x , endPoint . y , 0 ) ; addCurvePoint ( new RPoint ( endPoint ) ) ; } private void quadBezierAdaptativeRecursive ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , int level ) { if ( level > segmentRecursionLimit ) { return ; } float x12 = ( x1 + x2 ) / 2 ; float y12 = ( y1 + y2 ) / 2 ; float x23 = ( x2 + x3 ) / 2 ; float y23 = ( y2 + y3 ) / 2 ; float x123 = ( x12 + x23 ) / 2 ; float y123 = ( y12 + y23 ) / 2 ; float dx = x3 - x1 ; float dy = y3 - y1 ; float d = Math . abs ( ( ( x2 - x3 ) * dy - ( y2 - y3 ) * dx ) ) ; if ( d > segmentCollinearityEpsilon ) { if ( d * d <= segmentDistTolSqr * ( dx * dx + dy * dy ) ) { if ( segmentAngleTol < segmentAngleTolEpsilon ) { addCurvePoint ( new RPoint ( x123 , y123 ) ) ; return ; } float da = Math . abs ( ( float ) Math . atan2 ( y3 - y2 , x3 - x2 ) - ( float ) Math . atan2 ( y2 - y1 , x2 - x1 ) ) ; if ( da >= Math . PI ) da = 2 * ( float ) Math . PI - da ; if ( da < segmentAngleTol ) { addCurvePoint ( new RPoint ( x123 , y123 ) ) ; return ; } } } else { if ( Math . abs ( x1 + x3 - x2 - x2 ) + Math . abs ( y1 + y3 - y2 - y2 ) <= segmentDistTolMnhttn ) { addCurvePoint ( new RPoint ( x123 , y123 ) ) ; return ; } } quadBezierAdaptativeRecursive ( x1 , y1 , x12 , y12 , x123 , y123 , level + 1 ) ; quadBezierAdaptativeRecursive ( x123 , y123 , x23 , y23 , x3 , y3 , level + 1 ) ; } private void cubicBezierAdaptative ( ) { addCurvePoint ( new RPoint ( startPoint ) ) ; cubicBezierAdaptativeRecursive ( startPoint . x , startPoint . y , controlPoints [ 0 ] . x , controlPoints [ 0 ] . y , controlPoints [ 1 ] . x , controlPoints [ 1 ] . y , endPoint . x , endPoint . y , 0 ) ; addCurvePoint ( new RPoint ( endPoint ) ) ; } private void cubicBezierAdaptativeRecursive ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , int level ) { if ( level > segmentRecursionLimit ) { return ; } float x12 = ( x1 + x2 ) / 2 ; float y12 = ( y1 + y2 ) / 2 ; float x23 = ( x2 + x3 ) / 2 ; float y23 = ( y2 + y3 ) / 2 ; float x34 = ( x3 + x4 ) / 2 ; float y34 = ( y3 + y4 ) / 2 ; float x123 = ( x12 + x23 ) / 2 ; float y123 = ( y12 + y23 ) / 2 ; float x234 = ( x23 + x34 ) / 2 ; float y234 = ( y23 + y34 ) / 2 ; float x1234 = ( x123 + x234 ) / 2 ; float y1234 = ( y123 + y234 ) / 2 ; float dx = x4 - x1 ; float dy = y4 - y1 ; float d2 = Math . abs ( ( ( x2 - x4 ) * dy - ( y2 - y4 ) * dx ) ) ; float d3 = Math . abs ( ( ( x3 - x4 ) * dy - ( y3 - y4 ) * dx ) ) ; float da1 , da2 ; int d2b = ( d2 > segmentCollinearityEpsilon ) ? 1 : 0 ; int d3b = ( d3 > segmentCollinearityEpsilon ) ? 1 : 0 ; switch ( ( d2b << 1 ) + d3b ) { case 0 : if ( Math . abs ( x1 + x3 - x2 - x2 ) + Math . abs ( y1 + y3 - y2 - y2 ) + Math . abs ( x2 + x4 - x3 - x3 ) + Math . abs ( y2 + y4 - y3 - y3 ) <= segmentDistTolMnhttn ) { addCurvePoint ( new RPoint ( x1234 , y1234 ) ) ; return ; } break ; case 1 : if ( d3 * d3 <= segmentDistTolSqr * ( dx * dx + dy * dy ) ) { if ( segmentAngleTol < segmentAngleTolEpsilon ) { addCurvePoint ( new RPoint ( x23 , y23 ) ) ; return ; } da1 = Math . abs ( ( float ) Math . atan2 ( y4 - y3 , x4 - x3 ) - ( float ) Math . atan2 ( y3 - y2 , x3 - x2 ) ) ; if ( da1 >= ( float ) Math . PI ) da1 = 2 * ( float ) Math . PI - da1 ; if ( da1 < segmentAngleTol ) { addCurvePoint ( new RPoint ( x2 , y2 ) ) ; addCurvePoint ( new RPoint ( x3 , y3 ) ) ; return ; } if ( segmentCuspLimit != 0.0 ) { if ( da1 > segmentCuspLimit ) { addCurvePoint ( new RPoint ( x3 , y3 ) ) ; return ; } } } break ; case 2 : if ( d2 * d2 <= segmentDistTolSqr * ( dx * dx + dy * dy ) ) { if ( segmentAngleTol < segmentAngleTolEpsilon ) { addCurvePoint ( new RPoint ( x23 , y23 ) ) ; return ; } da1 = Math . abs ( ( float ) Math . atan2 ( y3 - y2 , x3 - x2 ) - ( float ) Math . atan2 ( y2 - y1 , x2 - x1 ) ) ; if ( da1 >= ( float ) Math . PI ) da1 = 2 * ( float ) Math . PI - da1 ; if ( da1 < segmentAngleTol ) { addCurvePoint ( new RPoint ( x2 , y2 ) ) ; addCurvePoint ( new RPoint ( x3 , y3 ) ) ; return ; } if ( segmentCuspLimit != 0.0 ) { if ( da1 > segmentCuspLimit ) { addCurvePoint ( new RPoint ( x2 , y2 ) ) ; return ; } } } break ; case 3 : if ( ( d2 + d3 ) * ( d2 + d3 ) <= segmentDistTolSqr * ( dx * dx + dy * dy ) ) { if ( segmentAngleTol < segmentAngleTolEpsilon ) { addCurvePoint ( new RPoint ( x23 , y23 ) ) ; return ; } float a23 = ( float ) Math . atan2 ( y3 - y2 , x3 - x2 ) ; da1 = Math . abs ( a23 - ( float ) Math . atan2 ( y2 - y1 , x2 - x1 ) ) ; da2 = Math . abs ( ( float ) Math . atan2 ( y4 - y3 , x4 - x3 ) - a23 ) ; if ( da1 >= ( float ) Math . PI ) da1 = 2 * ( float ) Math . PI - da1 ; if ( da2 >= ( float ) Math . PI ) da2 = 2 * ( float ) Math . PI - da2 ; if ( da1 + da2 < segmentAngleTol ) { addCurvePoint ( new RPoint ( x23 , y23 ) ) ; return ; } if ( segmentCuspLimit != 0.0 ) { if ( da1 > segmentCuspLimit ) { addCurvePoint ( new RPoint ( x2 , y2 ) ) ; return ; } if ( da2 > segmentCuspLimit ) { addCurvePoint ( new RPoint ( x3 , y3 ) ) ; return ; } } } break ; } cubicBezierAdaptativeRecursive ( x1 , y1 , x12 , y12 , x123 , y123 , x1234 , y1234 , level + 1 ) ; cubicBezierAdaptativeRecursive ( x1234 , y1234 , x234 , y234 , x34 , y34 , x4 , y4 , level + 1 ) ; } private void lineUniformStep ( ) { int steps = segmentSteps ; if ( segmentSteps == 0.0F ) { float dx = endPoint . x - startPoint . x ; float dy = endPoint . y - startPoint . y ; float len = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; steps = ( int ) ( len * 0.25 ) ; if ( steps < 4 ) steps = 4 ; } float dt = 1F / steps ; float fx , fy , fdx , fdy ; fx = startPoint . x ; fdx = ( endPoint . x - startPoint . x ) * dt ; fy = startPoint . y ; fdy = ( endPoint . y - startPoint . y ) * dt ; for ( int loop = 0 ; loop < steps ; loop ++ ) { addCurvePoint ( new RPoint ( fx , fy ) ) ; fx = fx + fdx ; fy = fy + fdy ; } addCurvePoint ( new RPoint ( endPoint ) ) ; } private void cubicBezierUniformStep ( ) { int steps = segmentSteps ; if ( segmentSteps == 0.0F ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; steps = ( int ) ( len * 0.25 ) ; if ( steps < 4 ) { steps = 4 ; } } float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y ; float temp = dt * dt ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop ++ ) { addCurvePoint ( new RPoint ( fx , fy ) ) ; fx = fx + fdx + fdd_per_2x + fddd_per_6x ; fdx = fdx + fddx + fddd_per_2x ; fddx = fddx + fdddx ; fdd_per_2x = fdd_per_2x + fddd_per_2x ; fy = fy + fdy + fdd_per_2y + fddd_per_6y ; fdy = fdy + fddy + fddd_per_2y ; fddy = fddy + fdddy ; fdd_per_2y = fdd_per_2y + fddd_per_2y ; } addCurvePoint ( new RPoint ( endPoint ) ) ; } private void quadBezierUniformStep ( ) { int steps = segmentSteps ; if ( segmentSteps == 0.0F ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; steps = ( int ) ( len * 0.25 ) ; if ( steps < 4 ) steps = 4 ; } float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y ; float temp = dt * dt ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop < steps ; loop ++ ) { addCurvePoint ( new RPoint ( fx , fy ) ) ; fx = fx + fdx + fdd_per_2x ; fdx = fdx + fddx ; fy = fy + fdy + fdd_per_2y ; fdy = fdy + fddy ; } addCurvePoint ( new RPoint ( endPoint ) ) ; } private void lineUniformLength ( ) { float dx1 = endPoint . x - startPoint . x ; float dy1 = endPoint . y - startPoint . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy ; fx = startPoint . x ; fdx = ( endPoint . x - startPoint . x ) * dt ; fy = startPoint . y ; fdy = ( endPoint . y - startPoint . y ) * dt ; for ( int loop = 0 ; loop <= steps ; loop ++ ) { if ( untilPoint <= 0 ) { addCurvePoint ( new RPoint ( fx , fy ) ) ; untilPoint += RCommand . segmentLength ; } untilPoint -= ( float ) Math . sqrt ( fdx * fdx + fdy * fdy ) ; fx = fx + fdx ; fy = fy + fdy ; } RCommand . segmentAccOffset = untilPoint ; } private void quadBezierUniformLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y , fix , fiy ; float temp = dt * dt ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop <= steps ; loop ++ ) { if ( untilPoint <= 0 ) { addCurvePoint ( new RPoint ( fx , fy ) ) ; untilPoint += RCommand . segmentLength ; } fix = fdx + fdd_per_2x ; fiy = fdy + fdd_per_2y ; untilPoint -= ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; fx = fx + fix ; fdx = fdx + fddx ; fy = fy + fiy ; fdy = fdy + fddy ; } RCommand . segmentAccOffset = untilPoint ; } private void cubicBezierUniformLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y , fix , fiy ; float temp = dt * dt ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop ++ ) { if ( untilPoint <= 0 ) { addCurvePoint ( new RPoint ( fx , fy ) ) ; untilPoint += RCommand . segmentLength ; } fix = fdx + fdd_per_2x + fddd_per_6x ; fiy = fdy + fdd_per_2y + fddd_per_6y ; untilPoint -= ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; fx = fx + fix ; fdx = fdx + fddx + fddd_per_2x ; fddx = fddx + fdddx ; fdd_per_2x = fdd_per_2x + fddd_per_2x ; fy = fy + fiy ; fdy = fdy + fddy + fddd_per_2y ; fddy = fddy + fdddy ; fdd_per_2y = fdd_per_2y + fddd_per_2y ; } RCommand . segmentAccOffset = untilPoint ; } private float quadBezierLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y , fix , fiy ; float temp = dt * dt ; float totallen = 0F ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop <= steps ; loop ++ ) { fix = fdx + fdd_per_2x ; fiy = fdy + fdd_per_2y ; totallen += ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; fx = fx + fix ; fdx = fdx + fddx ; fy = fy + fiy ; fdy = fdy + fddy ; } return totallen ; } private float cubicBezierLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y , fix , fiy ; float temp = dt * dt ; float totallen = 0F ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop ++ ) { fix = fdx + fdd_per_2x + fddd_per_6x ; fiy = fdy + fdd_per_2y + fddd_per_6y ; totallen += ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; fx = fx + fix ; fdx = fdx + fddx + fddd_per_2x ; fddx = fddx + fdddx ; fdd_per_2x = fdd_per_2x + fddd_per_2x ; fy = fy + fiy ; fdy = fdy + fddy + fddd_per_2y ; fddy = fddy + fdddy ; fdd_per_2y = fdd_per_2y + fddd_per_2y ; } return totallen ; } private void append ( RPoint nextcontrolpoint ) { RPoint [ ] newcontrolPoints ; if ( controlPoints == null ) { newcontrolPoints = new RPoint [ 1 ] ; newcontrolPoints [ 0 ] = nextcontrolpoint ; } else { newcontrolPoints = new RPoint [ controlPoints . length + 1 ] ; System . arraycopy ( controlPoints , 0 , newcontrolPoints , 0 , controlPoints . length ) ; newcontrolPoints [ controlPoints . length ] = nextcontrolpoint ; } this . controlPoints = newcontrolPoints ; } private void addCurvePoint ( RPoint nextcurvepoint ) { RPoint [ ] newcurvePoints ; if ( curvePoints == null ) { newcurvePoints = new RPoint [ 1 ] ; newcurvePoints [ 0 ] = nextcurvepoint ; } else { newcurvePoints = new RPoint [ curvePoints . length + 1 ] ; System . arraycopy ( curvePoints , 0 , newcurvePoints , 0 , curvePoints . length ) ; newcurvePoints [ curvePoints . length ] = nextcurvepoint ; } this . curvePoints = newcurvePoints ; } public RPoint [ ] intersectionPoints ( RCommand other ) { RPoint [ ] result = null ; switch ( commandType ) { case LINETO : switch ( other . getCommandType ( ) ) { case LINETO : result = lineLineIntersection ( this , other ) ; break ; case QUADBEZIERTO : result = lineQuadIntersection ( this , other ) ; break ; case CUBICBEZIERTO : result = lineCubicIntersection ( this , other ) ; break ; } break ; case QUADBEZIERTO : switch ( other . getCommandType ( ) ) { case LINETO : result = lineQuadIntersection ( other , this ) ; break ; case QUADBEZIERTO : result = quadQuadIntersection ( this , other ) ; break ; case CUBICBEZIERTO : result = quadCubicIntersection ( this , other ) ; break ; } break ; case CUBICBEZIERTO : switch ( other . getCommandType ( ) ) { case LINETO : result = lineCubicIntersection ( other , this ) ; break ; case QUADBEZIERTO : result = quadCubicIntersection ( other , this ) ; break ; case CUBICBEZIERTO : result = cubicCubicIntersection ( this , other ) ; break ; } break ; } return result ; } public static RPoint [ ] lineLineIntersection ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float epsilon = 1e-9f ; float denom = ( d . y - c . y ) * ( b . x - a . x ) - ( d . x - c . x ) * ( b . y - a . y ) ; if ( Math . abs ( denom ) < epsilon ) return null ; float t1 = ( ( d . x - c . x ) * ( a . y - c . y ) - ( d . y - c . y ) * ( a . x - c . x ) ) / denom ; float t2 = ( ( b . x - a . x ) * ( a . y - c . y ) - ( b . y - a . y ) * ( a . x - c . x ) ) / denom ; if ( t1 < 0.0f || t1 > 1.0f || t2 < 0.0f || t2 > 1.0f ) return null ; RPoint [ ] result = new RPoint [ 1 ] ; RPoint temp = new RPoint ( b ) ; temp . sub ( a ) ; temp . scale ( t1 ) ; result [ 0 ] = new RPoint ( a ) ; result [ 0 ] . add ( temp ) ; return result ; } public static RPoint [ ] lineQuadIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] lineCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadQuadIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] cubicCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public RClosest closestPoints ( RCommand other ) { RClosest result = new RClosest ( ) ; result . distance = 0 ; RPoint temp ; switch ( commandType ) { case LINETO : switch ( other . getCommandType ( ) ) { case LINETO : result . intersects = lineLineIntersection ( this , other ) ; if ( result . intersects == null ) { result = lineLineClosest ( this , other ) ; } break ; case QUADBEZIERTO : result . intersects = lineQuadIntersection ( this , other ) ; if ( result . intersects == null ) { result = lineQuadClosest ( this , other ) ; } break ; case CUBICBEZIERTO : result . intersects = lineCubicIntersection ( this , other ) ; if ( result . intersects == null ) { result = lineCubicClosest ( this , other ) ; } break ; } break ; case QUADBEZIERTO : switch ( other . getCommandType ( ) ) { case LINETO : result . intersects = lineQuadIntersection ( other , this ) ; if ( result . intersects == null ) { result = lineQuadClosest ( other , this ) ; temp = result . closest [ 0 ] ; result . closest [ 0 ] = result . closest [ 1 ] ; result . closest [ 1 ] = temp ; } break ; case QUADBEZIERTO : result . intersects = quadQuadIntersection ( this , other ) ; if ( result . intersects == null ) { result = quadQuadClosest ( this , other ) ; } break ; case CUBICBEZIERTO : result . intersects = quadCubicIntersection ( this , other ) ; if ( result . intersects == null ) { result = quadCubicClosest ( this , other ) ; } break ; } break ; case CUBICBEZIERTO : switch ( other . getCommandType ( ) ) { case LINETO : result . intersects = lineCubicIntersection ( other , this ) ; if ( result . intersects == null ) { result = lineCubicClosest ( other , this ) ; temp = result . closest [ 0 ] ; result . closest [ 0 ] = result . closest [ 1 ] ; result . closest [ 1 ] = temp ; } break ; case QUADBEZIERTO : result . intersects = quadCubicIntersection ( other , this ) ; if ( result . intersects == null ) { result = quadCubicClosest ( other , this ) ; temp = result . closest [ 0 ] ; result . closest [ 0 ] = result . closest [ 1 ] ; result . closest [ 1 ] = temp ; } break ; case CUBICBEZIERTO : result . intersects = cubicCubicIntersection ( this , other ) ; if ( result . intersects == null ) { result = cubicCubicClosest ( this , other ) ; } break ; } break ; } return result ; } public static float closestAdvFrom ( RCommand c , RPoint p ) { RPoint a = new RPoint ( c . startPoint ) ; RPoint b = new RPoint ( c . endPoint ) ; RPoint ap = new RPoint ( p ) ; ap . sub ( a ) ; RPoint ab = new RPoint ( b ) ; ab . sub ( a ) ; float denom = ab . sqrnorm ( ) ; float epsilon = 1e-19f ; if ( denom < epsilon ) return 0.5f ; float t = ( ab . x * ap . x + ab . y * ap . y ) / denom ; t = t > 0.0f ? t : 0.0f ; t = t < 1.0f ? t : 1.0f ; return t ; } public static RClosest lineLineClosest ( RCommand c1 , RCommand c2 ) { RPoint c1b = new RPoint ( c1 . startPoint ) ; RPoint c1e = new RPoint ( c1 . endPoint ) ; float c2t1 = closestAdvFrom ( c2 , c1b ) ; float c2t2 = closestAdvFrom ( c2 , c1e ) ; RPoint c2p1 = c2 . getPoint ( c2t1 ) ; RPoint c2p2 = c2 . getPoint ( c2t2 ) ; float dist1c2 = c2p1 . dist ( c1b ) ; float dist2c2 = c2p2 . dist ( c1e ) ; RPoint c2b = new RPoint ( c2 . startPoint ) ; RPoint c2e = new RPoint ( c2 . endPoint ) ; float c1t1 = closestAdvFrom ( c1 , c2b ) ; float c1t2 = closestAdvFrom ( c1 , c2e ) ; RPoint c1p1 = c1 . getPoint ( c1t1 ) ; RPoint c1p2 = c1 . getPoint ( c1t2 ) ; float dist1c1 = c1p1 . dist ( c2b ) ; float dist2c1 = c1p2 . dist ( c2e ) ; RClosest result = new RClosest ( ) ; result . distance = Math . min ( Math . min ( dist1c2 , dist2c2 ) , Math . min ( dist1c1 , dist2c1 ) ) ; result . closest = new RPoint [ 2 ] ; result . advancements = new float [ 2 ] ; if ( result . distance == dist1c2 ) { result . closest [ 0 ] = c1b ; result . closest [ 1 ] = c2p1 ; result . advancements [ 0 ] = 0 ; result . advancements [ 1 ] = c2t1 ; } else if ( result . distance == dist2c2 ) { result . closest [ 0 ] = c1e ; result . closest [ 1 ] = c2p2 ; result . advancements [ 0 ] = 1 ; result . advancements [ 1 ] = c2t2 ; } else if ( result . distance == dist1c1 ) { result . closest [ 0 ] = c2b ; result . closest [ 1 ] = c1p1 ; result . advancements [ 0 ] = 0 ; result . advancements [ 1 ] = c1t1 ; } else { result . closest [ 0 ] = c2e ; result . closest [ 1 ] = c1p2 ; result . advancements [ 0 ] = 1 ; result . advancements [ 1 ] = c1t2 ; } return result ; } public static RClosest lineQuadClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest lineCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest quadQuadClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest quadCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest cubicCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } } 
=======
public abstract class SchemaFactoryImpl extends SchemaFactory2 { private DatatypeLibraryFactory datatypeLibraryFactory = null ; private boolean defaultDatatypeLibraryFactory = true ; static final public String PROPERTY_DATATYPE_LIBRARY_FACTORY = "http://relaxng.org/properties/datatype-library-factory" ; protected SchemaFactoryImpl ( ) { } public Schema2 newSchema ( SAXSource source ) throws SAXException { Resolver resolver = null ; LSResourceResolver resourceResolver = getResourceResolver ( ) ; if ( resourceResolver != null ) resolver = LS . createResolver ( resourceResolver ) ; SAXResolver saxResolver = new SAXResolver ( resolver ) ; ErrorHandler eh = getErrorHandler ( ) ; if ( eh == null ) eh = new DraconianErrorHandler ( ) ; Parseable < Pattern , NameClass , Locator , VoidValue , CommentListImpl , AnnotationsImpl > parseable = createParseable ( source , saxResolver , eh ) ; SchemaPatternBuilder spb = new SchemaPatternBuilder ( ) ; try { return new SchemaImpl ( this , spb , SchemaBuilderImpl . parse ( parseable , eh , getDatatypeLibraryFactory ( ) , spb , false ) ) ; } catch ( IOException io ) { SAXParseException e = new SAXParseException ( io . getMessage ( ) , null , io ) ; eh . fatalError ( e ) ; throw e ; } catch ( IllegalSchemaException e ) { throw new SAXException ( "invalid schema" ) ; } } public void setProperty ( String name , Object object ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( PROPERTY_DATATYPE_LIBRARY_FACTORY . equals ( name ) ) { if ( object instanceof DatatypeLibraryFactory ) { datatypeLibraryFactory = ( DatatypeLibraryFactory ) object ; defaultDatatypeLibraryFactory = false ; } else throw new SAXNotSupportedException ( "value of \"" + PROPERTY_DATATYPE_LIBRARY_FACTORY + "\" property does not implement org.relaxng.datatype.DatatypeLibraryFactory" ) ; } else super . setProperty ( name , object ) ; } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( PROPERTY_DATATYPE_LIBRARY_FACTORY . equals ( name ) ) return getDatatypeLibraryFactory ( ) ; return super . getProperty ( name ) ; } private DatatypeLibraryFactory getDatatypeLibraryFactory ( ) { if ( defaultDatatypeLibraryFactory ) { datatypeLibraryFactory = new DatatypeLibraryFactoryImpl ( new RegexEngineImpl ( ) ) ; defaultDatatypeLibraryFactory = false ; } return datatypeLibraryFactory ; } abstract protected Parseable < Pattern , NameClass , Locator , VoidValue , CommentListImpl , AnnotationsImpl > createParseable ( SAXSource source , SAXResolver resolver , ErrorHandler eh ) throws SAXException ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
