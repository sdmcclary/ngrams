@ SuppressWarnings ( "restriction" ) public final class EFSUtils { private EFSUtils ( ) { } public static IFileStore getFileStore ( IResource resource ) { return WorkspaceFileSystem . getInstance ( ) . getStore ( resource . getFullPath ( ) ) ; } public static IFileStore getFileStore ( File file ) { return new LocalFile ( file ) ; } public static IFileStore getLocalFileStore ( File file ) { return EFS . getLocalFileSystem ( ) . fromLocalFile ( file ) ; } public static void setModificationTime ( long modifiedTime , IFileStore destFile ) throws CoreException { IFileInfo fi = new FileInfo ( ) ; fi . setLastModified ( modifiedTime ) ; destFile . putInfo ( fi , EFS . SET_LAST_MODIFIED , null ) ; } public static IFileStore [ ] getFiles ( IFileStore file ) throws CoreException { return getFiles ( file , false , true ) ; } public static IFileStore [ ] getFiles ( IFileStore file , IProgressMonitor monitor ) throws CoreException { return getFiles ( file , false , true , monitor ) ; } public static IFileStore [ ] getFiles ( IFileStore file , boolean recurse , boolean includeCloakedFiles ) throws CoreException { return getFiles ( file , recurse , includeCloakedFiles , null ) ; } public static String getAbsolutePath ( IFileStore file ) { return file . toURI ( ) . getPath ( ) ; } public static String getRelativePath ( IFileStore parent , IFileStore file ) { if ( parent . equals ( file ) || parent . isParentOf ( file ) ) { String rootFile = getAbsolutePath ( parent ) ; String childFile = getAbsolutePath ( file ) ; return childFile . substring ( rootFile . length ( ) ) ; } return null ; } public static IFileStore createFile ( IFileStore sourceRoot , IFileStore sourceStore , IFileStore destinationRoot ) { String sourceRootPath = sourceRoot . toURI ( ) . getPath ( ) ; String sourcePath = sourceStore . toURI ( ) . getPath ( ) ; int index = sourcePath . indexOf ( sourceRootPath ) ; if ( index > - 1 ) { String relativePath = sourcePath . substring ( index + sourceRootPath . length ( ) ) ; return destinationRoot . getFileStore ( new Path ( relativePath ) ) ; } return null ; } public static String getRelativePath ( IConnectionPoint point , IFileStore file ) { try { return getRelativePath ( point . getRoot ( ) , file ) ; } catch ( CoreException e ) { return null ; } } public static boolean copyFile ( IFileStore sourceStore , IFileStore destinationStore , IProgressMonitor monitor ) throws CoreException { if ( sourceStore == null || CloakingUtils . isFileCloaked ( sourceStore ) ) { return false ; } monitor = Policy . monitorFor ( monitor ) ; boolean success = true ; monitor . subTask ( MessageFormat . format ( "Copying {0} to {1}" , sourceStore . getName ( ) , destinationStore . getName ( ) ) ) ; sourceStore . copy ( destinationStore , EFS . OVERWRITE , monitor ) ; return success ; } public static boolean copyFileWithAttributes ( IFileStore sourceStore , IFileStore destinationStore , IProgressMonitor monitor , IFileInfo info ) throws CoreException { boolean success = copyFile ( sourceStore , destinationStore , monitor ) ; if ( success ) { EFSUtils . setModificationTime ( info . getLastModified ( ) , destinationStore ) ; } return success ; } public static IFileStore [ ] getFiles ( IFileStore file , boolean recurse , boolean includeCloakedFiles , IProgressMonitor monitor ) throws CoreException { IFileStore [ ] result = null ; ArrayList < IFileStore > list = new ArrayList < IFileStore > ( ) ; getFiles ( file , recurse , list , includeCloakedFiles , monitor ) ; result = list . toArray ( new IFileStore [ 0 ] ) ; return result ; } public static IFileStore [ ] getFiles ( IFileStore [ ] files , boolean recurse , boolean includeCloakedFiles , IProgressMonitor monitor ) throws CoreException { ArrayList < IFileStore > fileList = new ArrayList < IFileStore > ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { fileList . addAll ( Arrays . asList ( getFiles ( files [ i ] , recurse , includeCloakedFiles , monitor ) ) ) ; } return fileList . toArray ( new IFileStore [ 0 ] ) ; } public static IFileStore [ ] getAllFiles ( IFileStore [ ] files , boolean recurse , boolean includeCloakedFiles , IProgressMonitor monitor ) throws CoreException { ArrayList < IFileStore > fileList = new ArrayList < IFileStore > ( ) ; fileList . addAll ( Arrays . asList ( files ) ) ; IFileStore [ ] childFiles = getFiles ( files , true , false , monitor ) ; fileList . addAll ( Arrays . asList ( childFiles ) ) ; return fileList . toArray ( new IFileStore [ 0 ] ) ; } private static IProgressMonitor subMonitorFor ( IProgressMonitor monitor , int ticks ) { if ( monitor == null ) { return new NullProgressMonitor ( ) ; } if ( monitor instanceof NullProgressMonitor ) { return monitor ; } return new SubProgressMonitor ( monitor , ticks ) ; } private static void getFiles ( IFileStore file , boolean recurse , List < IFileStore > list , boolean includeCloakedFiles , IProgressMonitor monitor ) throws CoreException { if ( file == null ) { return ; } monitor = Policy . monitorFor ( monitor ) ; Policy . checkCanceled ( monitor ) ; if ( isFolder ( file , monitor ) ) { IFileStore [ ] children = file . childStores ( EFS . NONE , monitor ) ; if ( children != null ) { IProgressMonitor subMonitor = subMonitorFor ( monitor , 2 ) ; subMonitor . beginTask ( MessageFormat . format ( "Fetching children of {0}" , file . getName ( ) ) , children . length ) ; boolean addingFile ; for ( int i = 0 ; i < children . length ; i ++ ) { Policy . checkCanceled ( monitor ) ; IFileStore child = children [ i ] ; addingFile = false ; if ( includeCloakedFiles || ! CloakingUtils . isFileCloaked ( child ) ) { list . add ( child ) ; addingFile = true ; subMonitor . worked ( 1 ) ; } if ( recurse && addingFile && isFolder ( child , monitor ) ) { getFiles ( child , recurse , list , includeCloakedFiles , subMonitor ) ; } } subMonitor . done ( ) ; } } } private static boolean isFolder ( IFileStore file , IProgressMonitor monitor ) throws CoreException { IResource resource = ( IResource ) file . getAdapter ( IResource . class ) ; if ( resource instanceof IContainer ) { return true ; } else if ( ! ( resource instanceof IFile ) && file . fetchInfo ( EFS . NONE , monitor ) . isDirectory ( ) ) { return true ; } else { return false ; } } } 