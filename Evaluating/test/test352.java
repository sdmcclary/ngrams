<<<<<<< HEAD
public class HttpInputOutput extends AbstractBinaryOutput implements BinaryInput , BinaryOutput , LockableStream , EnvCleanup { private static final Logger log = Logger . getLogger ( HttpInputOutput . class . getName ( ) ) ; private Env _env ; private Path _path ; private StreamContextResource _context ; private LineReader _lineReader ; private ReadStream _is ; private WriteStream _os ; private HttpStreamWrapper _httpStream ; @ SuppressWarnings ( "unused" ) private Reader _readEncoding ; private String _readEncodingName ; private byte [ ] _bodyStart ; public HttpInputOutput ( Env env , Path path , StreamContextResource context ) throws IOException { init ( env , path , context ) ; } private void init ( Env env , Path path , StreamContextResource context ) throws IOException { _env = env ; _path = path ; env . addCleanup ( this ) ; _path = path ; _lineReader = new LineReader ( env ) ; if ( context != null ) { Value options = context . getOptions ( ) . get ( env . createStringOld ( path . getScheme ( ) ) ) ; String method = options . get ( env . createStringOld ( "method" ) ) . toString ( ) ; if ( method . equals ( "POST" ) ) { ReadWritePair pair = path . openReadWrite ( ) ; _is = pair . getReadStream ( ) ; _os = pair . getWriteStream ( ) ; } else _is = path . openRead ( ) ; _httpStream = ( HttpStreamWrapper ) _is . getSource ( ) ; setOptions ( env , options ) ; if ( _os != null && _bodyStart != null && _bodyStart . length > 0 ) _os . write ( _bodyStart , 0 , _bodyStart . length ) ; } else { _is = path . openRead ( ) ; _httpStream = ( HttpStreamWrapper ) _is . getSource ( ) ; } } private void setOptions ( Env env , Value options ) throws IOException { Iterator < Map . Entry < Value , Value > > iter = options . getIterator ( env ) ; while ( iter . hasNext ( ) ) { Map . Entry < Value , Value > entry = iter . next ( ) ; String optionName = entry . getKey ( ) . toString ( ) ; Value optionValue = entry . getValue ( ) ; if ( optionName . equals ( "method" ) ) _httpStream . setMethod ( optionValue . toString ( ) ) ; else if ( optionName . equals ( "header" ) ) { String option = optionValue . toString ( ) ; int start = 0 ; int len = option . length ( ) ; while ( start < len ) { int end = option . indexOf ( "\r\n" , start ) ; if ( end < 0 ) end = len ; int i = option . indexOf ( ':' , start ) ; if ( i < 0 || i > end ) { _httpStream . setAttribute ( option . substring ( start , end ) , "" ) ; break ; } else { String name = option . substring ( start , i ) ; String value = option . substring ( i + 1 , end ) . trim ( ) ; _httpStream . setAttribute ( name , value ) ; } start = end += 2 ; } } else if ( optionName . equals ( "user_agent" ) ) _httpStream . setAttribute ( "User-Agent" , optionValue . toString ( ) ) ; else if ( optionName . equals ( "content" ) ) _bodyStart = optionValue . toBinaryValue ( env ) . toBytes ( ) ; else if ( optionName . equals ( "proxy" ) ) env . stub ( "StreamContextResource::proxy option" ) ; else if ( optionName . equals ( "request_fulluri" ) ) env . stub ( "StreamContextResource::request_fulluri option" ) ; else if ( optionName . equals ( "protocol_version" ) ) { double version = optionValue . toDouble ( ) ; if ( version == 1.1 ) { } else if ( version == 1.0 ) _httpStream . setHttp10 ( ) ; else env . stub ( "StreamContextResource::protocol_version " + version ) ; } else if ( optionName . equals ( "timeout" ) ) { long ms = ( long ) optionValue . toDouble ( ) * 1000 ; _httpStream . setSocketTimeout ( ms ) ; } else if ( optionName . equals ( "ignore_errors" ) ) env . stub ( "ignore_errors::ignore_errors option" ) ; else env . stub ( "ignore_errors::" + optionName + " option" ) ; } } @ Override public void write ( int ch ) throws IOException { if ( _os != null ) _os . write ( ch ) ; } public StringValue appendTo ( StringValue builder ) throws IOException { if ( _is != null ) return builder . append ( _is ) ; else return builder ; } public InputStream getInputStream ( ) { return _is ; } public BinaryInput openCopy ( ) throws IOException { return new HttpInputOutput ( _env , _path , _context ) ; } public int read ( ) throws IOException { if ( _is != null ) return _is . read ( ) ; else return - 1 ; } public int read ( byte [ ] buffer , int offset , int length ) throws IOException { if ( _is != null ) return _is . read ( buffer , offset , length ) ; else return - 1 ; } public int read ( char [ ] buffer , int offset , int length ) throws IOException { if ( _is != null ) return _is . read ( buffer , offset , length ) ; else return - 1 ; } public StringValue read ( int length ) throws IOException { StringValue bb = _env . createBinaryBuilder ( ) ; TempBuffer temp = TempBuffer . allocate ( ) ; try { byte [ ] buffer = temp . getBuffer ( ) ; while ( length > 0 ) { int sublen = buffer . length ; if ( length < sublen ) sublen = length ; sublen = read ( buffer , 0 , sublen ) ; if ( sublen > 0 ) { bb . append ( buffer , 0 , sublen ) ; length -= sublen ; } else break ; } } finally { TempBuffer . free ( temp ) ; } return bb ; } @ Override public StringValue readLine ( long length ) throws IOException { return _lineReader . readLine ( _env , this , length ) ; } public boolean readOptionalLinefeed ( ) throws IOException { int ch = read ( ) ; if ( ch == '\n' ) { return true ; } else { unread ( ) ; return false ; } } public boolean isEOF ( ) { try { if ( _is == null ) return true ; return _is . available ( ) <= 0 ; } catch ( IOException e ) { return true ; } } public void setEncoding ( String encoding ) throws UnsupportedEncodingException { String mimeName = Encoding . getMimeName ( encoding ) ; if ( mimeName != null && mimeName . equals ( _readEncodingName ) ) return ; _readEncoding = Encoding . getReadEncoding ( getInputStream ( ) , encoding ) ; _readEncodingName = mimeName ; } @ Override public void unread ( ) throws IOException { if ( _is != null ) _is . unread ( ) ; } @ Override public boolean lock ( boolean shared , boolean block ) { return false ; } @ Override public boolean unlock ( ) { return false ; } public void closeRead ( ) { close ( ) ; } public void close ( ) { _env . removeCleanup ( this ) ; cleanup ( ) ; } @ Override public void cleanup ( ) { try { ReadStream is = _is ; WriteStream os = _os ; _is = null ; _os = null ; if ( is != null ) is . close ( ) ; if ( os != null ) os . close ( ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } } } 
=======
public class IdValidator extends IdContentHandler implements Validator { public IdValidator ( IdTypeMap idTypeMap , ErrorHandler eh ) { super ( idTypeMap , eh ) ; } public ContentHandler getContentHandler ( ) { return this ; } public DTDHandler getDTDHandler ( ) { return null ; } public void reset ( ) { super . reset ( ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
