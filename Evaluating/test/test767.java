@ SuppressWarnings ( "unchecked" ) public class DefaultRackEnvironment implements RackEnvironment { private final Ruby runtime ; private final Request request ; private RackInput input ; private final InputStream stream ; public DefaultRackEnvironment ( final Ruby runtime , final Request request ) { this . runtime = runtime ; this . request = request ; this . stream = new ByteBufInputStream ( this . request . getBody ( ) ) ; RubyIORackInput input = new RubyIORackInput ( this . runtime ) ; input . setBuffer ( this . request . getBody ( ) ) ; setRackInput ( input ) ; } private RubyHash createRubyHash ( final Request request ) { RubyHash env = request . getRubyHeaders ( ) ; assignConnectionRelatedCgiHeaders ( env , request ) ; tweakCgiVariables ( env , request . getUri ( ) ) ; updateEnv ( env , request ) ; return env ; } void updateEnv ( final RubyHash env , final Request request ) { env . put ( "rack.version" , Version . RACK ) ; env . put ( "rack.input" , getRackInput ( ) ) ; env . put ( "rack.errors" , new RubyIORackErrors ( runtime ) ) ; env . put ( "rack.multithread" , true ) ; env . put ( "rack.multiprocess" , false ) ; env . put ( "rack.run_once" , false ) ; } @ Override public InputStream getInput ( ) { return stream ; } @ Override public int getContentLength ( ) { return request . getBodyString ( ) . length ( ) ; } @ Override public RackInput getRackInput ( ) { return input ; } @ Override public void setRackInput ( final RackInput input ) { this . input = input ; } @ Override public RubyHash toRuby ( ) { return createRubyHash ( request ) ; } void assignConnectionRelatedCgiHeaders ( final RubyHash env , final Request request ) { InetSocketAddress remoteAddress = ( InetSocketAddress ) request . getRemoteAddress ( ) ; String remote = remoteAddress . getHostName ( ) . replace ( "/" , "" ) ; env . put ( "REMOTE_ADDR" , remote ) ; if ( ! env . containsKey ( "SERVER_NAME" ) && ! env . containsKey ( "SERVER_PORT" ) ) { if ( request . containsHeader ( HttpHeaderNames . HOST . toString ( ) ) ) { String [ ] parts = request . getHeader ( HttpHeaderNames . HOST . toString ( ) ) . split ( ":" ) ; if ( parts . length > 0 ) { env . put ( "SERVER_NAME" , parts [ 0 ] ) ; if ( parts . length > 1 ) { env . put ( "SERVER_PORT" , parts [ 1 ] ) ; } } } else { InetSocketAddress localAddress = ( InetSocketAddress ) request . getLocalAddress ( ) ; env . put ( "SERVER_NAME" , localAddress . getHostName ( ) ) ; env . put ( "SERVER_PORT" , String . valueOf ( localAddress . getPort ( ) ) ) ; } } env . put ( "SERVER_PROTOCOL" , request . getHttpRequest ( ) . protocolVersion ( ) . toString ( ) ) ; env . put ( "HTTP_VERSION" , request . getHttpRequest ( ) . protocolVersion ( ) . toString ( ) ) ; } void tweakCgiVariables ( final RubyHash env , final String path ) { env . putIfAbsent ( "SCRIPT_NAME" , "" ) ; if ( env . get ( "SCRIPT_NAME" ) . equals ( "/" ) ) env . put ( "SCRIPT_NAME" , "" ) ; if ( env . get ( "PATH_INFO" ) != null && env . get ( "PATH_INFO" ) . equals ( "" ) ) { env . remove ( "PATH_INFO" ) ; } if ( ! env . containsKey ( "SERVER_PORT" ) ) env . put ( "SERVER_PORT" , "80" ) ; env . put ( "REQUEST_URI" , path ) ; env . put ( "GATEWAY_INTERFACE" , "CGI/1.2" ) ; env . put ( "SERVER_SOFTWARE" , "Aspen " + Version . ASPEN ) ; } } 