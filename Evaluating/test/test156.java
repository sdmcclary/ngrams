<<<<<<< HEAD
public final class ComponentsFactory { private ComponentsFactory ( ) { } public static JComponent createInstructionsBox ( String text ) { JTextArea instructions = createInstructionsArea ( text ) ; return new JScrollPane ( instructions ) ; } public static JTextArea createInstructionsArea ( String text ) { JTextArea instructions = new JTextArea ( text ) ; instructions . setWrapStyleWord ( true ) ; instructions . setLineWrap ( true ) ; instructions . setTabSize ( 4 ) ; Color background = instructions . getBackground ( ) ; instructions . setEditable ( false ) ; instructions . setBackground ( background ) ; UifUtilities . smallerFont ( instructions ) ; instructions . setMargin ( new Insets ( 10 , 10 , 10 , 10 ) ) ; return instructions ; } public static JRadioButton createRadioButton ( String textWithMnemonic ) { return createRadioButton ( textWithMnemonic , null ) ; } public static JRadioButton createRadioButton ( String textWithMnemonic , ButtonModel model ) { JRadioButton button = new JRadioButton ( ) ; if ( model != null ) button . setModel ( model ) ; setTextAndMnemonic ( button , textWithMnemonic ) ; return button ; } public static JCheckBox createCheckBox ( String textWithMnemonic ) { return createCheckBox ( textWithMnemonic , null ) ; } public static JCheckBox createCheckBox ( String textWithMnemonic , ButtonModel model ) { JCheckBox checkBox = new JCheckBox ( ) ; if ( model != null ) checkBox . setModel ( model ) ; setTextAndMnemonic ( checkBox , textWithMnemonic ) ; return checkBox ; } public static JCheckBox createCheckBox ( String textWithMnemonic , Object bean , String propertyName , ValueModel trigger ) { return createCheckBox ( textWithMnemonic , new ToggleButtonAdapter ( new BufferedValueModel ( new PropertyAdapter ( bean , propertyName ) , trigger ) ) ) ; } public static JButton createButton ( String textWithMnemonic ) { JButton button = new JButton ( ) ; setTextAndMnemonic ( button , textWithMnemonic ) ; return button ; } public static JLabel createLabel ( String textWithMnemonic ) { MnemonicHolder holder = findMnemonic ( textWithMnemonic ) ; JLabel label = new JLabel ( holder . text ) ; if ( holder . mnemonicIndex != - 1 ) { label . setDisplayedMnemonic ( holder . mnemonicChar ) ; label . setDisplayedMnemonicIndex ( holder . mnemonicIndex ) ; } return label ; } public static AbstractButton setTextAndMnemonic ( AbstractButton button , String textWithMenmonic ) { setTextAndMnemonic ( button , findMnemonic ( textWithMenmonic ) ) ; return button ; } public static JTextArea createWrappedMultilineLabel ( String text ) { final JTextArea mlLabel = UIFactory . createWrappedMultilineLabel ( text ) ; final JLabel label = new JLabel ( ) ; mlLabel . setFont ( label . getFont ( ) ) ; mlLabel . setCursor ( label . getCursor ( ) ) ; return mlLabel ; } private static void setTextAndMnemonic ( AbstractButton button , MnemonicHolder holder ) { button . setText ( holder . text ) ; if ( holder . mnemonicIndex != - 1 ) { button . setMnemonic ( holder . mnemonicChar ) ; button . setDisplayedMnemonicIndex ( holder . mnemonicIndex ) ; } } private static MnemonicHolder findMnemonic ( String textWithMnemonic ) { MnemonicHolder holder = new MnemonicHolder ( ) ; holder . text = textWithMnemonic ; holder . mnemonicChar = ( char ) 0 ; holder . mnemonicIndex = - 1 ; if ( textWithMnemonic != null ) { int index = textWithMnemonic . indexOf ( '&' ) ; if ( index != - 1 ) { holder . mnemonicIndex = index ; holder . mnemonicChar = textWithMnemonic . charAt ( index + 1 ) ; int len = textWithMnemonic . length ( ) ; StringBuffer sb = new StringBuffer ( len - 1 ) ; sb . append ( textWithMnemonic . substring ( 0 , index ) ) ; sb . append ( textWithMnemonic . substring ( index + 1 , len ) ) ; holder . text = sb . toString ( ) ; } } return holder ; } public static JComponent createCollapsibleSeparator ( String textWithMnemonic , final JComponent comp ) { MnemonicHolder holder = findMnemonic ( textWithMnemonic ) ; CollapseControlLabel label = new CollapseControlLabel ( holder . text ) ; if ( holder . mnemonicIndex != - 1 ) { label . setDisplayedMnemonic ( holder . mnemonicChar ) ; label . setDisplayedMnemonicIndex ( holder . mnemonicIndex ) ; } if ( comp != null ) { comp . setVisible ( ! label . isCollapsed ( ) ) ; label . addPropertyChangeListener ( "collapsed" , new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { boolean collapsed = ( Boolean ) evt . getNewValue ( ) ; comp . setVisible ( ! collapsed ) ; } } ) ; } return label ; } private static class MnemonicHolder { private String text ; private char mnemonicChar ; private int mnemonicIndex ; } private static class CollapseControlLabel extends JLabel { private static final Icon ICON_COL_OUT = ResourceUtils . getIcon ( "ccl.col.out" ) ; private static final Icon ICON_COL_OVR = ResourceUtils . getIcon ( "ccl.col.ovr" ) ; private static final Icon ICON_EXP_OUT = ResourceUtils . getIcon ( "ccl.exp.out" ) ; private static final Icon ICON_EXP_OVR = ResourceUtils . getIcon ( "ccl.exp.ovr" ) ; private static final boolean DEFAULT_COLLAPSED = true ; private boolean collapsed ; private boolean over ; public CollapseControlLabel ( String text ) { this ( text , DEFAULT_COLLAPSED ) ; } public CollapseControlLabel ( String text , boolean aCollapsed ) { super ( text ) ; setCollapsed ( aCollapsed ) ; enableEvents ( AWTEvent . MOUSE_EVENT_MASK ) ; } public void setCollapsed ( boolean aCollapsed ) { if ( collapsed != aCollapsed ) { collapsed = aCollapsed ; updateCollapseIcon ( ) ; firePropertyChange ( "collapsed" , ! collapsed , collapsed ) ; } } public boolean isCollapsed ( ) { return collapsed ; } private void updateCollapseIcon ( ) { Icon icon ; if ( collapsed ) { icon = over ? ICON_COL_OVR : ICON_COL_OUT ; } else { icon = over ? ICON_EXP_OVR : ICON_EXP_OUT ; } setIcon ( icon ) ; } protected void processEvent ( AWTEvent e ) { int id = e . getID ( ) ; switch ( id ) { case MouseEvent . MOUSE_ENTERED : over = true ; updateCollapseIcon ( ) ; break ; case MouseEvent . MOUSE_EXITED : over = false ; updateCollapseIcon ( ) ; break ; case MouseEvent . MOUSE_CLICKED : setCollapsed ( ! collapsed ) ; break ; default : super . processEvent ( e ) ; break ; } } } } 
=======
class RestrictionViolationException extends Exception { private final String messageId ; private Locator loc ; private Name name ; private String namespaceUri ; RestrictionViolationException ( String messageId ) { this . messageId = messageId ; } RestrictionViolationException ( String messageId , Name name ) { this . messageId = messageId ; this . name = name ; } RestrictionViolationException ( String messageId , String namespaceUri ) { this . messageId = messageId ; this . namespaceUri = namespaceUri ; } String getMessageId ( ) { return messageId ; } Locator getLocator ( ) { return loc ; } void maybeSetLocator ( Locator loc ) { if ( this . loc == null ) this . loc = loc ; } Name getName ( ) { return name ; } String getNamespaceUri ( ) { return namespaceUri ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
