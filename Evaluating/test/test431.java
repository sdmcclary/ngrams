final class RowGroup { private final Cell [ ] EMPTY_CELL_ARRAY = { } ; private int currentRow = - 1 ; private int insertionPoint = 0 ; private int nextOldCell = 0 ; private final Table owner ; private final SortedSet < Cell > cellsIfEffect = new TreeSet < Cell > ( VerticalCellComparator . THE_INSTANCE ) ; private Cell [ ] cellsOnCurrentRow ; private boolean rowHadCells ; private final String type ; RowGroup ( Table owner , String type ) { super ( ) ; this . owner = owner ; this . type = type ; } public void cell ( Cell cell ) throws SAXException { rowHadCells = true ; findInsertionPoint ( ) ; cell . setPosition ( currentRow , insertionPoint ) ; owner . cell ( cell ) ; if ( cell . getBottom ( ) > currentRow + 1 ) { cellsIfEffect . add ( cell ) ; } insertionPoint = cell . getRight ( ) ; for ( int i = nextOldCell ; i < cellsOnCurrentRow . length ; i ++ ) { cellsOnCurrentRow [ i ] . errOnHorizontalOverlap ( cell ) ; } } private void findInsertionPoint ( ) { for ( ; ; ) { if ( nextOldCell == cellsOnCurrentRow . length ) { break ; } Cell other = cellsOnCurrentRow [ nextOldCell ] ; int newInsertionPoint = other . freeSlot ( insertionPoint ) ; if ( newInsertionPoint == insertionPoint ) { break ; } nextOldCell ++ ; insertionPoint = newInsertionPoint ; } } public void end ( ) throws SAXException { for ( Cell cell : cellsIfEffect ) { cell . errIfNotRowspanZero ( type ) ; } } public void endRow ( ) throws SAXException { if ( ! rowHadCells ) { owner . err ( "Row " + ( currentRow + 1 ) + " of " + ( type == null ? "an implicit row group" : "a row group established by a “" + type + "” element" ) + " has no cells beginning on it." ) ; } findInsertionPoint ( ) ; cellsOnCurrentRow = null ; int columnCount = owner . getColumnCount ( ) ; if ( owner . isHardWidth ( ) ) { if ( insertionPoint > columnCount ) { owner . err ( "A table row was " + insertionPoint + " columns wide and exceeded the column count established using column markup (" + columnCount + ")." ) ; } else if ( insertionPoint < columnCount ) { owner . err ( "A table row was " + insertionPoint + " columns wide, which is less than the column count established using column markup (" + columnCount + ")." ) ; } } else if ( columnCount == - 1 ) { owner . setColumnCount ( insertionPoint ) ; } else { if ( insertionPoint > columnCount ) { owner . warn ( "A table row was " + insertionPoint + " columns wide and exceeded the column count established by the first row (" + columnCount + ")." ) ; } else if ( insertionPoint < columnCount ) { owner . warn ( "A table row was " + insertionPoint + " columns wide, which is less than the column count established by the first row (" + columnCount + ")." ) ; } } for ( Iterator < Cell > iter = cellsIfEffect . iterator ( ) ; iter . hasNext ( ) ; ) { Cell cell = iter . next ( ) ; if ( cell . shouldBeCulled ( currentRow + 1 ) ) { iter . remove ( ) ; } } } public void startRow ( ) { currentRow ++ ; insertionPoint = 0 ; nextOldCell = 0 ; rowHadCells = false ; cellsOnCurrentRow = cellsIfEffect . toArray ( EMPTY_CELL_ARRAY ) ; Arrays . sort ( cellsOnCurrentRow , HorizontalCellComparator . THE_INSTANCE ) ; } } 