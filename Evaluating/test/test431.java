<<<<<<< HEAD
public class CustomConcurrentHashMap < K , V > extends AbstractMap < K , V > implements ConcurrentMap < K , V > , Serializable { private static final long serialVersionUID = 7249069246764182397L ; public enum Strength { strong ( "Strong" ) , weak ( "Weak" ) , soft ( "Soft" ) ; private final String name ; Strength ( String name ) { this . name = name ; } String getName ( ) { return name ; } } ; public static final Strength STRONG = Strength . strong ; public static final Strength WEAK = Strength . weak ; public static final Strength SOFT = Strength . soft ; private static final String SELF_STRING = "Self" ; private static final String INT_STRING = "Int" ; public static interface Equivalence < K > { boolean equal ( K key , Object x ) ; int hash ( Object x ) ; } static final class EquivalenceUsingIdentity implements Equivalence < Object > , Serializable { private static final long serialVersionUID = 7259069246764182397L ; public final boolean equal ( Object a , Object b ) { return a == b ; } public final int hash ( Object a ) { return System . identityHashCode ( a ) ; } } static final class EquivalenceUsingEquals implements Equivalence < Object > , Serializable { private static final long serialVersionUID = 7259069247764182397L ; public final boolean equal ( Object a , Object b ) { return a . equals ( b ) ; } public final int hash ( Object a ) { return a . hashCode ( ) ; } } public static final Equivalence < Object > IDENTITY = new EquivalenceUsingIdentity ( ) ; public static final Equivalence < Object > EQUALS = new EquivalenceUsingEquals ( ) ; public static interface MappingFunction < K , V > { V map ( K key ) ; } public static interface RemappingFunction < K , V > { V remap ( K key , V value ) ; } static interface Reclaimable { void onReclamation ( ) ; } static interface NodeFactory extends Serializable { Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) ; } static interface Node extends Reclaimable { Object get ( ) ; int getLocator ( ) ; Object getValue ( ) ; void setValue ( Object value ) ; Node getLinkage ( ) ; void setLinkage ( Node r ) ; } static final class Segment extends ReentrantLock { volatile Node [ ] table ; int count ; final void decrementCount ( ) { if ( -- count == 0 ) table = null ; } final void clearCount ( ) { count = 0 ; table = null ; } final void incrementCount ( ) { ++ count ; } final Node [ ] getTableForTraversal ( ) { return table ; } final Node [ ] getTableForAdd ( CustomConcurrentHashMap cchm ) { int len ; Node [ ] tab = table ; if ( tab == null || ( ( len = tab . length ) - ( len > > > 2 ) ) < count ) return resizeTable ( cchm ) ; else return tab ; } final Node [ ] resizeTable ( CustomConcurrentHashMap cchm ) { Node [ ] oldTable = table ; if ( oldTable == null ) return table = ( Node [ ] ) new Node [ cchm . initialSegmentCapacity ] ; int oldCapacity = oldTable . length ; if ( oldCapacity >= MAX_SEGMENT_CAPACITY ) return oldTable ; Node [ ] newTable = ( Node [ ] ) new Node [ oldCapacity << 1 ] ; int sizeMask = newTable . length - 1 ; NodeFactory fac = cchm . factory ; for ( int i = 0 ; i < oldCapacity ; i ++ ) { Node e = oldTable [ i ] ; if ( e != null ) { Node next = e . getLinkage ( ) ; int idx = e . getLocator ( ) & sizeMask ; if ( next == null ) newTable [ idx ] = e ; else { Node lastRun = e ; int lastIdx = idx ; for ( Node last = next ; last != null ; last = last . getLinkage ( ) ) { int k = last . getLocator ( ) & sizeMask ; if ( k != lastIdx ) { lastIdx = k ; lastRun = last ; } } newTable [ lastIdx ] = lastRun ; for ( Node p = e ; p != lastRun ; p = p . getLinkage ( ) ) { int ph = p . getLocator ( ) ; int k = ph & sizeMask ; Object pk = p . get ( ) ; Object pv ; if ( pk == null || ( pv = p . getValue ( ) ) == null ) -- count ; else newTable [ k ] = fac . newNode ( ph , pk , pv , cchm , newTable [ k ] ) ; } } } } return table = newTable ; } } static final int SEGMENT_BITS = 6 ; static final int NSEGMENTS = 1 << SEGMENT_BITS ; static final int SEGMENT_MASK = NSEGMENTS - 1 ; static final int SEGMENT_SHIFT = 32 - SEGMENT_BITS ; static final int MIN_SEGMENT_CAPACITY = 4 ; static final int MAX_SEGMENT_CAPACITY = 1 << ( 32 - SEGMENT_BITS ) ; static int spreadHash ( int h ) { h += ( h << 15 ) ^ 0xffffcd7d ; h ^= ( h > > > 10 ) ; h += ( h << 3 ) ; h ^= ( h > > > 6 ) ; h += ( h << 2 ) + ( h << 14 ) ; return h ^ ( h > > > 16 ) ; } transient volatile Segment [ ] segments ; final NodeFactory factory ; final Equivalence < ? super K > keyEquivalence ; final Equivalence < ? super V > valueEquivalence ; final int initialSegmentCapacity ; transient Set < K > keySet ; transient Set < Map . Entry < K , V > > entrySet ; transient Collection < V > values ; CustomConcurrentHashMap ( String ks , Equivalence < ? super K > keq , String vs , Equivalence < ? super V > veq , int expectedSize ) { if ( keq == null || veq == null ) throw new NullPointerException ( ) ; this . keyEquivalence = keq ; this . valueEquivalence = veq ; String factoryName = CustomConcurrentHashMap . class . getName ( ) + "$" + ks + "Key" + vs + "ValueNodeFactory" ; try { this . factory = ( NodeFactory ) ( Class . forName ( factoryName ) . newInstance ( ) ) ; } catch ( Exception ex ) { throw new Error ( "Cannot instantiate " + factoryName ) ; } int es = expectedSize ; if ( es == 0 ) this . initialSegmentCapacity = MIN_SEGMENT_CAPACITY ; else { int sc = ( int ) ( ( 1L + ( 4L * es ) / 3 ) > > > SEGMENT_BITS ) ; if ( sc < MIN_SEGMENT_CAPACITY ) sc = MIN_SEGMENT_CAPACITY ; else if ( sc > MAX_SEGMENT_CAPACITY ) sc = MAX_SEGMENT_CAPACITY ; this . initialSegmentCapacity = sc ; } this . segments = ( Segment [ ] ) new Segment [ NSEGMENTS ] ; } public CustomConcurrentHashMap ( Strength keyStrength , Equivalence < ? super K > keyEquivalence , Strength valueStrength , Equivalence < ? super V > valueEquivalence , int expectedSize ) { this ( keyStrength . getName ( ) , keyEquivalence , valueStrength . getName ( ) , valueEquivalence , expectedSize ) ; } public CustomConcurrentHashMap ( ) { this ( STRONG , EQUALS , STRONG , EQUALS , 0 ) ; } public static < ValueType > CustomConcurrentHashMap < Integer , ValueType > newIntKeyMap ( Strength valueStrength , Equivalence < ? super ValueType > valueEquivalence , int expectedSize ) { return new CustomConcurrentHashMap < Integer , ValueType > ( INT_STRING , EQUALS , valueStrength . getName ( ) , valueEquivalence , expectedSize ) ; } public static < KeyType > CustomConcurrentHashMap < KeyType , Integer > newIntValueMap ( Strength keyStrength , Equivalence < ? super KeyType > keyEquivalence , int expectedSize ) { return new CustomConcurrentHashMap < KeyType , Integer > ( keyStrength . getName ( ) , keyEquivalence , INT_STRING , EQUALS , expectedSize ) ; } public static CustomConcurrentHashMap < Integer , Integer > newIntKeyIntValueMap ( int expectedSize ) { return new CustomConcurrentHashMap < Integer , Integer > ( INT_STRING , EQUALS , INT_STRING , EQUALS , expectedSize ) ; } final Segment getSegmentForTraversal ( int hash ) { return segments [ ( hash > > > SEGMENT_SHIFT ) & SEGMENT_MASK ] ; } final Segment getSegmentForAdd ( int hash ) { Segment [ ] segs = segments ; int index = ( hash > > > SEGMENT_SHIFT ) & SEGMENT_MASK ; Segment seg = segs [ index ] ; if ( seg == null ) { synchronized ( segs ) { seg = segs [ index ] ; if ( seg == null ) { seg = new Segment ( ) ; storeSegment ( segs , index , seg ) ; } } } return seg ; } final Node findNode ( Object key , int hash , Segment seg ) { if ( seg != null ) { Node [ ] tab = seg . getTableForTraversal ( ) ; if ( tab != null ) { Node p = tab [ hash & ( tab . length - 1 ) ] ; while ( p != null ) { Object k = p . get ( ) ; if ( k == key || ( k != null && p . getLocator ( ) == hash && keyEquivalence . equal ( ( K ) k , key ) ) ) return p ; p = p . getLinkage ( ) ; } } } return null ; } public boolean containsKey ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForTraversal ( hash ) ; Node r = findNode ( key , hash , seg ) ; return r != null && r . getValue ( ) != null ; } public V get ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForTraversal ( hash ) ; Node r = findNode ( key , hash , seg ) ; if ( r == null ) return null ; return ( V ) ( r . getValue ( ) ) ; } final V doPut ( K key , V value , boolean onlyIfNull ) { if ( key == null || value == null ) throw new NullPointerException ( ) ; V oldValue = null ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForAdd ( hash ) ; seg . lock ( ) ; try { Node r = findNode ( key , hash , seg ) ; if ( r != null ) { oldValue = ( V ) ( r . getValue ( ) ) ; if ( ! onlyIfNull || oldValue == null ) r . setValue ( value ) ; } else { Node [ ] tab = seg . getTableForAdd ( this ) ; int i = hash & ( tab . length - 1 ) ; r = factory . newNode ( hash , key , value , this , tab [ i ] ) ; storeNode ( tab , i , r ) ; seg . incrementCount ( ) ; } } finally { seg . unlock ( ) ; } return oldValue ; } public V put ( K key , V value ) { return doPut ( key , value , false ) ; } public V putIfAbsent ( K key , V value ) { return doPut ( key , value , true ) ; } public void putAll ( Map < ? extends K , ? extends V > m ) { for ( Map . Entry < ? extends K , ? extends V > e : m . entrySet ( ) ) put ( e . getKey ( ) , e . getValue ( ) ) ; } public V replace ( K key , V value ) { if ( key == null || value == null ) throw new NullPointerException ( ) ; V oldValue = null ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForTraversal ( hash ) ; if ( seg != null ) { seg . lock ( ) ; try { Node r = findNode ( key , hash , seg ) ; if ( r != null ) { oldValue = ( V ) ( r . getValue ( ) ) ; r . setValue ( value ) ; } } finally { seg . unlock ( ) ; } } return oldValue ; } public boolean replace ( K key , V oldValue , V newValue ) { if ( key == null || oldValue == null || newValue == null ) throw new NullPointerException ( ) ; boolean replaced = false ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForTraversal ( hash ) ; if ( seg != null ) { seg . lock ( ) ; try { Node r = findNode ( key , hash , seg ) ; if ( r != null ) { V v = ( V ) ( r . getValue ( ) ) ; if ( v == oldValue || ( v != null && valueEquivalence . equal ( v , oldValue ) ) ) { r . setValue ( newValue ) ; replaced = true ; } } } finally { seg . unlock ( ) ; } } return replaced ; } public V remove ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; V oldValue = null ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForTraversal ( hash ) ; if ( seg != null ) { seg . lock ( ) ; try { Node [ ] tab = seg . getTableForTraversal ( ) ; if ( tab != null ) { int i = hash & ( tab . length - 1 ) ; Node pred = null ; Node p = tab [ i ] ; while ( p != null ) { Node n = p . getLinkage ( ) ; Object k = p . get ( ) ; if ( k == key || ( k != null && p . getLocator ( ) == hash && keyEquivalence . equal ( ( K ) k , key ) ) ) { oldValue = ( V ) ( p . getValue ( ) ) ; if ( pred == null ) tab [ i ] = n ; else pred . setLinkage ( n ) ; seg . decrementCount ( ) ; break ; } pred = p ; p = n ; } } } finally { seg . unlock ( ) ; } } return oldValue ; } public boolean remove ( Object key , Object value ) { if ( key == null ) throw new NullPointerException ( ) ; if ( value == null ) return false ; boolean removed = false ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForTraversal ( hash ) ; if ( seg != null ) { seg . lock ( ) ; try { Node [ ] tab = seg . getTableForTraversal ( ) ; if ( tab != null ) { int i = hash & ( tab . length - 1 ) ; Node pred = null ; Node p = tab [ i ] ; while ( p != null ) { Node n = p . getLinkage ( ) ; Object k = p . get ( ) ; if ( k == key || ( k != null && p . getLocator ( ) == hash && keyEquivalence . equal ( ( K ) k , key ) ) ) { V v = ( V ) ( p . getValue ( ) ) ; if ( v == value || ( v != null && valueEquivalence . equal ( v , value ) ) ) { if ( pred == null ) tab [ i ] = n ; else pred . setLinkage ( n ) ; seg . decrementCount ( ) ; removed = true ; } break ; } pred = p ; p = n ; } } } finally { seg . unlock ( ) ; } } return removed ; } final void removeIfReclaimed ( Node r ) { int hash = r . getLocator ( ) ; Segment seg = getSegmentForTraversal ( hash ) ; if ( seg != null ) { seg . lock ( ) ; try { Node [ ] tab = seg . getTableForTraversal ( ) ; if ( tab != null ) { int i = hash & ( tab . length - 1 ) ; Node pred = null ; Node p = tab [ i ] ; while ( p != null ) { Node n = p . getLinkage ( ) ; if ( p . get ( ) != null && p . getValue ( ) != null ) { if ( pred == null ) tab [ i ] = n ; else pred . setLinkage ( n ) ; seg . decrementCount ( ) ; p = n ; } else { pred = p ; p = n ; } } } } finally { seg . unlock ( ) ; } } } public final boolean isEmpty ( ) { final Segment [ ] segs = this . segments ; for ( int i = 0 ; i < segs . length ; ++ i ) { Segment seg = segs [ i ] ; if ( seg != null && seg . getTableForTraversal ( ) != null && seg . count != 0 ) return false ; } return true ; } public final int size ( ) { long sum = 0 ; final Segment [ ] segs = this . segments ; for ( int i = 0 ; i < segs . length ; ++ i ) { Segment seg = segs [ i ] ; if ( seg != null && seg . getTableForTraversal ( ) != null ) sum += seg . count ; } return sum >= Integer . MAX_VALUE ? Integer . MAX_VALUE : ( int ) sum ; } public final boolean containsValue ( Object value ) { if ( value == null ) throw new NullPointerException ( ) ; Segment [ ] segs = this . segments ; for ( int i = 0 ; i < segs . length ; ++ i ) { Segment seg = segs [ i ] ; Node [ ] tab ; if ( seg != null && ( tab = seg . getTableForTraversal ( ) ) != null ) { for ( int j = 0 ; j < tab . length ; ++ j ) { for ( Node p = tab [ j ] ; p != null ; p = p . getLinkage ( ) ) { V v = ( V ) ( p . getValue ( ) ) ; if ( v == value || ( v != null && valueEquivalence . equal ( v , value ) ) ) return true ; } } } } return false ; } public final void clear ( ) { Segment [ ] segs = this . segments ; for ( int i = 0 ; i < segs . length ; ++ i ) { Segment seg = segs [ i ] ; if ( seg != null ) { seg . lock ( ) ; try { seg . clearCount ( ) ; } finally { seg . unlock ( ) ; } } } } public V computeIfAbsent ( K key , MappingFunction < ? super K , ? extends V > mappingFunction ) { if ( key == null || mappingFunction == null ) throw new NullPointerException ( ) ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; Segment seg = getSegmentForTraversal ( hash ) ; Node r = findNode ( key , hash , seg ) ; V v = null ; if ( r == null ) { if ( seg == null ) seg = getSegmentForAdd ( hash ) ; seg . lock ( ) ; try { r = findNode ( key , hash , seg ) ; if ( r == null || ( v = ( V ) ( r . getValue ( ) ) ) == null ) { v = mappingFunction . map ( key ) ; if ( v != null ) { if ( r != null ) r . setValue ( v ) ; else { Node [ ] tab = seg . getTableForAdd ( this ) ; int i = hash & ( tab . length - 1 ) ; r = factory . newNode ( hash , key , v , this , tab [ i ] ) ; storeNode ( tab , i , r ) ; seg . incrementCount ( ) ; } } } } finally { seg . unlock ( ) ; } } if ( r != null && v == null ) removeIfReclaimed ( r ) ; return v ; } public V compute ( K key , RemappingFunction < ? super K , V > remappingFunction ) { if ( key == null || remappingFunction == null ) throw new NullPointerException ( ) ; int hash = spreadHash ( keyEquivalence . hash ( key ) ) ; V value = null ; Segment seg = getSegmentForAdd ( hash ) ; seg . lock ( ) ; try { Node [ ] tab = seg . getTableForAdd ( this ) ; int i = hash & ( tab . length - 1 ) ; Node pred = null ; Node p = tab [ i ] ; while ( p != null ) { K k = ( K ) ( p . get ( ) ) ; if ( k == key || ( k != null && p . getLocator ( ) == hash && keyEquivalence . equal ( k , key ) ) ) { value = ( V ) ( p . getValue ( ) ) ; break ; } pred = p ; p = p . getLinkage ( ) ; } value = remappingFunction . remap ( key , value ) ; if ( p != null ) { if ( value != null ) p . setValue ( value ) ; else { Node n = p . getLinkage ( ) ; if ( pred == null ) tab [ i ] = n ; else pred . setLinkage ( n ) ; seg . decrementCount ( ) ; } } else if ( value != null ) { Node r = factory . newNode ( hash , key , value , this , tab [ i ] ) ; storeNode ( tab , i , r ) ; seg . incrementCount ( ) ; } } finally { seg . unlock ( ) ; } return value ; } abstract class HashIterator { int nextSegmentIndex ; int nextTableIndex ; Node [ ] currentTable ; Node nextNode ; Object nextKey ; Object nextValue ; Object lastKey ; HashIterator ( ) { nextSegmentIndex = segments . length - 1 ; nextTableIndex = - 1 ; advance ( ) ; } public final boolean hasNext ( ) { return nextNode != null ; } final void advance ( ) { lastKey = nextKey ; if ( nextNode != null ) nextNode = nextNode . getLinkage ( ) ; for ( ; ; ) { if ( nextNode != null ) { if ( ( nextKey = nextNode . get ( ) ) != null && ( nextValue = nextNode . getValue ( ) ) != null ) return ; Node n = nextNode . getLinkage ( ) ; removeIfReclaimed ( nextNode ) ; nextNode = n ; } else if ( nextTableIndex >= 0 ) { nextNode = currentTable [ nextTableIndex -- ] ; } else if ( nextSegmentIndex >= 0 ) { Segment seg = segments [ nextSegmentIndex -- ] ; Node [ ] t ; if ( seg != null && ( t = seg . getTableForTraversal ( ) ) != null ) { currentTable = t ; nextTableIndex = t . length - 1 ; } } else { nextKey = null ; nextValue = null ; return ; } } } final K nextKey ( ) { if ( nextNode == null ) throw new NoSuchElementException ( ) ; Object k = nextKey ; advance ( ) ; return ( K ) k ; } final V nextValue ( ) { if ( nextNode == null ) throw new NoSuchElementException ( ) ; Object v = nextValue ; advance ( ) ; return ( V ) v ; } final Map . Entry < K , V > nextEntry ( ) { if ( nextNode == null ) throw new NoSuchElementException ( ) ; WriteThroughEntry e = new WriteThroughEntry ( ( K ) nextKey , ( V ) nextValue ) ; advance ( ) ; return e ; } public void remove ( ) { if ( lastKey == null ) throw new IllegalStateException ( ) ; CustomConcurrentHashMap . this . remove ( lastKey ) ; lastKey = null ; } } final class WriteThroughEntry implements Map . Entry < K , V > , Serializable { private static final long serialVersionUID = 7249069346764182397L ; final K key ; V value ; WriteThroughEntry ( K key , V value ) { this . key = key ; this . value = value ; } public K getKey ( ) { return key ; } public V getValue ( ) { return value ; } public V setValue ( V value ) { if ( value == null ) throw new NullPointerException ( ) ; V v = this . value ; this . value = value ; CustomConcurrentHashMap . this . doPut ( key , value , false ) ; return v ; } public int hashCode ( ) { return keyEquivalence . hash ( key ) ^ valueEquivalence . hash ( value ) ; } public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) return false ; Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; return ( keyEquivalence . equal ( key , e . getKey ( ) ) && valueEquivalence . equal ( value , e . getValue ( ) ) ) ; } } final class KeyIterator extends HashIterator implements Iterator < K > { public K next ( ) { return super . nextKey ( ) ; } } final KeyIterator keyIterator ( ) { return new KeyIterator ( ) ; } final class ValueIterator extends HashIterator implements Iterator < V > { public V next ( ) { return super . nextValue ( ) ; } } final class EntryIterator extends HashIterator implements Iterator < Map . Entry < K , V > > { public Map . Entry < K , V > next ( ) { return super . nextEntry ( ) ; } } final class KeySetView extends AbstractSet < K > { public Iterator < K > iterator ( ) { return new KeyIterator ( ) ; } public int size ( ) { return CustomConcurrentHashMap . this . size ( ) ; } public boolean isEmpty ( ) { return CustomConcurrentHashMap . this . isEmpty ( ) ; } public boolean contains ( Object o ) { return CustomConcurrentHashMap . this . containsKey ( o ) ; } public boolean remove ( Object o ) { return CustomConcurrentHashMap . this . remove ( o ) != null ; } public void clear ( ) { CustomConcurrentHashMap . this . clear ( ) ; } } final class Values extends AbstractCollection < V > { public Iterator < V > iterator ( ) { return new ValueIterator ( ) ; } public int size ( ) { return CustomConcurrentHashMap . this . size ( ) ; } public boolean isEmpty ( ) { return CustomConcurrentHashMap . this . isEmpty ( ) ; } public boolean contains ( Object o ) { return CustomConcurrentHashMap . this . containsValue ( o ) ; } public void clear ( ) { CustomConcurrentHashMap . this . clear ( ) ; } } final class EntrySet extends AbstractSet < Map . Entry < K , V > > { public Iterator < Map . Entry < K , V > > iterator ( ) { return new EntryIterator ( ) ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) return false ; Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; V v = CustomConcurrentHashMap . this . get ( e . getKey ( ) ) ; return v != null && valueEquivalence . equal ( v , e . getValue ( ) ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) return false ; Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; return CustomConcurrentHashMap . this . remove ( e . getKey ( ) , e . getValue ( ) ) ; } public int size ( ) { return CustomConcurrentHashMap . this . size ( ) ; } public boolean isEmpty ( ) { return CustomConcurrentHashMap . this . isEmpty ( ) ; } public void clear ( ) { CustomConcurrentHashMap . this . clear ( ) ; } } public Set < K > keySet ( ) { Set < K > ks = keySet ; return ( ks != null ) ? ks : ( keySet = new KeySetView ( ) ) ; } public Collection < V > values ( ) { Collection < V > vs = values ; return ( vs != null ) ? vs : ( values = new Values ( ) ) ; } public Set < Map . Entry < K , V > > entrySet ( ) { Set < Map . Entry < K , V > > es = entrySet ; return ( es != null ) ? es : ( entrySet = new EntrySet ( ) ) ; } public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Map ) ) return false ; Map < K , V > m = ( Map < K , V > ) o ; if ( m . size ( ) != size ( ) ) return false ; try { Iterator < Entry < K , V > > i = entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Entry < K , V > e = i . next ( ) ; K key = e . getKey ( ) ; V value = e . getValue ( ) ; if ( value != null ) { V mv = m . get ( key ) ; if ( mv == null ) return false ; if ( ! valueEquivalence . equal ( mv , value ) ) return false ; } } } catch ( ClassCastException unused ) { return false ; } catch ( NullPointerException unused ) { return false ; } return true ; } public int hashCode ( ) { int h = 0 ; Iterator < Entry < K , V > > i = entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) h += i . next ( ) . hashCode ( ) ; return h ; } private void writeObject ( java . io . ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; for ( Map . Entry < K , V > e : entrySet ( ) ) { s . writeObject ( e . getKey ( ) ) ; s . writeObject ( e . getValue ( ) ) ; } s . writeObject ( null ) ; s . writeObject ( null ) ; } private void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; this . segments = ( Segment [ ] ) ( new Segment [ NSEGMENTS ] ) ; for ( ; ; ) { K key = ( K ) s . readObject ( ) ; V value = ( V ) s . readObject ( ) ; if ( key == null ) break ; put ( key , value ) ; } } public static class KeySet < K > extends AbstractSet < K > implements Set < K > , Serializable { final CustomConcurrentHashMap < K , K > cchm ; public KeySet ( Strength strength , Equivalence < ? super K > equivalence , int expectedSize ) { this . cchm = new CustomConcurrentHashMap < K , K > ( strength . getName ( ) , equivalence , SELF_STRING , equivalence , expectedSize ) ; } public K intern ( K e ) { K oldElement = cchm . doPut ( e , e , true ) ; return ( oldElement != null ) ? oldElement : e ; } public boolean contains ( Object o ) { return cchm . containsKey ( o ) ; } public Iterator < K > iterator ( ) { return cchm . keyIterator ( ) ; } public boolean add ( K e ) { return cchm . doPut ( e , e , true ) != null ; } public boolean remove ( Object o ) { return cchm . remove ( o ) != null ; } public boolean isEmpty ( ) { return cchm . isEmpty ( ) ; } public int size ( ) { return cchm . size ( ) ; } public void clear ( ) { cchm . clear ( ) ; } public int hashCode ( ) { int h = 0 ; Iterator < K > i = iterator ( ) ; while ( i . hasNext ( ) ) h += cchm . keyEquivalence . hash ( i . next ( ) ) ; return h ; } } static volatile ReferenceQueue < Object > refQueue ; static ReferenceQueue < Object > getReclamationQueue ( ) { ReferenceQueue < Object > q = refQueue ; if ( q != null ) return q ; else return startReclamation ( ) ; } static synchronized ReferenceQueue < Object > startReclamation ( ) { ReferenceQueue < Object > q = refQueue ; if ( q == null ) { refQueue = q = new ReferenceQueue < Object > ( ) ; new ReclamationThread ( q ) . start ( ) ; } return q ; } static final class ReclamationThread extends Thread { final ReferenceQueue < Object > queue ; ReclamationThread ( ReferenceQueue < Object > q ) { this . queue = q ; setDaemon ( true ) ; } public void run ( ) { ReferenceQueue < Object > q = queue ; for ( ; ; ) { try { Reference < ? > r = q . remove ( ) ; if ( r instanceof Reclaimable ) ( ( Reclaimable ) r ) . onReclamation ( ) ; } catch ( InterruptedException e ) { } } } } static class EmbeddedWeakReference extends WeakReference implements Reclaimable { final Reclaimable outer ; EmbeddedWeakReference ( Object x , Reclaimable outer ) { super ( x , getReclamationQueue ( ) ) ; this . outer = outer ; } public final void onReclamation ( ) { clear ( ) ; outer . onReclamation ( ) ; } } static class EmbeddedSoftReference extends SoftReference implements Reclaimable { final Reclaimable outer ; EmbeddedSoftReference ( Object x , Reclaimable outer ) { super ( x , getReclamationQueue ( ) ) ; this . outer = outer ; } public final void onReclamation ( ) { clear ( ) ; outer . onReclamation ( ) ; } } static abstract class StrongKeyNode implements Node { final Object key ; final int locator ; StrongKeyNode ( int locator , Object key ) { this . locator = locator ; this . key = key ; } public final Object get ( ) { return key ; } public final int getLocator ( ) { return locator ; } } static abstract class StrongKeySelfValueNode extends StrongKeyNode { StrongKeySelfValueNode ( int locator , Object key ) { super ( locator , key ) ; } public final Object getValue ( ) { return key ; } public final void setValue ( Object value ) { } public final void onReclamation ( ) { } } static final class TerminalStrongKeySelfValueNode extends StrongKeySelfValueNode { TerminalStrongKeySelfValueNode ( int locator , Object key ) { super ( locator , key ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedStrongKeySelfValueNode extends StrongKeySelfValueNode { volatile Node linkage ; LinkedStrongKeySelfValueNode ( int locator , Object key , Node linkage ) { super ( locator , key ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class StrongKeySelfValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalStrongKeySelfValueNode ( locator , key ) ; else return new LinkedStrongKeySelfValueNode ( locator , key , linkage ) ; } } static abstract class StrongKeyStrongValueNode extends StrongKeyNode { volatile Object value ; StrongKeyStrongValueNode ( int locator , Object key , Object value ) { super ( locator , key ) ; this . value = value ; } public final Object getValue ( ) { return value ; } public final void setValue ( Object value ) { this . value = value ; } public final void onReclamation ( ) { } } static final class TerminalStrongKeyStrongValueNode extends StrongKeyStrongValueNode { TerminalStrongKeyStrongValueNode ( int locator , Object key , Object value ) { super ( locator , key , value ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedStrongKeyStrongValueNode extends StrongKeyStrongValueNode { volatile Node linkage ; LinkedStrongKeyStrongValueNode ( int locator , Object key , Object value , Node linkage ) { super ( locator , key , value ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class StrongKeyStrongValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalStrongKeyStrongValueNode ( locator , key , value ) ; else return new LinkedStrongKeyStrongValueNode ( locator , key , value , linkage ) ; } } static abstract class StrongKeyIntValueNode extends StrongKeyNode { volatile int value ; StrongKeyIntValueNode ( int locator , Object key , Object value ) { super ( locator , key ) ; this . value = ( ( Integer ) value ) . intValue ( ) ; } public final Object getValue ( ) { return Integer . valueOf ( value ) ; } public final void setValue ( Object value ) { this . value = ( ( Integer ) value ) . intValue ( ) ; } public final void onReclamation ( ) { } } static final class TerminalStrongKeyIntValueNode extends StrongKeyIntValueNode { TerminalStrongKeyIntValueNode ( int locator , Object key , Object value ) { super ( locator , key , value ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedStrongKeyIntValueNode extends StrongKeyIntValueNode { volatile Node linkage ; LinkedStrongKeyIntValueNode ( int locator , Object key , Object value , Node linkage ) { super ( locator , key , value ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class StrongKeyIntValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalStrongKeyIntValueNode ( locator , key , value ) ; else return new LinkedStrongKeyIntValueNode ( locator , key , value , linkage ) ; } } static abstract class StrongKeyWeakValueNode extends StrongKeyNode { volatile EmbeddedWeakReference valueRef ; final CustomConcurrentHashMap cchm ; StrongKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key ) ; this . cchm = cchm ; if ( value != null ) this . valueRef = new EmbeddedWeakReference ( value , this ) ; } public final void onReclamation ( ) { cchm . removeIfReclaimed ( this ) ; } public final Object getValue ( ) { EmbeddedWeakReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedWeakReference ( value , this ) ; } } static final class TerminalStrongKeyWeakValueNode extends StrongKeyWeakValueNode { TerminalStrongKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedStrongKeyWeakValueNode extends StrongKeyWeakValueNode { volatile Node linkage ; LinkedStrongKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class StrongKeyWeakValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalStrongKeyWeakValueNode ( locator , key , value , cchm ) ; else return new LinkedStrongKeyWeakValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class StrongKeySoftValueNode extends StrongKeyNode { volatile EmbeddedSoftReference valueRef ; final CustomConcurrentHashMap cchm ; StrongKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key ) ; this . cchm = cchm ; if ( value != null ) this . valueRef = new EmbeddedSoftReference ( value , this ) ; } public final void onReclamation ( ) { cchm . removeIfReclaimed ( this ) ; } public final Object getValue ( ) { EmbeddedSoftReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedSoftReference ( value , this ) ; } } static final class TerminalStrongKeySoftValueNode extends StrongKeySoftValueNode { TerminalStrongKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedStrongKeySoftValueNode extends StrongKeySoftValueNode { volatile Node linkage ; LinkedStrongKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class StrongKeySoftValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalStrongKeySoftValueNode ( locator , key , value , cchm ) ; else return new LinkedStrongKeySoftValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class WeakKeyNode extends WeakReference implements Node { final int locator ; final CustomConcurrentHashMap cchm ; WeakKeyNode ( int locator , Object key , CustomConcurrentHashMap cchm ) { super ( key ) ; this . locator = locator ; this . cchm = cchm ; } public final int getLocator ( ) { return locator ; } public final void onReclamation ( ) { clear ( ) ; cchm . removeIfReclaimed ( this ) ; } } static abstract class WeakKeySelfValueNode extends WeakKeyNode { WeakKeySelfValueNode ( int locator , Object key , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; } public final Object getValue ( ) { return get ( ) ; } public final void setValue ( Object value ) { } } static final class TerminalWeakKeySelfValueNode extends WeakKeySelfValueNode { TerminalWeakKeySelfValueNode ( int locator , Object key , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedWeakKeySelfValueNode extends WeakKeySelfValueNode { volatile Node linkage ; LinkedWeakKeySelfValueNode ( int locator , Object key , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class WeakKeySelfValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalWeakKeySelfValueNode ( locator , key , cchm ) ; else return new LinkedWeakKeySelfValueNode ( locator , key , cchm , linkage ) ; } } static abstract class WeakKeyStrongValueNode extends WeakKeyNode { volatile Object value ; WeakKeyStrongValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; this . value = value ; } public final Object getValue ( ) { return value ; } public final void setValue ( Object value ) { this . value = value ; } } static final class TerminalWeakKeyStrongValueNode extends WeakKeyStrongValueNode { TerminalWeakKeyStrongValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedWeakKeyStrongValueNode extends WeakKeyStrongValueNode { volatile Node linkage ; LinkedWeakKeyStrongValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class WeakKeyStrongValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalWeakKeyStrongValueNode ( locator , key , value , cchm ) ; else return new LinkedWeakKeyStrongValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class WeakKeyIntValueNode extends WeakKeyNode { volatile int value ; WeakKeyIntValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; this . value = ( ( Integer ) value ) . intValue ( ) ; } public final Object getValue ( ) { return Integer . valueOf ( value ) ; } public final void setValue ( Object value ) { this . value = ( ( Integer ) value ) . intValue ( ) ; } } static final class TerminalWeakKeyIntValueNode extends WeakKeyIntValueNode { TerminalWeakKeyIntValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedWeakKeyIntValueNode extends WeakKeyIntValueNode { volatile Node linkage ; LinkedWeakKeyIntValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class WeakKeyIntValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalWeakKeyIntValueNode ( locator , key , value , cchm ) ; else return new LinkedWeakKeyIntValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class WeakKeyWeakValueNode extends WeakKeyNode { volatile EmbeddedWeakReference valueRef ; WeakKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; if ( value != null ) this . valueRef = new EmbeddedWeakReference ( value , this ) ; } public final Object getValue ( ) { EmbeddedWeakReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedWeakReference ( value , this ) ; } } static final class TerminalWeakKeyWeakValueNode extends WeakKeyWeakValueNode { TerminalWeakKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedWeakKeyWeakValueNode extends WeakKeyWeakValueNode { volatile Node linkage ; LinkedWeakKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class WeakKeyWeakValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalWeakKeyWeakValueNode ( locator , key , value , cchm ) ; else return new LinkedWeakKeyWeakValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class WeakKeySoftValueNode extends WeakKeyNode { volatile EmbeddedSoftReference valueRef ; WeakKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; if ( value != null ) this . valueRef = new EmbeddedSoftReference ( value , this ) ; } public final Object getValue ( ) { EmbeddedSoftReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedSoftReference ( value , this ) ; } } static final class TerminalWeakKeySoftValueNode extends WeakKeySoftValueNode { TerminalWeakKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedWeakKeySoftValueNode extends WeakKeySoftValueNode { volatile Node linkage ; LinkedWeakKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class WeakKeySoftValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalWeakKeySoftValueNode ( locator , key , value , cchm ) ; else return new LinkedWeakKeySoftValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class SoftKeyNode extends SoftReference implements Node { final int locator ; final CustomConcurrentHashMap cchm ; SoftKeyNode ( int locator , Object key , CustomConcurrentHashMap cchm ) { super ( key ) ; this . locator = locator ; this . cchm = cchm ; } public final int getLocator ( ) { return locator ; } public final void onReclamation ( ) { clear ( ) ; cchm . removeIfReclaimed ( this ) ; } } static abstract class SoftKeySelfValueNode extends SoftKeyNode { SoftKeySelfValueNode ( int locator , Object key , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; } public final Object getValue ( ) { return get ( ) ; } public final void setValue ( Object value ) { } } static final class TerminalSoftKeySelfValueNode extends SoftKeySelfValueNode { TerminalSoftKeySelfValueNode ( int locator , Object key , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedSoftKeySelfValueNode extends SoftKeySelfValueNode { volatile Node linkage ; LinkedSoftKeySelfValueNode ( int locator , Object key , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class SoftKeySelfValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalSoftKeySelfValueNode ( locator , key , cchm ) ; else return new LinkedSoftKeySelfValueNode ( locator , key , cchm , linkage ) ; } } static abstract class SoftKeyStrongValueNode extends SoftKeyNode { volatile Object value ; SoftKeyStrongValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; this . value = value ; } public final Object getValue ( ) { return value ; } public final void setValue ( Object value ) { this . value = value ; } } static final class TerminalSoftKeyStrongValueNode extends SoftKeyStrongValueNode { TerminalSoftKeyStrongValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedSoftKeyStrongValueNode extends SoftKeyStrongValueNode { volatile Node linkage ; LinkedSoftKeyStrongValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class SoftKeyStrongValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalSoftKeyStrongValueNode ( locator , key , value , cchm ) ; else return new LinkedSoftKeyStrongValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class SoftKeyIntValueNode extends SoftKeyNode { volatile int value ; SoftKeyIntValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; this . value = ( ( Integer ) value ) . intValue ( ) ; } public final Object getValue ( ) { return Integer . valueOf ( value ) ; } public final void setValue ( Object value ) { this . value = ( ( Integer ) value ) . intValue ( ) ; } } static final class TerminalSoftKeyIntValueNode extends SoftKeyIntValueNode { TerminalSoftKeyIntValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedSoftKeyIntValueNode extends SoftKeyIntValueNode { volatile Node linkage ; LinkedSoftKeyIntValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class SoftKeyIntValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalSoftKeyIntValueNode ( locator , key , value , cchm ) ; else return new LinkedSoftKeyIntValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class SoftKeyWeakValueNode extends SoftKeyNode { volatile EmbeddedWeakReference valueRef ; SoftKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; if ( value != null ) this . valueRef = new EmbeddedWeakReference ( value , this ) ; } public final Object getValue ( ) { EmbeddedWeakReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedWeakReference ( value , this ) ; } } static final class TerminalSoftKeyWeakValueNode extends SoftKeyWeakValueNode { TerminalSoftKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedSoftKeyWeakValueNode extends SoftKeyWeakValueNode { volatile Node linkage ; LinkedSoftKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class SoftKeyWeakValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalSoftKeyWeakValueNode ( locator , key , value , cchm ) ; else return new LinkedSoftKeyWeakValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class SoftKeySoftValueNode extends SoftKeyNode { volatile EmbeddedSoftReference valueRef ; SoftKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , cchm ) ; if ( value != null ) this . valueRef = new EmbeddedSoftReference ( value , this ) ; } public final Object getValue ( ) { EmbeddedSoftReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedSoftReference ( value , this ) ; } } static final class TerminalSoftKeySoftValueNode extends SoftKeySoftValueNode { TerminalSoftKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedSoftKeySoftValueNode extends SoftKeySoftValueNode { volatile Node linkage ; LinkedSoftKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class SoftKeySoftValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalSoftKeySoftValueNode ( locator , key , value , cchm ) ; else return new LinkedSoftKeySoftValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class IntKeyNode implements Node { final int key ; IntKeyNode ( int locator , Object key ) { this . key = ( ( Integer ) key ) . intValue ( ) ; } public final Object get ( ) { return Integer . valueOf ( key ) ; } public final int getLocator ( ) { return spreadHash ( key ) ; } } static abstract class IntKeySelfValueNode extends IntKeyNode { IntKeySelfValueNode ( int locator , Object key ) { super ( locator , key ) ; } public final Object getValue ( ) { return Integer . valueOf ( key ) ; } public final void setValue ( Object value ) { } public final void onReclamation ( ) { } } static final class TerminalIntKeySelfValueNode extends IntKeySelfValueNode { TerminalIntKeySelfValueNode ( int locator , Object key ) { super ( locator , key ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedIntKeySelfValueNode extends IntKeySelfValueNode { volatile Node linkage ; LinkedIntKeySelfValueNode ( int locator , Object key , Node linkage ) { super ( locator , key ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class IntKeySelfValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalIntKeySelfValueNode ( locator , key ) ; else return new LinkedIntKeySelfValueNode ( locator , key , linkage ) ; } } static abstract class IntKeyStrongValueNode extends IntKeyNode { volatile Object value ; IntKeyStrongValueNode ( int locator , Object key , Object value ) { super ( locator , key ) ; this . value = value ; } public final Object getValue ( ) { return value ; } public final void setValue ( Object value ) { this . value = value ; } public final void onReclamation ( ) { } } static final class TerminalIntKeyStrongValueNode extends IntKeyStrongValueNode { TerminalIntKeyStrongValueNode ( int locator , Object key , Object value ) { super ( locator , key , value ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedIntKeyStrongValueNode extends IntKeyStrongValueNode { volatile Node linkage ; LinkedIntKeyStrongValueNode ( int locator , Object key , Object value , Node linkage ) { super ( locator , key , value ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class IntKeyStrongValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalIntKeyStrongValueNode ( locator , key , value ) ; else return new LinkedIntKeyStrongValueNode ( locator , key , value , linkage ) ; } } static abstract class IntKeyIntValueNode extends IntKeyNode { volatile int value ; IntKeyIntValueNode ( int locator , Object key , Object value ) { super ( locator , key ) ; this . value = ( ( Integer ) value ) . intValue ( ) ; } public final Object getValue ( ) { return Integer . valueOf ( value ) ; } public final void setValue ( Object value ) { this . value = ( ( Integer ) value ) . intValue ( ) ; } public final void onReclamation ( ) { } } static final class TerminalIntKeyIntValueNode extends IntKeyIntValueNode { TerminalIntKeyIntValueNode ( int locator , Object key , Object value ) { super ( locator , key , value ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedIntKeyIntValueNode extends IntKeyIntValueNode { volatile Node linkage ; LinkedIntKeyIntValueNode ( int locator , Object key , Object value , Node linkage ) { super ( locator , key , value ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class IntKeyIntValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalIntKeyIntValueNode ( locator , key , value ) ; else return new LinkedIntKeyIntValueNode ( locator , key , value , linkage ) ; } } static abstract class IntKeyWeakValueNode extends IntKeyNode { volatile EmbeddedWeakReference valueRef ; final CustomConcurrentHashMap cchm ; IntKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key ) ; this . cchm = cchm ; if ( value != null ) this . valueRef = new EmbeddedWeakReference ( value , this ) ; } public final void onReclamation ( ) { cchm . removeIfReclaimed ( this ) ; } public final Object getValue ( ) { EmbeddedWeakReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedWeakReference ( value , this ) ; } } static final class TerminalIntKeyWeakValueNode extends IntKeyWeakValueNode { TerminalIntKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedIntKeyWeakValueNode extends IntKeyWeakValueNode { volatile Node linkage ; LinkedIntKeyWeakValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class IntKeyWeakValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalIntKeyWeakValueNode ( locator , key , value , cchm ) ; else return new LinkedIntKeyWeakValueNode ( locator , key , value , cchm , linkage ) ; } } static abstract class IntKeySoftValueNode extends IntKeyNode { volatile EmbeddedSoftReference valueRef ; final CustomConcurrentHashMap cchm ; IntKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key ) ; this . cchm = cchm ; if ( value != null ) this . valueRef = new EmbeddedSoftReference ( value , this ) ; } public final void onReclamation ( ) { cchm . removeIfReclaimed ( this ) ; } public final Object getValue ( ) { EmbeddedSoftReference vr = valueRef ; return vr == null ? null : vr . get ( ) ; } public final void setValue ( Object value ) { if ( value == null ) valueRef = null ; else valueRef = new EmbeddedSoftReference ( value , this ) ; } } static final class TerminalIntKeySoftValueNode extends IntKeySoftValueNode { TerminalIntKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm ) { super ( locator , key , value , cchm ) ; } public final Node getLinkage ( ) { return null ; } public final void setLinkage ( Node r ) { } } static final class LinkedIntKeySoftValueNode extends IntKeySoftValueNode { volatile Node linkage ; LinkedIntKeySoftValueNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { super ( locator , key , value , cchm ) ; this . linkage = linkage ; } public final Node getLinkage ( ) { return linkage ; } public final void setLinkage ( Node r ) { linkage = r ; } } static final class IntKeySoftValueNodeFactory implements NodeFactory , Serializable { private static final long serialVersionUID = 7249069346764182397L ; public final Node newNode ( int locator , Object key , Object value , CustomConcurrentHashMap cchm , Node linkage ) { if ( linkage == null ) return new TerminalIntKeySoftValueNode ( locator , key , value , cchm ) ; else return new LinkedIntKeySoftValueNode ( locator , key , value , cchm , linkage ) ; } } static final Unsafe _unsafe ; static final long tableBase ; static final int tableShift ; static final long segmentsBase ; static final int segmentsShift ; private static Unsafe getUnsafe ( ) throws Throwable { try { return Unsafe . getUnsafe ( ) ; } catch ( SecurityException se ) { try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < Unsafe > ( ) { public Unsafe run ( ) throws Exception { return getUnsafePrivileged ( ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw e . getCause ( ) ; } } } private static Unsafe getUnsafePrivileged ( ) throws NoSuchFieldException , IllegalAccessException { Field f = Unsafe . class . getDeclaredField ( "theUnsafe" ) ; f . setAccessible ( true ) ; return ( Unsafe ) f . get ( null ) ; } static { try { _unsafe = getUnsafe ( ) ; tableBase = _unsafe . arrayBaseOffset ( Node [ ] . class ) ; int s = _unsafe . arrayIndexScale ( Node [ ] . class ) ; if ( ( s & ( s - 1 ) ) != 0 ) throw new Error ( "data type scale not a power of two" ) ; tableShift = 31 - Integer . numberOfLeadingZeros ( s ) ; segmentsBase = _unsafe . arrayBaseOffset ( Segment [ ] . class ) ; s = _unsafe . arrayIndexScale ( Segment [ ] . class ) ; if ( ( s & ( s - 1 ) ) != 0 ) throw new Error ( "data type scale not a power of two" ) ; segmentsShift = 31 - Integer . numberOfLeadingZeros ( s ) ; } catch ( Throwable e ) { throw new RuntimeException ( "Could not initialize intrinsics" , e ) ; } } static final void storeNode ( Node [ ] table , int i , Node r ) { _unsafe . putOrderedObject ( table , ( i << tableShift ) + tableBase , r ) ; } static final void storeSegment ( Segment [ ] segs , int i , Segment s ) { _unsafe . putOrderedObject ( segs , ( i << segmentsShift ) + segmentsBase , s ) ; } } 
=======
final class RowGroup { private final Cell [ ] EMPTY_CELL_ARRAY = { } ; private int currentRow = - 1 ; private int insertionPoint = 0 ; private int nextOldCell = 0 ; private final Table owner ; private final SortedSet < Cell > cellsIfEffect = new TreeSet < Cell > ( VerticalCellComparator . THE_INSTANCE ) ; private Cell [ ] cellsOnCurrentRow ; private boolean rowHadCells ; private final String type ; RowGroup ( Table owner , String type ) { super ( ) ; this . owner = owner ; this . type = type ; } public void cell ( Cell cell ) throws SAXException { rowHadCells = true ; findInsertionPoint ( ) ; cell . setPosition ( currentRow , insertionPoint ) ; owner . cell ( cell ) ; if ( cell . getBottom ( ) > currentRow + 1 ) { cellsIfEffect . add ( cell ) ; } insertionPoint = cell . getRight ( ) ; for ( int i = nextOldCell ; i < cellsOnCurrentRow . length ; i ++ ) { cellsOnCurrentRow [ i ] . errOnHorizontalOverlap ( cell ) ; } } private void findInsertionPoint ( ) { for ( ; ; ) { if ( nextOldCell == cellsOnCurrentRow . length ) { break ; } Cell other = cellsOnCurrentRow [ nextOldCell ] ; int newInsertionPoint = other . freeSlot ( insertionPoint ) ; if ( newInsertionPoint == insertionPoint ) { break ; } nextOldCell ++ ; insertionPoint = newInsertionPoint ; } } public void end ( ) throws SAXException { for ( Cell cell : cellsIfEffect ) { cell . errIfNotRowspanZero ( type ) ; } } public void endRow ( ) throws SAXException { if ( ! rowHadCells ) { owner . err ( "Row " + ( currentRow + 1 ) + " of " + ( type == null ? "an implicit row group" : "a row group established by a " + type + " element" ) + " has no cells beginning on it." ) ; } findInsertionPoint ( ) ; cellsOnCurrentRow = null ; int columnCount = owner . getColumnCount ( ) ; if ( owner . isHardWidth ( ) ) { if ( insertionPoint > columnCount ) { owner . err ( "A table row was " + insertionPoint + " columns wide and exceeded the column count established using column markup (" + columnCount + ")." ) ; } else if ( insertionPoint < columnCount ) { owner . err ( "A table row was " + insertionPoint + " columns wide, which is less than the column count established using column markup (" + columnCount + ")." ) ; } } else if ( columnCount == - 1 ) { owner . setColumnCount ( insertionPoint ) ; } else { if ( insertionPoint > columnCount ) { owner . warn ( "A table row was " + insertionPoint + " columns wide and exceeded the column count established by the first row (" + columnCount + ")." ) ; } else if ( insertionPoint < columnCount ) { owner . warn ( "A table row was " + insertionPoint + " columns wide, which is less than the column count established by the first row (" + columnCount + ")." ) ; } } for ( Iterator < Cell > iter = cellsIfEffect . iterator ( ) ; iter . hasNext ( ) ; ) { Cell cell = iter . next ( ) ; if ( cell . shouldBeCulled ( currentRow + 1 ) ) { iter . remove ( ) ; } } } public void startRow ( ) { currentRow ++ ; insertionPoint = 0 ; nextOldCell = 0 ; rowHadCells = false ; cellsOnCurrentRow = cellsIfEffect . toArray ( EMPTY_CELL_ARRAY ) ; Arrays . sort ( cellsOnCurrentRow , HorizontalCellComparator . THE_INSTANCE ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
