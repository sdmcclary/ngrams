<<<<<<< HEAD
public class MySqlClientDecoder { private static final Logger logger = LoggerFactory . getLogger ( MySqlClientDecoder . class ) ; public static final int SALT_SIZE = 8 ; public static final int SALT2_SIZE = 12 ; public static final int GREETING_UNUSED_SIZE = 13 ; public static final int SQL_STATE_LENGTH = 5 ; public static final int RESPONSE_OK = 0x00 ; public static final int RESPONSE_EOF = 0xfe ; public static final int RESPONSE_ERROR = 0xff ; enum State { CONNECTING , RESPONSE , FIELD , FIELD_EOF , ROW } private State state = State . CONNECTING ; private String charset = "ISO8859_1" ; private int expectedFieldPackets = 0 ; private int fieldIndex = 0 ; private MysqlField [ ] fields ; public ServerPacket decode ( InputStream input , boolean block ) throws IOException { if ( ! input . markSupported ( ) && ! block ) { throw new IllegalArgumentException ( "Non-blocking decoding requires an InputStream that supports marking" ) ; } input . mark ( Integer . MAX_VALUE ) ; ServerPacket message = null ; try { message = doDecode ( input , block ) ; } finally { if ( message == null ) { input . reset ( ) ; } } return message ; } protected ServerPacket doDecode ( InputStream input , boolean block ) throws IOException { if ( ! block ) { if ( input . available ( ) < 3 ) { return null ; } } final int length = IoUtils . readUnsignedMediumInt ( input ) ; if ( ! block ) { if ( input . available ( ) < length + 1 ) { return null ; } } final int packetNumber = IoUtils . safeRead ( input ) ; BoundedInputStream in = new BoundedInputStream ( input , length ) ; boolean threwException = false ; try { logger . trace ( "Decoding in state {}" , state ) ; switch ( state ) { case CONNECTING : ServerGreeting serverGreeting = decodeServerGreeting ( in , length , packetNumber ) ; state = State . RESPONSE ; return serverGreeting ; case RESPONSE : int fieldCount = in . read ( ) ; if ( fieldCount == RESPONSE_OK ) { return decodeOkResponse ( in , length , packetNumber ) ; } if ( fieldCount == RESPONSE_ERROR ) { ErrorResponse response = decodeErrorResponse ( in , length , packetNumber ) ; return response ; } if ( fieldCount == RESPONSE_EOF ) { throw new IllegalStateException ( "Did not expect an EOF response from the server" ) ; } expectedFieldPackets = ( int ) IoUtils . readBinaryLengthEncoding ( in , fieldCount ) ; fields = new MysqlField [ expectedFieldPackets ] ; logger . trace ( "Field count {}" , expectedFieldPackets ) ; Long extra = null ; if ( in . getRemaining ( ) > 0 ) { extra = IoUtils . readBinaryLengthEncoding ( in ) ; } state = State . FIELD ; return new ResultSetResponse ( length , packetNumber , expectedFieldPackets , extra ) ; case FIELD : ResultSetFieldResponse resultSetFieldResponse = decodeFieldResponse ( in , length , packetNumber ) ; expectedFieldPackets -- ; logger . trace ( "fieldPacketCount: {}" , expectedFieldPackets ) ; if ( expectedFieldPackets == 0 ) { state = State . FIELD_EOF ; } return resultSetFieldResponse ; case FIELD_EOF : fieldCount = in . read ( ) ; if ( fieldCount != RESPONSE_EOF ) { throw new IllegalStateException ( "Expected an EOF response from the server" ) ; } EofResponse fieldEof = decodeEofResponse ( in , length , packetNumber , EofResponse . Type . FIELD ) ; state = State . ROW ; fieldIndex = 0 ; return fieldEof ; case ROW : fieldCount = in . read ( ) ; if ( fieldCount == RESPONSE_EOF ) { EofResponse rowEof = decodeEofResponse ( in , length , packetNumber , EofResponse . Type . ROW ) ; state = State . RESPONSE ; return rowEof ; } Value [ ] values = new Value [ fields . length ] ; for ( int i = 0 ; i < fields . length ; ) { MysqlField field = fields [ i ++ ] ; Object value = null ; if ( fieldCount != IoUtils . NULL_VALUE ) { String strVal = IoUtils . readLengthCodedString ( in , fieldCount , charset ) ; switch ( field . getColumnType ( ) ) { case TINYINT : value = Byte . valueOf ( strVal ) ; break ; case INTEGER : case BIGINT : value = Long . valueOf ( strVal ) ; break ; case VARCHAR : value = strVal ; break ; default : throw new IllegalStateException ( "Don't know how to handle column type of " + field . getColumnType ( ) ) ; } } values [ field . getIndex ( ) ] = new DefaultValue ( field , value ) ; if ( i < fields . length ) { fieldCount = in . read ( ) ; } } return new ResultSetRowResponse ( length , packetNumber , values ) ; default : throw new IllegalStateException ( "Unkown decoder state " + state ) ; } } catch ( IOException e ) { threwException = true ; throw e ; } catch ( RuntimeException e ) { threwException = true ; throw e ; } finally { if ( ! threwException && in . getRemaining ( ) > 0 ) { throw new IllegalStateException ( "Buffer underrun occured; remaining bytes: " + in . getRemaining ( ) ) ; } } } protected ServerGreeting decodeServerGreeting ( InputStream in , int length , int packetNumber ) throws IOException { int protocol = IoUtils . safeRead ( in ) ; String version = IoUtils . readString ( in , "ASCII" ) ; int threadId = IoUtils . readInt ( in ) ; byte [ ] salt = new byte [ SALT_SIZE + SALT2_SIZE ] ; in . read ( salt , 0 , SALT_SIZE ) ; in . read ( ) ; Set < ClientCapabilities > serverCapabilities = IoUtils . readEnumSetShort ( in , ClientCapabilities . class ) ; MysqlCharacterSet charSet = MysqlCharacterSet . findById ( in . read ( ) ) ; Set < ServerStatus > serverStatus = IoUtils . readEnumSetShort ( in , ServerStatus . class ) ; in . skip ( GREETING_UNUSED_SIZE ) ; in . read ( salt , SALT_SIZE , SALT2_SIZE ) ; in . read ( ) ; return new ServerGreeting ( length , packetNumber , protocol , version , threadId , salt , serverCapabilities , charSet , serverStatus ) ; } protected OkResponse decodeOkResponse ( BoundedInputStream in , int length , int packetNumber ) throws IOException { long affectedRows = IoUtils . readBinaryLengthEncoding ( in ) ; long insertId = IoUtils . readBinaryLengthEncoding ( in ) ; Set < ServerStatus > serverStatus = IoUtils . readEnumSetShort ( in , ServerStatus . class ) ; int warningCount = IoUtils . readUnsignedShort ( in ) ; String message = IoUtils . readFixedLengthString ( in , in . getRemaining ( ) , charset ) ; return new OkResponse ( length , packetNumber , affectedRows , insertId , serverStatus , warningCount , message ) ; } protected ErrorResponse decodeErrorResponse ( InputStream in , int length , int packetNumber ) throws IOException { int errorNumber = IoUtils . readUnsignedShort ( in ) ; in . read ( ) ; String sqlState = IoUtils . readString ( in , "ASCII" ) ; String message = IoUtils . readString ( in , charset ) ; return new ErrorResponse ( length , packetNumber , errorNumber , sqlState , message ) ; } protected EofResponse decodeEofResponse ( InputStream in , int length , int packetNumber , EofResponse . Type type ) throws IOException { int warnings = IoUtils . readUnsignedShort ( in ) ; Set < ServerStatus > serverStatus = IoUtils . readEnumSetShort ( in , ServerStatus . class ) ; return new EofResponse ( length , packetNumber , warnings , serverStatus , type ) ; } protected ResultSetFieldResponse decodeFieldResponse ( InputStream in , int packetLength , int packetNumber ) throws IOException { String catalogName = IoUtils . readLengthCodedString ( in , charset ) ; String schemaName = IoUtils . readLengthCodedString ( in , charset ) ; String tableLabel = IoUtils . readLengthCodedString ( in , charset ) ; String tableName = IoUtils . readLengthCodedString ( in , charset ) ; String columnLabel = IoUtils . readLengthCodedString ( in , charset ) ; String columnName = IoUtils . readLengthCodedString ( in , charset ) ; in . read ( ) ; int characterSetNumber = IoUtils . readUnsignedShort ( in ) ; MysqlCharacterSet charSet = MysqlCharacterSet . findById ( characterSetNumber ) ; long length = IoUtils . readUnsignedInt ( in ) ; int fieldTypeId = in . read ( ) ; MysqlType fieldType = MysqlType . findById ( fieldTypeId ) ; Set < FieldFlag > flags = IoUtils . readEnumSet ( in , FieldFlag . class ) ; int decimals = in . read ( ) ; in . skip ( 2 ) ; long fieldDefault = IoUtils . readBinaryLengthEncoding ( in ) ; MysqlField field = new MysqlField ( fieldIndex , catalogName , schemaName , tableLabel , tableName , fieldType , columnLabel , columnName , 0 , decimals , charSet , length , flags , fieldDefault ) ; fields [ fieldIndex ++ ] = field ; return new ResultSetFieldResponse ( packetLength , packetNumber , field ) ; } private static class BoundedInputStream extends InputStream { private final InputStream in ; private int remaining ; public BoundedInputStream ( InputStream in , int length ) { this . in = in ; this . remaining = length ; } @ Override public int read ( ) throws IOException { int i = in . read ( ) ; if ( i >= 0 ) { remaining -- ; } if ( remaining < 0 ) { throw new IllegalStateException ( "Buffer overrun" ) ; } return i ; } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { int i = in . read ( b , off , len ) ; remaining -= i ; if ( remaining < 0 ) { throw new IllegalStateException ( "Read too many bytes" ) ; } return i ; } @ Override public long skip ( long n ) throws IOException { long i = in . skip ( n ) ; remaining -= i ; if ( remaining < 0 ) { throw new IllegalStateException ( "Read too many bytes" ) ; } return i ; } public int getRemaining ( ) { return remaining ; } } void setState ( State state ) { this . state = state ; } } 
=======
class RegexFeatures { static private final int EXAMPLE_NON_BMP_CHAR = 0x10000 ; static private final String EXAMPLE_SURROGATE_PAIR = new String ( new char [ ] { Utf16 . surrogate1 ( EXAMPLE_NON_BMP_CHAR ) , Utf16 . surrogate2 ( EXAMPLE_NON_BMP_CHAR ) } ) ; static final boolean SURROGATES_DIRECT = Pattern . compile ( "[^x]" ) . matcher ( EXAMPLE_SURROGATE_PAIR ) . matches ( ) ; private RegexFeatures ( ) { } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
