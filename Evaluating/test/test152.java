public class URLInputStream extends InputStream { private static final Logger LOG = Logger . getLogger ( URLInputStream . class . getName ( ) ) ; private static final IRetriesPolicy DEFAULT_RETRIES_POLICY = new DirectRetriesPolicy ( ) ; private static final String MSG_EXCEPTION_IN_THE_HANDLER = Strings . error ( "failed.to.handle" ) ; private static final String MSG_IO_ERROR = Strings . error ( "net.there.was.an.error.during.io" ) ; public static final int BANDWIDTH_UNLIMITED = 0 ; private URL sourceUrl ; private BandwidthInputStream bis ; private int bandwidth ; private int read ; private int contentLength ; private boolean closed ; private boolean finished ; private IRetriesPolicy retriesPolicy ; private List listeners ; private long lastFetchingTime ; private IPermanentRedirectionListener redirectionListener ; private boolean paused ; private int responseCode = - 1 ; private long lastModifiedTime ; private long serverTime ; private String userAgent ; private String username ; private String password ; public URLInputStream ( URL aSourceUrl ) { this ( aSourceUrl , - 1 ) ; } public URLInputStream ( URL aSourceUrl , String aUserAgent ) { this ( aSourceUrl , - 1 ) ; userAgent = aUserAgent ; } public URLInputStream ( URL aSourceUrl , long aLastFetchingTime ) { this ( aSourceUrl , 0 , aLastFetchingTime ) ; } public URLInputStream ( URL aSourceUrl , int aResumeFrom , long aLastFetchingTime ) { if ( aSourceUrl == null ) throw new NullPointerException ( Strings . error ( "unspecified.url" ) ) ; retriesPolicy = DEFAULT_RETRIES_POLICY ; listeners = Collections . synchronizedList ( new ArrayList ( ) ) ; sourceUrl = aSourceUrl ; lastFetchingTime = aLastFetchingTime ; bis = null ; closed = false ; setBandwidth ( BANDWIDTH_UNLIMITED ) ; read = aResumeFrom ; finished = false ; paused = false ; lastModifiedTime = - 1 ; serverTime = - 1 ; userAgent = null ; } public void setBasicAuthenticationInfo ( String username , String password ) { this . username = username ; this . password = password ; } public void setRedirectionListener ( IPermanentRedirectionListener listener ) { redirectionListener = listener ; } public void setRetriesPolicy ( IRetriesPolicy aRetriesPolicy ) { retriesPolicy = aRetriesPolicy ; } public void addListener ( IStreamProgressListener aListener ) { listeners . add ( aListener ) ; } public void removeListener ( IStreamProgressListener aListener ) { listeners . remove ( aListener ) ; } public int getBandwidth ( ) { return bandwidth ; } public URL getSourceURL ( ) { return sourceUrl ; } public void setBandwidth ( int aBandwidth ) { bandwidth = aBandwidth ; if ( bis != null ) bis . setBandwidth ( aBandwidth ) ; } private synchronized void incRead ( int delta ) { if ( ! finished ) { read += delta ; fireRead ( delta ) ; if ( contentLength != - 1 && read >= contentLength ) finished ( ) ; } } private synchronized void finished ( ) { if ( ! finished ) { fireFinished ( ) ; finished = true ; } } public int read ( ) throws IOException { int ch = - 1 ; blockOnPause ( ) ; boolean success = false ; while ( ! success ) { connect ( ) ; try { ch = bis . read ( ) ; success = true ; } catch ( IOException e ) { LOG . log ( Level . WARNING , MSG_IO_ERROR , e ) ; bis = null ; } } if ( ch == - 1 ) finished ( ) ; return ch ; } public int available ( ) throws IOException { int num = 0 ; boolean success = false ; while ( ! success ) { connect ( ) ; try { num = bis . available ( ) ; success = true ; } catch ( IOException e ) { LOG . log ( Level . WARNING , MSG_IO_ERROR , e ) ; bis = null ; } } return num ; } public void close ( ) throws IOException { if ( bis != null && ! closed ) { bis . close ( ) ; bis = null ; finished ( ) ; } closed = true ; } public boolean isClosed ( ) { return closed ; } public synchronized void mark ( int readlimit ) { try { connect ( ) ; bis . mark ( readlimit ) ; } catch ( IOException e ) { LOG . log ( Level . SEVERE , Strings . error ( "net.failed.to.establish.connection" ) , e ) ; } } public boolean markSupported ( ) { boolean supported = false ; try { connect ( ) ; supported = bis . markSupported ( ) ; } catch ( IOException e ) { LOG . log ( Level . SEVERE , Strings . error ( "net.failed.to.establish.connection" ) , e ) ; } return supported ; } public int read ( byte b [ ] , int off , int len ) throws IOException { int justRead = 0 ; blockOnPause ( ) ; boolean success = false ; while ( ! success ) { connect ( ) ; try { justRead = bis . read ( b , off , len ) ; if ( justRead == - 1 ) finished ( ) ; success = true ; } catch ( IOException e ) { LOG . log ( Level . WARNING , MSG_IO_ERROR , e ) ; bis = null ; } } return justRead ; } public synchronized void reset ( ) throws IOException { boolean success = false ; while ( ! success ) { connect ( ) ; try { bis . reset ( ) ; success = true ; } catch ( IOException e ) { LOG . log ( Level . WARNING , MSG_IO_ERROR , e ) ; bis = null ; } } } public long skip ( long n ) throws IOException { long skipped = 0 ; blockOnPause ( ) ; boolean success = false ; while ( ! success ) { connect ( ) ; try { skipped = bis . skip ( n ) ; success = true ; } catch ( IOException e ) { LOG . log ( Level . WARNING , MSG_IO_ERROR , e ) ; bis = null ; } } return skipped ; } public synchronized void connect ( ) throws IOException { try { if ( bis == null && ! closed ) { boolean connected = false ; int attempt = 0 ; fireConnecting ( ) ; while ( ! connected ) { IRetriesPolicy . Failure failure = null ; try { failure = connectionAttempt ( attempt ++ ) ; } catch ( RuntimeException e ) { if ( e . getCause ( ) instanceof AuthCancelException ) { throw new NotAuthenticatedException ( ) ; } throw e ; } if ( failure != null ) { handleFailure ( failure ) ; } else { connected = true ; } } fireConnected ( contentLength ) ; } else if ( closed ) { throw new IOException ( Strings . error ( "net.stream.is.already.closed" ) ) ; } } catch ( IOException e ) { fireErrored ( e ) ; throw e ; } } IRetriesPolicy . Failure connectionAttempt ( int attempt ) { IRetriesPolicy . Failure failure = null ; long start = System . currentTimeMillis ( ) ; try { bis = new BandwidthInputStream ( makeConnection ( read ) ) ; bis . setBandwidth ( bandwidth ) ; } catch ( IOException e ) { failure = new IRetriesPolicy . Failure ( attempt , start , System . currentTimeMillis ( ) , false , 0 , e ) ; } return failure ; } void handleFailure ( IRetriesPolicy . Failure aFailure ) throws IOException { IOException cause = aFailure . getCause ( ) ; if ( cause instanceof FileNotFoundException || cause instanceof CyclicRedirectionException ) { throw cause ; } else if ( cause instanceof UISException ) { int code = ( ( UISException ) cause ) . getCode ( ) ; if ( code != HttpURLConnection . HTTP_CLIENT_TIMEOUT && code != HttpURLConnection . HTTP_UNAUTHORIZED ) throw cause ; } long timeToWait = retriesPolicy . getTimeBeforeRetry ( aFailure ) ; if ( timeToWait == - 1 ) { throw cause ; } else if ( timeToWait > 0 ) { try { Thread . sleep ( timeToWait ) ; } catch ( InterruptedException e ) { } } } protected InputStream makeConnection ( long read ) throws IOException { URLConnectionHolder holder = ResumingSupport . resume ( sourceUrl , read , lastFetchingTime , userAgent , username , password ) ; URLConnection con = holder . getConnection ( ) ; URL permRedirURL = holder . getPermanentRedirectionURL ( ) ; if ( permRedirURL != null ) { sourceUrl = permRedirURL ; firePermanentRedirection ( sourceUrl ) ; } contentLength = 0 ; responseCode = 200 ; boolean isCompressed = false ; if ( con instanceof HttpURLConnection ) { HttpURLConnection httpCon = ( HttpURLConnection ) con ; responseCode = httpCon . getResponseCode ( ) ; isCompressed = "gzip" . equalsIgnoreCase ( httpCon . getContentEncoding ( ) ) ; } if ( responseCode != HttpURLConnection . HTTP_UNAUTHORIZED ) { analyzeResponseCodes ( con ) ; contentLength = resolveContentLength ( con ) ; lastModifiedTime = resolveLastModifiedTime ( con ) ; serverTime = resolveServerTime ( con ) ; } InputStream is = new CountingFilterInputStream ( con . getInputStream ( ) ) ; if ( isCompressed ) is = new CorrectedGZIPInputStream ( is ) ; return is ; } private void analyzeResponseCodes ( URLConnection con ) throws IOException { if ( ! ( con instanceof HttpURLConnection ) ) return ; HttpURLConnection hcon = ( HttpURLConnection ) con ; int series = responseCode / 100 ; if ( series == 5 ) throw new ServerErrorException ( responseCode , hcon . getResponseMessage ( ) ) ; if ( series == 4 && responseCode != 401 ) { throw new ClientErrorException ( responseCode , hcon . getResponseMessage ( ) ) ; } } public int getResponseCode ( ) { return responseCode ; } protected int resolveContentLength ( URLConnection aCon ) { return aCon . getContentLength ( ) ; } protected long resolveLastModifiedTime ( URLConnection aCon ) { long time = aCon . getLastModified ( ) ; return time == 0 ? - 1 : time ; } protected long resolveServerTime ( URLConnection aCon ) { long time = aCon . getDate ( ) ; return time == 0 ? - 1 : time ; } BandwidthInputStream getStream ( ) { return bis ; } protected IStreamProgressListener [ ] getListeners ( ) { IStreamProgressListener [ ] list ; synchronized ( listeners ) { list = ( IStreamProgressListener [ ] ) listeners . toArray ( new IStreamProgressListener [ listeners . size ( ) ] ) ; } return list ; } protected void fireConnecting ( ) { IStreamProgressListener [ ] listeners = getListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { IStreamProgressListener listener = listeners [ i ] ; try { listener . connecting ( this ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , MSG_EXCEPTION_IN_THE_HANDLER , e ) ; } } } protected void fireConnected ( long size ) { IStreamProgressListener [ ] listeners = getListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { IStreamProgressListener listener = listeners [ i ] ; try { listener . connected ( this , size ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , MSG_EXCEPTION_IN_THE_HANDLER , e ) ; } } } protected void fireRead ( int bytes ) { IStreamProgressListener [ ] listeners = getListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { IStreamProgressListener listener = listeners [ i ] ; try { listener . read ( this , bytes ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , MSG_EXCEPTION_IN_THE_HANDLER , e ) ; } } } protected void fireFinished ( ) { IStreamProgressListener [ ] listeners = getListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { IStreamProgressListener listener = listeners [ i ] ; try { listener . finished ( this ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , MSG_EXCEPTION_IN_THE_HANDLER , e ) ; } } } protected void fireErrored ( IOException ex ) { IStreamProgressListener [ ] listeners = getListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { IStreamProgressListener listener = listeners [ i ] ; try { listener . errored ( this , ex ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , MSG_EXCEPTION_IN_THE_HANDLER , e ) ; } } } private void firePermanentRedirection ( URL newURL ) { try { if ( redirectionListener != null ) redirectionListener . redirectedTo ( newURL ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , Strings . error ( "failed.to.notify.a.listener" ) , e ) ; } } public synchronized void setPaused ( boolean aPaused ) { paused = aPaused ; notifyAll ( ) ; } public boolean isPaused ( ) { return paused ; } private synchronized void blockOnPause ( ) { try { while ( paused ) wait ( ) ; } catch ( InterruptedException e ) { LOG . log ( Level . WARNING , Strings . error ( "interrupted" ) , e ) ; } } public long getLastModifiedTime ( ) { return lastModifiedTime ; } public long getServerTime ( ) { return serverTime ; } private class CountingFilterInputStream extends FilterInputStream { public CountingFilterInputStream ( InputStream in ) { super ( in ) ; } @ Override public int read ( ) throws IOException { int ch = super . read ( ) ; if ( ch != - 1 ) incRead ( 1 ) ; return ch ; } @ Override public int read ( byte b [ ] , int off , int len ) throws IOException { int read = super . read ( b , off , len ) ; if ( read != - 1 ) incRead ( read ) ; return read ; } @ Override public long skip ( long n ) throws IOException { long skipped = super . skip ( n ) ; incRead ( ( int ) skipped ) ; return skipped ; } } } 