<<<<<<< HEAD
public abstract class ParallelArrayWithMapping < T , U > extends AbstractParallelAnyArray . OPap < T > { ParallelArrayWithMapping ( ForkJoinPool ex , int origin , int fence , T [ ] array ) { super ( ex , origin , fence , array ) ; } public void apply ( Procedure < ? super U > procedure ) { ex . invoke ( new PAS . FJOApply ( this , origin , fence , null , procedure ) ) ; } public U reduce ( Reducer < U > reducer , U base ) { PAS . FJOReduce f = new PAS . FJOReduce ( this , origin , fence , null , reducer , base ) ; ex . invoke ( f ) ; return ( U ) ( f . result ) ; } public U any ( ) { int i = anyIndex ( ) ; return ( i < 0 ) ? null : ( U ) oget ( i ) ; } public U min ( Comparator < ? super U > comparator ) { return reduce ( CommonOps . < U > minReducer ( comparator ) , null ) ; } public U min ( ) { return reduce ( ( Reducer < U > ) ( CommonOps . castedMinReducer ( ) ) , null ) ; } public U max ( Comparator < ? super U > comparator ) { return reduce ( CommonOps . < U > maxReducer ( comparator ) , null ) ; } public U max ( ) { return reduce ( ( Reducer < U > ) ( CommonOps . castedMaxReducer ( ) ) , null ) ; } public ParallelArray . SummaryStatistics < U > summary ( Comparator < ? super U > comparator ) { PAS . FJOStats f = new PAS . FJOStats ( this , origin , fence , null , comparator ) ; ex . invoke ( f ) ; return ( ParallelArray . SummaryStatistics < U > ) f ; } public ParallelArray . SummaryStatistics < U > summary ( ) { return summary ( ( Comparator < ? super U > ) ( CommonOps . castedComparator ( ) ) ) ; } public ParallelArray < U > all ( ) { return new ParallelArray < U > ( ex , ( U [ ] ) allObjects ( null ) ) ; } public ParallelArray < U > all ( Class < ? super U > elementType ) { return new ParallelArray < U > ( ex , ( U [ ] ) allObjects ( elementType ) ) ; } public abstract < V > ParallelArrayWithMapping < T , V > withMapping ( Op < ? super U , ? extends V > op ) ; public abstract ParallelArrayWithDoubleMapping < T > withMapping ( ObjectToDouble < ? super U > op ) ; public abstract ParallelArrayWithLongMapping < T > withMapping ( ObjectToLong < ? super U > op ) ; public < V , W , X > ParallelArrayWithMapping < T , W > withMapping ( BinaryOp < ? super U , ? super V , ? extends W > combiner , ParallelArrayWithMapping < X , V > other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V > ParallelArrayWithMapping < T , V > withMapping ( ObjectAndDoubleToObject < ? super U , ? extends V > combiner , ParallelDoubleArrayWithDoubleMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V > ParallelArrayWithMapping < T , V > withMapping ( ObjectAndLongToObject < ? super U , ? extends V > combiner , ParallelLongArrayWithLongMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V , W > ParallelArrayWithDoubleMapping < T > withMapping ( ObjectAndObjectToDouble < ? super U , ? super V > combiner , ParallelArrayWithMapping < W , V > other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithDoubleMapping < T > withMapping ( ObjectAndDoubleToDouble < ? super U > combiner , ParallelDoubleArrayWithDoubleMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithDoubleMapping < T > withMapping ( ObjectAndLongToDouble < ? super U > combiner , ParallelLongArrayWithLongMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V , W > ParallelArrayWithLongMapping < T > withMapping ( ObjectAndObjectToLong < ? super U , ? super V > combiner , ParallelArrayWithMapping < W , V > other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithLongMapping < T > withMapping ( ObjectAndDoubleToLong < ? super U > combiner , ParallelDoubleArrayWithDoubleMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithLongMapping < T > withMapping ( ObjectAndLongToLong < ? super U > combiner , ParallelLongArrayWithLongMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public abstract < V > ParallelArrayWithMapping < T , V > withIndexedMapping ( IntAndObjectToObject < ? super U , ? extends V > mapper ) ; public abstract ParallelArrayWithDoubleMapping < T > withIndexedMapping ( IntAndObjectToDouble < ? super U > mapper ) ; public abstract ParallelArrayWithLongMapping < T > withIndexedMapping ( IntAndObjectToLong < ? super U > mapper ) ; public Iterable < U > sequentially ( ) { return new Sequentially < U > ( ) ; } } 
=======
public final class TableChecker extends Checker { public TableChecker ( ) { super ( ) ; } private Table current ; private final LinkedList < Table > stack = new LinkedList < Table > ( ) ; private void push ( ) { if ( current != null ) { stack . addLast ( current ) ; } current = new Table ( this ) ; } private void pop ( ) throws SAXException { if ( current == null ) { throw new IllegalStateException ( "Bug!" ) ; } current . end ( ) ; if ( stack . isEmpty ( ) ) { current = null ; } else { current = stack . removeLast ( ) ; } } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { if ( "http://www.w3.org/1999/xhtml" . equals ( uri ) ) { if ( "table" . equals ( localName ) ) { push ( ) ; } else if ( current != null ) { if ( "td" . equals ( localName ) ) { current . startCell ( false , atts ) ; } else if ( "th" . equals ( localName ) ) { current . startCell ( true , atts ) ; } else if ( "tr" . equals ( localName ) ) { current . startRow ( ) ; } else if ( "tbody" . equals ( localName ) || "thead" . equals ( localName ) || "tfoot" . equals ( localName ) ) { current . startRowGroup ( localName ) ; } else if ( "col" . equals ( localName ) ) { current . startCol ( AttributeUtil . parseNonNegativeInteger ( atts . getValue ( "" , "span" ) ) ) ; } else if ( "colgroup" . equals ( localName ) ) { current . startColGroup ( AttributeUtil . parseNonNegativeInteger ( atts . getValue ( "" , "span" ) ) ) ; } } } } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( "http://www.w3.org/1999/xhtml" . equals ( uri ) ) { if ( "table" . equals ( localName ) ) { pop ( ) ; } else if ( current != null ) { if ( "td" . equals ( localName ) ) { current . endCell ( ) ; } else if ( "th" . equals ( localName ) ) { current . endCell ( ) ; } else if ( "tr" . equals ( localName ) ) { current . endRow ( ) ; } else if ( "tbody" . equals ( localName ) || "thead" . equals ( localName ) || "tfoot" . equals ( localName ) ) { current . endRowGroup ( ) ; } else if ( "col" . equals ( localName ) ) { current . endCol ( ) ; } else if ( "colgroup" . equals ( localName ) ) { current . endColGroup ( ) ; } } } } public void reset ( ) { stack . clear ( ) ; current = null ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
