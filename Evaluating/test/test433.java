public abstract class ParallelArrayWithMapping < T , U > extends AbstractParallelAnyArray . OPap < T > { ParallelArrayWithMapping ( ForkJoinPool ex , int origin , int fence , T [ ] array ) { super ( ex , origin , fence , array ) ; } public void apply ( Procedure < ? super U > procedure ) { ex . invoke ( new PAS . FJOApply ( this , origin , fence , null , procedure ) ) ; } public U reduce ( Reducer < U > reducer , U base ) { PAS . FJOReduce f = new PAS . FJOReduce ( this , origin , fence , null , reducer , base ) ; ex . invoke ( f ) ; return ( U ) ( f . result ) ; } public U any ( ) { int i = anyIndex ( ) ; return ( i < 0 ) ? null : ( U ) oget ( i ) ; } public U min ( Comparator < ? super U > comparator ) { return reduce ( CommonOps . < U > minReducer ( comparator ) , null ) ; } public U min ( ) { return reduce ( ( Reducer < U > ) ( CommonOps . castedMinReducer ( ) ) , null ) ; } public U max ( Comparator < ? super U > comparator ) { return reduce ( CommonOps . < U > maxReducer ( comparator ) , null ) ; } public U max ( ) { return reduce ( ( Reducer < U > ) ( CommonOps . castedMaxReducer ( ) ) , null ) ; } public ParallelArray . SummaryStatistics < U > summary ( Comparator < ? super U > comparator ) { PAS . FJOStats f = new PAS . FJOStats ( this , origin , fence , null , comparator ) ; ex . invoke ( f ) ; return ( ParallelArray . SummaryStatistics < U > ) f ; } public ParallelArray . SummaryStatistics < U > summary ( ) { return summary ( ( Comparator < ? super U > ) ( CommonOps . castedComparator ( ) ) ) ; } public ParallelArray < U > all ( ) { return new ParallelArray < U > ( ex , ( U [ ] ) allObjects ( null ) ) ; } public ParallelArray < U > all ( Class < ? super U > elementType ) { return new ParallelArray < U > ( ex , ( U [ ] ) allObjects ( elementType ) ) ; } public abstract < V > ParallelArrayWithMapping < T , V > withMapping ( Op < ? super U , ? extends V > op ) ; public abstract ParallelArrayWithDoubleMapping < T > withMapping ( ObjectToDouble < ? super U > op ) ; public abstract ParallelArrayWithLongMapping < T > withMapping ( ObjectToLong < ? super U > op ) ; public < V , W , X > ParallelArrayWithMapping < T , W > withMapping ( BinaryOp < ? super U , ? super V , ? extends W > combiner , ParallelArrayWithMapping < X , V > other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V > ParallelArrayWithMapping < T , V > withMapping ( ObjectAndDoubleToObject < ? super U , ? extends V > combiner , ParallelDoubleArrayWithDoubleMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V > ParallelArrayWithMapping < T , V > withMapping ( ObjectAndLongToObject < ? super U , ? extends V > combiner , ParallelLongArrayWithLongMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V , W > ParallelArrayWithDoubleMapping < T > withMapping ( ObjectAndObjectToDouble < ? super U , ? super V > combiner , ParallelArrayWithMapping < W , V > other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithDoubleMapping < T > withMapping ( ObjectAndDoubleToDouble < ? super U > combiner , ParallelDoubleArrayWithDoubleMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithDoubleMapping < T > withMapping ( ObjectAndLongToDouble < ? super U > combiner , ParallelLongArrayWithLongMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public < V , W > ParallelArrayWithLongMapping < T > withMapping ( ObjectAndObjectToLong < ? super U , ? super V > combiner , ParallelArrayWithMapping < W , V > other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithLongMapping < T > withMapping ( ObjectAndDoubleToLong < ? super U > combiner , ParallelDoubleArrayWithDoubleMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public ParallelArrayWithLongMapping < T > withMapping ( ObjectAndLongToLong < ? super U > combiner , ParallelLongArrayWithLongMapping other ) { if ( other . hasFilter ( ) ) throw new IllegalArgumentException ( ) ; return withIndexedMapping ( AbstractParallelAnyArray . indexedMapper ( combiner , other , origin ) ) ; } public abstract < V > ParallelArrayWithMapping < T , V > withIndexedMapping ( IntAndObjectToObject < ? super U , ? extends V > mapper ) ; public abstract ParallelArrayWithDoubleMapping < T > withIndexedMapping ( IntAndObjectToDouble < ? super U > mapper ) ; public abstract ParallelArrayWithLongMapping < T > withIndexedMapping ( IntAndObjectToLong < ? super U > mapper ) ; public Iterable < U > sequentially ( ) { return new Sequentially < U > ( ) ; } } 