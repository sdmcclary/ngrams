<<<<<<< HEAD
public class ModelTranslator { private static Context mContext ; private static HashMap < String , Integer > formColumnNamesToIndex ; private static HashMap < String , Integer > fieldColumnNamesToIndex ; private static HashMap < String , Integer > typeColumnNamesToIndex ; private static HashMap < Integer , Form > formIdCache = new HashMap < Integer , Form > ( ) ; private static HashMap < Integer , Vector < Field > > fieldToFormHash = new HashMap < Integer , Vector < Field > > ( ) ; private static HashMap < Integer , SimpleFieldType > fieldTypeHash = new HashMap < Integer , SimpleFieldType > ( ) ; private static SmsDbHelper mDbHelper ; public static boolean doesFormExist ( Context context , String prefixCandidate , String nameCandidate ) { Uri formExistUri = RapidSmsDBConstants . Form . CONTENT_URI ; StringBuilder whereclause = new StringBuilder ( ) ; whereclause . append ( RapidSmsDBConstants . Form . PREFIX + "='" + prefixCandidate + "'" ) ; whereclause . append ( " OR " ) ; whereclause . append ( RapidSmsDBConstants . Form . FORMNAME + "='" + nameCandidate + "'" ) ; Cursor existsCursor = context . getContentResolver ( ) . query ( formExistUri , null , whereclause . toString ( ) , null , null ) ; if ( existsCursor . getCount ( ) == 0 ) { existsCursor . close ( ) ; return false ; } else { existsCursor . close ( ) ; return true ; } } public static void addFormToDatabase ( Form f ) { boolean newFormInserted ; ContentValues typecv = new ContentValues ( ) ; if ( f . getFormId ( ) != - 1 ) { typecv . put ( BaseColumns . _ID , f . getFormId ( ) ) ; } typecv . put ( RapidSmsDBConstants . Form . FORMNAME , f . getFormName ( ) ) ; typecv . put ( RapidSmsDBConstants . Form . PARSEMETHOD , "simpleregex" ) ; typecv . put ( RapidSmsDBConstants . Form . PREFIX , f . getPrefix ( ) ) ; typecv . put ( RapidSmsDBConstants . Form . DESCRIPTION , f . getDescription ( ) ) ; Uri insertedFormUri = mContext . getContentResolver ( ) . insert ( RapidSmsDBConstants . Form . CONTENT_URI , typecv ) ; Log . d ( "dimagi" , "****** Inserted form into db: " + insertedFormUri ) ; int newFormId = Integer . valueOf ( insertedFormUri . getPathSegments ( ) . get ( 1 ) ) . intValue ( ) ; f . setFormId ( newFormId ) ; Field [ ] fields = f . getFields ( ) ; Log . d ( "dimagi" , "****** Begin fields loop: " + fields . length ) ; for ( int j = 0 ; j < fields . length ; j ++ ) { Field thefield = fields [ j ] ; Log . d ( "dimagi" , "******** Iterating through fields: " + thefield . getName ( ) ) ; Uri fieldUri = RapidSmsDBConstants . Field . CONTENT_URI ; StringBuilder where = new StringBuilder ( ) ; where . append ( "name='" + thefield . getName ( ) + "' AND " ) ; where . append ( "form_id=" + newFormId ) ; Cursor crfield = mContext . getContentResolver ( ) . query ( fieldUri , null , where . toString ( ) , null , null ) ; if ( crfield . getCount ( ) == 0 ) { ContentValues fieldcv = new ContentValues ( ) ; if ( thefield . getFieldId ( ) != - 1 ) { fieldcv . put ( BaseColumns . _ID , thefield . getFieldId ( ) ) ; } fieldcv . put ( RapidSmsDBConstants . Field . NAME , thefield . getName ( ) ) ; fieldcv . put ( RapidSmsDBConstants . Field . FORM , f . getFormId ( ) ) ; fieldcv . put ( RapidSmsDBConstants . Field . PROMPT , thefield . getDescription ( ) ) ; fieldcv . put ( RapidSmsDBConstants . Field . SEQUENCE , thefield . getSequenceId ( ) ) ; fieldcv . put ( RapidSmsDBConstants . Field . FIELDTYPE , ( ( SimpleFieldType ) ( thefield . getFieldType ( ) ) ) . getId ( ) ) ; Uri insertedFieldUri = mContext . getContentResolver ( ) . insert ( RapidSmsDBConstants . Field . CONTENT_URI , fieldcv ) ; Log . d ( "dimagi" , "********** Inserted Field into db: " + insertedFieldUri ) ; } crfield . close ( ) ; } generateFormTable ( f ) ; SmsParseReceiver . initFormCache ( ) ; } public static void setDbHelper ( SmsDbHelper helper , Context context ) { mDbHelper = helper ; mContext = context ; } public static Form [ ] getAllForms ( ) { Uri getFormsUri = RapidSmsDBConstants . Form . CONTENT_URI ; Cursor allformsCursor = mContext . getContentResolver ( ) . query ( getFormsUri , null , null , null , null ) ; if ( formColumnNamesToIndex == null ) { formColumnNamesToIndex = new HashMap < String , Integer > ( ) ; String [ ] colnames = allformsCursor . getColumnNames ( ) ; int colcount = colnames . length ; for ( int i = 0 ; i < colcount ; i ++ ) { formColumnNamesToIndex . put ( colnames [ i ] , new Integer ( allformsCursor . getColumnIndex ( colnames [ i ] ) ) ) ; } } int formcount = allformsCursor . getCount ( ) ; Form [ ] ret = new Form [ formcount ] ; allformsCursor . moveToFirst ( ) ; for ( int i = 0 ; i < formcount ; i ++ ) { int id = allformsCursor . getInt ( formColumnNamesToIndex . get ( BaseColumns . _ID ) . intValue ( ) ) ; Integer idInt = Integer . valueOf ( id ) ; if ( formIdCache . containsKey ( idInt ) ) { ret [ i ] = formIdCache . get ( idInt ) ; } String name = allformsCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . FORMNAME ) . intValue ( ) ) ; String prefix = allformsCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . PREFIX ) . intValue ( ) ) ; String description = allformsCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . DESCRIPTION ) . intValue ( ) ) ; String parsemethod = allformsCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . PARSEMETHOD ) . intValue ( ) ) ; Field [ ] fields = getFieldsForForm ( id ) ; Form theForm = new Form ( id , name , prefix , description , fields , ParserType . SIMPLEREGEX ) ; formIdCache . put ( idInt , theForm ) ; ret [ i ] = theForm ; allformsCursor . moveToNext ( ) ; } allformsCursor . close ( ) ; return ret ; } public static Form getFormById ( int id ) { return getFormFromUri ( Uri . parse ( RapidSmsDBConstants . Form . CONTENT_URI_STRING + id ) ) ; } public static Form getFormFromUri ( Uri formUri ) { Integer formid = Integer . valueOf ( formUri . getPathSegments ( ) . get ( 1 ) ) ; if ( formIdCache . containsKey ( formid ) ) { return formIdCache . get ( formid ) ; } Cursor formCursor = mContext . getContentResolver ( ) . query ( formUri , null , null , null , null ) ; if ( formCursor . getCount ( ) != 1 ) { throw new IllegalArgumentException ( formUri + " returned a bad result." ) ; } if ( formColumnNamesToIndex == null ) { formColumnNamesToIndex = new HashMap < String , Integer > ( ) ; String [ ] colnames = formCursor . getColumnNames ( ) ; int colcount = colnames . length ; for ( int i = 0 ; i < colcount ; i ++ ) { formColumnNamesToIndex . put ( colnames [ i ] , new Integer ( formCursor . getColumnIndex ( colnames [ i ] ) ) ) ; } } formCursor . moveToFirst ( ) ; int id = formCursor . getInt ( formColumnNamesToIndex . get ( BaseColumns . _ID ) . intValue ( ) ) ; String name = formCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . FORMNAME ) . intValue ( ) ) ; String prefix = formCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . PREFIX ) . intValue ( ) ) ; String description = formCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . DESCRIPTION ) . intValue ( ) ) ; String parsemethod = formCursor . getString ( formColumnNamesToIndex . get ( RapidSmsDBConstants . Form . PARSEMETHOD ) . intValue ( ) ) ; Field [ ] fields = getFieldsForForm ( id ) ; Form ret = new Form ( formCursor . getInt ( 0 ) , name , prefix , description , fields , ParserType . SIMPLEREGEX ) ; formIdCache . put ( Integer . valueOf ( id ) , ret ) ; formCursor . close ( ) ; return ret ; } public static Field [ ] getFieldsForForm ( int formId ) { Context c ; Uri fieldsUri = RapidSmsDBConstants . Field . CONTENT_URI ; Cursor fieldsCursor = mContext . getContentResolver ( ) . query ( fieldsUri , null , RapidSmsDBConstants . Field . FORM + "=" + formId , null , "sequence ASC" ) ; if ( fieldColumnNamesToIndex == null ) { fieldColumnNamesToIndex = new HashMap < String , Integer > ( ) ; String [ ] colnames = fieldsCursor . getColumnNames ( ) ; int colcount = colnames . length ; for ( int i = 0 ; i < colcount ; i ++ ) { fieldColumnNamesToIndex . put ( colnames [ i ] , new Integer ( fieldsCursor . getColumnIndex ( colnames [ i ] ) ) ) ; } } Field [ ] newfields = new Field [ fieldsCursor . getCount ( ) ] ; fieldsCursor . moveToFirst ( ) ; int fieldcount = 0 ; do { int id = fieldsCursor . getInt ( fieldColumnNamesToIndex . get ( BaseColumns . _ID ) . intValue ( ) ) ; String name = fieldsCursor . getString ( fieldColumnNamesToIndex . get ( RapidSmsDBConstants . Field . NAME ) . intValue ( ) ) ; String prompt = fieldsCursor . getString ( fieldColumnNamesToIndex . get ( RapidSmsDBConstants . Field . PROMPT ) . intValue ( ) ) ; int sequence = fieldsCursor . getInt ( fieldColumnNamesToIndex . get ( RapidSmsDBConstants . Field . SEQUENCE ) . intValue ( ) ) ; int fieldtype = fieldsCursor . getInt ( fieldColumnNamesToIndex . get ( RapidSmsDBConstants . Field . FIELDTYPE ) . intValue ( ) ) ; Field newField = new Field ( id , sequence , name , prompt , getFieldType ( fieldtype ) ) ; newfields [ fieldcount ++ ] = newField ; } while ( fieldsCursor . moveToNext ( ) ) ; fieldsCursor . close ( ) ; return newfields ; } public static ITokenParser [ ] getFieldTypes ( ) { Uri typesUri = RapidSmsDBConstants . FieldType . CONTENT_URI ; Cursor typeCursor = mContext . getContentResolver ( ) . query ( typesUri , null , null , null , null ) ; ITokenParser [ ] ret = new ITokenParser [ typeCursor . getCount ( ) ] ; typeCursor . moveToFirst ( ) ; int typecounter = 0 ; do { int id = typeCursor . getInt ( typeColumnNamesToIndex . get ( BaseColumns . _ID ) . intValue ( ) ) ; ITokenParser newType = getFieldType ( id ) ; ret [ typecounter ++ ] = newType ; } while ( typeCursor . moveToNext ( ) ) ; typeCursor . close ( ) ; return ret ; } public static ITokenParser getFieldType ( int type_id ) { Integer typeInt = new Integer ( type_id ) ; if ( fieldTypeHash . containsKey ( typeInt ) ) { return fieldTypeHash . get ( typeInt ) ; } Uri typeUri = Uri . parse ( RapidSmsDBConstants . FieldType . CONTENT_URI_STRING + type_id ) ; Cursor typeCursor = mContext . getContentResolver ( ) . query ( typeUri , null , null , null , null ) ; if ( typeColumnNamesToIndex == null ) { typeColumnNamesToIndex = new HashMap < String , Integer > ( ) ; String [ ] colnames = typeCursor . getColumnNames ( ) ; int colcount = colnames . length ; for ( int i = 0 ; i < colcount ; i ++ ) { typeColumnNamesToIndex . put ( colnames [ i ] , new Integer ( typeCursor . getColumnIndex ( colnames [ i ] ) ) ) ; } } if ( typeCursor . getCount ( ) != 1 ) { throw new IllegalArgumentException ( typeUri + " returned a bad result." ) ; } typeCursor . moveToFirst ( ) ; int id = typeCursor . getInt ( typeColumnNamesToIndex . get ( BaseColumns . _ID ) . intValue ( ) ) ; String dataType = typeCursor . getString ( typeColumnNamesToIndex . get ( RapidSmsDBConstants . FieldType . DATATYPE ) . intValue ( ) ) ; String name = typeCursor . getString ( typeColumnNamesToIndex . get ( RapidSmsDBConstants . FieldType . NAME ) . intValue ( ) ) ; String regex = typeCursor . getString ( typeColumnNamesToIndex . get ( RapidSmsDBConstants . FieldType . REGEX ) . intValue ( ) ) ; SimpleFieldType newType = new SimpleFieldType ( id , dataType , regex , name ) ; fieldTypeHash . put ( typeInt , newType ) ; typeCursor . close ( ) ; return newType ; } private static void getFieldDeclaration ( Field field , StringBuilder sb , boolean last ) { sb . append ( " \"" ) ; sb . append ( "col_" + field . getName ( ) ) ; sb . append ( "\"" ) ; if ( field . getFieldType ( ) . getParsedDataType ( ) . equals ( "integer" ) ) { sb . append ( " integer NULL" ) ; } else if ( field . getFieldType ( ) . getParsedDataType ( ) . equals ( "number" ) ) { sb . append ( " float NULL" ) ; } else if ( field . getFieldType ( ) . getParsedDataType ( ) . equals ( "boolean" ) ) { sb . append ( " bool NULL" ) ; } else if ( field . getFieldType ( ) . getParsedDataType ( ) . equals ( "word" ) ) { sb . append ( " varchar(36) NULL" ) ; } else if ( field . getFieldType ( ) . getParsedDataType ( ) . equals ( "ratio" ) ) { sb . append ( " float NULL" ) ; } else if ( field . getFieldType ( ) . getParsedDataType ( ) . equals ( "datetime" ) ) { sb . append ( " datetime NULL" ) ; } if ( ! last ) { sb . append ( ", " ) ; } } public static void ClearFormTables ( ) { SQLiteDatabase db = mDbHelper . getWritableDatabase ( ) ; db . execSQL ( "delete from " + RapidSmsDBConstants . FieldType . TABLE ) ; db . execSQL ( "delete from " + RapidSmsDBConstants . Field . TABLE ) ; db . execSQL ( "delete from " + RapidSmsDBConstants . Form . TABLE ) ; Log . v ( "dimagi" , "wiped the form/field/fieldtype/formdata table for debug purposes" ) ; } public static void generateFormTable ( Form form ) { SQLiteDatabase db = mDbHelper . getWritableDatabase ( ) ; try { Cursor formdatacursor = db . rawQuery ( "select * from formdata_" + form . getPrefix ( ) + ";" , null ) ; if ( formdatacursor . getCount ( ) > 0 ) { return ; } else { db . execSQL ( "drop table formdata_" + form . getPrefix ( ) ) ; } } catch ( SQLException ex ) { } StringBuilder sb = new StringBuilder ( ) ; sb . append ( "create table formdata_" ) ; sb . append ( form . getPrefix ( ) ) ; sb . append ( " (" ) ; sb . append ( " \"_id\" integer not null PRIMARY KEY, " ) ; sb . append ( " \"message_id\" integer not null references \"message\", " ) ; org . rapidsms . java . core . model . Field [ ] fields = form . getFields ( ) ; int fieldcount = fields . length ; boolean last = false ; for ( int i = 0 ; i < fieldcount ; i ++ ) { if ( i == fieldcount - 1 ) { last = true ; } getFieldDeclaration ( fields [ i ] , sb , last ) ; } sb . append ( " );" ) ; db . execSQL ( sb . toString ( ) ) ; } } 
=======
public class Html5DatatypeLibrary implements DatatypeLibrary { public Html5DatatypeLibrary ( ) { super ( ) ; } public DatatypeBuilder createDatatypeBuilder ( String baseTypeLocalName ) throws DatatypeException { return new ParameterlessDatatypeBuilder ( createDatatype ( baseTypeLocalName ) ) ; } public Datatype createDatatype ( String typeLocalName ) throws DatatypeException { if ( "ID" . equals ( typeLocalName ) ) { return new Id ( ) ; } else if ( "IDREF" . equals ( typeLocalName ) ) { return Idref . THE_INSTANCE ; } else if ( "IDREFS" . equals ( typeLocalName ) ) { return Idrefs . THE_INSTANCE ; } else if ( "pattern" . equals ( typeLocalName ) ) { return Pattern . THE_INSTANCE ; } else if ( "datetime" . equals ( typeLocalName ) ) { return Datetime . THE_INSTANCE ; } else if ( "datetime-local" . equals ( typeLocalName ) ) { return DatetimeLocal . THE_INSTANCE ; } else if ( "datetime-tz" . equals ( typeLocalName ) ) { return DatetimeTz . THE_INSTANCE ; } else if ( "date-or-time" . equals ( typeLocalName ) ) { return DateOrTime . THE_INSTANCE ; } else if ( "date" . equals ( typeLocalName ) ) { return Date . THE_INSTANCE ; } else if ( "month" . equals ( typeLocalName ) ) { return Month . THE_INSTANCE ; } else if ( "week" . equals ( typeLocalName ) ) { return Week . THE_INSTANCE ; } else if ( "time" . equals ( typeLocalName ) ) { return Time . THE_INSTANCE ; } else if ( "iri" . equals ( typeLocalName ) ) { return Iri . THE_INSTANCE ; } else if ( "iri-ref" . equals ( typeLocalName ) ) { return IriRef . THE_INSTANCE ; } else if ( "string" . equals ( typeLocalName ) ) { return AsciiCaseInsensitiveString . THE_INSTANCE ; } else if ( "language" . equals ( typeLocalName ) ) { return Language . THE_INSTANCE ; } else if ( "media-query" . equals ( typeLocalName ) ) { return MediaQuery . THE_INSTANCE ; } else if ( "mime-type" . equals ( typeLocalName ) ) { return MimeType . THE_INSTANCE ; } else if ( "browsing-context" . equals ( typeLocalName ) ) { return BrowsingContext . THE_INSTANCE ; } else if ( "browsing-context-or-keyword" . equals ( typeLocalName ) ) { return BrowsingContextOrKeyword . THE_INSTANCE ; } else if ( "hash-name" . equals ( typeLocalName ) ) { return HashName . THE_INSTANCE ; } else if ( "integer" . equals ( typeLocalName ) ) { return Int . THE_INSTANCE ; } else if ( "integer-non-negative" . equals ( typeLocalName ) ) { return IntNonNegative . THE_INSTANCE ; } else if ( "integer-positive" . equals ( typeLocalName ) ) { return IntPositive . THE_INSTANCE ; } else if ( "float" . equals ( typeLocalName ) ) { return FloatingPointExponent . THE_INSTANCE ; } else if ( "float-non-negative" . equals ( typeLocalName ) ) { return FloatingPointExponentNonNegative . THE_INSTANCE ; } else if ( "float-positive" . equals ( typeLocalName ) ) { return FloatingPointExponentPositive . THE_INSTANCE ; } else if ( "mime-type-list" . equals ( typeLocalName ) ) { return MimeTypeList . THE_INSTANCE ; } else if ( "circle" . equals ( typeLocalName ) ) { return Circle . THE_INSTANCE ; } else if ( "rectangle" . equals ( typeLocalName ) ) { return Rectangle . THE_INSTANCE ; } else if ( "polyline" . equals ( typeLocalName ) ) { return Polyline . THE_INSTANCE ; } else if ( "xml-name" . equals ( typeLocalName ) ) { return XmlName . THE_INSTANCE ; } else if ( "meta-charset" . equals ( typeLocalName ) ) { return MetaCharset . THE_INSTANCE ; } else if ( "microdata-property" . equals ( typeLocalName ) ) { return MicrodataProperty . THE_INSTANCE ; } else if ( "charset" . equals ( typeLocalName ) ) { return Charset . THE_INSTANCE ; } else if ( "refresh" . equals ( typeLocalName ) ) { return Refresh . THE_INSTANCE ; } else if ( "paren-start" . equals ( typeLocalName ) ) { return ParenthesisStart . THE_INSTANCE ; } else if ( "paren-end" . equals ( typeLocalName ) ) { return ParenthesisEnd . THE_INSTANCE ; } else if ( "email-address" . equals ( typeLocalName ) ) { return EmailAddress . THE_INSTANCE ; } else if ( "email-address-list" . equals ( typeLocalName ) ) { return EmailAddressList . THE_INSTANCE ; } else if ( "keylabellist" . equals ( typeLocalName ) ) { return KeyLabelList . THE_INSTANCE ; } else if ( "zero" . equals ( typeLocalName ) ) { return Zero . THE_INSTANCE ; } else if ( "cdo-cdc-pair" . equals ( typeLocalName ) ) { return CdoCdcPair . THE_INSTANCE ; } else if ( "script" . equals ( typeLocalName ) ) { return Script . THE_INSTANCE ; } else if ( "script-documentation" . equals ( typeLocalName ) ) { return ScriptDocumentation . THE_INSTANCE ; } else if ( "functionbody" . equals ( typeLocalName ) ) { return FunctionBody . THE_INSTANCE ; } else if ( "a-rel" . equals ( typeLocalName ) ) { return ARel . THE_INSTANCE ; } else if ( "link-rel" . equals ( typeLocalName ) ) { return LinkRel . THE_INSTANCE ; } else if ( "meta-name" . equals ( typeLocalName ) ) { return MetaName . THE_INSTANCE ; } else if ( "non-empty-string" . equals ( typeLocalName ) ) { return NonEmptyString . THE_INSTANCE ; } else if ( "string-without-line-breaks" . equals ( typeLocalName ) ) { return StringWithoutLineBreaks . THE_INSTANCE ; } else if ( "simple-color" . equals ( typeLocalName ) ) { return SimpleColor . THE_INSTANCE ; } else if ( "time-datetime" . equals ( typeLocalName ) ) { return TimeDatetime . THE_INSTANCE ; } else if ( "svg-pathdata" . equals ( typeLocalName ) ) { return new SvgPathData ( ) ; } throw new DatatypeException ( "Unknown local name for datatype: " + typeLocalName ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
