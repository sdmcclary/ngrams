public class LexemeConsumerHelper { Environment env ; LexemeBasedEnvironmentLoader envLoader ; LexemeList lexemeList ; int llSize ; private IParseState parseState ; LexemeConsumerHelper ( Environment env , LexemeBasedEnvironmentLoader envLoader , IParseState parseState ) { this . env = env ; this . envLoader = envLoader ; this . parseState = parseState ; this . lexemeList = parseState . getLexemeList ( ) ; this . llSize = this . lexemeList . size ( ) ; } protected LexemeConsumerResult consumeIdentifier ( int startIndex , IScope scope , boolean isVar ) throws EndOfFileException { JSIdentifierConsumer indentifier = new JSIdentifierConsumer ( scope , isVar ) ; return indentifier . consume ( startIndex ) ; } protected LexemeConsumerResult consumeIdentifier ( int startIndex , IScope scope , IObject parent ) throws EndOfFileException { JSIdentifierConsumer indentifier = new JSIdentifierConsumer ( scope , parent ) ; return indentifier . consume ( startIndex ) ; } protected LexemeConsumerResult consumeStatements ( int startIndex , IScope scope ) throws EndOfFileException { JSStatementConsumer statements = new JSStatementConsumer ( scope ) ; return statements . consume ( startIndex ) ; } protected LexemeConsumerResult consumeObjectLiteral ( int startIndex , IScope scope , IObject objectLiteral ) throws EndOfFileException { JSObjectLiteralConsumer objectLiteralConsumer = new JSObjectLiteralConsumer ( scope , objectLiteral ) ; return objectLiteralConsumer . consume ( startIndex ) ; } private void addPotentialAliases ( IObject obj , TypedDescription alias ) { if ( obj != null && alias != null && alias . getTypes ( ) . length > 0 ) { String [ ] aliasTypes = alias . getTypes ( ) ; for ( int i = 0 ; i < aliasTypes . length ; i ++ ) { String type = aliasTypes [ i ] ; if ( type != null && type != "" ) { String name = type ; IObject root = env . getGlobal ( ) ; if ( type . indexOf ( "." ) > - 1 ) { int dotLoc = type . lastIndexOf ( "." ) ; String basename = type . substring ( 0 , dotLoc ) ; name = type . substring ( dotLoc + 1 ) ; root = lookupOrCreateObject ( basename , env ) ; } if ( ! name . equals ( "" ) ) { JSReference aliasRef = new JSReference ( root , name , false ) ; envLoader . putPropertyValue ( aliasRef , obj ) ; } } } } } protected LexemeConsumerResult consumeArrayLiteral ( int startIndex , IScope scope ) throws EndOfFileException { JSArrayLiteralConsumer arrayLiteral = new JSArrayLiteralConsumer ( scope ) ; return arrayLiteral . consume ( startIndex ) ; } protected LexemeConsumerResult consumeFunction ( int startIndex , IScope scope , JSReference ref , FunctionDocumentation functionDoc ) throws EndOfFileException { JSFunctionConsumer function = new JSFunctionConsumer ( scope , ref , functionDoc ) ; return function . consume ( startIndex ) ; } protected LexemeConsumerResult consumeAssignment ( int startIndex , IScope scope , JSReference reference , int referenceStartIndex ) throws EndOfFileException { JSAssignmentConsumer assignment = new JSAssignmentConsumer ( scope , reference , referenceStartIndex ) ; return assignment . consume ( startIndex ) ; } protected LexemeConsumerResult consumeNewStatement ( int startIndex , IScope scope ) throws EndOfFileException { JSNewStatementConsumer newStatement = new JSNewStatementConsumer ( scope ) ; return newStatement . consume ( startIndex ) ; } class LexemeConsumerResult { int endIndex ; Object value ; LexemeConsumerResult ( int endIndex , Object value ) { this . endIndex = endIndex ; this . value = value ; } } abstract class LexemeConsumer { public abstract LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException ; protected int skipWhitespace ( int startIndex ) throws EndOfFileException { int index = startIndex ; while ( index < llSize ) { index = getJSLexeme ( index ) ; Lexeme l = lastLexeme ; if ( l . typeIndex != JSTokenTypes . COMMENT && l . typeIndex != JSTokenTypes . DOCUMENTATION ) { return index ; } index ++ ; } throw new EndOfFileException ( ) ; } protected FunctionDocumentation getFunctionDocumentation ( Lexeme lexeme ) { if ( lexeme == null ) { return null ; } JSParseState jsps = ( JSParseState ) parseState . getParseState ( JSMimeType . MimeType ) ; if ( jsps != null ) { IDocumentationStore store = jsps . getDocumentationStore ( ) ; IDocumentation doc = store . getDocumentationFromOffset ( lexeme . getEndingOffset ( ) ) ; if ( doc instanceof FunctionDocumentation ) { return ( FunctionDocumentation ) doc ; } } return null ; } protected IDocumentation getPropertyDocumentation ( Lexeme lexeme ) { if ( lexeme == null ) { return null ; } JSParseState jsps = ( JSParseState ) parseState . getParseState ( JSMimeType . MimeType ) ; if ( jsps != null ) { IDocumentationStore store = jsps . getDocumentationStore ( ) ; IDocumentation doc = store . getDocumentationFromOffset ( lexeme . offset + lexeme . getLength ( ) ) ; return doc ; } return null ; } protected Lexeme findDocumentationLexemeAboveIndex ( int index ) { int i = index - 1 ; int maxLookback = 10 ; int minIndex = i > maxLookback ? i - maxLookback : 0 ; while ( i >= minIndex ) { Lexeme lexeme = lexemeList . get ( i ) ; if ( lexeme . typeIndex == ScriptDocTokenTypes . END_DOCUMENTATION && lexeme . getToken ( ) . getLanguage ( ) . equals ( ScriptDocMimeType . MimeType ) ) { return lexeme ; } else { switch ( lexeme . typeIndex ) { case JSTokenTypes . COMMENT : break ; case JSTokenTypes . VAR : break ; case JSTokenTypes . IDENTIFIER : break ; case JSTokenTypes . COLON : break ; default : return null ; } } i -- ; } return null ; } } class JSAssignmentConsumer extends LexemeConsumer { IScope scope ; boolean isVar ; JSReference reference ; int referenceStartIndex ; JSAssignmentConsumer ( IScope scope , JSReference reference , int referenceStartIndex ) { this . scope = scope ; this . reference = reference ; this . referenceStartIndex = referenceStartIndex ; } public LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException { int index = startIndex ; index = getJSLexeme ( index ) ; Lexeme lexeme = lastLexeme ; if ( lexeme . typeIndex != JSTokenTypes . EQUAL && lexeme . typeIndex != JSTokenTypes . COLON ) { throw new IllegalStateException ( ) ; } LexemeConsumerResult result ; index = skipWhitespace ( index + 1 ) ; index = getJSLexeme ( index ) ; lexeme = lastLexeme ; IObject assignValue = null ; switch ( lexeme . typeIndex ) { case JSTokenTypes . FUNCTION : if ( lastObjectKind . size ( ) > 0 ) { lastObjectKind . pop ( ) ; lastObjectKind . push ( FUNCTION ) ; } FunctionDocumentation functionDoc = getFunctionDocumentation ( findDocumentationLexemeAboveIndex ( referenceStartIndex ) ) ; JSFunctionConsumerResult fResult = ( JSFunctionConsumerResult ) consumeFunction ( index , scope , reference , functionDoc ) ; if ( fResult . function != null ) { envLoader . registerScope ( fResult . function . getBodyScope ( ) , fResult . scopeStartingOffset , fResult . scopeEndingOffset ) ; if ( reference . getObjectBase ( ) instanceof JSObject ) { fResult . function . setGuessedMemberObject ( ( JSObject ) reference . getObjectBase ( ) ) ; } } index = fResult . endIndex ; break ; case JSTokenTypes . NEW : result = consumeNewStatement ( index , scope ) ; index = result . endIndex ; assignValue = ( IObject ) result . value ; if ( assignValue != null ) { envLoader . putPropertyValue ( reference , assignValue ) ; } break ; case JSTokenTypes . STRING : index ++ ; assignValue = envLoader . createNewInstance ( "String" , lexeme . getStartingOffset ( ) , false ) ; envLoader . putPropertyValue ( reference , assignValue ) ; break ; case JSTokenTypes . NUMBER : index ++ ; assignValue = envLoader . createNewInstance ( "Number" , lexeme . getStartingOffset ( ) , false ) ; envLoader . putPropertyValue ( reference , assignValue ) ; break ; case JSTokenTypes . NULL : index ++ ; assignValue = ObjectBase . NULL ; envLoader . putPropertyValue ( reference , assignValue ) ; break ; case JSTokenTypes . TRUE : case JSTokenTypes . FALSE : index ++ ; assignValue = envLoader . createNewInstance ( "Boolean" , lexeme . getStartingOffset ( ) , false ) ; envLoader . putPropertyValue ( reference , assignValue ) ; break ; case JSTokenTypes . REGEX : index ++ ; assignValue = envLoader . createNewInstance ( "RegExp" , lexeme . getStartingOffset ( ) , false ) ; envLoader . putPropertyValue ( reference , assignValue ) ; break ; case JSTokenTypes . LCURLY : if ( lastObjectKind . size ( ) > 0 ) { lastObjectKind . pop ( ) ; lastObjectKind . push ( OBJECT_LITERAL ) ; } IObject objectLiteral = new JSObject ( new Range ( lexeme . getStartingOffset ( ) , lexeme . getEndingOffset ( ) ) ) ; if ( reference != null ) { IObject o = null ; Property p = reference . getObjectBase ( ) . getProperty ( reference . getPropertyName ( ) ) ; if ( p != null ) { o = p . getValue ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ; } if ( o != null ) { objectLiteral = o ; } envLoader . putPropertyValue ( reference , objectLiteral ) ; } result = consumeObjectLiteral ( index , scope , objectLiteral ) ; index = result . endIndex ; assignValue = ( IObject ) result . value ; if ( assignValue != null ) { envLoader . putPropertyValue ( reference , assignValue ) ; } break ; case JSTokenTypes . LBRACKET : result = consumeArrayLiteral ( index , scope ) ; index = result . endIndex ; assignValue = ( IObject ) result . value ; if ( assignValue != null ) { envLoader . putPropertyValue ( reference , assignValue ) ; } break ; case JSTokenTypes . IDENTIFIER : String hashName = LexemeConsumerHelper . getNameHash ( index , lexemeList ) ; boolean isInvoking = hashName . endsWith ( ")" ) ; String retName = LexemeConsumerHelper . lookupReturnStringFromHash ( hashName , scope , env ) ; if ( retName != null && ! retName . equals ( "" ) ) { assignValue = envLoader . createNewInstance ( retName , lexeme . getStartingOffset ( ) , isInvoking ) ; envLoader . putPropertyValue ( reference , assignValue ) ; } else { IObject obj = LexemeConsumerHelper . lookupReturnTypeFromNameHash ( hashName , scope , env ) ; int offset = lexeme . getStartingOffset ( ) ; int fileIndex = envLoader . getFileIndex ( ) ; if ( obj instanceof IFunction ) { IFunction f = ( IFunction ) obj ; assignValue = f . construct ( env , FunctionBase . EmptyArgs , fileIndex , new Range ( offset , offset + 1 ) ) ; envLoader . putPropertyValue ( reference , assignValue ) ; } else if ( obj != null ) { IObject fobj = obj . getPropertyValue ( "constructor" , fileIndex , offset ) ; if ( fobj != null && fobj instanceof IFunction ) { IFunction f = ( IFunction ) fobj ; assignValue = f . construct ( env , FunctionBase . EmptyArgs , fileIndex , new Range ( offset , offset + 1 ) ) ; envLoader . putPropertyValue ( reference , assignValue ) ; } } } break ; default : break ; } return new LexemeConsumerResult ( index , assignValue ) ; } } class JSStatementConsumer extends LexemeConsumer { boolean isVar ; IScope parentScope ; int curlyDepth ; JSReference assignToReference ; int assignToLexemeStartIndex ; JSStatementConsumer ( IScope parentScope ) { this . parentScope = parentScope ; } public LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException { int index = startIndex ; while ( index < llSize ) { index = skipWhitespace ( index ) ; index = getJSLexeme ( index ) ; Lexeme lexeme = lastLexeme ; switch ( lexeme . typeIndex ) { case JSTokenTypes . FUNCTION : JSFunctionConsumerResult fResult = ( JSFunctionConsumerResult ) consumeFunction ( index , parentScope , null , null ) ; if ( fResult . function != null ) { envLoader . registerScope ( fResult . function . getBodyScope ( ) , fResult . scopeStartingOffset , fResult . scopeEndingOffset ) ; } index = fResult . endIndex ; break ; case JSTokenTypes . IDENTIFIER : case JSTokenTypes . THIS : int identifierStartIndex = index ; LexemeConsumerHelper . LexemeConsumerResult result = consumeIdentifier ( index , parentScope , isVar ) ; isVar = false ; index = result . endIndex ; int nextIndex = skipWhitespace ( index + 1 ) ; nextIndex = getJSLexeme ( nextIndex ) ; Lexeme nextLexeme = lastLexeme ; if ( nextLexeme . typeIndex == JSTokenTypes . EQUAL ) { assignToLexemeStartIndex = identifierStartIndex ; assignToReference = ( JSReference ) result . value ; } break ; case JSTokenTypes . VAR : isVar = true ; break ; case JSTokenTypes . LCURLY : curlyDepth ++ ; break ; case JSTokenTypes . RCURLY : curlyDepth -- ; if ( curlyDepth < 0 ) { return new LexemeConsumerResult ( index , null ) ; } break ; case JSTokenTypes . EQUAL : { IObject assignedValue = null ; if ( assignToReference != null ) { nextIndex = skipWhitespace ( index + 1 ) ; nextIndex = getJSLexeme ( nextIndex ) ; nextLexeme = lastLexeme ; if ( nextLexeme . typeIndex == JSTokenTypes . FUNCTION || nextLexeme . typeIndex == JSTokenTypes . NEW || nextLexeme . typeIndex == JSTokenTypes . LCURLY || nextLexeme . typeIndex == JSTokenTypes . LBRACKET ) { result = consumeAssignment ( index , parentScope , assignToReference , assignToLexemeStartIndex ) ; index = result . endIndex ; assignedValue = ( IObject ) result . value ; } else if ( nextLexeme . typeIndex == JSTokenTypes . STRING || nextLexeme . typeIndex == JSTokenTypes . NUMBER || nextLexeme . typeIndex == JSTokenTypes . REGEX || nextLexeme . typeIndex == JSTokenTypes . TRUE || nextLexeme . typeIndex == JSTokenTypes . FALSE ) { nextIndex = skipWhitespace ( nextIndex + 1 ) ; nextIndex = getJSLexeme ( nextIndex ) ; nextLexeme = lastLexeme ; if ( nextLexeme . typeIndex == JSTokenTypes . SEMICOLON ) { result = consumeAssignment ( index , parentScope , assignToReference , assignToLexemeStartIndex ) ; index = result . endIndex ; assignedValue = ( IObject ) result . value ; } } else if ( nextLexeme . typeIndex == JSTokenTypes . IDENTIFIER ) { result = consumeAssignment ( index , parentScope , assignToReference , assignToLexemeStartIndex ) ; index = result . endIndex ; assignedValue = ( IObject ) result . value ; } IDocumentation propertyDoc = getPropertyDocumentation ( findDocumentationLexemeAboveIndex ( assignToLexemeStartIndex ) ) ; if ( propertyDoc != null ) { IObject propValue = assignedValue ; if ( propValue == null || propValue == ObjectBase . UNDEFINED ) { propValue = envLoader . getPropertyValue ( assignToReference , lexeme . getStartingOffset ( ) ) ; } if ( propValue != ObjectBase . UNDEFINED ) { try { if ( propertyDoc instanceof PropertyDocumentation ) { PropertyDocumentation pDoc = ( PropertyDocumentation ) propertyDoc ; IObject retValue = null ; TypedDescription typeDesc = pDoc . getReturn ( ) ; if ( typeDesc != null && typeDesc . getTypes ( ) . length > 0 ) { String type = typeDesc . getTypes ( ) [ 0 ] ; if ( type != null ) { retValue = envLoader . createNewInstance ( type , lexeme . getStartingOffset ( ) , false ) ; envLoader . putPropertyValue ( assignToReference , retValue ) ; propValue . setPrototype ( retValue ) ; } } addPotentialAliases ( propValue , pDoc . getAliases ( ) ) ; } } catch ( Exception e ) { IdeLog . logError ( JSPlugin . getDefault ( ) , Messages . LexemeConsumerHelper_ErrorSettingPrototype , e ) ; } if ( propValue != null ) { propValue . setDocumentation ( propertyDoc ) ; } } } assignToReference = null ; assignToLexemeStartIndex = - 1 ; } break ; } default : break ; } index ++ ; } throw new EndOfFileException ( ) ; } } class JSObjectLiteralConsumer extends LexemeConsumer { IScope parentScope ; IObject objectLiteral ; JSObjectLiteralConsumer ( IScope parentScope , IObject objectLiteral ) { this . parentScope = parentScope ; this . objectLiteral = objectLiteral ; } public LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException { startIndex = getJSLexeme ( startIndex ) ; Lexeme lexeme = lastLexeme ; if ( lexeme . typeIndex != JSTokenTypes . LCURLY ) { throw new IllegalStateException ( ) ; } int curlyDepth = 1 ; int index = startIndex ; JSReference currentReference = null ; int currentReferenceStartIndex = - 1 ; while ( index < llSize && curlyDepth > 0 ) { if ( index + 1 < llSize ) { index = skipWhitespace ( index + 1 ) ; } index = getJSLexeme ( index ) ; lexeme = lastLexeme ; LexemeConsumerResult result ; switch ( lexeme . typeIndex ) { case JSTokenTypes . RCURLY : curlyDepth -- ; break ; case JSTokenTypes . COMMA : if ( index + 1 == llSize ) { index ++ ; } break ; case JSTokenTypes . IDENTIFIER : currentReferenceStartIndex = index ; result = consumeIdentifier ( index , parentScope , objectLiteral ) ; currentReference = ( JSReference ) result . value ; index = result . endIndex ; break ; case JSTokenTypes . COLON : lastObjectKind . push ( "unknown" ) ; if ( currentReference != null ) { result = consumeAssignment ( index , parentScope , currentReference , currentReferenceStartIndex ) ; index = result . endIndex ; } String lastObj = ( String ) lastObjectKind . pop ( ) ; boolean wasObjLit = lastObj . equals ( OBJECT_LITERAL ) ; boolean wasFn = lastObj . equals ( FUNCTION ) ; if ( ! wasObjLit && ! wasFn && index < llSize ) { Lexeme curLexeme = lexemeList . get ( index ) ; if ( curLexeme . typeIndex == JSTokenTypes . RCURLY ) { curlyDepth -- ; } } break ; default : curlyDepth = 0 ; break ; } } return new LexemeConsumerResult ( index , objectLiteral ) ; } } class JSArrayLiteralConsumer extends LexemeConsumer { IScope parentScope ; JSArrayLiteralConsumer ( IScope parentScope ) { this . parentScope = parentScope ; } public LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException { startIndex = getJSLexeme ( startIndex ) ; Lexeme lexeme = lastLexeme ; if ( lexeme . typeIndex != JSTokenTypes . LBRACKET ) { throw new IllegalStateException ( ) ; } int startingOffset = lexeme . getStartingOffset ( ) ; int bracketDepth = 1 ; int index = startIndex ; if ( index + 1 < llSize ) { index = skipWhitespace ( index + 1 ) ; } String type = "Object" ; index = getJSLexeme ( index ) ; lexeme = lastLexeme ; switch ( lexeme . typeIndex ) { case JSTokenTypes . RBRACKET : bracketDepth -- ; break ; case JSTokenTypes . STRING : type = "String" ; break ; case JSTokenTypes . NUMBER : type = "Number" ; break ; case JSTokenTypes . TRUE : case JSTokenTypes . FALSE : type = "Boolean" ; break ; case JSTokenTypes . REGEX : type = "RegExp" ; break ; case JSTokenTypes . LBRACKET : type = "Array" ; break ; case JSTokenTypes . FUNCTION : type = "Function" ; break ; case JSTokenTypes . NEW : if ( index + 1 < llSize ) { index = skipWhitespace ( index + 1 ) ; } index = getJSLexeme ( index ) ; lexeme = lastLexeme ; if ( lexeme . typeIndex == JSTokenTypes . RBRACKET ) { bracketDepth = 0 ; } else if ( lexeme . typeIndex == JSTokenTypes . IDENTIFIER ) { type = lexeme . getText ( ) ; } break ; default : break ; } while ( index < llSize && bracketDepth > 0 ) { if ( index + 1 < llSize ) { index = skipWhitespace ( index + 1 ) ; } else { bracketDepth = 0 ; break ; } index = getJSLexeme ( index ) ; lexeme = lastLexeme ; switch ( lexeme . typeIndex ) { case JSTokenTypes . RBRACKET : bracketDepth -- ; break ; default : break ; } if ( lexeme . isAfterEOL ( ) ) { bracketDepth = 0 ; } } PropertyDocumentation doc = new PropertyDocumentation ( ) ; doc . getReturn ( ) . addType ( "Array" ) ; doc . getReturn ( ) . addType ( type ) ; IObject array = envLoader . createNewInstance ( "Array" , startingOffset , false ) ; array . setDocumentation ( doc ) ; return new LexemeConsumerResult ( index , array ) ; } } class JSNewStatementConsumer extends LexemeConsumer { IScope scope ; JSNewStatementConsumer ( IScope scope ) { this . scope = scope ; } public LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException { int index = startIndex ; index = getJSLexeme ( index ) ; Lexeme lexeme = lastLexeme ; if ( lexeme . typeIndex != JSTokenTypes . NEW ) { throw new IllegalStateException ( ) ; } Range range = new Range ( lexeme . getStartingOffset ( ) , lexeme . getEndingOffset ( ) ) ; index = skipWhitespace ( index + 1 ) ; index = getJSLexeme ( index ) ; lexeme = lastLexeme ; IObject newValue = null ; if ( lexeme . typeIndex == JSTokenTypes . IDENTIFIER ) { LexemeConsumerResult result = consumeIdentifier ( index , scope , false ) ; index = result . endIndex ; JSReference propReference = ( JSReference ) result . value ; IObject value ; if ( propReference . getObjectBase ( ) instanceof IScope ) { value = envLoader . getVariableValue ( ( IScope ) propReference . getObjectBase ( ) , propReference . getPropertyName ( ) , range . getStartingOffset ( ) ) ; } else { value = envLoader . getPropertyValue ( propReference , range . getStartingOffset ( ) ) ; } if ( value instanceof IFunction ) { newValue = envLoader . createNewInstance ( range . getStartingOffset ( ) , ( IFunction ) value ) ; } } else { index = startIndex ; } if ( newValue == null ) { newValue = new JSObject ( range ) ; } return new LexemeConsumerResult ( index , newValue ) ; } } class JSFunctionConsumer extends LexemeConsumer { private IScope parentScope ; private String functionName ; private ArrayList functionArgs = new ArrayList ( ) ; private JSReference reference ; private FunctionDocumentation functionDocs ; JSFunctionConsumer ( IScope parentScope , JSReference ref , FunctionDocumentation functionDocs ) { this . parentScope = parentScope ; this . reference = ref ; this . functionDocs = functionDocs ; } public LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException { int index = startIndex ; index = getJSLexeme ( index ) ; Lexeme lexeme = lastLexeme ; if ( lexeme . typeIndex != JSTokenTypes . FUNCTION ) { throw new IllegalStateException ( ) ; } int functionStart = lexeme . getEndingOffset ( ) ; FunctionDocumentation functionDoc = functionDocs ; if ( functionDoc == null ) { functionDoc = getFunctionDocumentation ( findDocumentationLexemeAboveIndex ( index ) ) ; } index = advanceToLCurly ( index ) ; index = getJSLexeme ( index ) ; Lexeme lCurly = lastLexeme ; if ( lCurly . typeIndex != JSTokenTypes . LCURLY ) { return new JSFunctionConsumerResult ( index , null , functionName , 0 , 0 ) ; } String [ ] funcArgs = new String [ this . functionArgs . size ( ) ] ; for ( int i = 0 ; i < funcArgs . length ; i ++ ) { Lexeme l = ( Lexeme ) functionArgs . get ( i ) ; funcArgs [ i ] = l . getText ( ) ; } int functionOffset = lexeme . getStartingOffset ( ) ; if ( functionName != null ) { functionOffset = Integer . MIN_VALUE + 1 + lexeme . getStartingOffset ( ) ; } JSFunction func = envLoader . createFunctionInstance ( functionOffset , false ) ; if ( this . reference != null && this . reference . getObjectBase ( ) instanceof JSObject ) { func . setGuessedMemberObject ( ( JSObject ) this . reference . getObjectBase ( ) ) ; } else { func . setGuessedMemberObject ( ( JSObject ) func . getLocalProperty ( "prototype" ) . getValue ( FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ) ; } IScope bodyScope = new JSScope ( ) ; bodyScope . setParentScope ( parentScope ) ; bodyScope . setEnclosingFunction ( func ) ; func . setBodyScope ( bodyScope ) ; if ( functionDoc != null ) { func . setDocumentation ( functionDoc ) ; } func . setParameters ( funcArgs ) ; TypedDescription [ ] argTypes = functionDoc != null ? functionDoc . getParams ( ) : new TypedDescription [ 0 ] ; int size = functionArgs . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String type = null ; TypedDescription argDesc = null ; if ( argTypes . length > i ) { argDesc = argTypes [ i ] ; String [ ] types = argDesc . getTypes ( ) ; type = types . length > 0 ? types [ 0 ] : type ; } Lexeme l = ( Lexeme ) functionArgs . get ( i ) ; if ( type == null ) { envLoader . addVariable ( bodyScope , l . getText ( ) , l . getStartingOffset ( ) , true ) ; } else { IObject argVal = null ; IObject classType = lookupReturnTypeFromNameHash ( type , env . getGlobal ( ) , env ) ; boolean isFunction = true ; if ( classType instanceof IFunction ) { argVal = envLoader . createNewInstance ( functionOffset , ( IFunction ) classType ) ; } else { isFunction = false ; argVal = classType ; } if ( argVal != null ) { envLoader . putVariableValue ( bodyScope , l . getText ( ) , argVal , true ) ; PropertyDocumentation argDoc = new PropertyDocumentation ( ) ; String desc = argDesc . getDescription ( ) == null ? "" : argDesc . getDescription ( ) ; argDoc . setDescription ( desc ) ; if ( isFunction ) { argDoc . getReturn ( ) . addType ( type ) ; } argVal . setDocumentation ( argDoc ) ; } } } IObject argsArray = envLoader . addVariable ( bodyScope , "arguments" , lCurly . getStartingOffset ( ) , true ) ; int fileIndex = FileContextManager . BUILT_IN_FILE_INDEX ; IObject gFn = env . getGlobal ( ) . getPropertyValue ( "Function" , fileIndex , 0 ) ; IObject fnprot = gFn . getPropertyValue ( "prototype" , fileIndex , 0 ) ; IObject args = fnprot . getPropertyValue ( "arguments" , fileIndex , 0 ) ; argsArray . setDocumentation ( args . getDocumentation ( ) ) ; if ( functionDoc != null && functionDoc . getExtends ( ) != null ) { String [ ] types = functionDoc . getExtends ( ) . getTypes ( ) ; IObject fnObj = null ; if ( types . length > 0 ) { String type = types [ 0 ] ; if ( ! type . equals ( "Object" ) ) { fnObj = lookupReturnTypeFromNameHash ( type , env . getGlobal ( ) , env ) ; if ( fnObj != null ) { Property prot = fnObj . getProperty ( "prototype" ) ; if ( prot != null ) { func . deletePropertyName ( "prototype" ) ; func . putPropertyValue ( "prototype" , prot . getAssignment ( 0 ) , envLoader . getFileIndex ( ) ) ; } } } } addPotentialAliases ( func , functionDoc . getAliases ( ) ) ; } if ( reference != null ) { envLoader . putPropertyValue ( reference , func ) ; } else if ( functionName != null ) { envLoader . replaceFunctionDeclaration ( lexeme . getStartingOffset ( ) , parentScope , functionName , func ) ; } index = skipWhitespace ( index + 1 ) ; LexemeConsumerHelper . LexemeConsumerResult result = consumeStatements ( index , bodyScope ) ; index = result . endIndex ; index = getJSLexeme ( index ) ; Lexeme offsetLx = lastLexeme ; int endScopeOffset = offsetLx . getEndingOffset ( ) ; return new JSFunctionConsumerResult ( result . endIndex , func , functionName , functionStart , endScopeOffset ) ; } private int advanceToLCurly ( int functionIndex ) throws EndOfFileException { int index = skipWhitespace ( functionIndex + 1 ) ; index = getJSLexeme ( index ) ; Lexeme nextLexeme = lastLexeme ; if ( nextLexeme . typeIndex == JSTokenTypes . IDENTIFIER ) { functionName = nextLexeme . getText ( ) ; index = this . skipWhitespace ( index + 1 ) ; } index = getJSLexeme ( index ) ; nextLexeme = lastLexeme ; if ( nextLexeme . typeIndex == JSTokenTypes . LPAREN ) { index = skipWhitespace ( index + 1 ) ; index = getJSLexeme ( index ) ; nextLexeme = lastLexeme ; while ( nextLexeme . typeIndex != JSTokenTypes . RPAREN ) { if ( nextLexeme . typeIndex == JSTokenTypes . IDENTIFIER ) { functionArgs . add ( nextLexeme ) ; } else if ( nextLexeme . typeIndex != JSTokenTypes . COMMA ) { return index ; } index = skipWhitespace ( index + 1 ) ; index = getJSLexeme ( index ) ; nextLexeme = lastLexeme ; } index = skipWhitespace ( index + 1 ) ; index = getJSLexeme ( index ) ; nextLexeme = lastLexeme ; } if ( nextLexeme . typeIndex == JSTokenTypes . LCURLY ) { return index ; } return index ; } } class JSFunctionConsumerResult extends LexemeConsumerResult { String name ; JSFunction function ; int scopeStartingOffset ; int scopeEndingOffset ; JSFunctionConsumerResult ( int endIndex , JSFunction function , String name , int scopeStartingOffset , int scopeEndingOffset ) { super ( endIndex , function ) ; this . name = name ; this . function = function ; this . scopeStartingOffset = scopeStartingOffset ; this . scopeEndingOffset = scopeEndingOffset ; } } class JSIdentifierConsumer extends LexemeConsumer { private IScope scope ; private boolean isVar ; private JSReference reference ; IObject parentObject ; JSIdentifierConsumer ( IScope scope , boolean isVar ) { this . scope = scope ; this . isVar = isVar ; parentObject = scope ; } JSIdentifierConsumer ( IScope scope , IObject parentObject ) { this . scope = scope ; this . isVar = false ; this . parentObject = parentObject ; } public LexemeConsumerResult consume ( int startIndex ) throws EndOfFileException { int index = startIndex ; index = getJSLexeme ( index ) ; Lexeme lexeme = lastLexeme ; boolean isLocalVar = isVar || lexeme . typeIndex == JSTokenTypes . THIS ; while ( lexeme != null && index != - 1 ) { if ( lexeme . typeIndex == JSTokenTypes . IDENTIFIER || lexeme . typeIndex == JSTokenTypes . THIS ) { String propertyName = lexeme . getText ( ) ; int nextIndex = skipWhitespace ( index + 1 ) ; nextIndex = getJSLexeme ( nextIndex ) ; Lexeme nextLexeme = lastLexeme ; if ( nextLexeme . typeIndex == JSTokenTypes . LBRACKET ) { int bracketDepth = 1 ; while ( bracketDepth > 0 && nextLexeme != null ) { nextIndex = skipWhitespace ( nextIndex + 1 ) ; nextIndex = getJSLexeme ( nextIndex ) ; nextLexeme = lastLexeme ; if ( nextLexeme . typeIndex == JSTokenTypes . LBRACKET ) { bracketDepth ++ ; } else if ( nextLexeme . typeIndex == JSTokenTypes . RBRACKET ) { bracketDepth -- ; } } index = nextIndex ; propertyName = propertyName + "[]" ; } reference = new JSReference ( parentObject , propertyName , isLocalVar ) ; IObject parentTemp = parentObject ; if ( parentObject instanceof IScope ) { parentObject = envLoader . addVariable ( scope , propertyName , lexeme . getStartingOffset ( ) , isLocalVar ) ; isLocalVar = false ; } else { parentObject = envLoader . addProperty ( scope , parentObject , propertyName , lexeme . getStartingOffset ( ) ) ; } if ( propertyName . equals ( "this" ) && parentTemp instanceof IScope ) { IFunction fn = ( ( IScope ) parentTemp ) . getEnclosingFunction ( ) ; if ( fn instanceof JSFunction ) { JSObject guessedPrototype = ( ( JSFunction ) fn ) . getGuessedMemberObject ( ) ; if ( guessedPrototype != null ) { parentObject = guessedPrototype ; } } } } else if ( lexeme . typeIndex != JSTokenTypes . DOT ) { index = index - 1 ; break ; } index ++ ; if ( llSize > index ) { index = getJSLexeme ( index ) ; lexeme = lastLexeme ; } else { lexeme = null ; } } return new LexemeConsumerResult ( index , reference ) ; } } private int lastIndex = - 1 ; private Lexeme lastLexeme = null ; private Stack lastObjectKind = new Stack ( ) ; private final String OBJECT_LITERAL = "__objectLiteral__" ; private final String FUNCTION = "__function__" ; private int getJSLexeme ( int index ) { if ( index == lastIndex ) { return index ; } lastLexeme = lexemeList . get ( index ) ; if ( ! lastLexeme . getLanguage ( ) . equals ( JSMimeType . MimeType ) ) { while ( ++ index < llSize ) { lastLexeme = lexemeList . get ( index ) ; if ( lastLexeme . getLanguage ( ) . equals ( JSMimeType . MimeType ) ) { break ; } } } lastIndex = index ; return lastIndex ; } private static String NOT_AN_IDENTIFIER = "NOT_AN_IDENTIFIER" ; private static String getNameHash ( int position , LexemeList lexemes ) { String name = "" ; int parenCount = 0 ; int lexLen = lexemes . size ( ) ; while ( position < lexLen ) { Lexeme curLexeme = lexemes . get ( position ) ; if ( name . equals ( NOT_AN_IDENTIFIER ) ) { name = "" ; } switch ( curLexeme . typeIndex ) { case JSTokenTypes . LPAREN : int startParenCount = parenCount ; name += "(" ; parenCount ++ ; while ( ++ position < lexLen ) { Lexeme lx = lexemes . get ( position ) ; if ( lx . typeIndex == JSTokenTypes . LPAREN ) { parenCount ++ ; } else if ( lx . typeIndex == JSTokenTypes . RPAREN ) { parenCount -- ; } if ( startParenCount == parenCount ) { name += ")" ; break ; } } break ; case JSTokenTypes . RPAREN : name += ")" ; parenCount -- ; break ; case JSTokenTypes . IDENTIFIER : name += curLexeme . getText ( ) ; break ; case JSTokenTypes . DOT : name += curLexeme . getText ( ) ; break ; case JSTokenTypes . WHITESPACE : break ; default : position = lexLen ; break ; } if ( curLexeme . isAfterEOL ( ) ) { break ; } position ++ ; } return name ; } private static String lookupReturnStringFromHash ( String fullname , IScope scope , Environment environment ) { if ( fullname . equals ( NOT_AN_IDENTIFIER ) ) { return null ; } if ( fullname . length ( ) == 0 ) { return null ; } String result = "" ; int lastDot = fullname . lastIndexOf ( "." ) ; String baseName = "" ; String name = fullname ; if ( lastDot > - 1 ) { baseName = fullname . substring ( 0 , lastDot ) ; name = fullname . substring ( lastDot + 1 ) ; } IObject obj = environment . getGlobal ( ) ; if ( baseName != "" ) { obj = lookupReturnTypeFromNameHash ( baseName , scope , environment ) ; } if ( obj == null ) { return "" ; } boolean isInvoking = false ; int firstParen = name . indexOf ( "(" ) ; if ( name . endsWith ( ")" ) && firstParen > - 1 ) { isInvoking = true ; name = name . substring ( 0 , firstParen ) ; } IObject robj = obj . getPropertyValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) . getInstance ( environment , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; if ( ! isInvoking && robj instanceof IFunction ) { result = fullname ; } else if ( robj . getDocumentation ( ) != null && robj . getDocumentation ( ) instanceof PropertyDocumentation ) { PropertyDocumentation pdoc = ( ( PropertyDocumentation ) robj . getDocumentation ( ) ) ; if ( pdoc . getReturn ( ) != null && pdoc . getReturn ( ) . getTypes ( ) != null ) { String [ ] types = pdoc . getReturn ( ) . getTypes ( ) ; if ( types . length > 0 ) { if ( pdoc . getIsInstance ( ) ) { result = "+" + types [ 0 ] ; } else { result = types [ 0 ] ; } } } } else { name = name . toString ( ) ; } return result ; } private static IObject lookupReturnTypeFromNameHash ( String fullname , IScope scope , Environment environment ) { if ( fullname . equals ( NOT_AN_IDENTIFIER ) ) { return null ; } if ( fullname . length ( ) == 0 ) { return null ; } String [ ] names = fullname . split ( "\\." ) ; IObject obj = scope ; for ( int i = 0 ; i < names . length ; i ++ ) { String name = names [ i ] ; boolean isMethodCall = false ; if ( name . endsWith ( "()" ) ) { isMethodCall = true ; name = name . substring ( 0 , name . length ( ) - 2 ) ; } if ( i == 0 ) { if ( name . equals ( "this" ) && obj instanceof IScope ) { IFunction enclFn = ( ( IScope ) obj ) . getEnclosingFunction ( ) ; if ( enclFn != null && enclFn instanceof JSFunction ) { JSFunction fn = ( JSFunction ) enclFn ; IDocumentation doc = fn . getDocumentation ( ) ; if ( doc instanceof PropertyDocumentation ) { PropertyDocumentation pdoc = ( PropertyDocumentation ) doc ; if ( pdoc instanceof FunctionDocumentation && ( ( FunctionDocumentation ) pdoc ) . getIsConstructor ( ) ) { obj = fn . getPropertyValue ( "prototype" , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } else { String rettype = fn . getMemberOf ( ) ; if ( rettype != null && ! rettype . equals ( "" ) ) { if ( rettype . indexOf ( "." ) > - 1 ) { obj = lookupNamespaceFromNameHash ( rettype , environment ) ; } else { obj = lookupReturnTypeFromNameHash ( rettype , environment . getGlobal ( ) , environment ) ; } if ( obj != null ) { obj = obj . getPropertyValue ( "prototype" , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } } } } else { obj = fn . getGuessedMemberObject ( ) ; } } } else { obj = scope . getVariableValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) . getInstance ( environment , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } } else { obj = obj . getPropertyValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) . getInstance ( environment , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } if ( obj == null || obj == ObjectBase . UNDEFINED ) { return null ; } if ( isMethodCall || ( i == names . length - 1 && fullname . endsWith ( "." ) ) ) { IDocumentation doc = obj . getDocumentation ( ) ; if ( doc instanceof PropertyDocumentation ) { PropertyDocumentation pdoc = ( PropertyDocumentation ) doc ; String [ ] rettypes = pdoc . getReturn ( ) . getTypes ( ) ; if ( rettypes . length > 0 ) { String rettype = rettypes [ 0 ] ; if ( rettype . indexOf ( "." ) > - 1 ) { obj = lookupNamespaceFromNameHash ( rettype , environment ) ; } else { obj = lookupReturnTypeFromNameHash ( rettype , environment . getGlobal ( ) , environment ) ; } if ( obj != null ) { obj = obj . getPropertyValue ( "prototype" , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } } } else { if ( obj instanceof JSFunction ) { obj = ( ( JSFunction ) obj ) . getGuessedMemberObject ( ) ; } else { obj = environment . getGlobal ( ) . getPropertyValue ( "Object" , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } } } } return obj ; } private static IObject lookupNamespaceFromNameHash ( String fullname , Environment environment ) { if ( fullname . length ( ) == 0 ) { return null ; } String [ ] names = fullname . split ( "\\." ) ; IScope scope = environment . getGlobal ( ) ; IObject obj = scope ; for ( int i = 0 ; i < names . length ; i ++ ) { String name = names [ i ] ; if ( i == 0 ) { obj = scope . getVariableValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) . getInstance ( environment , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } else { obj = obj . getPropertyValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) . getInstance ( environment , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } if ( obj == ObjectBase . UNDEFINED ) { return null ; } } return obj ; } private static IObject lookupOrCreateObject ( String fullname , Environment environment ) { if ( fullname . length ( ) == 0 ) { return environment . getGlobal ( ) ; } String [ ] names = fullname . split ( "\\." ) ; IScope scope = environment . getGlobal ( ) ; IObject obj = scope ; IObject prevObj = scope ; String path = "" ; for ( int i = 0 ; i < names . length ; i ++ ) { String name = names [ i ] ; if ( i == 0 ) { path = name ; obj = scope . getVariableValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) . getInstance ( environment , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } else { path += "." + name ; obj = obj . getPropertyValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) . getInstance ( environment , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } if ( obj == ObjectBase . UNDEFINED ) { Range r = new Range ( 0 , 0 ) ; IObject guessedObj = new JSObject ( r ) ; Property p = new Property ( guessedObj , FileContextManager . BUILT_IN_FILE_INDEX , 0 ) ; prevObj . putLocalProperty ( name , p ) ; obj = guessedObj ; prevObj = guessedObj ; } } return obj ; } public static Reference addDocHolderToEnvironment ( String id , IDocumentation doc , IParseState parseState ) { Reference result = null ; Environment environment = ( Environment ) JSLanguageEnvironment . getInstance ( ) . getRuntimeEnvironment ( ) ; String [ ] path = ( id . indexOf ( "." ) > - 1 ) ? id . split ( "\\." ) : new String [ ] { id } ; IObject scope = environment . getGlobal ( ) ; boolean hasDef = true ; for ( int i = 0 ; i < path . length ; i ++ ) { String name = path [ i ] ; if ( scope . hasLocalProperty ( name ) ) { scope = scope . getPropertyValue ( name , FileContextManager . CURRENT_FILE_INDEX , Integer . MAX_VALUE ) ; } else { hasDef = false ; break ; } } if ( ! hasDef ) { IObject objBase = environment . getGlobal ( ) ; String name = id ; int dotLoc = id . lastIndexOf ( "." ) ; if ( dotLoc > - 1 ) { name = id . substring ( dotLoc + 1 ) ; String basename = id . substring ( 0 , dotLoc ) ; objBase = lookupOrCreateObject ( basename , environment ) ; } if ( "" . equals ( name ) ) { IdeLog . logInfo ( JSPlugin . getDefault ( ) , StringUtils . format ( Messages . LexemeConsumerHelper_MalformedIdTag , id ) ) ; } if ( objBase != null && ! "" . equals ( name ) ) { Range r = new Range ( 0 , 0 ) ; IObject obj = new JSObject ( r ) ; Property p = new Property ( obj , parseState . getFileIndex ( ) , 0 ) ; objBase . putLocalProperty ( name , p ) ; result = new JSReference ( objBase , name , false ) ; if ( obj . getDocumentation ( ) == null ) { obj . setDocumentation ( doc ) ; } } } return result ; } } 