@ Named ( "requirePluginVersions" ) public final class RequirePluginVersions extends AbstractStandardEnforcerRule { private boolean banLatest = true ; private boolean banRelease = true ; private boolean banSnapshots = true ; private boolean banTimestamps = true ; private boolean banMavenDefaults = true ; private String phases = "clean,deploy,site" ; private List < String > additionalPlugins ; private List < String > unCheckedPlugins ; private String unCheckedPluginList ; private Map < String , Lifecycle > phaseToLifecycleMap ; private Collection < Lifecycle > lifecycles ; private final PluginManager pluginManager ; private final ArtifactFactory factory ; private final RepositorySystem repositorySystem ; private final MavenSession session ; private final EnforcerRuleUtils utils ; private final RuntimeInformation runtimeInformation ; private final DefaultLifecycles defaultLifeCycles ; private final MavenProject project ; private final ExpressionEvaluator evaluator ; private final PlexusContainer container ; @ Inject public RequirePluginVersions ( PluginManager pluginManager , ArtifactFactory factory , RepositorySystem repositorySystem , MavenSession session , EnforcerRuleUtils utils , RuntimeInformation runtimeInformation , DefaultLifecycles defaultLifeCycles , MavenProject project , ExpressionEvaluator evaluator , PlexusContainer container ) { this . pluginManager = Objects . requireNonNull ( pluginManager ) ; this . factory = Objects . requireNonNull ( factory ) ; this . repositorySystem = Objects . requireNonNull ( repositorySystem ) ; this . session = Objects . requireNonNull ( session ) ; this . utils = Objects . requireNonNull ( utils ) ; this . runtimeInformation = Objects . requireNonNull ( runtimeInformation ) ; this . defaultLifeCycles = Objects . requireNonNull ( defaultLifeCycles ) ; this . project = Objects . requireNonNull ( project ) ; this . evaluator = Objects . requireNonNull ( evaluator ) ; this . container = Objects . requireNonNull ( container ) ; } @ Override public void execute ( ) throws EnforcerRuleException { try { lifecycles = defaultLifeCycles . getLifeCycles ( ) ; Set < Plugin > allPlugins = getBoundPlugins ( project , phases ) ; allPlugins = addAdditionalPlugins ( allPlugins , additionalPlugins ) ; allPlugins . addAll ( getProfilePlugins ( project ) ) ; allPlugins = removeUncheckedPlugins ( combineUncheckedPlugins ( unCheckedPlugins , unCheckedPluginList ) , allPlugins ) ; if ( allPlugins . isEmpty ( ) ) { getLog ( ) . info ( "No plugin bindings found." ) ; return ; } else { getLog ( ) . debug ( "All Plugins in use: " + allPlugins ) ; } List < PluginWrapper > pluginWrappers = getAllPluginEntries ( project ) ; for ( PluginWrapper pluginWrapper : pluginWrappers ) { getLog ( ) . debug ( "pluginWrappers: " + pluginWrapper . getGroupId ( ) + ":" + pluginWrapper . getArtifactId ( ) + ":" + pluginWrapper . getVersion ( ) + " source: " + pluginWrapper . getSource ( ) ) ; } List < Plugin > failures = new ArrayList < > ( ) ; for ( Plugin plugin : allPlugins ) { if ( ! hasValidVersionSpecified ( plugin , pluginWrappers ) ) { failures . add ( plugin ) ; } } if ( ! failures . isEmpty ( ) ) { handleMessagesToTheUser ( project , failures ) ; } } catch ( PluginNotFoundException | LifecycleExecutionException e ) { throw new EnforcerRuleException ( e . getLocalizedMessage ( ) , e ) ; } } private void handleMessagesToTheUser ( MavenProject project , List < Plugin > failures ) throws EnforcerRuleException { StringBuilder newMsg = new StringBuilder ( ) ; newMsg . append ( "Some plugins are missing valid versions or depend on Maven " ) ; newMsg . append ( runtimeInformation . getMavenVersion ( ) ) ; newMsg . append ( " defaults" ) ; handleBanMessages ( newMsg ) ; newMsg . append ( System . lineSeparator ( ) ) ; for ( Plugin plugin : failures ) { newMsg . append ( "   " ) ; newMsg . append ( plugin . getGroupId ( ) ) ; newMsg . append ( ":" ) ; newMsg . append ( plugin . getArtifactId ( ) ) ; try { newMsg . append ( ". \tThe version currently in use is " ) ; Plugin currentPlugin = findCurrentPlugin ( plugin , project ) ; if ( currentPlugin == null ) { newMsg . append ( "unknown" ) ; } else { newMsg . append ( currentPlugin . getVersion ( ) ) ; if ( PluginWrapper . isVersionFromDefaultLifecycleBindings ( currentPlugin ) . orElse ( false ) ) { newMsg . append ( " via default lifecycle bindings" ) ; } else { String msg = PluginWrapper . isVersionFromSuperpom ( currentPlugin ) . filter ( b -> b ) . map ( t -> " via super POM" ) . orElse ( " via super POM or default lifecycle bindings" ) ; newMsg . append ( msg ) ; } } } catch ( Exception e ) { getLog ( ) . debug ( "Exception while determining plugin Version " + e . getMessage ( ) ) ; newMsg . append ( ". Unable to determine the plugin version." ) ; } newMsg . append ( System . lineSeparator ( ) ) ; } String message = getMessage ( ) ; if ( message != null && ! message . isEmpty ( ) ) { newMsg . append ( message ) ; } throw new EnforcerRuleException ( newMsg . toString ( ) ) ; } private void handleBanMessages ( StringBuilder newMsg ) { if ( banLatest || banRelease || banSnapshots || banTimestamps ) { List < String > banList = new ArrayList < > ( ) ; if ( banLatest ) { banList . add ( "LATEST" ) ; } if ( banRelease ) { banList . add ( "RELEASE" ) ; } if ( banSnapshots ) { banList . add ( "SNAPSHOT" ) ; if ( banTimestamps ) { banList . add ( "TIMESTAMP SNAPSHOT" ) ; } } if ( ! banList . isEmpty ( ) ) { newMsg . append ( " (" ) ; newMsg . append ( String . join ( ", " , banList ) ) ; newMsg . append ( " as plugin version are not allowed)" ) ; } } } Set < Plugin > removeUncheckedPlugins ( Collection < String > uncheckedPlugins , Set < Plugin > plugins ) throws EnforcerRuleError { if ( uncheckedPlugins != null && ! uncheckedPlugins . isEmpty ( ) ) { for ( String pluginKey : uncheckedPlugins ) { Plugin plugin = parsePluginString ( pluginKey , "UncheckedPlugins" ) ; plugins . remove ( plugin ) ; } } return plugins ; } public Collection < String > combineUncheckedPlugins ( Collection < String > uncheckedPlugins , String uncheckedPluginsList ) { if ( uncheckedPluginsList != null && ! uncheckedPluginsList . isEmpty ( ) ) { if ( uncheckedPlugins == null ) { uncheckedPlugins = new HashSet < > ( ) ; } else if ( ! uncheckedPlugins . isEmpty ( ) ) { getLog ( ) . warn ( "The parameter 'unCheckedPlugins' is deprecated. Use 'unCheckedPluginList' instead" ) ; } uncheckedPlugins . addAll ( Arrays . asList ( uncheckedPluginsList . split ( "," ) ) ) ; } return uncheckedPlugins ; } public Set < Plugin > addAdditionalPlugins ( Set < Plugin > existing , List < String > additional ) throws EnforcerRuleError { if ( additional != null ) { for ( String pluginString : additional ) { Plugin plugin = parsePluginString ( pluginString , "AdditionalPlugins" ) ; if ( existing == null ) { existing = new HashSet < > ( ) ; existing . add ( plugin ) ; } else if ( ! existing . contains ( plugin ) ) { existing . add ( plugin ) ; } } } return existing ; } private Plugin parsePluginString ( String pluginString , String field ) throws EnforcerRuleError { if ( pluginString != null ) { String [ ] pluginStrings = pluginString . split ( ":" ) ; if ( pluginStrings . length == 2 ) { Plugin plugin = new Plugin ( ) ; plugin . setGroupId ( StringUtils . strip ( pluginStrings [ 0 ] ) ) ; plugin . setArtifactId ( StringUtils . strip ( pluginStrings [ 1 ] ) ) ; return plugin ; } else { throw new EnforcerRuleError ( "Invalid " + field + " string: " + pluginString ) ; } } else { throw new EnforcerRuleError ( "Invalid " + field + " string: " + pluginString ) ; } } public Set < Plugin > getProfilePlugins ( MavenProject project ) { Set < Plugin > result = new HashSet < > ( ) ; List < Profile > profiles = project . getActiveProfiles ( ) ; if ( profiles != null && ! profiles . isEmpty ( ) ) { for ( Profile p : profiles ) { BuildBase b = p . getBuild ( ) ; if ( b != null ) { List < Plugin > plugins = b . getPlugins ( ) ; if ( plugins != null ) { result . addAll ( plugins ) ; } } } } return result ; } private Plugin findCurrentPlugin ( Plugin plugin , MavenProject project ) throws EnforcerRuleException { Plugin found = null ; try { Model model = project . getModel ( ) ; Map < String , Plugin > plugins = model . getBuild ( ) . getPluginsAsMap ( ) ; found = plugins . get ( plugin . getKey ( ) ) ; } catch ( NullPointerException e ) { } if ( found == null ) { Artifact artifact = factory . createPluginArtifact ( plugin . getGroupId ( ) , plugin . getArtifactId ( ) , VersionRange . createFromVersion ( "LATEST" ) ) ; try { repositorySystem . resolveArtifact ( session . getRepositorySession ( ) , new ArtifactRequest ( RepositoryUtils . toArtifact ( artifact ) , session . getCurrentProject ( ) . getRemotePluginRepositories ( ) , "resolvePlugin" ) ) ; } catch ( ArtifactResolutionException e ) { throw new EnforcerRuleException ( "Unable to resolve the plugin " + artifact . getArtifactId ( ) , e ) ; } plugin . setVersion ( artifact . getVersion ( ) ) ; found = plugin ; } return found ; } private Set < Plugin > getBoundPlugins ( MavenProject project , String thePhases ) throws PluginNotFoundException , LifecycleExecutionException { Set < Plugin > allPlugins = new HashSet < > ( ) ; String [ ] lifecyclePhases = thePhases . split ( "," ) ; for ( int i = 0 ; i < lifecyclePhases . length ; i ++ ) { String lifecyclePhase = lifecyclePhases [ i ] ; if ( lifecyclePhase != null && ! lifecyclePhase . isEmpty ( ) ) { try { Lifecycle lifecycle = getLifecycleForPhase ( lifecyclePhase ) ; getLog ( ) . debug ( "getBoundPlugins(): " + project . getId ( ) + " " + lifecyclePhase + " " + lifecycle . getId ( ) ) ; allPlugins . addAll ( getAllPlugins ( project , lifecycle ) ) ; } catch ( BuildFailureException e ) { } } } return allPlugins ; } public boolean hasValidVersionSpecified ( Plugin source , List < PluginWrapper > pluginWrappers ) { boolean found = false ; boolean status = false ; for ( PluginWrapper plugin : pluginWrappers ) { if ( isMatchingPlugin ( source , plugin ) ) { found = true ; String version = plugin . getVersion ( ) ; try { version = ( String ) evaluator . evaluate ( version ) ; } catch ( ExpressionEvaluationException e ) { return false ; } if ( isValidVersion ( version ) ) { getLog ( ) . debug ( "checking for notEmpty and notIsWhitespace(): " + version ) ; if ( banRelease && version . equals ( "RELEASE" ) ) { return false ; } if ( banLatest && version . equals ( "LATEST" ) ) { return false ; } if ( banSnapshots && isSnapshot ( version ) ) { return false ; } status = true ; if ( ! banRelease && ! banLatest && ! banSnapshots ) { break ; } } } } if ( ! found ) { getLog ( ) . debug ( "plugin " + source . getGroupId ( ) + ":" + source . getArtifactId ( ) + " not found" ) ; } return status ; } private boolean isValidVersion ( String version ) { return ( version != null && ! version . isEmpty ( ) ) && ! StringUtils . isWhitespace ( version ) ; } private boolean isMatchingPlugin ( Plugin source , PluginWrapper plugin ) { return source . getArtifactId ( ) . equals ( plugin . getArtifactId ( ) ) && source . getGroupId ( ) . equals ( plugin . getGroupId ( ) ) ; } private boolean isSnapshot ( String baseVersion ) { if ( banTimestamps ) { return Artifact . VERSION_FILE_PATTERN . matcher ( baseVersion ) . matches ( ) || baseVersion . endsWith ( Artifact . SNAPSHOT_VERSION ) ; } else { return baseVersion . endsWith ( Artifact . SNAPSHOT_VERSION ) ; } } private Set < Plugin > getAllPlugins ( MavenProject project , Lifecycle lifecycle ) throws PluginNotFoundException , LifecycleExecutionException { getLog ( ) . debug ( "RequirePluginVersions.getAllPlugins:" ) ; Set < Plugin > plugins = new HashSet < > ( ) ; Map < String , String > mappings = findMappingsForLifecycle ( project , lifecycle ) ; for ( Map . Entry < String , String > entry : mappings . entrySet ( ) ) { getLog ( ) . debug ( "  lifecycleMapping = " + entry . getKey ( ) ) ; String pluginsForLifecycle = ( String ) entry . getValue ( ) ; getLog ( ) . debug ( "  plugins = " + pluginsForLifecycle ) ; if ( pluginsForLifecycle != null && ! pluginsForLifecycle . isEmpty ( ) ) { String pluginList [ ] = pluginsForLifecycle . split ( "," ) ; for ( String plugin : pluginList ) { plugin = StringUtils . strip ( plugin ) ; getLog ( ) . debug ( "    plugin = " + plugin ) ; String tokens [ ] = plugin . split ( ":" ) ; getLog ( ) . debug ( "    GAV = " + Arrays . asList ( tokens ) ) ; Plugin p = new Plugin ( ) ; p . setGroupId ( tokens [ 0 ] ) ; p . setArtifactId ( tokens [ 1 ] ) ; plugins . add ( p ) ; } } } plugins . addAll ( project . getBuildPlugins ( ) ) ; return plugins ; } public Map < String , Lifecycle > getPhaseToLifecycleMap ( ) throws LifecycleExecutionException { if ( phaseToLifecycleMap == null ) { phaseToLifecycleMap = new HashMap < > ( ) ; for ( Lifecycle lifecycle : lifecycles ) { List < String > phases = lifecycle . getPhases ( ) ; for ( String phase : phases ) { getLog ( ) . debug ( "getPhaseToLifecycleMap(): phase: " + phase ) ; if ( phaseToLifecycleMap . containsKey ( phase ) ) { Lifecycle prevLifecycle = ( Lifecycle ) phaseToLifecycleMap . get ( phase ) ; throw new LifecycleExecutionException ( "Phase '" + phase + "' is defined in more than one lifecycle: '" + lifecycle . getId ( ) + "' and '" + prevLifecycle . getId ( ) + "'" ) ; } else { phaseToLifecycleMap . put ( phase , lifecycle ) ; } } } } return phaseToLifecycleMap ; } private Lifecycle getLifecycleForPhase ( String phase ) throws BuildFailureException , LifecycleExecutionException { Lifecycle lifecycle = getPhaseToLifecycleMap ( ) . get ( phase ) ; if ( lifecycle == null ) { throw new BuildFailureException ( "Unable to find lifecycle for phase '" + phase + "'" ) ; } return lifecycle ; } private Map < String , String > findMappingsForLifecycle ( MavenProject project , Lifecycle lifecycle ) throws LifecycleExecutionException , PluginNotFoundException { String packaging = project . getPackaging ( ) ; Map < String , String > mappings = null ; LifecycleMapping m = ( LifecycleMapping ) findExtension ( project , LifecycleMapping . ROLE , packaging , session . getSettings ( ) , session . getLocalRepository ( ) ) ; if ( m != null ) { mappings = m . getPhases ( lifecycle . getId ( ) ) ; } Map < String , String > defaultMappings = lifecycle . getDefaultPhases ( ) ; if ( mappings == null ) { try { m = container . lookup ( LifecycleMapping . class , packaging ) ; mappings = m . getPhases ( lifecycle . getId ( ) ) ; } catch ( ComponentLookupException e ) { if ( defaultMappings == null ) { throw new LifecycleExecutionException ( "Cannot find lifecycle mapping for packaging: \'" + packaging + "\'." , e ) ; } } } if ( mappings == null ) { if ( defaultMappings == null ) { throw new LifecycleExecutionException ( "Cannot find lifecycle mapping for packaging: \'" + packaging + "\', and there is no default" ) ; } else { mappings = defaultMappings ; } } return mappings ; } private Object findExtension ( MavenProject project , String role , String roleHint , Settings settings , ArtifactRepository localRepository ) throws LifecycleExecutionException , PluginNotFoundException { Object pluginComponent = null ; List < Plugin > buildPlugins = project . getBuildPlugins ( ) ; for ( Plugin plugin : buildPlugins ) { if ( plugin . isExtensions ( ) ) { verifyPlugin ( plugin , project , settings , localRepository ) ; try { pluginComponent = pluginManager . getPluginComponent ( plugin , role , roleHint ) ; if ( pluginComponent != null ) { break ; } } catch ( ComponentLookupException e ) { getLog ( ) . debug ( "Unable to find the lifecycle component in the extension " + e . getMessage ( ) ) ; } catch ( PluginManagerException e ) { throw new LifecycleExecutionException ( "Error getting extensions from the plugin '" + plugin . getKey ( ) + "': " + e . getMessage ( ) , e ) ; } } } return pluginComponent ; } private PluginDescriptor verifyPlugin ( Plugin plugin , MavenProject project , Settings settings , ArtifactRepository localRepository ) throws LifecycleExecutionException , PluginNotFoundException { PluginDescriptor pluginDescriptor ; try { pluginDescriptor = pluginManager . verifyPlugin ( plugin , project , settings , localRepository ) ; } catch ( PluginManagerException e ) { throw new LifecycleExecutionException ( "Internal error in the plugin manager getting plugin '" + plugin . getKey ( ) + "': " + e . getMessage ( ) , e ) ; } catch ( PluginVersionResolutionException | InvalidVersionSpecificationException | InvalidPluginException | PluginVersionNotFoundException | org . apache . maven . artifact . resolver . ArtifactResolutionException | ArtifactNotFoundException e ) { throw new LifecycleExecutionException ( e . getMessage ( ) , e ) ; } return pluginDescriptor ; } private List < PluginWrapper > getAllPluginEntries ( MavenProject project ) { List < PluginWrapper > plugins = new ArrayList < > ( ) ; getPlugins ( plugins , project . getModel ( ) ) ; getReportingPlugins ( plugins , project . getModel ( ) ) ; getPluginManagementPlugins ( plugins , project . getModel ( ) ) ; addPluginsInProfiles ( plugins , project . getModel ( ) ) ; return plugins ; } private void addPluginsInProfiles ( List < PluginWrapper > plugins , Model model ) { List < Profile > profiles = ofNullable ( model ) . map ( Model :: getProfiles ) . orElseGet ( Collections :: emptyList ) ; for ( Profile profile : profiles ) { getProfilePlugins ( plugins , profile ) ; getProfileReportingPlugins ( plugins , profile ) ; getProfilePluginManagementPlugins ( plugins , profile ) ; } } private void getProfilePluginManagementPlugins ( List < PluginWrapper > plugins , Profile profile ) { List < Plugin > modelPlugins = ofNullable ( profile ) . map ( Profile :: getBuild ) . map ( PluginConfiguration :: getPluginManagement ) . map ( PluginContainer :: getPlugins ) . orElseGet ( Collections :: emptyList ) ; plugins . addAll ( PluginWrapper . addAll ( utils . resolvePlugins ( modelPlugins ) , banMavenDefaults ) ) ; } private void getProfileReportingPlugins ( List < PluginWrapper > plugins , Profile profile ) { List < ReportPlugin > modelReportPlugins = ofNullable ( profile ) . map ( ModelBase :: getReporting ) . map ( Reporting :: getPlugins ) . orElseGet ( Collections :: emptyList ) ; plugins . addAll ( PluginWrapper . addAll ( utils . resolveReportPlugins ( modelReportPlugins ) , banMavenDefaults ) ) ; } private void getProfilePlugins ( List < PluginWrapper > plugins , Profile profile ) { List < Plugin > modelPlugins = ofNullable ( profile ) . map ( Profile :: getBuild ) . map ( PluginContainer :: getPlugins ) . orElseGet ( Collections :: emptyList ) ; plugins . addAll ( PluginWrapper . addAll ( utils . resolvePlugins ( modelPlugins ) , banMavenDefaults ) ) ; } private void getPlugins ( List < PluginWrapper > plugins , Model model ) { List < Plugin > modelPlugins = ofNullable ( model ) . map ( Model :: getBuild ) . map ( PluginContainer :: getPlugins ) . orElseGet ( Collections :: emptyList ) ; plugins . addAll ( PluginWrapper . addAll ( utils . resolvePlugins ( modelPlugins ) , banMavenDefaults ) ) ; } private void getPluginManagementPlugins ( List < PluginWrapper > plugins , Model model ) { List < Plugin > modelPlugins = ofNullable ( model ) . map ( Model :: getBuild ) . map ( PluginConfiguration :: getPluginManagement ) . map ( PluginContainer :: getPlugins ) . orElseGet ( Collections :: emptyList ) ; plugins . addAll ( PluginWrapper . addAll ( utils . resolvePlugins ( modelPlugins ) , banMavenDefaults ) ) ; } private void getReportingPlugins ( List < PluginWrapper > plugins , Model model ) { List < ReportPlugin > modelReportPlugins = ofNullable ( model ) . map ( ModelBase :: getReporting ) . map ( Reporting :: getPlugins ) . orElseGet ( Collections :: emptyList ) ; plugins . addAll ( PluginWrapper . addAll ( utils . resolveReportPlugins ( modelReportPlugins ) , banMavenDefaults ) ) ; } public void setBanLatest ( boolean theBanLatest ) { this . banLatest = theBanLatest ; } public void setBanRelease ( boolean theBanRelease ) { this . banRelease = theBanRelease ; } public boolean isBanSnapshots ( ) { return this . banSnapshots ; } public void setBanSnapshots ( boolean theBanSnapshots ) { this . banSnapshots = theBanSnapshots ; } public void setBanTimestamps ( boolean theBanTimestamps ) { this . banTimestamps = theBanTimestamps ; } @ Override public String toString ( ) { return String . format ( "RequirePluginVersions[message=%s, banLatest=%b, banRelease=%b, banSnapshots=%b, banTimestamps=%b, phases=%s, additionalPlugins=%s, unCheckedPluginList=%s, unCheckedPlugins=%s]" , getMessage ( ) , banLatest , banRelease , banSnapshots , banTimestamps , phases , additionalPlugins , unCheckedPluginList , unCheckedPlugins ) ; } } 