<<<<<<< HEAD
public class Builder { private final static Logger logger = LoggerFactory . getLogger ( Builder . class ) ; private static final Pattern prefixNameSplitter = Pattern . compile ( "([a-z]+)([A-Z0-9]+[a-zA-Z0-9]*)" ) ; public final static Map < String , ? > EMPTY_PROPERTIES = null ; public final static String NAME = "name" ; public final static String CONTENT = "content" ; public final static String CONSTRAINTS = "constraints" ; public final static String BIND = "bind" ; public final static String VALIDATE = "validate" ; public final static String VALUE = "value" ; public final static String LAYOUT = "layout" ; public final static String ON_ACTION = "onAction" ; public final static String ON_FOCUS = "onFocus" ; public final static String ON_FOCUS_LOST = "onFocusLost" ; public final static String THIS = "this" ; public final static String NAMED_OBJECT_REGEX = "\\$\\{[a-zA-Z0-9]+\\}" ; private final static int NAMED_OBJECT_PREFIX_LENGTH = 2 ; private final static int NAMED_OBJECT_SUFFIX_LENGTH = 1 ; public static final String RESOURCE_BUNDLE = "org/javabuilders/Resources" ; public final static String VALIDATE_CUSTOM_COMMAND = "$validate" ; public final static String CONFIRM_CUSTOM_COMMAND = "$confirm" ; public final static String BOOLEAN_FALSE = "false" ; public final static String BOOLEAN_TRUE = "true" ; public final static String INTERNAL_FIELD_PREFIX = "__" ; public final static String PROTOTYPE_FIELD_PREFIX = "$" ; public static BuildResult build ( BuilderConfig config , Object caller , ResourceBundle ... resourceBundles ) { return build ( config , caller , EMPTY_PROPERTIES , resourceBundles ) ; } public static BuildResult build ( BuilderConfig config , Object caller , Map < String , ? > customProperties , ResourceBundle ... resourceBundles ) { Class < ? > type = caller . getClass ( ) ; String fileName = null ; if ( type . isAnnotationPresent ( BuildFile . class ) ) { fileName = type . getAnnotation ( BuildFile . class ) . value ( ) ; } else { Class < ? > declaringType = type . getDeclaringClass ( ) ; if ( declaringType == null ) { fileName = type . getSimpleName ( ) + config . getYamlExtension ( ) ; } else { StringBuilder bld = new StringBuilder ( type . getSimpleName ( ) ) ; while ( declaringType != null ) { bld . insert ( 0 , declaringType . getSimpleName ( ) ) ; bld . insert ( declaringType . getSimpleName ( ) . length ( ) , "." ) ; declaringType = declaringType . getDeclaringClass ( ) ; } bld . append ( config . getYamlExtension ( ) ) ; fileName = bld . toString ( ) ; } } BuildResult result ; result = build ( config , caller , fileName , customProperties , resourceBundles ) ; return result ; } public static BuildResult build ( BuilderConfig config , Object caller , String fileName , ResourceBundle ... resourceBundles ) { return build ( config , caller , fileName , null , resourceBundles ) ; } public static BuildResult build ( BuilderConfig config , Object caller , String fileName , Map < String , ? > customProperties , ResourceBundle ... resourceBundles ) { if ( caller == null ) { throw new NullPointerException ( "Caller cannot be null or empty" ) ; } InputStream input = null ; if ( BuilderConfig . getDevSourceFolder ( ) == null || caller . getClass ( ) . getPackage ( ) . getName ( ) . startsWith ( Builder . class . getPackage ( ) . getName ( ) ) ) { input = caller . getClass ( ) . getResourceAsStream ( fileName ) ; } else { String yamlFileName = fileName ; try { URI bin = caller . getClass ( ) . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) . toURI ( ) ; URI src = bin . resolve ( new URI ( BuilderConfig . getDevSourceFolder ( ) + "/" + caller . getClass ( ) . getPackage ( ) . getName ( ) . replace ( "." , "/" ) + "/" + fileName ) ) ; yamlFileName = src . toString ( ) ; input = new FileInputStream ( new File ( src ) ) ; } catch ( Exception e ) { throw new BuildException ( e , "Unable to process file {0}.\n{1}" , yamlFileName , e ) ; } } if ( input == null ) { throw new BuildException ( "No YAML file found: {0}.\nMaybe you are using an older extension (.yaml) " + " and need to change it via config.setYamlExtension(String) in your main().\n" + "The default was changed to ''.yml'' as of version 1.1 to be compatible with the YAML standard." , fileName ) ; } StringBuilder bld = new StringBuilder ( ) ; try { BufferedReader rdr = new BufferedReader ( new InputStreamReader ( input ) ) ; String line = rdr . readLine ( ) ; while ( line != null ) { bld . append ( line ) . append ( "\n" ) ; line = rdr . readLine ( ) ; } rdr . close ( ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } return buildFromString ( config , caller , bld . toString ( ) , fileName , customProperties , resourceBundles ) ; } public static BuildResult buildFromString ( BuilderConfig config , Object caller , String yamlContent , ResourceBundle ... resourceBundles ) { return buildFromString ( config , caller , yamlContent , null , null , resourceBundles ) ; } public static BuildResult buildFromString ( BuilderConfig config , Object caller , String yamlContent , Map < String , ? > customProperties , ResourceBundle ... resourceBundles ) { return buildFromString ( config , caller , yamlContent , null , customProperties , resourceBundles ) ; } @ SuppressWarnings ( "unchecked" ) public static BuildResult buildFromString ( BuilderConfig config , Object caller , String yamlContent , String fileName , Map < String , ? > customProperties , ResourceBundle ... resourceBundles ) { if ( caller == null ) { throw new NullPointerException ( "Caller cannot be null or empty" ) ; } BuildProcess process = new BuildProcess ( config , caller , resourceBundles ) ; if ( customProperties != null ) { for ( String key : customProperties . keySet ( ) ) { process . getBuildResult ( ) . getProperties ( ) . put ( key , customProperties . get ( key ) ) ; } } BuilderUtils . validateYamlContent ( yamlContent , fileName ) ; Yaml yaml = new Yaml ( ) ; Object document = yaml . load ( yamlContent ) ; executeBuild ( document , config , process ) ; return process . getBuildResult ( ) ; } public static Object buildControlFromName ( BuildProcess process , Node parent , String name ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Build control from name: {}, name" ) ; } Class < ? > clazz = null ; String yamlContent = null ; if ( name . startsWith ( PROTOTYPE_FIELD_PREFIX ) ) { yamlContent = process . getConfig ( ) . getPrototype ( name . substring ( 1 ) ) ; if ( yamlContent != null ) { yamlContent = yamlContent . trim ( ) ; String key = BuilderUtils . getRealKey ( yamlContent ) ; clazz = process . getConfig ( ) . getClassType ( key ) ; if ( clazz != null ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; BuilderUtils . uncompressYaml ( yamlContent , map ) ; processDocumentNode ( process . getConfig ( ) , process , parent , clazz . getSimpleName ( ) , map ) ; return process . getByName ( name . substring ( 1 ) ) ; } else { throw new BuildException ( "Unable to find type for protype {0}" , yamlContent ) ; } } else { throw new BuildException ( "Unable to find prototype definition for {0}" , name ) ; } } else { Matcher m = prefixNameSplitter . matcher ( name ) ; if ( m . find ( ) && m . groupCount ( ) == 2 ) { String prefix = m . group ( 1 ) ; String suffix = m . group ( 2 ) ; PrefixControlDefinition def = process . getConfig ( ) . getPrefix ( prefix ) ; if ( def != null ) { clazz = def . getType ( ) ; yamlContent = def . getDefaultsAsYaml ( process , name , suffix ) ; } else { throw new BuildException ( "Unable to find type for prefix {0} for {1}" , prefix , name ) ; } } else { throw new BuildException ( "Unable to parse prefix and suffix from control name: {0}" , name ) ; } } Yaml yaml = new Yaml ( ) ; Object rawDocumentNode = yaml . load ( yamlContent ) ; processDocumentNode ( process . getConfig ( ) , process , parent , clazz . getSimpleName ( ) , rawDocumentNode ) ; return process . getByName ( name ) ; } @ SuppressWarnings ( "unchecked" ) private static void executeBuild ( Object document , BuilderConfig config , BuildProcess process ) throws BuildException { BuildListener [ ] listeners = config . getBuildListeners ( ) ; BuildEvent buildEvent = new BuildEvent ( process . getCaller ( ) , process . getBuildResult ( ) ) ; if ( listeners . length > 0 ) { for ( BuildListener listener : listeners ) { listener . buildStarted ( buildEvent ) ; } } document = BuilderPreProcessor . preprocess ( config , process , document , null ) ; process . setDocument ( document ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Building from YAML document:\n{}" , document ) ; } if ( document instanceof Map ) { Map < String , Object > map = ( Map < String , Object > ) document ; Set < String > systemNodes = new LinkedHashSet < String > ( ) ; systemNodes . add ( BIND ) ; systemNodes . add ( VALIDATE ) ; List < String > priorities = new LinkedList < String > ( ) ; for ( String key : map . keySet ( ) ) { if ( ! systemNodes . contains ( key ) ) { priorities . add ( key ) ; } } for ( String systemNode : systemNodes ) { if ( map . containsKey ( systemNode ) ) { priorities . add ( systemNode ) ; } } for ( String key : priorities ) { Object docNode = map . get ( key ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Processing root node: {}" , key ) ; } if ( docNode instanceof Map ) { processDocumentNode ( config , process , null , key , docNode ) ; } else if ( docNode instanceof List ) { Map < String , Object > content = new HashMap < String , Object > ( ) ; content . put ( Builder . CONTENT , docNode ) ; docNode = content ; processDocumentNode ( config , process , null , key , docNode ) ; } else if ( docNode instanceof String ) { Map < String , Object > value = new HashMap < String , Object > ( ) ; value . put ( Builder . VALUE , docNode ) ; docNode = value ; processDocumentNode ( config , process , null , key , docNode ) ; } else { throw new BuildException ( "Unable to handle the root node :" + key ) ; } if ( ! systemNodes . contains ( key ) ) { for ( NamedObjectPropertyValue request : process . getPropertiesAsNamedObjects ( ) ) { request . setReference ( process ) ; } process . getPropertiesAsNamedObjects ( ) . clear ( ) ; } } } else { processDocumentNode ( config , process , null , null , document ) ; } BuilderUtils . updateNamedObjectReferencesInCaller ( process ) ; listeners = config . getBuildListeners ( ) ; for ( BuildListener listener : listeners ) { listener . buildEnded ( buildEvent ) ; } } @ SuppressWarnings ( "unchecked" ) private static void processDocumentNode ( BuilderConfig config , BuildProcess process , Node parent , String currentKey , Object rawDocumentNode ) throws BuildException { if ( rawDocumentNode instanceof Map ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Started creating object defined by alias: {}" , currentKey ) ; } Map < String , Object > data = ( Map < String , Object > ) rawDocumentNode ; Class < ? > currentType = BuilderUtils . getClassFromAlias ( process , currentKey , null ) ; if ( currentType == null ) { throw new InvalidTypeException ( currentKey ) ; } handleType ( config , process , parent , currentKey , data , currentType ) ; } else if ( rawDocumentNode instanceof List ) { if ( parent == null ) { throw new BuildException ( "Yaml cannot start with a List as root: {0}" , rawDocumentNode ) ; } @ SuppressWarnings ( "rawtypes" ) List items = ( List ) rawDocumentNode ; Class < ? > type = BuilderUtils . getClassFromAlias ( process , currentKey , null ) ; if ( Builder . CONTENT . equals ( currentKey ) || type != null ) { Node itemsNode = new Node ( parent , currentKey ) ; if ( parent != null ) { parent . addChildNode ( itemsNode ) ; itemsNode . setMainObject ( parent . getMainObject ( ) ) ; itemsNode . setConsumedKeys ( parent . getConsumedKeys ( ) ) ; } boolean treatListAsPropertyValue = true ; for ( Object item : items ) { if ( item instanceof Map ) { Map < String , Object > itemMap = ( Map < String , Object > ) item ; for ( String itemKey : itemMap . keySet ( ) ) { Object itemValue = itemMap . get ( itemKey ) ; processDocumentNode ( config , process , itemsNode , itemKey , itemValue ) ; treatListAsPropertyValue = false ; } } } if ( treatListAsPropertyValue ) { handleProperty ( config , process , parent , currentKey ) ; } } else { handleProperty ( config , process , parent , currentKey ) ; } } else { if ( parent != null ) { handleProperty ( config , process , parent , currentKey ) ; } else { throw new InvalidFormatException ( "Unable to process document node : {0}" , rawDocumentNode ) ; } } } public static Object createControlFromCompressedYaml ( BuildProcess process , Node parent , String compressedYaml ) { Map < String , Object > data = new HashMap < String , Object > ( ) ; BuilderUtils . uncompressYaml ( compressedYaml , data ) ; String key = BuilderUtils . getRealKey ( compressedYaml ) ; Class < ? > classType = BuilderUtils . getClassFromAlias ( process , key , null ) ; return handleType ( process . getConfig ( ) , process , parent , key , data , classType ) . getMainObject ( ) ; } private static Node handleType ( BuilderConfig config , BuildProcess process , Node parent , String currentKey , Map < String , Object > data , Class < ? > classType ) throws BuildException { Class < ? > currentType = BuilderUtils . getClassFromAlias ( process , currentKey , null ) ; if ( currentType == null ) { throw new InvalidTypeException ( currentKey ) ; } handleDefaults ( config , process , parent , currentKey , data , currentType ) ; validate ( config , process , parent , currentKey , data , currentType ) ; ITypeHandler typeHandler = TypeDefinition . getTypeHandler ( config , currentType ) ; Node current = null ; Object existingInstance = BuilderUtils . getExistingInstanceIfAvailable ( process . getCaller ( ) , currentType , config , data ) ; if ( existingInstance != null ) { current = typeHandler . useExistingInstance ( config , process , parent , currentKey , data , existingInstance ) ; } else if ( parent == null && process . getCaller ( ) != null && currentType . isAssignableFrom ( process . getCaller ( ) . getClass ( ) ) ) { current = typeHandler . useExistingInstance ( config , process , parent , currentKey , data , process . getCaller ( ) ) ; } else { current = typeHandler . createNewInstance ( config , process , parent , currentKey , data ) ; } if ( current == null ) { return null ; } else if ( current . getMainObject ( ) == null ) { throw new BuildException ( "ITypeHandler for alias " + currentKey + " did not set Node.mainObject to a value" ) ; } for ( String typeHandlerKey : typeHandler . getConsumedKeys ( ) ) { current . getConsumedKeys ( ) . add ( typeHandlerKey ) ; } TypeDefinition def = config . getTypeDefinition ( currentType ) ; if ( def != null ) { ITypeHandlerFinishProcessor finishProcessor = config . getTypeDefinition ( currentType ) . getFinishProcessor ( ) ; if ( finishProcessor != null && finishProcessor instanceof IKeyValueConsumer ) { IKeyValueConsumer consumer = ( IKeyValueConsumer ) finishProcessor ; for ( String key : consumer . getConsumedKeys ( ) ) { current . getConsumedKeys ( ) . add ( key ) ; } } } Class < ? > createdClassType = current . getMainObject ( ) . getClass ( ) ; Set < TypeDefinition > typeDefinitions = config . getTypeDefinitions ( createdClassType ) ; Set < String > ignored = TypeDefinition . getIgnored ( config , current . getMainObject ( ) . getClass ( ) ) ; List < ITypeHandlerAfterCreationProcessor > afterCreationProcessors = TypeDefinition . getAfterCreationProcessors ( config , createdClassType ) ; for ( ITypeHandlerAfterCreationProcessor processor : afterCreationProcessors ) { processor . afterCreation ( config , process , current , currentKey , data ) ; } if ( parent != null ) { Class < ? > parentClass = parent . getMainObject ( ) . getClass ( ) ; Method method = TypeDefinition . getTypeAsMethod ( config , parentClass , createdClassType ) ; if ( method != null ) { try { Object target = parent . getMainObject ( ) ; Object argument = current . getMainObject ( ) ; method . invoke ( target , argument ) ; } catch ( Exception e ) { throw new BuildException ( e , "Unable to call {0} on {1} with type {2}. Error: {3}" , method , parentClass . getSimpleName ( ) , createdClassType . getSimpleName ( ) , e . getMessage ( ) ) ; } } } if ( ! ( typeHandler instanceof ITypeChildrenHandler ) ) { Map < Integer , List < String > > delayedKeysByWeight = new TreeMap < Integer , List < String > > ( ) ; for ( String childKey : data . keySet ( ) ) { Object childValue = data . get ( childKey ) ; if ( current . getConsumedKeys ( ) . contains ( childKey ) ) { continue ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Processing child key: {}" , childKey ) ; } if ( childValue instanceof String ) { if ( TypeDefinition . isLocalizableProperty ( childKey , typeDefinitions ) ) { data . put ( childKey , process . getBuildResult ( ) . getResource ( String . valueOf ( childValue ) ) ) ; } } Class < ? > childClass = BuilderUtils . getClassFromAlias ( process , childKey , null ) ; if ( childClass != null ) { ITypeHandler childTypeHandler = TypeDefinition . getTypeHandler ( config , childClass ) ; Integer delayedWeight = TypeDefinition . getDelayedWeight ( childTypeHandler , config . getTypeDefinitions ( createdClassType ) ) ; if ( childTypeHandler != null && delayedWeight > 0 ) { addToDelayedKeys ( delayedKeysByWeight , delayedWeight , childKey ) ; } else { processDocumentNode ( config , process , current , childKey , childValue ) ; } } else { if ( ! ignored . contains ( childKey ) && ! isInternal ( childKey ) ) { Integer delayedWeight = TypeDefinition . getDelayedWeight ( typeHandler , childKey , config . getTypeDefinitions ( createdClassType ) ) ; if ( delayedWeight > 0 ) { addToDelayedKeys ( delayedKeysByWeight , delayedWeight , childKey ) ; } else { processDocumentNode ( config , process , current , childKey , childValue ) ; } } } } for ( Integer delayWeight : delayedKeysByWeight . keySet ( ) ) { List < String > keys = delayedKeysByWeight . get ( delayWeight ) ; for ( String delayedKey : keys ) { Object delayedValue = data . get ( delayedKey ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Processing delayed weight: {} / {}" , delayWeight , delayedKey ) ; } processDocumentNode ( config , process , current , delayedKey , delayedValue ) ; } } ChildrenCardinalityUtils . checkChildrenCardinality ( config , current ) ; } if ( parent == null && current . getMainObject ( ) != null ) { process . getBuildResult ( ) . getRoots ( ) . add ( current . getMainObject ( ) ) ; } if ( typeHandler instanceof ITypeHandlerFinishProcessor ) { ITypeHandlerFinishProcessor postHandler = ( ITypeHandlerFinishProcessor ) typeHandler ; postHandler . finish ( config , process , current , currentKey , data ) ; } List < ITypeHandlerFinishProcessor > postProcessors = TypeDefinition . getFinishProcessors ( config , createdClassType ) ; for ( ITypeHandlerFinishProcessor postProcessor : postProcessors ) { postProcessor . finish ( config , process , current , currentKey , data ) ; } String name = config . getNameIfAvailable ( data ) ; if ( name != null ) { process . addNamedObject ( name , current . getMainObject ( ) ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Finished creating object defined by alias: {}" , currentKey ) ; } return current ; } private static boolean isInternal ( String childKey ) { return childKey . startsWith ( INTERNAL_FIELD_PREFIX ) ; } private static void addToDelayedKeys ( Map < Integer , List < String > > delayedKeysByWeight , Integer delayWeight , String key ) { List < String > delayedKeys = delayedKeysByWeight . get ( delayWeight ) ; if ( delayedKeys == null ) { delayedKeys = new LinkedList < String > ( ) ; delayedKeysByWeight . put ( delayWeight , delayedKeys ) ; } delayedKeys . add ( key ) ; } private static void handleProperty ( BuilderConfig config , BuildProcess process , Node parent , String currentKey ) throws BuildException { if ( ! parent . getConsumedKeys ( ) . contains ( currentKey ) ) { if ( parent . getProperty ( currentKey ) instanceof String ) { String sValue = parent . getStringProperty ( currentKey ) ; if ( sValue . matches ( Builder . NAMED_OBJECT_REGEX ) ) { NamedObjectPropertyValue nopValue = new NamedObjectPropertyValue ( parent . getMainObject ( ) , currentKey , sValue . substring ( NAMED_OBJECT_PREFIX_LENGTH , sValue . length ( ) - NAMED_OBJECT_SUFFIX_LENGTH ) ) ; process . getPropertiesAsNamedObjects ( ) . add ( nopValue ) ; parent . getConsumedKeys ( ) . add ( currentKey ) ; return ; } } if ( parent . getProperty ( currentKey ) instanceof String ) { String sValue = parent . getStringProperty ( currentKey ) ; if ( sValue . matches ( BuilderConfig . GLOBAL_VARIABLE_REGEX ) ) { GlobalVariablePropertyHandler . getInstance ( ) . handle ( config , process , parent , currentKey ) ; return ; } } IPropertyHandler handler = TypeDefinition . getPropertyHandler ( config , parent . getMainObject ( ) . getClass ( ) , currentKey ) ; if ( logger . isDebugEnabled ( ) ) { if ( handler . getConsumedKeys ( ) . size ( ) == 0 ) { logger . debug ( "Handling property '{}' of value '{}' for type alias '{}'" , new Object [ ] { currentKey , parent . getProperties ( ) . get ( currentKey ) , parent . getKey ( ) } ) ; } else { for ( String consumedKey : handler . getConsumedKeys ( ) ) { if ( parent . getProperties ( ) . containsKey ( consumedKey ) ) { logger . debug ( "Handling property '{}' of value '{}' for type alias '{}'" , new Object [ ] { consumedKey , parent . getProperties ( ) . get ( consumedKey ) , parent . getKey ( ) } ) ; } } } } if ( handler instanceof IPropertyList ) { IPropertyList propertyList = ( IPropertyList ) handler ; for ( String consumedKey : handler . getConsumedKeys ( ) ) { if ( propertyList . isList ( consumedKey ) ) { Object value = parent . getProperties ( ) . get ( consumedKey ) ; if ( value != null && ! ( value instanceof List ) ) { List < Object > valueList = new ArrayList < Object > ( ) ; valueList . add ( value ) ; parent . getProperties ( ) . put ( consumedKey , valueList ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Converted single value {} to a single item list for property " , consumedKey ) ; } } } } } try { if ( handler instanceof ITypeAsValueSupport && PropertyUtils . isValid ( parent . getMainObject ( ) , currentKey ) ) { Class < ? > propertyType = PropertyUtils . getPropertyType ( parent . getMainObject ( ) , currentKey ) ; ITypeAsValueHandler < ? extends Object > asValueHandler = TypeDefinition . getTypeAsValueHandler ( config , propertyType ) ; if ( asValueHandler != null ) { String sValue = parent . getStringProperty ( currentKey ) ; if ( sValue . matches ( asValueHandler . getRegex ( ) ) ) { parent . getProperties ( ) . put ( currentKey , asValueHandler . getValue ( process , parent , currentKey , parent . getProperty ( currentKey ) ) ) ; } else { throw new BuildException ( "Invalid {0} value \"{1}\" for {2}.{3}. Must in be in \"{4}\" format, e.g. \"{5}\"" , propertyType . getSimpleName ( ) , sValue , parent . getMainObject ( ) . getClass ( ) . getSimpleName ( ) , currentKey , asValueHandler . getRegex ( ) , asValueHandler . getInputValueSample ( ) ) ; } } } } catch ( Exception e ) { throw new BuildException ( e , "Unable to process property {0}.{1} : {2}" , parent . getMainObject ( ) . getClass ( ) . getSimpleName ( ) , currentKey , e . getMessage ( ) ) ; } validateProperty ( handler , config , process , parent , currentKey ) ; handler . handle ( config , process , parent , currentKey ) ; parent . getConsumedKeys ( ) . add ( currentKey ) ; for ( String key : handler . getConsumedKeys ( ) ) { parent . getConsumedKeys ( ) . add ( key ) ; } } } @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private static void validateProperty ( IPropertyHandler handler , BuilderConfig config , BuildProcess result , Node parent , String currentKey ) throws BuildException { if ( handler instanceof IAllowedValues ) { String value = parent . getStringProperty ( currentKey ) ; IAllowedValues list = ( IAllowedValues ) handler ; if ( ! list . getAllowedValues ( ) . contains ( value ) ) { throw new InvalidPropertyValueException ( parent . getKey ( ) , currentKey , value , list . getAllowedValues ( ) ) ; } } if ( handler instanceof IAllowedPropertyFormat ) { IAllowedPropertyFormat format = ( IAllowedPropertyFormat ) handler ; for ( String consumedKey : handler . getConsumedKeys ( ) ) { if ( parent . containsProperty ( consumedKey ) ) { String value = parent . getStringProperty ( consumedKey ) ; if ( ! value . matches ( format . getRegexPattern ( currentKey ) ) ) { throw new InvalidPropertyValueException ( parent . getKey ( ) , currentKey , value , format . getRegexPattern ( currentKey ) , format . getValidSample ( currentKey ) ) ; } } } } if ( handler instanceof IAllowedPropertyCombinations ) { IAllowedPropertyCombinations combination = ( IAllowedPropertyCombinations ) handler ; if ( ! combination . getAllowedCombinations ( ) . isValid ( parent . getProperties ( ) . keySet ( ) ) ) { throw new BuildException ( "Invalid combination of properties. Valid are: " + combination . getAllowedCombinations ( ) ) ; } } if ( handler instanceof IPropertyList ) { IPropertyList listHandler = ( IPropertyList ) handler ; for ( String consumedKey : handler . getConsumedKeys ( ) ) { if ( parent . containsProperty ( consumedKey ) && listHandler . isList ( consumedKey ) ) { List < Object > values = ( List < Object > ) parent . getProperties ( ) . get ( consumedKey ) ; Values valueList = null ; for ( ValueListDefinition vlDef : listHandler . getValueListDefinitions ( consumedKey ) ) { if ( vlDef . isExactMatch ( values ) ) { valueList = new Values ( vlDef ) ; vlDef . validateValues ( values , result , parent , valueList ) ; if ( ! valueList . isValid ( ) ) { throw new BuildException ( valueList . getErrors ( ) ) ; } break ; } } if ( valueList == null ) { throw new BuildException ( String . format ( "Values '%s' did not match to any defined value list definition for property '%s'" , values , consumedKey ) ) ; } else { parent . getProperties ( ) . put ( consumedKey , valueList ) ; } } } } } private static void validate ( BuilderConfig config , BuildProcess process , Node parent , String currentKey , Map < String , Object > currentProperties , Class < ? > classType ) throws InvalidParentTypeException , MissingRequiredPropertyException , MissingRequiredTypeException { if ( parent != null && ! TypeDefinition . isParentAllowed ( parent , config . getTypeDefinitions ( classType ) ) ) { throw new InvalidParentTypeException ( classType , parent . getMainObject ( ) . getClass ( ) , TypeDefinition . getAllowedParents ( config , classType ) ) ; } for ( String requiredKey : TypeDefinition . getRequiredKeys ( config , classType ) ) { if ( ! currentProperties . containsKey ( requiredKey ) ) { throw new MissingRequiredPropertyException ( currentKey , requiredKey , currentProperties ) ; } } for ( Class < ? > requiredType : TypeDefinition . getRequiredTypes ( config , classType ) ) { boolean found = false ; keySearch : for ( String key : currentProperties . keySet ( ) ) { if ( currentProperties . get ( key ) instanceof Map ) { Class < ? > type = BuilderUtils . getClassFromAlias ( process , key , null ) ; if ( type != null && requiredType . isAssignableFrom ( type ) ) { found = true ; break keySearch ; } } } if ( ! found ) { throw new MissingRequiredTypeException ( currentKey , requiredType , currentProperties ) ; } } } private static void handleDefaults ( BuilderConfig config , BuildProcess result , Node parent , String currentKey , Map < String , Object > currentProperties , Class < ? > classType ) { Map < String , Object > defaults = TypeDefinition . getDefaults ( config , classType ) ; for ( String key : defaults . keySet ( ) ) { if ( ! currentProperties . containsKey ( key ) ) { currentProperties . put ( key , defaults . get ( key ) ) ; } } } } 
=======
class AttributePattern extends Pattern { private final NameClass nameClass ; private final Pattern p ; private final Locator loc ; AttributePattern ( NameClass nameClass , Pattern value , Locator loc ) { super ( false , EMPTY_CONTENT_TYPE , combineHashCode ( ATTRIBUTE_HASH_CODE , nameClass . hashCode ( ) , value . hashCode ( ) ) ) ; this . nameClass = nameClass ; this . p = value ; this . loc = loc ; } Pattern expand ( SchemaPatternBuilder b ) { Pattern ep = p . expand ( b ) ; if ( ep != p ) return b . makeAttribute ( nameClass , ep , loc ) ; else return this ; } void checkRestrictions ( int context , DuplicateAttributeDetector dad , Alphabet alpha ) throws RestrictionViolationException { switch ( context ) { case START_CONTEXT : throw new RestrictionViolationException ( "start_contains_attribute" ) ; case ELEMENT_CONTEXT : if ( nameClass . isOpen ( ) ) throw new RestrictionViolationException ( "open_name_class_not_repeated" ) ; break ; case ELEMENT_REPEAT_GROUP_CONTEXT : throw new RestrictionViolationException ( "one_or_more_contains_group_contains_attribute" ) ; case ELEMENT_REPEAT_INTERLEAVE_CONTEXT : throw new RestrictionViolationException ( "one_or_more_contains_interleave_contains_attribute" ) ; case LIST_CONTEXT : throw new RestrictionViolationException ( "list_contains_attribute" ) ; case ATTRIBUTE_CONTEXT : throw new RestrictionViolationException ( "attribute_contains_attribute" ) ; case DATA_EXCEPT_CONTEXT : throw new RestrictionViolationException ( "data_except_contains_attribute" ) ; } dad . addAttribute ( nameClass ) ; try { p . checkRestrictions ( ATTRIBUTE_CONTEXT , null , null ) ; } catch ( RestrictionViolationException e ) { e . maybeSetLocator ( loc ) ; throw e ; } } boolean samePattern ( Pattern other ) { if ( ! ( other instanceof AttributePattern ) ) return false ; AttributePattern ap = ( AttributePattern ) other ; return nameClass . equals ( ap . nameClass ) && p == ap . p ; } void checkRecursion ( int depth ) throws SAXException { p . checkRecursion ( depth ) ; } < T > T apply ( PatternFunction < T > f ) { return f . caseAttribute ( this ) ; } Pattern getContent ( ) { return p ; } NameClass getNameClass ( ) { return nameClass ; } Locator getLocator ( ) { return loc ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
