<<<<<<< HEAD
public class ArticleActivityMeter extends JComponent { private static final int NUM_DAYS = 7 ; private static final int NUM_BLOCKS_PER_DAY = 6 ; private static final int BLOCK_SIZE = 4 ; private static final int BLOCK_GAP = 1 ; private static final int OVER_SIZE = 4 ; private static final int BORDER_WIDTH = 1 ; private static final Color ARTICLE_READ_COLOR = new Color ( 84 , 194 , 84 ) ; private static final Color ARTICLE_UNREAD_COLOR = new Color ( 194 , 84 , 84 ) ; private static final Color NO_ARTICLE_COLOR = new Color ( 194 , 194 , 194 ) ; private static final Color ARTICLE_HOVER_HIGHLIGHT = new Color ( 230 , 230 , 230 ) ; private static final boolean SHOW_NEWEST_ON_RIGHT = true ; private static final Dimension MY_SIZE = new Dimension ( NUM_DAYS * BLOCK_SIZE + BORDER_WIDTH * 2 , NUM_BLOCKS_PER_DAY * BLOCK_SIZE + OVER_SIZE + BORDER_WIDTH * 2 ) ; private int myHoverDay = - 1 ; private UnreadStats myUnreadStats ; public ArticleActivityMeter ( ) { setFocusable ( false ) ; } protected void processMouseEvent ( MouseEvent e ) { super . processMouseEvent ( e ) ; switch ( e . getID ( ) ) { case MouseEvent . MOUSE_EXITED : setHoverDay ( - 1 ) ; break ; case MouseEvent . MOUSE_PRESSED : case MouseEvent . MOUSE_RELEASED : case MouseEvent . MOUSE_CLICKED : UifUtilities . delegateEventToParent ( this , e ) ; break ; default : break ; } } protected void processMouseMotionEvent ( MouseEvent e ) { super . processMouseMotionEvent ( e ) ; if ( e . getID ( ) == MouseEvent . MOUSE_MOVED ) { setHoverDay ( pointToDay ( e . getPoint ( ) ) ) ; } else if ( e . getID ( ) == MouseEvent . MOUSE_DRAGGED ) { UifUtilities . delegateEventToParent ( this , e ) ; } } public void init ( UnreadStats stats ) { myUnreadStats = stats ; setForeground ( Color . DARK_GRAY ) ; setSize ( MY_SIZE ) ; setPreferredSize ( MY_SIZE ) ; initToolTip ( ) ; } public void setHoverDay ( int day ) { if ( day != myHoverDay ) { myHoverDay = day ; initToolTip ( ) ; repaint ( ) ; } } protected void initToolTip ( ) { String toolTip ; if ( myHoverDay < 0 ) { toolTip = "" ; } else { Object [ ] args = new Object [ 3 ] ; String dayString , message ; UnreadStats . DayCount dayCount = myUnreadStats . getDayCount ( myHoverDay ) ; if ( myHoverDay < 2 ) { if ( myHoverDay == 0 ) { dayString = Strings . message ( "activitymeter.today" ) ; } else { dayString = Strings . message ( "activitymeter.yesterday" ) ; } } else { Calendar cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , - 1 * ( myHoverDay ) ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( "'" + Strings . message ( "activitymeter.last" ) + " 'EEEE" ) ; dayString = dateFormat . format ( cal . getTime ( ) ) ; } int total = dayCount . getTotal ( ) ; int read = dayCount . getRead ( ) ; int unread = dayCount . getUnread ( ) ; args [ 0 ] = dayString ; args [ 1 ] = new Integer ( total ) ; args [ 2 ] = new Integer ( unread ) ; if ( total == 0 ) { message = Strings . message ( "activitymeter.no.articles" ) ; } else if ( total == 1 ) { message = ( unread == 1 ) ? Strings . message ( "activitymeter.1.article.unread" ) : Strings . message ( "activitymeter.1.article" ) ; } else if ( read == 0 ) { message = Strings . message ( "activitymeter.n.articles.all.unread" ) ; } else if ( unread == 0 ) { message = Strings . message ( "activitymeter.n.articles" ) ; } else { message = Strings . message ( "activitymeter.n.articles.m.unread" ) ; } toolTip = MessageFormat . format ( message , args ) ; } setToolTipText ( toolTip ) ; } protected void paintComponent ( Graphics g ) { if ( myHoverDay >= 0 ) { int x = dayToX ( myHoverDay ) - BLOCK_GAP ; g . setColor ( ARTICLE_HOVER_HIGHLIGHT ) ; g . fillRect ( x , 0 , BLOCK_SIZE + BLOCK_GAP , BLOCK_SIZE * NUM_BLOCKS_PER_DAY + OVER_SIZE + BORDER_WIDTH * 2 ) ; } for ( int day = 0 ; day < NUM_DAYS ; ++ day ) { UnreadStats . DayCount dc = myUnreadStats . getDayCount ( day ) ; int read , unread ; unread = dc . getUnread ( ) ; read = unread + dc . getRead ( ) ; int bx ; if ( SHOW_NEWEST_ON_RIGHT ) { bx = dayToX ( day ) ; } else { bx = day * BLOCK_SIZE + BORDER_WIDTH ; } int by = OVER_SIZE + ( NUM_BLOCKS_PER_DAY * BLOCK_SIZE ) + BORDER_WIDTH ; for ( int j = 0 ; j < NUM_BLOCKS_PER_DAY + 1 ; ++ j ) { Color col ; if ( j < unread ) { col = ARTICLE_UNREAD_COLOR ; } else if ( j < read ) { col = ARTICLE_READ_COLOR ; } else { col = NO_ARTICLE_COLOR ; } if ( day == myHoverDay ) col = col . darker ( ) ; g . setColor ( col ) ; if ( j < NUM_BLOCKS_PER_DAY ) { by -= BLOCK_SIZE ; g . fillRect ( bx , by , BLOCK_SIZE - BLOCK_GAP , BLOCK_SIZE - BLOCK_GAP ) ; } else { by -= BLOCK_GAP + 1 ; g . fillRect ( bx , by , BLOCK_SIZE - BLOCK_GAP , 1 ) ; by -- ; g . fillRect ( bx + 1 , by , BLOCK_SIZE - BLOCK_GAP - 1 , 1 ) ; by -- ; g . fillRect ( bx + 2 , by , BLOCK_SIZE - BLOCK_GAP - 2 , 1 ) ; } } } } static int dayToX ( int day ) { int x ; if ( SHOW_NEWEST_ON_RIGHT ) { x = MY_SIZE . width - ( ( day + 1 ) * BLOCK_SIZE ) - BORDER_WIDTH ; } else { x = day * BLOCK_SIZE + BORDER_WIDTH ; } return x ; } static int pointToDay ( Point p ) { int n ; if ( SHOW_NEWEST_ON_RIGHT ) { n = ( MY_SIZE . width - BORDER_WIDTH - p . x ) / BLOCK_SIZE ; } else { n = ( p . x - BORDER_WIDTH ) / BLOCK_SIZE ; } n = Math . min ( n , NUM_DAYS - 1 ) ; n = Math . max ( n , 0 ) ; return n ; } } 
=======
class TextPattern extends Pattern { TextPattern ( ) { super ( true , MIXED_CONTENT_TYPE , TEXT_HASH_CODE ) ; } boolean samePattern ( Pattern other ) { return other instanceof TextPattern ; } < T > T apply ( PatternFunction < T > f ) { return f . caseText ( this ) ; } void checkRestrictions ( int context , DuplicateAttributeDetector dad , Alphabet alpha ) throws RestrictionViolationException { switch ( context ) { case DATA_EXCEPT_CONTEXT : throw new RestrictionViolationException ( "data_except_contains_text" ) ; case START_CONTEXT : throw new RestrictionViolationException ( "start_contains_text" ) ; case LIST_CONTEXT : throw new RestrictionViolationException ( "list_contains_text" ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
