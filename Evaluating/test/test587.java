public class HTMLContentProvider implements ITreeContentProvider , IOutlineContentProviderExtension { private static final Object [ ] NO_OBJECTS = new Object [ 0 ] ; private IPathResolver resolver ; private Map < String , Object [ ] > cache = new WeakHashMap < String , Object [ ] > ( ) ; private HashMap < String , IPropertyChangeListener > listeners = new HashMap < String , IPropertyChangeListener > ( ) ; private JSContentProvider provider ; public HTMLContentProvider ( ) { } public Object [ ] getChildren ( Object parentElement ) { Object [ ] result = NO_OBJECTS ; if ( parentElement instanceof HTMLElementNode ) { HTMLElementNode item = ( HTMLElementNode ) parentElement ; if ( item . getName ( ) . equals ( "script" ) ) { String attribute = item . getAttribute ( "src" ) ; if ( attribute . length ( ) > 0 ) { return getExternalScriptChildren ( attribute , item ) ; } } result = UnifiedOutlineProvider . getInstance ( ) . getChildren ( item , HTMLMimeType . MimeType ) ; } return result ; } private Object [ ] getExternalScriptChildren ( final String attribute , IResolvableItem parent ) { Object [ ] cached = cache . get ( attribute ) ; if ( cached != null ) { return cached ; } if ( resolver == null ) { return NO_OBJECTS ; } try { IPropertyChangeListener propertyChangeListener = listeners . get ( attribute ) ; if ( propertyChangeListener == null ) { propertyChangeListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { cache . remove ( attribute ) ; } } ; resolver . addChangeListener ( attribute , propertyChangeListener ) ; } listeners . put ( attribute , propertyChangeListener ) ; String source = resolver . resolveSource ( attribute ) ; IEditorInput input = resolver . resolveEditorInput ( attribute ) ; if ( source == null ) { return new Object [ ] { new WarningItem ( StringUtils . format ( HTMLContentProviderMessages . HTMLContentProvider_NOT_RESOLVABLE , attribute ) ) } ; } JSParser ps ; try { ps = new JSParser ( ) ; IParseState pState = ps . createParseState ( null ) ; pState . setEditState ( source , source , 0 , 0 ) ; IParseNode parse = ps . parse ( pState ) ; provider = new JSContentProvider ( ) ; Object [ ] elements = provider . getElements ( parse . getChildren ( ) ) ; for ( int a = 0 ; a < elements . length ; a ++ ) { if ( elements [ a ] instanceof JSOutlineItem ) { JSOutlineItem item = ( JSOutlineItem ) elements [ a ] ; item . setResolveInformation ( input ) ; item . setParent ( parent ) ; } } cache . put ( attribute , elements ) ; return elements ; } catch ( ParserInitializationException e ) { IdeLog . logError ( HTMLPlugin . getDefault ( ) , e . getMessage ( ) ) ; return NO_OBJECTS ; } catch ( LexerException e ) { IdeLog . logError ( HTMLPlugin . getDefault ( ) , e . getMessage ( ) ) ; return NO_OBJECTS ; } } catch ( Exception e ) { IdeLog . logError ( HTMLPlugin . getDefault ( ) , e . getMessage ( ) ) ; WarningItem warningItem = new WarningItem ( e . getMessage ( ) ) ; warningItem . setError ( true ) ; return new Object [ ] { warningItem } ; } } public Object getParent ( Object element ) { Object result = null ; if ( element instanceof HTMLElementNode ) { HTMLElementNode item = ( HTMLElementNode ) element ; result = item . getParent ( ) ; } return result ; } public boolean hasChildren ( Object element ) { boolean result = false ; if ( element instanceof HTMLElementNode ) { HTMLElementNode elementNode = ( ( HTMLElementNode ) element ) ; if ( isScriptWithSrc ( elementNode ) ) { if ( resolver != null ) { elementNode . setResolveInformation ( resolver . resolveEditorInput ( elementNode . getAttribute ( "src" ) ) ) ; return true ; } } result = elementNode . hasChildren ( ) ; } return result ; } private boolean isScriptWithSrc ( HTMLElementNode elementNode ) { if ( elementNode . getName ( ) . equals ( "script" ) ) { String attribute = elementNode . getAttribute ( "src" ) ; if ( attribute . length ( ) > 0 ) { return true ; } } return false ; } public Object [ ] getElements ( Object inputElement ) { List < Object > elements = new ArrayList < Object > ( ) ; if ( inputElement instanceof HTMLDocumentNode ) { this . processNode ( elements , ( IParseNode ) inputElement ) ; } return elements . toArray ( new Object [ elements . size ( ) ] ) ; } public void dispose ( ) { } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { if ( newInput == null ) { disconnectListeners ( ) ; } cache . clear ( ) ; } private void disconnectListeners ( ) { if ( resolver != null ) { for ( Iterator < String > iterator = listeners . keySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { String key = iterator . next ( ) ; IPropertyChangeListener object = listeners . get ( key ) ; resolver . removeChangeListener ( key , object ) ; } listeners . clear ( ) ; } } private void processNode ( List < Object > elements , IParseNode node ) { switch ( node . getTypeIndex ( ) ) { case HTMLParseNodeTypes . DOCUMENT : for ( int i = 0 ; i < node . getChildCount ( ) ; i ++ ) { this . processNode ( elements , node . getChild ( i ) ) ; } break ; case HTMLParseNodeTypes . ELEMENT : elements . add ( node ) ; break ; default : if ( ! node . getLanguage ( ) . equals ( HTMLMimeType . MimeType ) ) { Object [ ] list = UnifiedOutlineProvider . getInstance ( ) . getElements ( node ) ; if ( list != null ) { for ( int i = 0 ; i < list . length ; i ++ ) { elements . add ( list [ i ] ) ; } } } break ; } } public void setPathResolver ( IPathResolver resolver ) { if ( this . resolver != null ) { if ( ! this . resolver . equals ( resolver ) ) { disconnectListeners ( ) ; cache . clear ( ) ; } } this . resolver = resolver ; } public void pageActivated ( IPathResolver _resolver ) { setPathResolver ( resolver ) ; } public void pageClosed ( IPathResolver _resolver ) { disconnectListeners ( ) ; cache . clear ( ) ; } } 