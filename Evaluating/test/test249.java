<<<<<<< HEAD
public class TemplateFieldEditor extends FieldEditor { public static final int VALIDATE_ON_KEY_STROKE = 0 ; public static final int VALIDATE_ON_FOCUS_LOST = 1 ; public static int UNLIMITED = - 1 ; private boolean isValid ; protected String oldValue ; Text textField ; @ SuppressWarnings ( "unused" ) private int widthInChars = UNLIMITED ; private int textLimit = UNLIMITED ; private String errorMessage ; private boolean emptyStringAllowed = true ; private int validateStrategy = VALIDATE_ON_KEY_STROKE ; protected TemplateFieldEditor ( ) { } public TemplateFieldEditor ( String name , String labelText , int width , int strategy , Composite parent ) { init ( name , labelText ) ; widthInChars = width ; setValidateStrategy ( strategy ) ; isValid = false ; errorMessage = JFaceResources . getString ( "StringFieldEditor.errorMessage" ) ; createControl ( parent ) ; } public TemplateFieldEditor ( String name , String labelText , int width , Composite parent ) { this ( name , labelText , width , VALIDATE_ON_KEY_STROKE , parent ) ; } public TemplateFieldEditor ( String name , String labelText , Composite parent ) { this ( name , labelText , UNLIMITED , parent ) ; } protected void adjustForNumColumns ( int numColumns ) { GridData gd = ( GridData ) textField . getLayoutData ( ) ; gd . horizontalSpan = numColumns - 1 ; gd . grabExcessHorizontalSpace = gd . horizontalSpan == 1 ; } protected boolean checkState ( ) { boolean result = false ; if ( emptyStringAllowed ) { result = true ; } if ( textField == null ) { result = false ; } String txt = textField . getText ( ) ; result = ( txt . trim ( ) . length ( ) > 0 ) || emptyStringAllowed ; result = result && doCheckState ( ) ; if ( result ) { clearErrorMessage ( ) ; } else { showErrorMessage ( errorMessage ) ; } return result ; } protected boolean doCheckState ( ) { return true ; } protected void doFillIntoGrid ( Composite parent , int numColumns ) { getLabelControl ( parent ) ; textField = getTextControl ( parent ) ; GridData gd = new GridData ( ) ; gd . horizontalSpan = numColumns - 1 ; GC gc = new GC ( textField ) ; try { Point textExtent = gc . textExtent ( "X" ) ; gd . heightHint = textExtent . y * 3 ; gd . horizontalAlignment = GridData . FILL ; gd . grabExcessHorizontalSpace = true ; } finally { gc . dispose ( ) ; } textField . setLayoutData ( gd ) ; } protected void doLoad ( ) { if ( textField != null ) { String value = getPreferenceStore ( ) . getString ( getPreferenceName ( ) ) ; textField . setText ( value ) ; oldValue = value ; } } protected void doLoadDefault ( ) { if ( textField != null ) { String value = getPreferenceStore ( ) . getDefaultString ( getPreferenceName ( ) ) ; textField . setText ( value ) ; } valueChanged ( ) ; } protected void doStore ( ) { getPreferenceStore ( ) . setValue ( getPreferenceName ( ) , textField . getText ( ) ) ; } public String getErrorMessage ( ) { return errorMessage ; } public int getNumberOfControls ( ) { return 2 ; } public String getStringValue ( ) { if ( textField != null ) { return textField . getText ( ) ; } return getPreferenceStore ( ) . getString ( getPreferenceName ( ) ) ; } protected Text getTextControl ( ) { return textField ; } public Text getTextControl ( Composite parent ) { if ( textField == null ) { textField = new Text ( parent , SWT . MULTI | SWT . LEAD | SWT . BORDER | SWT . WRAP ) ; textField . setFont ( parent . getFont ( ) ) ; switch ( validateStrategy ) { case VALIDATE_ON_KEY_STROKE : textField . addKeyListener ( new KeyAdapter ( ) { public void keyReleased ( KeyEvent e ) { valueChanged ( ) ; } } ) ; textField . addFocusListener ( new FocusAdapter ( ) { public void focusLost ( FocusEvent e ) { valueChanged ( ) ; } } ) ; break ; case VALIDATE_ON_FOCUS_LOST : textField . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { clearErrorMessage ( ) ; } } ) ; textField . addFocusListener ( new FocusAdapter ( ) { public void focusGained ( FocusEvent e ) { refreshValidState ( ) ; } public void focusLost ( FocusEvent e ) { valueChanged ( ) ; clearErrorMessage ( ) ; } } ) ; break ; default : Assert . isTrue ( false , "Unknown validate strategy" ) ; } textField . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { textField = null ; } } ) ; if ( textLimit > 0 ) { textField . setTextLimit ( textLimit ) ; } } else { checkParent ( textField , parent ) ; } return textField ; } public boolean isEmptyStringAllowed ( ) { return emptyStringAllowed ; } public boolean isValid ( ) { return isValid ; } protected void refreshValidState ( ) { isValid = checkState ( ) ; } public void setEmptyStringAllowed ( boolean b ) { emptyStringAllowed = b ; } public void setErrorMessage ( String message ) { errorMessage = message ; } public void setFocus ( ) { if ( textField != null ) { textField . setFocus ( ) ; } } public void setStringValue ( String value ) { if ( textField != null ) { if ( value == null ) { value = "" ; } oldValue = textField . getText ( ) ; if ( ! oldValue . equals ( value ) ) { textField . setText ( value ) ; valueChanged ( ) ; } } } public void setTextLimit ( int limit ) { textLimit = limit ; if ( textField != null ) { textField . setTextLimit ( limit ) ; } } public void setValidateStrategy ( int value ) { Assert . isTrue ( value == VALIDATE_ON_FOCUS_LOST || value == VALIDATE_ON_KEY_STROKE ) ; validateStrategy = value ; } public void showErrorMessage ( ) { showErrorMessage ( errorMessage ) ; } protected void valueChanged ( ) { setPresentsDefaultValue ( false ) ; boolean oldState = isValid ; refreshValidState ( ) ; if ( isValid != oldState ) { fireStateChanged ( IS_VALID , oldState , isValid ) ; } String newValue = textField . getText ( ) ; if ( ! newValue . equals ( oldValue ) ) { fireValueChanged ( VALUE , oldValue , newValue ) ; oldValue = newValue ; } } public void setEnabled ( boolean enabled , Composite parent ) { super . setEnabled ( enabled , parent ) ; getTextControl ( parent ) . setEnabled ( enabled ) ; } } 
=======
public class RewindableReader extends Reader implements Rewindable { static class Block { Block next ; final char [ ] buf ; int used = 0 ; static final int MIN_SIZE = 1024 ; Block ( int minSize ) { buf = new char [ Math . max ( MIN_SIZE , minSize ) ] ; } Block ( ) { this ( 0 ) ; } void append ( char b ) { buf [ used ++ ] = b ; } void append ( char [ ] b , int off , int len ) { System . arraycopy ( b , off , buf , used , len ) ; used += len ; } } private Block head ; private int curBlockAvail ; private Block curBlock ; private int curBlockPos ; private Block lastBlock ; private boolean saving = true ; private final Reader in ; private boolean pretendClosed = false ; private boolean eof ; public RewindableReader ( Reader in ) { if ( in == null ) throw new NullPointerException ( ) ; this . in = in ; } public void close ( ) throws IOException { if ( saving ) { curBlockAvail = 0 ; curBlock = null ; pretendClosed = true ; } else { head = null ; curBlock = null ; lastBlock = null ; saving = false ; curBlockAvail = 0 ; in . close ( ) ; } } public void rewind ( ) { if ( ! saving ) throw new IllegalStateException ( "rewind() after willNotRewind()" ) ; pretendClosed = false ; if ( head == null ) return ; curBlock = head ; curBlockPos = 0 ; curBlockAvail = curBlock . used ; } public boolean canRewind ( ) { return saving ; } public void willNotRewind ( ) { saving = false ; head = null ; lastBlock = null ; if ( pretendClosed ) { pretendClosed = false ; try { in . close ( ) ; } catch ( IOException e ) { } } } public int read ( ) throws IOException { if ( curBlockAvail > 0 ) { int c = curBlock . buf [ curBlockPos ++ ] & 0xFF ; -- curBlockAvail ; if ( curBlockAvail == 0 ) { curBlock = curBlock . next ; if ( curBlock != null ) { curBlockPos = 0 ; curBlockAvail = curBlock . used ; } } return c ; } int c = in . read ( ) ; if ( saving && c != - 1 ) { if ( lastBlock == null ) lastBlock = head = new Block ( ) ; else if ( lastBlock . used == lastBlock . buf . length ) lastBlock = lastBlock . next = new Block ( ) ; lastBlock . append ( ( char ) c ) ; } return c ; } public int read ( char b [ ] , int off , int len ) throws IOException { if ( curBlockAvail == 0 && ! saving ) return in . read ( b , off , len ) ; if ( b == null ) throw new NullPointerException ( ) ; if ( len < 0 ) throw new IndexOutOfBoundsException ( ) ; int nRead = 0 ; if ( curBlockAvail != 0 ) { for ( ; ; ) { if ( len == 0 ) return nRead ; b [ off ++ ] = curBlock . buf [ curBlockPos ++ ] ; -- len ; nRead ++ ; -- curBlockAvail ; if ( curBlockAvail == 0 ) { curBlock = curBlock . next ; if ( curBlock == null ) break ; curBlockAvail = curBlock . used ; curBlockPos = 0 ; } } } if ( len == 0 ) return nRead ; if ( eof ) return nRead > 0 ? nRead : - 1 ; try { int n = in . read ( b , off , len ) ; if ( n < 0 ) { eof = true ; return nRead > 0 ? nRead : - 1 ; } nRead += n ; if ( saving ) { if ( lastBlock == null ) lastBlock = head = new Block ( n ) ; else if ( lastBlock . buf . length - lastBlock . used < n ) { if ( lastBlock . used != lastBlock . buf . length ) { int free = lastBlock . buf . length - lastBlock . used ; lastBlock . append ( b , off , free ) ; off += free ; n -= free ; } lastBlock = lastBlock . next = new Block ( n ) ; } lastBlock . append ( b , off , n ) ; } } catch ( IOException e ) { eof = true ; if ( nRead == 0 ) throw e ; } return nRead ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
