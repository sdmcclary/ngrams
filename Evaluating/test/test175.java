<<<<<<< HEAD
public class ruby extends AbstractMaxRubyObject { private String scriptFilePath ; private File scriptFile ; private Atom [ ] scriptFileArgs ; private int evalOutlet = - 1 ; private boolean autowatch = false ; private FileWatcher fileWatcher ; private String [ ] symbolsTo ; private SymbolConversionOption [ ] symbolConversionOptions ; public ruby ( Atom [ ] args ) { super ( ) ; declareAttribute ( "evalout" , "getevalout" , "evalout" ) ; declareAttribute ( "evaloutlet" , "getevalout" , "evalout" ) ; declareAttribute ( "file" , "getfile" , "file" ) ; declareAttribute ( "scriptfile" , "getfile" , "file" ) ; declareAttribute ( "autowatch" , "getautowatch" , "autowatch" ) ; declareAttribute ( "symbols_to" , "getsymbols_to" , "symbols_to" ) ; int inlets = 1 ; if ( args . length > 0 && args [ 0 ] . isInt ( ) && args [ 0 ] . getInt ( ) > 1 ) { inlets = args [ 0 ] . getInt ( ) ; } int outlets = 1 ; if ( args . length > 1 && args [ 1 ] . isInt ( ) && args [ 1 ] . getInt ( ) > 1 ) { outlets = args [ 1 ] . getInt ( ) ; } declareIO ( inlets , outlets ) ; createInfoOutlet ( false ) ; symbolConversionOptions = new SymbolConversionOption [ inlets ] ; for ( int i = 0 ; i < symbolConversionOptions . length ; i ++ ) { symbolConversionOptions [ i ] = SymbolConversionOption . DEFAULT ; } } @ Override protected Executable getInitializer ( ) { return new RubyInitializer ( ) ; } protected class RubyInitializer extends DefaultRubyInitializer { @ Override public void execute ( ) { super . execute ( ) ; if ( scriptFile != null ) { initFile ( ) ; } } } @ Override public void notifyDeleted ( ) { stopFileWatcher ( ) ; super . notifyDeleted ( ) ; } public int getevalout ( ) { return evalOutlet ; } public void evalout ( int evalout ) { if ( evalout >= getNumOutlets ( ) ) { err ( "Invalid evalout " + evalout ) ; } else { this . evalOutlet = evalout ; } } public String getfile ( ) { if ( scriptFile != null ) { return scriptFile . getAbsolutePath ( ) ; } else { return null ; } } public void file ( Atom [ ] args ) { if ( args != null && args . length > 0 ) { scriptFilePath = args [ 0 ] . toString ( ) ; scriptFile = Utils . getFile ( scriptFilePath , getParentPatcher ( ) , true ) ; scriptFileArgs = Atom . removeFirst ( args ) ; if ( scriptFile == null ) { err ( "File not found: " + scriptFilePath ) ; if ( Utils . isPatcherSaved ( getParentPatcher ( ) ) ) { info ( "Send the \"createfile\" message to create the file \"" + getFileToBeCreated ( ) + "\"" ) ; } else { info ( "Save the patcher and send the \"createfile\" message" ) ; info ( "...to create the file \"" + scriptFilePath + "\" in the patcher's folder." ) ; } } } else { scriptFilePath = null ; scriptFile = Utils . getFile ( null ) ; scriptFileArgs = Atom . emptyArray ; } if ( scriptFile != null && initialized ) { initFile ( ) ; } } public boolean getautowatch ( ) { return autowatch ; } public void autowatch ( boolean autowatch ) { this . autowatch = autowatch ; if ( initialized ) { if ( autowatch ) { startFileWatcher ( ) ; } else { stopFileWatcher ( ) ; } } } public String [ ] getsymbols_to ( ) { return symbolsTo ; } public void symbols_to ( String [ ] params ) { for ( int i = 0 ; i < params . length ; i ++ ) { String param = params [ i ] ; if ( i >= symbolConversionOptions . length ) { err ( "More @symbols_to arguments than inlets, ignoring extra arguments." ) ; break ; } SymbolConversionOption option = SymbolConversionOption . fromString ( param ) ; if ( option == null ) { err ( "Invalid @symbols_to argument '" + param + "'. Defaulting to " + SymbolConversionOption . DEFAULT ) ; continue ; } else if ( option == SymbolConversionOption . REMAINING_INLETS ) { if ( i > 0 ) { SymbolConversionOption previousOption = symbolConversionOptions [ i - 1 ] ; for ( int j = i ; j < symbolConversionOptions . length ; j ++ ) { symbolConversionOptions [ j ] = previousOption ; } } if ( i < params . length - 1 ) { err ( "Ignoring @symbols_to argument(s) after the " + SymbolConversionOption . REMAINING_INLETS ) ; } break ; } else { symbolConversionOptions [ i ] = option ; } } symbolsTo = new String [ symbolConversionOptions . length ] ; for ( int i = 0 ; i < symbolsTo . length ; i ++ ) { symbolsTo [ i ] = symbolConversionOptions [ i ] . toString ( ) ; } } private void startFileWatcher ( ) { if ( fileWatcher == null ) { if ( scriptFile != null && autowatch ) { fileWatcher = new FileWatcher ( scriptFile , fileWatcherCallback ) ; fileWatcher . start ( ) ; } } else { fileWatcher . setFile ( scriptFile ) ; fileWatcher . resumeWatching ( ) ; } } private void stopFileWatcher ( ) { if ( fileWatcher != null ) { fileWatcher . pauseWatching ( ) ; } } private Executable fileWatcherCallback = new Executable ( ) { public void execute ( ) { loadFile ( ) ; } } ; private void initFile ( ) { stopFileWatcher ( ) ; loadFile ( ) ; startFileWatcher ( ) ; } private synchronized void loadFile ( ) { info ( "loading script '" + scriptFile + "' on " + new Date ( ) ) ; try { ruby . init ( scriptFile , scriptFileArgs ) ; } catch ( Exception e ) { err ( "Error evaluating script file: " + scriptFile . getPath ( ) ) ; } flush ( ) ; } public void bang ( ) { evalRuby ( "bang()" ) ; } public void list ( Atom [ ] args ) { StringBuilder s = new StringBuilder ( ) ; int inletIdx = getInlet ( ) ; if ( inletIdx <= 9 ) { s . append ( "in" ) . append ( inletIdx ) . append ( "(" ) ; } else { s . append ( "inlet(" ) . append ( inletIdx ) . append ( "," ) ; } joinArgs ( args , s , 0 ) ; s . append ( ")" ) ; evalRuby ( s ) ; } public void symbol ( Atom [ ] args ) { list ( args ) ; } public void call ( Atom [ ] args ) { if ( args . length < 1 || args [ 0 ] == null ) return ; StringBuilder s = new StringBuilder ( ) ; s . append ( args [ 0 ] ) ; s . append ( "(" ) ; joinArgs ( args , s , 1 ) ; s . append ( ")" ) ; evalRuby ( s ) ; } public void send ( Atom [ ] args ) { if ( args . length < 2 || args [ 0 ] == null || args [ 1 ] == null ) return ; StringBuilder s = new StringBuilder ( ) ; s . append ( args [ 0 ] ) . append ( "." ) . append ( args [ 1 ] ) ; s . append ( "(" ) ; joinArgs ( args , s , 2 ) ; s . append ( ")" ) ; evalRuby ( s ) ; } public void eval ( Atom [ ] args ) { StringBuilder input = new StringBuilder ( ) ; for ( Atom arg : args ) { input . append ( Utils . detokenize ( arg . toString ( ) ) ) . append ( " " ) ; } evalRuby ( input . toString ( ) . trim ( ) ) ; } private void joinArgs ( Atom [ ] args , StringBuilder s , int startIndex ) { for ( int i = startIndex ; i < args . length ; i ++ ) { if ( i > startIndex ) { s . append ( "," ) ; } Atom arg = args [ i ] ; if ( arg == null ) { continue ; } String value = arg . toString ( ) ; switch ( symbolConversionOptions [ getInlet ( ) ] ) { case STRING : value = '"' + value . replaceAll ( "\"" , "\\\\\"" ) + '"' ; break ; case SYMBOL : value = ':' + value . replaceAll ( " " , "_" ) ; break ; default : value = Utils . detokenize ( value ) ; } s . append ( value ) ; } } public void text ( String script ) { evalRuby ( script . trim ( ) ) ; } public void textblock ( String name ) { String script = TextBlock . get ( name ) ; if ( script != null ) { evalRuby ( script ) ; } else { error ( "No textblock named '" + name + "'" ) ; } } protected void evalRuby ( CharSequence input ) { try { if ( ruby == null ) { err ( "not initialized yet. Did not evaluate: " + input + ". If you are loadbanging a script, try using a deferlow." ) ; return ; } Object val = ruby . eval ( input , evalOutlet >= 0 ) ; if ( evalOutlet >= 0 ) { if ( val instanceof Atom [ ] ) { outlet ( evalOutlet , ( Atom [ ] ) val ) ; } else { outlet ( evalOutlet , ( Atom ) val ) ; } } } catch ( Exception e ) { err ( "could not evaluate: " + input ) ; } flush ( ) ; } private void flush ( ) { System . out . flush ( ) ; System . err . flush ( ) ; } @ Override protected void dblclick ( ) { try { if ( scriptFile != null ) { String filePath = scriptFile . getAbsolutePath ( ) ; info ( "Attempting to open file '" + filePath + "'" ) ; Process p ; if ( MaxSystem . isOsWindows ( ) ) { p = Runtime . getRuntime ( ) . exec ( new String [ ] { "cmd" , "/c" , "start" , "file editor" , filePath } ) ; } else { p = Runtime . getRuntime ( ) . exec ( new String [ ] { "open" , filePath } ) ; } try { p . waitFor ( ) ; if ( p . exitValue ( ) != 0 ) { err ( Utils . getInputStreamAsString ( p . getErrorStream ( ) ) ) ; } } catch ( InterruptedException e ) { err ( e . getMessage ( ) ) ; } } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public void createfile ( ) { MaxPatcher patcher = getParentPatcher ( ) ; if ( ! Utils . isPatcherSaved ( patcher ) ) { err ( "patcher must be saved before creating a file" ) ; return ; } if ( scriptFilePath == null ) { err ( "@file attribute must be a filename (or relative path)" ) ; return ; } File file = getFileToBeCreated ( ) ; if ( file . exists ( ) ) { err ( "File exists \"" + file + "\"" ) ; return ; } info ( "creating file: " + file , true ) ; try { if ( file . createNewFile ( ) ) { scriptFile = file ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } private File getFileToBeCreated ( ) { MaxPatcher patcher = getParentPatcher ( ) ; if ( patcher != null ) { File folder = new File ( patcher . getPath ( ) ) ; return new File ( folder , scriptFilePath ) ; } return null ; } } 
=======
public class Context extends DtdContext implements MatchContext { protected PrefixMapping prefixMapping = new PrefixMapping ( "xml" , WellKnownNamespaces . XML , null ) ; public Context ( ) { } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { prefixMapping = new PrefixMapping ( prefix , "" . equals ( uri ) ? null : uri , prefixMapping ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { prefixMapping = prefixMapping . getPrevious ( ) ; } public String getBaseUri ( ) { return null ; } protected static final class PrefixMapping { private final String prefix ; private final String namespaceURI ; private final PrefixMapping previous ; PrefixMapping ( String prefix , String namespaceURI , PrefixMapping prev ) { this . prefix = prefix ; this . namespaceURI = namespaceURI ; this . previous = prev ; } PrefixMapping getPrevious ( ) { return previous ; } } public String resolveNamespacePrefix ( String prefix ) { PrefixMapping tem = prefixMapping ; do { if ( tem . prefix . equals ( prefix ) ) return tem . namespaceURI ; tem = tem . previous ; } while ( tem != null ) ; return null ; } public void reset ( ) { prefixMapping = new PrefixMapping ( "xml" , WellKnownNamespaces . XML , null ) ; clearDtdContext ( ) ; } public String getPrefix ( String namespaceURI ) { PrefixMapping tem = prefixMapping ; do { if ( namespaceURI . equals ( tem . namespaceURI ) && tem . namespaceURI == resolveNamespacePrefix ( tem . prefix ) ) return tem . prefix ; tem = tem . previous ; } while ( tem != null ) ; return null ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
