<<<<<<< HEAD
public class IOUtil { public static void closeStream ( InputStream in ) { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ex ) { Log . fatal ( "Cannot close input stream" , ex ) ; } } } public static void closeStream ( OutputStream in ) { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ex ) { Log . fatal ( "Cannot close output stream" , ex ) ; } } } private static final int COPY_BUF_SIZE = 4096 ; private static LinkedList < byte [ ] > buffers = new LinkedList < byte [ ] > ( ) ; private static Random rnd = new Random ( ) ; private static Boolean canMoveOver = null ; public static File getTempName ( File file ) throws IOException { return getTempName ( file . getParentFile ( ) , file . getName ( ) , ".bak" ) ; } public static File getTempName ( File dir , String prefix , String suffix ) throws IOException { int left = 10 ; prefix = Util . isEmpty ( prefix ) ? "" : prefix + "-" ; for ( File f ; ( f = new File ( dir , prefix + Integer . toHexString ( ( ( rnd . nextInt ( ) & 0xffff ) | 0x1000 ) ) + suffix ) ) != null ; left -- ) { if ( left <= 0 ) throw new IOException ( "Cannot make temporary name" ) ; if ( ! f . exists ( ) ) return f ; } assert false ; return null ; } public static File createTempFile ( File f ) throws IOException { File nf = getTempName ( f ) ; if ( ! nf . createNewFile ( ) ) throw new IOException ( "Cannot create " + f ) ; return nf ; } public static File createTempFile ( File dir , String prefix , String suffix ) throws IOException { File f = getTempName ( dir , prefix , suffix ) ; if ( ! f . createNewFile ( ) ) throw new IOException ( "Cannot create " + f ) ; return f ; } public static boolean replace ( File srcFile , File targetFile ) throws IOException { backup ( srcFile , targetFile ) ; return true ; } public static File backup ( File f ) throws IOException { return backup ( f , getTempName ( f ) ) ; } public static File backup ( File f , File tmp ) throws IOException { Log . debug ( "Atomically moving " + f + " to " + tmp ) ; determineMoveOver ( tmp ) ; boolean tmpExists = tmp . exists ( ) ; assert canMoveOver != null ; if ( canMoveOver && ! tmpExists && ! tmp . createNewFile ( ) ) { throw new IOException ( "Cannot create " + tmp ) ; } else if ( canMoveOver && tmpExists ) { ; } else if ( tmpExists && ! tmp . delete ( ) ) { throw new IOException ( "Cannot delete " + tmp ) ; } if ( ! f . renameTo ( tmp ) ) { if ( canMoveOver && ! tmp . delete ( ) ) throw new IOException ( "Cannot delete " + tmp ) ; throw new IOException ( "Cannot replace " + f + " with " + tmp + ( canMoveOver ? "(by move over)" : "" ) ) ; } return tmp ; } private static boolean determineMoveOver ( File tmp ) throws IOException { boolean tmpExists = tmp . exists ( ) ; boolean tmpWasMade = false ; if ( canMoveOver == null ) { File tmp2 = null ; try { if ( ! tmpExists ) { if ( ! tmp . createNewFile ( ) ) throw new IOException ( "Cannot create " + tmp ) ; Log . debug ( "Created" , tmp ) ; tmpWasMade = true ; } tmp2 = getTempName ( tmp . getParentFile ( ) , tmp . getName ( ) , ".tmp" ) ; if ( ! tmp2 . createNewFile ( ) ) throw new IOException ( "Cannot create " + tmp ) ; File origTmp = new File ( tmp . getPath ( ) ) ; canMoveOver = tmp . renameTo ( tmp2 ) ? Boolean . TRUE : Boolean . FALSE ; if ( canMoveOver && ! tmp2 . renameTo ( origTmp ) ) { Log . fatal ( "Cannot move potentially valuable data in " + tmp2 + "back to file " + origTmp ) ; throw new IOException ( "Cannot move " + tmp2 + " to " + origTmp ) ; } } finally { if ( tmp2 . exists ( ) && ! tmp2 . delete ( ) ) Log . fatal ( "Cannot delete temp file" + tmp2 ) ; if ( canMoveOver == null && ! tmpWasMade && tmp . exists ( ) ) Log . debug ( "Attempting delete of " + tmp ) ; if ( canMoveOver == null && tmp . exists ( ) && ! tmp . delete ( ) ) Log . fatal ( "Cannot delete temp file" + tmp ) ; } Log . debug ( "Host OS move over capability is" , canMoveOver ) ; } return tmpWasMade ; } public static int copyStream ( InputStream src , OutputStream dest , long maxLeft ) throws IOException { byte [ ] buffer = IOUtil . getBuf ( ) ; int total = 0 , count = 0 ; do { int maxchunk = ( int ) ( maxLeft > buffer . length ? buffer . length : maxLeft ) ; count = src . read ( buffer , 0 , maxchunk ) ; if ( count > 0 ) { dest . write ( buffer , 0 , count ) ; total += count ; maxLeft -= count ; } } while ( count > - 1 && maxLeft > 0 ) ; IOUtil . freeBuf ( buffer ) ; return total ; } public static int copyStream ( InputStream src , OutputStream dest ) throws IOException { return copyStream ( src , dest , Long . MAX_VALUE ) ; } public static void copyFile ( File src , File dst ) throws IOException { FileInputStream fin = null ; FileOutputStream fout = null ; try { try { fin = new FileInputStream ( src ) ; fout = new FileOutputStream ( dst ) ; copyStream ( fin , fout ) ; } finally { if ( fout != null ) fout . close ( ) ; } } finally { if ( fin != null ) fin . close ( ) ; } } static synchronized void freeBuf ( byte [ ] buf ) { buffers . addLast ( buf ) ; } static synchronized byte [ ] getBuf ( ) { if ( buffers . size ( ) > 0 ) { return buffers . removeFirst ( ) ; } else { return new byte [ COPY_BUF_SIZE ] ; } } public static void delTree ( File f ) throws IOException { delTree ( f , true , null ) ; } public static void delTree ( File f , boolean delRoot ) throws IOException { delTree ( f , delRoot , null ) ; } public static void delTree ( File f , boolean delRoot , FilenameFilter fi ) throws IOException { if ( f . isDirectory ( ) ) { File [ ] entries = f . listFiles ( ) ; for ( int i = 0 ; i < entries . length ; i ++ ) delTree ( entries [ i ] , true , fi ) ; } if ( delRoot && ( fi == null || fi . accept ( f . getParentFile ( ) , f . getName ( ) ) ) && ! f . delete ( ) ) throw new IOException ( "Can't delete " + f ) ; } } 
=======
public class Sax2XMLReaderCreator implements XMLReaderCreator { private final String className ; public Sax2XMLReaderCreator ( ) { this . className = null ; } public Sax2XMLReaderCreator ( String className ) { this . className = className ; } public XMLReader createXMLReader ( ) throws SAXException { XMLReader xr ; if ( className == null ) xr = XMLReaderFactory . createXMLReader ( ) ; else xr = XMLReaderFactory . createXMLReader ( className ) ; xr . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; xr . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , false ) ; try { xr . setFeature ( "http://xml.org/sax/features/validation" , false ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } return xr ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
