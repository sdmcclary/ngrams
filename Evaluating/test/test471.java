<<<<<<< HEAD
public class CustomTwitterClient extends RestfulJSONClient implements TwitterClient { private final TwitterCredentials credentials ; private final RequestExecutor streamingAPIClient ; private final RequestExecutor updateAPIClient ; private final TweetStatistics statistics ; private final TwitterAPILimits limits ; public CustomTwitterClient ( ) throws TwitterClientException { this ( getWhitelisted ( ) ) ; } private static boolean getWhitelisted ( ) throws TwitterClientException { try { return TwitLogic . getConfiguration ( ) . getBoolean ( TwitLogic . TWITTER_WHITELISTED , false ) ; } catch ( PropertyException e ) { throw new TwitterClientException ( e ) ; } } private CustomTwitterClient ( final boolean whitelisted ) throws TwitterClientException { LOGGER . info ( "instantiating " + ( whitelisted ? "whitelisted" : "default" ) + " Twitter client" ) ; statistics = new TweetStatistics ( ) ; TimerTask logStatistics = new TimerTask ( ) { public void run ( ) { statistics . logAndClear ( ) ; } } ; long l ; try { l = TwitLogic . getConfiguration ( ) . getLong ( TwitLogic . LOGGING_STATSINTERVAL , 0 ) ; } catch ( PropertyException e ) { throw new TwitterClientException ( e ) ; } if ( 0 == l ) { LOGGER . warning ( "no value given for stats logging interval. Statistics will not be generated" ) ; } else { Timer timer = new Timer ( "tweet statistics logger" ) ; timer . scheduleAtFixedRate ( logStatistics , l , l ) ; } credentials = new TwitterCredentials ( ) ; limits = whitelisted ? TwitterAPILimits . WHITELIST_LIMITS : TwitterAPILimits . DEFAULT_LIMITS ; streamingAPIClient = new RequestExecutor ( ) { private final HttpClient client = createClient ( true ) ; public HttpResponse execute ( HttpUriRequest request ) throws TwitterClientException { try { return client . execute ( request ) ; } catch ( HttpHostConnectException e ) { LOGGER . warning ( "failed to connect to host: " + e ) ; throw new TwitterConnectionResetException ( e ) ; } catch ( SocketException e ) { LOGGER . warning ( "socket exception: " + e ) ; throw new TwitterConnectionResetException ( e ) ; } catch ( IOException e ) { throw new TwitterClientException ( e ) ; } } } ; updateAPIClient = new DefaultRequestExecutor ( ) ; } public TwitterAPILimits getLimits ( ) { return limits ; } public TweetStatistics getStatistics ( ) { return statistics ; } public void stop ( ) { } public Place fetchPlace ( final String id ) throws TwitterClientException { HttpGet request = new HttpGet ( TwitterAPI . API_PLACES_URL + id + ".json" ) ; JSONObject object = requestJSONObject ( request ) ; try { return new Place ( object ) ; } catch ( TweetParseException e ) { throw new TwitterClientException ( e ) ; } } public void requestUserTimeline ( final User user , final Handler < Tweet > handler ) throws TwitterClientException { StringBuilder sb = new StringBuilder ( TwitterAPI . STATUSES_USER_TIMELINE_URL ) . append ( ".json" ) . append ( "?" ) ; if ( null == user . getId ( ) ) { sb . append ( TwitterAPI . SCREEN_NAME ) . append ( "=" ) . append ( user . getScreenName ( ) ) ; } else { sb . append ( TwitterAPI . USER_ID ) . append ( "=" ) . append ( user . getId ( ) ) ; } HttpGet request = new HttpGet ( sb . toString ( ) ) ; requestStatusArray ( request , handler ) ; } public void processSampleStream ( final Handler < Tweet > addHandler , final Handler < Tweet > deleteHandler ) throws TwitterClientException { HttpGet request = new HttpGet ( TwitterAPI . STREAM_STATUSES_SAMPLE_URL ) ; continuousStream ( request , addHandler , deleteHandler ) ; } private static String [ ] userIds ( final Collection < User > users ) { String [ ] ids = new String [ users . size ( ) ] ; int i = 0 ; for ( User user : users ) { ids [ i ] = "" + user . getId ( ) ; i ++ ; } return ids ; } public void processFilterStream ( final Collection < User > users , final Collection < String > terms , final double [ ] [ ] location , final Handler < Tweet > addHandler , final Handler < Tweet > deleteHandler , final int previousStatusCount ) throws TwitterClientException { if ( 0 == users . size ( ) && 0 == terms . size ( ) ) { throw new TwitterClientException ( "no users to follow and no keywords to track!  Set " + TwitLogic . FOLLOWLIST + " and related properties in your configuration" ) ; } if ( users . size ( ) > limits . getFollowUserIdsLimit ( ) ) { LOGGER . warning ( "the default access level allows up to " + limits . getFollowUserIdsLimit ( ) + " follow userids (you are attempting to use " + users . size ( ) + ")" ) ; } if ( terms . size ( ) > limits . getTrackKeywordsLimit ( ) ) { LOGGER . warning ( "the default access level allows up to " + limits . getTrackKeywordsLimit ( ) + " tracked keywords (you are attempting to use " + terms . size ( ) + ")" ) ; } HttpPost request = new HttpPost ( TwitterAPI . STREAM_STATUSES_FILTER_URL ) ; List < NameValuePair > formParams = new ArrayList < NameValuePair > ( ) ; LOGGER . info ( "following " + users . size ( ) + " users and tracking " + terms . size ( ) + " terms" ) ; if ( 0 < users . size ( ) ) { String followUsers = commaDelimit ( userIds ( users ) ) ; LOGGER . fine ( "following users: " + followUsers ) ; formParams . add ( new BasicNameValuePair ( "follow" , followUsers ) ) ; } if ( 0 < terms . size ( ) ) { String [ ] ta = new String [ terms . size ( ) ] ; terms . toArray ( ta ) ; String trackTerms = commaDelimit ( ta ) ; LOGGER . fine ( "tracking terms: " + trackTerms ) ; formParams . add ( new BasicNameValuePair ( "track" , trackTerms ) ) ; } if ( previousStatusCount > 0 ) { formParams . add ( new BasicNameValuePair ( "count" , "" + previousStatusCount ) ) ; } setEntity ( request , formParams ) ; StatusStreamParser . ExitReason r = continuousStream ( request , addHandler , deleteHandler ) ; LOGGER . fine ( "done processing stream (" + r + ")" ) ; } public void search ( final String term , final GeoDisc geo , final Handler < Tweet > handler ) throws TwitterClientException { if ( null != geo ) { throw new UnsupportedOperationException ( "sorry, geocodes are not supported in the custom Twitter client" ) ; } HttpGet request = new HttpGet ( TwitterAPI . SEARCH_URL + ".json" + "?q=" + term ) ; JSONObject r = requestJSONObject ( request ) ; try { JSONArray results = r . getJSONArray ( "results" ) ; for ( int i = 0 ; i < results . length ( ) ; i ++ ) { Tweet t ; try { t = new Tweet ( results . getJSONObject ( i ) ) ; } catch ( TweetParseException e ) { throw new TwitterClientException ( e ) ; } try { if ( ! handler . isOpen ( ) ) { return ; } handler . handle ( t ) ; } catch ( HandlerException e ) { throw new TwitterClientException ( e ) ; } } } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } } public void updateStatus ( final Tweet tweet ) throws TwitterClientException { HttpPost request = new HttpPost ( TwitterAPI . STATUSES_UPDATE_URL + ".json" ) ; List < NameValuePair > formParams = new ArrayList < NameValuePair > ( ) ; formParams . add ( new BasicNameValuePair ( TwitterAPI . STATUS , tweet . getText ( ) ) ) ; if ( null != tweet . getInReplyToTweet ( ) && null != tweet . getInReplyToTweet ( ) . getId ( ) ) { formParams . add ( new BasicNameValuePair ( TwitterAPI . IN_REPLY_TO_STATUS_ID , tweet . getInReplyToTweet ( ) . getId ( ) ) ) ; } setEntity ( request , formParams ) ; sign ( request ) ; makeSignedJSONRequest ( request , updateAPIClient ) ; } public User findUserInfo ( final String screenName ) throws TwitterClientException { HttpGet request = new HttpGet ( TwitterAPI . USERS_SHOW_URL + ".json" + "?" + TwitterAPI . SCREEN_NAME + "=" + screenName ) ; JSONObject object = requestJSONObject ( request ) ; try { return new User ( object ) ; } catch ( TweetParseException e ) { throw new TwitterClientException ( e ) ; } } public void addToList ( final User user , final String listId , final String userId ) throws TwitterClientException { HttpPost request = new HttpPost ( TwitterAPI . API_LISTS_URL + "/" + user . getScreenName ( ) + "/" + listId + "/members.json" ) ; sign ( request ) ; List < NameValuePair > formParams = new ArrayList < NameValuePair > ( ) ; formParams . add ( new BasicNameValuePair ( TwitterAPI . ID , userId ) ) ; formParams . add ( new BasicNameValuePair ( TwitterAPI . LIST_ID , listId ) ) ; setEntity ( request , formParams ) ; JSONObject json = requestJSONObject ( request ) ; System . out . println ( "response JSON: " + json ) ; } public List < User > getListMembers ( final User user , final String listId ) throws TwitterClientException { List < User > users = new LinkedList < User > ( ) ; String cursor = "-1" ; while ( null != cursor && ! cursor . equals ( "0" ) ) { HttpGet request = new HttpGet ( TwitterAPI . API_LISTS_URL + "/" + user . getScreenName ( ) + "/" + listId + "/members.json" + "?cursor=" + cursor ) ; sign ( request ) ; JSONObject json = requestJSONObject ( request ) ; JSONArray array ; try { array = json . getJSONArray ( TwitterAPI . Field . USERS . toString ( ) ) ; } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } users . addAll ( constructUserList ( array ) ) ; cursor = json . optString ( ( TwitterAPI . UserListField . NEXT_CURSOR . toString ( ) ) ) ; } return users ; } public List < User > getFollowers ( final User user , final int limit ) throws TwitterClientException { if ( - 1 != limit ) { throw new UnsupportedOperationException ( "limit not supported" ) ; } List < User > users = new LinkedList < User > ( ) ; String cursor = "-1" ; while ( null != cursor && ! cursor . equals ( "0" ) ) { HttpGet request = new HttpGet ( TwitterAPI . API_FOLLOWERS_URL + "/" + user . getScreenName ( ) + ".json" + "?cursor=" + cursor ) ; sign ( request ) ; JSONObject json = requestJSONObject ( request ) ; System . out . println ( json ) ; JSONArray array ; try { array = json . getJSONArray ( TwitterAPI . Field . IDS . toString ( ) ) ; } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } users . addAll ( constructUserListFromIDs ( array ) ) ; cursor = json . optString ( ( TwitterAPI . UserListField . NEXT_CURSOR . toString ( ) ) ) ; } return users ; } public List < User > getFollowees ( final User user , final int limit ) throws TwitterClientException { if ( - 1 != limit ) { throw new UnsupportedOperationException ( "limit not supported" ) ; } List < User > users = new LinkedList < User > ( ) ; String cursor = "-1" ; while ( null != cursor && ! cursor . equals ( "0" ) ) { HttpGet request = new HttpGet ( TwitterAPI . API_FRIENDS_URL + "/" + user . getScreenName ( ) + ".json" + "?cursor=" + cursor ) ; sign ( request ) ; JSONObject json = requestJSONObject ( request ) ; JSONArray array ; try { array = json . getJSONArray ( TwitterAPI . Field . IDS . toString ( ) ) ; } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } users . addAll ( constructUserListFromIDs ( array ) ) ; cursor = json . optString ( ( TwitterAPI . UserListField . NEXT_CURSOR . toString ( ) ) ) ; } return users ; } public boolean handlePublicTimelinePage ( final User user , final int page , final Handler < Tweet > handler ) throws TwitterClientException , HandlerException { if ( page < 1 ) { throw new IllegalArgumentException ( "bad page number" ) ; } HttpGet request = new HttpGet ( TwitterAPI . USER_TIMELINE_URL + "/" + user . getScreenName ( ) + ".json" + "?page=" + page + "&count=" + limits . getTimelinePageCountLimit ( ) ) ; JSONArray array = requestJSONArray ( request ) ; for ( int i = 0 ; i < array . length ( ) ; i ++ ) { Tweet t ; try { t = new Tweet ( array . getJSONObject ( i ) ) ; } catch ( TweetParseException e ) { throw new TwitterClientException ( e ) ; } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } if ( ! handler . isOpen ( ) ) { return false ; } handler . handle ( t ) ; } return 0 < array . length ( ) ; } public void handleTimelineFrom ( final User user , final Date minTimestamp , final Date maxTimestamp , final Handler < Tweet > handler ) throws TwitterClientException , HandlerException { final Date min = null == minTimestamp ? new Date ( 0 ) : minTimestamp ; final Date max = null == maxTimestamp ? new Date ( ) : maxTimestamp ; Handler < Tweet > dateFilter = new Handler < Tweet > ( ) { private int statuses = 0 ; private boolean open = true ; public boolean isOpen ( ) { return open ; } public void handle ( final Tweet tweet ) throws HandlerException { if ( ++ statuses >= limits . getStatusesLimit ( ) ) { LOGGER . warning ( "maximum number (" + limits . getStatusesLimit ( ) + ") of statuses retrieved for user " + user . getScreenName ( ) ) ; } Date t = tweet . getCreatedAt ( ) ; if ( t . compareTo ( max ) > 0 ) { return ; } open = t . compareTo ( min ) >= 0 && handler . isOpen ( ) ; if ( open ) { handler . handle ( tweet ) ; } } } ; int page = 1 ; while ( handlePublicTimelinePage ( user , page , dateFilter ) ) { page ++ ; } } public void processTimelineFrom ( final Set < User > users , final Date minTimestamp , final Date maxTimestamp , final Handler < Tweet > handler ) throws TwitterClientException , HandlerException { for ( User u : users ) { try { handleTimelineFrom ( u , minTimestamp , maxTimestamp , handler ) ; } catch ( UnauthorizedException e ) { LOGGER . warning ( "not authorized to get " + u . getScreenName ( ) + "'s timeline" ) ; } } } private List < User > constructUserList ( final JSONArray array ) throws TwitterClientException { List < User > users = new LinkedList < User > ( ) ; try { for ( int i = 0 ; i < array . length ( ) ; i ++ ) { try { users . add ( new User ( array . getJSONObject ( i ) ) ) ; } catch ( TweetParseException e ) { throw new TwitterClientException ( e ) ; } } } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } return users ; } private List < User > constructUserListFromIDs ( final JSONArray array ) throws TwitterClientException { List < User > users = new LinkedList < User > ( ) ; try { for ( int i = 0 ; i < array . length ( ) ; i ++ ) { users . add ( new User ( array . getInt ( i ) ) ) ; } } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } return users ; } private void sign ( final HttpUriRequest request ) throws TwitterClientException { try { if ( null != credentials ) { credentials . sign ( request ) ; } } catch ( OAuthExpectationFailedException e ) { throw new TwitterClientException ( e ) ; } catch ( OAuthMessageSignerException e ) { throw new TwitterClientException ( e ) ; } catch ( OAuthCommunicationException e ) { throw new TwitterClientException ( e ) ; } } private void setEntity ( final HttpPost request , final List < NameValuePair > formParams ) throws TwitterClientException { UrlEncodedFormEntity entity ; try { entity = new UrlEncodedFormEntity ( formParams , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new TwitterClientException ( e ) ; } request . setEntity ( entity ) ; } private JSONArray requestJSONArray ( final HttpUriRequest request ) throws TwitterClientException { try { HttpResponse response = requestUntilSucceed ( request , restAPIClient ) ; HttpEntity responseEntity = response . getEntity ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; responseEntity . writeTo ( bos ) ; String s = bos . toString ( ) ; bos . close ( ) ; if ( s . startsWith ( ( "{" ) ) ) { JSONObject object = new JSONObject ( s ) ; checkForTwitterAPIException ( object ) ; } return new JSONArray ( s ) ; } catch ( IOException e ) { throw new TwitterClientException ( e ) ; } catch ( JSONException e ) { throw new TwitterClientException ( e ) ; } } private void requestStatusArray ( final HttpUriRequest request , final Handler < Tweet > handler ) throws TwitterClientException { JSONArray array = requestJSONArray ( request ) ; if ( null != array ) { int length = array . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { try { JSONObject obj = ( JSONObject ) array . get ( i ) ; if ( ! handler . isOpen ( ) ) { break ; } handler . handle ( new Tweet ( obj ) ) ; } catch ( Exception e ) { throw new TwitterClientException ( e ) ; } } } } private StatusStreamParser . ExitReason continuousStream ( final HttpUriRequest request , final Handler < Tweet > addHandler , final Handler < Tweet > deleteHandler ) throws TwitterClientException { long lastWait = 0 ; while ( true ) { long timeOfLastRequest = System . currentTimeMillis ( ) ; StatusStreamParser . ExitReason exit = singleStreamRequest ( request , addHandler , deleteHandler ) ; long wait ; switch ( exit ) { case END_OF_INPUT : wait = nextWait ( lastWait , timeOfLastRequest , false ) ; break ; case EXCEPTION_THROWN : return exit ; case HANDLER_QUIT : return exit ; case NULL_RESPONSE : wait = nextWait ( lastWait , timeOfLastRequest , false ) ; break ; case CONNECTION_REFUSED : wait = CONNECTION_REFUSED_WAIT ; break ; case CONNECTION_RESET : wait = CONNECTION_RESET_WAIT ; break ; default : throw new IllegalStateException ( "unexpected exit state: " + exit ) ; } try { lastWait = wait ; LOGGER . fine ( "waiting " + wait + "ms before next request" ) ; Thread . sleep ( wait ) ; } catch ( InterruptedException e ) { throw new TwitterClientException ( e ) ; } } } private StatusStreamParser . ExitReason singleStreamRequest ( final HttpUriRequest request , final Handler < Tweet > addHandler , final Handler < Tweet > deleteHandler ) throws TwitterClientException { sign ( request ) ; HttpResponse response ; try { response = makeSignedJSONRequest ( request , streamingAPIClient ) ; } catch ( TwitterConnectionResetException e ) { return StatusStreamParser . ExitReason . CONNECTION_REFUSED ; } if ( null != response ) { HttpEntity responseEntity = response . getEntity ( ) ; try { boolean recoverFromErrors = true ; return new StatusStreamParser ( addHandler , deleteHandler , recoverFromErrors ) . parse ( responseEntity . getContent ( ) ) ; } catch ( IOException e ) { throw new TwitterClientException ( e ) ; } catch ( HandlerException e ) { throw new TwitterClientException ( e ) ; } } else { return StatusStreamParser . ExitReason . NULL_RESPONSE ; } } private String commaDelimit ( final String [ ] elements ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = true ; for ( String s : elements ) { if ( first ) { first = false ; } else { sb . append ( "," ) ; } sb . append ( s ) ; } return sb . toString ( ) ; } public static void main ( final String [ ] args ) throws Exception { Properties props = new Properties ( ) ; props . load ( new FileInputStream ( "/Users/josh/projects/fortytwo/twitlogic/config/twitlogic.properties" ) ) ; TwitLogic . setConfiguration ( props ) ; CustomTwitterClient client = new CustomTwitterClient ( ) ; List < User > l = client . getFollowees ( new User ( "joshsh" , 7083182 ) , - 1 ) ; for ( User u : l ) { System . out . println ( "" + u ) ; } } } 
=======
public class IriRef extends AbstractDatatype { public static final IriRef THE_INSTANCE = new IriRef ( ) ; protected IriRef ( ) { super ( ) ; } private final static boolean WARN = System . getProperty ( "org.whattf.datatype.warn" , "" ) . equals ( "true" ) ? true : false ; private enum KnownViolationCode { COMPATIBILITY_CHARACTER , CONTROL_CHARACTER , DNS_LABEL_DASH_START_OR_END , DOUBLE_WHITESPACE , EMPTY_SCHEME , HAS_PASSWORD , ILLEGAL_CHARACTER , ILLEGAL_PERCENT_ENCODING , IP_V4_HAS_FOUR_COMPONENTS , IP_V4_OCTET_RANGE , IP_V6_OR_FUTURE_ADDRESS_SYNTAX , NON_INITIAL_DOT_SEGMENT , NOT_DNS_NAME , PORT_SHOULD_NOT_BE_WELL_KNOWN , REQUIRED_COMPONENT_MISSING , SCHEME_MUST_START_WITH_LETTER , UNDEFINED_UNICODE_CHARACTER , UNICODE_WHITESPACE , UNREGISTERED_NONIETF_SCHEME_TREE , WHITESPACE , ZZZ_DUMMY_DEFAULT } private final CharSequencePair splitScheme ( CharSequence iri ) { StringBuilder sb = new StringBuilder ( ) ; Boolean atSchemeBeginning = true ; for ( int i = 0 ; i < iri . length ( ) ; i ++ ) { char c = toAsciiLowerCase ( iri . charAt ( i ) ) ; if ( atSchemeBeginning ) { if ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) { continue ; } if ( 'a' <= c && 'z' >= c ) { atSchemeBeginning = false ; sb . append ( c ) ; } else { return null ; } } else { if ( ( 'a' <= c && 'z' >= c ) || ( '0' <= c && '9' >= c ) || c == '+' || c == '.' ) { sb . append ( c ) ; continue ; } else if ( c == ':' ) { return new CharSequencePair ( sb , iri . subSequence ( i + 1 , iri . length ( ) ) ) ; } else { return null ; } } } return null ; } public void checkValid ( CharSequence literal ) throws DatatypeException { IRIFactory fac = new IRIFactory ( ) ; fac . shouldViolation ( true , false ) ; fac . securityViolation ( true , false ) ; fac . dnsViolation ( true , false ) ; fac . mintingViolation ( false , false ) ; fac . useSpecificationIRI ( true ) ; fac . useSchemeSpecificRules ( "http" , true ) ; fac . useSchemeSpecificRules ( "https" , true ) ; fac . useSchemeSpecificRules ( "ftp" , true ) ; fac . useSchemeSpecificRules ( "mailto" , true ) ; fac . useSchemeSpecificRules ( "file" , true ) ; fac . useSchemeSpecificRules ( "data" , true ) ; IRI iri ; boolean data = false ; try { CharSequencePair pair = splitScheme ( literal ) ; if ( pair == null ) { iri = fac . construct ( trimHtmlSpaces ( literal . toString ( ) ) ) ; } else { CharSequence scheme = pair . getHead ( ) ; CharSequence tail = pair . getTail ( ) ; if ( isWellKnown ( scheme ) ) { iri = fac . construct ( trimHtmlSpaces ( literal . toString ( ) ) ) ; } else if ( "javascript" . contentEquals ( scheme ) ) { iri = null ; Reader reader = new BufferedReader ( new Utf8PercentDecodingReader ( new StringReader ( "function(event){" + tail . toString ( ) + "}" ) ) ) ; reader . mark ( 1 ) ; int c = reader . read ( ) ; if ( c != 0xFEFF ) { reader . reset ( ) ; } try { Context context = ContextFactory . getGlobal ( ) . enterContext ( ) ; context . setOptimizationLevel ( 0 ) ; context . setLanguageVersion ( Context . VERSION_1_6 ) ; context . compileReader ( reader , null , - 1 , null ) ; } finally { Context . exit ( ) ; } } else if ( "data" . contentEquals ( scheme ) ) { data = true ; iri = fac . construct ( trimHtmlSpaces ( literal . toString ( ) ) ) ; } else if ( isHttpAlias ( scheme ) ) { StringBuilder sb = new StringBuilder ( 5 + tail . length ( ) ) ; sb . append ( "http:" ) . append ( tail ) ; iri = fac . construct ( trimHtmlTrailingSpaces ( sb . toString ( ) ) ) ; } else { StringBuilder sb = new StringBuilder ( 2 + literal . length ( ) ) ; sb . append ( "x-" ) . append ( literal ) ; iri = fac . construct ( trimHtmlTrailingSpaces ( sb . toString ( ) ) ) ; } } } catch ( IRIException e ) { Violation v = e . getViolation ( ) ; KnownViolationCode vc = KnownViolationCode . valueOf ( "ZZZ_DUMMY_DEFAULT" ) ; try { vc = KnownViolationCode . valueOf ( v . codeName ( ) ) ; } catch ( Exception ex ) { } switch ( vc ) { case HAS_PASSWORD : if ( WARN ) { throw newDatatypeException ( underbarStringToSentence ( v . component ( ) ) + " component contains a password." , WARN ) ; } else { return ; } case NON_INITIAL_DOT_SEGMENT : if ( WARN ) { throw newDatatypeException ( "Path component contains a segment “/../” not at the beginning of a relative reference, or it contains a “/./”. These should be removed." , WARN ) ; } else { return ; } case PORT_SHOULD_NOT_BE_WELL_KNOWN : if ( WARN ) { throw newDatatypeException ( "Ports under 1024 should be accessed using the appropriate scheme name." , WARN ) ; } else { return ; } case COMPATIBILITY_CHARACTER : if ( WARN ) { throw newDatatypeException ( underbarStringToSentence ( v . codeName ( ) ) + " in " + toAsciiLowerCase ( v . component ( ) ) + " component." , WARN ) ; } else { return ; } case DNS_LABEL_DASH_START_OR_END : throw newDatatypeException ( "Host component contains a DNS name with a “-” (dash) character at the beginning or end." ) ; case DOUBLE_WHITESPACE : case WHITESPACE : throw newDatatypeException ( "Whitespace in " + toAsciiLowerCase ( v . component ( ) ) + " component. " + "Use “%20” in place of spaces." ) ; case EMPTY_SCHEME : throw newDatatypeException ( "Scheme component is empty." ) ; case ILLEGAL_PERCENT_ENCODING : throw newDatatypeException ( underbarStringToSentence ( v . component ( ) ) + " component contains a percent sign that is not followed by two hexadecimal digits." ) ; case IP_V4_HAS_FOUR_COMPONENTS : throw newDatatypeException ( "Host component is entirely numeric but does not have four components like an IPv4 address." ) ; case IP_V4_OCTET_RANGE : throw newDatatypeException ( "Host component contains a number not in the range 0-255, or a number with a leading zero." ) ; case IP_V6_OR_FUTURE_ADDRESS_SYNTAX : throw newDatatypeException ( "Host component contains an IPv6 (or IPvFuture) syntax violation." ) ; case NOT_DNS_NAME : throw newDatatypeException ( "Host component did not meet the restrictions on DNS names." ) ; case REQUIRED_COMPONENT_MISSING : throw newDatatypeException ( "A component that is required by the scheme is missing." ) ; case SCHEME_MUST_START_WITH_LETTER : throw newDatatypeException ( "Scheme component must start with a letter." ) ; case UNREGISTERED_NONIETF_SCHEME_TREE : throw newDatatypeException ( "Scheme component has a “-” (dash) character, but does not start with “x-”, and the prefix is not known as the prefix of an alternative tree for URI schemes." ) ; case CONTROL_CHARACTER : case ILLEGAL_CHARACTER : case UNDEFINED_UNICODE_CHARACTER : case UNICODE_WHITESPACE : throw newDatatypeException ( underbarStringToSentence ( v . codeName ( ) ) + " in " + toAsciiLowerCase ( v . component ( ) ) + " component." ) ; default : throw newDatatypeException ( v . codeName ( ) + " in " + toAsciiLowerCase ( v . component ( ) ) + " component." ) ; } } catch ( IOException e ) { throw newDatatypeException ( e . getMessage ( ) ) ; } catch ( RhinoException e ) { throw newDatatypeException ( e . getMessage ( ) ) ; } if ( isAbsolute ( ) ) { if ( iri != null && ! iri . isAbsolute ( ) ) { throw newDatatypeException ( "Not an absolute IRI." ) ; } } if ( iri != null ) { if ( "" . equals ( iri . toString ( ) ) ) { throw newDatatypeException ( "Must be non-empty." ) ; } if ( data ) { try { DataUri dataUri = new DataUri ( iri ) ; InputStream is = dataUri . getInputStream ( ) ; while ( is . read ( ) >= 0 ) { } } catch ( DataUriException e ) { throw newDatatypeException ( e . getIndex ( ) , e . getHead ( ) , e . getLiteral ( ) , e . getTail ( ) ) ; } catch ( IOException e ) { throw newDatatypeException ( e . getMessage ( ) ) ; } } } } private final boolean isHttpAlias ( CharSequence scheme ) { return "feed" . contentEquals ( scheme ) || "webcal" . contentEquals ( scheme ) ; } private final boolean isWellKnown ( CharSequence scheme ) { return "http" . contentEquals ( scheme ) || "https" . contentEquals ( scheme ) || "ftp" . contentEquals ( scheme ) || "mailto" . contentEquals ( scheme ) || "file" . contentEquals ( scheme ) ; } protected boolean isAbsolute ( ) { return false ; } protected static final String underbarStringToSentence ( String str ) { if ( str == null ) { return null ; } char [ ] buf = new char [ str . length ( ) ] ; buf [ 0 ] = str . charAt ( 0 ) ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' ) { c += 0x20 ; } else if ( c == 0x5f ) { c = 0x20 ; } buf [ i ] = c ; } return new String ( buf ) ; } protected static final String trimHtmlSpaces ( String str ) { return trimHtmlLeadingSpaces ( trimHtmlTrailingSpaces ( str ) ) ; } protected static final String trimHtmlLeadingSpaces ( String str ) { if ( str == null ) { return null ; } for ( int i = str . length ( ) ; i > 0 ; -- i ) { char c = str . charAt ( str . length ( ) - i ) ; if ( ! ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) ) { return str . substring ( str . length ( ) - i , str . length ( ) ) ; } } return "" ; } protected static final String trimHtmlTrailingSpaces ( String str ) { if ( str == null ) { return null ; } for ( int i = str . length ( ) - 1 ; i >= 0 ; -- i ) { char c = str . charAt ( i ) ; if ( ! ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) ) { return str . substring ( 0 , i + 1 ) ; } } return "" ; } @ Override public String getName ( ) { return "IRI reference" ; } private class CharSequencePair { private final CharSequence head ; private final CharSequence tail ; public CharSequencePair ( final CharSequence head , final CharSequence tail ) { this . head = head ; this . tail = tail ; } public CharSequence getHead ( ) { return head ; } public CharSequence getTail ( ) { return tail ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
