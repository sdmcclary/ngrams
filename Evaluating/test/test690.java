<<<<<<< HEAD
public class FileCharSequenceProvider { private static int NUMBER_OF_BUFFERS = 3 ; public static int BUFFER_SIZE = 2 << 18 ; private FileCharSequence fReused = null ; public CharSequence newCharSequence ( File file ) throws CoreException , IOException { if ( this . fReused == null ) { return new FileCharSequence ( file ) ; } FileCharSequence curr = this . fReused ; this . fReused = null ; curr . reset ( file ) ; return curr ; } public void releaseCharSequence ( CharSequence seq ) throws CoreException , IOException { if ( seq instanceof FileCharSequence ) { FileCharSequence curr = ( FileCharSequence ) seq ; try { curr . close ( ) ; } finally { if ( this . fReused == null ) { this . fReused = curr ; } } } } public static class FileCharSequenceException extends RuntimeException { private static final long serialVersionUID = 1L ; FileCharSequenceException ( IOException e ) { super ( e ) ; } FileCharSequenceException ( CoreException e ) { super ( e ) ; } public void throwWrappedException ( ) throws CoreException , IOException { Throwable wrapped = this . getCause ( ) ; if ( wrapped instanceof CoreException ) { throw ( CoreException ) wrapped ; } else if ( wrapped instanceof IOException ) { throw ( IOException ) wrapped ; } } } private static final class CharSubSequence implements CharSequence { private final int fSequenceOffset ; private final int fSequenceLength ; private final FileCharSequence fParent ; public CharSubSequence ( FileCharSequence parent , int offset , int length ) { this . fParent = parent ; this . fSequenceOffset = offset ; this . fSequenceLength = length ; } public int length ( ) { return this . fSequenceLength ; } public char charAt ( int index ) { if ( index < 0 ) { throw new IndexOutOfBoundsException ( "index must be larger than 0" ) ; } if ( index >= this . fSequenceLength ) { throw new IndexOutOfBoundsException ( "index must be smaller than length" ) ; } return this . fParent . charAt ( this . fSequenceOffset + index ) ; } public CharSequence subSequence ( int start , int end ) { if ( end < start ) { throw new IndexOutOfBoundsException ( "end cannot be smaller than start" ) ; } if ( start < 0 ) { throw new IndexOutOfBoundsException ( "start must be larger than 0" ) ; } if ( end > this . fSequenceLength ) { throw new IndexOutOfBoundsException ( "end must be smaller or equal than length" ) ; } return this . fParent . subSequence ( this . fSequenceOffset + start , this . fSequenceOffset + end ) ; } public String toString ( ) { try { return this . fParent . getSubstring ( this . fSequenceOffset , this . fSequenceLength ) ; } catch ( IOException e ) { throw new FileCharSequenceException ( e ) ; } catch ( CoreException e ) { throw new FileCharSequenceException ( e ) ; } } } private static final class Buffer { private final char [ ] fBuf ; private int fOffset ; private int fLength ; private Buffer fNext ; private Buffer fPrevious ; public Buffer ( ) { this . fBuf = new char [ FileCharSequenceProvider . BUFFER_SIZE ] ; this . reset ( ) ; this . fNext = this ; this . fPrevious = this ; } public boolean contains ( int pos ) { int offset = this . fOffset ; return ( offset <= pos ) && ( pos < offset + this . fLength ) ; } public boolean fill ( Reader reader , int pos ) throws IOException { int res = reader . read ( this . fBuf ) ; if ( res == - 1 ) { this . fOffset = pos ; this . fLength = 0 ; return true ; } int charsRead = res ; while ( charsRead < FileCharSequenceProvider . BUFFER_SIZE ) { res = reader . read ( this . fBuf , charsRead , FileCharSequenceProvider . BUFFER_SIZE - charsRead ) ; if ( res == - 1 ) { this . fOffset = pos ; this . fLength = charsRead ; return true ; } charsRead += res ; } this . fOffset = pos ; this . fLength = FileCharSequenceProvider . BUFFER_SIZE ; return false ; } public char get ( int pos ) { return this . fBuf [ pos - this . fOffset ] ; } public StringBuffer append ( StringBuffer buf , int start , int length ) { return buf . append ( this . fBuf , start - this . fOffset , length ) ; } public StringBuffer appendAll ( StringBuffer buf ) { return buf . append ( this . fBuf , 0 , this . fLength ) ; } public int getEndOffset ( ) { return this . fOffset + this . fLength ; } public void removeFromChain ( ) { this . fPrevious . fNext = this . fNext ; this . fNext . fPrevious = this . fPrevious ; this . fNext = this ; this . fPrevious = this ; } public void insertBefore ( Buffer other ) { this . fNext = other ; this . fPrevious = other . fPrevious ; this . fPrevious . fNext = this ; other . fPrevious = this ; } public Buffer getNext ( ) { return this . fNext ; } public Buffer getPrevious ( ) { return this . fPrevious ; } public void reset ( ) { this . fOffset = - 1 ; this . fLength = 0 ; } } private final class FileCharSequence implements CharSequence { private Reader fReader ; private int fReaderPos ; private Integer fLength ; private Buffer fMostCurrentBuffer ; private int fNumberOfBuffers ; private File fFile ; public FileCharSequence ( File file ) throws CoreException , IOException { this . fNumberOfBuffers = 0 ; this . reset ( file ) ; } public void reset ( File file ) throws CoreException , IOException { this . fFile = file ; this . fLength = null ; Buffer curr = this . fMostCurrentBuffer ; if ( curr != null ) { do { curr . reset ( ) ; curr = curr . getNext ( ) ; } while ( curr != this . fMostCurrentBuffer ) ; } this . initializeReader ( ) ; } private void initializeReader ( ) throws CoreException , IOException { if ( this . fReader != null ) { this . fReader . close ( ) ; } String charset = ResourcesPlugin . getEncoding ( ) ; this . fReader = new InputStreamReader ( this . getInputStream ( charset ) , charset ) ; this . fReaderPos = 0 ; } private InputStream getInputStream ( String charset ) throws CoreException , IOException { InputStream contents = new BufferedInputStream ( new FileInputStream ( this . fFile ) ) ; return contents ; } private void clearReader ( ) throws IOException { if ( this . fReader != null ) { this . fReader . close ( ) ; } this . fReader = null ; this . fReaderPos = Integer . MAX_VALUE ; } public int length ( ) { if ( this . fLength == null ) { try { this . getBuffer ( Integer . MAX_VALUE ) ; } catch ( IOException e ) { throw new FileCharSequenceException ( e ) ; } catch ( CoreException e ) { throw new FileCharSequenceException ( e ) ; } } return this . fLength . intValue ( ) ; } private Buffer getBuffer ( int pos ) throws IOException , CoreException { Buffer curr = this . fMostCurrentBuffer ; if ( curr != null ) { do { if ( curr . contains ( pos ) ) { return curr ; } curr = curr . getNext ( ) ; } while ( curr != this . fMostCurrentBuffer ) ; } Buffer buf = this . findBufferToUse ( ) ; this . fillBuffer ( buf , pos ) ; if ( buf . contains ( pos ) ) { return buf ; } return null ; } private Buffer findBufferToUse ( ) { if ( this . fNumberOfBuffers < FileCharSequenceProvider . NUMBER_OF_BUFFERS ) { this . fNumberOfBuffers ++ ; Buffer newBuffer = new Buffer ( ) ; if ( this . fMostCurrentBuffer == null ) { this . fMostCurrentBuffer = newBuffer ; return newBuffer ; } newBuffer . insertBefore ( this . fMostCurrentBuffer ) ; return newBuffer ; } return this . fMostCurrentBuffer . getPrevious ( ) ; } private boolean fillBuffer ( Buffer buffer , int pos ) throws CoreException , IOException { if ( this . fReaderPos > pos ) { this . initializeReader ( ) ; } do { boolean endReached = buffer . fill ( this . fReader , this . fReaderPos ) ; this . fReaderPos = buffer . getEndOffset ( ) ; if ( endReached ) { this . fLength = new Integer ( this . fReaderPos ) ; this . fReaderPos = Integer . MAX_VALUE ; return true ; } } while ( this . fReaderPos <= pos ) ; return true ; } public char charAt ( final int index ) { final Buffer current = this . fMostCurrentBuffer ; if ( ( current != null ) && current . contains ( index ) ) { return current . get ( index ) ; } if ( index < 0 ) { throw new IndexOutOfBoundsException ( "index must be larger than 0" ) ; } if ( ( this . fLength != null ) && ( index >= this . fLength . intValue ( ) ) ) { throw new IndexOutOfBoundsException ( "index must be smaller than length" ) ; } try { final Buffer buffer = this . getBuffer ( index ) ; if ( buffer == null ) { throw new IndexOutOfBoundsException ( "index must be smaller than length" ) ; } if ( buffer != this . fMostCurrentBuffer ) { if ( buffer . getNext ( ) != this . fMostCurrentBuffer ) { buffer . removeFromChain ( ) ; buffer . insertBefore ( this . fMostCurrentBuffer ) ; } this . fMostCurrentBuffer = buffer ; } return buffer . get ( index ) ; } catch ( IOException e ) { throw new FileCharSequenceException ( e ) ; } catch ( CoreException e ) { throw new FileCharSequenceException ( e ) ; } } public String getSubstring ( int start , int length ) throws IOException , CoreException { int pos = start ; int endPos = start + length ; if ( ( this . fLength != null ) && ( endPos > this . fLength . intValue ( ) ) ) { throw new IndexOutOfBoundsException ( "end must be smaller than length" ) ; } StringBuffer res = new StringBuffer ( length ) ; Buffer buffer = this . getBuffer ( pos ) ; while ( ( pos < endPos ) && ( buffer != null ) ) { int bufEnd = buffer . getEndOffset ( ) ; if ( bufEnd >= endPos ) { return buffer . append ( res , pos , endPos - pos ) . toString ( ) ; } buffer . append ( res , pos , bufEnd - pos ) ; pos = bufEnd ; buffer = this . getBuffer ( pos ) ; } return res . toString ( ) ; } public CharSequence subSequence ( int start , int end ) { if ( end < start ) { throw new IndexOutOfBoundsException ( "end cannot be smaller than start" ) ; } if ( start < 0 ) { throw new IndexOutOfBoundsException ( "start must be larger than 0" ) ; } if ( ( this . fLength != null ) && ( end > this . fLength . intValue ( ) ) ) { throw new IndexOutOfBoundsException ( "end must be smaller than length" ) ; } return new CharSubSequence ( this , start , end - start ) ; } public void close ( ) throws IOException { this . clearReader ( ) ; } public String toString ( ) { int len = this . fLength != null ? this . fLength . intValue ( ) : 4000 ; StringBuffer res = new StringBuffer ( len ) ; try { Buffer buffer = this . getBuffer ( 0 ) ; while ( buffer != null ) { buffer . appendAll ( res ) ; buffer = this . getBuffer ( res . length ( ) ) ; } return res . toString ( ) ; } catch ( IOException e ) { throw new FileCharSequenceException ( e ) ; } catch ( CoreException e ) { throw new FileCharSequenceException ( e ) ; } } } } 
=======
public class ServiceConnectionMidp implements ServiceConnection { private HttpConnection connection ; public ServiceConnectionMidp ( String url ) throws IOException { connection = ( HttpConnection ) Connector . open ( url , Connector . READ_WRITE , true ) ; } public void disconnect ( ) throws IOException { connection . close ( ) ; } public void setRequestProperty ( String string , String soapAction ) throws IOException { connection . setRequestProperty ( string , soapAction ) ; } public void setRequestMethod ( String post ) throws IOException { connection . setRequestMethod ( post ) ; } public OutputStream openOutputStream ( ) throws IOException { return connection . openOutputStream ( ) ; } public InputStream openInputStream ( ) throws IOException { return connection . openInputStream ( ) ; } public void connect ( ) throws IOException { throw new RuntimeException ( "ServiceConnectionMidp.connect is not available." ) ; } public InputStream getErrorStream ( ) { throw new RuntimeException ( "ServiceConnectionMidp.getErrorStream is not available." ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
