<<<<<<< HEAD
public class LoggingPreferences { public static class Rule { private String name ; private String rule ; private boolean isRegexp ; private boolean isCaseInsensitive ; public Rule ( String name , String rule , boolean isRegexp , boolean isCaseInsensitive ) { this . name = name ; this . rule = rule ; this . isRegexp = isRegexp ; this . isCaseInsensitive = isCaseInsensitive ; } public String getName ( ) { return name ; } public String getRule ( ) { return rule ; } public boolean isRegexp ( ) { return isRegexp ; } public void setRule ( String rule ) { this . rule = rule ; } public boolean isCaseInsensitive ( ) { return isCaseInsensitive ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( name == null ) ? 0 : name . hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final Rule other = ( Rule ) obj ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; return true ; } @ Override public String toString ( ) { return name ; } } private class RulesList extends AbstractList < Rule > { private List < Rule > base ; public RulesList ( List < Rule > base ) { this . base = base ; } @ Override public Rule get ( int index ) { return base . get ( index ) ; } @ Override public int size ( ) { return base . size ( ) ; } @ Override public void add ( int index , Rule element ) { if ( base . contains ( element ) ) { return ; } base . add ( index , element ) ; saveRules ( base ) ; notifyRulesChanged ( ) ; } @ Override public Rule remove ( int index ) { Rule toReturn = base . remove ( index ) ; saveRules ( base ) ; notifyRulesChanged ( ) ; return toReturn ; } @ Override public void clear ( ) { base . clear ( ) ; saveRules ( base ) ; notifyRulesChanged ( ) ; } @ Override public boolean addAll ( int index , Collection < ? extends Rule > c ) { boolean added = base . addAll ( index , c ) ; saveRules ( base ) ; return added ; } } public static final String COLORIZER_ID = "com.aptana.ide.logging.coloring.colorizer" ; private static final String BASE_KEY = "com.aptana.ide.logging.preferences.LoggingPreferences" ; public static final String DEFAULT_RULES_POINT_ID = "com.aptana.ide.logging.defaultRules" ; private static final String LENGTH_KEY = BASE_KEY + "_length" ; private static final String NAME_KEY = BASE_KEY + "_name" ; private static final String CONTENT_KEY = BASE_KEY + "_content" ; private static final String REGEXP_KEY = BASE_KEY + "_isregexp" ; private static final String CASEINSENSITIVE_KEY = BASE_KEY + "_iscasesensitive" ; private static final String AUTOBOLDING_KEY = BASE_KEY + "_autobolding" ; private static final String WRAPPING_KEY = BASE_KEY + "_wrapping" ; public static final String MAIN_TEXT_FONT_KEY = BASE_KEY + ".maintextfont" ; public static final String CURSORLINE_KEY = BASE_KEY + ".cursorline" ; public static final String CURSORLINE_COLOR_KEY = BASE_KEY + ".cursorlinecolor" ; public static final String TEXT_COLOR_KEY = BASE_KEY + ".textcolor" ; public static final String READ_TIMEOUT_KEY = BASE_KEY + ".readtimeout" ; public static final String READ_BUFFER_KEY = BASE_KEY + ".readbuffer" ; public static final String DEFAULT_ENCODING_KEY = BASE_KEY + ".defaultencoding" ; private static final String BACKLOG_LINES_KEY = BASE_KEY + ".backloglines" ; private static final int WINDOWS_DEFAULT_FONT_SIZE = 9 ; private static final int MAC_OS_DEFAULT_FONT_SIZE = 10 ; private static final int LINUX_DEFAULT_FONT_SIZE = 10 ; private static final String DEFAULT_FONT_FAMILY = "Courier" ; private static final Object RULE_ELEMENT = "rule" ; private static final String NAME_ATTRIBVUTE = "name" ; private static final String CONTENT_ATTRIBUTE = "content" ; private static final String ISREGEXP_ATTRIBUTE = "regexp" ; private static final String ISCASEINSENSITIVE_ATTRIBUTE = "caseInsensitive" ; private static final String BOLD_ATTRIBUTE = "bold" ; private static final String ITALIC_ATTRIBUTE = "italic" ; private static final String UNDERLINE_ATTRIBUTE = "underline" ; private static final String COLOR_ATTRIBUTE = "color" ; private RulesList rules ; private List < ILoggingPreferenceListener > listeners = new ArrayList < ILoggingPreferenceListener > ( ) ; private List < ILoggingPreferenceListener > pendingToAddListeners = new ArrayList < ILoggingPreferenceListener > ( ) ; private List < ILoggingPreferenceListener > pendingToRemoveListeners = new ArrayList < ILoggingPreferenceListener > ( ) ; private Boolean autoBolding ; private Boolean wrapping ; private FontRegistry fontRegistry = new FontRegistry ( Display . getCurrent ( ) ) ; private boolean mainFontLoaded = false ; private ColorRegistry colorRegistry = new ColorRegistry ( Display . getCurrent ( ) ) ; private Integer readTimeout ; private Integer readBuffer ; private String defaultEncoding ; private Integer backLogLines ; public List < Rule > getRules ( ) { if ( rules == null ) { final List < Rule > base = loadRules ( ) ; rules = new RulesList ( base ) ; } return rules ; } public void initializePreferences ( ) { IPreferenceStore store = getPreferenceStore ( ) ; store . setDefault ( WRAPPING_KEY , false ) ; store . setDefault ( AUTOBOLDING_KEY , true ) ; store . setDefault ( CURSORLINE_KEY , true ) ; PreferenceConverter . setDefault ( store , CURSORLINE_COLOR_KEY , new RGB ( 233 , 233 , 235 ) ) ; PreferenceConverter . setDefault ( store , TEXT_COLOR_KEY , new RGB ( 128 , 128 , 128 ) ) ; store . setDefault ( READ_TIMEOUT_KEY , 100 ) ; store . setDefault ( READ_BUFFER_KEY , 1024 * 32 ) ; store . setDefault ( DEFAULT_ENCODING_KEY , "UTF-8" ) ; store . setDefault ( BACKLOG_LINES_KEY , 750 ) ; initializeDefaultFont ( ) ; if ( store . getString ( LENGTH_KEY ) . length ( ) == 0 ) { initializeDefaultRules ( ) ; } } public boolean getAutoBolding ( ) { if ( autoBolding == null ) { loadAutoBolding ( ) ; } return autoBolding ; } public void setAutoBolding ( boolean autobolding ) { this . autoBolding = autobolding ; saveAutoBolding ( ) ; } public int getReadTimeout ( ) { if ( readTimeout == null ) { loadReadTimeout ( ) ; } return readTimeout ; } public void setReadTimeout ( int readtimeout ) { this . readTimeout = readtimeout ; saveReadTimeout ( ) ; } public int getReadBuffer ( ) { if ( readBuffer == null ) { loadReadBuffer ( ) ; } return readBuffer ; } public void setReadBuffer ( int readbuffer ) { this . readBuffer = readbuffer ; saveReadBuffer ( ) ; } public boolean getWrapping ( ) { if ( wrapping == null ) { loadWrapping ( ) ; } return wrapping ; } public void setWrapping ( boolean wrapping ) { this . wrapping = wrapping ; saveWrapping ( ) ; notifyWrappingChanged ( wrapping ) ; } public int getBacklogLines ( ) { if ( backLogLines == null ) { loadBacklogLines ( ) ; } return backLogLines ; } public void setBacklogLines ( int lines ) { backLogLines = lines ; saveBacklogLines ( ) ; } public void setCursorLineColor ( RGB rgb ) { PreferenceConverter . setValue ( getPreferenceStore ( ) , CURSORLINE_COLOR_KEY , rgb ) ; } public RGB getCursorLineColor ( ) { return PreferenceConverter . getColor ( getPreferenceStore ( ) , CURSORLINE_COLOR_KEY ) ; } public RGB getTextColorRGB ( ) { RGB color = colorRegistry . getRGB ( TEXT_COLOR_KEY ) ; if ( color == null ) { RGB rgb = PreferenceConverter . getColor ( getPreferenceStore ( ) , TEXT_COLOR_KEY ) ; colorRegistry . put ( TEXT_COLOR_KEY , rgb ) ; color = colorRegistry . getRGB ( TEXT_COLOR_KEY ) ; } return color ; } public Color getTextColor ( ) { Color color = colorRegistry . get ( TEXT_COLOR_KEY ) ; if ( color == null ) { RGB rgb = PreferenceConverter . getColor ( getPreferenceStore ( ) , TEXT_COLOR_KEY ) ; colorRegistry . put ( TEXT_COLOR_KEY , rgb ) ; color = colorRegistry . get ( TEXT_COLOR_KEY ) ; } return color ; } public void setTextColor ( RGB rgb ) { PreferenceConverter . setValue ( getPreferenceStore ( ) , TEXT_COLOR_KEY , rgb ) ; colorRegistry . put ( TEXT_COLOR_KEY , rgb ) ; notifyForegroundColorChanged ( colorRegistry . get ( TEXT_COLOR_KEY ) ) ; } public FontData [ ] getFontData ( ) { synchronized ( fontRegistry ) { loadMainFont ( ) ; return fontRegistry . getFontData ( MAIN_TEXT_FONT_KEY ) ; } } public Font getFont ( ) { synchronized ( fontRegistry ) { loadMainFont ( ) ; return fontRegistry . get ( MAIN_TEXT_FONT_KEY ) ; } } public void setFontData ( FontData [ ] data ) { synchronized ( fontRegistry ) { PreferenceConverter . setValue ( getPreferenceStore ( ) , MAIN_TEXT_FONT_KEY , data ) ; fontRegistry . put ( MAIN_TEXT_FONT_KEY , data ) ; notifyFontChanged ( fontRegistry . get ( MAIN_TEXT_FONT_KEY ) ) ; mainFontLoaded = true ; } } public boolean getDefaultAutoBolding ( ) { IPreferenceStore store = getPreferenceStore ( ) ; return store . getDefaultBoolean ( AUTOBOLDING_KEY ) ; } public int getDefaultBacklogLines ( ) { IPreferenceStore store = getPreferenceStore ( ) ; return store . getDefaultInt ( BACKLOG_LINES_KEY ) ; } public int getDefaultReadTimeout ( ) { IPreferenceStore store = getPreferenceStore ( ) ; return store . getDefaultInt ( READ_TIMEOUT_KEY ) ; } public int getDefaultReadBuffer ( ) { IPreferenceStore store = getPreferenceStore ( ) ; return store . getDefaultInt ( READ_BUFFER_KEY ) ; } public boolean getDefaultWrapping ( ) { IPreferenceStore store = getPreferenceStore ( ) ; return store . getDefaultBoolean ( WRAPPING_KEY ) ; } public RGB getDefaultCursorLineColor ( ) { return PreferenceConverter . getDefaultColor ( getPreferenceStore ( ) , CURSORLINE_COLOR_KEY ) ; } public RGB getDefaultTextColor ( ) { return PreferenceConverter . getDefaultColor ( getPreferenceStore ( ) , TEXT_COLOR_KEY ) ; } public FontData [ ] getDefaultFont ( ) { return PreferenceConverter . getDefaultFontDataArray ( getPreferenceStore ( ) , MAIN_TEXT_FONT_KEY ) ; } public String getDefaultDefaultEncoding ( ) { IPreferenceStore store = getPreferenceStore ( ) ; return store . getDefaultString ( DEFAULT_ENCODING_KEY ) ; } public void addPreferenceListener ( ILoggingPreferenceListener listener ) { pendingToAddListeners . add ( listener ) ; } public void removePreferenceListener ( ILoggingPreferenceListener listener ) { pendingToRemoveListeners . add ( listener ) ; } public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; saveDefaultEncoding ( ) ; } public String getDefaultEncoding ( ) { if ( defaultEncoding == null ) { loadDefaultEncoding ( ) ; } return defaultEncoding ; } public static void createLanguageColorizer ( ) { ColorizerReader reader = new ColorizerReader ( TokenTypes . getTokenList ( ) ) ; LanguageColorizer lc = reader . loadColorization ( LoggingPreferences . COLORIZER_ID , true ) ; if ( lc != null ) { LanguageRegistry . registerLanguageColorizer ( TokenTypes . LANGUAGE , lc ) ; } if ( lc == null ) { lc = new LanguageColorizer ( TokenTypes . LANGUAGE ) ; LanguageRegistry . registerLanguageColorizer ( TokenTypes . LANGUAGE , lc ) ; LanguageRegistry . setPreferenceId ( TokenTypes . LANGUAGE , LoggingPreferences . COLORIZER_ID ) ; } } public int getRegexpMaxLines ( ) { return 1 ; } public void initializeDefaultRules ( ) { createLanguageColorizer ( ) ; LoggingStructureProvider provider = new LoggingStructureProvider ( ) ; fillDefaultRules ( provider ) ; provider . buildLanguageColorizer ( LanguageRegistry . getLanguageColorizer ( TokenTypes . LANGUAGE ) , LoggingPreferences . COLORIZER_ID ) ; provider . applyChanges ( ) ; } private List < Rule > loadRules ( ) { IPreferenceStore store = getPreferenceStore ( ) ; int length = store . getInt ( LENGTH_KEY ) ; List < Rule > result = new ArrayList < Rule > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { String ruleName = store . getString ( NAME_KEY + i ) ; String ruleContent = store . getString ( CONTENT_KEY + i ) ; Boolean ruleIsRegexp = store . getBoolean ( REGEXP_KEY + i ) ; Boolean isCaseInsensitive = store . getBoolean ( CASEINSENSITIVE_KEY + i ) ; Rule rule = new Rule ( ruleName , ruleContent , ruleIsRegexp , isCaseInsensitive ) ; result . add ( rule ) ; } return result ; } private void saveRules ( List < Rule > rules ) { clearList ( ) ; IPreferenceStore store = getPreferenceStore ( ) ; store . setValue ( LENGTH_KEY , rules . size ( ) ) ; for ( int i = 0 ; i < rules . size ( ) ; i ++ ) { Rule rule = rules . get ( i ) ; store . setValue ( NAME_KEY + i , rule . getName ( ) ) ; store . setValue ( CONTENT_KEY + i , rule . getRule ( ) ) ; store . setValue ( REGEXP_KEY + i , rule . isRegexp ( ) ) ; store . setValue ( CASEINSENSITIVE_KEY + i , rule . isCaseInsensitive ( ) ) ; } } private void clearList ( ) { IPreferenceStore store = getPreferenceStore ( ) ; int length = store . getDefaultInt ( LENGTH_KEY ) ; for ( int i = 0 ; i < length ; i ++ ) { store . setValue ( NAME_KEY + i , "" ) ; store . setValue ( CONTENT_KEY + i , "" ) ; store . setValue ( REGEXP_KEY + i , false ) ; store . setValue ( CASEINSENSITIVE_KEY + i , false ) ; } } private IPreferenceStore getPreferenceStore ( ) { return LoggingPlugin . getDefault ( ) . getPreferenceStore ( ) ; } private void notifyRulesChanged ( ) { for ( ILoggingPreferenceListener listener : getListeners ( ) ) { listener . rulesChanged ( ) ; } } private void notifyWrappingChanged ( boolean wrapping ) { for ( ILoggingPreferenceListener listener : getListeners ( ) ) { listener . wrappingChanged ( wrapping ) ; } } private void notifyFontChanged ( Font font ) { for ( ILoggingPreferenceListener listener : getListeners ( ) ) { listener . fontChanged ( font ) ; } } private void notifyForegroundColorChanged ( Color color ) { for ( ILoggingPreferenceListener listener : getListeners ( ) ) { listener . textForegroundColorChanged ( color ) ; } } private List < ILoggingPreferenceListener > getListeners ( ) { listeners . addAll ( pendingToAddListeners ) ; listeners . removeAll ( pendingToRemoveListeners ) ; pendingToAddListeners . clear ( ) ; pendingToRemoveListeners . clear ( ) ; return listeners ; } private void saveAutoBolding ( ) { if ( autoBolding != null ) { IPreferenceStore store = getPreferenceStore ( ) ; store . setValue ( AUTOBOLDING_KEY , autoBolding ) ; } } private void loadAutoBolding ( ) { IPreferenceStore store = getPreferenceStore ( ) ; autoBolding = store . getBoolean ( AUTOBOLDING_KEY ) ; } private void saveReadTimeout ( ) { if ( readTimeout != null ) { IPreferenceStore store = getPreferenceStore ( ) ; store . setValue ( READ_TIMEOUT_KEY , readTimeout ) ; } } private void loadReadTimeout ( ) { IPreferenceStore store = getPreferenceStore ( ) ; readTimeout = store . getInt ( READ_TIMEOUT_KEY ) ; } private void saveReadBuffer ( ) { if ( readBuffer != null ) { IPreferenceStore store = getPreferenceStore ( ) ; store . setValue ( READ_BUFFER_KEY , readBuffer ) ; } } private void loadReadBuffer ( ) { IPreferenceStore store = getPreferenceStore ( ) ; readBuffer = store . getInt ( READ_BUFFER_KEY ) ; } private void saveWrapping ( ) { if ( wrapping != null ) { IPreferenceStore store = getPreferenceStore ( ) ; store . setValue ( WRAPPING_KEY , wrapping ) ; } } private void loadWrapping ( ) { IPreferenceStore store = getPreferenceStore ( ) ; wrapping = store . getBoolean ( WRAPPING_KEY ) ; } private void saveDefaultEncoding ( ) { IPreferenceStore store = getPreferenceStore ( ) ; store . setValue ( DEFAULT_ENCODING_KEY , defaultEncoding ) ; } private void loadDefaultEncoding ( ) { IPreferenceStore store = getPreferenceStore ( ) ; defaultEncoding = store . getString ( DEFAULT_ENCODING_KEY ) ; } private void saveBacklogLines ( ) { IPreferenceStore store = getPreferenceStore ( ) ; store . setValue ( BACKLOG_LINES_KEY , backLogLines ) ; } private void loadBacklogLines ( ) { IPreferenceStore store = getPreferenceStore ( ) ; backLogLines = store . getInt ( BACKLOG_LINES_KEY ) ; } public void fillDefaultRules ( LoggingStructureProvider provider ) { loadRulesFromExtensions ( provider ) ; } private void loadRulesFromExtensions ( LoggingStructureProvider provider ) { IExtensionRegistry registry = Platform . getExtensionRegistry ( ) ; IExtensionPoint ep = registry . getExtensionPoint ( DEFAULT_RULES_POINT_ID ) ; if ( ep != null ) { IExtension [ ] extensions = ep . getExtensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { IExtension extension = extensions [ i ] ; IConfigurationElement [ ] elements = extension . getConfigurationElements ( ) ; for ( int j = 0 ; j < elements . length ; j ++ ) { IConfigurationElement element = elements [ j ] ; String elementName = element . getName ( ) ; if ( elementName . equals ( RULE_ELEMENT ) ) { String name = element . getAttribute ( NAME_ATTRIBVUTE ) ; String content = element . getAttribute ( CONTENT_ATTRIBUTE ) ; boolean isRegexp = getBooleanAttribute ( element , ISREGEXP_ATTRIBUTE , true ) ; boolean isCaseSensitive = getBooleanAttribute ( element , ISCASEINSENSITIVE_ATTRIBUTE , false ) ; boolean isBold = getBooleanAttribute ( element , BOLD_ATTRIBUTE , false ) ; boolean isItalic = getBooleanAttribute ( element , ITALIC_ATTRIBUTE , false ) ; boolean isUnderline = getBooleanAttribute ( element , UNDERLINE_ATTRIBUTE , false ) ; String colorString = element . getAttribute ( COLOR_ATTRIBUTE ) ; RGB color = new RGB ( 0 , 0 , 0 ) ; try { color = getRGB ( colorString ) ; } catch ( IllegalArgumentException ex ) { IdeLog . logError ( LoggingPlugin . getDefault ( ) , Messages . getString ( "LoggingPreferences.ERR_WrongFormat" ) + colorString ) ; } provider . addRule ( name , content , isRegexp , isCaseSensitive , color , isBold , isItalic , isUnderline ) ; } } } } } private RGB getRGB ( String colorString ) throws IllegalArgumentException { if ( colorString == null ) { throw new IllegalArgumentException ( "Null is not a valid RGB" ) ; } StringTokenizer tokenizer = new StringTokenizer ( colorString , "," ) ; try { String red = tokenizer . nextToken ( ) . trim ( ) ; String green = tokenizer . nextToken ( ) . trim ( ) ; String blue = tokenizer . nextToken ( ) . trim ( ) ; int rval = 0 , gval = 0 , bval = 0 ; rval = Integer . parseInt ( red ) ; gval = Integer . parseInt ( green ) ; bval = Integer . parseInt ( blue ) ; return new RGB ( rval , gval , bval ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } } private void initializeDefaultFont ( ) { Font defaultFont = JFaceResources . getDefaultFont ( ) ; FontData [ ] data = defaultFont . getFontData ( ) ; String osName = System . getProperty ( "os.name" , "Windows" ) ; int height = data [ 0 ] . getHeight ( ) ; if ( data != null && data . length > 0 ) { if ( osName . startsWith ( "Windows" ) ) { height = WINDOWS_DEFAULT_FONT_SIZE ; } else if ( osName . startsWith ( "Linux" ) ) { height = LINUX_DEFAULT_FONT_SIZE ; } else if ( osName . startsWith ( "Mac OS" ) ) { height = MAC_OS_DEFAULT_FONT_SIZE ; } } data [ 0 ] . setHeight ( height ) ; if ( supports ( DEFAULT_FONT_FAMILY , height ) ) { data [ 0 ] . setName ( DEFAULT_FONT_FAMILY ) ; } PreferenceConverter . setDefault ( getPreferenceStore ( ) , MAIN_TEXT_FONT_KEY , data ) ; } private boolean supports ( String name , int height ) { try { Font font = new Font ( Display . getCurrent ( ) , name , height , 0 ) ; font . dispose ( ) ; return true ; } catch ( SWTError error ) { return false ; } } private boolean getBooleanAttribute ( IConfigurationElement element , String name , boolean defaultValue ) { String attributeString = element . getAttribute ( name ) ; if ( attributeString == null ) { return defaultValue ; } return Boolean . parseBoolean ( attributeString ) ; } private void loadMainFont ( ) { if ( ! mainFontLoaded ) { FontData [ ] data = PreferenceConverter . getFontDataArray ( getPreferenceStore ( ) , MAIN_TEXT_FONT_KEY ) ; fontRegistry . put ( MAIN_TEXT_FONT_KEY , data ) ; mainFontLoaded = true ; } } LoggingPreferences ( ) { } } 
=======
public class ServiceContainer implements RequestHandler { private String domain ; private Map < String , MessageHandler > pathMap ; public ServiceContainer ( String domain ) { this . domain = domain ; this . pathMap = new HashMap < String , MessageHandler > ( ) ; } public String getDomain ( ) { return domain ; } public void bindName ( Address name , MessageHandler receiver ) { pathMap . put ( extractLocalname ( name ) , receiver ) ; } private String extractLocalname ( Address name ) { if ( name . getDomain ( ) . equals ( domain ) ) { return name . getLocalName ( ) ; } else { throw new IllegalArgumentException ( "Domain mismatch: " + name + ", " + domain ) ; } } public void handleRequest ( HttpRequest req ) { String targetLocalname = req . getRawPath ( ) . substring ( 1 ) ; Address target = new Address ( targetLocalname , domain ) ; String senderStr = req . getHeader ( "X-SMQP-Sender" ) ; Address sender = senderStr == null ? null : Address . parse ( senderStr ) ; String contentType = req . getHeader ( "Content-type" ) ; String method = req . getHeader ( "X-SMQP-Method" , "send" ) ; Message msg = new Message ( sender , target , req . getBody ( ) , contentType , method ) ; try { if ( pathMap . containsKey ( targetLocalname ) ) { MessageHandler handler = pathMap . get ( targetLocalname ) ; int responseCode = handler . handleMessage ( msg ) ; req . setResponse ( responseCode , "" ) ; } else { req . setResponse ( 404 , "Destination not found" ) ; } } catch ( Exception e ) { LogRecord r = new LogRecord ( Level . SEVERE , "Exception at " + target ) ; r . setThrown ( e ) ; Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( r ) ; req . setResponse ( 500 , "Internal error" ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
