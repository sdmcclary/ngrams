public abstract class SWTWorker < T , V > implements Future < T > , Runnable { private static final int MAX_WORKER_THREADS = 10 ; private volatile int progress ; private volatile StateValue state ; private final FutureTask < T > future ; private final PropertyChangeSupport propertyChangeSupport ; private AccumulativeRunnable < V > doProcess ; private AccumulativeRunnable < Integer > doNotifyProgressChange ; private AccumulativeRunnable < Runnable > doSubmit ; private static ExecutorService executorService = null ; private Display display ; public enum StateValue { PENDING , STARTED , DONE } ; public SWTWorker ( Display display ) { this . display = display ; doSubmit = new DoSubmitAccumulativeRunnable ( this . display ) ; Callable < T > callable = new Callable < T > ( ) { public T call ( ) throws Exception { setState ( StateValue . STARTED ) ; return doInBackground ( ) ; } } ; future = new FutureTask < T > ( callable ) { @ Override protected void done ( ) { doneEDT ( ) ; setState ( StateValue . DONE ) ; } } ; state = StateValue . PENDING ; propertyChangeSupport = new SWTPropertyChangeSupport ( this , this . display ) ; doProcess = null ; doNotifyProgressChange = null ; } protected abstract T doInBackground ( ) throws Exception ; public final void run ( ) { future . run ( ) ; } protected final void publish ( V ... chunks ) { synchronized ( this ) { if ( doProcess == null ) { doProcess = new AccumulativeRunnable < V > ( this . display ) { @ Override public void run ( List < V > args ) { process ( args ) ; } @ Override protected void submit ( ) { doSubmit . add ( this ) ; } } ; } } doProcess . add ( chunks ) ; } protected void process ( List < V > chunks ) { } protected void done ( ) { } protected final void setProgress ( int progress ) { if ( progress < 0 || progress > 100 ) { throw new IllegalArgumentException ( "the value should be from 0 to 100" ) ; } if ( this . progress == progress ) { return ; } int oldProgress = this . progress ; this . progress = progress ; if ( ! getPropertyChangeSupport ( ) . hasListeners ( "progress" ) ) { return ; } synchronized ( this ) { if ( doNotifyProgressChange == null ) { doNotifyProgressChange = new AccumulativeRunnable < Integer > ( this . display ) { @ Override public void run ( List < Integer > args ) { firePropertyChange ( "progress" , args . get ( 0 ) , args . get ( args . size ( ) - 1 ) ) ; } @ Override protected void submit ( ) { doSubmit . add ( this ) ; } } ; } } doNotifyProgressChange . add ( oldProgress , progress ) ; } public final int getProgress ( ) { return progress ; } public final void execute ( ) { getWorkersExecutorService ( ) . execute ( this ) ; } public final boolean cancel ( boolean mayInterruptIfRunning ) { return future . cancel ( mayInterruptIfRunning ) ; } public final boolean isCancelled ( ) { return future . isCancelled ( ) ; } public final boolean isDone ( ) { return future . isDone ( ) ; } public final T get ( ) throws InterruptedException , ExecutionException { return future . get ( ) ; } public final T get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { return future . get ( timeout , unit ) ; } public final void addPropertyChangeListener ( PropertyChangeListener listener ) { getPropertyChangeSupport ( ) . addPropertyChangeListener ( listener ) ; } public final void removePropertyChangeListener ( PropertyChangeListener listener ) { getPropertyChangeSupport ( ) . removePropertyChangeListener ( listener ) ; } public final void firePropertyChange ( String propertyName , Object oldValue , Object newValue ) { getPropertyChangeSupport ( ) . firePropertyChange ( propertyName , oldValue , newValue ) ; } public final PropertyChangeSupport getPropertyChangeSupport ( ) { return propertyChangeSupport ; } public final StateValue getState ( ) { if ( isDone ( ) ) { return StateValue . DONE ; } else { return state ; } } private void setState ( StateValue state ) { StateValue old = this . state ; this . state = state ; firePropertyChange ( "state" , old , state ) ; } private void doneEDT ( ) { Runnable doDone = new Runnable ( ) { public void run ( ) { done ( ) ; } } ; if ( Thread . currentThread ( ) . equals ( this . display . getThread ( ) ) ) { doDone . run ( ) ; } else { doSubmit . add ( doDone ) ; } } private static synchronized ExecutorService getWorkersExecutorService ( ) { if ( executorService == null ) { ThreadFactory threadFactory = new ThreadFactory ( ) { final AtomicInteger threadNumber = new AtomicInteger ( 1 ) ; public Thread newThread ( final Runnable r ) { StringBuilder name = new StringBuilder ( "SwingWorker-pool-" ) ; name . append ( System . identityHashCode ( this ) ) ; name . append ( "-thread-" ) ; name . append ( threadNumber . getAndIncrement ( ) ) ; Thread t = new Thread ( r , name . toString ( ) ) ; ; if ( t . isDaemon ( ) ) t . setDaemon ( false ) ; if ( t . getPriority ( ) != Thread . NORM_PRIORITY ) t . setPriority ( Thread . NORM_PRIORITY ) ; return t ; } } ; executorService = new ThreadPoolExecutor ( 0 , MAX_WORKER_THREADS , 5L , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( ) , threadFactory ) { private final ReentrantLock pauseLock = new ReentrantLock ( ) ; private final Condition unpaused = pauseLock . newCondition ( ) ; private boolean isPaused = false ; private final ReentrantLock executeLock = new ReentrantLock ( ) ; @ Override public void execute ( Runnable command ) { executeLock . lock ( ) ; try { pauseLock . lock ( ) ; try { isPaused = true ; } finally { pauseLock . unlock ( ) ; } setCorePoolSize ( MAX_WORKER_THREADS ) ; super . execute ( command ) ; setCorePoolSize ( 0 ) ; pauseLock . lock ( ) ; try { isPaused = false ; unpaused . signalAll ( ) ; } finally { pauseLock . unlock ( ) ; } } finally { executeLock . unlock ( ) ; } } @ Override protected void afterExecute ( Runnable r , Throwable t ) { super . afterExecute ( r , t ) ; pauseLock . lock ( ) ; try { while ( isPaused ) { unpaused . await ( ) ; } } catch ( InterruptedException ignore ) { } finally { pauseLock . unlock ( ) ; } } } ; } return executorService ; } private static class DoSubmitAccumulativeRunnable extends AccumulativeRunnable < Runnable > implements ActionListener { private final static int DELAY = ( int ) ( 1000 / 30 ) ; DoSubmitAccumulativeRunnable ( Display display ) { super ( display ) ; } @ Override protected void run ( List < Runnable > args ) { int i = 0 ; try { for ( Runnable runnable : args ) { i ++ ; runnable . run ( ) ; } } finally { if ( i < args . size ( ) ) { Runnable argsTail [ ] = new Runnable [ args . size ( ) - i ] ; for ( int j = 0 ; j < argsTail . length ; j ++ ) { argsTail [ j ] = args . get ( i + j ) ; } add ( true , argsTail ) ; } } } @ Override protected void submit ( ) { final Runnable timer = new Runnable ( ) { public void run ( ) { DoSubmitAccumulativeRunnable . this . run ( ) ; DoSubmitAccumulativeRunnable . this . display . timerExec ( - 1 , this ) ; } } ; this . display . asyncExec ( new Runnable ( ) { public void run ( ) { DoSubmitAccumulativeRunnable . this . display . timerExec ( DELAY , timer ) ; } } ) ; } public void actionPerformed ( ActionEvent event ) { run ( ) ; } } } 