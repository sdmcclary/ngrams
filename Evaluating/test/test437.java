public class ConcurrentSkipListSet < E > extends AbstractSet < E > implements NavigableSet < E > , Cloneable , java . io . Serializable { private static final long serialVersionUID = - 2479143111061671589L ; private final ConcurrentSkipListMap < E , Object > m ; public ConcurrentSkipListSet ( ) { m = new ConcurrentSkipListMap < E , Object > ( ) ; } public ConcurrentSkipListSet ( Comparator < ? super E > c ) { m = new ConcurrentSkipListMap < E , Object > ( c ) ; } public ConcurrentSkipListSet ( Collection < ? extends E > c ) { m = new ConcurrentSkipListMap < E , Object > ( ) ; addAll ( c ) ; } public ConcurrentSkipListSet ( SortedSet < E > s ) { m = new ConcurrentSkipListMap < E , Object > ( s . comparator ( ) ) ; addAll ( s ) ; } public Object clone ( ) { ConcurrentSkipListSet < E > clone = null ; try { clone = ( ConcurrentSkipListSet < E > ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( ) ; } clone . m . initialize ( ) ; clone . addAll ( this ) ; return clone ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean add ( E o ) { return m . putIfAbsent ( o , Boolean . TRUE ) == null ; } public boolean remove ( Object o ) { return m . removep ( o ) ; } public void clear ( ) { m . clear ( ) ; } public Iterator < E > iterator ( ) { return m . keyIterator ( ) ; } public Iterator < E > descendingIterator ( ) { return m . descendingKeyIterator ( ) ; } public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Set ) ) return false ; Collection c = ( Collection ) o ; try { return containsAll ( c ) && c . containsAll ( this ) ; } catch ( ClassCastException unused ) { return false ; } catch ( NullPointerException unused ) { return false ; } } public boolean removeAll ( Collection < ? > c ) { boolean modified = false ; for ( Iterator < ? > i = c . iterator ( ) ; i . hasNext ( ) ; ) if ( remove ( i . next ( ) ) ) modified = true ; return modified ; } public E ceiling ( E o ) { return m . ceilingKey ( o ) ; } public E lower ( E o ) { return m . lowerKey ( o ) ; } public E floor ( E o ) { return m . floorKey ( o ) ; } public E higher ( E o ) { return m . higherKey ( o ) ; } public E pollFirst ( ) { return m . pollFirstKey ( ) ; } public E pollLast ( ) { return m . pollLastKey ( ) ; } public Comparator < ? super E > comparator ( ) { return m . comparator ( ) ; } public E first ( ) { return m . firstKey ( ) ; } public E last ( ) { return m . lastKey ( ) ; } public NavigableSet < E > subSet ( E fromElement , E toElement ) { return new ConcurrentSkipListSubSet < E > ( m , fromElement , toElement ) ; } public NavigableSet < E > headSet ( E toElement ) { return new ConcurrentSkipListSubSet < E > ( m , null , toElement ) ; } public NavigableSet < E > tailSet ( E fromElement ) { return new ConcurrentSkipListSubSet < E > ( m , fromElement , null ) ; } static class ConcurrentSkipListSubSet < E > extends AbstractSet < E > implements NavigableSet < E > , java . io . Serializable { private static final long serialVersionUID = - 7647078645896651609L ; private final ConcurrentSkipListMap . ConcurrentSkipListSubMap < E , Object > s ; ConcurrentSkipListSubSet ( ConcurrentSkipListMap < E , Object > map , E fromElement , E toElement ) { s = new ConcurrentSkipListMap . ConcurrentSkipListSubMap < E , Object > ( map , fromElement , toElement ) ; } public NavigableSet < E > subSet ( E fromElement , E toElement ) { if ( ! s . inOpenRange ( fromElement ) || ! s . inOpenRange ( toElement ) ) throw new IllegalArgumentException ( "element out of range" ) ; return new ConcurrentSkipListSubSet < E > ( s . getMap ( ) , fromElement , toElement ) ; } public NavigableSet < E > headSet ( E toElement ) { E least = s . getLeast ( ) ; if ( ! s . inOpenRange ( toElement ) ) throw new IllegalArgumentException ( "element out of range" ) ; return new ConcurrentSkipListSubSet < E > ( s . getMap ( ) , least , toElement ) ; } public NavigableSet < E > tailSet ( E fromElement ) { E fence = s . getFence ( ) ; if ( ! s . inOpenRange ( fromElement ) ) throw new IllegalArgumentException ( "element out of range" ) ; return new ConcurrentSkipListSubSet < E > ( s . getMap ( ) , fromElement , fence ) ; } public int size ( ) { return s . size ( ) ; } public boolean isEmpty ( ) { return s . isEmpty ( ) ; } public boolean contains ( Object o ) { return s . containsKey ( o ) ; } public void clear ( ) { s . clear ( ) ; } public E first ( ) { return s . firstKey ( ) ; } public E last ( ) { return s . lastKey ( ) ; } public E ceiling ( E o ) { return s . ceilingKey ( o ) ; } public E lower ( E o ) { return s . lowerKey ( o ) ; } public E floor ( E o ) { return s . floorKey ( o ) ; } public E higher ( E o ) { return s . higherKey ( o ) ; } public boolean remove ( Object o ) { return s . remove ( o ) == Boolean . TRUE ; } public boolean add ( E o ) { return s . put ( o , Boolean . TRUE ) == null ; } public Comparator < ? super E > comparator ( ) { return s . comparator ( ) ; } public Iterator < E > iterator ( ) { return s . keySet ( ) . iterator ( ) ; } public Iterator < E > descendingIterator ( ) { return s . descendingKeySet ( ) . iterator ( ) ; } public E pollFirst ( ) { Map . Entry < E , ? > e = s . pollFirstEntry ( ) ; return ( e == null ) ? null : e . getKey ( ) ; } public E pollLast ( ) { Map . Entry < E , ? > e = s . pollLastEntry ( ) ; return ( e == null ) ? null : e . getKey ( ) ; } } } 