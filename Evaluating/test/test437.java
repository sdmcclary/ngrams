<<<<<<< HEAD
public class ConcurrentSkipListSet < E > extends AbstractSet < E > implements NavigableSet < E > , Cloneable , java . io . Serializable { private static final long serialVersionUID = - 2479143111061671589L ; private final ConcurrentSkipListMap < E , Object > m ; public ConcurrentSkipListSet ( ) { m = new ConcurrentSkipListMap < E , Object > ( ) ; } public ConcurrentSkipListSet ( Comparator < ? super E > c ) { m = new ConcurrentSkipListMap < E , Object > ( c ) ; } public ConcurrentSkipListSet ( Collection < ? extends E > c ) { m = new ConcurrentSkipListMap < E , Object > ( ) ; addAll ( c ) ; } public ConcurrentSkipListSet ( SortedSet < E > s ) { m = new ConcurrentSkipListMap < E , Object > ( s . comparator ( ) ) ; addAll ( s ) ; } public Object clone ( ) { ConcurrentSkipListSet < E > clone = null ; try { clone = ( ConcurrentSkipListSet < E > ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( ) ; } clone . m . initialize ( ) ; clone . addAll ( this ) ; return clone ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean add ( E o ) { return m . putIfAbsent ( o , Boolean . TRUE ) == null ; } public boolean remove ( Object o ) { return m . removep ( o ) ; } public void clear ( ) { m . clear ( ) ; } public Iterator < E > iterator ( ) { return m . keyIterator ( ) ; } public Iterator < E > descendingIterator ( ) { return m . descendingKeyIterator ( ) ; } public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Set ) ) return false ; Collection c = ( Collection ) o ; try { return containsAll ( c ) && c . containsAll ( this ) ; } catch ( ClassCastException unused ) { return false ; } catch ( NullPointerException unused ) { return false ; } } public boolean removeAll ( Collection < ? > c ) { boolean modified = false ; for ( Iterator < ? > i = c . iterator ( ) ; i . hasNext ( ) ; ) if ( remove ( i . next ( ) ) ) modified = true ; return modified ; } public E ceiling ( E o ) { return m . ceilingKey ( o ) ; } public E lower ( E o ) { return m . lowerKey ( o ) ; } public E floor ( E o ) { return m . floorKey ( o ) ; } public E higher ( E o ) { return m . higherKey ( o ) ; } public E pollFirst ( ) { return m . pollFirstKey ( ) ; } public E pollLast ( ) { return m . pollLastKey ( ) ; } public Comparator < ? super E > comparator ( ) { return m . comparator ( ) ; } public E first ( ) { return m . firstKey ( ) ; } public E last ( ) { return m . lastKey ( ) ; } public NavigableSet < E > subSet ( E fromElement , E toElement ) { return new ConcurrentSkipListSubSet < E > ( m , fromElement , toElement ) ; } public NavigableSet < E > headSet ( E toElement ) { return new ConcurrentSkipListSubSet < E > ( m , null , toElement ) ; } public NavigableSet < E > tailSet ( E fromElement ) { return new ConcurrentSkipListSubSet < E > ( m , fromElement , null ) ; } static class ConcurrentSkipListSubSet < E > extends AbstractSet < E > implements NavigableSet < E > , java . io . Serializable { private static final long serialVersionUID = - 7647078645896651609L ; private final ConcurrentSkipListMap . ConcurrentSkipListSubMap < E , Object > s ; ConcurrentSkipListSubSet ( ConcurrentSkipListMap < E , Object > map , E fromElement , E toElement ) { s = new ConcurrentSkipListMap . ConcurrentSkipListSubMap < E , Object > ( map , fromElement , toElement ) ; } public NavigableSet < E > subSet ( E fromElement , E toElement ) { if ( ! s . inOpenRange ( fromElement ) || ! s . inOpenRange ( toElement ) ) throw new IllegalArgumentException ( "element out of range" ) ; return new ConcurrentSkipListSubSet < E > ( s . getMap ( ) , fromElement , toElement ) ; } public NavigableSet < E > headSet ( E toElement ) { E least = s . getLeast ( ) ; if ( ! s . inOpenRange ( toElement ) ) throw new IllegalArgumentException ( "element out of range" ) ; return new ConcurrentSkipListSubSet < E > ( s . getMap ( ) , least , toElement ) ; } public NavigableSet < E > tailSet ( E fromElement ) { E fence = s . getFence ( ) ; if ( ! s . inOpenRange ( fromElement ) ) throw new IllegalArgumentException ( "element out of range" ) ; return new ConcurrentSkipListSubSet < E > ( s . getMap ( ) , fromElement , fence ) ; } public int size ( ) { return s . size ( ) ; } public boolean isEmpty ( ) { return s . isEmpty ( ) ; } public boolean contains ( Object o ) { return s . containsKey ( o ) ; } public void clear ( ) { s . clear ( ) ; } public E first ( ) { return s . firstKey ( ) ; } public E last ( ) { return s . lastKey ( ) ; } public E ceiling ( E o ) { return s . ceilingKey ( o ) ; } public E lower ( E o ) { return s . lowerKey ( o ) ; } public E floor ( E o ) { return s . floorKey ( o ) ; } public E higher ( E o ) { return s . higherKey ( o ) ; } public boolean remove ( Object o ) { return s . remove ( o ) == Boolean . TRUE ; } public boolean add ( E o ) { return s . put ( o , Boolean . TRUE ) == null ; } public Comparator < ? super E > comparator ( ) { return s . comparator ( ) ; } public Iterator < E > iterator ( ) { return s . keySet ( ) . iterator ( ) ; } public Iterator < E > descendingIterator ( ) { return s . descendingKeySet ( ) . iterator ( ) ; } public E pollFirst ( ) { Map . Entry < E , ? > e = s . pollFirstEntry ( ) ; return ( e == null ) ? null : e . getKey ( ) ; } public E pollLast ( ) { Map . Entry < E , ? > e = s . pollLastEntry ( ) ; return ( e == null ) ? null : e . getKey ( ) ; } } } 
=======
abstract class AbstractDatetime extends AbstractDatatype { private static int [ ] DAYS_IN_MONTHS = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; AbstractDatetime ( ) { super ( ) ; } private void checkMonth ( String year , String month ) throws DatatypeException { checkMonth ( Integer . parseInt ( year ) , Integer . parseInt ( month ) ) ; } private void checkMonth ( int year , int month ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } } private void checkDate ( String year , String month , String day ) throws DatatypeException { checkDate ( Integer . parseInt ( year ) , Integer . parseInt ( month ) , Integer . parseInt ( day ) ) ; } private void checkDate ( int year , int month , int day ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } if ( day < 1 ) { throw newDatatypeException ( "Day cannot be less than 1." ) ; } if ( day > DAYS_IN_MONTHS [ month - 1 ] ) { if ( ! ( day == 29 && month == 2 && isLeapYear ( year ) ) ) { throw newDatatypeException ( "Day out of range." ) ; } } } private boolean isLeapYear ( int year ) { return ( year % 400 == 0 ) || ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) ; } private void checkYearlessDate ( String month , String day ) throws DatatypeException { checkYearlessDate ( Integer . parseInt ( month ) , Integer . parseInt ( day ) ) ; } private void checkYearlessDate ( int month , int day ) throws DatatypeException { if ( month < 1 ) { throw newDatatypeException ( "Month cannot be less than 1." ) ; } if ( month > 12 ) { throw newDatatypeException ( "Month cannot be greater than 12." ) ; } if ( day < 1 ) { throw newDatatypeException ( "Day cannot be less than 1." ) ; } } private void checkWeek ( String year , String week ) throws DatatypeException { checkWeek ( Integer . parseInt ( year ) , Integer . parseInt ( week ) ) ; } private void checkWeek ( int year , int week ) throws DatatypeException { if ( year < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } if ( week < 1 ) { throw newDatatypeException ( "Week cannot be less than 1." ) ; } if ( week > 53 ) { throw newDatatypeException ( "Week cannot be greater than 53." ) ; } } protected final void checkHour ( String hour ) throws DatatypeException { checkHour ( Integer . parseInt ( hour ) ) ; } private void checkHour ( int hour ) throws DatatypeException { if ( hour > 23 ) { throw newDatatypeException ( "Hour cannot be greater than 23." ) ; } } protected final void checkMinute ( String minute ) throws DatatypeException { checkMinute ( Integer . parseInt ( minute ) ) ; } private void checkMinute ( int minute ) throws DatatypeException { if ( minute > 59 ) { throw newDatatypeException ( "Minute cannot be greater than 59." ) ; } } protected final void checkSecond ( String second ) throws DatatypeException { checkSecond ( Integer . parseInt ( second ) ) ; } private void checkSecond ( int second ) throws DatatypeException { if ( second > 59 ) { throw newDatatypeException ( "Second cannot be greater than 59." ) ; } } protected final void checkMilliSecond ( String millisecond ) throws DatatypeException { if ( millisecond . length ( ) > 3 ) { throw newDatatypeException ( "A fraction of a second must be one, two, or three digits." ) ; } } private void checkTzd ( String hours , String minutes ) throws DatatypeException { if ( hours . charAt ( 0 ) == '+' ) { hours = hours . substring ( 1 ) ; } checkTzd ( Integer . parseInt ( hours ) , Integer . parseInt ( minutes ) ) ; } private void checkTzd ( int hours , int minutes ) throws DatatypeException { if ( hours < - 23 || hours > 23 ) { throw newDatatypeException ( "Hours out of range in time zone designator." ) ; } if ( minutes > 59 ) { throw newDatatypeException ( "Minutes out of range in time zone designator." ) ; } } protected abstract Pattern getPattern ( ) ; public void checkValid ( CharSequence literal ) throws DatatypeException { String year ; String month ; String day ; String hour ; String minute ; String seconds ; String milliseconds ; String tzdHours ; String tzdMinutes ; Matcher m = getPattern ( ) . matcher ( literal ) ; if ( m . matches ( ) ) { year = m . group ( 1 ) ; month = m . group ( 2 ) ; if ( year != null ) { checkMonth ( year , month ) ; return ; } year = m . group ( 3 ) ; month = m . group ( 4 ) ; day = m . group ( 5 ) ; if ( year != null ) { checkDate ( year , month , day ) ; return ; } month = m . group ( 6 ) ; day = m . group ( 7 ) ; if ( year != null ) { checkYearlessDate ( month , day ) ; return ; } hour = m . group ( 8 ) ; minute = m . group ( 9 ) ; seconds = m . group ( 10 ) ; milliseconds = m . group ( 11 ) ; if ( hour != null ) { checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } return ; } year = m . group ( 12 ) ; month = m . group ( 13 ) ; day = m . group ( 14 ) ; hour = m . group ( 15 ) ; minute = m . group ( 16 ) ; seconds = m . group ( 17 ) ; milliseconds = m . group ( 18 ) ; if ( year != null ) { checkDate ( year , month , day ) ; checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } return ; } tzdHours = m . group ( 19 ) ; tzdMinutes = m . group ( 20 ) ; if ( tzdHours != null ) { checkTzd ( tzdHours , tzdMinutes ) ; return ; } year = m . group ( 21 ) ; month = m . group ( 22 ) ; day = m . group ( 23 ) ; hour = m . group ( 24 ) ; minute = m . group ( 25 ) ; seconds = m . group ( 26 ) ; milliseconds = m . group ( 27 ) ; tzdHours = m . group ( 28 ) ; tzdMinutes = m . group ( 29 ) ; if ( year != null ) { checkDate ( year , month , day ) ; checkHour ( hour ) ; checkMinute ( minute ) ; if ( seconds != null ) { checkSecond ( seconds ) ; } if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; } if ( tzdHours != null ) { checkTzd ( tzdHours , tzdMinutes ) ; } return ; } year = m . group ( 30 ) ; String week = m . group ( 31 ) ; if ( year != null ) { checkWeek ( year , week ) ; } year = m . group ( 32 ) ; if ( year != null && Integer . parseInt ( year ) < 1 ) { throw newDatatypeException ( "Year cannot be less than 1." ) ; } milliseconds = m . group ( 33 ) ; if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; return ; } milliseconds = m . group ( 34 ) ; if ( milliseconds != null ) { checkMilliSecond ( milliseconds ) ; return ; } } else { throw newDatatypeException ( "The literal did not satisfy the " + getName ( ) + " format." ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
