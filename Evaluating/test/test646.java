<<<<<<< HEAD
public class UnifiedErrorManager implements IErrorManager , IPropertyChangeListener { ErrorDescriptor [ ] _errorDescriptors ; protected FileService fileService ; String mimeType ; ValidatorRef [ ] validators ; public UnifiedErrorManager ( FileService fileService , String mimeType ) { this . fileService = fileService ; this . mimeType = mimeType ; if ( getPreferenceStore ( ) != null ) { getPreferenceStore ( ) . addPropertyChangeListener ( this ) ; } initializeValidators ( ) ; } public void onContentChanged ( FileContextContentEvent evt ) { if ( evt . getSource ( ) != fileService ) { return ; } IFileSourceProvider sourceProvider = fileService . getSourceProvider ( ) ; String path = CoreUIUtils . getPathFromURI ( sourceProvider . getSourceURI ( ) ) ; String sourceString = null ; try { sourceString = sourceProvider . getSource ( ) ; } catch ( IOException e1 ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedErrorManager_Error , e1 ) ; return ; } if ( sourceProvider instanceof DocumentSourceProvider ) { IFileError [ ] errors = parseForErrors ( path , sourceString , sourceProvider ) ; fileService . setFileErrors ( errors ) ; } } public boolean showInfos ( ) { return ShowInfos . isInstanceChecked ( ) ; } public boolean showWarnings ( ) { return ShowWarnings . isInstanceChecked ( ) ; } public boolean showErrors ( ) { return ShowErrors . isInstanceChecked ( ) ; } public IFileError [ ] parseForErrors ( String path , String source , IFileSourceProvider sourceProvider ) { loadErrorDescriptors ( ) ; UnifiedErrorReporter reporter = new UnifiedErrorReporter ( sourceProvider ) ; if ( validators != null ) { for ( ValidatorRef validatorRef : validators ) { try { IFileError [ ] errors = validatorRef . parseForErrors ( path , source , sourceProvider , showErrors ( ) , showWarnings ( ) , showInfos ( ) ) ; if ( errors != null & errors . length > 0 ) { reporter . addErrors ( errors ) ; } } catch ( Exception ex ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedErrorManager_ValidatorRefParseDelegationError , ex ) ; } } } return filterMessages ( reporter . getErrors ( ) ) ; } private IFileError [ ] filterMessages ( IFileError [ ] errors ) { if ( errors == null ) return new IFileError [ 0 ] ; List < IFileError > newErrors = new ArrayList < IFileError > ( ) ; for ( IFileError error : errors ) { if ( filterMessage ( error . getMessage ( ) ) != null ) { newErrors . add ( error ) ; } } return ( IFileError [ ] ) newErrors . toArray ( new IFileError [ newErrors . size ( ) ] ) ; } public String filterMessage ( String msg ) { if ( isFiltered ( IMarker . SEVERITY_INFO , msg ) ) { return null ; } else { return msg ; } } private void loadErrorDescriptors ( ) { IPreferenceStore store = getPreferenceStore ( ) ; if ( store != null ) { String editors = store . getString ( IPreferenceConstants . IGNORE_PROBLEMS ) ; _errorDescriptors = ErrorDescriptor . deserializeErrorDescriptors ( editors ) ; } } protected boolean isFiltered ( int severity , String message ) { if ( _errorDescriptors == null ) { return false ; } FileError fe = new FileError ( ) ; fe . setMessage ( message ) ; for ( int i = 0 ; i < _errorDescriptors . length ; i ++ ) { ErrorDescriptor ed = _errorDescriptors [ i ] ; if ( ed . matchesError ( fe ) ) { return true ; } } return false ; } protected IPreferenceStore getPreferenceStore ( ) { return null ; } public void propertyChange ( PropertyChangeEvent event ) { String property = event . getProperty ( ) ; if ( IPreferenceConstants . IGNORE_PROBLEMS . equals ( property ) && fileService != null ) { fileService . forceContentChangedEvent ( ) ; } else if ( IPreferenceConstants . VALIDATORS_LIST . equals ( property ) ) { initializeValidators ( ) ; fileService . forceContentChangedEvent ( ) ; } } private void initializeValidators ( ) { ValidatorRef [ ] registeredValidators = ValidatorManager . getInstance ( ) . getValidators ( mimeType ) ; IPreferenceStore preferenceStore = getPreferenceStore ( ) ; if ( preferenceStore != null ) { String property = preferenceStore . getString ( IPreferenceConstants . VALIDATORS_LIST ) ; if ( property != null && property . length ( ) > 0 ) { String [ ] preferredValidators = property . split ( "," ) ; ArrayList newValidators = new ArrayList ( ) ; for ( int i = 0 ; i < preferredValidators . length ; i ++ ) { for ( int j = 0 ; j < registeredValidators . length ; j ++ ) { if ( preferredValidators [ i ] . equals ( registeredValidators [ j ] . getName ( ) ) ) { newValidators . add ( registeredValidators [ j ] ) ; continue ; } } } validators = ( ValidatorRef [ ] ) newValidators . toArray ( new ValidatorRef [ 0 ] ) ; } else { validators = registeredValidators ; } } else { IdeLog . logInfo ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedErrorManager_PreferenceRetrievalError ) ; validators = registeredValidators ; } } public String processLanguagePartition ( ITypedRegion partition , String source ) { return source ; } protected String stripChars ( String source , int start , int length ) { char [ ] c = source . toCharArray ( ) ; int end = start + length ; if ( end > c . length ) { end = c . length ; } for ( int i = start ; i < end ; i ++ ) { if ( c [ i ] != '\r' && c [ i ] != '\n' ) { c [ i ] = ' ' ; } } return new String ( c ) ; } } 
=======
public class DataUriException extends IOException { private final int index ; private final String head ; private final char literal ; private final String tail ; public DataUriException ( int index , String head , char literal , String tail ) { super ( head + '“' + literal + '”' + tail ) ; this . index = index ; this . head = head ; this . literal = literal ; this . tail = tail ; } public int getIndex ( ) { return index ; } public String getHead ( ) { return head ; } public char getLiteral ( ) { return literal ; } public String getTail ( ) { return tail ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
