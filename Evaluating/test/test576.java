public class CSSAutoIndentStrategy extends UnifiedAutoIndentStrategy { private String linePrefix ; public CSSAutoIndentStrategy ( EditorFileContext context , SourceViewerConfiguration configuration , ISourceViewer sourceViewer ) { super ( context , configuration , sourceViewer ) ; } public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { if ( command . text == null || command . length > 0 ) { return ; } if ( UnifiedConfiguration . isNewlineString ( command . text ) ) { if ( isIndentComment ( document , command ) ) { indentCommentAfterNewLine ( document , command ) ; } else if ( ! indentAfterOpenBrace ( document , command ) ) { super . customizeDocumentCommand ( document , command ) ; } } else { super . customizeDocumentCommand ( document , command ) ; } } private boolean isIndentComment ( IDocument document , DocumentCommand command ) { LexemeList lexemeList = getLexemeList ( ) ; int lexemeFloorIndex = lexemeList . getLexemeFloorIndex ( command . offset ) ; if ( lexemeFloorIndex == - 1 ) { return false ; } Lexeme lexemeFromOffset = lexemeList . get ( lexemeFloorIndex ) ; if ( lexemeFromOffset == null ) { return false ; } int typeIndex = lexemeFromOffset . getToken ( ) . getTypeIndex ( ) ; return typeIndex == CSSTokenTypes . COMMENT ; } public IPreferenceStore getPreferenceStore ( ) { return CSSPlugin . getDefault ( ) . getPreferenceStore ( ) ; } protected LexemeList getLexemeList ( ) { CSSFileLanguageService ls = ( CSSFileLanguageService ) context . getLanguageService ( CSSMimeType . MimeType ) ; return ls . getFileContext ( ) . getLexemeList ( ) ; } protected char [ ] getAutoInsertCharacters ( ) { return new char [ ] { } ; } protected boolean indentCloseToken ( IDocument doc , DocumentCommand c , int offset , int lineOffset , int firstNonWS ) { boolean isClose = false ; if ( doc . getLength ( ) < 2 || offset < 2 ) { isClose = true ; } else { try { if ( doc . getChar ( offset - 1 ) == '/' && doc . getChar ( offset - 2 ) == '*' ) { isClose = true ; } } catch ( BadLocationException e ) { } } if ( isClose ) { String append = getIndentationString ( doc , lineOffset , firstNonWS ) ; if ( append . endsWith ( " " ) ) { append = append . substring ( 0 , append . length ( ) - 1 ) ; } c . text += append ; return true ; } return false ; } protected void indentCommentAfterNewLine ( IDocument d , DocumentCommand c ) { int offset = c . offset ; if ( offset == - 1 || d . getLength ( ) == 0 ) { return ; } try { int p = ( offset == d . getLength ( ) ? offset - 1 : offset ) ; IRegion line = d . getLineInformationOfOffset ( p ) ; int lineOffset = line . getOffset ( ) ; int firstNonWS = findEndOfWhiteSpace ( d , lineOffset , offset ) ; if ( indentCloseToken ( d , c , offset , lineOffset , firstNonWS ) ) { return ; } if ( ( d . getLength ( ) > firstNonWS + 1 ) && ( d . getChar ( firstNonWS + 1 ) == '/' ) ) { super . indentAfterNewLine ( d , c ) ; return ; } IPreferenceStore store = CSSPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean useStar = true ; if ( store != null ) { useStar = true ; } linePrefix = useStar ? "* " : " " ; StringBuffer buf = new StringBuffer ( c . text ) ; IRegion prefix = findPrefixRange ( d , line ) ; String indentation = d . get ( prefix . getOffset ( ) , prefix . getLength ( ) ) ; int lengthToAdd = Math . min ( offset - prefix . getOffset ( ) , prefix . getLength ( ) ) ; buf . append ( indentation . substring ( 0 , lengthToAdd ) ) ; if ( firstNonWS < offset ) { if ( d . getChar ( firstNonWS ) == '/' ) { buf . append ( " " + linePrefix ) ; if ( isNewComment ( d , offset ) ) { c . shiftsCaret = false ; c . caretOffset = c . offset + buf . length ( ) ; String lineDelimiter = TextUtilities . getDefaultLineDelimiter ( d ) ; String endTag = lineDelimiter + indentation + " */" ; if ( d . getLength ( ) > firstNonWS + 2 && d . getChar ( firstNonWS + 1 ) == '*' ) { d . replace ( offset , 0 , endTag ) ; } else { buf . append ( endTag ) ; } } } } if ( lengthToAdd < prefix . getLength ( ) ) { c . caretOffset = offset + prefix . getLength ( ) - lengthToAdd ; } c . text = buf . toString ( ) ; } catch ( BadLocationException excp ) { } } protected boolean isNewComment ( IDocument document , int commandOffset ) { try { int lineIndex = document . getLineOfOffset ( commandOffset ) + 1 ; if ( lineIndex >= document . getNumberOfLines ( ) ) { return true ; } IRegion line = document . getLineInformation ( lineIndex ) ; ITypedRegion partition = TextUtilities . getPartition ( document , UnifiedConfiguration . UNIFIED_PARTITIONING , commandOffset , false ) ; int partitionEnd = partition . getOffset ( ) + partition . getLength ( ) - 1 ; if ( line . getOffset ( ) >= partitionEnd ) { return true ; } String comment = this . getLexemeList ( ) . getLexemeFromOffset ( commandOffset ) . getText ( ) ; if ( ! comment . endsWith ( "*/" ) ) { return true ; } int firstNewline = comment . indexOf ( '\n' ) ; if ( comment . length ( ) < 4 ) { return true ; } if ( comment . startsWith ( "/**/" ) ) { return false ; } if ( firstNewline > - 1 && firstNewline <= comment . length ( ) ) { String subComment = comment . substring ( firstNewline ) . trim ( ) ; if ( subComment . startsWith ( "*" ) ) { return false ; } if ( subComment . indexOf ( "\n" ) == - 1 ) { return true ; } } if ( comment . indexOf ( "/*" , 2 ) != - 1 ) { return true ; } return false ; } catch ( BadLocationException e ) { return false ; } } protected IRegion findPrefixRange ( IDocument document , IRegion line ) throws BadLocationException { int lineOffset = line . getOffset ( ) ; int lineEnd = lineOffset + line . getLength ( ) ; int indentEnd = findEndOfWhiteSpace ( document , lineOffset , lineEnd ) ; if ( indentEnd < lineEnd && document . get ( indentEnd , linePrefix . length ( ) ) . equals ( linePrefix ) ) { indentEnd ++ ; while ( indentEnd < lineEnd && document . getChar ( indentEnd ) == ' ' ) { indentEnd ++ ; } } return new Region ( lineOffset , indentEnd - lineOffset ) ; } } 