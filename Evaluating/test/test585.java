public class HTMLContentAssistProcessor extends UnifiedContentAssistProcessor implements IContentAssistProcessor { private IContextInformationValidator validator ; private static Map < String , String > entities ; private static Image fIconField = UnifiedEditorsPlugin . getImage ( "icons/field_public.gif" ) ; private static Image fIconFieldGuess = UnifiedEditorsPlugin . getImage ( "icons/field_public_guess.gif" ) ; private static Image fIconTag = UnifiedEditorsPlugin . getImage ( "icons/html_tag.gif" ) ; private static Image fIconTagGuess = UnifiedEditorsPlugin . getImage ( "icons/html_tag_guess.gif" ) ; private static Image fIconEvent = UnifiedEditorsPlugin . getImage ( "icons/event.gif" ) ; private static Image fIconFile = UnifiedEditorsPlugin . getImage ( "icons/file.gif" ) ; private static Image fIconFolder = UnifiedEditorsPlugin . getImage ( "icons/folder.gif" ) ; private HTMLCompletionProposalComparator contentAssistComparator ; private String AUTO_ADDED = "Auto-added from environment" ; public static String ERROR = "ERROR" ; public static String OUTSIDE_ELEMENT = "OUTSIDE_ELEMENT" ; public static String INSIDE_OPEN_ELEMENT = "INSIDE_OPEN_ELEMENT" ; public static String INSIDE_END_TAG = "INSIDE_END_TAG" ; private EditorFileContext context ; private IMetadataEnvironment environment ; private Hashtable < String , ArrayList < String > > additionalProposals = new Hashtable < String , ArrayList < String > > ( ) ; public HTMLContentAssistProcessor ( EditorFileContext context ) { this . context = context ; this . environment = ( IMetadataEnvironment ) HTMLLanguageEnvironment . getInstance ( ) . getRuntimeEnvironment ( ) ; } public ICompletionProposal [ ] computeInnerCompletionProposals ( ITextViewer viewer , int offset , int position , LexemeList lexemeList , char activationChar , char previousChar ) { additionalProposals . clear ( ) ; HTMLContextLocation currentLocation = getLocation ( offset , lexemeList ) ; String tagPrefix = currentLocation . getTagName ( ) ; ICompletionProposal [ ] result = null ; if ( unifiedViewer != null && unifiedViewer . isHotkeyActivated ( ) ) { unifiedViewer . setHotkeyActivated ( false ) ; activationChar = DEFAULT_CHARACTER ; } if ( position < 0 ) { return null ; } Lexeme currentLexeme = lexemeList . get ( position ) ; if ( currentLocation . getLocation ( ) . equals ( ERROR ) ) { return result ; } if ( currentLocation . getLocation ( ) . equals ( INSIDE_END_TAG ) && currentLocation . getAttributes ( ) . size ( ) == 0 ) { return getTagCompletionProposals ( tagPrefix , previousChar , offset , currentLexeme , lexemeList ) ; } if ( currentLocation . getLocation ( ) . equals ( OUTSIDE_ELEMENT ) && previousChar == '/' ) { return getTagCompletionProposals ( "" , activationChar , offset , currentLexeme , lexemeList ) ; } if ( currentLocation . getLocation ( ) . equals ( OUTSIDE_ELEMENT ) && ( activationChar == '<' || activationChar == DEFAULT_CHARACTER ) ) { if ( currentLexeme != null && currentLexeme . typeIndex == HTMLTokenTypes . TEXT && currentLexeme . getText ( ) . trim ( ) . startsWith ( "&" ) ) { result = computeHTMLEntityProposals ( currentLexeme , currentLexeme . getText ( ) ) . values ( ) . toArray ( new ICompletionProposal [ 0 ] ) ; setSelection ( currentLexeme . getText ( ) , result ) ; return result ; } return getTagCompletionProposals ( "" , previousChar , offset , currentLexeme , lexemeList ) ; } if ( currentLocation . getLocation ( ) . equals ( OUTSIDE_ELEMENT ) && activationChar == '&' ) { String prefix = currentLexeme . getText ( ) ; int length = offset - currentLexeme . getStartingOffset ( ) ; if ( length <= 0 ) { prefix = "" ; } else if ( length <= prefix . length ( ) ) { prefix = prefix . substring ( 0 , length ) ; } result = computeHTMLEntityProposals ( currentLexeme , prefix ) . values ( ) . toArray ( new ICompletionProposal [ 0 ] ) ; setSelection ( currentLexeme . getText ( ) , result ) ; return result ; } ArrayList < KeyValuePair > attributes = currentLocation . getAttributes ( ) ; String attributePrefix = null ; String valuePrefix = null ; if ( attributes . size ( ) > 0 ) { for ( KeyValuePair kvp : attributes ) { if ( kvp . getLocation ( ) == currentLexeme . offset ) { attributePrefix = ( String ) kvp . getKey ( ) ; valuePrefix = ( String ) kvp . getValue ( ) ; break ; } } } if ( currentLocation . getLocation ( ) . equals ( INSIDE_OPEN_ELEMENT ) ) { if ( ( previousChar == ' ' || previousChar == '\t' ) && tagPrefix != null ) { if ( HTMLUtils . insideQuotedString ( currentLexeme , offset ) ) { return null ; } attributePrefix = "" ; if ( currentLexeme . getCategoryIndex ( ) != TokenCategories . ERROR ) { valuePrefix = null ; } } if ( attributePrefix == null || currentLexeme . typeIndex == HTMLTokenTypes . START_TAG && currentLexeme . containsOffset ( offset ) ) { KeyValuePair stylePair = get ( attributes , "style" ) ; if ( stylePair != null && ( offset > stylePair . getLocation ( ) && offset <= ( stylePair . getLocation ( ) + 2 + ( ( String ) stylePair . getValue ( ) ) . length ( ) ) ) ) { return new CSSContentAssistProcessor ( context ) . computeInnerCompletionProposals ( viewer , offset , position , lexemeList , activationChar , previousChar ) ; } result = getTagCompletionProposals ( tagPrefix , previousChar , offset , currentLexeme , lexemeList ) ; } else if ( valuePrefix != null ) { if ( valuePrefix . equals ( "/" ) ) { valuePrefix = "" ; } result = getAttributeValueCompletionProposals ( tagPrefix , attributePrefix , valuePrefix , offset ) ; String strippedValue = StringUtils . trimStringQuotes ( valuePrefix ) ; setSelection ( strippedValue , result ) ; } else { Lexeme startTag = HTMLUtils . getTagOpenLexeme ( currentLexeme , lexemeList ) ; Lexeme endTag = HTMLUtils . getTagCloseLexeme ( currentLexeme , lexemeList ) ; Map < String , String > attribs = HTMLUtils . gatherAttributes ( startTag , endTag , lexemeList ) ; boolean attributeQuoted = attribs . get ( attributePrefix ) == null ? false : true ; result = getAttributeCompletionProposals ( tagPrefix , attributePrefix , previousChar , attributes , attributeQuoted , offset ) ; setSelection ( attributePrefix . toLowerCase ( ) , result ) ; } } return result ; } private KeyValuePair get ( ArrayList < KeyValuePair > attributes , String key ) { for ( KeyValuePair keyValuePair : attributes ) { if ( keyValuePair . getKey ( ) . equals ( key ) ) return keyValuePair ; } return null ; } public ICompletionProposal [ ] getAttributeValueCompletionProposals ( String tagPrefix2 , String attributePrefix2 , String valuePrefix , int offset ) { if ( tagPrefix2 == null || attributePrefix2 == null ) { return null ; } String strippedValue = StringUtils . trimStringQuotes ( valuePrefix ) ; ArrayList < ICompletionProposal > completionProposals = new ArrayList < ICompletionProposal > ( ) ; ArrayList < String > addedFields = new ArrayList < String > ( ) ; Hashtable < String , FieldMetadata > fields = environment . getGlobalFields ( ) ; String tagNameLower = tagPrefix2 . toLowerCase ( ) ; String propertyNameLower = attributePrefix2 . toLowerCase ( ) ; String valueNameLower = strippedValue . toLowerCase ( ) ; int beginOffset = getOffsetForInsertion ( getHTMLOffsetMapper ( ) . getCurrentLexeme ( ) , offset ) ; int replaceLength = valueNameLower . length ( ) ; Lexeme curLexeme = getHTMLOffsetMapper ( ) . getCurrentLexeme ( ) ; if ( curLexeme . getCategoryIndex ( ) == TokenCategories . ERROR ) { beginOffset = curLexeme . offset ; } if ( valuePrefix . startsWith ( "\"" ) || valuePrefix . startsWith ( "'" ) ) { beginOffset ++ ; } int sortingType = HTMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY ; ElementMetadata em = environment . getElement ( tagNameLower ) ; FieldMetadata fm = null ; if ( em == null ) { fm = fields . get ( propertyNameLower ) ; } else { fm = ( FieldMetadata ) em . getFields ( ) . get ( propertyNameLower ) ; } if ( fm != null ) { ICompletionProposal [ ] props = getFieldMetadataCompletionProposals ( em , fm , beginOffset , replaceLength , sortingType ) ; completionProposals . addAll ( Arrays . asList ( props ) ) ; } try { if ( propertyNameLower . equals ( "src" ) ) { ICompletionProposal [ ] fileProps = getFilePathCompletionProposals ( valuePrefix , beginOffset , replaceLength , sortingType ) ; completionProposals . addAll ( Arrays . asList ( fileProps ) ) ; } } catch ( Exception ex ) { IdeLog . logError ( JSPlugin . getDefault ( ) , Messages . HTMLContentAssistProcessor_ErrorComputingFilePath , ex ) ; } try { if ( propertyNameLower . equals ( "class" ) ) { ICompletionProposal [ ] fileProps = getCSSClassCompletionProposals ( valuePrefix , beginOffset , replaceLength , sortingType ) ; completionProposals . addAll ( Arrays . asList ( fileProps ) ) ; } else if ( propertyNameLower . equals ( "id" ) ) { ICompletionProposal [ ] fileProps = getCSSIdCompletionProposals ( valuePrefix , beginOffset , replaceLength , sortingType ) ; completionProposals . addAll ( Arrays . asList ( fileProps ) ) ; } } catch ( Exception ex ) { IdeLog . logError ( JSPlugin . getDefault ( ) , Messages . HTMLContentAssistProcessor_ErrorComputingFilePath , ex ) ; } ICompletionProposal [ ] xPathProps = getXPathCompletionProposals ( propertyNameLower , beginOffset , replaceLength , sortingType ) ; completionProposals . addAll ( Arrays . asList ( xPathProps ) ) ; if ( additionalProposals . containsKey ( propertyNameLower ) ) { ArrayList < String > addl = additionalProposals . get ( fm . getName ( ) ) ; for ( int i = 0 ; i < addl . size ( ) ; i ++ ) { String s = ( String ) addl . get ( i ) ; String trimmedValue = StringUtils . trimStringQuotes ( StringUtils . trimStringQuotes ( s ) ) ; if ( trimmedValue . equals ( "" ) ) { continue ; } String replaceString = trimmedValue ; String displayString = trimmedValue ; int cursorPosition = replaceString . length ( ) ; HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconFieldGuess , displayString , null , "<b>" + trimmedValue + "</b><br>" + AUTO_ADDED , sortingType , unifiedViewer , null ) ; if ( cp != null && ! addedFields . contains ( s ) ) { addedFields . add ( s ) ; completionProposals . add ( cp ) ; } } } ICompletionProposal [ ] result = completionProposals . toArray ( new ICompletionProposal [ completionProposals . size ( ) ] ) ; Arrays . sort ( result , getProposalComparator ( ) ) ; return result ; } public HTMLContextLocation getLocation ( int offset , LexemeList ll ) { HTMLContextLocation cl = new HTMLContextLocation ( ) ; cl . setLocation ( OUTSIDE_ELEMENT ) ; if ( offset == 0 ) { return cl ; } int currentLexemePosition = computeCurrentLexemeIndex ( offset , ll ) ; KeyValuePair currentAttribute = null ; while ( currentLexemePosition >= 0 ) { Lexeme curLexeme = ll . get ( currentLexemePosition ) ; if ( curLexeme . typeIndex == HTMLTokenTypes . NAME ) { boolean isAttributeValue = false ; if ( currentLexemePosition > 0 ) { Lexeme prev = ll . get ( currentLexemePosition - 1 ) ; if ( prev . typeIndex == HTMLTokenTypes . EQUAL ) { isAttributeValue = true ; } } String lexemeText = curLexeme . getText ( ) ; if ( isAttributeValue ) { currentAttribute = new KeyValuePair ( "PLACEHOLDER" , lexemeText , curLexeme . offset ) ; } else if ( currentAttribute != null ) { KeyValuePair foundAttribute = cl . find ( lexemeText , currentAttribute . getLocation ( ) ) ; if ( foundAttribute != null && foundAttribute . getLocation ( ) != curLexeme . offset ) { cl . getAttributes ( ) . remove ( foundAttribute ) ; } cl . getAttributes ( ) . add ( 0 , new KeyValuePair ( lexemeText , currentAttribute . getValue ( ) , currentAttribute . getLocation ( ) ) ) ; currentAttribute = null ; } else { KeyValuePair foundAttribute = cl . find ( lexemeText , curLexeme . offset ) ; if ( foundAttribute != null && foundAttribute . getLocation ( ) != curLexeme . offset ) { cl . getAttributes ( ) . remove ( foundAttribute ) ; } cl . getAttributes ( ) . add ( 0 , new KeyValuePair ( lexemeText , null , curLexeme . offset ) ) ; currentAttribute = null ; } } if ( curLexeme . typeIndex == HTMLTokenTypes . EQUAL ) { if ( currentAttribute == null ) { currentAttribute = new KeyValuePair ( "PLACEHOLDER" , "" , curLexeme . offset ) ; } } if ( curLexeme . typeIndex == HTMLTokenTypes . STRING ) { currentAttribute = new KeyValuePair ( "PLACEHOLDER" , curLexeme . getText ( ) , curLexeme . offset ) ; } if ( curLexeme . typeIndex == HTMLTokenTypes . START_TAG ) { cl . setTagName ( curLexeme . getText ( ) . replaceAll ( "<" , "" ) ) ; } if ( curLexeme . typeIndex == HTMLTokenTypes . END_TAG ) { cl . setTagName ( curLexeme . getText ( ) . replaceAll ( "</" , "" ) ) ; cl . setLocation ( INSIDE_END_TAG ) ; break ; } if ( curLexeme . typeIndex == HTMLTokenTypes . GREATER_THAN ) { cl . setLocation ( OUTSIDE_ELEMENT ) ; break ; } if ( curLexeme . typeIndex == HTMLTokenTypes . ERROR && curLexeme . getText ( ) . equals ( "/" ) ) { cl . setLocation ( ERROR ) ; break ; } if ( curLexeme . typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN && ( curLexeme . containsOffset ( offset ) || offset >= curLexeme . getEndingOffset ( ) ) ) { cl . setLocation ( OUTSIDE_ELEMENT ) ; break ; } if ( curLexeme . typeIndex == HTMLTokenTypes . START_TAG || curLexeme . typeIndex == HTMLTokenTypes . ERROR && curLexeme . getText ( ) . equals ( "<" ) ) { cl . setLocation ( INSIDE_OPEN_ELEMENT ) ; break ; } currentLexemePosition -- ; } return cl ; } public char [ ] getCompletionProposalAutoActivationCharacters ( ) { return new char [ ] { '<' , '/' , ' ' , '\t' , '=' , '>' , '&' } ; } public char [ ] getContextInformationAutoActivationCharacters ( ) { return new char [ ] { '=' } ; } public int [ ] getCompletionProposalSeparatorLexemes ( ) { return new int [ ] { HTMLTokenTypes . GREATER_THAN , HTMLTokenTypes . SLASH_GREATER_THAN , HTMLTokenTypes . EQUAL , HTMLTokenTypes . START_TAG , HTMLTokenTypes . END_TAG } ; } public int [ ] getCompletionProposalIdleActivationTokens ( ) { return new int [ ] { HTMLTokenTypes . START_TAG , HTMLTokenTypes . END_TAG , HTMLTokenTypes . NAME } ; } public IContextInformationValidator getContextInformationValidator ( ) { if ( validator == null ) validator = new HTMLContextInformationValidator ( this ) ; return validator ; } public String getErrorMessage ( ) { return null ; } public static int getOffsetForInsertion ( Lexeme curLexeme , int offset ) { if ( curLexeme == null ) { return offset ; } int beginOffset = offset ; if ( curLexeme . typeIndex == HTMLTokenTypes . TEXT ) { return beginOffset ; } if ( curLexeme . getCategoryIndex ( ) == TokenCategories . KEYWORD || curLexeme . getCategoryIndex ( ) == TokenCategories . LITERAL || HTMLUtils . isStartTag ( curLexeme ) || HTMLUtils . isEndTag ( curLexeme ) ) { beginOffset = curLexeme . getStartingOffset ( ) ; } return beginOffset ; } public ICompletionProposal [ ] getAttributeCompletionProposals ( String tagPrefix , String attributePrefix , char activationChar , ArrayList < KeyValuePair > addedAttributes , boolean hasAttachedValue , int offset ) { if ( tagPrefix == null ) { return null ; } Hashtable < String , HTMLCompletionProposal > completionProposals = new Hashtable < String , HTMLCompletionProposal > ( ) ; String tagPrefixLower = tagPrefix . toLowerCase ( ) ; String attributePrefixLower = attributePrefix . toLowerCase ( ) ; ElementMetadata em = environment . getElement ( tagPrefixLower ) ; if ( em == null ) { return null ; } int beginOffset = offset ; Lexeme curLexeme = getHTMLOffsetMapper ( ) . getCurrentLexeme ( ) ; if ( curLexeme . typeIndex == HTMLTokenTypes . NAME ) { beginOffset = curLexeme . getStartingOffset ( ) ; } Iterator iter = em . getFields ( ) . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { FieldMetadata fm = ( FieldMetadata ) iter . next ( ) ; HTMLCompletionProposal cp = createFieldProposal ( attributePrefixLower , beginOffset , em , fm , hasAttachedValue ) ; completionProposals . put ( fm . getName ( ) , cp ) ; } Iterator iterEvents = em . getEvents ( ) . values ( ) . iterator ( ) ; while ( iterEvents . hasNext ( ) ) { EventMetadata evm = ( EventMetadata ) iterEvents . next ( ) ; HTMLCompletionProposal cp = createEventProposal ( attributePrefixLower , beginOffset , em , evm , hasAttachedValue ) ; completionProposals . put ( evm . getName ( ) , cp ) ; } ICompletionProposal [ ] result = completionProposals . values ( ) . toArray ( new ICompletionProposal [ completionProposals . size ( ) ] ) ; Arrays . sort ( result , getProposalComparator ( ) ) ; return result ; } public HTMLCompletionProposal createFieldProposal ( String attributePrefix , int beginOffset , ElementMetadata em , FieldMetadata fm , boolean hasAttachedValue ) { String docText = environment . getFieldDocumentation ( fm ) ; String replaceString = fm . getName ( ) ; String quoteString = HTMLUtils . quoteAttributeValue ( getPreferenceStore ( ) , "" ) ; boolean insertEquals = HTMLUtils . insertEquals ( getPreferenceStore ( ) ) ; if ( ! hasAttachedValue && insertEquals ) { replaceString = replaceString + "=" + quoteString ; } String displayString = fm . getName ( ) ; int cursorPosition = replaceString . length ( ) ; if ( ! hasAttachedValue && insertEquals && quoteString . length ( ) == 2 ) { cursorPosition -- ; } int replaceLength = attributePrefix . length ( ) ; Image [ ] userAgents = null ; if ( fm . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImages ( getUserAgents ( ) , em . getUserAgentPlatformNames ( ) ) ; } else { userAgents = getUserAgentImages ( getUserAgents ( ) , fm . getUserAgentPlatformNames ( ) ) ; } HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconField , displayString , null , docText , HTMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , userAgents ) ; return cp ; } public HTMLCompletionProposal createEventProposal ( String attributePrefix , int beginOffset , ElementMetadata em , EventMetadata fm , boolean hasAttachedValue ) { String docText = environment . getEventDocumentation ( fm ) ; String replaceString = fm . getName ( ) ; String quoteString = HTMLUtils . quoteAttributeValue ( getPreferenceStore ( ) , "" ) ; boolean insertEquals = HTMLUtils . insertEquals ( getPreferenceStore ( ) ) ; if ( ! hasAttachedValue && insertEquals ) { replaceString = replaceString + "=" + quoteString ; } String displayString = fm . getName ( ) ; int cursorPosition = replaceString . length ( ) ; int replaceLength = attributePrefix . length ( ) ; if ( ! hasAttachedValue && insertEquals && quoteString . length ( ) == 2 ) { cursorPosition -- ; } Image [ ] userAgents = null ; if ( fm . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImages ( getUserAgents ( ) , em . getUserAgentPlatformNames ( ) ) ; } else { userAgents = getUserAgentImages ( getUserAgents ( ) , fm . getUserAgentPlatformNames ( ) ) ; } HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconEvent , displayString , null , docText , HTMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , userAgents ) ; return cp ; } public ICompletionProposal [ ] getTagCompletionProposals ( String prefix , char activationChar , int offset , Lexeme currentLexeme , LexemeList lexemeList ) { IParseState parseState = context . getParseState ( ) ; HTMLParseState htmlParseState = ( HTMLParseState ) parseState . getParseState ( HTMLMimeType . MimeType ) ; Hashtable < String , HTMLCompletionProposal > completionProposals = new Hashtable < String , HTMLCompletionProposal > ( ) ; if ( currentLexeme == null ) { return null ; } if ( currentLexeme . typeIndex != HTMLTokenTypes . TEXT && ! HTMLUtils . isStartTag ( currentLexeme ) && ! HTMLUtils . isEndTag ( currentLexeme ) ) { return null ; } int tagClosedType = HTMLUtils . isTagClosed ( currentLexeme , lexemeList ) ; boolean tagClosed = tagClosedType != HTMLUtils . TAG_OPEN ; String textPrefix = HTMLUtils . getOpenTagName ( currentLexeme , offset ) ; if ( tagClosed ) { textPrefix = HTMLUtils . getOpenTagName ( currentLexeme , currentLexeme . getEndingOffset ( ) ) ; } String testPrefix = textPrefix . toLowerCase ( ) ; int lastAmpersand = textPrefix . lastIndexOf ( '&' ) ; if ( lastAmpersand > - 1 && lastAmpersand > textPrefix . lastIndexOf ( ';' ) && lastAmpersand > textPrefix . lastIndexOf ( ' ' ) ) { testPrefix = textPrefix . substring ( lastAmpersand ) ; completionProposals . putAll ( computeHTMLEntityProposals ( currentLexeme , textPrefix ) ) ; } else { testPrefix = textPrefix . toLowerCase ( ) ; } if ( currentLexeme . typeIndex == HTMLTokenTypes . TEXT ) { textPrefix = "" ; } int beginOffset = getOffsetForInsertion ( currentLexeme , offset ) ; String [ ] em = environment . getAllElements ( ) ; for ( int i = 0 ; i < em . length ; i ++ ) { String e = em [ i ] ; String docText = environment . getElementDocumentation ( e ) ; String displayString = e ; String replaceString = e ; int replaceLength = textPrefix . length ( ) ; int cursorPosition = replaceString . length ( ) ; if ( HTMLUtils . isEndTag ( currentLexeme ) ) { if ( tagClosed ) { replaceString = HTMLUtils . createOpenTag ( replaceString , false ) ; } else { replaceString = HTMLUtils . createOpenTag ( replaceString , true ) ; } replaceLength = currentLexeme . length ; cursorPosition = replaceString . length ( ) ; } else { boolean insertClosingTags = true ; if ( getPreferenceStore ( ) != null ) { insertClosingTags = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . AUTO_INSERT_CLOSE_TAGS ) ; } if ( insertClosingTags ) { int cursorOffset = 1 ; boolean emptyTag = htmlParseState . isEmptyTagType ( replaceString ) ; boolean isDocType = replaceString != null && replaceString . toLowerCase ( ) . startsWith ( "!doctype" ) ; String startString = null ; if ( emptyTag && ! tagClosed && htmlParseState . getDocumentType ( ) >= HTMLDocumentType . XHTML_1_0_STRICT ) { startString = HTMLUtils . createSelfClosedTag ( replaceString ) ; cursorOffset = 2 ; } else { startString = HTMLUtils . createOpenTag ( replaceString , ! tagClosed ) ; } cursorPosition = startString . length ( ) ; if ( ! tagClosed && ! HTMLUtils . isStartTagBalanced ( currentLexeme , lexemeList , htmlParseState ) && ! emptyTag && ! isDocType ) { replaceString = startString + HTMLUtils . createCloseTag ( replaceString , true ) ; cursorOffset = 1 ; } else { replaceString = startString ; } if ( ! tagClosed ) { cursorPosition = cursorPosition - cursorOffset ; } } else { replaceString = HTMLUtils . createOpenTag ( replaceString , true ) ; cursorPosition = replaceString . length ( ) ; } if ( currentLexeme . typeIndex != HTMLTokenTypes . TEXT ) { replaceLength ++ ; } } HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconTag , displayString , null , docText , HTMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , getUserAgentImages ( getUserAgents ( ) , environment . getUserAgentPlatformNames ( e ) ) ) ; completionProposals . put ( displayString , cp ) ; } boolean addedCloseTag = false ; Lexeme unclosed = HTMLUtils . getPreviousUnclosedTag ( currentLexeme , lexemeList , htmlParseState ) ; if ( unclosed != null && ! HTMLUtils . isStartTagBalanced ( unclosed , lexemeList , htmlParseState ) ) { String displayString = HTMLUtils . stripTagEndings ( unclosed . getText ( ) ) ; String replaceString = displayString ; boolean emptyTag = htmlParseState . isEmptyTagType ( displayString ) ; if ( ! emptyTag ) { addedCloseTag = true ; if ( tagClosed ) { replaceString = HTMLUtils . createCloseTag ( replaceString , false ) ; } else { replaceString = HTMLUtils . createCloseTag ( replaceString , true ) ; } int replaceLength = getReplaceLengthByLexeme ( currentLexeme , offset ) ; int cursorPosition = replaceString . length ( ) ; displayString = "/" + displayString ; ElementMetadata e = environment . getElement ( unclosed ) ; String docText = null ; if ( e != null ) { docText = environment . getElementDocumentation ( e . getName ( ) ) ; } HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , currentLexeme . getStartingOffset ( ) , replaceLength , cursorPosition , fIconTag , displayString , null , docText , HTMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , getAllUserAgentImages ( getUserAgents ( ) ) ) ; completionProposals . put ( displayString , cp ) ; } } ICompletionProposal [ ] result = completionProposals . values ( ) . toArray ( new ICompletionProposal [ completionProposals . size ( ) ] ) ; Arrays . sort ( result , getProposalComparator ( ) ) ; if ( HTMLUtils . isEndTag ( currentLexeme ) && addedCloseTag ) { setSelection ( "/" + testPrefix , result ) ; } else { setSelection ( testPrefix , result ) ; } return result ; } private Map < String , HTMLCompletionProposal > computeHTMLEntityProposals ( Lexeme currentLexeme , String textPrefix ) { Map < String , HTMLCompletionProposal > completionProposals = new HashMap < String , HTMLCompletionProposal > ( ) ; Map < String , String > entityMap = getEntities ( ) ; String trimmedPrefix = StringUtils . trimStart ( textPrefix ) ; trimmedPrefix = trimmedPrefix . substring ( trimmedPrefix . lastIndexOf ( "&" ) ) ; for ( Map . Entry < String , String > entry : entityMap . entrySet ( ) ) { String displayString = '&' + entry . getKey ( ) + ';' ; String replaceString = displayString ; int beginOffset = currentLexeme . getStartingOffset ( ) + textPrefix . lastIndexOf ( '&' ) ; int replaceLength = textPrefix . length ( ) - textPrefix . lastIndexOf ( '&' ) ; String doc = entry . getValue ( ) ; if ( ! displayString . startsWith ( trimmedPrefix ) ) continue ; HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , beginOffset , replaceLength , replaceString . length ( ) , fIconTag , displayString , null , doc , HTMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , getUserAgentImages ( getUserAgents ( ) , new String [ 0 ] ) ) ; completionProposals . put ( displayString , cp ) ; } return completionProposals ; } private Map < String , String > getEntities ( ) { if ( entities == null ) { entities = new HashMap < String , String > ( ) ; try { InputStream stream = FileLocator . openStream ( HTMLPlugin . getDefault ( ) . getBundle ( ) , new Path ( "src/com/aptana/ide/editor/html/resources/entities.properties" ) , false ) ; Properties loadedEntities = new Properties ( ) ; loadedEntities . load ( stream ) ; for ( Object entityObject : loadedEntities . keySet ( ) ) { String entity = ( String ) entityObject ; entities . put ( entity , loadedEntities . getProperty ( entity ) ) ; } } catch ( Exception e ) { IdeLog . logError ( HTMLPlugin . getDefault ( ) , e . getMessage ( ) , e ) ; } } return entities ; } public IOffsetMapper getOffsetMapper ( ) { IFileLanguageService ls = this . context . getLanguageService ( HTMLMimeType . MimeType ) ; if ( ls != null ) { return ls . getOffsetMapper ( ) ; } else { return null ; } } public HTMLOffsetMapper getHTMLOffsetMapper ( ) { return ( HTMLOffsetMapper ) getOffsetMapper ( ) ; } protected IPreferenceStore getPreferenceStore ( ) { if ( PluginUtils . isPluginLoaded ( HTMLPlugin . getDefault ( ) ) ) { return HTMLPlugin . getDefault ( ) . getPreferenceStore ( ) ; } else { return null ; } } public IContextInformation [ ] computeInnerContextInformation ( String documentSource , int offset , int position , LexemeList lexemeList ) { IContextInformation [ ] ici = null ; HTMLContextLocation currentLocation = getLocation ( offset , lexemeList ) ; String tagPrefix = currentLocation . getTagName ( ) ; if ( tagPrefix == null ) { return null ; } Hashtable fields = environment . getGlobalFields ( ) ; ArrayList < KeyValuePair > attributes = currentLocation . getAttributes ( ) ; if ( attributes . size ( ) == 0 ) { return null ; } KeyValuePair attribute = attributes . get ( attributes . size ( ) - 1 ) ; String propertyNameLower = ( ( String ) attribute . getKey ( ) ) . toLowerCase ( ) ; FieldMetadata fm = ( FieldMetadata ) fields . get ( propertyNameLower ) ; if ( fm == null || fm . getValues ( ) . size ( ) > 0 ) { return null ; } ContextInformation ci = new ContextInformation ( "contextDisplayString" , fm . getDescription ( ) ) ; if ( ci != null ) { ici = new IContextInformation [ ] { ci } ; } return ici ; } public Comparator < ICompletionProposal > getProposalComparator ( ) { if ( contentAssistComparator == null ) contentAssistComparator = new HTMLCompletionProposalComparator ( ) ; return contentAssistComparator ; } private ICompletionProposal [ ] getFilePathCompletionProposals ( String valuePrefix , int beginOffset , int replaceLength , int sortingType ) { ArrayList < HTMLCompletionProposal > completionProposals = new ArrayList < HTMLCompletionProposal > ( ) ; Map < String , Image > ht = com . aptana . ide . core . ui . ImageUtils . fileIconsHash ; IEditorInput pathEditor = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getActiveEditor ( ) . getEditorInput ( ) ; String urlPrefix = null ; if ( pathEditor instanceof FileEditorInput ) { urlPrefix = getProjectContextRoot ( pathEditor ) ; } String editorPath = CoreUIUtils . getPathFromEditorInput ( pathEditor ) ; if ( urlPrefix != null && ! "" . equals ( urlPrefix ) && valuePrefix != null && valuePrefix . indexOf ( '/' ) == 1 ) { editorPath = urlPrefix ; } String currentPath = editorPath ; if ( valuePrefix != null ) { String s = StringUtils . trimStringQuotes ( valuePrefix ) ; if ( ! "" . equals ( s ) ) { File current = new File ( currentPath ) ; if ( current . isDirectory ( ) ) { currentPath = currentPath + s ; } else { currentPath = current . getParent ( ) . toString ( ) + File . separator + s ; } } } File [ ] files = FileUtils . getFilesInDirectory ( new File ( currentPath ) ) ; if ( files == null ) { return new ICompletionProposal [ 0 ] ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . getName ( ) . startsWith ( "." ) ) { continue ; } String fileType = "" ; try { fileType = FileSystemView . getFileSystemView ( ) . getSystemTypeDescription ( f ) ; } catch ( Exception ex ) { IdeLog . logError ( HTMLPlugin . getDefault ( ) , Messages . HTMLContentAssistProcessor_TypeDescriptionError , ex ) ; } if ( f . toString ( ) . equals ( editorPath ) ) { continue ; } Image image = null ; if ( fileType != null ) { image = ht . get ( fileType ) ; } if ( image == null ) { image = fIconFile ; if ( f . isDirectory ( ) ) { image = fIconFolder ; } } String replaceString = FileUtils . makeFilePathRelative ( new File ( editorPath ) , f ) ; replaceString = replaceString . replaceAll ( "\\\\" , "/" ) ; String displayString = CoreUIUtils . getPathFromURI ( replaceString ) ; int cursorPosition = replaceString . length ( ) ; HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , image , displayString , null , f . toString ( ) , sortingType , unifiedViewer , new Image [ 0 ] ) ; if ( cp != null ) { completionProposals . add ( cp ) ; } } return completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private ICompletionProposal [ ] getCSSClassCompletionProposals ( String valuePrefix , int beginOffset , int replaceLength , int sortingType ) { String trimmedValue = StringUtils . trimStringQuotes ( valuePrefix ) ; ArrayList < HTMLCompletionProposal > completionProposals = new ArrayList < HTMLCompletionProposal > ( ) ; String path = "" ; IEditorInput pathEditor = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getActiveEditor ( ) . getEditorInput ( ) ; if ( pathEditor instanceof IFileEditorInput ) { IFileEditorInput fileEI = ( IFileEditorInput ) pathEditor ; path = fileEI . getFile ( ) . getProject ( ) . getFullPath ( ) . toPortableString ( ) ; } Collection < String > classes = CSSLanguageEnvironment . getInstance ( ) . getClasses ( path , trimmedValue ) ; for ( String cssClass : classes ) { int cursorPosition = cssClass . length ( ) ; HTMLCompletionProposal cp = new HTMLCompletionProposal ( cssClass , beginOffset , replaceLength , cursorPosition , fIconTagGuess , cssClass , null , cssClass , sortingType , unifiedViewer , getAllUserAgentImages ( getUserAgents ( ) ) ) ; completionProposals . add ( cp ) ; } return completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private ICompletionProposal [ ] getCSSIdCompletionProposals ( String valuePrefix , int beginOffset , int replaceLength , int sortingType ) { String trimmedValue = StringUtils . trimStringQuotes ( valuePrefix ) ; ArrayList < HTMLCompletionProposal > completionProposals = new ArrayList < HTMLCompletionProposal > ( ) ; String path = "" ; IEditorInput pathEditor = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getActiveEditor ( ) . getEditorInput ( ) ; if ( pathEditor instanceof IFileEditorInput ) { IFileEditorInput fileEI = ( IFileEditorInput ) pathEditor ; path = fileEI . getFile ( ) . getProject ( ) . getFullPath ( ) . toPortableString ( ) ; } Collection < String > ids = CSSLanguageEnvironment . getInstance ( ) . getIds ( path , trimmedValue ) ; for ( String cssId : ids ) { int cursorPosition = cssId . length ( ) ; HTMLCompletionProposal cp = new HTMLCompletionProposal ( cssId , beginOffset , replaceLength , cursorPosition , fIconTagGuess , cssId , null , cssId , sortingType , unifiedViewer , getAllUserAgentImages ( getUserAgents ( ) ) ) ; completionProposals . add ( cp ) ; } return completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private String getProjectContextRoot ( IEditorInput input ) { String urlPrefix = null ; FileEditorInput fei = ( FileEditorInput ) input ; IFile file = fei . getFile ( ) ; IProject project = file . getProject ( ) ; urlPrefix = HTMLContextRootUtils . resolveURL ( project , "/" ) ; urlPrefix = project . getLocation ( ) . append ( urlPrefix ) . toOSString ( ) ; return urlPrefix ; } public ICompletionProposal [ ] getXPathCompletionProposals ( String attributeName , int offset , int replaceLength , int sortingType ) { ArrayList < HTMLCompletionProposal > completionProposals = new ArrayList < HTMLCompletionProposal > ( ) ; IParseNode root = context . getParseState ( ) . getRoot ( ) . getParseResults ( ) ; String editors = null ; if ( getPreferenceStore ( ) != null ) { editors = getPreferenceStore ( ) . getString ( com . aptana . ide . editors . preferences . IPreferenceConstants . CODE_ASSIST_EXPRESSIONS ) ; } CodeAssistExpression [ ] expressions = CodeAssistExpression . deserializeErrorDescriptors ( editors ) ; for ( int i = 0 ; i < expressions . length ; i ++ ) { CodeAssistExpression expression = expressions [ i ] ; if ( attributeName . matches ( expression . getExpression ( ) ) ) { try { XPath xpath = new ParseNodeXPath ( expression . getXPath ( ) ) ; Object result = xpath . evaluate ( root ) ; if ( result instanceof List ) { List xpathResult = ( List ) result ; for ( Iterator iter = xpathResult . iterator ( ) ; iter . hasNext ( ) ; ) { Object element = ( Object ) iter . next ( ) ; if ( element instanceof ParseNodeAttribute ) { ParseNodeAttribute pna = ( ParseNodeAttribute ) element ; String replaceString = pna . getValue ( ) ; int cursorPosition = replaceString . length ( ) ; HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , offset , replaceLength , cursorPosition , fIconFieldGuess , replaceString , null , "<b>" + replaceString + "</b><br>" + AUTO_ADDED , sortingType , unifiedViewer , null ) ; if ( cp != null ) { completionProposals . add ( cp ) ; } } } } } catch ( JaxenException e ) { IdeLog . logError ( HTMLPlugin . getDefault ( ) , e . getMessage ( ) ) ; } } } return completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private ICompletionProposal [ ] getFieldMetadataCompletionProposals ( ElementMetadata em , FieldMetadata fm , int beginOffset , int replaceLength , int sortingType ) { ArrayList < HTMLCompletionProposal > completionProposals = new ArrayList < HTMLCompletionProposal > ( ) ; for ( int i = 0 ; i < fm . getValues ( ) . size ( ) ; i ++ ) { ValueMetadata value = ( ValueMetadata ) fm . getValues ( ) . get ( i ) ; if ( value . getName ( ) != "*" ) { String docText = "" ; docText = MetadataEnvironment . getValueDocumentation ( value ) ; String replaceString = value . getName ( ) ; String displayString = value . getName ( ) ; if ( replaceString . equals ( "*" ) ) { replaceString = "" ; } int cursorPosition = replaceString . length ( ) ; Image [ ] userAgents = null ; if ( value . getUserAgents ( ) . length == 0 && fm . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImages ( getUserAgents ( ) , em . getUserAgentPlatformNames ( ) ) ; } else if ( value . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImages ( getUserAgents ( ) , fm . getUserAgentPlatformNames ( ) ) ; } else { userAgents = getUserAgentImages ( getUserAgents ( ) , value . getUserAgentPlatformNames ( ) ) ; } HTMLCompletionProposal cp = new HTMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconField , displayString , null , docText , sortingType , unifiedViewer , userAgents ) ; if ( cp != null ) { completionProposals . add ( cp ) ; } } } return completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private int getReplaceLengthByLexeme ( Lexeme lexeme , int offset ) { return Math . min ( lexeme . getText ( ) . trim ( ) . length ( ) , offset - lexeme . offset ) ; } } 