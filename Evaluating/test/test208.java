public class JDBCTap extends Tap { private static final Logger LOG = LoggerFactory . getLogger ( JDBCTap . class ) ; String connectionUrl ; String username ; String password ; String driverClassName ; TableDesc tableDesc ; int batchSize = 1000 ; int concurrentReads = 0 ; public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , String tableName , JDBCScheme scheme ) { this ( connectionUrl , username , password , driverClassName , new TableDesc ( tableName ) , scheme , SinkMode . APPEND ) ; } public JDBCTap ( String connectionUrl , String driverClassName , TableDesc tableDesc , JDBCScheme scheme , SinkMode sinkMode ) { this ( connectionUrl , null , null , driverClassName , tableDesc , scheme , sinkMode ) ; } public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , TableDesc tableDesc , JDBCScheme scheme ) { this ( connectionUrl , username , password , driverClassName , tableDesc , scheme , SinkMode . APPEND ) ; } public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , TableDesc tableDesc , JDBCScheme scheme , SinkMode sinkMode ) { super ( scheme , sinkMode ) ; this . connectionUrl = connectionUrl ; this . username = username ; this . password = password ; this . driverClassName = driverClassName ; this . tableDesc = tableDesc ; if ( tableDesc . getColumnDefs ( ) == null && sinkMode != SinkMode . APPEND ) throw new IllegalArgumentException ( "cannot have sink mode REPLACE or KEEP without TableDesc column defs, use APPEND mode" ) ; if ( sinkMode != SinkMode . APPEND ) LOG . warn ( "using sink mode: {}, consider APPEND to prevent DROP TABLE from being called during Flow or Cascade setup" , sinkMode ) ; } public JDBCTap ( String connectionUrl , String driverClassName , TableDesc tableDesc , JDBCScheme scheme ) { this ( connectionUrl , driverClassName , tableDesc , scheme , SinkMode . APPEND ) ; } public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , JDBCScheme scheme ) { super ( scheme ) ; this . connectionUrl = connectionUrl ; this . username = username ; this . password = password ; this . driverClassName = driverClassName ; } public JDBCTap ( String connectionUrl , String driverClassName , JDBCScheme scheme ) { this ( connectionUrl , null , null , driverClassName , scheme ) ; } public String getTableName ( ) { return tableDesc . tableName ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public int getBatchSize ( ) { return batchSize ; } public int getConcurrentReads ( ) { return concurrentReads ; } public void setConcurrentReads ( int concurrentReads ) { this . concurrentReads = concurrentReads ; } public Path getPath ( ) { return new Path ( "jdbc:/" + connectionUrl . replaceAll ( ":" , "_" ) ) ; } @ Override public boolean isWriteDirect ( ) { return true ; } public TupleEntryIterator openForRead ( JobConf conf ) throws IOException { return new TupleEntryIterator ( getSourceFields ( ) , new TapIterator ( this , conf ) ) ; } public TupleEntryCollector openForWrite ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) throw new TapException ( "this tap may not be used as a sink, no TableDesc defined" ) ; return new TapCollector ( this , conf ) ; } @ Override public boolean isSink ( ) { return tableDesc != null ; } @ Override public void sourceInit ( JobConf conf ) throws IOException { FileInputFormat . setInputPaths ( conf , getPath ( ) ) ; if ( username == null ) DBConfiguration . configureDB ( conf , driverClassName , connectionUrl ) ; else DBConfiguration . configureDB ( conf , driverClassName , connectionUrl , username , password ) ; super . sourceInit ( conf ) ; } @ Override public void sinkInit ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) return ; if ( isReplace ( ) && conf . get ( "mapred.task.partition" ) == null && ! deletePath ( conf ) ) throw new TapException ( "unable to drop table: " + tableDesc . getTableName ( ) ) ; if ( ! makeDirs ( conf ) ) throw new TapException ( "unable to create table: " + tableDesc . getTableName ( ) ) ; if ( username == null ) DBConfiguration . configureDB ( conf , driverClassName , connectionUrl ) ; else DBConfiguration . configureDB ( conf , driverClassName , connectionUrl , username , password ) ; super . sinkInit ( conf ) ; } private Connection createConnection ( ) { try { LOG . info ( "creating connection: {}" , connectionUrl ) ; Class . forName ( driverClassName ) ; Connection connection = null ; if ( username == null ) connection = DriverManager . getConnection ( connectionUrl ) ; else connection = DriverManager . getConnection ( connectionUrl , username , password ) ; connection . setAutoCommit ( false ) ; return connection ; } catch ( ClassNotFoundException exception ) { throw new TapException ( "unable to load driver class: " + driverClassName , exception ) ; } catch ( SQLException exception ) { throw new TapException ( "unable to open connection: " + connectionUrl , exception ) ; } } public int executeUpdate ( String updateString ) { Connection connection = null ; int result ; try { connection = createConnection ( ) ; try { LOG . info ( "executing update: {}" , updateString ) ; Statement statement = connection . createStatement ( ) ; result = statement . executeUpdate ( updateString ) ; connection . commit ( ) ; statement . close ( ) ; } catch ( SQLException exception ) { throw new TapException ( "unable to execute update statement: " + updateString , exception ) ; } } finally { try { if ( connection != null ) connection . close ( ) ; } catch ( SQLException exception ) { LOG . warn ( "ignoring connection close exception" , exception ) ; } } return result ; } public List < Object [ ] > executeQuery ( String queryString , int returnResults ) { Connection connection = null ; List < Object [ ] > result = Collections . emptyList ( ) ; try { connection = createConnection ( ) ; try { LOG . info ( "executing query: {}" , queryString ) ; Statement statement = connection . createStatement ( ) ; ResultSet resultSet = statement . executeQuery ( queryString ) ; if ( returnResults != 0 ) result = copyResultSet ( resultSet , returnResults == - 1 ? Integer . MAX_VALUE : returnResults ) ; connection . commit ( ) ; statement . close ( ) ; } catch ( SQLException exception ) { throw new TapException ( "unable to execute query statement: " + queryString , exception ) ; } } finally { try { if ( connection != null ) connection . close ( ) ; } catch ( SQLException exception ) { LOG . warn ( "ignoring connection close exception" , exception ) ; } } return result ; } private List < Object [ ] > copyResultSet ( ResultSet resultSet , int length ) throws SQLException { List < Object [ ] > results = new ArrayList < Object [ ] > ( length ) ; int size = resultSet . getMetaData ( ) . getColumnCount ( ) ; int count = 0 ; while ( resultSet . next ( ) && count < length ) { count ++ ; Object [ ] row = new Object [ size ] ; for ( int i = 0 ; i < row . length ; i ++ ) row [ i ] = resultSet . getObject ( i + 1 ) ; results . add ( row ) ; } return results ; } public boolean makeDirs ( JobConf conf ) throws IOException { if ( pathExists ( conf ) ) return true ; try { LOG . info ( "creating table: {}" , tableDesc . tableName ) ; executeUpdate ( tableDesc . getCreateTableStatement ( ) ) ; } catch ( TapException exception ) { LOG . warn ( "unable to create table: {}" , tableDesc . tableName ) ; LOG . warn ( "sql failure" , exception . getCause ( ) ) ; return false ; } return pathExists ( conf ) ; } public boolean deletePath ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) return false ; if ( ! pathExists ( conf ) ) return true ; try { LOG . info ( "deleting table: {}" , tableDesc . tableName ) ; executeUpdate ( tableDesc . getTableDropStatement ( ) ) ; } catch ( TapException exception ) { LOG . warn ( "unable to drop table: {}" , tableDesc . tableName ) ; LOG . warn ( "sql failure" , exception . getCause ( ) ) ; return false ; } return ! pathExists ( conf ) ; } public boolean pathExists ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) return true ; try { LOG . info ( "test table exists: {}" , tableDesc . tableName ) ; executeQuery ( tableDesc . getTableExistsQuery ( ) , 0 ) ; } catch ( TapException exception ) { return false ; } return true ; } public long getPathModified ( JobConf conf ) throws IOException { return System . currentTimeMillis ( ) ; } @ Override public String toString ( ) { return "JDBCTap{" + "connectionUrl='" + connectionUrl + '\'' + ", driverClassName='" + driverClassName + '\'' + ", tableDesc=" + tableDesc + '}' ; } @ Override public boolean equals ( Object object ) { if ( this == object ) return true ; if ( ! ( object instanceof JDBCTap ) ) return false ; if ( ! super . equals ( object ) ) return false ; JDBCTap jdbcTap = ( JDBCTap ) object ; if ( connectionUrl != null ? ! connectionUrl . equals ( jdbcTap . connectionUrl ) : jdbcTap . connectionUrl != null ) return false ; if ( driverClassName != null ? ! driverClassName . equals ( jdbcTap . driverClassName ) : jdbcTap . driverClassName != null ) return false ; if ( password != null ? ! password . equals ( jdbcTap . password ) : jdbcTap . password != null ) return false ; if ( tableDesc != null ? ! tableDesc . equals ( jdbcTap . tableDesc ) : jdbcTap . tableDesc != null ) return false ; if ( username != null ? ! username . equals ( jdbcTap . username ) : jdbcTap . username != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( connectionUrl != null ? connectionUrl . hashCode ( ) : 0 ) ; result = 31 * result + ( username != null ? username . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( driverClassName != null ? driverClassName . hashCode ( ) : 0 ) ; result = 31 * result + ( tableDesc != null ? tableDesc . hashCode ( ) : 0 ) ; result = 31 * result + batchSize ; return result ; } } 