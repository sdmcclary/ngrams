<<<<<<< HEAD
public class JDBCTap extends Tap { private static final Logger LOG = LoggerFactory . getLogger ( JDBCTap . class ) ; String connectionUrl ; String username ; String password ; String driverClassName ; TableDesc tableDesc ; int batchSize = 1000 ; int concurrentReads = 0 ; public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , String tableName , JDBCScheme scheme ) { this ( connectionUrl , username , password , driverClassName , new TableDesc ( tableName ) , scheme , SinkMode . APPEND ) ; } public JDBCTap ( String connectionUrl , String driverClassName , TableDesc tableDesc , JDBCScheme scheme , SinkMode sinkMode ) { this ( connectionUrl , null , null , driverClassName , tableDesc , scheme , sinkMode ) ; } public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , TableDesc tableDesc , JDBCScheme scheme ) { this ( connectionUrl , username , password , driverClassName , tableDesc , scheme , SinkMode . APPEND ) ; } public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , TableDesc tableDesc , JDBCScheme scheme , SinkMode sinkMode ) { super ( scheme , sinkMode ) ; this . connectionUrl = connectionUrl ; this . username = username ; this . password = password ; this . driverClassName = driverClassName ; this . tableDesc = tableDesc ; if ( tableDesc . getColumnDefs ( ) == null && sinkMode != SinkMode . APPEND ) throw new IllegalArgumentException ( "cannot have sink mode REPLACE or KEEP without TableDesc column defs, use APPEND mode" ) ; if ( sinkMode != SinkMode . APPEND ) LOG . warn ( "using sink mode: {}, consider APPEND to prevent DROP TABLE from being called during Flow or Cascade setup" , sinkMode ) ; } public JDBCTap ( String connectionUrl , String driverClassName , TableDesc tableDesc , JDBCScheme scheme ) { this ( connectionUrl , driverClassName , tableDesc , scheme , SinkMode . APPEND ) ; } public JDBCTap ( String connectionUrl , String username , String password , String driverClassName , JDBCScheme scheme ) { super ( scheme ) ; this . connectionUrl = connectionUrl ; this . username = username ; this . password = password ; this . driverClassName = driverClassName ; } public JDBCTap ( String connectionUrl , String driverClassName , JDBCScheme scheme ) { this ( connectionUrl , null , null , driverClassName , scheme ) ; } public String getTableName ( ) { return tableDesc . tableName ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public int getBatchSize ( ) { return batchSize ; } public int getConcurrentReads ( ) { return concurrentReads ; } public void setConcurrentReads ( int concurrentReads ) { this . concurrentReads = concurrentReads ; } public Path getPath ( ) { return new Path ( "jdbc:/" + connectionUrl . replaceAll ( ":" , "_" ) ) ; } @ Override public boolean isWriteDirect ( ) { return true ; } public TupleEntryIterator openForRead ( JobConf conf ) throws IOException { return new TupleEntryIterator ( getSourceFields ( ) , new TapIterator ( this , conf ) ) ; } public TupleEntryCollector openForWrite ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) throw new TapException ( "this tap may not be used as a sink, no TableDesc defined" ) ; return new TapCollector ( this , conf ) ; } @ Override public boolean isSink ( ) { return tableDesc != null ; } @ Override public void sourceInit ( JobConf conf ) throws IOException { FileInputFormat . setInputPaths ( conf , getPath ( ) ) ; if ( username == null ) DBConfiguration . configureDB ( conf , driverClassName , connectionUrl ) ; else DBConfiguration . configureDB ( conf , driverClassName , connectionUrl , username , password ) ; super . sourceInit ( conf ) ; } @ Override public void sinkInit ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) return ; if ( isReplace ( ) && conf . get ( "mapred.task.partition" ) == null && ! deletePath ( conf ) ) throw new TapException ( "unable to drop table: " + tableDesc . getTableName ( ) ) ; if ( ! makeDirs ( conf ) ) throw new TapException ( "unable to create table: " + tableDesc . getTableName ( ) ) ; if ( username == null ) DBConfiguration . configureDB ( conf , driverClassName , connectionUrl ) ; else DBConfiguration . configureDB ( conf , driverClassName , connectionUrl , username , password ) ; super . sinkInit ( conf ) ; } private Connection createConnection ( ) { try { LOG . info ( "creating connection: {}" , connectionUrl ) ; Class . forName ( driverClassName ) ; Connection connection = null ; if ( username == null ) connection = DriverManager . getConnection ( connectionUrl ) ; else connection = DriverManager . getConnection ( connectionUrl , username , password ) ; connection . setAutoCommit ( false ) ; return connection ; } catch ( ClassNotFoundException exception ) { throw new TapException ( "unable to load driver class: " + driverClassName , exception ) ; } catch ( SQLException exception ) { throw new TapException ( "unable to open connection: " + connectionUrl , exception ) ; } } public int executeUpdate ( String updateString ) { Connection connection = null ; int result ; try { connection = createConnection ( ) ; try { LOG . info ( "executing update: {}" , updateString ) ; Statement statement = connection . createStatement ( ) ; result = statement . executeUpdate ( updateString ) ; connection . commit ( ) ; statement . close ( ) ; } catch ( SQLException exception ) { throw new TapException ( "unable to execute update statement: " + updateString , exception ) ; } } finally { try { if ( connection != null ) connection . close ( ) ; } catch ( SQLException exception ) { LOG . warn ( "ignoring connection close exception" , exception ) ; } } return result ; } public List < Object [ ] > executeQuery ( String queryString , int returnResults ) { Connection connection = null ; List < Object [ ] > result = Collections . emptyList ( ) ; try { connection = createConnection ( ) ; try { LOG . info ( "executing query: {}" , queryString ) ; Statement statement = connection . createStatement ( ) ; ResultSet resultSet = statement . executeQuery ( queryString ) ; if ( returnResults != 0 ) result = copyResultSet ( resultSet , returnResults == - 1 ? Integer . MAX_VALUE : returnResults ) ; connection . commit ( ) ; statement . close ( ) ; } catch ( SQLException exception ) { throw new TapException ( "unable to execute query statement: " + queryString , exception ) ; } } finally { try { if ( connection != null ) connection . close ( ) ; } catch ( SQLException exception ) { LOG . warn ( "ignoring connection close exception" , exception ) ; } } return result ; } private List < Object [ ] > copyResultSet ( ResultSet resultSet , int length ) throws SQLException { List < Object [ ] > results = new ArrayList < Object [ ] > ( length ) ; int size = resultSet . getMetaData ( ) . getColumnCount ( ) ; int count = 0 ; while ( resultSet . next ( ) && count < length ) { count ++ ; Object [ ] row = new Object [ size ] ; for ( int i = 0 ; i < row . length ; i ++ ) row [ i ] = resultSet . getObject ( i + 1 ) ; results . add ( row ) ; } return results ; } public boolean makeDirs ( JobConf conf ) throws IOException { if ( pathExists ( conf ) ) return true ; try { LOG . info ( "creating table: {}" , tableDesc . tableName ) ; executeUpdate ( tableDesc . getCreateTableStatement ( ) ) ; } catch ( TapException exception ) { LOG . warn ( "unable to create table: {}" , tableDesc . tableName ) ; LOG . warn ( "sql failure" , exception . getCause ( ) ) ; return false ; } return pathExists ( conf ) ; } public boolean deletePath ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) return false ; if ( ! pathExists ( conf ) ) return true ; try { LOG . info ( "deleting table: {}" , tableDesc . tableName ) ; executeUpdate ( tableDesc . getTableDropStatement ( ) ) ; } catch ( TapException exception ) { LOG . warn ( "unable to drop table: {}" , tableDesc . tableName ) ; LOG . warn ( "sql failure" , exception . getCause ( ) ) ; return false ; } return ! pathExists ( conf ) ; } public boolean pathExists ( JobConf conf ) throws IOException { if ( ! isSink ( ) ) return true ; try { LOG . info ( "test table exists: {}" , tableDesc . tableName ) ; executeQuery ( tableDesc . getTableExistsQuery ( ) , 0 ) ; } catch ( TapException exception ) { return false ; } return true ; } public long getPathModified ( JobConf conf ) throws IOException { return System . currentTimeMillis ( ) ; } @ Override public String toString ( ) { return "JDBCTap{" + "connectionUrl='" + connectionUrl + '\'' + ", driverClassName='" + driverClassName + '\'' + ", tableDesc=" + tableDesc + '}' ; } @ Override public boolean equals ( Object object ) { if ( this == object ) return true ; if ( ! ( object instanceof JDBCTap ) ) return false ; if ( ! super . equals ( object ) ) return false ; JDBCTap jdbcTap = ( JDBCTap ) object ; if ( connectionUrl != null ? ! connectionUrl . equals ( jdbcTap . connectionUrl ) : jdbcTap . connectionUrl != null ) return false ; if ( driverClassName != null ? ! driverClassName . equals ( jdbcTap . driverClassName ) : jdbcTap . driverClassName != null ) return false ; if ( password != null ? ! password . equals ( jdbcTap . password ) : jdbcTap . password != null ) return false ; if ( tableDesc != null ? ! tableDesc . equals ( jdbcTap . tableDesc ) : jdbcTap . tableDesc != null ) return false ; if ( username != null ? ! username . equals ( jdbcTap . username ) : jdbcTap . username != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( connectionUrl != null ? connectionUrl . hashCode ( ) : 0 ) ; result = 31 * result + ( username != null ? username . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( driverClassName != null ? driverClassName . hashCode ( ) : 0 ) ; result = 31 * result + ( tableDesc != null ? tableDesc . hashCode ( ) : 0 ) ; result = 31 * result + batchSize ; return result ; } } 
=======
public class OptionParser { private final String optionSpec ; private char optionChar = 0 ; private String optionArg = null ; private int argIndex = 0 ; private int currentOptionIndex = 0 ; private final String [ ] args ; private static final char OPTION_CHAR = '-' ; public static class MissingArgumentException extends Exception { } public static class InvalidOptionException extends Exception { } public OptionParser ( String optionSpec , String [ ] args ) { this . optionSpec = optionSpec ; this . args = new String [ args . length ] ; System . arraycopy ( args , 0 , this . args , 0 , args . length ) ; } public char getOptionChar ( ) { return optionChar ; } public String getOptionCharString ( ) { return new String ( new char [ ] { optionChar } ) ; } public String getOptionArg ( ) { return optionArg ; } public boolean moveToNextOption ( ) throws InvalidOptionException , MissingArgumentException { if ( currentOptionIndex > 0 && currentOptionIndex == args [ argIndex ] . length ( ) ) { currentOptionIndex = 0 ; argIndex ++ ; } if ( currentOptionIndex == 0 ) { if ( argIndex >= args . length ) return false ; String arg = args [ argIndex ] ; if ( arg . length ( ) < 2 || arg . charAt ( 0 ) != OPTION_CHAR ) return false ; if ( arg . length ( ) == 2 && arg . charAt ( 1 ) == OPTION_CHAR ) { argIndex ++ ; return false ; } currentOptionIndex = 1 ; } optionChar = args [ argIndex ] . charAt ( currentOptionIndex ++ ) ; optionArg = null ; int i = optionSpec . indexOf ( optionChar ) ; if ( i < 0 || ( optionChar == ':' && i > 0 ) ) throw new InvalidOptionException ( ) ; if ( i + 1 < optionSpec . length ( ) && optionSpec . charAt ( i + 1 ) == ':' ) { if ( currentOptionIndex < args [ argIndex ] . length ( ) ) { optionArg = args [ argIndex ] . substring ( currentOptionIndex ) ; currentOptionIndex = 0 ; argIndex ++ ; } else if ( argIndex + 1 < args . length ) { optionArg = args [ ++ argIndex ] ; ++ argIndex ; currentOptionIndex = 0 ; } else throw new MissingArgumentException ( ) ; } return true ; } public String [ ] getRemainingArgs ( ) { String [ ] tem = new String [ args . length - argIndex ] ; System . arraycopy ( args , argIndex , tem , 0 , tem . length ) ; return tem ; } public static void main ( String [ ] args ) { String optSpec = args [ 0 ] ; String [ ] tem = new String [ args . length - 1 ] ; System . arraycopy ( args , 1 , tem , 0 , tem . length ) ; args = tem ; OptionParser opts = new OptionParser ( optSpec , args ) ; try { while ( opts . moveToNextOption ( ) ) { System . err . print ( "option " + opts . getOptionChar ( ) ) ; String arg = opts . getOptionArg ( ) ; if ( arg == null ) System . err . println ( " (no argument)" ) ; else System . err . println ( " arg=" + arg ) ; } args = opts . getRemainingArgs ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) System . err . println ( "arg=" + args [ i ] ) ; } catch ( OptionParser . MissingArgumentException e ) { System . err . println ( "missing argument for option " + opts . getOptionChar ( ) ) ; } catch ( OptionParser . InvalidOptionException e ) { System . err . println ( "invalid option " + opts . getOptionChar ( ) ) ; } } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
