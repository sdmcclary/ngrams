<<<<<<< HEAD
public final class ImportGuidesAction extends AbstractAction { private static final Logger LOG = Logger . getLogger ( ImportGuidesAction . class . getName ( ) ) ; private static final String HTTP_REQUEST_AUTHORIZATION = "Authorization" ; private static final String BLOGLINES_SERVICE_URL = "http://rpc.bloglines.com/listsubs" ; private static ImportGuidesAction instance ; private ImportGuidesAction ( ) { setEnabled ( false ) ; } public static synchronized ImportGuidesAction getInstance ( ) { if ( instance == null ) instance = new ImportGuidesAction ( ) ; return instance ; } public void actionPerformed ( ActionEvent event ) { if ( GlobalController . SINGLETON . checkForNewSubscription ( ) ) return ; final ImportGuidesDialog dialog = new ImportGuidesDialog ( GlobalController . SINGLETON . getMainFrame ( ) ) ; dialog . open ( ) ; if ( ! dialog . hasBeenCanceled ( ) ) { setEnabled ( false ) ; try { processImport ( dialog ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } finally { setEnabled ( true ) ; } } } private void processImport ( ImportGuidesDialog dialog ) { final Importer importer ; final String url ; boolean fromURL = dialog . isFromURL ( ) ; final boolean isSingle = dialog . isSingleMode ( ) ; final boolean isAppending = dialog . isAppendingMode ( ) ; if ( fromURL ) { url = dialog . getUrlString ( ) ; importer = new ImporterAdv ( ) ; } else { String email = dialog . getBloglinesEmail ( ) ; String password = dialog . getBloglinesPassword ( ) ; url = BLOGLINES_SERVICE_URL ; importer = createBloglinesImporter ( email , password ) ; } Thread thread = new Thread ( ) { public void run ( ) { doImport ( importer , url , isSingle , isAppending , GlobalModel . SINGLETON , true ) ; } } ; thread . start ( ) ; } public static void doImport ( Importer aImporter , String aUrl , final boolean aSingle , final boolean aAppending , final GlobalModel aModel , final boolean isConfirmationRequired ) { OPMLGuideSet guideSet = null ; URL baseUrl = null ; try { try { baseUrl = new URL ( aUrl ) ; } catch ( MalformedURLException e ) { throw ImporterException . malformedUrl ( e . getMessage ( ) ) ; } guideSet = aImporter . process ( baseUrl , aSingle ) ; } catch ( ImporterException e ) { processException ( e ) ; } if ( guideSet != null ) { final OPMLGuide [ ] aGuides = guideSet . getGuides ( ) ; final URL aBaseUrl = baseUrl ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( aGuides . length > 0 ) { processImportedGuides ( aModel , aBaseUrl , aGuides , aSingle || aAppending , isConfirmationRequired ) ; } else { JOptionPane . showMessageDialog ( GlobalController . SINGLETON . getMainFrame ( ) , Strings . message ( "import.guides.nothing.to.import" ) ) ; } } } ) ; } } public static void importAndAppend ( GlobalModel model , String url ) { doImport ( new ImporterAdv ( ) , url , false , true , model , false ) ; } private static Importer createBloglinesImporter ( final String username , final String password ) { return new BloglinesImporter ( ) { public Reader createReaderForURL ( URL url ) throws IOException { HttpURLConnection con = ( HttpURLConnection ) url . openConnection ( ) ; if ( username != null && password != null ) { con . setRequestProperty ( HTTP_REQUEST_AUTHORIZATION , StringUtils . createBasicAuthToken ( username , password ) ) ; } return XmlReaderFactory . create ( con . getInputStream ( ) ) ; } } ; } private static void processImportedGuides ( GlobalModel model , URL baseURL , OPMLGuide [ ] guides , boolean isAppending , boolean isConfirmationRequired ) { int result = JOptionPane . YES_OPTION ; if ( isConfirmationRequired ) { int feedsCount = countFeeds ( guides ) ; String message ; if ( guides . length == 1 ) { message = MessageFormat . format ( Strings . message ( "import.guides.ready.to.import.0.feeds" ) , feedsCount ) ; } else { message = MessageFormat . format ( Strings . message ( "import.guides.ready.to.import.0.guides.with.1.feeds" ) , guides . length , feedsCount ) ; } message += Strings . message ( "import.guides.continue" ) ; result = JOptionPane . showConfirmDialog ( GlobalController . SINGLETON . getMainFrame ( ) , message , Strings . message ( "import.guides.dialog.title" ) , JOptionPane . YES_NO_OPTION ) ; } if ( result == JOptionPane . YES_OPTION ) { final GuidesSet cgs = model . getGuidesSet ( ) ; if ( isAppending ) { appendGuides ( baseURL , guides , cgs ) ; } else { replaceGuides ( baseURL , guides , cgs ) ; } } } static int countFeeds ( OPMLGuide [ ] guides ) { int count = 0 ; for ( int i = 0 ; i < guides . length ; i ++ ) { OPMLGuide guide = guides [ i ] ; count += guide . getFeeds ( ) . size ( ) ; OPMLReadingList [ ] lists = guide . getReadingLists ( ) ; for ( int j = 0 ; j < lists . length ; j ++ ) { OPMLReadingList list = lists [ j ] ; count += list . getFeeds ( ) . size ( ) ; } } return count ; } static void appendGuides ( URL baseURL , OPMLGuide [ ] guides , GuidesSet set ) { final Set < String > titles = set . getGuidesTitles ( ) ; for ( final OPMLGuide guide : guides ) { String title = getUniqueTitle ( guide . getTitle ( ) , titles ) ; appendGuide ( baseURL , guide , title , set ) ; titles . add ( title ) ; } } static int appendGuide ( URL baseURL , OPMLGuide opmlGuide , String uniqueTitle , GuidesSet guidesSet ) { IGuide guide = Helper . createGuide ( baseURL , opmlGuide , null ) ; guide . setTitle ( uniqueTitle ) ; String icon = guide . getIconKey ( ) ; if ( StringUtils . isEmpty ( icon ) ) { icon = getUnusedIcon ( guidesSet ) ; guide . setIconKey ( icon ) ; } replaceFeedsWithShares ( guidesSet , guide ) ; guidesSet . add ( guide ) ; GlobalController . SINGLETON . getPoller ( ) . update ( guide ) ; return guide . getFeedsCount ( ) ; } static void replaceFeedsWithShares ( GuidesSet set , IGuide guide ) { IFeed [ ] feeds = guide . getFeeds ( ) ; for ( IFeed feed : feeds ) { IFeed existing = set . findFeed ( feed ) ; if ( existing != null && existing != feed ) { GuidesSet . replaceFeed ( feed , existing ) ; } } } static String getUnusedIcon ( GuidesSet set ) { String icon = null ; int unusedIconIndex = GuideIcons . findUnusedIconName ( set . getGuidesIconKeys ( ) ) ; if ( unusedIconIndex != - 1 ) icon = GuideIcons . getIconsNames ( ) [ unusedIconIndex ] ; return icon ; } static String getUniqueTitle ( String title , Set titles ) { String uniqueTitle = title ; int i = 2 ; while ( titles . contains ( uniqueTitle ) ) { uniqueTitle = title + "_" + i ; i ++ ; } return uniqueTitle ; } public static void replaceGuides ( URL baseURL , OPMLGuide [ ] guides , GuidesSet set ) { set . clear ( ) ; appendGuides ( baseURL , guides , set ) ; } private static void processException ( ImporterException e ) { JOptionPane . showMessageDialog ( GlobalController . SINGLETON . getMainFrame ( ) , ImporterException . getStringType ( e ) , Strings . message ( "import.guides.dialog.title" ) , JOptionPane . ERROR_MESSAGE ) ; } } 
=======
public class IdTypeMapBuilder { private boolean hadError ; private final ErrorHandler eh ; private final PatternFunction < Integer > idTypeFunction = new IdTypeFunction ( ) ; private final IdTypeMapImpl idTypeMap = new IdTypeMapImpl ( ) ; private final Set < ElementPattern > elementProcessed = new HashSet < ElementPattern > ( ) ; private final List < PossibleConflict > possibleConflicts = new ArrayList < PossibleConflict > ( ) ; private void notePossibleConflict ( NameClass elementNameClass , NameClass attributeNameClass , Locator loc ) { possibleConflicts . add ( new PossibleConflict ( elementNameClass , attributeNameClass , loc ) ) ; } private static class WrappedSAXException extends RuntimeException { private final SAXException cause ; WrappedSAXException ( SAXException cause ) { this . cause = cause ; } } private static class PossibleConflict { private final NameClass elementNameClass ; private final NameClass attributeNameClass ; private final Locator locator ; private PossibleConflict ( NameClass elementNameClass , NameClass attributeNameClass , Locator locator ) { this . elementNameClass = elementNameClass ; this . attributeNameClass = attributeNameClass ; this . locator = locator ; } } private static class ScopedName { private final Name elementName ; private final Name attributeName ; private ScopedName ( Name elementName , Name attributeName ) { this . elementName = elementName ; this . attributeName = attributeName ; } public int hashCode ( ) { return elementName . hashCode ( ) ^ attributeName . hashCode ( ) ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof ScopedName ) ) return false ; ScopedName other = ( ScopedName ) obj ; return elementName . equals ( other . elementName ) && attributeName . equals ( other . attributeName ) ; } } private static class IdTypeMapImpl implements IdTypeMap { private final Map < ScopedName , Integer > table = new HashMap < ScopedName , Integer > ( ) ; public int getIdType ( Name elementName , Name attributeName ) { Integer n = table . get ( new ScopedName ( elementName , attributeName ) ) ; if ( n == null ) return Datatype . ID_TYPE_NULL ; return n ; } private void add ( Name elementName , Name attributeName , int idType ) { table . put ( new ScopedName ( elementName , attributeName ) , idType ) ; } } private class IdTypeFunction extends AbstractPatternFunction < Integer > { public Integer caseOther ( Pattern p ) { return Datatype . ID_TYPE_NULL ; } public Integer caseData ( DataPattern p ) { return p . getDatatype ( ) . getIdType ( ) ; } public Integer caseDataExcept ( DataExceptPattern p ) { return p . getDatatype ( ) . getIdType ( ) ; } public Integer caseValue ( ValuePattern p ) { return p . getDatatype ( ) . getIdType ( ) ; } } private class BuildFunction extends AbstractPatternFunction < VoidValue > { private final NameClass elementNameClass ; private final Locator locator ; private final boolean attributeIsParent ; BuildFunction ( NameClass elementNameClass , Locator locator ) { this . elementNameClass = elementNameClass ; this . locator = locator ; this . attributeIsParent = false ; } BuildFunction ( NameClass elementNameClass , Locator locator , boolean attributeIsParent ) { this . elementNameClass = elementNameClass ; this . locator = locator ; this . attributeIsParent = attributeIsParent ; } private BuildFunction down ( ) { if ( ! attributeIsParent ) return this ; return new BuildFunction ( elementNameClass , locator , false ) ; } public VoidValue caseChoice ( ChoicePattern p ) { BuildFunction f = down ( ) ; p . getOperand1 ( ) . apply ( f ) ; p . getOperand2 ( ) . apply ( f ) ; return VoidValue . VOID ; } public VoidValue caseInterleave ( InterleavePattern p ) { BuildFunction f = down ( ) ; p . getOperand1 ( ) . apply ( f ) ; p . getOperand2 ( ) . apply ( f ) ; return VoidValue . VOID ; } public VoidValue caseGroup ( GroupPattern p ) { BuildFunction f = down ( ) ; p . getOperand1 ( ) . apply ( f ) ; p . getOperand2 ( ) . apply ( f ) ; return VoidValue . VOID ; } public VoidValue caseOneOrMore ( OneOrMorePattern p ) { p . getOperand ( ) . apply ( down ( ) ) ; return VoidValue . VOID ; } public VoidValue caseElement ( ElementPattern p ) { if ( elementProcessed . contains ( p ) ) return VoidValue . VOID ; elementProcessed . add ( p ) ; p . getContent ( ) . apply ( new BuildFunction ( p . getNameClass ( ) , p . getLocator ( ) ) ) ; return VoidValue . VOID ; } public VoidValue caseAttribute ( AttributePattern p ) { int idType = p . getContent ( ) . apply ( idTypeFunction ) ; if ( idType != Datatype . ID_TYPE_NULL ) { NameClass attributeNameClass = p . getNameClass ( ) ; if ( ! ( attributeNameClass instanceof SimpleNameClass ) ) { error ( "id_attribute_name_class" , p . getLocator ( ) ) ; return VoidValue . VOID ; } elementNameClass . accept ( new ElementNameClassVisitor ( ( ( SimpleNameClass ) attributeNameClass ) . getName ( ) , locator , idType ) ) ; } else notePossibleConflict ( elementNameClass , p . getNameClass ( ) , locator ) ; p . getContent ( ) . apply ( new BuildFunction ( null , p . getLocator ( ) , true ) ) ; return VoidValue . VOID ; } private void datatype ( Datatype dt ) { if ( dt . getIdType ( ) != Datatype . ID_TYPE_NULL && ! attributeIsParent ) error ( "id_parent" , locator ) ; } public VoidValue caseData ( DataPattern p ) { datatype ( p . getDatatype ( ) ) ; return VoidValue . VOID ; } public VoidValue caseDataExcept ( DataExceptPattern p ) { datatype ( p . getDatatype ( ) ) ; p . getExcept ( ) . apply ( down ( ) ) ; return VoidValue . VOID ; } public VoidValue caseValue ( ValuePattern p ) { datatype ( p . getDatatype ( ) ) ; return VoidValue . VOID ; } public VoidValue caseList ( ListPattern p ) { p . getOperand ( ) . apply ( down ( ) ) ; return VoidValue . VOID ; } public VoidValue caseOther ( Pattern p ) { return VoidValue . VOID ; } } private class ElementNameClassVisitor implements NameClassVisitor { private final Name attributeName ; private final Locator locator ; private final int idType ; ElementNameClassVisitor ( Name attributeName , Locator locator , int idType ) { this . attributeName = attributeName ; this . locator = locator ; this . idType = idType ; } public void visitChoice ( NameClass nc1 , NameClass nc2 ) { nc1 . accept ( this ) ; nc2 . accept ( this ) ; } public void visitName ( Name elementName ) { int tem = idTypeMap . getIdType ( elementName , attributeName ) ; if ( tem != Datatype . ID_TYPE_NULL && tem != idType ) error ( "id_type_conflict" , elementName , attributeName , locator ) ; idTypeMap . add ( elementName , attributeName , idType ) ; } public void visitNsName ( String ns ) { visitOther ( ) ; } public void visitNsNameExcept ( String ns , NameClass nc ) { visitOther ( ) ; } public void visitAnyName ( ) { visitOther ( ) ; } public void visitAnyNameExcept ( NameClass nc ) { visitOther ( ) ; } public void visitNull ( ) { } public void visitError ( ) { } private void visitOther ( ) { error ( "id_element_name_class" , locator ) ; } } private void error ( String key , Locator locator ) { hadError = true ; if ( eh != null ) try { eh . error ( new SAXParseException ( SchemaBuilderImpl . localizer . message ( key ) , locator ) ) ; } catch ( SAXException e ) { throw new WrappedSAXException ( e ) ; } } private void error ( String key , Name arg1 , Name arg2 , Locator locator ) { hadError = true ; if ( eh != null ) try { eh . error ( new SAXParseException ( SchemaBuilderImpl . localizer . message ( key , NameFormatter . format ( arg1 ) , NameFormatter . format ( arg2 ) ) , locator ) ) ; } catch ( SAXException e ) { throw new WrappedSAXException ( e ) ; } } public IdTypeMapBuilder ( ErrorHandler eh , Pattern pattern ) throws SAXException { this . eh = eh ; try { pattern . apply ( new BuildFunction ( null , null ) ) ; for ( PossibleConflict pc : possibleConflicts ) { if ( pc . elementNameClass instanceof SimpleNameClass && pc . attributeNameClass instanceof SimpleNameClass ) { Name elementName = ( ( SimpleNameClass ) pc . elementNameClass ) . getName ( ) ; Name attributeName = ( ( SimpleNameClass ) pc . attributeNameClass ) . getName ( ) ; int idType = idTypeMap . getIdType ( elementName , attributeName ) ; if ( idType != Datatype . ID_TYPE_NULL ) error ( "id_type_conflict" , elementName , attributeName , pc . locator ) ; } else { for ( ScopedName sn : idTypeMap . table . keySet ( ) ) { if ( pc . elementNameClass . contains ( sn . elementName ) && pc . attributeNameClass . contains ( sn . attributeName ) ) { error ( "id_type_conflict" , sn . elementName , sn . attributeName , pc . locator ) ; break ; } } } } } catch ( WrappedSAXException e ) { throw e . cause ; } } public IdTypeMap getIdTypeMap ( ) { if ( hadError ) return null ; return idTypeMap ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
