<<<<<<< HEAD
public class Assertions extends Checker { private static boolean w3cBranding = "1" . equals ( System . getProperty ( "nu.validator.servlet.w3cbranding" ) ) ? true : false ; private static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString ( String lowerCaseLiteral , String string ) { if ( string == null ) { return false ; } if ( lowerCaseLiteral . length ( ) != string . length ( ) ) { return false ; } for ( int i = 0 ; i < lowerCaseLiteral . length ( ) ; i ++ ) { char c0 = lowerCaseLiteral . charAt ( i ) ; char c1 = string . charAt ( i ) ; if ( c1 >= 'A' && c1 <= 'Z' ) { c1 += 0x20 ; } if ( c0 != c1 ) { return false ; } } return true ; } private static boolean equalsIgnoreAsciiCase ( String one , String other ) { if ( other == null ) { if ( one == null ) { return true ; } else { return false ; } } if ( one . length ( ) != other . length ( ) ) { return false ; } for ( int i = 0 ; i < one . length ( ) ; i ++ ) { char c0 = one . charAt ( i ) ; char c1 = other . charAt ( i ) ; if ( c0 >= 'A' && c0 <= 'Z' ) { c0 += 0x20 ; } if ( c1 >= 'A' && c1 <= 'Z' ) { c1 += 0x20 ; } if ( c0 != c1 ) { return false ; } } return true ; } private static final String trimSpaces ( String str ) { return trimLeadingSpaces ( trimTrailingSpaces ( str ) ) ; } private static final String trimLeadingSpaces ( String str ) { if ( str == null ) { return null ; } for ( int i = str . length ( ) ; i > 0 ; -- i ) { char c = str . charAt ( str . length ( ) - i ) ; if ( ! ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) ) { return str . substring ( str . length ( ) - i , str . length ( ) ) ; } } return "" ; } private static final String trimTrailingSpaces ( String str ) { if ( str == null ) { return null ; } for ( int i = str . length ( ) - 1 ; i >= 0 ; -- i ) { char c = str . charAt ( i ) ; if ( ! ( ' ' == c || '\t' == c || '\n' == c || '\f' == c || '\r' == c ) ) { return str . substring ( 0 , i + 1 ) ; } } return "" ; } private static final Map < String , String > OBSOLETE_ELEMENTS = new HashMap < String , String > ( ) ; static { OBSOLETE_ELEMENTS . put ( "center" , "Use CSS instead." ) ; OBSOLETE_ELEMENTS . put ( "font" , "Use CSS instead." ) ; OBSOLETE_ELEMENTS . put ( "big" , "Use CSS instead." ) ; OBSOLETE_ELEMENTS . put ( "strike" , "Use CSS instead." ) ; OBSOLETE_ELEMENTS . put ( "tt" , "Use CSS instead." ) ; OBSOLETE_ELEMENTS . put ( "acronym" , "Use the “abbr” element instead." ) ; OBSOLETE_ELEMENTS . put ( "dir" , "Use the “ul” element instead." ) ; OBSOLETE_ELEMENTS . put ( "applet" , "Use the “object” element instead." ) ; OBSOLETE_ELEMENTS . put ( "basefont" , "Use CSS instead." ) ; OBSOLETE_ELEMENTS . put ( "frameset" , "Use the “iframe” element and CSS instead, or use server-side includes." ) ; OBSOLETE_ELEMENTS . put ( "noframes" , "Use the “iframe” element and CSS instead, or use server-side includes." ) ; if ( w3cBranding ) { OBSOLETE_ELEMENTS . put ( "hgroup" , "To mark up subheadings, consider either just putting the " + "subheading into a “p” element after the " + "“h1”-“h6” element containing the " + "main heading, or else putting the subheading directly " + "within the “h1”-“h6” element " + "containing the main heading, but separated from the main " + "heading by punctuation and/or within, for example, a " + "“span class=\"subheading\"” element with " + "differentiated styling. " + "To group headings and subheadings, alternative titles, " + "or taglines, consider using the “header” or " + "“div” elements." ) ; } } private static final Map < String , String [ ] > OBSOLETE_ATTRIBUTES = new HashMap < String , String [ ] > ( ) ; static { OBSOLETE_ATTRIBUTES . put ( "abbr" , new String [ ] { "td" , "th" } ) ; OBSOLETE_ATTRIBUTES . put ( "archive" , new String [ ] { "object" } ) ; OBSOLETE_ATTRIBUTES . put ( "axis" , new String [ ] { "td" , "th" } ) ; OBSOLETE_ATTRIBUTES . put ( "charset" , new String [ ] { "link" , "a" } ) ; OBSOLETE_ATTRIBUTES . put ( "classid" , new String [ ] { "object" } ) ; OBSOLETE_ATTRIBUTES . put ( "code" , new String [ ] { "object" } ) ; OBSOLETE_ATTRIBUTES . put ( "codebase" , new String [ ] { "object" } ) ; OBSOLETE_ATTRIBUTES . put ( "codetype" , new String [ ] { "object" } ) ; OBSOLETE_ATTRIBUTES . put ( "coords" , new String [ ] { "a" } ) ; OBSOLETE_ATTRIBUTES . put ( "datafld" , new String [ ] { "span" , "div" , "object" , "input" , "select" , "textarea" , "button" , "table" } ) ; OBSOLETE_ATTRIBUTES . put ( "dataformatas" , new String [ ] { "span" , "div" , "object" , "input" , "select" , "textarea" , "button" , "table" } ) ; OBSOLETE_ATTRIBUTES . put ( "datasrc" , new String [ ] { "span" , "div" , "object" , "input" , "select" , "textarea" , "button" , "table" } ) ; OBSOLETE_ATTRIBUTES . put ( "datapagesize" , new String [ ] { "table" } ) ; OBSOLETE_ATTRIBUTES . put ( "declare" , new String [ ] { "object" } ) ; OBSOLETE_ATTRIBUTES . put ( "event" , new String [ ] { "script" } ) ; OBSOLETE_ATTRIBUTES . put ( "for" , new String [ ] { "script" } ) ; OBSOLETE_ATTRIBUTES . put ( "language" , new String [ ] { "script" } ) ; if ( ! w3cBranding ) { OBSOLETE_ATTRIBUTES . put ( "longdesc" , new String [ ] { "img" , "iframe" } ) ; } OBSOLETE_ATTRIBUTES . put ( "methods" , new String [ ] { "link" , "a" } ) ; OBSOLETE_ATTRIBUTES . put ( "name" , new String [ ] { "img" , "embed" , "option" } ) ; OBSOLETE_ATTRIBUTES . put ( "nohref" , new String [ ] { "area" } ) ; OBSOLETE_ATTRIBUTES . put ( "profile" , new String [ ] { "head" } ) ; OBSOLETE_ATTRIBUTES . put ( "scheme" , new String [ ] { "meta" } ) ; OBSOLETE_ATTRIBUTES . put ( "scope" , new String [ ] { "td" } ) ; OBSOLETE_ATTRIBUTES . put ( "shape" , new String [ ] { "a" } ) ; OBSOLETE_ATTRIBUTES . put ( "standby" , new String [ ] { "object" } ) ; OBSOLETE_ATTRIBUTES . put ( "target" , new String [ ] { "link" } ) ; OBSOLETE_ATTRIBUTES . put ( "type" , new String [ ] { "param" } ) ; OBSOLETE_ATTRIBUTES . put ( "urn" , new String [ ] { "a" , "link" } ) ; OBSOLETE_ATTRIBUTES . put ( "usemap" , new String [ ] { "input" } ) ; OBSOLETE_ATTRIBUTES . put ( "valuetype" , new String [ ] { "param" } ) ; OBSOLETE_ATTRIBUTES . put ( "version" , new String [ ] { "html" } ) ; } private static final Map < String , String > OBSOLETE_ATTRIBUTES_MSG = new HashMap < String , String > ( ) ; static { OBSOLETE_ATTRIBUTES_MSG . put ( "abbr" , "Consider instead beginning the cell contents with concise text, followed by further elaboration if needed." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "archive" , "Use the “data” and “type” attributes to invoke plugins. To set a parameter with the name “archive”, use the “param” element." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "axis" , "Use the “scope” attribute." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "charset" , "Use an HTTP Content-Type header on the linked resource instead." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "classid" , "Use the “data” and “type” attributes to invoke plugins. To set a parameter with the name “classid”, use the “param” element." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "code" , "Use the “data” and “type” attributes to invoke plugins. To set a parameter with the name “code”, use the “param” element." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "codebase" , "Use the “data” and “type” attributes to invoke plugins. To set a parameter with the name “codebase”, use the “param” element." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "codetype" , "Use the “data” and “type” attributes to invoke plugins. To set a parameter with the name “codetype”, use the “param” element." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "coords" , "Use “area” instead of “a” for image maps." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "datapagesize" , "You can safely omit it." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "datafld" , "Use script and a mechanism such as XMLHttpRequest to populate the page dynamically" ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "dataformatas" , "Use script and a mechanism such as XMLHttpRequest to populate the page dynamically" ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "datasrc" , "Use script and a mechanism such as XMLHttpRequest to populate the page dynamically" ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "for" , "Use DOM Events mechanisms to register event listeners." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "event" , "Use DOM Events mechanisms to register event listeners." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "declare" , "Repeat the “object” element completely each time the resource is to be reused." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "language" , "Use the “type” attribute instead." ) ; if ( ! w3cBranding ) { OBSOLETE_ATTRIBUTES_MSG . put ( "longdesc" , "Use a regular “a” element to link to the description." ) ; } OBSOLETE_ATTRIBUTES_MSG . put ( "methods" , "Use the HTTP OPTIONS feature instead." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "name" , "Use the “id” attribute instead." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "nohref" , "Omitting the “href” attribute is sufficient." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "profile" , "To declare which “meta” terms are used in the document, instead register the names as meta extensions. To trigger specific UA behaviors, use a “link” element instead." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "scheme" , "Use only one scheme per field, or make the scheme declaration part of the value." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "scope" , "Use the “scope” attribute on a “th” element instead." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "shape" , "Use “area” instead of “a” for image maps." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "standby" , "Optimise the linked resource so that it loads quickly or, at least, incrementally." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "target" , "You can safely omit it." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "type" , "Use the “name” and “value” attributes without declaring value types." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "urn" , "Specify the preferred persistent identifier using the “href” attribute instead." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "usemap" , "Use the “img” element instead of the “input” element for image maps." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "valuetype" , "Use the “name” and “value” attributes without declaring value types." ) ; OBSOLETE_ATTRIBUTES_MSG . put ( "version" , "You can safely omit it." ) ; } private static final Map < String , String [ ] > OBSOLETE_STYLE_ATTRS = new HashMap < String , String [ ] > ( ) ; static { OBSOLETE_STYLE_ATTRS . put ( "align" , new String [ ] { "caption" , "iframe" , "img" , "input" , "object" , "embed" , "legend" , "table" , "hr" , "div" , "h1" , "h2" , "h3" , "h4" , "h5" , "h6" , "p" , "col" , "colgroup" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" } ) ; OBSOLETE_STYLE_ATTRS . put ( "alink" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "allowtransparency" , new String [ ] { "iframe" } ) ; OBSOLETE_STYLE_ATTRS . put ( "background" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "bgcolor" , new String [ ] { "table" , "tr" , "td" , "th" , "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "border" , new String [ ] { "object" , "table" } ) ; OBSOLETE_STYLE_ATTRS . put ( "cellpadding" , new String [ ] { "table" } ) ; OBSOLETE_STYLE_ATTRS . put ( "cellspacing" , new String [ ] { "table" } ) ; OBSOLETE_STYLE_ATTRS . put ( "char" , new String [ ] { "col" , "colgroup" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" } ) ; OBSOLETE_STYLE_ATTRS . put ( "charoff" , new String [ ] { "col" , "colgroup" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" } ) ; OBSOLETE_STYLE_ATTRS . put ( "clear" , new String [ ] { "br" } ) ; OBSOLETE_STYLE_ATTRS . put ( "color" , new String [ ] { "hr" } ) ; OBSOLETE_STYLE_ATTRS . put ( "compact" , new String [ ] { "dl" , "menu" , "ol" , "ul" } ) ; OBSOLETE_STYLE_ATTRS . put ( "frameborder" , new String [ ] { "iframe" } ) ; OBSOLETE_STYLE_ATTRS . put ( "frame" , new String [ ] { "table" } ) ; OBSOLETE_STYLE_ATTRS . put ( "height" , new String [ ] { "td" , "th" } ) ; OBSOLETE_STYLE_ATTRS . put ( "hspace" , new String [ ] { "img" , "object" , "embed" } ) ; OBSOLETE_STYLE_ATTRS . put ( "link" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "marginbottom" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "marginheight" , new String [ ] { "iframe" , "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "marginleft" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "marginright" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "margintop" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "marginwidth" , new String [ ] { "iframe" , "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "noshade" , new String [ ] { "hr" } ) ; OBSOLETE_STYLE_ATTRS . put ( "nowrap" , new String [ ] { "td" , "th" } ) ; OBSOLETE_STYLE_ATTRS . put ( "rules" , new String [ ] { "table" } ) ; OBSOLETE_STYLE_ATTRS . put ( "scrolling" , new String [ ] { "iframe" } ) ; OBSOLETE_STYLE_ATTRS . put ( "size" , new String [ ] { "hr" } ) ; OBSOLETE_STYLE_ATTRS . put ( "text" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "type" , new String [ ] { "li" , "ul" } ) ; OBSOLETE_STYLE_ATTRS . put ( "valign" , new String [ ] { "col" , "colgroup" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" } ) ; OBSOLETE_STYLE_ATTRS . put ( "vlink" , new String [ ] { "body" } ) ; OBSOLETE_STYLE_ATTRS . put ( "vspace" , new String [ ] { "img" , "object" , "embed" } ) ; OBSOLETE_STYLE_ATTRS . put ( "width" , new String [ ] { "hr" , "table" , "td" , "th" , "col" , "colgroup" , "pre" } ) ; } private static final String [ ] SPECIAL_ANCESTORS = { "a" , "address" , "button" , "caption" , "dfn" , "dt" , "figcaption" , "figure" , "footer" , "form" , "header" , "label" , "map" , "noscript" , "th" , "time" , "progress" , "meter" , "article" , "aside" , "nav" } ; private static int specialAncestorNumber ( String name ) { for ( int i = 0 ; i < SPECIAL_ANCESTORS . length ; i ++ ) { if ( name == SPECIAL_ANCESTORS [ i ] ) { return i ; } } return - 1 ; } private static Map < String , Integer > ANCESTOR_MASK_BY_DESCENDANT = new HashMap < String , Integer > ( ) ; private static void registerProhibitedAncestor ( String ancestor , String descendant ) { int number = specialAncestorNumber ( ancestor ) ; if ( number == - 1 ) { throw new IllegalStateException ( "Ancestor not found in array: " + ancestor ) ; } Integer maskAsObject = ANCESTOR_MASK_BY_DESCENDANT . get ( descendant ) ; int mask = 0 ; if ( maskAsObject != null ) { mask = maskAsObject . intValue ( ) ; } mask |= ( 1 << number ) ; ANCESTOR_MASK_BY_DESCENDANT . put ( descendant , new Integer ( mask ) ) ; } static { registerProhibitedAncestor ( "form" , "form" ) ; registerProhibitedAncestor ( "time" , "time" ) ; registerProhibitedAncestor ( "progress" , "progress" ) ; registerProhibitedAncestor ( "meter" , "meter" ) ; registerProhibitedAncestor ( "dfn" , "dfn" ) ; registerProhibitedAncestor ( "noscript" , "noscript" ) ; registerProhibitedAncestor ( "label" , "label" ) ; registerProhibitedAncestor ( "address" , "address" ) ; registerProhibitedAncestor ( "address" , "section" ) ; registerProhibitedAncestor ( "address" , "nav" ) ; registerProhibitedAncestor ( "address" , "article" ) ; registerProhibitedAncestor ( "address" , "aside" ) ; registerProhibitedAncestor ( "header" , "header" ) ; registerProhibitedAncestor ( "footer" , "header" ) ; registerProhibitedAncestor ( "address" , "header" ) ; registerProhibitedAncestor ( "header" , "footer" ) ; registerProhibitedAncestor ( "footer" , "footer" ) ; registerProhibitedAncestor ( "dt" , "header" ) ; registerProhibitedAncestor ( "dt" , "footer" ) ; registerProhibitedAncestor ( "dt" , "article" ) ; registerProhibitedAncestor ( "dt" , "aside" ) ; registerProhibitedAncestor ( "dt" , "nav" ) ; registerProhibitedAncestor ( "dt" , "section" ) ; registerProhibitedAncestor ( "dt" , "h1" ) ; registerProhibitedAncestor ( "dt" , "h2" ) ; registerProhibitedAncestor ( "dt" , "h2" ) ; registerProhibitedAncestor ( "dt" , "h3" ) ; registerProhibitedAncestor ( "dt" , "h4" ) ; registerProhibitedAncestor ( "dt" , "h5" ) ; registerProhibitedAncestor ( "dt" , "h6" ) ; registerProhibitedAncestor ( "dt" , "hgroup" ) ; registerProhibitedAncestor ( "th" , "header" ) ; registerProhibitedAncestor ( "th" , "footer" ) ; registerProhibitedAncestor ( "th" , "article" ) ; registerProhibitedAncestor ( "th" , "aside" ) ; registerProhibitedAncestor ( "th" , "nav" ) ; registerProhibitedAncestor ( "th" , "section" ) ; registerProhibitedAncestor ( "th" , "h1" ) ; registerProhibitedAncestor ( "th" , "h2" ) ; registerProhibitedAncestor ( "th" , "h2" ) ; registerProhibitedAncestor ( "th" , "h3" ) ; registerProhibitedAncestor ( "th" , "h4" ) ; registerProhibitedAncestor ( "th" , "h5" ) ; registerProhibitedAncestor ( "th" , "h6" ) ; registerProhibitedAncestor ( "th" , "hgroup" ) ; registerProhibitedAncestor ( "address" , "footer" ) ; registerProhibitedAncestor ( "address" , "h1" ) ; registerProhibitedAncestor ( "address" , "h2" ) ; registerProhibitedAncestor ( "address" , "h3" ) ; registerProhibitedAncestor ( "address" , "h4" ) ; registerProhibitedAncestor ( "address" , "h5" ) ; registerProhibitedAncestor ( "address" , "h6" ) ; registerProhibitedAncestor ( "a" , "a" ) ; registerProhibitedAncestor ( "button" , "a" ) ; registerProhibitedAncestor ( "a" , "details" ) ; registerProhibitedAncestor ( "button" , "details" ) ; registerProhibitedAncestor ( "a" , "button" ) ; registerProhibitedAncestor ( "button" , "button" ) ; registerProhibitedAncestor ( "a" , "textarea" ) ; registerProhibitedAncestor ( "button" , "textarea" ) ; registerProhibitedAncestor ( "a" , "select" ) ; registerProhibitedAncestor ( "button" , "select" ) ; registerProhibitedAncestor ( "a" , "keygen" ) ; registerProhibitedAncestor ( "button" , "keygen" ) ; registerProhibitedAncestor ( "a" , "embed" ) ; registerProhibitedAncestor ( "button" , "embed" ) ; registerProhibitedAncestor ( "a" , "iframe" ) ; registerProhibitedAncestor ( "button" , "iframe" ) ; registerProhibitedAncestor ( "a" , "label" ) ; registerProhibitedAncestor ( "button" , "label" ) ; registerProhibitedAncestor ( "caption" , "table" ) ; registerProhibitedAncestor ( "article" , "main" ) ; registerProhibitedAncestor ( "aside" , "main" ) ; registerProhibitedAncestor ( "header" , "main" ) ; registerProhibitedAncestor ( "footer" , "main" ) ; registerProhibitedAncestor ( "nav" , "main" ) ; } private static final int A_BUTTON_MASK = ( 1 << specialAncestorNumber ( "a" ) ) | ( 1 << specialAncestorNumber ( "button" ) ) ; private static final int FIGCAPTION_MASK = ( 1 << specialAncestorNumber ( "figcaption" ) ) ; private static final int FIGURE_MASK = ( 1 << specialAncestorNumber ( "figure" ) ) ; private static final int MAP_MASK = ( 1 << specialAncestorNumber ( "map" ) ) ; private static final int HREF_MASK = ( 1 << 30 ) ; private static final int LABEL_FOR_MASK = ( 1 << 28 ) ; private static final Map < String , Set < String > > REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT = new HashMap < String , Set < String > > ( ) ; private static final Map < String , Set < String > > ariaOwnsIdsByRole = new HashMap < String , Set < String > > ( ) ; private static void registerRequiredAncestorRole ( String parent , String child ) { Set < String > parents = REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT . get ( child ) ; if ( parents == null ) { parents = new HashSet < String > ( ) ; } parents . add ( parent ) ; REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT . put ( child , parents ) ; } static { registerRequiredAncestorRole ( "combobox" , "option" ) ; registerRequiredAncestorRole ( "listbox" , "option" ) ; registerRequiredAncestorRole ( "radiogroup" , "option" ) ; registerRequiredAncestorRole ( "menu" , "option" ) ; registerRequiredAncestorRole ( "menu" , "menuitem" ) ; registerRequiredAncestorRole ( "menu" , "menuitemcheckbox" ) ; registerRequiredAncestorRole ( "menu" , "menuitemradio" ) ; registerRequiredAncestorRole ( "menubar" , "menuitem" ) ; registerRequiredAncestorRole ( "menubar" , "menuitemcheckbox" ) ; registerRequiredAncestorRole ( "menubar" , "menuitemradio" ) ; registerRequiredAncestorRole ( "tablist" , "tab" ) ; registerRequiredAncestorRole ( "tree" , "treeitem" ) ; registerRequiredAncestorRole ( "tree" , "option" ) ; registerRequiredAncestorRole ( "group" , "treeitem" ) ; registerRequiredAncestorRole ( "group" , "listitem" ) ; registerRequiredAncestorRole ( "group" , "menuitemradio" ) ; registerRequiredAncestorRole ( "list" , "listitem" ) ; registerRequiredAncestorRole ( "row" , "gridcell" ) ; registerRequiredAncestorRole ( "row" , "columnheader" ) ; registerRequiredAncestorRole ( "row" , "rowheader" ) ; registerRequiredAncestorRole ( "grid" , "row" ) ; registerRequiredAncestorRole ( "grid" , "rowgroup" ) ; registerRequiredAncestorRole ( "rowgroup" , "row" ) ; registerRequiredAncestorRole ( "treegrid" , "row" ) ; } private static final Set < String > MUST_NOT_DANGLE_IDREFS = new HashSet < String > ( ) ; static { MUST_NOT_DANGLE_IDREFS . add ( "aria-controls" ) ; MUST_NOT_DANGLE_IDREFS . add ( "aria-describedby" ) ; MUST_NOT_DANGLE_IDREFS . add ( "aria-flowto" ) ; MUST_NOT_DANGLE_IDREFS . add ( "aria-labelledby" ) ; MUST_NOT_DANGLE_IDREFS . add ( "aria-owns" ) ; } private class IdrefLocator { private final Locator locator ; private final String idref ; private final String additional ; public IdrefLocator ( Locator locator , String idref ) { this . locator = new LocatorImpl ( locator ) ; this . idref = idref ; this . additional = null ; } public IdrefLocator ( Locator locator , String idref , String additional ) { this . locator = new LocatorImpl ( locator ) ; this . idref = idref ; this . additional = additional ; } public Locator getLocator ( ) { return locator ; } public String getIdref ( ) { return idref ; } public String getAdditional ( ) { return additional ; } } private class StackNode { private final int ancestorMask ; private final String name ; private final String role ; private final String activeDescendant ; private final String forAttr ; private Set < Locator > imagesLackingAlt = new HashSet < Locator > ( ) ; private Locator nonEmptyOption = null ; private boolean children = false ; private boolean selectedOptions = false ; private boolean labeledDescendants = false ; private boolean trackDescendants = false ; private boolean textNodeFound = false ; private boolean imgFound = false ; private boolean embeddedContentFound = false ; private boolean figcaptionNeeded = false ; private boolean figcaptionContentFound = false ; private boolean optionNeeded = false ; private boolean optionFound = false ; private boolean noValueOptionFound = false ; private boolean emptyValueOptionFound = false ; public StackNode ( int ancestorMask , String name , String role , String activeDescendant , String forAttr ) { this . ancestorMask = ancestorMask ; this . name = name ; this . role = role ; this . activeDescendant = activeDescendant ; this . forAttr = forAttr ; } public int getAncestorMask ( ) { return ancestorMask ; } public String getName ( ) { return name ; } public boolean isChildren ( ) { return children ; } public void setChildren ( ) { this . children = true ; } public boolean isSelectedOptions ( ) { return selectedOptions ; } public void setSelectedOptions ( ) { this . selectedOptions = true ; } public boolean isLabeledDescendants ( ) { return labeledDescendants ; } public void setLabeledDescendants ( ) { this . labeledDescendants = true ; } public boolean isTrackDescendant ( ) { return trackDescendants ; } public void setTrackDescendants ( ) { this . trackDescendants = true ; } public String getRole ( ) { return role ; } public String getActiveDescendant ( ) { return activeDescendant ; } public String getForAttr ( ) { return forAttr ; } public boolean hasTextNode ( ) { return textNodeFound ; } public void setTextNodeFound ( ) { this . textNodeFound = true ; } public boolean hasImg ( ) { return imgFound ; } public void setImgFound ( ) { this . imgFound = true ; } public boolean hasEmbeddedContent ( ) { return embeddedContentFound ; } public void setEmbeddedContentFound ( ) { this . embeddedContentFound = true ; } public boolean needsFigcaption ( ) { return figcaptionNeeded ; } public void setFigcaptionNeeded ( ) { this . figcaptionNeeded = true ; } public boolean hasFigcaptionContent ( ) { return figcaptionContentFound ; } public void setFigcaptionContentFound ( ) { this . figcaptionContentFound = true ; } public Set < Locator > getImagesLackingAlt ( ) { return imagesLackingAlt ; } public void addImageLackingAlt ( Locator locator ) { this . imagesLackingAlt . add ( locator ) ; } public boolean isOptionNeeded ( ) { return optionNeeded ; } public void setOptionNeeded ( ) { this . optionNeeded = true ; } public boolean hasOption ( ) { return optionFound ; } public void setOptionFound ( ) { this . optionFound = true ; } public boolean hasNoValueOption ( ) { return noValueOptionFound ; } public void setNoValueOptionFound ( ) { this . noValueOptionFound = true ; } public boolean hasEmptyValueOption ( ) { return emptyValueOptionFound ; } public void setEmptyValueOptionFound ( ) { this . emptyValueOptionFound = true ; } public Locator nonEmptyOptionLocator ( ) { return nonEmptyOption ; } public void setNonEmptyOption ( Locator locator ) { this . nonEmptyOption = locator ; } } private StackNode [ ] stack ; private int currentPtr ; public Assertions ( ) { super ( ) ; } private void push ( StackNode node ) { currentPtr ++ ; if ( currentPtr == stack . length ) { StackNode [ ] newStack = new StackNode [ stack . length + 64 ] ; System . arraycopy ( stack , 0 , newStack , 0 , stack . length ) ; stack = newStack ; } stack [ currentPtr ] = node ; } private StackNode pop ( ) { return stack [ currentPtr -- ] ; } private StackNode peek ( ) { return stack [ currentPtr ] ; } private Map < StackNode , Locator > openSingleSelects = new HashMap < StackNode , Locator > ( ) ; private Map < StackNode , Locator > openLabels = new HashMap < StackNode , Locator > ( ) ; private Map < StackNode , TaintableLocatorImpl > openMediaElements = new HashMap < StackNode , TaintableLocatorImpl > ( ) ; private Map < StackNode , Locator > openActiveDescendants = new HashMap < StackNode , Locator > ( ) ; private LinkedHashSet < IdrefLocator > contextmenuReferences = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > menuIds = new HashSet < String > ( ) ; private LinkedHashSet < IdrefLocator > formControlReferences = new LinkedHashSet < IdrefLocator > ( ) ; private LinkedHashSet < IdrefLocator > needsAriaOwner = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > formControlIds = new HashSet < String > ( ) ; private LinkedHashSet < IdrefLocator > listReferences = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > listIds = new HashSet < String > ( ) ; private LinkedHashSet < IdrefLocator > ariaReferences = new LinkedHashSet < IdrefLocator > ( ) ; private Set < String > allIds = new HashSet < String > ( ) ; private int currentFigurePtr ; private boolean hasMain ; private final void errContainedInOrOwnedBy ( String role , Locator locator ) throws SAXException { err ( "An element with “role=" + role + "”" + " must be contained in, or owned by, an element with " + renderRoleSet ( REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT . get ( role ) ) + "." , locator ) ; } private boolean currentElementHasRequiredAncestorRole ( Set < String > requiredAncestorRoles ) { for ( String role : requiredAncestorRoles ) { for ( int i = 0 ; i < currentPtr ; i ++ ) { if ( role . equals ( stack [ currentPtr - i ] . getRole ( ) ) ) { return true ; } } } return false ; } @ Override public void endDocument ( ) throws SAXException { for ( IdrefLocator idrefLocator : contextmenuReferences ) { if ( ! menuIds . contains ( idrefLocator . getIdref ( ) ) ) { err ( "The “contextmenu” attribute must refer to a “menu” element." , idrefLocator . getLocator ( ) ) ; } } for ( IdrefLocator idrefLocator : formControlReferences ) { if ( ! formControlIds . contains ( idrefLocator . getIdref ( ) ) ) { err ( "The “for” attribute of the “label” element must refer to a form control." , idrefLocator . getLocator ( ) ) ; } } for ( IdrefLocator idrefLocator : listReferences ) { if ( ! listIds . contains ( idrefLocator . getIdref ( ) ) ) { err ( "The “list” attribute of the “input” element must refer to a “datalist” element." , idrefLocator . getLocator ( ) ) ; } } for ( IdrefLocator idrefLocator : ariaReferences ) { if ( ! allIds . contains ( idrefLocator . getIdref ( ) ) ) { err ( "The “" + idrefLocator . getAdditional ( ) + "” attribute must point to an element in the same document." , idrefLocator . getLocator ( ) ) ; } } for ( IdrefLocator idrefLocator : needsAriaOwner ) { boolean foundOwner = false ; String role = idrefLocator . getAdditional ( ) ; for ( String ownerRole : REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT . get ( role ) ) { if ( ariaOwnsIdsByRole . size ( ) != 0 && ariaOwnsIdsByRole . get ( ownerRole ) != null && ariaOwnsIdsByRole . get ( ownerRole ) . contains ( idrefLocator . getIdref ( ) ) ) { foundOwner = true ; break ; } } if ( ! foundOwner ) { errContainedInOrOwnedBy ( role , idrefLocator . getLocator ( ) ) ; } } reset ( ) ; stack = null ; } private static double getDoubleAttribute ( Attributes atts , String name ) { String str = atts . getValue ( "" , name ) ; if ( str == null ) { return Double . NaN ; } else { try { return Double . parseDouble ( str ) ; } catch ( NumberFormatException e ) { return Double . NaN ; } } } @ Override public void endElement ( String uri , String localName , String name ) throws SAXException { StackNode node = pop ( ) ; Locator locator = null ; openSingleSelects . remove ( node ) ; openLabels . remove ( node ) ; openMediaElements . remove ( node ) ; if ( "http://www.w3.org/1999/xhtml" == uri ) { if ( "figure" == localName ) { if ( ( node . needsFigcaption ( ) && ! node . hasFigcaptionContent ( ) ) || node . hasTextNode ( ) || node . hasEmbeddedContent ( ) ) { for ( Locator imgLocator : node . getImagesLackingAlt ( ) ) { err ( "An “img” element must have an" + " “alt” attribute, except under" + " certain conditions. For details, consult" + " guidance on providing text alternatives" + " for images." , imgLocator ) ; } } } else if ( "select" == localName && node . isOptionNeeded ( ) ) { if ( ! node . hasOption ( ) ) { err ( "A “select” element with a" + " “required” attribute and without a" + " “multiple” attribute, and whose size" + " is “1”, must have a child" + " “option” element." ) ; } if ( node . nonEmptyOptionLocator ( ) != null ) { err ( "The first child “option” element of a" + " “select” element with a" + " “required” attribute and without a" + " “multiple” attribute, and whose size" + " is “1”, must have either an empty" + " “value” attribute, or must have no" + " text content." , node . nonEmptyOptionLocator ( ) ) ; } } else if ( "option" == localName && ! stack [ currentPtr ] . hasOption ( ) ) { stack [ currentPtr ] . setOptionFound ( ) ; } } if ( ( locator = openActiveDescendants . remove ( node ) ) != null ) { warn ( "Attribute “aria-activedescendant” value should " + "either refer to a descendant element, or should " + "be accompanied by attribute “aria-owns”." , locator ) ; } } @ Override public void startDocument ( ) throws SAXException { reset ( ) ; stack = new StackNode [ 32 ] ; currentPtr = 0 ; currentFigurePtr = - 1 ; stack [ 0 ] = null ; hasMain = false ; } public void reset ( ) { openSingleSelects . clear ( ) ; openLabels . clear ( ) ; openMediaElements . clear ( ) ; openActiveDescendants . clear ( ) ; contextmenuReferences . clear ( ) ; menuIds . clear ( ) ; ariaOwnsIdsByRole . clear ( ) ; needsAriaOwner . clear ( ) ; formControlReferences . clear ( ) ; formControlIds . clear ( ) ; listReferences . clear ( ) ; listIds . clear ( ) ; ariaReferences . clear ( ) ; allIds . clear ( ) ; } @ Override public void startElement ( String uri , String localName , String name , Attributes atts ) throws SAXException { Set < String > ids = new HashSet < String > ( ) ; String role = null ; String activeDescendant = null ; String owns = null ; String forAttr = null ; boolean href = false ; boolean activeDescendantWithAriaOwns = false ; StackNode parent = peek ( ) ; int ancestorMask = 0 ; String parentRole = null ; String parentName = null ; if ( parent != null ) { ancestorMask = parent . getAncestorMask ( ) ; parentName = parent . getName ( ) ; parentRole = parent . getRole ( ) ; } if ( "http://www.w3.org/1999/xhtml" == uri ) { boolean controls = false ; boolean hidden = false ; boolean add = false ; boolean toolbar = false ; boolean usemap = false ; boolean ismap = false ; boolean selected = false ; boolean itemid = false ; boolean itemref = false ; boolean itemscope = false ; boolean itemtype = false ; boolean languageJavaScript = false ; boolean typeNotTextJavaScript = false ; String xmlLang = null ; String lang = null ; String id = null ; String contextmenu = null ; String list = null ; int len = atts . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { String attUri = atts . getURI ( i ) ; if ( attUri . length ( ) == 0 ) { String attLocal = atts . getLocalName ( i ) ; if ( "href" == attLocal ) { href = true ; } else if ( "controls" == attLocal ) { controls = true ; } else if ( "type" == attLocal && "param" != localName && "ol" != localName && "ul" != localName && "li" != localName ) { String attValue = atts . getValue ( i ) ; if ( lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "hidden" , attValue ) ) { hidden = true ; } else if ( lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "toolbar" , attValue ) ) { toolbar = true ; } if ( ! lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "text/javascript" , attValue ) ) { typeNotTextJavaScript = true ; } } else if ( "role" == attLocal ) { role = atts . getValue ( i ) ; } else if ( "aria-activedescendant" == attLocal ) { activeDescendant = atts . getValue ( i ) ; } else if ( "aria-owns" == attLocal ) { owns = atts . getValue ( i ) ; } else if ( "list" == attLocal ) { list = atts . getValue ( i ) ; } else if ( "lang" == attLocal ) { lang = atts . getValue ( i ) ; } else if ( "id" == attLocal ) { id = atts . getValue ( i ) ; } else if ( "for" == attLocal && "label" == localName ) { forAttr = atts . getValue ( i ) ; ancestorMask |= LABEL_FOR_MASK ; } else if ( "contextmenu" == attLocal ) { contextmenu = atts . getValue ( i ) ; } else if ( "ismap" == attLocal ) { ismap = true ; } else if ( "selected" == attLocal ) { selected = true ; } else if ( "usemap" == attLocal && "input" != localName ) { usemap = true ; } else if ( "itemid" == attLocal ) { itemid = true ; } else if ( "itemref" == attLocal ) { itemref = true ; } else if ( "itemscope" == attLocal ) { itemscope = true ; } else if ( "itemtype" == attLocal ) { itemtype = true ; } else if ( "language" == attLocal && lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "javascript" , atts . getValue ( i ) ) ) { languageJavaScript = true ; } else if ( "rev" == attLocal && ! ( "1" . equals ( System . getProperty ( "nu.validator.schema.rev-allowed" ) ) ) ) { err ( "The “rev” attribute on the “" + localName + "” element is obsolete. " + "Use the “rel” attribute instead, " + "with a term having the opposite meaning." ) ; } else if ( OBSOLETE_ATTRIBUTES . containsKey ( attLocal ) && "ol" != localName && "ul" != localName && "li" != localName ) { String [ ] elementNames = OBSOLETE_ATTRIBUTES . get ( attLocal ) ; Arrays . sort ( elementNames ) ; if ( Arrays . binarySearch ( elementNames , localName ) >= 0 ) { String suggestion = OBSOLETE_ATTRIBUTES_MSG . containsKey ( attLocal ) ? " " + OBSOLETE_ATTRIBUTES_MSG . get ( attLocal ) : "" ; err ( "The “" + attLocal + "” attribute on the “" + localName + "” element is obsolete." + suggestion ) ; } } else if ( OBSOLETE_STYLE_ATTRS . containsKey ( attLocal ) ) { String [ ] elementNames = OBSOLETE_STYLE_ATTRS . get ( attLocal ) ; Arrays . sort ( elementNames ) ; if ( Arrays . binarySearch ( elementNames , localName ) >= 0 ) { err ( "The “" + attLocal + "” attribute on the “" + localName + "” element is obsolete. Use CSS instead." ) ; } } else if ( "dropzone" == attLocal ) { String [ ] tokens = atts . getValue ( i ) . toString ( ) . split ( "[ \\t\\n\\f\\r]+" ) ; Arrays . sort ( tokens ) ; for ( int j = 0 ; j < tokens . length ; j ++ ) { String keyword = tokens [ j ] ; if ( j > 0 && keyword . equals ( tokens [ j - 1 ] ) ) { err ( "Duplicate keyword " + keyword + ". Each keyword must be unique." ) ; } } } } else if ( "http://www.w3.org/XML/1998/namespace" == attUri ) { if ( "lang" == atts . getLocalName ( i ) ) { xmlLang = atts . getValue ( i ) ; } } if ( atts . getType ( i ) == "ID" ) { String attVal = atts . getValue ( i ) ; if ( attVal . length ( ) != 0 ) { ids . add ( attVal ) ; } } } if ( "figure" == localName ) { currentFigurePtr = currentPtr + 1 ; } if ( ( ancestorMask & FIGURE_MASK ) != 0 ) { if ( "img" == localName ) { if ( stack [ currentFigurePtr ] . hasImg ( ) ) { stack [ currentFigurePtr ] . setEmbeddedContentFound ( ) ; } else { stack [ currentFigurePtr ] . setImgFound ( ) ; } } else if ( "audio" == localName || "canvas" == localName || "embed" == localName || "iframe" == localName || "math" == localName || "object" == localName || "svg" == localName || "video" == localName ) { stack [ currentFigurePtr ] . setEmbeddedContentFound ( ) ; } } if ( "option" == localName && ! parent . hasOption ( ) ) { if ( atts . getIndex ( "" , "value" ) < 0 ) { parent . setNoValueOptionFound ( ) ; } else if ( atts . getIndex ( "" , "value" ) > - 1 && "" . equals ( atts . getValue ( "" , "value" ) ) ) { parent . setEmptyValueOptionFound ( ) ; } else { parent . setNonEmptyOption ( ( new LocatorImpl ( getDocumentLocator ( ) ) ) ) ; } } if ( OBSOLETE_ELEMENTS . get ( localName ) != null ) { err ( "The “" + localName + "” element is obsolete. " + OBSOLETE_ELEMENTS . get ( localName ) ) ; } Integer maskAsObject ; int mask = 0 ; String descendantUiString = "" ; if ( ( maskAsObject = ANCESTOR_MASK_BY_DESCENDANT . get ( localName ) ) != null ) { mask = maskAsObject . intValue ( ) ; descendantUiString = localName ; } else if ( "video" == localName && controls ) { mask = A_BUTTON_MASK ; descendantUiString = "video” with the attribute “controls" ; } else if ( "audio" == localName && controls ) { mask = A_BUTTON_MASK ; descendantUiString = "audio” with the attribute “controls" ; } else if ( "menu" == localName && toolbar ) { mask = A_BUTTON_MASK ; descendantUiString = "menu” with the attribute “type=toolbar" ; } else if ( "img" == localName && usemap ) { mask = A_BUTTON_MASK ; descendantUiString = "img” with the attribute “usemap" ; } else if ( "object" == localName && usemap ) { mask = A_BUTTON_MASK ; descendantUiString = "object” with the attribute “usemap" ; } else if ( "input" == localName && ! hidden ) { mask = A_BUTTON_MASK ; descendantUiString = "input" ; } if ( mask != 0 ) { int maskHit = ancestorMask & mask ; if ( maskHit != 0 ) { for ( int j = 0 ; j < SPECIAL_ANCESTORS . length ; j ++ ) { if ( ( maskHit & 1 ) != 0 ) { err ( "The element “" + descendantUiString + "” must not appear as a descendant of the “" + SPECIAL_ANCESTORS [ j ] + "” element." ) ; } maskHit >>= 1 ; } } } if ( "area" == localName && ( ( ancestorMask & MAP_MASK ) == 0 ) ) { err ( "The “area” element must have a “map” ancestor." ) ; } else if ( "img" == localName ) { String titleVal = atts . getValue ( "" , "title" ) ; if ( ismap && ( ( ancestorMask & HREF_MASK ) == 0 ) ) { err ( "The “img” element with the " + "“ismap” attribute set must have an " + "“a” ancestor with the " + "“href” attribute." ) ; } if ( atts . getIndex ( "" , "alt" ) < 0 ) { if ( w3cBranding || ( titleVal == null || "" . equals ( titleVal ) ) ) { if ( ( ancestorMask & FIGURE_MASK ) == 0 ) { err ( "An “img” element must have an" + " “alt” attribute, except under" + " certain conditions. For details, consult" + " guidance on providing text alternatives" + " for images." ) ; } else { stack [ currentFigurePtr ] . setFigcaptionNeeded ( ) ; stack [ currentFigurePtr ] . addImageLackingAlt ( new LocatorImpl ( getDocumentLocator ( ) ) ) ; } } } } else if ( "input" == localName || "button" == localName || "select" == localName || "textarea" == localName || "keygen" == localName ) { for ( Map . Entry < StackNode , Locator > entry : openLabels . entrySet ( ) ) { StackNode node = entry . getKey ( ) ; Locator locator = entry . getValue ( ) ; if ( node . isLabeledDescendants ( ) ) { err ( "The “label” element may contain at most one “input”, “button”, “select”, “textarea”, or “keygen” descendant." ) ; warn ( "“label” element with multiple labelable descendants." , locator ) ; } else { node . setLabeledDescendants ( ) ; } } if ( ( ancestorMask & LABEL_FOR_MASK ) != 0 ) { boolean hasMatchingFor = false ; for ( int i = 0 ; ( stack [ currentPtr - i ] . getAncestorMask ( ) & LABEL_FOR_MASK ) != 0 ; i ++ ) { String forVal = stack [ currentPtr - i ] . getForAttr ( ) ; if ( forVal != null && forVal . equals ( id ) ) { hasMatchingFor = true ; break ; } } if ( id == null || ! hasMatchingFor ) { err ( "Any “" + localName + "” descendant of a “label” element with a “for” attribute must have an ID value that matches that “for” attribute." ) ; } } } else if ( "table" == localName ) { if ( atts . getIndex ( "" , "summary" ) >= 0 ) { err ( "The “summary” attribute is obsolete." + " Consider describing the structure of the" + " “table” in a “caption” " + " element or in a “figure” element " + " containing the “table”; or," + " simplify the structure of the" + " “table” so that no description" + " is needed." ) ; } } else if ( "track" == localName && atts . getIndex ( "" , "default" ) >= 0 ) { for ( Map . Entry < StackNode , TaintableLocatorImpl > entry : openMediaElements . entrySet ( ) ) { StackNode node = entry . getKey ( ) ; TaintableLocatorImpl locator = entry . getValue ( ) ; if ( node . isTrackDescendant ( ) ) { err ( "The “default” attribute must not occur" + " on more than one “track” element" + " within the same “audio” or" + " “video” element." ) ; if ( ! locator . isTainted ( ) ) { warn ( "“audio” or “video” element" + " has more than one “track” child" + " element with a “default” attribute." , locator ) ; locator . markTainted ( ) ; } } else { node . setTrackDescendants ( ) ; } } } else if ( "main" == localName ) { if ( hasMain ) { err ( "A document must not include more than one" + " “main” element." ) ; } hasMain = true ; } else if ( "progress" == localName ) { double value = getDoubleAttribute ( atts , "value" ) ; if ( ! Double . isNaN ( value ) ) { double max = getDoubleAttribute ( atts , "max" ) ; if ( Double . isNaN ( max ) ) { if ( ! ( value <= 1.0 ) ) { err ( "The value of the  “value” attribute must be less than or equal to one when the “max” attribute is absent." ) ; } } else { if ( ! ( value <= max ) ) { err ( "The value of the  “value” attribute must be less than or equal to the value of the “max” attribute." ) ; } } } } else if ( "meter" == localName ) { double value = getDoubleAttribute ( atts , "value" ) ; double min = getDoubleAttribute ( atts , "min" ) ; double max = getDoubleAttribute ( atts , "max" ) ; double optimum = getDoubleAttribute ( atts , "optimum" ) ; double low = getDoubleAttribute ( atts , "low" ) ; double high = getDoubleAttribute ( atts , "high" ) ; if ( ! Double . isNaN ( min ) && ! Double . isNaN ( value ) && ! ( min <= value ) ) { err ( "The value of the “min” attribute must be less than or equal to the value of the “value” attribute." ) ; } if ( Double . isNaN ( min ) && ! Double . isNaN ( value ) && ! ( 0 <= value ) ) { err ( "The value of the “value” attribute must be greater than or equal to zero when the “min” attribute is absent." ) ; } if ( ! Double . isNaN ( value ) && ! Double . isNaN ( max ) && ! ( value <= max ) ) { err ( "The value of the “value” attribute must be less than or equal to the value of the “max” attribute." ) ; } if ( ! Double . isNaN ( value ) && Double . isNaN ( max ) && ! ( value <= 1 ) ) { err ( "The value of the “value” attribute must be less than or equal to one when the “max” attribute is absent." ) ; } if ( ! Double . isNaN ( min ) && ! Double . isNaN ( max ) && ! ( min <= max ) ) { err ( "The value of the “min” attribute must be less than or equal to the value of the “max” attribute." ) ; } if ( Double . isNaN ( min ) && ! Double . isNaN ( max ) && ! ( 0 <= max ) ) { err ( "The value of the “max” attribute must be greater than or equal to zero when the “min” attribute is absent." ) ; } if ( ! Double . isNaN ( min ) && Double . isNaN ( max ) && ! ( min <= 1 ) ) { err ( "The value of the “min” attribute must be less than or equal to one when the “max” attribute is absent." ) ; } if ( ! Double . isNaN ( min ) && ! Double . isNaN ( low ) && ! ( min <= low ) ) { err ( "The value of the “min” attribute must be less than or equal to the value of the “low” attribute." ) ; } if ( Double . isNaN ( min ) && ! Double . isNaN ( low ) && ! ( 0 <= low ) ) { err ( "The value of the “low” attribute must be greater than or equal to zero when the “min” attribute is absent." ) ; } if ( ! Double . isNaN ( min ) && ! Double . isNaN ( high ) && ! ( min <= high ) ) { err ( "The value of the “min” attribute must be less than or equal to the value of the “high” attribute." ) ; } if ( Double . isNaN ( min ) && ! Double . isNaN ( high ) && ! ( 0 <= high ) ) { err ( "The value of the “high” attribute must be greater than or equal to zero when the “min” attribute is absent." ) ; } if ( ! Double . isNaN ( low ) && ! Double . isNaN ( high ) && ! ( low <= high ) ) { err ( "The value of the “low” attribute must be less than or equal to the value of the “high” attribute." ) ; } if ( ! Double . isNaN ( high ) && ! Double . isNaN ( max ) && ! ( high <= max ) ) { err ( "The value of the “high” attribute must be less than or equal to the value of the “max” attribute." ) ; } if ( ! Double . isNaN ( high ) && Double . isNaN ( max ) && ! ( high <= 1 ) ) { err ( "The value of the “high” attribute must be less than or equal to one when the “max” attribute is absent." ) ; } if ( ! Double . isNaN ( low ) && ! Double . isNaN ( max ) && ! ( low <= max ) ) { err ( "The value of the “low” attribute must be less than or equal to the value of the “max” attribute." ) ; } if ( ! Double . isNaN ( low ) && Double . isNaN ( max ) && ! ( low <= 1 ) ) { err ( "The value of the “low” attribute must be less than or equal to one when the “max” attribute is absent." ) ; } if ( ! Double . isNaN ( min ) && ! Double . isNaN ( optimum ) && ! ( min <= optimum ) ) { err ( "The value of the “min” attribute must be less than or equal to the value of the “optimum” attribute." ) ; } if ( Double . isNaN ( min ) && ! Double . isNaN ( optimum ) && ! ( 0 <= optimum ) ) { err ( "The value of the “optimum” attribute must be greater than or equal to zero when the “min” attribute is absent." ) ; } if ( ! Double . isNaN ( optimum ) && ! Double . isNaN ( max ) && ! ( optimum <= max ) ) { err ( "The value of the “optimum” attribute must be less than or equal to the value of the “max” attribute." ) ; } if ( ! Double . isNaN ( optimum ) && Double . isNaN ( max ) && ! ( optimum <= 1 ) ) { err ( "The value of the “optimum” attribute must be less than or equal to one when the “max” attribute is absent." ) ; } } else if ( "map" == localName && id != null ) { String nameVal = atts . getValue ( "" , "name" ) ; if ( nameVal != null && ! nameVal . equals ( id ) ) { err ( "The “id” attribute on a “map” element must have an the same value as the “name” attribute." ) ; } } else if ( "script" == localName ) { if ( languageJavaScript && typeNotTextJavaScript ) { err ( "A “script” element with the “language=\"JavaScript\"” attribute set must not have a “type” attribute whose value is not “text/javascript”." ) ; } if ( atts . getIndex ( "" , "src" ) < 0 ) { if ( atts . getIndex ( "" , "charset" ) >= 0 ) { err ( "Element “script” must not have attribute “charset” unless attribute “src” is also specified." ) ; } if ( atts . getIndex ( "" , "defer" ) >= 0 ) { err ( "Element “script” must not have attribute “defer” unless attribute “src” is also specified." ) ; } if ( atts . getIndex ( "" , "async" ) >= 0 ) { err ( "Element “script” must not have attribute “async” unless attribute “src” is also specified." ) ; } } } else if ( "bdo" == localName && atts . getIndex ( "" , "dir" ) < 0 ) { err ( "Element “bdo” must have attribute “dir”." ) ; } if ( lang != null && xmlLang != null && ! equalsIgnoreAsciiCase ( lang , xmlLang ) ) { err ( "When the attribute “lang” in no namespace and the attribute “lang” in the XML namespace are both present, they must have the same value." ) ; } if ( contextmenu != null ) { contextmenuReferences . add ( new IdrefLocator ( new LocatorImpl ( getDocumentLocator ( ) ) , contextmenu ) ) ; } if ( "menu" == localName ) { menuIds . addAll ( ids ) ; } if ( role != null && owns != null ) { for ( Set < String > value : REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT . values ( ) ) { if ( value . contains ( role ) ) { String [ ] ownedIds = AttributeUtil . split ( owns ) ; for ( int i = 0 ; i < ownedIds . length ; i ++ ) { Set < String > ownedIdsForThisRole = ariaOwnsIdsByRole . get ( role ) ; if ( ownedIdsForThisRole == null ) { ownedIdsForThisRole = new HashSet < String > ( ) ; } ownedIdsForThisRole . add ( ownedIds [ i ] ) ; ariaOwnsIdsByRole . put ( role , ownedIdsForThisRole ) ; } break ; } } } if ( "datalist" == localName ) { listIds . addAll ( ids ) ; } if ( "label" == localName ) { String forVal = atts . getValue ( "" , "for" ) ; if ( forVal != null ) { formControlReferences . add ( new IdrefLocator ( new LocatorImpl ( getDocumentLocator ( ) ) , forVal ) ) ; } } if ( ( "input" == localName && ! hidden ) || "textarea" == localName || "select" == localName || "button" == localName || "keygen" == localName || "output" == localName ) { formControlIds . addAll ( ids ) ; } if ( "input" == localName && list != null ) { listReferences . add ( new IdrefLocator ( new LocatorImpl ( getDocumentLocator ( ) ) , list ) ) ; } if ( "input" == localName && lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "button" , atts . getValue ( "" , "type" ) ) ) { if ( atts . getValue ( "" , "value" ) == null || "" . equals ( atts . getValue ( "" , "value" ) ) ) { err ( "Element “input” with attribute “type” whose value is “button” must have non-empty attribute “value”." ) ; } } if ( "track" == localName ) { if ( "" . equals ( atts . getValue ( "" , "label" ) ) ) { err ( "Attribute “label” for element “track” must have non-empty value." ) ; } } if ( "option" == localName && selected ) { for ( Map . Entry < StackNode , Locator > entry : openSingleSelects . entrySet ( ) ) { StackNode node = entry . getKey ( ) ; if ( node . isSelectedOptions ( ) ) { err ( "The “select” element cannot have more than one selected “option” descendant unless the “multiple” attribute is specified." ) ; } else { node . setSelectedOptions ( ) ; } } } if ( "meta" == localName ) { if ( lowerCaseLiteralEqualsIgnoreAsciiCaseString ( "content-language" , atts . getValue ( "" , "http-equiv" ) ) ) { err ( "Using the “meta” element to specify the" + " document-wide default language is obsolete." + " Consider specifying the language on the root" + " element instead." ) ; } } if ( itemid && ! ( itemscope && itemtype ) ) { err ( "The “itemid” attribute must not be specified on elements that do not have both an “itemscope” attribute and an “itemtype” attribute specified." ) ; } if ( itemref && ! itemscope ) { err ( "The “itemref” attribute must not be specified on elements that do not have an “itemscope” attribute specified." ) ; } if ( itemtype && ! itemscope ) { err ( "The “itemtype” attribute must not be specified on elements that do not have an “itemscope” attribute specified." ) ; } } else { int len = atts . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( atts . getType ( i ) == "ID" ) { String attVal = atts . getValue ( i ) ; if ( attVal . length ( ) != 0 ) { ids . add ( attVal ) ; } } String attLocal = atts . getLocalName ( i ) ; if ( atts . getURI ( i ) . length ( ) == 0 ) { if ( "role" == attLocal ) { role = atts . getValue ( i ) ; } else if ( "aria-activedescendant" == attLocal ) { activeDescendant = atts . getValue ( i ) ; } else if ( "aria-owns" == attLocal ) { owns = atts . getValue ( i ) ; } } } allIds . addAll ( ids ) ; } Set < String > requiredAncestorRoles = REQUIRED_ROLE_ANCESTOR_BY_DESCENDANT . get ( role ) ; if ( requiredAncestorRoles != null && ! "presentation" . equals ( parentRole ) && ! "tbody" . equals ( localName ) && ! "tfoot" . equals ( localName ) && ! "thead" . equals ( localName ) ) { if ( ! currentElementHasRequiredAncestorRole ( requiredAncestorRoles ) ) { if ( atts . getIndex ( "" , "id" ) > - 1 && ! "" . equals ( atts . getValue ( "" , "id" ) ) ) { needsAriaOwner . add ( new IdrefLocator ( new LocatorImpl ( getDocumentLocator ( ) ) , atts . getValue ( "" , "id" ) , role ) ) ; } else { errContainedInOrOwnedBy ( role , getDocumentLocator ( ) ) ; } } } for ( String att : MUST_NOT_DANGLE_IDREFS ) { String attVal = atts . getValue ( "" , att ) ; if ( attVal != null ) { String [ ] tokens = AttributeUtil . split ( attVal ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { String token = tokens [ i ] ; ariaReferences . add ( new IdrefLocator ( getDocumentLocator ( ) , token , att ) ) ; } } } allIds . addAll ( ids ) ; if ( activeDescendant != null && ! "" . equals ( activeDescendant ) ) { if ( owns != null && ! "" . equals ( owns ) ) { activeDescendantWithAriaOwns = true ; } } for ( Iterator < Map . Entry < StackNode , Locator > > iterator = openActiveDescendants . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < StackNode , Locator > entry = iterator . next ( ) ; if ( ids . contains ( entry . getKey ( ) . getActiveDescendant ( ) ) ) { iterator . remove ( ) ; } } if ( "http://www.w3.org/1999/xhtml" == uri ) { int number = specialAncestorNumber ( localName ) ; if ( number > - 1 ) { ancestorMask |= ( 1 << number ) ; } if ( "a" == localName && href ) { ancestorMask |= HREF_MASK ; } StackNode child = new StackNode ( ancestorMask , localName , role , activeDescendant , forAttr ) ; if ( activeDescendant != null && ! activeDescendantWithAriaOwns ) { openActiveDescendants . put ( child , new LocatorImpl ( getDocumentLocator ( ) ) ) ; } if ( "select" == localName && atts . getIndex ( "" , "multiple" ) == - 1 ) { openSingleSelects . put ( child , getDocumentLocator ( ) ) ; } else if ( "label" == localName ) { openLabels . put ( child , new LocatorImpl ( getDocumentLocator ( ) ) ) ; } else if ( "video" == localName || "audio" == localName ) { openMediaElements . put ( child , new TaintableLocatorImpl ( getDocumentLocator ( ) ) ) ; } push ( child ) ; if ( "select" == localName && atts . getIndex ( "" , "required" ) > - 1 && atts . getIndex ( "" , "multiple" ) < 0 ) { if ( atts . getIndex ( "" , "size" ) > - 1 ) { String size = trimSpaces ( atts . getValue ( "" , "size" ) ) ; if ( ! "" . equals ( size ) ) { try { if ( ( size . length ( ) > 1 && size . charAt ( 0 ) == '+' && Integer . parseInt ( size . substring ( 1 ) ) == 1 ) || Integer . parseInt ( size ) == 1 ) { child . setOptionNeeded ( ) ; } else { } } catch ( NumberFormatException e ) { } } } else { child . setOptionNeeded ( ) ; } } } else { StackNode child = new StackNode ( ancestorMask , null , role , activeDescendant , forAttr ) ; if ( activeDescendant != null ) { openActiveDescendants . put ( child , new LocatorImpl ( getDocumentLocator ( ) ) ) ; } push ( child ) ; } } private void processChildContent ( StackNode parent ) throws SAXException { if ( parent == null ) { return ; } parent . setChildren ( ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { StackNode node = peek ( ) ; for ( int i = start ; i < start + length ; i ++ ) { char c = ch [ i ] ; switch ( c ) { case ' ' : case '\t' : case '\r' : case '\n' : continue ; default : if ( "figcaption" . equals ( node . name ) || ( node . ancestorMask & FIGCAPTION_MASK ) != 0 ) { if ( ( node . ancestorMask & FIGURE_MASK ) != 0 ) { stack [ currentFigurePtr ] . setFigcaptionContentFound ( ) ; } for ( int j = 1 ; j < currentFigurePtr ; j ++ ) { if ( "figure" . equals ( stack [ currentFigurePtr - j ] . getName ( ) ) ) { stack [ currentFigurePtr - j ] . setTextNodeFound ( ) ; } } } else if ( "figure" . equals ( node . name ) || ( node . ancestorMask & FIGURE_MASK ) != 0 ) { stack [ currentFigurePtr ] . setTextNodeFound ( ) ; for ( int k = 1 ; k < currentFigurePtr ; k ++ ) { if ( "figure" . equals ( stack [ currentFigurePtr - k ] . getName ( ) ) ) { stack [ currentFigurePtr - k ] . setTextNodeFound ( ) ; } } } else if ( "option" . equals ( node . name ) && ! stack [ currentPtr - 1 ] . hasOption ( ) && ( ! stack [ currentPtr - 1 ] . hasEmptyValueOption ( ) || stack [ currentPtr - 1 ] . hasNoValueOption ( ) ) && stack [ currentPtr - 1 ] . nonEmptyOptionLocator ( ) == null ) { stack [ currentPtr - 1 ] . setNonEmptyOption ( ( new LocatorImpl ( getDocumentLocator ( ) ) ) ) ; } processChildContent ( node ) ; return ; } } } private CharSequence renderRoleSet ( Set < String > roles ) { boolean first = true ; StringBuilder sb = new StringBuilder ( ) ; for ( String role : roles ) { if ( first ) { first = false ; } else { sb . append ( " or " ) ; } sb . append ( "“role=" ) ; sb . append ( role ) ; sb . append ( '”' ) ; } return sb ; } } 
=======
public class FlagOption implements Option { private final FlagPropertyId pid ; public FlagOption ( FlagPropertyId pid ) { this . pid = pid ; } public FlagPropertyId getPropertyId ( ) { return pid ; } public Flag valueOf ( String arg ) throws OptionArgumentException { if ( arg != null ) throw new OptionArgumentPresenceException ( ) ; return Flag . PRESENT ; } public Object combine ( Object [ ] values ) { return null ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
