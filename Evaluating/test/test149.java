public class FilterableList implements List < IFeed > { private List < IFeed > sourceList ; private List < IFeed > filteredSourceList ; private MultiFilterAnd filter ; public FilterableList ( List < IFeed > aSourceList ) { sourceList = aSourceList ; filteredSourceList = clone ( aSourceList , new ArrayList < IFeed > ( aSourceList . size ( ) ) ) ; filter = new MultiFilterAnd ( "milti filter" ) ; } public void addFilter ( Filter aFilter , final int priority ) { final boolean becomeMoreRestrictive = filter . addFilter ( aFilter , priority ) ; if ( becomeMoreRestrictive ) { filteredSourceList = getFilteredList ( aFilter , filteredSourceList ) ; } else { filteredSourceList = getFilteredList ( filter , sourceList ) ; } } public void removeFilter ( Filter aFilter ) { if ( filter . removeFilter ( aFilter ) ) { filteredSourceList = getFilteredList ( filter , sourceList ) ; } } public int getFilterIndex ( Filter aFilter ) { return filter . getFilterIndex ( aFilter ) ; } public int size ( ) { return filteredSourceList . size ( ) ; } public void clear ( ) { sourceList . clear ( ) ; filteredSourceList . clear ( ) ; } public boolean isEmpty ( ) { return filteredSourceList . isEmpty ( ) ; } public Object [ ] toArray ( ) { return filteredSourceList . toArray ( ) ; } public IFeed get ( int index ) { return filteredSourceList . get ( index ) ; } public IFeed remove ( int index ) { final IFeed object = filteredSourceList . remove ( index ) ; sourceList . remove ( object ) ; return object ; } public void add ( int index , IFeed element ) { if ( filter . accept ( element ) ) { final IFeed objectAtIndex = filteredSourceList . get ( index ) ; filteredSourceList . add ( index , element ) ; sourceList . add ( sourceList . indexOf ( objectAtIndex ) , element ) ; } else { sourceList . add ( index , element ) ; } } public int indexOf ( Object o ) { return filteredSourceList . indexOf ( o ) ; } public int lastIndexOf ( Object o ) { return filteredSourceList . lastIndexOf ( o ) ; } public boolean add ( IFeed o ) { if ( filter . accept ( o ) ) filteredSourceList . add ( o ) ; sourceList . add ( o ) ; return true ; } public boolean contains ( Object o ) { return filteredSourceList . contains ( o ) ; } public boolean remove ( Object o ) { boolean containElement = filteredSourceList . remove ( o ) ; if ( containElement ) { sourceList . remove ( o ) ; } return containElement ; } public boolean addAll ( Collection < ? extends IFeed > c ) { return false ; } public boolean addAll ( int index , Collection < ? extends IFeed > c ) { return false ; } public boolean containsAll ( Collection < ? > c ) { return false ; } public boolean removeAll ( Collection < ? > c ) { return false ; } public boolean retainAll ( Collection < ? > c ) { return false ; } public Iterator < IFeed > iterator ( ) { return filteredSourceList . iterator ( ) ; } public List < IFeed > subList ( int fromIndex , int toIndex ) { return null ; } public ListIterator < IFeed > listIterator ( ) { return filteredSourceList . listIterator ( ) ; } public ListIterator < IFeed > listIterator ( int index ) { return filteredSourceList . listIterator ( index ) ; } public IFeed set ( int index , IFeed element ) { throw new IllegalArgumentException ( Strings . error ( "operation.is.not.supported" ) ) ; } public < T > T [ ] toArray ( T [ ] a ) { return filteredSourceList . toArray ( a ) ; } private List < IFeed > getFilteredList ( Filter aFilter , List < IFeed > aSourceList ) { ArrayList < IFeed > filteredList = new ArrayList < IFeed > ( aSourceList . size ( ) ) ; for ( IFeed feed : aSourceList ) { if ( aFilter . accept ( feed ) ) filteredList . add ( feed ) ; } return filteredList ; } private List < IFeed > clone ( List < IFeed > aListPrototype , List < IFeed > aListClone ) { aListClone . clear ( ) ; aListClone . addAll ( aListPrototype ) ; return aListClone ; } public abstract static class Filter { private String name ; public Filter ( final String filterName ) { name = filterName ; } public boolean equals ( Object object ) { return name . equalsIgnoreCase ( ( ( Filter ) object ) . name ) ; } public int hashCode ( ) { return super . hashCode ( ) ; } public String toString ( ) { return "Filter: " + name ; } public abstract boolean isMoreRestrictive ( final Filter aFilter ) ; public abstract boolean accept ( Object object ) ; } public static final class MultiFilterAnd extends Filter { private List < Filter > filters ; private List < Integer > filterPriorities ; public MultiFilterAnd ( String name ) { super ( name ) ; this . filters = new ArrayList < Filter > ( ) ; this . filterPriorities = new ArrayList < Integer > ( ) ; } public int getFilterIndex ( Filter aFilter ) { return filters . indexOf ( aFilter ) ; } public boolean addFilter ( Filter aFilter , final int priority ) { boolean becomeMoreRestrictive = true ; final int filterIndex = filters . indexOf ( aFilter ) ; if ( filterIndex == - 1 ) { int fi = - 1 ; for ( int i = 0 , n = filterPriorities . size ( ) ; ( i < n ) && ( fi == - 1 ) ; i ++ ) { if ( priority <= filterPriorities . get ( i ) ) { fi = i ; } } if ( fi == - 1 ) { filters . add ( aFilter ) ; filterPriorities . add ( priority ) ; } else { filters . add ( fi , aFilter ) ; filterPriorities . add ( fi , priority ) ; } } else { final Filter filterPrev = filters . get ( filterIndex ) ; if ( ! aFilter . isMoreRestrictive ( filterPrev ) ) { becomeMoreRestrictive = false ; } filters . set ( filterIndex , aFilter ) ; } return becomeMoreRestrictive ; } public boolean removeFilter ( Filter aFilter ) { boolean becomeLessRestrictive = false ; for ( int i = 0 , n = filters . size ( ) ; i < n && ! becomeLessRestrictive ; i ++ ) { if ( aFilter . equals ( filters . get ( i ) ) ) { filters . remove ( i ) ; filterPriorities . remove ( i ) ; becomeLessRestrictive = true ; } } return becomeLessRestrictive ; } public boolean removeFilter ( final String filterName ) { boolean becomeLessRestrictive = false ; for ( int i = 0 , n = filters . size ( ) ; i < n && ! becomeLessRestrictive ; i ++ ) { final Filter aFilter = this . filters . get ( i ) ; if ( filterName . equalsIgnoreCase ( aFilter . name ) ) { filters . remove ( i ) ; filterPriorities . remove ( i ) ; becomeLessRestrictive = true ; } } return becomeLessRestrictive ; } public boolean isMoreRestrictive ( Filter aFilter ) { return true ; } public boolean accept ( Object object ) { boolean isAccepted = true ; for ( int i = 0 , n = filters . size ( ) ; i < n && isAccepted ; i ++ ) { final Filter aFilter = filters . get ( i ) ; isAccepted = aFilter . accept ( object ) ; } return isAccepted ; } } } 