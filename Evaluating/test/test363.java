<<<<<<< HEAD
public class QuercusSessionManager { static protected final L10N L = new L10N ( QuercusSessionManager . class ) ; static protected final Logger log = Logger . getLogger ( QuercusSessionManager . class . getName ( ) ) ; private static int FALSE = 0 ; private static int COOKIE = 1 ; private static int TRUE = 2 ; private static int SET_TRUE = 1 ; private static int SET_FALSE = 2 ; protected LruCache < String , SessionArrayValue > _sessions ; protected Iterator < SessionArrayValue > _sessionIter ; protected ArrayList < SessionArrayValue > _sessionList = new ArrayList < SessionArrayValue > ( ) ; protected int _sessionMax = 4096 ; private long _sessionTimeout = 30 * 60 * 1000L ; private int _reuseSessionId = COOKIE ; @ SuppressWarnings ( "unused" ) private int _cookieLength = 18 ; private int _alwaysLoadSession ; private boolean _alwaysSaveSession ; private boolean _saveOnlyOnShutdown ; @ SuppressWarnings ( "unused" ) private boolean _isAppendServerIndex = false ; protected boolean _isClosed ; protected Object _statisticsLock = new Object ( ) ; protected long _sessionCreateCount ; protected long _sessionTimeoutCount ; public QuercusSessionManager ( ) { _sessions = new LruCache < String , SessionArrayValue > ( _sessionMax ) ; _sessionIter = _sessions . values ( ) ; } boolean getAlwaysSaveSession ( ) { return _alwaysSaveSession ; } public void setAlwaysSaveSession ( boolean save ) { _alwaysSaveSession = save ; } boolean getAlwaysLoadSession ( ) { return _alwaysLoadSession == SET_TRUE ; } public void setAlwaysLoadSession ( boolean load ) { _alwaysLoadSession = load ? SET_TRUE : SET_FALSE ; } public boolean getSaveOnlyOnShutdown ( ) { return _saveOnlyOnShutdown ; } public void setSaveOnlyOnShutdown ( boolean save ) { _saveOnlyOnShutdown = save ; } public void setSaveOnShutdown ( boolean save ) { log . warning ( "<save-on-shutdown> is deprecated.  Use <save-only-on-shutdown> instead" ) ; setSaveOnlyOnShutdown ( save ) ; } public void setCookieLength ( int cookieLength ) { if ( cookieLength < 7 ) cookieLength = 7 ; _cookieLength = cookieLength ; } protected void setSessionTimeout ( long sessionTimeout ) { _sessionTimeout = sessionTimeout ; } public int getActiveSessionCount ( ) { if ( _sessions == null ) return - 1 ; else return _sessions . size ( ) ; } public long getSessionCreateCount ( ) { return _sessionCreateCount ; } public long getSessionTimeoutCount ( ) { return _sessionTimeoutCount ; } public int getReuseSessionId ( ) { return _reuseSessionId ; } public void setReuseSessionId ( String reuse ) throws ConfigException { if ( reuse == null ) _reuseSessionId = COOKIE ; else if ( reuse . equalsIgnoreCase ( "true" ) || reuse . equalsIgnoreCase ( "yes" ) || reuse . equalsIgnoreCase ( "cookie" ) ) _reuseSessionId = COOKIE ; else if ( reuse . equalsIgnoreCase ( "false" ) || reuse . equalsIgnoreCase ( "no" ) ) _reuseSessionId = FALSE ; else if ( reuse . equalsIgnoreCase ( "all" ) ) _reuseSessionId = TRUE ; else throw new ConfigException ( L . l ( "'{0}' is an invalid value for reuse-session-id.  'true' or 'false' are the allowed values." , reuse ) ) ; } public boolean isClosed ( ) { return _isClosed ; } public int getSessionMax ( ) { return _sessionMax ; } public void setSessionMax ( int max ) { _sessionMax = max ; } public void removeSession ( String sessionId ) { _sessions . remove ( sessionId ) ; remove ( sessionId ) ; } protected void remove ( String sessionId ) { } public void load ( ObjectInputStream in , Object obj ) throws IOException { SessionArrayValue session = ( SessionArrayValue ) obj ; session . load ( null , in ) ; } public boolean isEmpty ( Object obj ) { SessionArrayValue session = ( SessionArrayValue ) obj ; return session . isEmpty ( ) ; } public void setCookieAppendServerIndex ( boolean isAppend ) { _isAppendServerIndex = isAppend ; } public SessionArrayValue createSession ( Env env , String oldId , long now ) { String id = oldId ; if ( id == null || id . length ( ) < 4 ) id = createSessionId ( env ) ; SessionArrayValue session = create ( env , id , now ) ; if ( session == null ) return null ; synchronized ( _statisticsLock ) { _sessionCreateCount ++ ; } return session ; } public String createSessionId ( Env env ) { String id ; do { CharBuffer sb = new CharBuffer ( ) ; Base64 . encode ( sb , RandomUtil . getRandomLong ( ) ) ; Base64 . encode ( sb , System . currentTimeMillis ( ) ) ; id = sb . toString ( ) ; } while ( getSession ( env , id , 0 ) != null ) ; if ( id == null || id . equals ( "" ) ) throw new RuntimeException ( ) ; return id ; } public SessionArrayValue getSession ( Env env , String key , long now ) { SessionArrayValue session ; boolean isNew = false ; if ( _sessions == null ) return null ; session = _sessions . get ( key ) ; if ( session != null && ! session . getId ( ) . equals ( key ) ) throw new IllegalStateException ( key + " != " + session . getId ( ) ) ; if ( session != null ) { if ( session . inUse ( ) ) { return ( SessionArrayValue ) session . copy ( env ) ; } } if ( session == null ) return null ; if ( isNew ) { isNew = ! load ( env , session , now ) ; } else if ( ! getSaveOnlyOnShutdown ( ) && ! session . load ( ) ) { session . reset ( now ) ; isNew = true ; } if ( ! isNew ) session . setAccess ( now ) ; return ( SessionArrayValue ) session . copy ( env ) ; } public void saveSession ( Env env , SessionArrayValue session ) { SessionArrayValue copy = ( SessionArrayValue ) session . copy ( env ) ; _sessions . put ( session . getId ( ) , copy ) ; session . finish ( ) ; } protected SessionArrayValue create ( Env env , String key , long now ) { SessionArrayValue session = createSessionValue ( key , now , _sessionTimeout ) ; load ( env , session , now ) ; session = _sessions . putIfNew ( key , session ) ; if ( ! key . equals ( session . getId ( ) ) ) throw new IllegalStateException ( key + " != " + session . getId ( ) ) ; return ( SessionArrayValue ) session . copy ( env ) ; } protected SessionArrayValue createSessionValue ( String key , long now , long sessionTimeout ) { return new SessionArrayValue ( key , now , _sessionTimeout ) ; } protected boolean load ( Env env , SessionArrayValue session , long now ) { try { if ( session . inUse ( ) ) { return true ; } else if ( now <= 0 ) { return false ; } else if ( session . load ( ) ) { session . setAccess ( now ) ; return true ; } else { session . reset ( now ) ; } } catch ( Exception e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; session . reset ( now ) ; } return false ; } public void handleAlarm ( ) { try { _sessionList . clear ( ) ; int liveSessions = 0 ; if ( _isClosed ) return ; long now = System . currentTimeMillis ( ) ; synchronized ( _sessions ) { _sessionIter = _sessions . values ( _sessionIter ) ; while ( _sessionIter . hasNext ( ) ) { SessionArrayValue session = _sessionIter . next ( ) ; long maxIdleTime = session . getMaxInactiveInterval ( ) ; if ( session . inUse ( ) ) liveSessions ++ ; else if ( session . getAccessTime ( ) + maxIdleTime < now ) _sessionList . add ( session ) ; else liveSessions ++ ; } } synchronized ( _statisticsLock ) { _sessionTimeoutCount += _sessionList . size ( ) ; } for ( int i = 0 ; i < _sessionList . size ( ) ; i ++ ) { SessionArrayValue session = _sessionList . get ( i ) ; try { session . getMaxInactiveInterval ( ) ; _sessions . remove ( session . getId ( ) ) ; session . invalidate ( ) ; } catch ( Throwable e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } } } finally { } } public void close ( ) { synchronized ( this ) { if ( _isClosed ) return ; _isClosed = true ; } if ( _sessions == null ) return ; _sessionList . clear ( ) ; ArrayList < SessionArrayValue > list = new ArrayList < SessionArrayValue > ( ) ; boolean isError = false ; synchronized ( _sessions ) { _sessionIter = _sessions . values ( _sessionIter ) ; while ( _sessionIter . hasNext ( ) ) { SessionArrayValue session = _sessionIter . next ( ) ; if ( session . isValid ( ) ) list . add ( session ) ; } } for ( int i = list . size ( ) - 1 ; i >= 0 ; i -- ) { SessionArrayValue session = list . get ( i ) ; try { if ( session . isValid ( ) ) { synchronized ( session ) { if ( ! session . isEmpty ( ) ) session . storeOnShutdown ( ) ; } } _sessions . remove ( session . getId ( ) ) ; } catch ( Exception e ) { if ( ! isError ) log . log ( Level . WARNING , "Can't store session: " + e , e ) ; isError = true ; } } } public void notifyRemove ( String id ) { SessionArrayValue session = _sessions . remove ( id ) ; if ( session != null ) session . invalidate ( ) ; } public void notifyUpdate ( String id ) { } public void store ( OutputStream out , Object obj ) throws IOException { SessionArrayValue session = ( SessionArrayValue ) obj ; session . store ( Env . getInstance ( ) , out ) ; } } 
=======
public class SchematronSchemaReaderFactory implements SchemaReaderFactory , TransformerFactoryInitializer { public SchemaReader createSchemaReader ( String namespaceUri ) { if ( namespaceUri . equals ( SchemaReaderImpl . SCHEMATRON_URI ) ) { try { return new SchemaReaderImpl ( newTransformerFactory ( ) , this ) ; } catch ( TransformerFactoryConfigurationError e ) { } catch ( IncorrectSchemaException e ) { } catch ( TransformerConfigurationException e ) { } } return null ; } public Option getOption ( String uri ) { return SchematronProperty . getOption ( uri ) ; } public SAXTransformerFactory newTransformerFactory ( ) { TransformerFactory factory = TransformerFactory . newInstance ( ) ; if ( factory . getFeature ( SAXTransformerFactory . FEATURE ) ) return ( SAXTransformerFactory ) factory ; throw new TransformerFactoryConfigurationError ( "JAXP TransformerFactory must support SAXTransformerFactory feature" ) ; } public void initTransformerFactory ( TransformerFactory factory ) { } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
