<<<<<<< HEAD
class RegexpSet { static final int BITSET_CHARS = 128 ; static RegexpSet SPACE = null ; static RegexpSet WORD = null ; static RegexpSet DIGIT = null ; static RegexpSet DOT = null ; static RegexpSet PALNUM = null ; static RegexpSet PALPHA = null ; static RegexpSet PASCII = null ; static RegexpSet PBLANK = null ; static RegexpSet PCNTRL = null ; static RegexpSet PDIGIT = null ; static RegexpSet PGRAPH = null ; static RegexpSet PLOWER = null ; static RegexpSet PPRINT = null ; static RegexpSet PPUNCT = null ; static RegexpSet PSPACE = null ; static RegexpSet PUPPER = null ; static RegexpSet PXDIGIT = null ; static HashMap < String , RegexpSet > CLASS_MAP = null ; boolean _bitset [ ] = new boolean [ BITSET_CHARS ] ; IntSet _range ; RegexpSet ( ) { _range = new IntSet ( ) ; } RegexpSet ( RegexpSet old ) { System . arraycopy ( old . _bitset , 0 , _bitset , 0 , _bitset . length ) ; _range = ( IntSet ) old . _range . clone ( ) ; } void mergeOr ( RegexpSet b ) { for ( int i = 0 ; i < BITSET_CHARS ; i ++ ) _bitset [ i ] = _bitset [ i ] || b . _bitset [ i ] ; _range . union ( b . _range ) ; } void mergeOrInv ( RegexpSet b ) { for ( int i = 0 ; i < BITSET_CHARS ; i ++ ) _bitset [ i ] = _bitset [ i ] || ! b . _bitset [ i ] ; _range . unionNegate ( b . _range , 0 , 0xffff ) ; } void setRange ( int low , int high ) { if ( low > high || low < 0 || high > 0xffff ) throw new RuntimeException ( "Range out of range" ) ; if ( low < BITSET_CHARS ) { for ( int i = low ; i < Math . min ( high + 1 , BITSET_CHARS ) ; i ++ ) _bitset [ i ] = true ; if ( high < BITSET_CHARS ) return ; low = BITSET_CHARS ; } _range . union ( low , high ) ; } boolean mergeOverlap ( RegexpSet next ) { boolean isDisjoint = true ; for ( int i = 0 ; i < BITSET_CHARS ; i ++ ) { _bitset [ i ] = _bitset [ i ] & next . _bitset [ i ] ; if ( _bitset [ i ] ) isDisjoint = false ; } if ( _range . intersection ( next . _range ) ) isDisjoint = false ; return isDisjoint ; } void difference ( RegexpSet next ) { for ( int i = 0 ; i < BITSET_CHARS ; i ++ ) { _bitset [ i ] = _bitset [ i ] & ! next . _bitset [ i ] ; } _range . difference ( next . _range ) ; } boolean match ( int ch ) { if ( ch < 0 ) return false ; else if ( ch < BITSET_CHARS ) return _bitset [ ch ] ; else { return _range . contains ( ch ) ; } } RegexpNode createNode ( ) { if ( _range . size ( ) == 0 ) return new RegexpNode . AsciiSet ( _bitset ) ; else return new RegexpNode . Set ( _bitset , _range ) ; } RegexpNode createNotNode ( ) { if ( _range . size ( ) == 0 ) return new RegexpNode . AsciiNotSet ( _bitset ) ; else return new RegexpNode . NotSet ( _bitset , _range ) ; } int getSize ( ) { return _range . size ( ) ; } static { SPACE = new RegexpSet ( ) ; SPACE . setRange ( ' ' , ' ' ) ; SPACE . setRange ( 0x09 , 0x0A ) ; SPACE . setRange ( 0x0C , 0x0D ) ; DOT = new RegexpSet ( ) ; DOT . setRange ( '\n' , '\n' ) ; DIGIT = new RegexpSet ( ) ; DIGIT . setRange ( '0' , '9' ) ; WORD = new RegexpSet ( ) ; WORD . setRange ( 'a' , 'z' ) ; WORD . setRange ( 'A' , 'Z' ) ; WORD . setRange ( '0' , '9' ) ; WORD . setRange ( '_' , '_' ) ; PASCII = new RegexpSet ( ) ; PASCII . setRange ( 0 , 0x7F ) ; PASCII . setRange ( 0x81 , 0x87 ) ; PASCII . setRange ( 0x89 , 0x97 ) ; PASCII . setRange ( 0x9A , 0xFF ) ; PBLANK = new RegexpSet ( ) ; PBLANK . setRange ( ' ' , ' ' ) ; PBLANK . setRange ( '\t' , '\t' ) ; PBLANK . setRange ( 0xA0 , 0xA0 ) ; PCNTRL = new RegexpSet ( ) ; PCNTRL . setRange ( 0 , 0x1F ) ; PCNTRL . setRange ( 0x7F , 0x7F ) ; PCNTRL . setRange ( 0x81 , 0x81 ) ; PCNTRL . setRange ( 0x8D , 0x8D ) ; PCNTRL . setRange ( 0x8F , 0x90 ) ; PCNTRL . setRange ( 0x9D , 0x9D ) ; PDIGIT = new RegexpSet ( ) ; PDIGIT . setRange ( '0' , '9' ) ; PDIGIT . setRange ( 0xB2 , 0xB3 ) ; PDIGIT . setRange ( 0xB9 , 0xB9 ) ; PLOWER = new RegexpSet ( ) ; PLOWER . setRange ( 'a' , 'z' ) ; PLOWER . setRange ( 0x83 , 0x83 ) ; PLOWER . setRange ( 0x9A , 0x9A ) ; PLOWER . setRange ( 0x9C , 0x9C ) ; PLOWER . setRange ( 0x9E , 0x9E ) ; PLOWER . setRange ( 0xAA , 0xAA ) ; PLOWER . setRange ( 0xB5 , 0xB5 ) ; PLOWER . setRange ( 0xBA , 0xBA ) ; PLOWER . setRange ( 0xDF , 0xF6 ) ; PLOWER . setRange ( 0xF8 , 0xFF ) ; PSPACE = new RegexpSet ( ) ; PSPACE . setRange ( ' ' , ' ' ) ; PSPACE . setRange ( 0x09 , 0x0D ) ; PSPACE . setRange ( 0xA0 , 0xA0 ) ; PUPPER = new RegexpSet ( ) ; PUPPER . setRange ( 'A' , 'Z' ) ; PUPPER . setRange ( 0x8A , 0x8A ) ; PUPPER . setRange ( 0x8C , 0x8C ) ; PUPPER . setRange ( 0x8E , 0x8E ) ; PUPPER . setRange ( 0x9F , 0x9F ) ; PUPPER . setRange ( 0xC0 , 0xD6 ) ; PUPPER . setRange ( 0xD8 , 0xDE ) ; PXDIGIT = new RegexpSet ( ) ; PXDIGIT . setRange ( '0' , '9' ) ; PXDIGIT . setRange ( 'A' , 'F' ) ; PXDIGIT . setRange ( 'a' , 'f' ) ; PALPHA = new RegexpSet ( ) ; PALPHA . mergeOr ( PLOWER ) ; PALPHA . mergeOr ( PUPPER ) ; PALNUM = new RegexpSet ( ) ; PALNUM . mergeOr ( PALPHA ) ; PALNUM . mergeOr ( PDIGIT ) ; PPUNCT = new RegexpSet ( ) ; PPUNCT . setRange ( 0x21 , 0x2F ) ; PPUNCT . setRange ( 0x3A , 0x40 ) ; PPUNCT . setRange ( 0x5B , 0x60 ) ; PPUNCT . setRange ( 0x7B , 0x7E ) ; PPUNCT . setRange ( 0x82 , 0x82 ) ; PPUNCT . setRange ( 0x84 , 0x87 ) ; PPUNCT . setRange ( 0x89 , 0x89 ) ; PPUNCT . setRange ( 0x8B , 0x8B ) ; PPUNCT . setRange ( 0x91 , 0x97 ) ; PPUNCT . setRange ( 0x9B , 0x9B ) ; PPUNCT . setRange ( 0xA1 , 0xBF ) ; PPUNCT . setRange ( 0xD7 , 0xD7 ) ; PPUNCT . setRange ( 0xF7 , 0xF7 ) ; PGRAPH = new RegexpSet ( ) ; PGRAPH . mergeOr ( PALNUM ) ; PGRAPH . mergeOr ( PPUNCT ) ; PPRINT = new RegexpSet ( ) ; PPRINT . mergeOr ( PGRAPH ) ; PPRINT . setRange ( ' ' , ' ' ) ; PPRINT . setRange ( 0x09 , 0x09 ) ; PPRINT . setRange ( 0xA0 , 0xA0 ) ; CLASS_MAP = new HashMap < String , RegexpSet > ( ) ; CLASS_MAP . put ( "alnum" , PALNUM ) ; CLASS_MAP . put ( "alpha" , PALPHA ) ; CLASS_MAP . put ( "ascii" , PASCII ) ; CLASS_MAP . put ( "blank" , PBLANK ) ; CLASS_MAP . put ( "cntrl" , PCNTRL ) ; CLASS_MAP . put ( "digit" , PDIGIT ) ; CLASS_MAP . put ( "graph" , PGRAPH ) ; CLASS_MAP . put ( "lower" , PLOWER ) ; CLASS_MAP . put ( "print" , PPRINT ) ; CLASS_MAP . put ( "punct" , PPUNCT ) ; CLASS_MAP . put ( "space" , PSPACE ) ; CLASS_MAP . put ( "upper" , PUPPER ) ; CLASS_MAP . put ( "xdigit" , PXDIGIT ) ; } } 
=======
class SchemaReaderImpl extends AbstractSchemaReader { static final String SCHEMATRON_URI = "http://www.ascc.net/xml/schematron" ; private static final String LOCATION_URI = "http://www.thaiopensource.com/ns/location" ; private static final String ERROR_URI = "http://www.thaiopensource.com/ns/error" ; private final Localizer localizer = new Localizer ( SchemaReaderImpl . class ) ; private final Class < ? extends SAXTransformerFactory > transformerFactoryClass ; private final TransformerFactoryInitializer transformerFactoryInitializer ; private final Templates schematron ; private final Schema schematronSchema ; private static final String SCHEMATRON_SCHEMA = "schematron.rnc" ; private static final String SCHEMATRON_STYLESHEET = "schematron.xsl" ; private static final String SCHEMATRON_XSLTC_STYLESHEET = "schematron-xsltc.xsl" ; private static final PropertyId < ? > [ ] supportedPropertyIds = { ValidateProperty . ERROR_HANDLER , ValidateProperty . XML_READER_CREATOR , ValidateProperty . ENTITY_RESOLVER , ValidateProperty . URI_RESOLVER , ValidateProperty . RESOLVER , SchematronProperty . DIAGNOSE , SchematronProperty . PHASE , } ; SchemaReaderImpl ( SAXTransformerFactory transformerFactory , TransformerFactoryInitializer transformerFactoryInitializer ) throws TransformerConfigurationException , IncorrectSchemaException { this . transformerFactoryClass = transformerFactory . getClass ( ) ; this . transformerFactoryInitializer = transformerFactoryInitializer ; final boolean isXsltc = isXsltc ( transformerFactoryClass ) ; final String stylesheet = isXsltc ? SCHEMATRON_XSLTC_STYLESHEET : SCHEMATRON_STYLESHEET ; final String resourceName = fullResourceName ( stylesheet ) ; final StreamSource source = new StreamSource ( getResourceAsStream ( resourceName ) ) ; initTransformerFactory ( transformerFactory ) ; schematron = transformerFactory . newTemplates ( source ) ; InputSource schemaSource = new InputSource ( getResourceAsStream ( fullResourceName ( SCHEMATRON_SCHEMA ) ) ) ; PropertyMapBuilder builder = new PropertyMapBuilder ( ) ; builder . put ( ValidateProperty . ERROR_HANDLER , new DraconianErrorHandler ( ) ) ; RngProperty . CHECK_ID_IDREF . add ( builder ) ; try { schematronSchema = CompactSchemaReader . getInstance ( ) . createSchema ( schemaSource , builder . toPropertyMap ( ) ) ; } catch ( SAXException e ) { throw new IncorrectSchemaException ( ) ; } catch ( IOException e ) { throw new IncorrectSchemaException ( ) ; } } static boolean isXsltc ( Class < ? extends SAXTransformerFactory > cls ) { return cls . getName ( ) . indexOf ( ".xsltc." ) >= 0 ; } public Option getOption ( String uri ) { return SchematronProperty . getOption ( uri ) ; } private void initTransformerFactory ( TransformerFactory factory ) { transformerFactoryInitializer . initTransformerFactory ( factory ) ; } static class UserException extends Exception { private final SAXException exception ; UserException ( SAXException exception ) { this . exception = exception ; } SAXException getException ( ) { return exception ; } } static class UserWrapErrorHandler extends CountingErrorHandler { UserWrapErrorHandler ( ErrorHandler errorHandler ) { super ( errorHandler ) ; } public void warning ( SAXParseException exception ) throws SAXException { try { super . warning ( exception ) ; } catch ( SAXException e ) { throw new SAXException ( new UserException ( e ) ) ; } } public void error ( SAXParseException exception ) throws SAXException { try { super . error ( exception ) ; } catch ( SAXException e ) { throw new SAXException ( new UserException ( e ) ) ; } } public void fatalError ( SAXParseException exception ) throws SAXException { try { super . fatalError ( exception ) ; } catch ( SAXException e ) { throw new SAXException ( new UserException ( e ) ) ; } } } static class ErrorFilter extends DelegatingContentHandler { private final ErrorHandler eh ; private final Localizer localizer ; private Locator locator ; ErrorFilter ( ContentHandler delegate , ErrorHandler eh , Localizer localizer ) { super ( delegate ) ; this . eh = eh ; this . localizer = localizer ; } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; super . setDocumentLocator ( locator ) ; } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { if ( namespaceURI . equals ( ERROR_URI ) && localName . equals ( "error" ) ) eh . error ( new SAXParseException ( localizer . message ( atts . getValue ( "" , "message" ) , atts . getValue ( "" , "arg" ) ) , locator ) ) ; super . startElement ( namespaceURI , localName , qName , atts ) ; } } static class LocationFilter extends DelegatingContentHandler implements Locator { private final String mainSystemId ; private String systemId = null ; private int lineNumber = - 1 ; private int columnNumber = - 1 ; private SAXException exception = null ; LocationFilter ( ContentHandler delegate , String systemId ) { super ( delegate ) ; this . mainSystemId = systemId ; } SAXException getException ( ) { return exception ; } public void setDocumentLocator ( Locator locator ) { } public void startDocument ( ) throws SAXException { getDelegate ( ) . setDocumentLocator ( this ) ; super . startDocument ( ) ; } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { systemId = getLocationAttribute ( atts , "system-id" ) ; lineNumber = toInteger ( getLocationAttribute ( atts , "line-number" ) ) ; columnNumber = toInteger ( getLocationAttribute ( atts , "column-number" ) ) ; try { super . startElement ( namespaceURI , localName , qName , atts ) ; } catch ( SAXException e ) { this . exception = e ; setDelegate ( null ) ; } systemId = null ; lineNumber = - 1 ; columnNumber = - 1 ; } private static String getLocationAttribute ( Attributes atts , String name ) { return atts . getValue ( LOCATION_URI , name ) ; } private static int toInteger ( String value ) { if ( value == null ) return - 1 ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { return - 1 ; } } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { if ( systemId != null && ! systemId . equals ( "" ) ) return systemId ; return mainSystemId ; } public int getLineNumber ( ) { return lineNumber ; } public int getColumnNumber ( ) { return columnNumber ; } } static class SAXErrorListener implements ErrorListener { private final ErrorHandler eh ; private final String systemId ; private boolean hadError = false ; SAXErrorListener ( ErrorHandler eh , String systemId ) { this . eh = eh ; this . systemId = systemId ; } boolean getHadError ( ) { return hadError ; } public void warning ( TransformerException exception ) throws TransformerException { SAXParseException spe = transform ( exception ) ; try { eh . warning ( spe ) ; } catch ( SAXException e ) { throw new TransformerException ( new UserException ( e ) ) ; } } public void error ( TransformerException exception ) throws TransformerException { hadError = true ; SAXParseException spe = transform ( exception ) ; try { eh . error ( spe ) ; } catch ( SAXException e ) { throw new TransformerException ( new UserException ( e ) ) ; } } public void fatalError ( TransformerException exception ) throws TransformerException { hadError = true ; SAXParseException spe = transform ( exception ) ; try { eh . fatalError ( spe ) ; } catch ( SAXException e ) { throw new TransformerException ( new UserException ( e ) ) ; } } SAXParseException transform ( TransformerException exception ) throws TransformerException { Throwable cause = exception . getException ( ) ; if ( cause instanceof RuntimeException ) throw ( RuntimeException ) cause ; if ( cause instanceof SAXException || cause instanceof IncorrectSchemaException || cause instanceof IOException ) throw exception ; SourceLocator locator = exception . getLocator ( ) ; if ( locator == null ) return new SAXParseException ( exception . getMessage ( ) , null ) ; String s = locator . getSystemId ( ) ; if ( s == null ) s = systemId ; return new SAXParseException ( exception . getMessage ( ) , locator . getPublicId ( ) , s , locator . getLineNumber ( ) , locator . getColumnNumber ( ) ) ; } } public Schema createSchema ( SAXSource source , PropertyMap properties ) throws IOException , SAXException , IncorrectSchemaException { ErrorHandler eh = properties . get ( ValidateProperty . ERROR_HANDLER ) ; CountingErrorHandler ceh = new CountingErrorHandler ( eh ) ; InputSource in = source . getInputSource ( ) ; String systemId = in . getSystemId ( ) ; IfValidHandler ifValidHandler = new IfValidHandler ( ) ; ifValidHandler . setErrorHandler ( ceh ) ; try { SAXTransformerFactory factory = ( SAXTransformerFactory ) transformerFactoryClass . newInstance ( ) ; initTransformerFactory ( factory ) ; TransformerHandler transformerHandler = factory . newTransformerHandler ( schematron ) ; ifValidHandler . setDelegate ( transformerHandler ) ; Transformer transformer = transformerHandler . getTransformer ( ) ; String phase = properties . get ( SchematronProperty . PHASE ) ; if ( phase != null ) transformer . setParameter ( "phase" , phase ) ; boolean diagnose = properties . contains ( SchematronProperty . DIAGNOSE ) ; if ( diagnose ) transformer . setParameter ( "diagnose" , Boolean . TRUE ) ; PropertyMapBuilder builder = new PropertyMapBuilder ( properties ) ; builder . put ( ValidateProperty . ERROR_HANDLER , ifValidHandler ) ; Validator validator = schematronSchema . createValidator ( builder . toPropertyMap ( ) ) ; ifValidHandler . setValidator ( validator . getContentHandler ( ) ) ; XMLReader xr = source . getXMLReader ( ) ; if ( xr == null ) xr = ResolverFactory . createResolver ( properties ) . createXMLReader ( ) ; xr . setContentHandler ( ifValidHandler ) ; xr . setDTDHandler ( validator . getDTDHandler ( ) ) ; factory . setErrorListener ( new SAXErrorListener ( ceh , systemId ) ) ; TemplatesHandler templatesHandler = factory . newTemplatesHandler ( ) ; templatesHandler . setSystemId ( systemId ) ; LocationFilter stage2 = new LocationFilter ( new ErrorFilter ( templatesHandler , ceh , localizer ) , systemId ) ; transformerHandler . setResult ( new SAXResult ( stage2 ) ) ; xr . setErrorHandler ( ceh ) ; xr . parse ( in ) ; SAXException exception = stage2 . getException ( ) ; if ( exception != null ) throw exception ; if ( ceh . getHadErrorOrFatalError ( ) ) throw new IncorrectSchemaException ( ) ; Templates templates = templatesHandler . getTemplates ( ) ; if ( ceh . getHadErrorOrFatalError ( ) ) throw new IncorrectSchemaException ( ) ; return new SchemaImpl ( templates , transformerFactoryClass , properties , supportedPropertyIds ) ; } catch ( SAXException e ) { throw cleanupSAXException ( e ) ; } catch ( TransformerConfigurationException e ) { throw new SAXException ( localizer . message ( "unexpected_schema_creation_error" ) ) ; } catch ( InstantiationException e ) { throw new SAXException ( e ) ; } catch ( IllegalAccessException e ) { throw new SAXException ( e ) ; } } private static String fullResourceName ( String name ) { String className = SchemaReaderImpl . class . getName ( ) ; return className . substring ( 0 , className . lastIndexOf ( '.' ) ) . replace ( '.' , '/' ) + "/resources/" + name ; } private static InputStream getResourceAsStream ( String resourceName ) { ClassLoader cl = SchemaReaderImpl . class . getClassLoader ( ) ; if ( cl == null ) return ClassLoader . getSystemResourceAsStream ( resourceName ) ; else return cl . getResourceAsStream ( resourceName ) ; } private static SAXException cleanupSAXException ( SAXException saxException ) { if ( exceptionHasLocation ( saxException ) ) return saxException ; Exception exception = saxException . getException ( ) ; if ( exception instanceof SAXException && exception . getMessage ( ) == null ) return cleanupSAXException ( ( SAXException ) exception ) ; if ( exception instanceof TransformerException ) return cleanupTransformerException ( ( TransformerException ) exception ) ; return saxException ; } private static SAXException cleanupTransformerException ( TransformerException e ) { String message = e . getMessage ( ) ; Throwable cause = e . getException ( ) ; SourceLocator transformLoc = e . getLocator ( ) ; if ( message != null && cause != null && message . equals ( cause . toString ( ) ) ) message = null ; if ( message == null && cause instanceof SAXException && transformLoc == null ) return cleanupSAXException ( ( SAXException ) cause ) ; if ( cause instanceof TransformerException && transformLoc == null ) return cleanupTransformerException ( ( TransformerException ) cause ) ; Exception exception = null ; if ( cause instanceof Exception ) exception = ( Exception ) cause ; String publicId = null ; String systemId = null ; int lineNumber = - 1 ; int columnNumber = - 1 ; if ( transformLoc != null ) { publicId = transformLoc . getPublicId ( ) ; systemId = transformLoc . getSystemId ( ) ; lineNumber = transformLoc . getLineNumber ( ) ; columnNumber = transformLoc . getColumnNumber ( ) ; } if ( publicId != null || systemId != null || lineNumber >= 0 || columnNumber >= 0 ) return new SAXParseException ( message , publicId , systemId , lineNumber , columnNumber , exception ) ; return new SAXException ( message , exception ) ; } private static boolean exceptionHasLocation ( SAXException saxException ) { if ( ! ( saxException instanceof SAXParseException ) ) return false ; SAXParseException pe = ( SAXParseException ) saxException ; return ( pe . getPublicId ( ) != null || pe . getSystemId ( ) != null || pe . getLineNumber ( ) >= 0 || pe . getColumnNumber ( ) >= 0 ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
