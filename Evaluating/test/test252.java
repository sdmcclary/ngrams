public final class Attributes extends Segment { private ArrayList attributeList = null ; private static final int AFTER_TAG_NAME = 0 ; private static final int BETWEEN_ATTRIBUTES = 1 ; private static final int IN_NAME = 2 ; private static final int AFTER_NAME = 3 ; private static final int START_VALUE = 4 ; private static final int IN_VALUE = 5 ; private static final int AFTER_VALUE_FINAL_QUOTE = 6 ; private static int defaultMaxErrorCount = 1 ; private Attributes ( Source source , int begin , int end , ArrayList attributeList ) { super ( source , begin , end ) ; this . attributeList = attributeList ; } static Attributes construct ( Source source , int begin , int maxEnd , int maxErrorCount ) { return construct ( source , "Attributes" , BETWEEN_ATTRIBUTES , begin , - 1 , maxEnd , null , maxErrorCount ) ; } static Attributes construct ( Source source , int startTagBegin , int attributesBegin , int maxEnd , String startTagName , int maxErrorCount ) { return construct ( source , "Attributes for StartTag" , BETWEEN_ATTRIBUTES , startTagBegin , attributesBegin , maxEnd , startTagName , maxErrorCount ) ; } static Attributes construct ( Source source , int startTagBegin , String startTagName ) { return construct ( source , "StartTag" , AFTER_TAG_NAME , startTagBegin , - 1 , - 1 , startTagName , defaultMaxErrorCount ) ; } private static Attributes construct ( Source source , String logType , int state , int logBegin , int attributesBegin , int maxEnd , String startTagName , int maxErrorCount ) { char optionalTerminatingChar = '/' ; if ( startTagName != null ) { if ( attributesBegin == - 1 ) attributesBegin = logBegin + 1 + startTagName . length ( ) ; if ( startTagName . charAt ( 0 ) == '?' ) optionalTerminatingChar = '?' ; } else { attributesBegin = logBegin ; } ArrayList attributeList = new ArrayList ( ) ; String lsource = source . getParseTextLowerCase ( ) ; int i = attributesBegin ; char quote = ' ' ; Segment nameSegment = null ; String key = null ; int currentBegin = - 1 ; boolean isTerminatingCharacter = false ; int errorCount = 0 ; try { while ( ! isTerminatingCharacter ) { char c = lsource . charAt ( i ) ; if ( c == '>' || i == maxEnd || ( c == optionalTerminatingChar && lsource . charAt ( i + 1 ) == '>' ) ) isTerminatingCharacter = true ; switch ( state ) { case IN_VALUE : if ( isTerminatingCharacter || c == quote || ( quote == ' ' && isWhiteSpace ( c ) ) ) { Segment valueSegment ; Segment valueSegmentIncludingQuotes ; if ( quote == ' ' ) { valueSegment = valueSegmentIncludingQuotes = new Segment ( source , currentBegin , i ) ; } else { if ( isTerminatingCharacter ) { if ( i == maxEnd ) { source . log ( logType , startTagName , logBegin , "terminated in the middle of a quoted attribute value" , i ) ; if ( reachedMaxErrorCount ( ++ errorCount , source , logType , startTagName , logBegin , maxErrorCount ) ) return null ; valueSegment = new Segment ( source , currentBegin , i ) ; valueSegmentIncludingQuotes = new Segment ( source , currentBegin - 1 , i ) ; } else { isTerminatingCharacter = false ; break ; } } else { valueSegment = new Segment ( source , currentBegin , i ) ; valueSegmentIncludingQuotes = new Segment ( source , currentBegin - 1 , i + 1 ) ; } } attributeList . add ( new Attribute ( source , key , nameSegment , valueSegment , valueSegmentIncludingQuotes ) ) ; state = BETWEEN_ATTRIBUTES ; } else if ( c == '<' && quote == ' ' ) { source . log ( logType , startTagName , logBegin , "rejected because of '<' character in unquoted attribute value" , i ) ; return null ; } break ; case IN_NAME : if ( isTerminatingCharacter || c == '=' || isWhiteSpace ( c ) ) { nameSegment = new Segment ( source , currentBegin , i ) ; key = nameSegment . getSourceText ( ) . toLowerCase ( ) ; if ( isTerminatingCharacter ) attributeList . add ( new Attribute ( source , key , nameSegment ) ) ; else state = ( c == '=' ? START_VALUE : AFTER_NAME ) ; } else if ( ! isIdentifierPart ( c ) ) { if ( c == '<' ) { source . log ( logType , startTagName , logBegin , "rejected because of '<' character in attribute name" , i ) ; return null ; } source . log ( logType , startTagName , logBegin , "contains attribute name with invalid character" , i ) ; if ( reachedMaxErrorCount ( ++ errorCount , source , logType , startTagName , logBegin , maxErrorCount ) ) return null ; } break ; case AFTER_NAME : if ( isTerminatingCharacter || ! ( c == '=' || isWhiteSpace ( c ) ) ) { attributeList . add ( new Attribute ( source , key , nameSegment ) ) ; if ( isTerminatingCharacter ) break ; state = BETWEEN_ATTRIBUTES ; i -- ; } else if ( c == '=' ) { state = START_VALUE ; } break ; case BETWEEN_ATTRIBUTES : if ( ! isTerminatingCharacter ) { if ( isWhiteSpace ( c ) ) { quote = ' ' ; } else { if ( quote != ' ' ) { source . log ( logType , startTagName , logBegin , "has missing whitespace after quoted attribute value" , i ) ; } if ( ! isIdentifierStart ( c ) ) { if ( c == '<' ) { source . log ( logType , startTagName , logBegin , "rejected because of '<' character" , i ) ; return null ; } source . log ( logType , startTagName , logBegin , "contains attribute name with invalid first character" , i ) ; if ( reachedMaxErrorCount ( ++ errorCount , source , logType , startTagName , logBegin , maxErrorCount ) ) return null ; } state = IN_NAME ; currentBegin = i ; } } break ; case START_VALUE : currentBegin = i ; if ( isTerminatingCharacter ) { source . log ( logType , startTagName , logBegin , "has missing attribute value after '=' sign" , i ) ; Segment valueSegment = new Segment ( source , i , i ) ; attributeList . add ( new Attribute ( source , key , nameSegment , valueSegment , valueSegment ) ) ; state = BETWEEN_ATTRIBUTES ; break ; } if ( isWhiteSpace ( c ) ) break ; if ( c == '<' ) { source . log ( logType , startTagName , logBegin , "rejected because of '<' character at start of attribuite value" , i ) ; return null ; } else if ( c == '\'' || c == '"' ) { quote = c ; currentBegin ++ ; } else { quote = ' ' ; } state = IN_VALUE ; break ; case AFTER_TAG_NAME : if ( ! isTerminatingCharacter ) { if ( ! isWhiteSpace ( c ) ) { source . log ( logType , startTagName , logBegin , "rejected because name contains invalid character" , i ) ; return null ; } state = BETWEEN_ATTRIBUTES ; } break ; } i ++ ; } return new Attributes ( source , attributesBegin , i - 1 , attributeList ) ; } catch ( IndexOutOfBoundsException ex ) { source . log ( logType , startTagName , logBegin , "rejected because it has no closing '>' character" , - 1 ) ; return null ; } } private static boolean reachedMaxErrorCount ( int errorCount , Source source , String logType , String startTagName , int logBegin , int maxErrorCount ) { if ( errorCount <= maxErrorCount ) return false ; source . log ( logType , startTagName , logBegin , "rejected because it contains too many errors" , - 1 ) ; return true ; } public Attribute get ( String name ) { if ( size ( ) == 0 ) return null ; for ( int i = 0 ; i < size ( ) ; i ++ ) { Attribute attribute = ( Attribute ) attributeList . get ( i ) ; if ( attribute . getKey ( ) . equalsIgnoreCase ( name ) ) return attribute ; } return null ; } public List getList ( ) { return attributeList ; } public int getCount ( ) { return attributeList . size ( ) ; } public int size ( ) { return getCount ( ) ; } public Iterator iterator ( ) { return attributeList . iterator ( ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "Attributes " ) . append ( super . toString ( ) ) . append ( ": " ) ; if ( attributeList == null ) { sb . append ( "EMPTY" ) ; } else { sb . append ( '\n' ) ; for ( Iterator i = attributeList . iterator ( ) ; i . hasNext ( ) ; ) { Attribute attribute = ( Attribute ) i . next ( ) ; sb . append ( "  " ) . append ( attribute . toString ( ) ) ; } } return sb . toString ( ) ; } public static int getDefaultMaxErrorCount ( ) { return defaultMaxErrorCount ; } public static void setDefaultMaxErrorCount ( int value ) { defaultMaxErrorCount = value ; } } 