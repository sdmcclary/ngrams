<<<<<<< HEAD
public class Utilities { public static void launch ( String command , File fileObject ) { CommandLauncher . launch ( formatCommand ( command , fileObject , true ) ) ; } public static String formatCommand ( String command , File fileObject ) { return formatCommand ( command , fileObject , false ) ; } private static String formatCommand ( String command , File fileObject , boolean escapeDoublebackslashes ) { String [ ] paths ; if ( fileObject . getParentFile ( ) == null ) { paths = new String [ ] { fileObject . getAbsolutePath ( ) . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) , "" , fileObject . getAbsolutePath ( ) . replace ( '\\' , '/' ) , "" , fileObject . getAbsolutePath ( ) . replace ( '/' , '\\' ) , "" , fileObject . getName ( ) , "" } ; } else { paths = new String [ ] { fileObject . getAbsolutePath ( ) . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) , fileObject . getParentFile ( ) . getAbsolutePath ( ) . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) , fileObject . getAbsolutePath ( ) . replace ( '\\' , '/' ) , fileObject . getParentFile ( ) . getAbsolutePath ( ) . replace ( '\\' , '/' ) , fileObject . getAbsolutePath ( ) . replace ( '/' , '\\' ) , fileObject . getParentFile ( ) . getAbsolutePath ( ) . replace ( '/' , '\\' ) , fileObject . getName ( ) , fileObject . getParentFile ( ) . getName ( ) } ; } return MessageFormat . format ( Utilities . convertParameters ( command ) , ( escapeDoublebackslashes ? escapeDoublebackslashes ( paths ) : paths ) ) ; } private static Object [ ] escapeDoublebackslashes ( String [ ] in ) { String [ ] out = new String [ in . length ] ; for ( int i = 0 ; i < in . length ; i ++ ) { out [ i ] = in [ i ] . replaceAll ( Pattern . quote ( "\\\\" ) , Matcher . quoteReplacement ( "\\\\\\\\" ) ) ; } return out ; } static String convertParameters ( String command ) { return command . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_PATH ) , "{0}" ) . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_PARENT_PATH ) , "{1}" ) . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_PATH_SLASHES ) , "{2}" ) . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_PARENT_PATH_SLASHES ) , "{3}" ) . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_PATH_BACKSLASHES ) , "{4}" ) . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_PARENT_PATH_BACKSLASHES ) , "{5}" ) . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_NAME ) , "{6}" ) . replaceAll ( Pattern . quote ( PathtoolsPreferences . FILE_PARENT_NAME ) , "{7}" ) ; } public static String [ ] parseParameters ( String s ) { int NULL = 0x0 ; int INPARAM = 0x1 ; int INPARAMPENDING = 0x2 ; int STICK = 0x4 ; int STICKPENDING = 0x8 ; List < String > params = new LinkedList < String > ( ) ; char c ; int state = NULL ; StringBuffer buff = new StringBuffer ( 20 ) ; int slength = s . length ( ) ; for ( int i = 0 ; i < slength ; i ++ ) { c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( state == NULL ) { if ( buff . length ( ) > 0 ) { params . add ( buff . toString ( ) ) ; buff . setLength ( 0 ) ; } } else if ( state == STICK ) { params . add ( buff . toString ( ) ) ; buff . setLength ( 0 ) ; state = NULL ; } else if ( state == STICKPENDING ) { buff . append ( '\\' ) ; params . add ( buff . toString ( ) ) ; buff . setLength ( 0 ) ; state = NULL ; } else if ( state == INPARAMPENDING ) { state = INPARAM ; buff . append ( '\\' ) ; buff . append ( c ) ; } else { buff . append ( c ) ; } continue ; } if ( c == '\\' ) { if ( state == NULL ) { ++ i ; if ( i < slength ) { char cc = s . charAt ( i ) ; if ( ( cc == '"' ) || ( cc == '\\' ) ) { buff . append ( cc ) ; } else if ( Character . isWhitespace ( cc ) ) { buff . append ( c ) ; -- i ; } else { buff . append ( c ) ; buff . append ( cc ) ; } } else { buff . append ( '\\' ) ; break ; } continue ; } else if ( state == INPARAM ) { state = INPARAMPENDING ; } else if ( state == INPARAMPENDING ) { buff . append ( '\\' ) ; state = INPARAM ; } else if ( state == STICK ) { state = STICKPENDING ; } else if ( state == STICKPENDING ) { buff . append ( '\\' ) ; state = STICK ; } continue ; } if ( c == '"' ) { if ( state == NULL ) { state = INPARAM ; } else if ( state == INPARAM ) { state = STICK ; } else if ( state == STICK ) { state = INPARAM ; } else if ( state == STICKPENDING ) { buff . append ( '"' ) ; state = STICK ; } else { buff . append ( '"' ) ; state = INPARAM ; } continue ; } if ( state == INPARAMPENDING ) { buff . append ( '\\' ) ; state = INPARAM ; } else if ( state == STICKPENDING ) { buff . append ( '\\' ) ; state = STICK ; } buff . append ( c ) ; } if ( state == INPARAM ) { params . add ( buff . toString ( ) ) ; } else if ( ( state & ( INPARAMPENDING | STICKPENDING ) ) != 0 ) { buff . append ( '\\' ) ; params . add ( buff . toString ( ) ) ; } else { if ( buff . length ( ) != 0 ) { params . add ( buff . toString ( ) ) ; } } String [ ] ret = params . toArray ( new String [ 0 ] ) ; return ret ; } } 
=======
public class SoapPrimitive { String namespace ; String name ; String value ; public SoapPrimitive ( String namespace , String name , String value ) { this . namespace = namespace ; this . name = name ; this . value = value ; } public boolean equals ( Object o ) { if ( ! ( o instanceof SoapPrimitive ) ) { return false ; } SoapPrimitive p = ( SoapPrimitive ) o ; return name . equals ( p . name ) && ( namespace == null ? p . namespace == null : namespace . equals ( p . namespace ) ) && ( value == null ? ( p . value == null ) : value . equals ( p . value ) ) ; } public int hashCode ( ) { return name . hashCode ( ) ^ ( namespace == null ? 0 : namespace . hashCode ( ) ) ; } public String toString ( ) { return value ; } public String getNamespace ( ) { return namespace ; } public String getName ( ) { return name ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
