<<<<<<< HEAD
public abstract class UnifiedEditor extends BaseTextEditor implements IUnifiedEditor , IPropertyChangeListener , ISelectionChangedListener , IRedrawRangeListener { public static final String ADD_BOOKMARK = "AddBookmark" ; public static final String ADD_TASK = "AddTask" ; public static boolean ctrlDown ; protected UnifiedOutlinePage outlinePage ; protected boolean autoActivateCodeAssist = true ; protected ListenerList fileServiceChangeListeners = new ListenerList ( ) ; private UnifiedColorizer _colorizer ; private IUnifiedEditorContributor _baseContributor ; private FileErrorListener _errorListener ; private WhitespaceCharacterPainter _whitespacePainter ; private EditorFileContext _fileContextWrapper ; private ArrayList < ISaveAsEvent > _saveAsListeners ; private ArrayList < ISaveEvent > _saveListeners ; private CommonNavigator _fileExplorerView ; private IPreferenceStore _prefStore ; private IPartListener _partListener ; private UnifiedProjectionSupport _projectionSupport ; private Listener _keyUpListener ; private VerifyKeyListener _verifyKeyListener ; private UnifiedViewer _viewer ; private IContextAwareness _contextAwareness ; private boolean _isDisposing = false ; private boolean _hasKeyBeenPressed = false ; private LineStyleListener _lineStyleListener ; private TextChangeListener _textChangeListener ; private PairMatcher _pairMatcher ; private Image _caretImage ; private UnifiedCursorLinePainter _painter ; private int _maxColorizingColumns ; private boolean _extendedStylesEnabled ; private SelectionAdapter _selectionListener ; private FocusAdapter _focusListener ; private ITextListener _textListener ; private IPreferenceStore _runtimeStore = new PreferenceStore ( ) ; private UnifiedBracketInserterManager _bracketInserterManager ; private CodeFormatAction _formatAction ; public UnifiedEditor ( ) { super ( ) ; addPluginToPreferenceStore ( UnifiedEditorsPlugin . getDefault ( ) ) ; this . _saveListeners = new ArrayList < ISaveEvent > ( ) ; this . _saveAsListeners = new ArrayList < ISaveAsEvent > ( ) ; } public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { this . _baseContributor = createLocalContributor ( ) ; this . _colorizer = UnifiedColorizer . getInstance ( ) ; setSourceViewerConfiguration ( new UnifiedConfiguration ( this , getPreferenceStore ( ) ) ) ; getFileServiceFactory ( ) ; this . _prefStore = UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) ; this . _prefStore = ( this . _prefStore == null ) ? null : this . _prefStore ; setDocumentProvider ( createDocumentProvider ( ) ) ; this . _fileContextWrapper = new EditorFileContext ( ) ; this . _baseContributor . setFileContext ( this . _fileContextWrapper ) ; syncFoldingPreferenceStore ( ) ; super . init ( site , input ) ; setEditorContextMenuId ( getSite ( ) . getId ( ) + "#UnifiedEditorContext" ) ; setRulerContextMenuId ( getSite ( ) . getId ( ) + "#UnifiedRulerContext" ) ; IPreferenceStore localPreferenceStore = this . getPreferenceStore ( ) ; if ( localPreferenceStore != null ) { autoActivateCodeAssist = localPreferenceStore . getBoolean ( IPreferenceConstants . CODE_ASSIST_AUTO_ACTIVATION ) ; } IUnifiedEditorContributor [ ] contributors = this . _baseContributor . getChildContributors ( ) ; if ( contributors != null && ! autoActivateCodeAssist ) { for ( int i = 0 ; i < contributors . length ; i ++ ) { autoActivateCodeAssist = autoActivateCodeAssist || contributors [ i ] . isAutoActivateContentAssist ( ) ; if ( autoActivateCodeAssist ) { break ; } } } } private void syncFoldingPreferenceStore ( ) { if ( this . _baseContributor != null ) { String language = this . _baseContributor . getLocalContentType ( ) ; LanguageColorizer colorizer = LanguageRegistry . getLanguageColorizer ( language ) ; if ( colorizer != null && colorizer . getFoldingBg ( ) != null ) { this . _runtimeStore . setDefault ( PREFERENCE_COLOR_BACKGROUND_SYSTEM_DEFAULT , true ) ; this . _runtimeStore . setValue ( PREFERENCE_COLOR_BACKGROUND_SYSTEM_DEFAULT , false ) ; PreferenceConverter . setValue ( this . _runtimeStore , PREFERENCE_COLOR_BACKGROUND , colorizer . getFoldingBg ( ) . getRGB ( ) ) ; } } } protected void rulerContextMenuAboutToShow ( IMenuManager menu ) { menu . add ( getAction ( ADD_BOOKMARK ) ) ; menu . add ( getAction ( ADD_TASK ) ) ; menu . add ( new Separator ( "source" ) ) ; menu . add ( _formatAction ) ; _formatAction . setActiveEditor ( null , this ) ; menu . add ( new Separator ( ) ) ; super . rulerContextMenuAboutToShow ( menu ) ; FoldingExtensionPointLoader . fillRulerContextMenu ( this , menu ) ; } protected void editorContextMenuAboutToShow ( IMenuManager menu ) { menu . add ( new Separator ( "debug" ) ) ; super . editorContextMenuAboutToShow ( menu ) ; IUnifiedEditorContributor contributor = getBaseContributor ( ) ; if ( contributor != null ) { String mimeType = contributor . getLocalContentType ( ) ; if ( mimeType != null && LanguageRegistry . getCodeFormatter ( mimeType ) != null ) { menu . add ( new Separator ( "source" ) ) ; menu . add ( _formatAction ) ; _formatAction . setActiveEditor ( null , this ) ; } OpenDeclarationAction openDelcaration = new OpenDeclarationAction ( ) ; openDelcaration . setActiveEditor ( this , this . getFileContext ( ) . getLanguageService ( mimeType ) ) ; menu . add ( openDelcaration ) ; } } protected void addPluginToPreferenceStore ( AbstractUIPlugin plugin ) { setPreferenceStore ( new ChainedPreferenceStore ( new IPreferenceStore [ ] { this . _runtimeStore , getPreferenceStore ( ) , plugin . getPreferenceStore ( ) } ) ) ; } public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ProjectionViewer viewer = ( ProjectionViewer ) getSourceViewer ( ) ; if ( viewer . canDoOperation ( ProjectionViewer . TOGGLE ) ) { viewer . doOperation ( ProjectionViewer . TOGGLE ) ; } this . _maxColorizingColumns = getPreferenceStore ( ) . getInt ( IPreferenceConstants . COLORIZER_MAXCOLUMNS ) ; linkColorer ( ) ; linkPairMatcher ( ) ; this . _extendedStylesEnabled = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . COLORIZER_TEXT_HIGHLIGHT_ENABLED ) ; if ( this . _extendedStylesEnabled ) { installTextOccurrenceHighlightSupport ( ) ; } LexemeUIHelp . setHelp ( this , this . getViewer ( ) . getTextWidget ( ) , getFileContext ( ) ) ; setEditorOptions ( ) ; } private void setEditorOptions ( ) { if ( getBaseContributor ( ) == null || this . getViewer ( ) == null || this . getViewer ( ) . getTextWidget ( ) == null ) { return ; } String language = getBaseContributor ( ) . getLocalContentType ( ) ; LanguageColorizer colorizer = LanguageRegistry . getLanguageColorizer ( language ) ; if ( colorizer != null && colorizer . getLineHighlightColor ( ) != null && colorizer . getCaretColor ( ) != null && colorizer . getBackground ( ) != null && colorizer . getSelectionForeground ( ) != null && colorizer . getSelectionBackground ( ) != null ) { if ( this . getViewer ( ) instanceof ITextViewerExtension2 ) { ITextViewerExtension2 highlightEditor = ( ITextViewerExtension2 ) this . getViewer ( ) ; if ( this . getViewer ( ) . getTextWidget ( ) != null ) { if ( this . _painter != null ) { highlightEditor . removePainter ( this . _painter ) ; } this . _painter = new UnifiedCursorLinePainter ( this , this . getViewer ( ) ) ; this . _painter . setHighlightColor ( colorizer . getLineHighlightColor ( ) ) ; highlightEditor . addPainter ( this . _painter ) ; if ( this . _selectionListener != null ) { this . getViewer ( ) . getTextWidget ( ) . removeSelectionListener ( this . _selectionListener ) ; } if ( this . _focusListener != null ) { this . getViewer ( ) . getTextWidget ( ) . removeFocusListener ( this . _focusListener ) ; } if ( this . _textListener != null ) { this . getViewer ( ) . removeTextListener ( this . _textListener ) ; } this . _selectionListener = new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; if ( _painter != null && text != null && ! text . isDisposed ( ) ) { Point p = text . getSelectionRange ( ) ; if ( p . y == 0 ) { _painter . paintLines ( 0 , text . getLineCount ( ) ) ; text . redraw ( ) ; text . update ( ) ; } } } } ; this . _focusListener = new FocusAdapter ( ) { public void focusGained ( FocusEvent e ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; if ( _painter != null && text != null && ! text . isDisposed ( ) ) { Point p = text . getSelectionRange ( ) ; if ( p . y > 0 ) { _painter . paintLines ( 0 , text . getLineCount ( ) ) ; } } } } ; this . _textListener = new ITextListener ( ) { public void textChanged ( TextEvent event ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; if ( _painter != null && text != null && ! text . isDisposed ( ) ) { Point p = text . getSelectionRange ( ) ; if ( p . y > 0 ) { _painter . paintLines ( 0 , text . getLineCount ( ) ) ; } } } } ; this . getViewer ( ) . addTextListener ( this . _textListener ) ; this . getViewer ( ) . getTextWidget ( ) . addFocusListener ( this . _focusListener ) ; this . getViewer ( ) . getTextWidget ( ) . addSelectionListener ( this . _selectionListener ) ; if ( isWordWrapEnabled ( ) ) { this . getViewer ( ) . getTextWidget ( ) . setWordWrap ( true ) ; this . getViewer ( ) . getTextWidget ( ) . addControlListener ( new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { if ( _projectionSupport != null ) { UnifiedRulerColumn column = _projectionSupport . getRulerColumn ( ) ; if ( column != null ) { column . redraw ( ) ; } } IVerticalRuler ruler = getVerticalRuler ( ) ; if ( ruler instanceof CompositeRuler ) { Iterator columnIter = ( ( CompositeRuler ) ruler ) . getDecoratorIterator ( ) ; while ( columnIter . hasNext ( ) ) { Object column = columnIter . next ( ) ; if ( column instanceof AnnotationRulerColumn ) { ( ( AnnotationRulerColumn ) column ) . redraw ( ) ; } } } if ( fLineNumberRulerColumn != null ) { fLineNumberRulerColumn . redraw ( ) ; } IOverviewRuler overviewRuler = getOverviewRuler ( ) ; if ( overviewRuler != null ) { overviewRuler . update ( ) ; } } } ) ; } } } setFoldingColors ( colorizer ) ; if ( ! Platform . getWS ( ) . equals ( Platform . WS_CARBON ) ) { if ( this . getViewer ( ) . getTextWidget ( ) != null ) { Caret caret = this . getViewer ( ) . getTextWidget ( ) . getCaret ( ) ; RGB converted = new RGB ( 0 , 0 , 0 ) ; converted . red = Math . abs ( colorizer . getCaretColor ( ) . getRed ( ) - colorizer . getLineHighlightColor ( ) . getRed ( ) ) ; converted . blue = Math . abs ( colorizer . getCaretColor ( ) . getBlue ( ) - colorizer . getLineHighlightColor ( ) . getBlue ( ) ) ; converted . green = Math . abs ( colorizer . getCaretColor ( ) . getGreen ( ) - colorizer . getLineHighlightColor ( ) . getGreen ( ) ) ; PaletteData data = new PaletteData ( new RGB [ ] { converted } ) ; int x = caret . getSize ( ) . x ; int y = caret . getSize ( ) . y ; if ( x > 0 && y > 0 ) { try { ImageData iData = new ImageData ( x , y , 1 , data ) ; caret . setImage ( null ) ; if ( this . _caretImage != null ) { this . _caretImage . dispose ( ) ; this . _caretImage = null ; } this . _caretImage = new Image ( caret . getDisplay ( ) , iData ) ; caret . setImage ( this . _caretImage ) ; } catch ( Error e ) { } catch ( Exception e ) { } } } } Color bg = colorizer . getBackground ( ) ; Color deadSpace = createDeadSpaceColor ( bg ) ; if ( deadSpace != null && ! deadSpace . isDisposed ( ) ) { this . getViewer ( ) . getTextWidget ( ) . setBackground ( deadSpace ) ; } else { this . getViewer ( ) . getTextWidget ( ) . setBackground ( bg ) ; } this . getViewer ( ) . getTextWidget ( ) . setSelectionBackground ( colorizer . getSelectionBackground ( ) ) ; this . getViewer ( ) . getTextWidget ( ) . setSelectionForeground ( colorizer . getSelectionForeground ( ) ) ; } else { IPreferenceStore store = EditorsPlugin . getDefault ( ) . getPreferenceStore ( ) ; RGB background = PreferenceConverter . getColor ( store , AbstractTextEditor . PREFERENCE_COLOR_BACKGROUND ) ; RGB selectionFg = PreferenceConverter . getColor ( store , AbstractTextEditor . PREFERENCE_COLOR_SELECTION_FOREGROUND ) ; RGB selectionBg = PreferenceConverter . getColor ( store , AbstractTextEditor . PREFERENCE_COLOR_SELECTION_BACKGROUND ) ; Color eclipseBackgroundColor = UnifiedColorManager . getInstance ( ) . getColor ( background ) ; if ( store . getBoolean ( AbstractTextEditor . PREFERENCE_COLOR_BACKGROUND_SYSTEM_DEFAULT ) ) { eclipseBackgroundColor = null ; } Color eclipseSelectionFgColor = UnifiedColorManager . getInstance ( ) . getColor ( selectionFg ) ; if ( store . getBoolean ( AbstractTextEditor . PREFERENCE_COLOR_SELECTION_FOREGROUND_SYSTEM_DEFAULT ) ) { eclipseSelectionFgColor = null ; } Color eclipseSelectionBgColor = UnifiedColorManager . getInstance ( ) . getColor ( selectionBg ) ; if ( store . getBoolean ( AbstractTextEditor . PREFERENCE_COLOR_SELECTION_BACKGROUND_SYSTEM_DEFAULT ) ) { eclipseSelectionBgColor = null ; } Color deadSpace = createDeadSpaceColor ( eclipseBackgroundColor ) ; if ( deadSpace != null ) { this . getViewer ( ) . getTextWidget ( ) . setBackground ( deadSpace ) ; } else { this . getViewer ( ) . getTextWidget ( ) . setBackground ( eclipseBackgroundColor ) ; } this . getViewer ( ) . getTextWidget ( ) . setSelectionBackground ( eclipseSelectionBgColor ) ; this . getViewer ( ) . getTextWidget ( ) . setSelectionForeground ( eclipseSelectionFgColor ) ; Caret caret = this . getViewer ( ) . getTextWidget ( ) . getCaret ( ) ; caret . setImage ( null ) ; if ( this . _caretImage != null ) { this . _caretImage . dispose ( ) ; this . _caretImage = null ; } if ( this . getViewer ( ) instanceof ITextViewerExtension2 ) { ITextViewerExtension2 highlightEditor = ( ITextViewerExtension2 ) this . getViewer ( ) ; if ( this . _painter != null ) { highlightEditor . removePainter ( this . _painter ) ; } } } } protected void setFoldingColors ( LanguageColorizer colorizer ) { if ( colorizer . getFoldingFg ( ) != null ) { SourceViewerConfiguration config = this . getSourceViewerConfiguration ( ) ; if ( config instanceof UnifiedConfiguration ) { UnifiedReconcilingStrategy strategy = ( ( UnifiedConfiguration ) config ) . getStrategy ( ) ; if ( strategy != null ) { strategy . setFoldingAnnotationHoverColor ( colorizer . getFoldingFg ( ) ) ; } } } if ( colorizer . getFoldingBg ( ) != null ) { if ( this . _projectionSupport != null ) { UnifiedRulerColumn column = this . _projectionSupport . getRulerColumn ( ) ; if ( column != null ) { column . setBackground ( colorizer . getFoldingBg ( ) ) ; } } if ( fLineNumberRulerColumn != null && fLineNumberRulerColumn . getControl ( ) != null && ! fLineNumberRulerColumn . getControl ( ) . isDisposed ( ) ) { if ( fLineNumberRulerColumn instanceof UnifiedLineNumberChangeRulerColumn ) { ( ( UnifiedLineNumberChangeRulerColumn ) fLineNumberRulerColumn ) . setTextWidget ( getViewer ( ) . getTextWidget ( ) ) ; ( ( UnifiedLineNumberChangeRulerColumn ) fLineNumberRulerColumn ) . setSourceViewer ( getViewer ( ) ) ; } fLineNumberRulerColumn . setBackground ( colorizer . getFoldingBg ( ) ) ; fLineNumberRulerColumn . redraw ( ) ; } } } private boolean isWordWrapEnabled ( ) { return UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . ENABLE_WORD_WRAP ) ; } protected IVerticalRulerColumn createLineNumberRulerColumn ( ) { if ( isWordWrapEnabled ( ) ) { if ( isPrefQuickDiffAlwaysOn ( ) ) { UnifiedLineNumberChangeRulerColumn column = new UnifiedLineNumberChangeRulerColumn ( getSharedColors ( ) ) ; if ( getViewer ( ) != null ) { column . setSourceViewer ( getViewer ( ) ) ; column . setTextWidget ( getViewer ( ) . getTextWidget ( ) ) ; } column . setHover ( createChangeHover ( ) ) ; fLineNumberRulerColumn = column ; } else { fLineNumberRulerColumn = new UnifiedLineNumberChangeRulerColumn ( getSharedColors ( ) ) ; if ( getViewer ( ) != null ) { ( ( UnifiedLineNumberChangeRulerColumn ) fLineNumberRulerColumn ) . setSourceViewer ( getViewer ( ) ) ; ( ( UnifiedLineNumberChangeRulerColumn ) fLineNumberRulerColumn ) . setTextWidget ( getViewer ( ) . getTextWidget ( ) ) ; } } initializeLineNumberRulerColumn ( fLineNumberRulerColumn ) ; return fLineNumberRulerColumn ; } else { return super . createLineNumberRulerColumn ( ) ; } } protected IOverviewRuler createOverviewRuler ( ISharedTextColors sharedColors ) { if ( isWordWrapEnabled ( ) ) { IOverviewRuler ruler = new UnifiedOverviewRuler ( getAnnotationAccess ( ) , VERTICAL_RULER_WIDTH , sharedColors ) ; Iterator e = EditorsPlugin . getDefault ( ) . getMarkerAnnotationPreferences ( ) . getAnnotationPreferences ( ) . iterator ( ) ; while ( e . hasNext ( ) ) { AnnotationPreference preference = ( AnnotationPreference ) e . next ( ) ; if ( preference . contributesToHeader ( ) ) ruler . addHeaderAnnotationType ( preference . getAnnotationType ( ) ) ; } return ruler ; } else { return super . createOverviewRuler ( sharedColors ) ; } } private Color createDeadSpaceColor ( Color bg ) { if ( bg != null ) { int factor = 4 ; boolean canGoDarker = bg . getRed ( ) - factor > 0 || bg . getGreen ( ) - factor > 0 || bg . getBlue ( ) - factor > 0 ; boolean canGoLighter = bg . getRed ( ) + factor > 0 || bg . getGreen ( ) + factor > 0 || bg . getBlue ( ) + factor > 0 ; int red = 0 ; int green = 0 ; int blue = 0 ; if ( canGoDarker ) { red = bg . getRed ( ) - factor > 0 ? ( int ) ( bg . getRed ( ) - factor ) : bg . getRed ( ) ; green = bg . getGreen ( ) - factor > 0 ? ( int ) ( bg . getGreen ( ) - factor ) : bg . getGreen ( ) ; blue = bg . getBlue ( ) - factor > 0 ? ( int ) ( bg . getBlue ( ) - factor ) : bg . getBlue ( ) ; } else if ( canGoLighter ) { red = bg . getRed ( ) + factor > 0 ? ( int ) ( bg . getRed ( ) + factor ) : bg . getRed ( ) ; green = bg . getGreen ( ) + factor > 0 ? ( int ) ( bg . getGreen ( ) + factor ) : bg . getGreen ( ) ; blue = bg . getBlue ( ) + factor > 0 ? ( int ) ( bg . getBlue ( ) + factor ) : bg . getBlue ( ) ; } if ( canGoDarker || canGoLighter ) { Color deadSpace = UnifiedColorManager . getInstance ( ) . getColor ( new RGB ( red , green , blue ) ) ; return deadSpace ; } } return null ; } private void installTextOccurrenceHighlightSupport ( ) { ISelectionProvider selectionProvider = getSelectionProvider ( ) ; if ( selectionProvider instanceof IPostSelectionProvider ) { IPostSelectionProvider provider = ( IPostSelectionProvider ) selectionProvider ; provider . addPostSelectionChangedListener ( this ) ; } else { selectionProvider . addSelectionChangedListener ( this ) ; } this . _extendedStylesEnabled = true ; } private void uninstallTextOccurrenceHighlightSupport ( ) { ISelectionProvider selectionProvider = getSelectionProvider ( ) ; if ( selectionProvider != null ) { if ( selectionProvider instanceof IPostSelectionProvider ) { IPostSelectionProvider provider = ( IPostSelectionProvider ) selectionProvider ; provider . removePostSelectionChangedListener ( this ) ; } else { selectionProvider . removeSelectionChangedListener ( this ) ; } } removeMarkedOccurrences ( ) ; this . _extendedStylesEnabled = false ; } private IRange underLine ; private Annotation [ ] fOccurrenceAnnotations ; void removeUnderlinedRange ( IRange range ) { underLine = range ; StyledText textWidget = getViewer ( ) . getTextWidget ( ) ; try { textWidget . redrawRange ( range . getStartingOffset ( ) , range . getLength ( ) , true ) ; } catch ( IllegalArgumentException e ) { } } public void redrawRange ( final IRange range ) { if ( range != null ) { final StyledText textWidget = getViewer ( ) . getTextWidget ( ) ; Display display = textWidget . getDisplay ( ) ; display . asyncExec ( new Runnable ( ) { public void run ( ) { try { textWidget . redrawRange ( range . getStartingOffset ( ) , range . getLength ( ) , true ) ; } catch ( IllegalArgumentException e ) { } } } ) ; } } void setUnderlinedRange ( IRange range ) { if ( range != null ) { underLine = null ; StyledText textWidget = getViewer ( ) . getTextWidget ( ) ; try { textWidget . redrawRange ( range . getStartingOffset ( ) , range . getLength ( ) , true ) ; } catch ( IllegalArgumentException e ) { } } } private void linkColorer ( ) { if ( this . _lineStyleListener == null ) { this . _lineStyleListener = new LineStyleListener ( ) { public void lineGetStyle ( LineStyleEvent e ) { EditorFileContext fileContext = getFileContext ( ) ; if ( fileContext == null || fileContext . getFileContext ( ) == null ) { return ; } IParseState parseState = fileContext . getParseState ( ) ; if ( parseState == null ) { return ; } LexemeList lexemeList = parseState . getLexemeList ( ) ; if ( lexemeList == null ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedEditor_LexemeListIsNull ) ; return ; } int orgOffset = e . lineOffset ; int offset = orgOffset ; int extra = 0 ; int lineLength = e . lineText . length ( ) ; if ( _viewer instanceof ITextViewerExtension5 ) { ITextViewerExtension5 v5 = ( ITextViewerExtension5 ) _viewer ; offset = v5 . widgetOffset2ModelOffset ( e . lineOffset ) ; extra = offset - e . lineOffset ; } int maxLineLength = ! isWordWrapEnabled ( ) && lineLength > _maxColorizingColumns ? _maxColorizingColumns : lineLength ; Lexeme [ ] lexemes = null ; synchronized ( lexemeList ) { int startingIndex = lexemeList . getLexemeCeilingIndex ( offset ) ; int endingIndex = lexemeList . getLexemeFloorIndex ( offset + maxLineLength ) ; if ( startingIndex == - 1 && endingIndex != - 1 ) { startingIndex = endingIndex ; } if ( endingIndex == - 1 && startingIndex != - 1 ) { endingIndex = startingIndex ; } if ( startingIndex != - 1 && endingIndex != - 1 ) { lexemes = lexemeList . cloneRange ( startingIndex , endingIndex ) ; } } if ( lexemes != null ) { Vector < StyleRange > styles = new Vector < StyleRange > ( ) ; _colorizer . createStyles ( parseState , styles , lexemes , _extendedStylesEnabled ) ; StyleRange [ ] styleResults = styles . toArray ( new StyleRange [ ] { } ) ; if ( extra > 0 ) { for ( int i = 0 ; i < styleResults . length ; i ++ ) { StyleRange range = styleResults [ i ] ; range . start -= extra ; } } if ( underLine != null ) { for ( int a = 0 ; a < styleResults . length ; a ++ ) { StyleRange styleRange = styleResults [ a ] ; if ( styleRange . start == underLine . getStartingOffset ( ) && ( styleRange . start + styleRange . length ) == underLine . getEndingOffset ( ) ) { styleRange . underline = true ; } } } else { for ( int a = 0 ; a < styleResults . length ; a ++ ) { StyleRange styleRange = styleResults [ a ] ; styleRange . underline = false ; } } e . styles = styleResults ; } UnifiedViewer rr = ( UnifiedViewer ) getViewer ( ) ; TextPresentation textPresentation = rr . getTextPresentation ( ) ; if ( textPresentation != null ) { TextPresentation ps = new TextPresentation ( ) ; if ( e . styles != null ) { ps . replaceStyleRanges ( e . styles ) ; } Iterator < ? > nonDefaultStyleRangeIterator = textPresentation . getNonDefaultStyleRangeIterator ( ) ; while ( nonDefaultStyleRangeIterator . hasNext ( ) ) { StyleRange clone = ( StyleRange ) ( ( StyleRange ) nonDefaultStyleRangeIterator . next ( ) ) . clone ( ) ; IRegion region = new Region ( clone . start , clone . length ) ; region = rr . modelRange2WidgetRange ( region ) ; if ( region != null ) { clone . start = region . getOffset ( ) ; clone . length = region . getLength ( ) ; ps . mergeStyleRange ( clone ) ; } } Iterator < ? > nonDefaultStyleRangeIterator2 = ps . getNonDefaultStyleRangeIterator ( ) ; ArrayList < StyleRange > rs = new ArrayList < StyleRange > ( ) ; while ( nonDefaultStyleRangeIterator2 . hasNext ( ) ) { StyleRange next = ( StyleRange ) nonDefaultStyleRangeIterator2 . next ( ) ; rs . add ( next ) ; } e . styles = rs . toArray ( new StyleRange [ rs . size ( ) ] ) ; } } } ; } if ( this . _textChangeListener == null ) { this . _textChangeListener = new TextChangeListener ( ) { public void textChanging ( TextChangingEvent event ) { } public void textChanged ( TextChangedEvent event ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; redrawFrom ( text , text . getLineAtOffset ( text . getCaretOffset ( ) ) ) ; } public void textSet ( TextChangedEvent event ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; redrawFrom ( text , 0 ) ; } private void redrawFrom ( StyledText text , int lno ) { if ( lno < 0 || lno >= text . getLineCount ( ) ) { return ; } int height = text . getClientArea ( ) . height ; int width = text . getClientArea ( ) . width + text . getHorizontalPixel ( ) ; try { text . redraw ( 0 , 0 , width , height , true ) ; } catch ( Exception e ) { } } } ; } getViewer ( ) . getTextWidget ( ) . addLineStyleListener ( this . _lineStyleListener ) ; getViewer ( ) . getTextWidget ( ) . getContent ( ) . addTextChangeListener ( this . _textChangeListener ) ; } private void linkPairMatcher ( ) { if ( this . _pairMatcher == null ) { this . _pairMatcher = new PairMatcher ( ) ; StyledText text = getViewer ( ) . getTextWidget ( ) ; text . addPaintListener ( this . _pairMatcher ) ; text . addKeyListener ( this . _pairMatcher ) ; text . addTraverseListener ( this . _pairMatcher ) ; text . addMouseListener ( this . _pairMatcher ) ; text . addSelectionListener ( this . _pairMatcher ) ; ScrollBar sb = text . getVerticalBar ( ) ; if ( sb != null ) { sb . addSelectionListener ( this . _pairMatcher ) ; } } } private void unlinkPairMatcher ( ) { if ( this . _pairMatcher != null ) { if ( getViewer ( ) == null ) { return ; } StyledText text = getViewer ( ) . getTextWidget ( ) ; if ( text == null || text . isDisposed ( ) == true ) { return ; } text . removePaintListener ( this . _pairMatcher ) ; text . removeKeyListener ( this . _pairMatcher ) ; text . removeTraverseListener ( this . _pairMatcher ) ; text . removeMouseListener ( this . _pairMatcher ) ; text . removeSelectionListener ( this . _pairMatcher ) ; ScrollBar sb = text . getVerticalBar ( ) ; if ( sb != null ) { sb . removeSelectionListener ( this . _pairMatcher ) ; } } } public PairMatch getPairMatch ( int offset ) { IParseState parseState = this . getFileContext ( ) . getParseState ( ) ; if ( parseState == null ) { return null ; } LexemeList lexemeList = parseState . getLexemeList ( ) ; Lexeme cursorLexeme = lexemeList . getLexemeFromOffset ( offset ) ; if ( cursorLexeme == null && offset > 0 ) { cursorLexeme = lexemeList . getLexemeFromOffset ( offset - 1 ) ; } if ( cursorLexeme == null ) { return null ; } String language = cursorLexeme . getLanguage ( ) ; IPairFinder finder = LanguageRegistry . getPairFinder ( language ) ; PairMatch match = null ; if ( finder != null && ! finder . doNotDisplay ( ) ) { if ( finder instanceof AbstractPairFinder ) { int loopCount = 2 ; match = ( ( AbstractPairFinder ) finder ) . findPairMatch ( offset , parseState , cursorLexeme , loopCount ) ; } else { match = finder . findPairMatch ( offset , parseState ) ; } } if ( match != null ) { match . setColor ( finder . getPairFinderColor ( ) ) ; match . setDisplayOnlyMatch ( finder . displayOnlyMatch ( ) ) ; match . offset = offset ; if ( match instanceof IPairMatchExt ) { List < PairMatch > subsequentMatches = ( ( IPairMatchExt ) match ) . getSubsequentMatches ( ) ; for ( PairMatch subMatch : subsequentMatches ) { subMatch . setColor ( finder . getPairFinderColor ( ) ) ; subMatch . setDisplayOnlyMatch ( finder . displayOnlyMatch ( ) ) ; subMatch . offset = offset ; } } } return match ; } protected Lexeme findBalancingLexeme ( int startIndex , String language , int startType , int endType , int direction ) { LexemeList lexemeList = this . getFileContext ( ) . getParseState ( ) . getLexemeList ( ) ; return findBalancingLexeme ( lexemeList , startIndex , language , startType , endType , direction ) ; } public static Lexeme findBalancingLexeme ( LexemeList lexemeList , int startIndex , String language , int startType , int endType , int direction ) { Lexeme result = null ; int count = 0 ; while ( 0 <= startIndex && startIndex < lexemeList . size ( ) ) { result = lexemeList . get ( startIndex ) ; if ( result . getLanguage ( ) . equals ( language ) ) { if ( result . typeIndex == endType ) { count -- ; if ( count == 0 ) { break ; } } else if ( result . typeIndex == startType ) { count ++ ; } } startIndex += direction ; } if ( count != 0 ) { result = null ; } return result ; } class PairMatcher implements SelectionListener , MouseListener , KeyListener , PaintListener , TraverseListener { private PairMatch _currentPair ; public void mouseDoubleClick ( MouseEvent e ) { } public void mouseDown ( MouseEvent e ) { stateChanged ( ) ; } public void mouseUp ( MouseEvent e ) { } public void keyPressed ( KeyEvent e ) { stateChanged ( ) ; } public void keyReleased ( KeyEvent e ) { } public void paintControl ( PaintEvent e ) { stateChanged ( ) ; pairsDraw ( e . gc , this . _currentPair ) ; } public void keyTraversed ( TraverseEvent e ) { stateChanged ( ) ; } public void widgetSelected ( SelectionEvent e ) { stateChanged ( ) ; } public void widgetDefaultSelected ( SelectionEvent e ) { } void stateChanged ( ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; if ( text != null ) { int offset = text . getCaretOffset ( ) ; if ( getViewer ( ) instanceof ITextViewerExtension5 ) { int resolved = ( ( ITextViewerExtension5 ) getViewer ( ) ) . widgetOffset2ModelOffset ( offset ) ; if ( resolved > - 1 ) { offset = resolved ; } } PairMatch newmatch = getPairMatch ( offset ) ; if ( ( newmatch == null && this . _currentPair != null ) || ( newmatch != null && ! newmatch . equals ( this . _currentPair ) ) ) { pairsDraw ( null , this . _currentPair ) ; pairsDraw ( null , newmatch ) ; } this . _currentPair = newmatch ; } } void pairsDraw ( GC gc , PairMatch pm ) { if ( pm == null ) { return ; } pairsDrawSingle ( gc , pm ) ; if ( pm instanceof IPairMatchExt ) { List < PairMatch > subsequentMatches = ( ( IPairMatchExt ) pm ) . getSubsequentMatches ( ) ; if ( subsequentMatches != null && subsequentMatches . size ( ) > 0 ) { for ( PairMatch subsequentMatch : subsequentMatches ) { pairsDrawSingle ( gc , subsequentMatch ) ; } } } } void pairsDrawSingle ( GC gc , PairMatch pm ) { if ( pm == null ) { return ; } StyledText text = getViewer ( ) . getTextWidget ( ) ; if ( text != null ) { int cursor = text . getCaretOffset ( ) ; if ( pm . displayOnlyMatch ( ) && gc != null ) { if ( cursor >= pm . beginStart && cursor <= pm . beginEnd ) { pairDraw ( gc , pm . endStart , pm . endEnd , pm . getColor ( ) ) ; } else if ( cursor >= pm . endStart && cursor <= pm . endEnd ) { pairDraw ( gc , pm . beginStart , pm . beginEnd , pm . getColor ( ) ) ; } } else { pairDraw ( gc , pm . beginStart , pm . beginEnd , pm . getColor ( ) ) ; pairDraw ( gc , pm . endStart , pm . endEnd , pm . getColor ( ) ) ; } } } void pairDraw ( GC gc , int start , int end , Color color ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; if ( getViewer ( ) instanceof ITextViewerExtension5 ) { ITextViewerExtension5 v5 = ( ITextViewerExtension5 ) getViewer ( ) ; start = v5 . modelOffset2WidgetOffset ( start ) ; end = v5 . modelOffset2WidgetOffset ( end ) ; } if ( start < 0 || end < 0 || start > text . getCharCount ( ) || end > text . getCharCount ( ) ) { return ; } if ( gc != null ) { try { Point left = text . getLocationAtOffset ( start ) ; Point right = text . getLocationAtOffset ( end ) ; gc . setForeground ( color ) ; gc . setLineWidth ( 1 ) ; gc . drawRectangle ( left . x + 1 , left . y + 1 , right . x - left . x - 2 , gc . getFontMetrics ( ) . getHeight ( ) - 2 ) ; } catch ( Exception e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , StringUtils . format ( Messages . UnifiedEditor_PairDraw , e . getMessage ( ) ) ) ; } } else { text . redrawRange ( start , end - start , true ) ; } } } public abstract String getDefaultFileExtension ( ) ; public void propertyChange ( PropertyChangeEvent e ) { } public boolean isActiveEditor ( ) { IEditorPart part = getEditorSite ( ) . getPage ( ) . getActiveEditor ( ) ; if ( part == null ) { return false ; } else if ( part instanceof IUnifiedEditor ) { IUnifiedEditor editor = ( IUnifiedEditor ) part ; return editor . getEditor ( ) == this ; } else { return part == this ; } } private void onKeyPressed ( VerifyEvent event ) { char c = event . character ; StyledText styledText = ( StyledText ) event . widget ; int keyCode = event . keyCode ; ITypedRegion reg = this . _fileContextWrapper . getPartitionAtOffset ( styledText . getCaretOffset ( ) ) ; if ( reg == null ) { return ; } final String contentType = reg . getType ( ) ; IUnifiedEditorContributor contributor = this . _baseContributor . findChildContributor ( contentType ) ; if ( contributor != null && contributor . isAutoActivateContentAssist ( ) && contributor . isValidIdentifier ( c , keyCode ) && isLeftCharacterWhitespace ( contributor , styledText , c , keyCode ) ) { getViewer ( ) . getTextWidget ( ) . setData ( IContentAssistConstants . ASSIST_FORCE_ACTIVATION , true ) ; showContentAssist ( ) ; } } private boolean isLeftCharacterWhitespace ( IUnifiedEditorContributor contributor , StyledText styledText , char c , int keyCode ) { int offset = styledText . getCaretOffset ( ) ; if ( offset == 0 ) { return true ; } String line = styledText . getText ( offset - 1 , offset - 1 ) ; if ( line . length ( ) > 0 ) { return contributor . isValidActivationCharacter ( line . charAt ( 0 ) , keyCode ) ; } else { return false ; } } private void showContentAssist ( ) { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final Display display = workbench . getDisplay ( ) ; display . asyncExec ( new Runnable ( ) { public void run ( ) { try { final SourceViewer sv = ( SourceViewer ) getSourceViewer ( ) ; if ( sv == null ) { return ; } Control c = display . getFocusControl ( ) ; if ( c == null || c != sv . getTextWidget ( ) ) { return ; } if ( sv . canDoOperation ( SourceViewer . CONTENTASSIST_PROPOSALS ) ) { sv . doOperation ( SourceViewer . CONTENTASSIST_PROPOSALS ) ; } } catch ( Exception e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedEditor_ErrorContentProposals , e ) ; } } } ) ; } public void showWhitespace ( boolean state ) { ISourceViewer fSourceViewer = this . getSourceViewer ( ) ; if ( state ) { if ( this . _whitespacePainter == null ) { if ( fSourceViewer instanceof ITextViewerExtension2 ) { this . _whitespacePainter = new WhitespaceCharacterPainter ( fSourceViewer ) ; ITextViewerExtension2 extension = ( ITextViewerExtension2 ) fSourceViewer ; extension . addPainter ( this . _whitespacePainter ) ; } } } else { if ( this . _whitespacePainter != null ) { if ( fSourceViewer instanceof ITextViewerExtension2 ) { ITextViewerExtension2 extension = ( ITextViewerExtension2 ) fSourceViewer ; extension . removePainter ( this . _whitespacePainter ) ; this . _whitespacePainter . deactivate ( true ) ; this . _whitespacePainter . dispose ( ) ; this . _whitespacePainter = null ; } } } } public void showPianoKeys ( boolean state ) { if ( this . _painter != null ) { StyledText text = getViewer ( ) . getTextWidget ( ) ; this . _painter . paintLines ( 0 , text . getLineCount ( ) ) ; } } public void updateFoldingStructure ( Map annotations ) { List < Annotation > deletions = new ArrayList < Annotation > ( ) ; Collection additions = annotations . values ( ) ; ProjectionAnnotationModel currentModel = getProjectionAnnotationModel ( ) ; if ( currentModel == null ) { return ; } for ( Iterator iter = currentModel . getAnnotationIterator ( ) ; iter . hasNext ( ) ; ) { Object annotation = iter . next ( ) ; if ( annotation instanceof ProjectionAnnotation ) { Position position = currentModel . getPosition ( ( Annotation ) annotation ) ; if ( additions . contains ( position ) ) { additions . remove ( position ) ; } else { deletions . add ( ( Annotation ) annotation ) ; } } } if ( annotations . size ( ) != 0 || deletions . size ( ) != 0 ) { currentModel . modifyAnnotations ( deletions . toArray ( new Annotation [ deletions . size ( ) ] ) , annotations , null ) ; } } protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { this . _viewer = new UnifiedViewer ( parent , ruler , getOverviewRuler ( ) , isOverviewRulerVisible ( ) , styles ) ; getSourceViewerDecorationSupport ( this . _viewer ) ; this . _projectionSupport = new UnifiedProjectionSupport ( this . _viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; this . _projectionSupport . install ( ) ; SourceViewer sv = this . _viewer ; Display d = this . getSite ( ) . getShell ( ) . getDisplay ( ) ; this . _keyUpListener = new Listener ( ) { public void handleEvent ( Event e ) { UnifiedEditor . ctrlDown = false ; } } ; d . addFilter ( SWT . KeyUp , this . _keyUpListener ) ; this . _verifyKeyListener = new VerifyKeyListener ( ) { public void verifyKey ( VerifyEvent event ) { _hasKeyBeenPressed = true ; onKeyPressed ( event ) ; if ( event . keyCode == SWT . CTRL ) { UnifiedEditor . ctrlDown = true ; } else { UnifiedEditor . ctrlDown = false ; } } } ; sv . prependVerifyKeyListener ( this . _verifyKeyListener ) ; SourceViewerConfiguration svc = this . getSourceViewerConfiguration ( ) ; if ( svc instanceof UnifiedConfiguration ) { UnifiedConfiguration uc = ( UnifiedConfiguration ) svc ; this . _bracketInserterManager = uc . getBracketInserterManager ( sv ) ; sv . prependVerifyKeyListener ( this . _bracketInserterManager ) ; } return this . _viewer ; } protected void doSetInput ( IEditorInput input ) throws CoreException { super . doSetInput ( input ) ; try { IDocumentProvider dp = getDocumentProvider ( ) ; if ( dp == null ) { throw new Exception ( Messages . UnifiedEditor_DocumentProviderNull ) ; } IDocument document = dp . getDocument ( input ) ; DocumentSourceProvider provider = new DocumentSourceProvider ( document , input ) ; if ( provider == null ) { throw new Exception ( Messages . UnifiedEditor_ProviderIsNull ) ; } boolean isNewInput = isNewInput ( input ) ; updateFileInfo ( input , provider , document ) ; updatePartitioner ( provider , document , isNewInput ) ; this . _fileContextWrapper . setFileContext ( FileContextManager . get ( provider . getSourceURI ( ) ) ) ; setErrorListeners ( input ) ; fireNewFileServiceEvent ( ) ; if ( this . getViewer ( ) != null && this . getViewer ( ) . getTextWidget ( ) != null ) { this . getViewer ( ) . getTextWidget ( ) . redraw ( ) ; this . getViewer ( ) . getTextWidget ( ) . update ( ) ; } } catch ( Exception e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , "Unable to set input in UnifiedEditor: " + e . getMessage ( ) , e ) ; IStatus status = new Status ( IStatus . ERROR , UnifiedEditorsPlugin . ID , IStatus . OK , "Unable to set input in Unified Editor" , e ) ; throw new CoreException ( status ) ; } } public void addFileServiceChangeListener ( IFileServiceChangeListener listener ) { fileServiceChangeListeners . add ( listener ) ; } public void removeFileServiceChangeListener ( IFileServiceChangeListener listener ) { fileServiceChangeListeners . remove ( listener ) ; } private void fireNewFileServiceEvent ( ) { if ( this . _fileContextWrapper != null && this . _fileContextWrapper . getFileContext ( ) != null ) { final IFileService newService = this . _fileContextWrapper . getFileContext ( ) ; Object [ ] listeners = fileServiceChangeListeners . getListeners ( ) ; for ( int i = 0 ; i < listeners . length ; ++ i ) { final IFileServiceChangeListener l = ( IFileServiceChangeListener ) listeners [ i ] ; SafeRunnable . run ( new SafeRunnable ( ) { public void run ( ) { l . fileServiceChanged ( newService ) ; } } ) ; } } } private void setErrorListeners ( IEditorInput input ) { if ( input instanceof IFileEditorInput ) { IFileEditorInput fileInput = ( IFileEditorInput ) input ; IFile file = fileInput . getFile ( ) ; this . _errorListener = new ProjectFileErrorListener ( file ) ; } else if ( input instanceof IPathEditorInput || input instanceof IURIEditorInput || input instanceof NonExistingFileEditorInput ) { IDocument doc = this . getDocumentProvider ( ) . getDocument ( input ) ; IAnnotationModel ann = this . getDocumentProvider ( ) . getAnnotationModel ( input ) ; this . _errorListener = new ExternalFileErrorListener ( ann , doc ) ; } if ( this . _errorListener != null ) { getFileContext ( ) . addErrorListener ( this . _errorListener ) ; } } protected void updateFileInfo ( IEditorInput input , DocumentSourceProvider provider , IDocument document ) { if ( isNewInput ( input ) ) { IFileServiceFactory fileServiceFactory = this . getFileServiceFactory ( ) ; if ( fileServiceFactory != null ) { FileService context = fileServiceFactory . createFileService ( provider , false ) ; FileContextManager . add ( provider . getSourceURI ( ) , context ) ; context . setRedrawRangeListener ( this ) ; } FileContextManager . connectSourceProvider ( provider . getSourceURI ( ) , provider ) ; } } private void updatePartitioner ( DocumentSourceProvider provider , IDocument document , boolean isNewInput ) { if ( isNewInput ) { UnifiedDocumentPartitioner partitioner = new UnifiedDocumentPartitioner ( provider . getSourceURI ( ) ) ; partitioner . setLegalContentTypes ( this . _baseContributor . getContentTypes ( ) ) ; partitioner . setPartitions ( ) ; if ( document instanceof IDocumentExtension3 ) { ( ( IDocumentExtension3 ) document ) . setDocumentPartitioner ( UnifiedConfiguration . UNIFIED_PARTITIONING , partitioner ) ; } else { throw new IllegalStateException ( Messages . UnifiedEditor_DocumentMustBe ) ; } } } public EditorFileContext getFileContext ( ) { return this . _fileContextWrapper ; } protected abstract IUnifiedEditorContributor createLocalContributor ( ) ; public void dispose ( ) { if ( this . _isDisposing ) { return ; } this . _isDisposing = true ; if ( this . _lineStyleListener != null ) { if ( getViewer ( ) . getTextWidget ( ) != null && getViewer ( ) . getTextWidget ( ) . isDisposed ( ) == false ) { getViewer ( ) . getTextWidget ( ) . removeLineStyleListener ( this . _lineStyleListener ) ; } } if ( this . _textChangeListener != null ) { if ( getViewer ( ) . getTextWidget ( ) != null && getViewer ( ) . getTextWidget ( ) . isDisposed ( ) == false ) { getViewer ( ) . getTextWidget ( ) . getContent ( ) . removeTextChangeListener ( this . _textChangeListener ) ; } } unlinkPairMatcher ( ) ; if ( this . _errorListener != null ) { getFileContext ( ) . removeErrorListener ( this . _errorListener ) ; } if ( this . _partListener != null ) { this . getEditorSite ( ) . getPage ( ) . removePartListener ( this . _partListener ) ; this . _partListener = null ; } if ( this . _keyUpListener != null ) { Display d = this . getSite ( ) . getShell ( ) . getDisplay ( ) ; d . removeFilter ( SWT . KeyUp , this . _keyUpListener ) ; this . _keyUpListener = null ; } if ( _verifyKeyListener != null ) { ( ( SourceViewer ) this . _viewer ) . removeVerifyKeyListener ( this . _verifyKeyListener ) ; this . _verifyKeyListener = null ; } if ( this . _bracketInserterManager != null ) { ( ( SourceViewer ) this . _viewer ) . removeVerifyKeyListener ( this . _bracketInserterManager ) ; this . _bracketInserterManager = null ; } SourceViewerConfiguration svc = this . getConfiguration ( ) ; if ( svc instanceof UnifiedConfiguration ) { ( ( UnifiedConfiguration ) svc ) . dispose ( ) ; } if ( outlinePage != null ) { outlinePage . dispose ( ) ; outlinePage = null ; } showWhitespace ( false ) ; if ( this . _whitespacePainter != null ) { this . _whitespacePainter . dispose ( ) ; } this . _saveListeners . clear ( ) ; this . _saveAsListeners . clear ( ) ; this . _lineStyleListener = null ; outlinePage = null ; if ( this . _baseContributor != null ) { this . _baseContributor . setParentConfiguration ( null ) ; this . _baseContributor = null ; } this . _errorListener = null ; this . _whitespacePainter = null ; this . _fileExplorerView = null ; this . _prefStore = null ; this . _contextAwareness = null ; this . disposeDocumentProvider ( ) ; if ( this . _fileContextWrapper != null ) { this . _fileContextWrapper . deactivateForEditing ( ) ; } if ( this . _extendedStylesEnabled ) { uninstallTextOccurrenceHighlightSupport ( ) ; } if ( this . _caretImage != null ) { this . _caretImage . dispose ( ) ; this . _caretImage = null ; } super . dispose ( ) ; } public abstract IFileServiceFactory getFileServiceFactory ( ) ; public Object getAdapter ( Class adapter ) { if ( adapter == IContextProvider . class ) { return LexemeUIHelp . getHelpContextProvider ( this , getFileContext ( ) ) ; } if ( IContentOutlinePage . class . equals ( adapter ) ) { return getOutlinePage ( ) ; } return super . getAdapter ( adapter ) ; } public ISourceViewer getViewer ( ) { return this . getSourceViewer ( ) ; } public SourceViewerConfiguration getConfiguration ( ) { return this . getSourceViewerConfiguration ( ) ; } public IContextAwareness getContextAwareness ( ) { if ( this . _contextAwareness == null ) { this . _contextAwareness = new IContextAwareness ( ) { public void update ( IFileService fileService ) { } public ContextItem getFileContext ( ) { return new ContextItem ( ) ; } } ; } return this . _contextAwareness ; } public UnifiedOutlinePage getOutlinePage ( ) { if ( this . outlinePage == null || ( this . outlinePage . getControl ( ) != null && this . outlinePage . getControl ( ) . isDisposed ( ) ) ) { this . outlinePage = new UnifiedOutlinePage ( this ) ; } return outlinePage ; } public UnifiedQuickOutlinePage createQuickOutlinePage ( ) { return new UnifiedQuickOutlinePage ( this ) ; } protected void handlePreferenceStoreChanged ( PropertyChangeEvent event ) { try { ISourceViewer sourceViewer = getSourceViewer ( ) ; if ( sourceViewer == null ) { return ; } String property = event . getProperty ( ) ; if ( IPreferenceConstants . COLORIZER_MAXCOLUMNS . equals ( property ) ) { this . _maxColorizingColumns = getPreferenceStore ( ) . getInt ( IPreferenceConstants . COLORIZER_MAXCOLUMNS ) ; } else if ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH . equals ( property ) || IPreferenceConstants . INSERT_SPACES_FOR_TABS . equals ( property ) ) { IPreferenceStore store = getPreferenceStore ( ) ; if ( store == null ) { throw new Exception ( Messages . UnifiedEditor_UnableToRetrievePreferenceStore ) ; } int prefs = store . getInt ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH ) ; SourceViewerConfiguration sv = getSourceViewerConfiguration ( ) ; boolean tabsOrSpaces = store . getBoolean ( IPreferenceConstants . INSERT_SPACES_FOR_TABS ) ; if ( sv != null && sv instanceof UnifiedConfiguration ) { UnifiedConfiguration uc = ( UnifiedConfiguration ) sv ; uc . setTabWidth ( prefs , tabsOrSpaces , sourceViewer ) ; } else { IdeLog . logInfo ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedEditor_ErrorUpdateTabWidth ) ; } } else if ( IPreferenceConstants . COLORIZER_TEXT_HIGHLIGHT_ENABLED . equals ( property ) ) { boolean textHighlightEnabled = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . COLORIZER_TEXT_HIGHLIGHT_ENABLED ) ; if ( textHighlightEnabled ) { installTextOccurrenceHighlightSupport ( ) ; } else { uninstallTextOccurrenceHighlightSupport ( ) ; } } else if ( property != null && property . startsWith ( IPreferenceConstants . EDITOR_FOLDING_ENABLED ) ) { String language = property . substring ( IPreferenceConstants . EDITOR_FOLDING_ENABLED . length ( ) + 1 , property . length ( ) ) ; if ( this . getViewer ( ) != null && this . getViewer ( ) instanceof ProjectionViewer ) { ProjectionViewer viewer = ( ProjectionViewer ) this . getViewer ( ) ; if ( UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( property ) ) { if ( this . getConfiguration ( ) instanceof UnifiedConfiguration ) { UnifiedReconcilingStrategy reconciler = ( ( UnifiedConfiguration ) this . getConfiguration ( ) ) . getStrategy ( ) ; if ( reconciler != null ) { reconciler . initialReconcile ( ) ; } } } else if ( viewer . getProjectionAnnotationModel ( ) != null ) { List < Annotation > mods = new ArrayList < Annotation > ( ) ; Iterator annotationIterator = viewer . getProjectionAnnotationModel ( ) . getAnnotationIterator ( ) ; if ( annotationIterator != null ) { while ( annotationIterator . hasNext ( ) ) { Annotation annotation = ( Annotation ) annotationIterator . next ( ) ; if ( annotation instanceof LanguageProjectAnnotation ) { LanguageProjectAnnotation lpa = ( LanguageProjectAnnotation ) annotation ; if ( language . equals ( lpa . getLanguage ( ) ) ) { lpa . markDeleted ( true ) ; mods . add ( lpa ) ; } } } viewer . getProjectionAnnotationModel ( ) . modifyAnnotations ( mods . toArray ( new Annotation [ mods . size ( ) ] ) , null , null ) ; } } } } else if ( property != null && property . startsWith ( "Colorization" ) ) { syncFoldingPreferenceStore ( ) ; if ( this . getConfiguration ( ) instanceof UnifiedConfiguration ) { UnifiedReconcilingStrategy reconciler = ( ( UnifiedConfiguration ) this . getConfiguration ( ) ) . getStrategy ( ) ; ProjectionAnnotationModel currentModel = getProjectionAnnotationModel ( ) ; if ( reconciler != null && currentModel != null ) { currentModel . removeAllAnnotations ( ) ; reconciler . initialReconcile ( ) ; } } } StyledText viewer = sourceViewer . getTextWidget ( ) ; if ( viewer != null ) { sourceViewer . getTextWidget ( ) . redraw ( ) ; } } catch ( Exception ex ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedEditor_ErrorHandlingPreferenceChange , ex ) ; } finally { super . handlePreferenceStoreChanged ( event ) ; Display display = Display . getCurrent ( ) ; if ( display == null ) display = Display . getDefault ( ) ; display . asyncExec ( new Runnable ( ) { public void run ( ) { setEditorOptions ( ) ; } } ) ; } } private ProjectionAnnotationModel getProjectionAnnotationModel ( ) { ProjectionViewer viewer = ( ProjectionViewer ) getSourceViewer ( ) ; if ( viewer != null ) { return viewer . getProjectionAnnotationModel ( ) ; } return null ; } protected void handleCursorPositionChanged ( ) { StyledText styledText = getSourceViewer ( ) . getTextWidget ( ) ; int offset = styledText . getCaretOffset ( ) ; try { if ( getSourceViewer ( ) instanceof ITextViewerExtension5 ) { offset = ( ( ITextViewerExtension5 ) getSourceViewer ( ) ) . widgetOffset2ModelOffset ( offset ) ; } } catch ( Exception e ) { } catch ( Error e ) { } IFileService fs = this . getFileContext ( ) ; if ( fs != null ) { LexemeList list = fs . getLexemeList ( ) ; if ( list == null ) { return ; } int index = list . getLexemeFloorIndex ( offset ) ; if ( index == - 1 ) { index = list . getLexemeCeilingIndex ( offset ) ; if ( index == - 1 ) { return ; } } Lexeme l = list . get ( index ) ; if ( l != null ) { IFileLanguageService ls = fs . getLanguageService ( l . getLanguage ( ) ) ; if ( ls != null && ls . getOffsetMapper ( ) != null ) { ls . getOffsetMapper ( ) . calculateCurrentLexeme ( offset ) ; } } } super . handleCursorPositionChanged ( ) ; } public IEditorPart getEditor ( ) { return this ; } protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { "com.aptana.ide.editors.UnifiedEditorsScope" } ) ; } protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { super . configureSourceViewerDecorationSupport ( support ) ; } protected void onSaveComplete ( ) { ISaveEvent [ ] listeners = null ; synchronized ( this . _saveListeners ) { listeners = this . _saveListeners . toArray ( new ISaveEvent [ this . _saveListeners . size ( ) ] ) ; } for ( int i = 0 ; i < listeners . length ; i ++ ) { ISaveEvent element = listeners [ i ] ; element . onSave ( this . getEditor ( ) ) ; } } protected void onSaveAsComplete ( File oldFile , File newFile ) { ISaveAsEvent [ ] listeners = null ; synchronized ( this . _saveAsListeners ) { listeners = this . _saveAsListeners . toArray ( new ISaveAsEvent [ this . _saveAsListeners . size ( ) ] ) ; } for ( int i = 0 ; i < listeners . length ; i ++ ) { ISaveAsEvent element = listeners [ i ] ; element . onSaveAs ( this . getEditor ( ) , oldFile , newFile ) ; } updateFileExplorer ( ) ; } private void updateFileExplorer ( ) { if ( this . _fileExplorerView == null ) { this . _fileExplorerView = ( CommonNavigator ) CoreUIUtils . getViewInternal ( "com.aptana.ide.ui.io.fileExplorerView" , null ) ; } if ( this . _fileExplorerView == null ) { return ; } Display . getDefault ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { _fileExplorerView . getCommonViewer ( ) . refresh ( ) ; } } ) ; } public void addSaveListener ( ISaveEvent listener ) { this . _saveListeners . add ( listener ) ; } public void removeSaveListener ( ISaveEvent listener ) { if ( this . _saveListeners . contains ( listener ) ) { this . _saveListeners . remove ( listener ) ; } } public void addSaveAsListener ( ISaveAsEvent listener ) { this . _saveAsListeners . add ( listener ) ; } public void removeSaveAsListener ( ISaveAsEvent listener ) { if ( this . _saveAsListeners . contains ( listener ) ) { this . _saveAsListeners . remove ( listener ) ; } } void showPairError ( ) { MessageDialog . openInformation ( null , Messages . UnifiedEditor_MatchingPairError , Messages . UnifiedEditor_MatchingPairErrorMessage ) ; } public boolean isHasKeyBeenPressed ( ) { return this . _hasKeyBeenPressed ; } public void setHasKeyBeenPressed ( boolean hasKeyBeenPressed ) { this . _hasKeyBeenPressed = hasKeyBeenPressed ; } protected void createActions ( ) { super . createActions ( ) ; final BookmarkRulerAction bra = new BookmarkRulerAction ( ) ; Action bookmarkAction = new Action ( ) { public void run ( ) { bra . run ( this ) ; } } ; bra . setActiveEditor ( bookmarkAction , this ) ; setAction ( ADD_BOOKMARK , bookmarkAction ) ; final TaskRulerAction tra = new TaskRulerAction ( ) ; Action taskAction = new Action ( ) { public void run ( ) { tra . run ( this ) ; } } ; tra . setActiveEditor ( taskAction , this ) ; setAction ( ADD_TASK , taskAction ) ; Action action = new ContentAssistAction ( UnifiedMessages . getResourceBundle ( ) , "ContentAssistProposal." , this ) ; String id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; action . setActionDefinitionId ( id ) ; setAction ( "ContentAssistProposal" , action ) ; markAsStateDependentAction ( "ContentAssistProposal" , true ) ; action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( UnifiedActionContributor . GOTO_MATCHING_BRACKET_ID ) ; setAction ( GotoMatchingBracketAction . GOTO_MATCHING_BRACKET , action ) ; Action actionContext = new TextOperationAction ( UnifiedMessages . getResourceBundle ( ) , "ContentAssistContextInformation." , this , ISourceViewer . CONTENTASSIST_CONTEXT_INFORMATION ) ; actionContext . setActionDefinitionId ( ITextEditorActionDefinitionIds . CONTENT_ASSIST_CONTEXT_INFORMATION ) ; setAction ( "ContentAssistContextInformation" , actionContext ) ; markAsStateDependentAction ( "ContentAssistContextInformation" , true ) ; FoldingExtensionPointLoader . createFoldingActions ( this ) ; _formatAction = new CodeFormatAction ( ) ; } public IUnifiedEditorContributor getBaseContributor ( ) { return this . _baseContributor ; } protected boolean isNewInput ( IEditorInput input ) { return true ; } public void selectionChanged ( SelectionChangedEvent event ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; if ( sourceViewer == null ) { return ; } StyledText styledText = sourceViewer . getTextWidget ( ) ; if ( styledText == null ) { return ; } int offset = - 1 ; Point selectionRange = sourceViewer . getSelectedRange ( ) ; if ( selectionRange . x > - 1 && selectionRange . y > 0 ) { offset = selectionRange . x ; } if ( offset < 0 ) { if ( sourceViewer instanceof ITextViewerExtension5 ) { ITextViewerExtension5 extension = ( ITextViewerExtension5 ) sourceViewer ; offset = extension . widgetOffset2ModelOffset ( styledText . getCaretOffset ( ) ) ; } else { offset = sourceViewer . getVisibleRegion ( ) . getOffset ( ) ; offset += styledText . getCaretOffset ( ) ; } } if ( offset < 0 ) { return ; } LexemeList lexemeList = getLexemeList ( ) ; if ( lexemeList == null ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedEditor_LexemeListIsNull ) ; return ; } Lexeme selectedLexeme = lexemeList . getLexemeFromOffset ( offset ) ; if ( selectedLexeme == null ) { return ; } if ( ! canMarkOccurrences ( selectedLexeme ) ) { return ; } String selectedText = selectedLexeme . getText ( ) ; if ( selectedText == null || selectedText . length ( ) == 0 ) { return ; } markOccurences ( lexemeList , selectedLexeme ) ; Job job = new UIJob ( "Redraw" ) { @ Override public IStatus runInUIThread ( IProgressMonitor monitor ) { getSourceViewer ( ) . getTextWidget ( ) . redraw ( ) ; return Status . OK_STATUS ; } } ; job . setPriority ( Job . INTERACTIVE ) ; job . setSystem ( true ) ; job . schedule ( ) ; } protected void markOccurences ( LexemeList lexemeList , Lexeme selectedLexeme ) { String selectedText = selectedLexeme . getText ( ) ; IAnnotationModel model = getDocumentProvider ( ) . getAnnotationModel ( getEditorInput ( ) ) ; Map < Annotation , Position > toAdd = new HashMap < Annotation , Position > ( ) ; for ( int i = 0 ; i < lexemeList . size ( ) ; i ++ ) { Lexeme lexeme = lexemeList . get ( i ) ; if ( lexeme != null ) { if ( lexeme . isHighlighted ( ) ) { lexeme . setHighlighted ( false ) ; } if ( lexeme . length == selectedLexeme . length && selectedText . equals ( lexeme . getText ( ) ) ) { lexeme . setHighlighted ( true ) ; if ( model != null ) { Position pos = new Position ( lexeme . offset , lexeme . length ) ; Annotation occurence = new Annotation ( "com.aptana.ide.annotation.occurence" , false , lexeme . getText ( ) ) ; toAdd . put ( occurence , pos ) ; } } } } synchronized ( getLockObject ( model ) ) { if ( model instanceof IAnnotationModelExtension ) { ( ( IAnnotationModelExtension ) model ) . replaceAnnotations ( fOccurrenceAnnotations , toAdd ) ; } else { removeOccurrenceAnnotations ( ) ; Iterator iter = toAdd . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry mapEntry = ( Map . Entry ) iter . next ( ) ; model . addAnnotation ( ( Annotation ) mapEntry . getKey ( ) , ( Position ) mapEntry . getValue ( ) ) ; } } fOccurrenceAnnotations = ( Annotation [ ] ) toAdd . keySet ( ) . toArray ( new Annotation [ toAdd . keySet ( ) . size ( ) ] ) ; } } protected LexemeList getLexemeList ( ) { EditorFileContext fileContext = getFileContext ( ) ; if ( fileContext == null || fileContext . getFileContext ( ) == null ) { return null ; } IParseState parseState = fileContext . getParseState ( ) ; if ( parseState == null ) { return null ; } LexemeList lexemeList = parseState . getLexemeList ( ) ; return lexemeList ; } public String getLanguageAtOffset ( int offset ) { LexemeList lexemeList = getLexemeList ( ) ; if ( lexemeList == null ) { return null ; } Lexeme lexemeAtOffset = lexemeList . getCeilingLexeme ( offset ) ; if ( lexemeAtOffset == null ) { return null ; } return lexemeAtOffset . getLanguage ( ) ; } private void removeOccurrenceAnnotations ( ) { IDocumentProvider documentProvider = getDocumentProvider ( ) ; if ( documentProvider == null ) return ; IAnnotationModel annotationModel = documentProvider . getAnnotationModel ( getEditorInput ( ) ) ; if ( annotationModel == null || fOccurrenceAnnotations == null ) return ; synchronized ( getLockObject ( annotationModel ) ) { if ( annotationModel instanceof IAnnotationModelExtension ) { ( ( IAnnotationModelExtension ) annotationModel ) . replaceAnnotations ( fOccurrenceAnnotations , null ) ; } else { for ( int i = 0 , length = fOccurrenceAnnotations . length ; i < length ; i ++ ) annotationModel . removeAnnotation ( fOccurrenceAnnotations [ i ] ) ; } fOccurrenceAnnotations = null ; } } private Object getLockObject ( IAnnotationModel annotationModel ) { if ( annotationModel instanceof ISynchronizable ) { Object lock = ( ( ISynchronizable ) annotationModel ) . getLockObject ( ) ; if ( lock != null ) return lock ; } return annotationModel ; } public void removeMarkedOccurrences ( ) { removeOccurrenceAnnotations ( ) ; LexemeList lexemeList = getLexemeList ( ) ; if ( lexemeList == null ) { return ; } for ( int i = 0 ; i < lexemeList . size ( ) ; i ++ ) { Lexeme lexeme = lexemeList . get ( i ) ; if ( lexeme != null && lexeme . isHighlighted ( ) ) { lexeme . setHighlighted ( false ) ; } } } public boolean canMarkOccurrences ( Lexeme lexeme ) { if ( lexeme . getCategoryIndex ( ) == TokenCategories . WHITESPACE ) { return false ; } if ( lexeme . getCategoryIndex ( ) == TokenCategories . PUNCTUATOR ) { return false ; } return true ; } public abstract IDocumentProvider createDocumentProvider ( ) ; public boolean autoActivateCodeAssist ( ) { return autoActivateCodeAssist ; } public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document == null ) return ; Point selectedPoint = sourceViewer . getSelectedRange ( ) ; IRegion selection = new Region ( selectedPoint . x , selectedPoint . y ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( com . aptana . ide . editors . unified . actions . Messages . GotoMatchingBracket_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } int sourceCaretOffset = selection . getOffset ( ) + selection . getLength ( ) ; PairMatch pair = getPairMatch ( sourceCaretOffset ) ; if ( pair == null ) { setStatusLineErrorMessage ( com . aptana . ide . editors . unified . actions . Messages . GotoMatchingBracket_error_noMatchingBracket ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } int start = 0 ; int end = 0 ; if ( sourceCaretOffset <= pair . beginEnd && sourceCaretOffset >= pair . beginStart ) { start = pair . endStart ; end = pair . endEnd ; } else { start = pair . beginStart ; end = pair . beginEnd ; } int length = end - start ; sourceViewer . setSelectedRange ( start , length ) ; sourceViewer . revealRange ( start , length ) ; } } 
=======
public class TimeDatetime extends AbstractDatetime { public static final TimeDatetime THE_INSTANCE = new TimeDatetime ( ) ; public int i ; private static final Pattern THE_PATTERN = Pattern . compile ( "^[ \\t\\r\\n\\f]*(?:(?:([0-9]{4,})-([0-9]{2}))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2}))|(?:([0-9]{2})-([0-9]{2}))|(?:([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\.([0-9]+))?)?)|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\.([0-9]+))?)?)|(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2})))|(?:([0-9]{4,})-([0-9]{2})-([0-9]{2})(?:T| )([0-9]{2}):([0-9]{2})(?::([0-9]{2})(?:\\.([0-9]+))?)?(?:Z|(?:[+-]([0-9]{2}):?([0-9]{2}))))|(?:([0-9]{4,})-W([0-9]{2}))|(?:([0-9]{4,}))|(?:P(?:(?:[0-9]+D)|(?:(?:[0-9]+D)?T[0-9]+H)|(?:(?:[0-9]+D)?T(?:[0-9]+H)?[0-9]+M)|(?:(?:[0-9]+D)?T(?:(?:[0-9]+)H)?(?:(?:[0-9]+)M)?(?:[0-9]+(?:\\.([0-9]+))?S))))|(?:[ \\t\\r\\n\\f]*[0-9]+(?:(?:[ \\t\\r\\n\\f]*(?:[Ww]|[Dd]|[Hh]|[Mm]))|(?:(?:\\.([0-9]+))?[ \\t\\r\\n\\f]*[Ss])))+)[ \\t\\r\\n\\f]*$" ) ; private TimeDatetime ( ) { super ( ) ; } @ Override protected Pattern getPattern ( ) { return THE_PATTERN ; } @ Override public String getName ( ) { return "time-datetime" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
