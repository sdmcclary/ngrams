public abstract class DataFeed extends AbstractFeed { private static final Logger LOG = Logger . getLogger ( DataFeed . class . getName ( ) ) ; public static final String PROP_PURGE_LIMIT = "purgeLimit" ; public static final String PROP_LAST_POLL_TIME = "lastPollTime" ; public static final String PROP_LAST_UPDATE_SERVER_TIME = "lastUpdateServerTime" ; public static final String PROP_RETRIEVALS = "retrievals" ; public static final String PROP_TOTAL_POLLED_ARTICLES = "totalPolledArticles" ; public static final String PROP_INITIALIZED = "initialized" ; public static final String PROP_FORMAT = "format" ; public static final String PROP_LANGUAGE = "language" ; public static final String PROP_MARK_READ_WHEN_NO_KEYWORDS = "markReadWhenNoKeywords" ; public static final String PROP_UPDATE_PERIOD = "updatePeriod" ; public static final String PROP_LAST_FETCH_ARTICLE_KEYS = "lastFetchArticleKeys" ; static final int DEFAULT_LAST_UPDATE_SERVER_TIME = - 1 ; static final int INIT_TIME_UNINITIALIZED = - 1 ; static final int DEFAULT_LAST_POLL_TIME = 0 ; static final int DEFAULT_TOTAL_POLLED_ARTICLES = 0 ; static final int DEFAULT_RETRIEVALS = 0 ; static final boolean DEFAULT_MARK_READ_WHEN_NO_KEYWORDS = false ; public static final int DEFAULT_PURGE_LIMIT = 30 ; static final int PURGE_LIMIT_INHERITED = - 1 ; static final int UPDATE_PERIOD_INHERITED = - 1 ; private static boolean globalPurgeUnread = true ; private static int globalPurgeLimit = 30 ; private static long globalUpdatePeriod = Constants . MILLIS_IN_HOUR ; private long initTime ; private final List < IArticle > articles ; protected List readArticlesKeys ; protected List pinnedArticlesKeys ; private int purgeLimit ; private long lastPollTime ; private long lastUpdateServerTime ; private int totalPolledArticles ; private int retrievals ; private String format ; private String language ; private long updatePeriod ; private int unreadArticlesCount ; private final ReadWriteLock unreadArticlesCountLock ; private ArticlesListener articlesListener ; private String [ ] lastFetchArticleKeys ; protected DataFeed ( ) { articles = new ArrayList < IArticle > ( ) ; unreadArticlesCount = 0 ; unreadArticlesCountLock = new ReaderPreferenceReadWriteLock ( ) ; readArticlesKeys = new ArrayList ( ) ; pinnedArticlesKeys = new ArrayList ( ) ; articlesListener = new ArticlesListener ( ) ; purgeLimit = PURGE_LIMIT_INHERITED ; updatePeriod = UPDATE_PERIOD_INHERITED ; resetFeedStatistics ( ) ; format = null ; language = null ; } protected void resetFeedStatistics ( ) { initTime = INIT_TIME_UNINITIALIZED ; lastPollTime = DEFAULT_LAST_POLL_TIME ; lastUpdateServerTime = DEFAULT_LAST_UPDATE_SERVER_TIME ; totalPolledArticles = DEFAULT_TOTAL_POLLED_ARTICLES ; retrievals = DEFAULT_RETRIEVALS ; } public synchronized IArticle getArticleAt ( int index ) { return articles . get ( index ) ; } public synchronized int getArticlesCount ( ) { return articles . size ( ) ; } public int getOwnArticlesCount ( ) { return getArticlesCount ( ) ; } public synchronized IArticle [ ] getArticles ( ) { return articles . toArray ( new IArticle [ articles . size ( ) ] ) ; } protected List < IArticle > getArticlesList ( ) { return articles ; } public synchronized boolean appendArticle ( IArticle article ) { if ( article == null ) throw new NullPointerException ( Strings . error ( "unspecified.article" ) ) ; article . setCandidateFeed ( this ) ; boolean result = insertArticle ( getArticlesCount ( ) , article ) ; article . setCandidateFeed ( null ) ; return result ; } public synchronized boolean insertArticle ( int index , IArticle article ) { if ( article == null ) throw new NullPointerException ( Strings . error ( "unspecified.article" ) ) ; if ( article . getFeed ( ) != null ) throw new IllegalStateException ( Strings . error ( "article.belongs.to.the.feed.already" ) ) ; int count = getArticlesCount ( ) ; if ( index < 0 || index > count ) throw new IndexOutOfBoundsException ( Strings . error ( "index.is.out.of.bounds.of.article.list" ) ) ; boolean added = false ; if ( article . getID ( ) > 0 || ! articles . contains ( article ) ) { articles . add ( index , article ) ; article . setFeed ( this ) ; added = true ; if ( isArticleOnReadList ( article ) ) article . setRead ( true ) ; if ( isArticleOnPinnedList ( article ) ) article . setPinned ( true ) ; article . addListener ( articlesListener ) ; if ( ! article . isRead ( ) ) setUnreadArticlesCount ( unreadArticlesCount + 1 ) ; article . setNew ( true ) ; try { fireArticleAdded ( article ) ; } finally { article . setNew ( false ) ; } } return added ; } public synchronized boolean removeArticle ( IArticle article ) { if ( article == null ) throw new NullPointerException ( Strings . error ( "unspecified.article" ) ) ; boolean removed ; removed = articles . remove ( article ) ; if ( removed ) { article . removeListener ( articlesListener ) ; if ( ! article . isRead ( ) ) setUnreadArticlesCount ( unreadArticlesCount - 1 ) ; fireArticleRemoved ( article ) ; } return removed ; } public int getUnreadArticlesCount ( ) { int count = 0 ; try { unreadArticlesCountLock . readLock ( ) . acquire ( ) ; count = unreadArticlesCount ; unreadArticlesCountLock . readLock ( ) . release ( ) ; } catch ( InterruptedException e ) { LOG . log ( Level . SEVERE , Strings . error ( "interrupted" ) , e ) ; } return count ; } private int getPinnedArticlesCount ( ) { int count = 0 ; for ( IArticle article : articles ) if ( article . isPinned ( ) ) count ++ ; return count ; } private void setUnreadArticlesCount ( int count ) throws IllegalArgumentException { if ( count < 0 || count > getArticlesCount ( ) ) throw new IllegalArgumentException ( MessageFormat . format ( Strings . error ( "unread.articles.count.ran.out.of.allowed.range" ) , count , getArticlesCount ( ) ) ) ; try { unreadArticlesCountLock . writeLock ( ) . acquire ( ) ; int oldValue = unreadArticlesCount ; unreadArticlesCount = count ; unreadArticlesCountLock . writeLock ( ) . release ( ) ; firePropertyChanged ( PROP_UNREAD_ARTICLES_COUNT , oldValue , count , false , true ) ; } catch ( InterruptedException e ) { LOG . log ( Level . SEVERE , Strings . error ( "interrupted" ) , e ) ; } } public synchronized String getReadArticlesKeys ( ) { String keys ; if ( ! isInitialized ( ) ) { if ( readArticlesKeys != null ) { keys = StringUtils . join ( readArticlesKeys . iterator ( ) , "," ) ; } else { keys = Constants . EMPTY_STRING ; } } else { List < String > keysList = new ArrayList < String > ( getUnreadArticlesCount ( ) ) ; for ( int i = 0 ; i < getArticlesCount ( ) ; i ++ ) { final IArticle a = getArticleAt ( i ) ; if ( a . isRead ( ) ) keysList . add ( a . getSimpleMatchKey ( ) ) ; } keys = StringUtils . join ( keysList . iterator ( ) , "," ) ; } return keys ; } public synchronized String getPinnedArticlesKeys ( ) { String keys ; if ( ! isInitialized ( ) ) { if ( pinnedArticlesKeys != null ) { keys = StringUtils . join ( pinnedArticlesKeys . iterator ( ) , "," ) ; } else { keys = Constants . EMPTY_STRING ; } } else { List < String > keysList = new ArrayList < String > ( ) ; for ( int i = 0 ; i < getArticlesCount ( ) ; i ++ ) { final IArticle a = getArticleAt ( i ) ; if ( a . isPinned ( ) ) keysList . add ( a . getSimpleMatchKey ( ) ) ; } keys = StringUtils . join ( keysList . iterator ( ) , "," ) ; } return keys ; } public synchronized void setReadArticlesKeys ( String keys ) { readArticlesKeys . clear ( ) ; if ( keys != null ) { readArticlesKeys = parseKeysToList ( keys ) ; for ( int i = 0 ; i < getArticlesCount ( ) ; i ++ ) { IArticle article = getArticleAt ( i ) ; if ( isArticleOnReadList ( article ) ) article . setRead ( true ) ; } } } public synchronized void setPinnedArticlesKeys ( String keys ) { pinnedArticlesKeys . clear ( ) ; if ( keys != null ) { pinnedArticlesKeys = parseKeysToList ( keys ) ; for ( int i = 0 ; i < getArticlesCount ( ) ; i ++ ) { IArticle article = getArticleAt ( i ) ; if ( isArticleOnPinnedList ( article ) ) article . setPinned ( true ) ; } } } private static ArrayList < String > parseKeysToList ( String keys ) { StringTokenizer st = new StringTokenizer ( keys , "," ) ; ArrayList < String > list = new ArrayList < String > ( st . countTokens ( ) ) ; while ( st . hasMoreTokens ( ) ) { String key = st . nextToken ( ) ; if ( key . length ( ) == 16 ) { long positive = 0x100000000L - Long . parseLong ( key . substring ( 8 ) , 16 ) ; key = Long . toHexString ( positive ) ; } list . add ( key ) ; } return list ; } private boolean isArticleOnPinnedList ( IArticle article ) { return pinnedArticlesKeys . size ( ) > 0 && pinnedArticlesKeys . contains ( article . getSimpleMatchKey ( ) ) ; } private boolean isArticleOnReadList ( IArticle article ) { return readArticlesKeys . size ( ) > 0 && readArticlesKeys . contains ( article . getSimpleMatchKey ( ) ) ; } public String getFormat ( ) { return format ; } public void setFormat ( String aFormat ) { String oldFormat = format ; format = aFormat ; firePropertyChanged ( PROP_FORMAT , oldFormat , format ) ; } public String getLanguage ( ) { return language ; } public void setLanguage ( String aLanguage ) { String oldLanguage = language ; language = aLanguage ; firePropertyChanged ( PROP_LANGUAGE , oldLanguage , language ) ; } public boolean isAutoFeedsDiscovery ( ) { return isAutoFeedsDiscoveryInParentGuides ( ) ; } private boolean isAutoFeedsDiscoveryInParentGuides ( ) { boolean guideAutoFeedsDiscovery = false ; IGuide [ ] parentGuides = getParentGuides ( ) ; for ( int i = 0 ; ! guideAutoFeedsDiscovery && i < parentGuides . length ; i ++ ) { guideAutoFeedsDiscovery = parentGuides [ i ] . isAutoFeedsDiscovery ( ) ; } return guideAutoFeedsDiscovery ; } public int getPurgeLimit ( ) { return purgeLimit ; } public int getPurgeLimitCombined ( ) { return purgeLimit == PURGE_LIMIT_INHERITED ? getGlobalPurgeLimit ( ) : purgeLimit ; } public static int getGlobalPurgeLimit ( ) { return globalPurgeLimit ; } public static void setGlobalPurgeLimit ( int limit ) { globalPurgeLimit = limit ; } public void setPurgeLimit ( int aPurgeLimit ) { int oldLimit = getPurgeLimitCombined ( ) ; purgeLimit = aPurgeLimit ; int newLimit = getPurgeLimitCombined ( ) ; firePropertyChanged ( PROP_PURGE_LIMIT , oldLimit , newLimit , true , false ) ; if ( oldLimit > newLimit ) clean ( ) ; } protected boolean isOnlyManual ( ) { return getUpdatePeriod ( ) == 0 ; } public final boolean isUpdatable ( boolean manual , boolean allowInvisible ) { return getID ( ) != - 1 && ! isProcessing ( ) && ( allowInvisible || canBenefitFromUpdate ( ) ) && isUpdatable ( manual ) ; } private boolean canBenefitFromUpdate ( ) { int m = getClassesMask ( ) & FeedClass . MASK_UNUPDATABLE ; return FeedDisplayModeManager . getInstance ( ) . isVisible ( m ) ; } protected boolean isUpdatable ( boolean manual ) { return manual || ( ! isInvalid ( ) && ! isOnlyManual ( ) && ( getLastPollTime ( ) + getUpdatePeriodCombined ( ) ) < System . currentTimeMillis ( ) ) ; } public void update ( ) { long updateTime = System . currentTimeMillis ( ) ; Channel channel = null ; try { channel = fetchFeed ( ) ; } catch ( Exception e ) { setInvalidnessReason ( Strings . message ( "feed.invalidness.reason.bad.data" ) ) ; LOG . log ( Level . SEVERE , MessageFormat . format ( Strings . error ( "feed.fetching.errored.internal.error" ) , toString ( ) ) , e ) ; } StandardArticle [ ] articles = null ; if ( channel != null ) { articles = new StandardArticle [ channel . getItemsCount ( ) ] ; for ( int i = 0 ; i < articles . length ; i ++ ) articles [ i ] = createArticle ( channel . getItemAt ( i ) ) ; } synchronized ( this ) { if ( channel != null ) { updateFeed ( channel ) ; updateArticles ( articles ) ; clean ( ) ; } setLastPollTime ( updateTime ) ; setInitTime ( updateTime ) ; setRetrievals ( getRetrievals ( ) + 1 ) ; } if ( articles != null ) { for ( StandardArticle article : articles ) article . setCandidateFeed ( null ) ; } } public synchronized void clean ( final int limit , boolean overridePurgeUnread ) { boolean purgeUnread = overridePurgeUnread || isPurgeUnread ( ) ; int total = getArticlesCount ( ) ; int unread = getUnreadArticlesCount ( ) ; int pinned = getPinnedArticlesCount ( ) ; int toRemove = calcArticlesToRemove ( total , unread , pinned , limit , purgeUnread ) ; if ( toRemove > 0 ) { processingStarted ( ) ; List < IArticle > canBeDeleted = new ArrayList < IArticle > ( ) ; for ( int i = 0 ; i < total ; i ++ ) { IArticle article = getArticleAt ( i ) ; if ( ( purgeUnread || article . isRead ( ) ) && ! article . isPinned ( ) ) canBeDeleted . add ( article ) ; } if ( canBeDeleted . size ( ) > 0 ) { Collections . sort ( canBeDeleted , new ArticleDateComparator ( ) ) ; toRemove = Math . min ( toRemove , canBeDeleted . size ( ) ) ; for ( int i = 0 ; i < toRemove ; i ++ ) { IArticle article = canBeDeleted . get ( i ) ; removeArticle ( article ) ; } } processingFinished ( ) ; } } public synchronized void clean ( ) { clean ( getPurgeLimitCombined ( ) , false ) ; } static int calcArticlesToRemove ( int total , int unread , int pinned , int limit , boolean purgeUnread ) { total = total - pinned ; int dynamic = purgeUnread ? total : total - unread ; int leave = Math . max ( limit , total - dynamic ) ; return Math . max ( 0 , total - leave ) ; } public boolean isPurgeUnread ( ) { return isGlobalPurgeUnread ( ) ; } public static boolean isGlobalPurgeUnread ( ) { return globalPurgeUnread ; } public static void setGlobalPurgeUnread ( boolean value ) { globalPurgeUnread = value ; } protected abstract Channel fetchFeed ( ) throws IOException ; protected void updateFeed ( Channel channel ) { String channelFormat = channel . getFormat ( ) ; if ( channelFormat != null ) setFormat ( channelFormat ) ; String channelLanguage = channel . getLanguage ( ) ; if ( channelLanguage != null ) setLanguage ( channelLanguage ) ; long newUpdatePeriod = channel . getUpdatePeriod ( ) ; if ( getUpdatePeriod ( ) == - 1 && newUpdatePeriod != - 1 ) setUpdatePeriod ( newUpdatePeriod ) ; setLastUpdateServerTime ( channel . getLastUpdateServerTime ( ) ) ; } protected void updateArticles ( StandardArticle [ ] incomingArticles ) { boolean canAddMore = true ; int added = 0 ; int purgeLimit = getPurgeLimitCombined ( ) ; List < String > keys = new ArrayList < String > ( incomingArticles . length ) ; try { for ( StandardArticle article : incomingArticles ) { String matchKey = article . getSimpleMatchKey ( ) ; keys . add ( matchKey ) ; if ( canAddMore && ! isArticleSeen ( matchKey ) && ! isDuplicate ( article ) && insertArticle ( 0 , article ) ) { added ++ ; if ( added == purgeLimit ) canAddMore = false ; } } } finally { setTotalPolledArticles ( getTotalPolledArticles ( ) + added ) ; setLastFetchArticleKeys ( keys . toArray ( new String [ keys . size ( ) ] ) ) ; } } protected boolean isDuplicate ( IArticle article ) { return false ; } private boolean isArticleSeen ( String aKey ) { if ( lastFetchArticleKeys == null || aKey == null ) return false ; boolean res = false ; for ( int i = 0 ; ! res && i < lastFetchArticleKeys . length ; i ++ ) { res = aKey . equals ( lastFetchArticleKeys [ i ] ) ; } return res ; } public void setLastFetchArticleKeys ( String [ ] aKeys ) { String [ ] old = lastFetchArticleKeys ; lastFetchArticleKeys = aKeys ; if ( ! Arrays . equals ( old , lastFetchArticleKeys ) ) { firePropertyChanged ( PROP_LAST_FETCH_ARTICLE_KEYS , old , lastFetchArticleKeys ) ; } } public String [ ] getLastFetchArticleKeys ( ) { return lastFetchArticleKeys ; } private StandardArticle createArticle ( Item item ) { String text = TextProcessor . filterText ( item . getText ( ) ) ; String title = TextProcessor . filterTitle ( item . getTitle ( ) , text ) ; StandardArticle article = new LazyArticle ( text ) ; article . setRead ( false ) ; article . setTitle ( title ) ; article . setAuthor ( item . getAuthor ( ) ) ; article . setLink ( item . getLink ( ) ) ; article . setPublicationDate ( item . getPublicationDate ( ) ) ; article . setSubject ( StringUtils . unescape ( item . getSubject ( ) ) ) ; article . getPlainText ( ) ; article . setCandidateFeed ( this ) ; article . computeSimpleMatchKey ( ) ; return article ; } public boolean isInitialized ( ) { return initTime != INIT_TIME_UNINITIALIZED ; } public long getInitTime ( ) { return initTime ; } public void setInitTime ( long aInitTime ) { if ( initTime == INIT_TIME_UNINITIALIZED && aInitTime != INIT_TIME_UNINITIALIZED ) { initTime = aInitTime ; firePropertyChanged ( PROP_INITIALIZED , false , true , false , true ) ; } } public long getLastPollTime ( ) { return lastPollTime ; } public void setLastPollTime ( long time ) { long old = lastPollTime ; lastPollTime = time ; firePropertyChanged ( PROP_LAST_POLL_TIME , old , time ) ; } public long getLastUpdateServerTime ( ) { return lastUpdateServerTime ; } public void setLastUpdateServerTime ( long time ) { long old = lastUpdateServerTime ; lastUpdateServerTime = time ; firePropertyChanged ( PROP_LAST_UPDATE_SERVER_TIME , old , time ) ; } public long getUpdatePeriodCombined ( ) { return updatePeriod < 0 ? getGlobalUpdatePeriod ( ) : updatePeriod ; } public long getUpdatePeriod ( ) { return updatePeriod ; } public void setUpdatePeriod ( long period ) { long oldPeriod = getUpdatePeriod ( ) ; updatePeriod = period ; long newPeriod = getUpdatePeriod ( ) ; firePropertyChanged ( PROP_UPDATE_PERIOD , oldPeriod , newPeriod , true , false ) ; } public static long getGlobalUpdatePeriod ( ) { return globalUpdatePeriod ; } public static void setGlobalUpdatePeriod ( long period ) { globalUpdatePeriod = period ; } public int getRetrievals ( ) { return retrievals ; } public void setRetrievals ( int aRetrievals ) { int old = retrievals ; retrievals = aRetrievals ; firePropertyChanged ( PROP_RETRIEVALS , new Integer ( old ) , new Integer ( retrievals ) ) ; } public int getTotalPolledArticles ( ) { return totalPolledArticles ; } public void setTotalPolledArticles ( int value ) { int old = totalPolledArticles ; totalPolledArticles = value ; firePropertyChanged ( PROP_TOTAL_POLLED_ARTICLES , new Integer ( old ) , new Integer ( value ) ) ; } private class ArticlesListener implements IArticleListener { public void propertyChanged ( IArticle article , String property , Object oldValue , Object newValue ) { if ( IArticle . PROP_READ . equals ( property ) ) { synchronized ( DataFeed . this ) { boolean readNow = ( Boolean ) newValue ; setUnreadArticlesCount ( unreadArticlesCount + ( readNow ? - 1 : 1 ) ) ; } } } } } 