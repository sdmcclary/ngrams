public class JavaMapAdapter < K , V > extends JavaAdapter < Map < K , V > > { private static final long serialVersionUID = 1L ; private Map < K , V > _map ; private long _nextAvailableIndex ; public JavaMapAdapter ( Env env , Map < K , V > map ) { this ( env , map , env . getJavaClassDefinition ( map . getClass ( ) ) ) ; } public JavaMapAdapter ( Env env , Map < K , V > map , JavaClassDef def ) { super ( env , map , def ) ; _map = map ; updateNextAvailableIndex ( ) ; } @ Override public void clear ( ) { _map . clear ( ) ; _nextAvailableIndex = 0 ; } public int size ( ) { return _map . size ( ) ; } @ SuppressWarnings ( "unchecked" ) @ Override public < T > T toJavaObject ( Env env , Class < T > type ) { if ( type . isAssignableFrom ( _map . getClass ( ) ) ) { return ( T ) _map ; } else { env . warning ( L . l ( "Can't assign {0} to {1}" , _map . getClass ( ) . getName ( ) , type . getName ( ) ) ) ; return null ; } } @ Override public Value copy ( ) { try { return new JavaMapAdapter < K , V > ( getEnv ( ) , _map , getClassDef ( ) ) ; } catch ( Exception e ) { throw new QuercusRuntimeException ( e ) ; } } @ Override public Value copy ( Env env , IdentityHashMap < Value , Value > map ) { return new JavaMapAdapter < K , V > ( env , _map , getClassDef ( ) ) ; } @ Override public int getSize ( ) { return size ( ) ; } @ Override public Value get ( Value key ) { Object obj = _map . get ( key . toJavaObject ( ) ) ; if ( obj != null ) return wrapJava ( _map . get ( key . toJavaObject ( ) ) ) ; else return UnsetValue . UNSET ; } @ Override public Value remove ( Value key ) { updateNextAvailableIndex ( ) ; if ( key . isLongConvertible ( ) || key instanceof BooleanValue ) { long pos = key . toLong ( ) ; Object value = _map . remove ( Long . valueOf ( pos ) ) ; if ( value != null ) { if ( pos + 1 == _nextAvailableIndex ) updateNextAvailableIndex ( ) ; return wrapJava ( value ) ; } } else { Object value = _map . remove ( key . toJavaObject ( ) ) ; if ( value != null ) return wrapJava ( value ) ; } return UnsetValue . UNSET ; } @ Override public Value createTailKey ( ) { updateNextAvailableIndex ( ) ; return LongValue . create ( _nextAvailableIndex ) ; } @ Override @ SuppressWarnings ( "unchecked" ) public Value putImpl ( Value key , Value value ) { K keyObject ; if ( key . isLongConvertible ( ) || key instanceof BooleanValue ) { keyObject = ( K ) Long . valueOf ( key . toLong ( ) ) ; } else { keyObject = ( K ) key . toJavaObject ( ) ; } Value val = wrapJava ( _map . put ( keyObject , ( V ) value . toJavaObject ( ) ) ) ; updateNextAvailableIndex ( keyObject ) ; return val ; } public Value containsKey ( Value key ) { return BooleanValue . create ( _map . containsKey ( key . toJavaObject ( ) ) ) ; } @ Override public Iterator < Value > getKeyIterator ( Env env ) { return new KeyIterator ( ) ; } @ Override public Iterator < Value > getValueIterator ( Env env ) { return new ValueIterator ( ) ; } @ Override public Iterator < Map . Entry < Value , Value > > getIterator ( Env env ) { return new MapIterator ( ) ; } @ Override public Set < Map . Entry < Value , Value > > entrySet ( ) { return new MapSet ( ) ; } @ Override @ SuppressWarnings ( "unchecked" ) public Set < Map . Entry > objectEntrySet ( ) { return ( Set < Map . Entry > ) _map . entrySet ( ) ; } @ Override public Collection < Value > values ( ) { return new ValueCollection ( ) ; } private void updateNextAvailableIndex ( ) { _nextAvailableIndex = 0 ; for ( Object key : _map . keySet ( ) ) { updateNextAvailableIndex ( key ) ; } } private void updateNextAvailableIndex ( Object objectKey ) { if ( objectKey instanceof Long ) { long key = ( ( Long ) objectKey ) . longValue ( ) ; if ( _nextAvailableIndex <= key ) _nextAvailableIndex = key + 1 ; } } public class MapSet extends AbstractSet < Map . Entry < Value , Value > > { MapSet ( ) { } @ Override public int size ( ) { return getSize ( ) ; } @ Override public Iterator < Map . Entry < Value , Value > > iterator ( ) { return new MapIterator ( ) ; } } public class MapIterator implements Iterator < Map . Entry < Value , Value > > { private Iterator < Map . Entry < K , V > > _iterator ; public MapIterator ( ) { _iterator = _map . entrySet ( ) . iterator ( ) ; } public boolean hasNext ( ) { return _iterator . hasNext ( ) ; } public Map . Entry < Value , Value > next ( ) { Map . Entry entry = _iterator . next ( ) ; Value key = wrapJava ( entry . getKey ( ) ) ; Value value = wrapJava ( entry . getValue ( ) ) ; return new ArrayValue . Entry ( key , value ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } public class ValueCollection extends AbstractCollection < Value > { ValueCollection ( ) { } @ Override public int size ( ) { return getSize ( ) ; } @ Override public Iterator < Value > iterator ( ) { return new ValueIterator ( ) ; } } public class ValueIterator implements Iterator < Value > { private Iterator _iterator ; public ValueIterator ( ) { _iterator = _map . values ( ) . iterator ( ) ; } public boolean hasNext ( ) { return _iterator . hasNext ( ) ; } public Value next ( ) { return wrapJava ( _iterator . next ( ) ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } public class KeyIterator implements Iterator < Value > { private Iterator _iterator ; public KeyIterator ( ) { _iterator = _map . keySet ( ) . iterator ( ) ; } public boolean hasNext ( ) { return _iterator . hasNext ( ) ; } public Value next ( ) { return wrapJava ( _iterator . next ( ) ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } } 