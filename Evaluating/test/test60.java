public class HiveMigrator implements Migrator { private Hive hive ; private PartitionDimension dimension ; public HiveMigrator ( Hive hive ) { this . hive = hive ; this . dimension = hive . getPartitionDimension ( ) ; } @ SuppressWarnings ( "unchecked" ) public void deepNodeToNodeCopy ( Object migrant , Node origin , Node destination , PartitionKeyMover mover ) { try { mover . copy ( migrant , destination ) ; for ( Pair < Mover , KeyLocator > p : ( List < Pair < Mover , KeyLocator > > ) mover . getDependentMovers ( ) ) { final KeyLocator value = p . getValue ( ) ; for ( Object childKey : value . findAll ( migrant ) ) { Mover childMover = p . getKey ( ) ; Object child = childMover . get ( childKey , origin ) ; childMover . copy ( child , destination ) ; } } } catch ( RuntimeException e ) { throw new MigrationException ( String . format ( "An error occured while copying records from node %s to node %s.  Records may be orphaned on node %s" , destination . getName ( ) , origin . getName ( ) , destination . getName ( ) ) , e ) ; } } @ SuppressWarnings ( "unchecked" ) public void cascadeDelete ( Object migrant , Node node , PartitionKeyMover mover ) { for ( Pair < Mover , KeyLocator > p : ( List < Pair < Mover , KeyLocator > > ) mover . getDependentMovers ( ) ) { for ( Object childKey : p . getValue ( ) . findAll ( migrant ) ) { Mover childMover = p . getKey ( ) ; Object child = childMover . get ( childKey , node ) ; childMover . delete ( child , node ) ; } } mover . delete ( migrant , node ) ; } @ SuppressWarnings ( "unchecked" ) public void move ( Object key , Node origin , Node destination , PartitionKeyMover mover ) { Object migrant = mover . get ( key , origin ) ; try { mover . copy ( migrant , destination ) ; for ( Pair < Mover , KeyLocator > p : ( List < Pair < Mover , KeyLocator > > ) mover . getDependentMovers ( ) ) { for ( Object childKey : p . getValue ( ) . findAll ( migrant ) ) { Mover childMover = p . getKey ( ) ; Object child = childMover . get ( childKey , origin ) ; childMover . copy ( child , destination ) ; } } } catch ( RuntimeException e ) { throw new MigrationException ( String . format ( "An error occured while copying records from node %s to node %s.  Records may be orphaned on node %s" , destination . getName ( ) , origin . getName ( ) , destination . getName ( ) ) , e ) ; } for ( Pair < Mover , KeyLocator > p : ( List < Pair < Mover , KeyLocator > > ) mover . getDependentMovers ( ) ) { for ( Object childKey : p . getValue ( ) . findAll ( migrant ) ) { Mover childMover = p . getKey ( ) ; Object child = childMover . get ( childKey , origin ) ; childMover . delete ( child , origin ) ; } } mover . delete ( migrant , origin ) ; } private Node getNode ( int id ) { return hive . getNode ( id ) ; } private Node getNode ( String id ) { return hive . getNode ( id ) ; } private void lock ( Object key ) { try { hive . directory ( ) . updatePrimaryIndexKeyReadOnly ( key , true ) ; } catch ( HiveLockableException e ) { throw new MigrationException ( "Failed to lock partition key " + key + " for writing." , e ) ; } } private void unlock ( Object key ) { try { hive . directory ( ) . updatePrimaryIndexKeyReadOnly ( key , false ) ; } catch ( HiveLockableException e ) { throw new MigrationException ( "Failed to unlock partition key " + key + " for writing." , e ) ; } } public void migrate ( Object key , Collection < String > destinationNames , PartitionKeyMover mover ) { Collection < Node > destinations = Collect . amass ( new Unary < String , Node > ( ) { public Node f ( String item ) { return getNode ( item ) ; } } , destinationNames ) ; doMigration ( key , destinations , mover ) ; } private void doMigration ( Object key , Collection < Node > destinations , PartitionKeyMover mover ) { try { lock ( key ) ; DbDirectory dir = new DbDirectory ( dimension ) ; Collection < Node > origins = Transform . map ( new Unary < KeySemaphore , Node > ( ) { public Node f ( KeySemaphore keySemaphore ) { return getNode ( keySemaphore . getNodeId ( ) ) ; } } , dir . getKeySemamphoresOfPrimaryIndexKey ( key ) ) ; Node authority = Lists . random ( origins ) ; Object migrant = mover . get ( key , authority ) ; for ( Node destination : destinations ) { try { deepNodeToNodeCopy ( migrant , authority , destination , mover ) ; } catch ( RuntimeException e ) { throw new MigrationException ( String . format ( "Error while copying records to node %s" , destination . getName ( ) ) , e ) ; } } try { dir . deletePrimaryIndexKey ( key ) ; for ( Node destination : destinations ) dir . insertPrimaryIndexKey ( destination , key ) ; } catch ( RuntimeException e ) { try { for ( Node origin : origins ) dir . insertPrimaryIndexKey ( origin , key ) ; } catch ( Exception ex ) { } throw new MigrationException ( String . format ( "Failed to update directory entry for %s. Records may be orphaned." , key ) , e ) ; } for ( Node node : origins ) { try { cascadeDelete ( migrant , node , mover ) ; } catch ( RuntimeException e ) { throw new MigrationException ( String . format ( "Error deleting old records on node %s" , node . getName ( ) ) , e ) ; } } } finally { unlock ( key ) ; } } } 