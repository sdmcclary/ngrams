public class GlMatcher < E > { public int [ ] tokenBoundaries ; public int [ ] docTokenBounds ; int falseHashMatches = 0 ; private HashAlgorithm < E > ha ; public GlMatcher ( HashAlgorithm < E > ha ) { this . ha = ha ; } public List < Segment < E > > match ( List < E > base , List < E > doc , int [ ] sizes ) { long timeB = System . currentTimeMillis ( ) ; List < Segment < E > > baseList = new ArrayList < Segment < E > > ( ) ; baseList . add ( Segment . createIns ( 0 , base , 0 ) ) ; List < Segment < E > > matchList = new LinkedList < Segment < E > > ( ) ; matchList . add ( Segment . createIns ( 0 , doc , 0 ) ) ; int minSize = sizes [ sizes . length - 1 ] ; for ( int b : sizes ) { findChunks ( matchList , baseList , b , minSize ) ; } long timeS = System . currentTimeMillis ( ) ; simplify ( matchList , doc ) ; long timeU = System . currentTimeMillis ( ) ; long timeE = System . currentTimeMillis ( ) ; assert ( _testPositionConsistency ( matchList ) ) ; return matchList ; } private static final < E > boolean _testPositionConsistency ( List < Segment < E > > ml ) { Log . log ( "testing position list consistency" , LogLevels . INFO ) ; int pos = 0 ; for ( Segment < E > s : ml ) { if ( pos != s . getPosition ( ) ) return false ; pos += s . getInsertLen ( ) ; } return true ; } public void simplify ( List < Segment < E > > ml , List < E > doc ) { Segment < E > prev = null ; for ( ListIterator < Segment < E > > li = ml . listIterator ( ) ; li . hasNext ( ) ; ) { Segment < E > current = li . next ( ) ; if ( prev != null && current . appendsTo ( prev ) ) { li . remove ( ) ; prev . append ( current , doc ) ; } else prev = current ; } } public void updatify ( List < Segment < E > > ml , List < Segment < E > > deletia , int baseLen ) { for ( int i = 0 ; i < ml . size ( ) ; i ++ ) { Segment < E > prev = i > 0 ? ml . get ( i - 1 ) : null ; Segment < E > current = ml . get ( i ) ; Segment < E > next = i + 1 < ml . size ( ) ? ml . get ( i + 1 ) : null ; if ( current . getOp ( ) == INSERT && ( prev == null || prev . getOp ( ) == COPY ) && ( next == null || next . getOp ( ) == COPY ) ) { int rqstart = prev != null ? prev . getOffset ( ) + prev . getLength ( ) : 0 ; int rqend = next != null ? next . getOffset ( ) : baseLen ; if ( rqend <= rqstart ) continue ; for ( ListIterator < Segment < E > > j = deletia . listIterator ( ) ; j . hasNext ( ) ; ) { Segment < E > del = j . next ( ) ; if ( del . getOffset ( ) > rqstart ) break ; if ( del . getOffset ( ) < rqstart ) continue ; if ( del . getOffset ( ) + del . getLength ( ) < rqend ) continue ; assert ( del . getOffset ( ) + del . getLength ( ) == rqend ) ; j . remove ( ) ; ml . set ( i , Segment . createUpdate ( del . getOffset ( ) , del . getLength ( ) , current . getInsert ( ) , current . getPosition ( ) ) ) ; } } } } protected void findChunks ( List < Segment < E > > currentOps , List < Segment < E > > base , int chunkSize , int minSize ) { int firstRegion = 0 ; int scanpos = - 1 ; Segment < E > m = null ; Segment < E > collatedIns = null ; Segment < E > match = null ; int collatedLen = - 1 ; if ( base . size ( ) == 0 ) return ; for ( ListIterator < Segment < E > > i = currentOps . listIterator ( ) ; scanpos != - 1 || i . hasNext ( ) ; ) { if ( scanpos == - 1 ) { m = i . next ( ) ; if ( m . getOp ( ) == COPY ) { firstRegion = - m . getOffset ( ) ; continue ; } if ( m . getOp ( ) == INSERT && m . getLength ( ) < chunkSize ) continue ; i . remove ( ) ; scanpos = 0 ; } assert m . getOp ( ) == INSERT ; int [ ] offlen = findChunkInRegions ( scanpos , m . getInsert ( ) , base , firstRegion , chunkSize , minSize ) ; if ( offlen == null ) { int splitSize = chunkSize ; if ( docTokenBounds != null ) { int off = m . getOffset ( ) + splitSize ; int low = Arrays . binarySearch ( docTokenBounds , off ) ; if ( low < 0 ) low = ( - low - 1 ) ; splitSize = docTokenBounds [ low ] - m . getOffset ( ) ; assert ( splitSize > 0 ) ; } boolean willSplit = m . getInsert ( ) . size ( ) - scanpos > splitSize ; int inssize = willSplit ? splitSize : m . getInsert ( ) . size ( ) - scanpos ; if ( collatedIns == null ) { collatedIns = Segment . < E > createCopy ( scanpos , - 1 , scanpos ) ; collatedLen = inssize ; } else { assert ( collatedIns . getOffset ( ) + collatedLen == scanpos ) ; collatedLen += inssize ; } if ( willSplit ) { scanpos += splitSize ; } else { scanpos = - 1 ; } } else { match = Segment . < E > createCopy ( offlen [ 0 ] , offlen [ 1 ] , m . getPosition ( ) + scanpos ) ; if ( ( scanpos + offlen [ 1 ] ) < m . getInsert ( ) . size ( ) ) scanpos += offlen [ 1 ] ; else scanpos = - 1 ; firstRegion = offlen [ 2 ] ; } if ( collatedIns != null && ( scanpos == - 1 || ! i . hasNext ( ) || match != null ) ) { int origin = collatedIns . getOffset ( ) ; collatedIns = Segment . createIns ( origin + m . getOffset ( ) , m . getInsert ( ) . subList ( origin , origin + collatedLen ) , origin + m . getPosition ( ) ) ; i . add ( collatedIns ) ; collatedIns = null ; } if ( match != null ) { i . add ( match ) ; match = null ; } } assert ( collatedIns == null ) ; } protected int [ ] findChunkInRegions ( int scanpos , List < E > chunkToMatch , List < Segment < E > > baseRegions , int firstRegion , int chunkSize , int minSize ) { if ( firstRegion < 0 ) { int offset = - firstRegion ; firstRegion = 0 ; while ( firstRegion < baseRegions . size ( ) && baseRegions . get ( firstRegion ) . getOffset ( ) < offset ) firstRegion ++ ; } int bfly = 0 , maxbfly = chunkSize >= 8 ? Integer . MAX_VALUE : 2 * chunkSize + 2 ; loop : for ( int ofi = firstRegion ; ofi < firstRegion + baseRegions . size ( ) ; ofi ++ ) { int i = ( baseRegions . size ( ) + bfly + firstRegion ) % baseRegions . size ( ) ; if ( bfly <= 0 ) bfly = - bfly + 1 ; else bfly = - bfly ; if ( bfly > maxbfly || bfly < - maxbfly ) return null ; Segment < E > region = baseRegions . get ( i ) ; int [ ] offlen = findChunk ( scanpos , chunkToMatch , region . getInsert ( ) , chunkSize , minSize ) ; if ( offlen != null ) { if ( tokenBoundaries != null ) { int start = - 1 , end = - 1 , regionMax = region . getOffset ( ) + region . getLength ( ) , regionMin = region . getOffset ( ) ; Log . log ( "Unaligned match is " + region . getInsert ( ) . subList ( offlen [ 0 ] , offlen [ 0 ] + offlen [ 1 ] ) , LogLevels . INFO ) ; { int origStart = offlen [ 0 ] + region . getOffset ( ) ; int low = Arrays . binarySearch ( tokenBoundaries , origStart ) ; if ( low < 0 ) { low = ( - low ) - 2 ; assert ( tokenBoundaries [ low + 1 ] >= regionMin ) ; int mid = ( tokenBoundaries [ low ] + tokenBoundaries [ low + 1 ] ) / 2 ; start = origStart <= mid && tokenBoundaries [ low ] >= regionMin ? tokenBoundaries [ low ] : tokenBoundaries [ low + 1 ] ; } else start = origStart ; } { int origEnd = offlen [ 0 ] + offlen [ 1 ] + region . getOffset ( ) ; int hi = Arrays . binarySearch ( tokenBoundaries , origEnd ) ; if ( hi < 0 ) { hi = ( - hi ) - 2 ; assert ( tokenBoundaries [ hi ] <= regionMax ) ; int mid = ( tokenBoundaries [ hi ] + tokenBoundaries [ hi + 1 ] ) / 2 ; end = origEnd > mid && tokenBoundaries [ hi + 1 ] <= regionMax ? tokenBoundaries [ hi + 1 ] : tokenBoundaries [ hi ] ; } else end = origEnd ; } if ( end <= start ) continue loop ; offlen [ 0 ] = start - region . getOffset ( ) ; offlen [ 1 ] = end - start ; assert ( offlen [ 0 ] >= 0 ) ; assert ( offlen [ 1 ] >= 0 ) ; assert ( offlen [ 0 ] < region . getLength ( ) ) ; assert ( offlen [ 0 ] + offlen [ 1 ] <= region . getLength ( ) ) ; assert ( region . getLength ( ) == region . getInsert ( ) . size ( ) ) ; Log . log ( "Aligned match is " + region . getInsert ( ) . subList ( offlen [ 0 ] , offlen [ 0 ] + offlen [ 1 ] ) , LogLevels . INFO ) ; } baseRegions . remove ( i ) ; if ( offlen [ 0 ] > 0 ) { Segment < E > pre = Segment . createIns ( region . getOffset ( ) , region . getInsert ( ) . subList ( 0 , offlen [ 0 ] ) , region . getOffset ( ) ) ; baseRegions . add ( i , pre ) ; i ++ ; } if ( offlen [ 0 ] + offlen [ 1 ] < region . getLength ( ) ) { int start = offlen [ 0 ] + offlen [ 1 ] ; Segment < E > post = Segment . createIns ( start + region . getOffset ( ) , region . getInsert ( ) . subList ( start , region . getInsert ( ) . size ( ) ) , start + region . getOffset ( ) ) ; baseRegions . add ( i , post ) ; } offlen [ 0 ] += region . getOffset ( ) ; return new int [ ] { offlen [ 0 ] , offlen [ 1 ] , i + 1 } ; } } return null ; } protected int [ ] findChunk ( int scanpos , List < E > chunk , List < E > baseRegion , int chunkSize , int minSize ) { int len = Math . min ( chunkSize , chunk . size ( ) - scanpos ) ; if ( baseRegion . size ( ) < len || len < minSize ) return null ; short [ ] froll = initroll ( chunk , len , scanpos ) ; short [ ] broll = initroll ( baseRegion , len , 0 ) ; for ( int i = 0 ; i + len <= baseRegion . size ( ) ; i ++ ) { if ( froll [ 0 ] == broll [ 0 ] && froll [ 1 ] == broll [ 1 ] ) { int j = 0 ; for ( ; j < len && chunk . get ( scanpos + j ) . equals ( baseRegion . get ( i + j ) ) ; j ++ ) ; if ( j == len ) { int maxmore = Math . min ( chunk . size ( ) - len - scanpos , baseRegion . size ( ) - i - len ) ; int extra = 0 ; while ( extra < maxmore && baseRegion . get ( i + len + extra ) . equals ( chunk . get ( scanpos + len + extra ) ) ) extra ++ ; return new int [ ] { i , len + extra } ; } else falseHashMatches ++ ; } if ( i + len < baseRegion . size ( ) ) updateroll ( broll , baseRegion . get ( i ) , baseRegion . get ( i + len ) , i , i + len ) ; } return null ; } protected final short [ ] initroll ( List < E > baseRegion , int len , int off ) { short a = 0 , b = 0 ; for ( int i = 0 ; i < len ; i ++ ) { short hash = ha . quickHash ( baseRegion . get ( i + off ) ) ; a += hash ; b += ( len - i ) * hash ; } return new short [ ] { a , b } ; } protected final void updateroll ( short [ ] state , E outT , E inT , int k , int l ) { short in = ha . quickHash ( inT ) ; short out = ha . quickHash ( outT ) ; state [ 0 ] += in - out ; state [ 1 ] = ( short ) ( ( state [ 1 ] - ( ( l - k ) * out ) ) + state [ 0 ] ) ; } } 