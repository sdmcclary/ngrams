public class BuilderPreProcessor { public static final Logger logger = LoggerFactory . getLogger ( BuilderPreProcessor . class ) ; public static final Map < Character , Character > listIndicators = new HashMap < Character , Character > ( ) ; static { listIndicators . put ( '(' , ')' ) ; listIndicators . put ( '[' , ']' ) ; listIndicators . put ( null , null ) ; } public static Object preprocess ( BuilderConfig config , BuildProcess process , Object current , Object parent ) throws BuildException { try { if ( current instanceof Map ) { current = handleMap ( config , process , current , parent ) ; } else if ( current instanceof List ) { current = handleList ( config , process , current , parent ) ; } else if ( current instanceof String && parent == null ) { current = handleString ( config , process , current , parent ) ; } return current ; } catch ( BuildException be ) { logger . error ( be . getMessage ( ) , be ) ; throw be ; } catch ( Exception e ) { logger . error ( e . getMessage ( ) , e ) ; throw new BuildException ( e ) ; } } @ SuppressWarnings ( "unchecked" ) private static Object handleMap ( BuilderConfig config , BuildProcess process , Object current , Object parent ) throws BuildException { Map < String , Object > map = ( Map < String , Object > ) current ; List < String > keysToRemove = new ArrayList < String > ( ) ; Map < String , Object > propertiesToAdd = new HashMap < String , Object > ( ) ; for ( String key : map . keySet ( ) ) { Object value = map . get ( key ) ; String realKey = getRealKey ( key ) ; Class < ? > typeClass = BuilderUtils . getClassFromAlias ( process , realKey , null ) ; if ( typeClass != null ) { ITypeHandler handler = TypeDefinition . getTypeHandler ( config , typeClass ) ; explodeShortcutTypeToMap ( config , process , handler , key , map ) ; Map < String , Object > typeMap = ( Map < String , Object > ) map . get ( key ) ; if ( typeMap == null ) { typeMap = new HashMap < String , Object > ( ) ; } if ( ! key . equals ( realKey ) ) { BuilderUtils . uncompressYaml ( key , typeMap ) ; propertiesToAdd . put ( realKey , typeMap ) ; keysToRemove . add ( key ) ; } handlePropertyAlias ( config , typeClass , typeMap ) ; handleMappedProperties ( config , typeClass , typeMap ) ; if ( ! ( handler instanceof ITypeChildrenHandler ) ) { preprocess ( config , process , typeMap , current ) ; } } else { preprocess ( config , process , value , current ) ; } } for ( String key : keysToRemove ) { map . remove ( key ) ; } for ( String key : propertiesToAdd . keySet ( ) ) { map . put ( key , propertiesToAdd . get ( key ) ) ; } return current ; } @ SuppressWarnings ( "unchecked" ) private static Object handleList ( BuilderConfig config , BuildProcess process , Object current , Object parent ) throws BuildException { List < Object > list = ( List < Object > ) current ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Object item = list . get ( i ) ; if ( item instanceof String ) { String stringItem = ( String ) item ; String realKey = getRealKey ( stringItem ) ; if ( ! stringItem . equals ( realKey ) ) { Class < ? > typeClass = BuilderUtils . getClassFromAlias ( process , realKey , null ) ; if ( typeClass != null ) { Map < String , Object > rootMap = new HashMap < String , Object > ( ) ; Map < String , Object > typeMap = new HashMap < String , Object > ( ) ; rootMap . put ( realKey , typeMap ) ; BuilderUtils . uncompressYaml ( stringItem , typeMap ) ; list . remove ( i ) ; list . add ( i , rootMap ) ; handlePropertyAlias ( config , typeClass , typeMap ) ; handleMappedProperties ( config , typeClass , typeMap ) ; } else { throw new BuildException ( "{0} is not a recognized alias" , realKey ) ; } } else { preprocess ( config , process , item , current ) ; } } else { preprocess ( config , process , item , current ) ; } } return current ; } private static Object handleString ( BuilderConfig config , BuildProcess process , Object current , Object parent ) throws BuildException { String value = ( String ) current ; String realKey = getRealKey ( value ) ; if ( ! value . equals ( realKey ) ) { Class < ? > typeClass = BuilderUtils . getClassFromAlias ( process , realKey , null ) ; if ( typeClass != null ) { Map < String , Object > rootMap = new HashMap < String , Object > ( ) ; Map < String , Object > typeMap = new HashMap < String , Object > ( ) ; rootMap . put ( realKey , typeMap ) ; BuilderUtils . uncompressYaml ( value , typeMap ) ; current = rootMap ; preprocess ( config , process , rootMap , parent ) ; handlePropertyAlias ( config , typeClass , typeMap ) ; handleMappedProperties ( config , typeClass , typeMap ) ; } else { throw new UnrecognizedAliasException ( "\"{0}\" is not a recognized alias" , realKey ) ; } } else { } return current ; } public static void explodeShortcutTypeToMap ( BuilderConfig config , BuildProcess process , ITypeHandler handler , String key , Map < String , Object > current ) throws BuildException { Object value = current . get ( key ) ; if ( value instanceof List ) { Map < String , Object > childMap = new HashMap < String , Object > ( ) ; childMap . put ( handler . getCollectionPropertyName ( ) , value ) ; value = childMap ; current . put ( key , childMap ) ; } if ( value instanceof String ) { String sValue = ( String ) value ; boolean isType = false ; String realTypeKey = getRealKey ( sValue ) ; if ( ! realTypeKey . equals ( value ) ) { Class < ? > valueClass = BuilderUtils . getClassFromAlias ( process , realTypeKey , null ) ; if ( valueClass != null ) { Map < String , Object > rootMap = new HashMap < String , Object > ( ) ; Map < String , Object > typeMap = new HashMap < String , Object > ( ) ; current . put ( key , rootMap ) ; rootMap . put ( realTypeKey , typeMap ) ; BuilderUtils . uncompressYaml ( sValue , typeMap ) ; isType = true ; } } if ( ! isType ) { Map < String , Object > childMap = new HashMap < String , Object > ( ) ; childMap . put ( handler . getSimpleValuePropertyName ( ) , value ) ; value = childMap ; current . put ( key , childMap ) ; } } } private static void handlePropertyAlias ( BuilderConfig config , Class < ? > typeClass , Map < String , Object > typeMap ) throws BuildException { Iterator < String > it = typeMap . keySet ( ) . iterator ( ) ; Map < String , Object > aliasedPropertiesToAdd = new HashMap < String , Object > ( ) ; while ( it . hasNext ( ) ) { String typeMapKey = it . next ( ) ; String actual = TypeDefinition . getPropertyForAlias ( config , typeClass , typeMapKey ) ; if ( actual != null ) { if ( typeMap . containsKey ( actual ) ) { throw new BuildException ( "Both \"{0}\" alias ({1}) and actual \"{2}\" property ({3}) have been specified. Only can of the two is allowed." , typeMapKey , typeMap . get ( typeMapKey ) , actual , typeMap . get ( actual ) ) ; } else { aliasedPropertiesToAdd . put ( actual , typeMap . get ( typeMapKey ) ) ; it . remove ( ) ; } } } for ( String typeMapKey : aliasedPropertiesToAdd . keySet ( ) ) { typeMap . put ( typeMapKey , aliasedPropertiesToAdd . get ( typeMapKey ) ) ; } } private static void handleMappedProperties ( BuilderConfig config , Class < ? > typeClass , Map < String , Object > typeMap ) throws BuildException { for ( String typeMapKey : typeMap . keySet ( ) ) { Object typeMapValue = typeMap . get ( typeMapKey ) ; if ( typeMapValue != null ) { Object mappedValue = TypeDefinition . getPropertyValue ( config , typeClass , typeMapKey , typeMapValue ) ; if ( ! mappedValue . equals ( typeMapValue ) ) { typeMap . put ( typeMapKey , mappedValue ) ; } } } } } 