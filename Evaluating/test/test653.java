public abstract class UnifiedBracketInserterBase implements VerifyKeyListener , ILinkedModeListener { protected ISourceViewer sourceViewer ; public UnifiedBracketInserterBase ( ISourceViewer sourceViewer ) { this . sourceViewer = sourceViewer ; } public static boolean hasPeerCharacter ( char character ) { switch ( character ) { case '(' : case ')' : case '<' : case '>' : case '[' : case ']' : case '"' : case '\'' : case '{' : case '}' : { return true ; } default : { return false ; } } } public static char getPeerCharacter ( char character ) { switch ( character ) { case '(' : return ')' ; case ')' : return '(' ; case '<' : return '>' ; case '>' : return '<' ; case '[' : return ']' ; case ']' : return '[' ; case '"' : return character ; case '\'' : return character ; case '{' : return '}' ; case '}' : return '{' ; default : throw new IllegalArgumentException ( ) ; } } public static boolean isStringBalanced ( String source , char charToCheck , boolean isInserting ) { if ( ! hasPeerCharacter ( charToCheck ) ) { return true ; } char peer = getPeerCharacter ( charToCheck ) ; char [ ] sourceChars = source . toCharArray ( ) ; int charCount = 0 ; int peerCount = 0 ; for ( int i = 0 ; i < sourceChars . length ; i ++ ) { if ( sourceChars [ i ] == charToCheck ) { charCount ++ ; } else if ( sourceChars [ i ] == peer ) { peerCount ++ ; } } if ( charToCheck == '"' || charToCheck == '\'' ) { double firstChangeOnly = charCount + 1 ; return ( firstChangeOnly % 2 ) == 0 ; } int insertCount = isInserting ? 1 : - 1 ; return charCount + insertCount == peerCount ; } protected boolean fCloseBrackets = true ; protected boolean fCloseStrings = true ; protected boolean fCloseAngularBrackets = false ; private final String CATEGORY = toString ( ) ; private IPositionUpdater fUpdater = new ExclusivePositionUpdater ( CATEGORY ) ; private Stack fBracketLevelStack = new Stack ( ) ; public void setCloseBracketsEnabled ( boolean enabled ) { fCloseBrackets = enabled ; } public void setCloseStringsEnabled ( boolean enabled ) { fCloseStrings = enabled ; } public void setCloseAngularBracketsEnabled ( boolean enabled ) { fCloseAngularBrackets = enabled ; } protected boolean isAngularIntroducer ( String identifier ) { return identifier . length ( ) > 0 && ( Character . isUpperCase ( identifier . charAt ( 0 ) ) || identifier . startsWith ( "final" ) || identifier . startsWith ( "public" ) || identifier . startsWith ( "public" ) || identifier . startsWith ( "protected" ) || identifier . startsWith ( "private" ) ) ; } public InsertMode getInsertMode ( ) { return AbstractDecoratedTextEditor . SMART_INSERT ; } public void verifyKey ( VerifyEvent event ) { if ( ! event . doit || getInsertMode ( ) != AbstractDecoratedTextEditor . SMART_INSERT ) { return ; } if ( ! isAutoInsertCharacter ( event . character ) ) { return ; } if ( ! isAutoInsertEnabled ( ) ) { return ; } IDocument document = sourceViewer . getDocument ( ) ; final Point selection = sourceViewer . getSelectedRange ( ) ; final int offset = selection . x ; final int length = selection . y ; try { if ( ! isValidAutoInsertLocation ( event . character , offset , length ) ) { return ; } final char character = event . character ; final char closingCharacter = getPeerCharacter ( character ) ; final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( character ) ; buffer . append ( closingCharacter ) ; if ( offset == document . getLength ( ) ) { String delim = null ; if ( document instanceof IDocumentExtension4 ) { delim = ( ( IDocumentExtension4 ) document ) . getDefaultLineDelimiter ( ) ; } if ( delim == null ) { delim = System . getProperty ( "line.separator" , "\r\n" ) ; } buffer . append ( delim ) ; } document . replace ( offset , length , buffer . toString ( ) ) ; BracketLevel level = new BracketLevel ( ) ; fBracketLevelStack . push ( level ) ; LinkedPositionGroup group = new LinkedPositionGroup ( ) ; group . addPosition ( new LinkedPosition ( document , offset + 1 , 0 , LinkedPositionGroup . NO_STOP ) ) ; LinkedModeModel model = new LinkedModeModel ( ) ; model . addLinkingListener ( this ) ; model . addGroup ( group ) ; model . forceInstall ( ) ; level . fOffset = offset ; level . fLength = 2 ; if ( fBracketLevelStack . size ( ) == 1 ) { document . addPositionCategory ( CATEGORY ) ; document . addPositionUpdater ( fUpdater ) ; } level . fFirstPosition = new Position ( offset , 1 ) ; level . fSecondPosition = new Position ( offset + 1 , 1 ) ; document . addPosition ( CATEGORY , level . fFirstPosition ) ; document . addPosition ( CATEGORY , level . fSecondPosition ) ; level . fUI = new EditorLinkedModeUI ( model , sourceViewer ) ; level . fUI . setSimpleMode ( true ) ; level . fUI . setExitPolicy ( new ExitPolicy ( closingCharacter , getEscapeCharacter ( closingCharacter ) , fBracketLevelStack ) ) ; level . fUI . setExitPosition ( sourceViewer , offset + 2 , 0 , Integer . MAX_VALUE ) ; level . fUI . setCyclingMode ( LinkedModeUI . CYCLE_NEVER ) ; level . fUI . enter ( ) ; IRegion newSelection = level . fUI . getSelectedRegion ( ) ; sourceViewer . setSelectedRange ( newSelection . getOffset ( ) , newSelection . getLength ( ) ) ; event . doit = doEvent ( event ) ; triggerAssistPopup ( event ) ; } catch ( BadLocationException e ) { IdeLog . logError ( Activator . getDefault ( ) , Messages . UnifiedBracketInserterBase_ERR_BadLocation , e ) ; } catch ( BadPositionCategoryException e ) { IdeLog . logError ( Activator . getDefault ( ) , Messages . UnifiedBracketInserterBase_ERR_BadLocation , e ) ; } } protected boolean doEvent ( VerifyEvent event ) { return false ; } public void left ( LinkedModeModel environment , int flags ) { final BracketLevel level = ( BracketLevel ) fBracketLevelStack . pop ( ) ; if ( flags != ILinkedModeListener . EXTERNAL_MODIFICATION ) { return ; } final IDocument document = sourceViewer . getDocument ( ) ; if ( document instanceof IDocumentExtension ) { IDocumentExtension extension = ( IDocumentExtension ) document ; extension . registerPostNotificationReplace ( null , new IDocumentExtension . IReplace ( ) { public void perform ( IDocument document , IDocumentListener owner ) { if ( ( level . fFirstPosition . isDeleted || level . fFirstPosition . length == 0 ) && ! level . fSecondPosition . isDeleted && level . fSecondPosition . offset == level . fFirstPosition . offset ) { try { document . replace ( level . fSecondPosition . offset , level . fSecondPosition . length , null ) ; } catch ( BadLocationException e ) { IdeLog . logError ( Activator . getDefault ( ) , Messages . UnifiedBracketInserterBase_ERR_BadLocation , e ) ; } } if ( fBracketLevelStack . size ( ) == 0 ) { document . removePositionUpdater ( fUpdater ) ; try { document . removePositionCategory ( CATEGORY ) ; } catch ( BadPositionCategoryException e ) { IdeLog . logError ( Activator . getDefault ( ) , Messages . UnifiedBracketInserterBase_ERR_BadLocation , e ) ; } } } } ) ; } } public void suspend ( LinkedModeModel environment ) { } public void resume ( LinkedModeModel environment , int flags ) { } private static class ExclusivePositionUpdater implements IPositionUpdater { private final String fCategory ; public ExclusivePositionUpdater ( String category ) { fCategory = category ; } public void update ( DocumentEvent event ) { int eventOffset = event . getOffset ( ) ; int eventOldLength = event . getLength ( ) ; int eventNewLength = event . getText ( ) == null ? 0 : event . getText ( ) . length ( ) ; int deltaLength = eventNewLength - eventOldLength ; try { Position [ ] positions = event . getDocument ( ) . getPositions ( fCategory ) ; for ( int i = 0 ; i != positions . length ; i ++ ) { Position position = positions [ i ] ; if ( position . isDeleted ( ) ) { continue ; } int offset = position . getOffset ( ) ; int length = position . getLength ( ) ; int end = offset + length ; if ( offset >= eventOffset + eventOldLength ) { position . setOffset ( offset + deltaLength ) ; } else if ( end <= eventOffset ) { } else if ( offset <= eventOffset && end >= eventOffset + eventOldLength ) { position . setLength ( length + deltaLength ) ; } else if ( offset < eventOffset ) { int newEnd = eventOffset ; position . setLength ( newEnd - offset ) ; } else if ( end > eventOffset + eventOldLength ) { int newOffset = eventOffset + eventNewLength ; position . setOffset ( newOffset ) ; position . setLength ( end - newOffset ) ; } else { position . delete ( ) ; } } } catch ( BadPositionCategoryException e ) { } } public String getCategory ( ) { return fCategory ; } } private static class BracketLevel { int fOffset ; int fLength ; LinkedModeUI fUI ; Position fFirstPosition ; Position fSecondPosition ; } private static char getEscapeCharacter ( char character ) { switch ( character ) { case '"' : case '\'' : return '\\' ; default : return 0 ; } } private class ExitPolicy implements IExitPolicy { final char fExitCharacter ; final char fEscapeCharacter ; final Stack fStack ; final int fSize ; public ExitPolicy ( char exitCharacter , char escapeCharacter , Stack stack ) { fExitCharacter = exitCharacter ; fEscapeCharacter = escapeCharacter ; fStack = stack ; fSize = fStack . size ( ) ; } public ExitFlags doExit ( LinkedModeModel model , VerifyEvent event , int offset , int length ) { if ( fSize == fStack . size ( ) && ! isMasked ( offset ) ) { if ( event . character == fExitCharacter ) { BracketLevel level = ( BracketLevel ) fStack . peek ( ) ; if ( level . fFirstPosition . offset > offset || level . fSecondPosition . offset < offset ) { return null ; } if ( level . fSecondPosition . offset == offset && length == 0 ) { triggerAssistClose ( event ) ; return new ExitFlags ( ILinkedModeListener . UPDATE_CARET , false ) ; } } if ( event . character == SWT . CR && offset > 0 ) { IDocument document = sourceViewer . getDocument ( ) ; try { if ( document . getChar ( offset - 1 ) == '{' ) { return new ExitFlags ( ILinkedModeListener . EXIT_ALL , true ) ; } } catch ( BadLocationException e ) { } } } return null ; } private boolean isMasked ( int offset ) { IDocument document = sourceViewer . getDocument ( ) ; try { return fEscapeCharacter == document . getChar ( offset - 1 ) ; } catch ( BadLocationException e ) { } return false ; } } protected boolean isValidAutoInsertLocation ( char character , int offset , int length ) { return true ; } private boolean isAutoInsertCharacter ( char c ) { char [ ] arr = getAutoInsertCharacters ( ) ; Arrays . sort ( arr ) ; int val = Arrays . binarySearch ( arr , c ) ; return val >= 0 ; } protected char [ ] getAutoInsertCharacters ( ) { return new char [ ] { '"' , '\'' , '(' , '[' , '{' } ; } protected boolean isAutoInsertEnabled ( ) { return true ; } protected void triggerAssistPopup ( VerifyEvent event ) { } protected void triggerAssistClose ( VerifyEvent event ) { } } 