public class UnifiedOverviewRuler implements IOverviewRuler { class InternalListener implements ITextListener , IAnnotationModelListener { public void textChanged ( TextEvent e ) { if ( fTextViewer != null && e . getDocumentEvent ( ) == null && e . getViewerRedrawState ( ) ) { redraw ( ) ; } } public void modelChanged ( IAnnotationModel model ) { update ( ) ; } } class FilterIterator implements Iterator { final static int TEMPORARY = 1 << 1 ; final static int PERSISTENT = 1 << 2 ; final static int IGNORE_BAGS = 1 << 3 ; private Iterator fIterator ; private Object fType ; private Annotation fNext ; private int fStyle ; public FilterIterator ( Object annotationType , int style ) { fType = annotationType ; fStyle = style ; if ( fModel != null ) { fIterator = fModel . getAnnotationIterator ( ) ; skip ( ) ; } } public FilterIterator ( Object annotationType , int style , Iterator iterator ) { fType = annotationType ; fStyle = style ; fIterator = iterator ; skip ( ) ; } private void skip ( ) { boolean temp = ( fStyle & TEMPORARY ) != 0 ; boolean pers = ( fStyle & PERSISTENT ) != 0 ; boolean ignr = ( fStyle & IGNORE_BAGS ) != 0 ; while ( fIterator . hasNext ( ) ) { Annotation next = ( Annotation ) fIterator . next ( ) ; if ( next . isMarkedDeleted ( ) ) continue ; if ( ignr && ( next instanceof AnnotationBag ) ) continue ; fNext = next ; Object annotationType = next . getType ( ) ; if ( fType == null || isSubtype ( annotationType ) ) { if ( temp && pers ) return ; if ( pers && next . isPersistent ( ) ) return ; if ( temp && ! next . isPersistent ( ) ) return ; } } fNext = null ; } private boolean isSubtype ( Object annotationType ) { if ( fAnnotationAccess instanceof IAnnotationAccessExtension ) { IAnnotationAccessExtension extension = ( IAnnotationAccessExtension ) fAnnotationAccess ; return extension . isSubtype ( annotationType , fType ) ; } return fType . equals ( annotationType ) ; } public boolean hasNext ( ) { return fNext != null ; } public Object next ( ) { try { return fNext ; } finally { if ( fIterator != null ) skip ( ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } class HeaderPainter implements PaintListener { private Color fIndicatorColor ; private Color fSeparatorColor ; public HeaderPainter ( ) { fSeparatorColor = fSharedTextColors . getColor ( ViewForm . borderInsideRGB ) ; } public void setColor ( Color color ) { fIndicatorColor = color ; } private void drawBevelRect ( GC gc , int x , int y , int w , int h , Color topLeft , Color bottomRight ) { gc . setForeground ( topLeft == null ? fSeparatorColor : topLeft ) ; gc . drawLine ( x , y , x + w - 1 , y ) ; gc . drawLine ( x , y , x , y + h - 1 ) ; gc . setForeground ( bottomRight == null ? fSeparatorColor : bottomRight ) ; gc . drawLine ( x + w , y , x + w , y + h ) ; gc . drawLine ( x , y + h , x + w , y + h ) ; } public void paintControl ( PaintEvent e ) { Point s = fHeader . getSize ( ) ; if ( fIndicatorColor != null ) { e . gc . setBackground ( fIndicatorColor ) ; Rectangle r = new Rectangle ( INSET , ( s . y - ( 2 * ANNOTATION_HEIGHT ) ) / 2 , s . x - ( 2 * INSET ) , 2 * ANNOTATION_HEIGHT ) ; e . gc . fillRectangle ( r ) ; Display d = fHeader . getDisplay ( ) ; if ( d != null ) drawBevelRect ( e . gc , r . x , r . y , r . width - 1 , r . height - 1 , null , null ) ; } e . gc . setForeground ( fSeparatorColor ) ; e . gc . setLineWidth ( 1 ) ; e . gc . drawLine ( 0 , s . y - 1 , s . x - 1 , s . y - 1 ) ; } } private static final int INSET = 2 ; private static final int ANNOTATION_HEIGHT = 4 ; private static boolean ANNOTATION_HEIGHT_SCALABLE = true ; private IAnnotationModel fModel ; private ITextViewer fTextViewer ; private Canvas fCanvas ; private Canvas fHeader ; private Image fBuffer ; private InternalListener fInternalListener = new InternalListener ( ) ; private int fWidth ; private Cursor fHitDetectionCursor ; private Cursor fLastCursor ; private int fLastMouseButtonActivityLine = - 1 ; private int fAnnotationHeight = - 1 ; private IAnnotationAccess fAnnotationAccess ; private HeaderPainter fHeaderPainter ; private Set < Object > fConfiguredAnnotationTypes = new HashSet < Object > ( ) ; private Set < Object > fConfiguredHeaderAnnotationTypes = new HashSet < Object > ( ) ; private Map < Object , Object > fAnnotationTypes2Colors = new HashMap < Object , Object > ( ) ; private ISharedTextColors fSharedTextColors ; private List < Object > fAnnotationsSortedByLayer = new ArrayList < Object > ( ) ; private List < Object > fLayersSortedByLayer = new ArrayList < Object > ( ) ; private Map fAllowedAnnotationTypes = new HashMap ( ) ; private Map fAllowedHeaderAnnotationTypes = new HashMap ( ) ; private List < Object > fCachedAnnotations = new ArrayList < Object > ( ) ; public UnifiedOverviewRuler ( IAnnotationAccess annotationAccess , int width , ISharedTextColors sharedColors ) { fAnnotationAccess = annotationAccess ; fWidth = width ; fSharedTextColors = sharedColors ; } public Control getControl ( ) { return fCanvas ; } public int getWidth ( ) { return fWidth ; } public void setModel ( IAnnotationModel model ) { if ( model != fModel || model != null ) { if ( fModel != null ) fModel . removeAnnotationModelListener ( fInternalListener ) ; fModel = model ; if ( fModel != null ) fModel . addAnnotationModelListener ( fInternalListener ) ; update ( ) ; } } public Control createControl ( Composite parent , ITextViewer textViewer ) { fTextViewer = textViewer ; fHitDetectionCursor = new Cursor ( parent . getDisplay ( ) , SWT . CURSOR_HAND ) ; fHeader = new Canvas ( parent , SWT . NONE ) ; fCanvas = new Canvas ( parent , SWT . NO_BACKGROUND ) ; fCanvas . addPaintListener ( new PaintListener ( ) { public void paintControl ( PaintEvent event ) { if ( fTextViewer != null ) doubleBufferPaint ( event . gc ) ; } } ) ; fCanvas . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { handleDispose ( ) ; fTextViewer = null ; } } ) ; fCanvas . addMouseListener ( new MouseAdapter ( ) { public void mouseDown ( MouseEvent event ) { handleMouseDown ( event ) ; } } ) ; fCanvas . addMouseMoveListener ( new MouseMoveListener ( ) { public void mouseMove ( MouseEvent event ) { handleMouseMove ( event ) ; } } ) ; if ( fTextViewer != null ) fTextViewer . addTextListener ( fInternalListener ) ; return fCanvas ; } private void handleDispose ( ) { if ( fTextViewer != null ) { fTextViewer . removeTextListener ( fInternalListener ) ; fTextViewer = null ; } if ( fModel != null ) fModel . removeAnnotationModelListener ( fInternalListener ) ; if ( fBuffer != null ) { fBuffer . dispose ( ) ; fBuffer = null ; } if ( fHitDetectionCursor != null ) { fHitDetectionCursor . dispose ( ) ; fHitDetectionCursor = null ; } fConfiguredAnnotationTypes . clear ( ) ; fAllowedAnnotationTypes . clear ( ) ; fConfiguredHeaderAnnotationTypes . clear ( ) ; fAllowedHeaderAnnotationTypes . clear ( ) ; fAnnotationTypes2Colors . clear ( ) ; fAnnotationsSortedByLayer . clear ( ) ; fLayersSortedByLayer . clear ( ) ; } private void doubleBufferPaint ( GC dest ) { Point size = fCanvas . getSize ( ) ; if ( size . x <= 0 || size . y <= 0 ) return ; if ( fBuffer != null ) { Rectangle r = fBuffer . getBounds ( ) ; if ( r . width != size . x || r . height != size . y ) { fBuffer . dispose ( ) ; fBuffer = null ; } } if ( fBuffer == null ) fBuffer = new Image ( fCanvas . getDisplay ( ) , size . x , size . y ) ; GC gc = new GC ( fBuffer ) ; try { gc . setBackground ( fCanvas . getBackground ( ) ) ; gc . fillRectangle ( 0 , 0 , size . x , size . y ) ; if ( fTextViewer instanceof ITextViewerExtension5 ) doPaint1 ( gc ) ; else doPaint ( gc ) ; } finally { gc . dispose ( ) ; } dest . drawImage ( fBuffer , 0 , 0 ) ; } private void doPaint ( GC gc ) { Rectangle r = new Rectangle ( 0 , 0 , 0 , 0 ) ; int yy , hh = ANNOTATION_HEIGHT ; IDocument document = fTextViewer . getDocument ( ) ; IRegion visible = fTextViewer . getVisibleRegion ( ) ; StyledText textWidget = fTextViewer . getTextWidget ( ) ; int maxLines = textWidget . getLineCount ( ) ; Point size = fCanvas . getSize ( ) ; int writable = JFaceTextUtil . computeLineHeight ( textWidget , 0 , maxLines , maxLines ) ; if ( size . y > writable ) size . y = Math . max ( writable - fHeader . getSize ( ) . y , 0 ) ; for ( Iterator iterator = fAnnotationsSortedByLayer . iterator ( ) ; iterator . hasNext ( ) ; ) { Object annotationType = iterator . next ( ) ; if ( skip ( annotationType ) ) continue ; int [ ] style = new int [ ] { FilterIterator . PERSISTENT , FilterIterator . TEMPORARY } ; for ( int t = 0 ; t < style . length ; t ++ ) { Iterator e = new FilterIterator ( annotationType , style [ t ] ) ; Color fill = getFillColor ( annotationType , style [ t ] == FilterIterator . TEMPORARY ) ; Color stroke = getStrokeColor ( annotationType , style [ t ] == FilterIterator . TEMPORARY ) ; for ( int i = 0 ; e . hasNext ( ) ; i ++ ) { Annotation a = ( Annotation ) e . next ( ) ; Position p = fModel . getPosition ( a ) ; if ( p == null || ! p . overlapsWith ( visible . getOffset ( ) , visible . getLength ( ) ) ) continue ; int annotationOffset = Math . max ( p . getOffset ( ) , visible . getOffset ( ) ) ; int annotationEnd = Math . min ( p . getOffset ( ) + p . getLength ( ) , visible . getOffset ( ) + visible . getLength ( ) ) ; int annotationLength = annotationEnd - annotationOffset ; try { if ( ANNOTATION_HEIGHT_SCALABLE ) { int numbersOfLines = document . getNumberOfLines ( annotationOffset , annotationLength ) ; IRegion lastLine = document . getLineInformationOfOffset ( annotationOffset + annotationLength ) ; if ( lastLine . getOffset ( ) == annotationOffset + annotationLength ) { numbersOfLines -= 2 ; hh = ( numbersOfLines * size . y ) / maxLines + ANNOTATION_HEIGHT ; if ( hh < ANNOTATION_HEIGHT ) hh = ANNOTATION_HEIGHT ; } else hh = ANNOTATION_HEIGHT ; } fAnnotationHeight = hh ; int startLine = textWidget . getLineAtOffset ( annotationOffset - visible . getOffset ( ) ) ; yy = Math . min ( ( startLine * size . y ) / maxLines , size . y - hh ) ; if ( fill != null ) { gc . setBackground ( fill ) ; gc . fillRectangle ( INSET , yy , size . x - ( 2 * INSET ) , hh ) ; } if ( stroke != null ) { gc . setForeground ( stroke ) ; r . x = INSET ; r . y = yy ; r . width = size . x - ( 2 * INSET ) ; r . height = hh ; gc . setLineWidth ( 1 ) ; gc . drawRectangle ( r ) ; } } catch ( BadLocationException x ) { } } } } } private void doPaint1 ( GC gc ) { Rectangle r = new Rectangle ( 0 , 0 , 0 , 0 ) ; int yy , hh = ANNOTATION_HEIGHT ; ITextViewerExtension5 extension = ( ITextViewerExtension5 ) fTextViewer ; IDocument document = fTextViewer . getDocument ( ) ; StyledText textWidget = fTextViewer . getTextWidget ( ) ; int maxLines = textWidget . getLineCount ( ) ; Point size = fCanvas . getSize ( ) ; int writable = JFaceTextUtil . computeLineHeight ( textWidget , 0 , maxLines , maxLines ) ; if ( size . y > writable ) size . y = Math . max ( writable - fHeader . getSize ( ) . y , 0 ) ; fCachedAnnotations . clear ( ) ; if ( fModel != null ) { Iterator iter = fModel . getAnnotationIterator ( ) ; while ( iter . hasNext ( ) ) { Annotation annotation = ( Annotation ) iter . next ( ) ; if ( annotation . isMarkedDeleted ( ) ) continue ; if ( skip ( annotation . getType ( ) ) ) continue ; fCachedAnnotations . add ( annotation ) ; } } for ( Iterator iterator = fAnnotationsSortedByLayer . iterator ( ) ; iterator . hasNext ( ) ; ) { Object annotationType = iterator . next ( ) ; if ( skip ( annotationType ) ) continue ; int [ ] style = new int [ ] { FilterIterator . PERSISTENT , FilterIterator . TEMPORARY } ; for ( int t = 0 ; t < style . length ; t ++ ) { Iterator e = new FilterIterator ( annotationType , style [ t ] , fCachedAnnotations . iterator ( ) ) ; Color fill = getFillColor ( annotationType , style [ t ] == FilterIterator . TEMPORARY ) ; Color stroke = getStrokeColor ( annotationType , style [ t ] == FilterIterator . TEMPORARY ) ; for ( int i = 0 ; e . hasNext ( ) ; i ++ ) { Annotation a = ( Annotation ) e . next ( ) ; Position p = fModel . getPosition ( a ) ; if ( p == null ) continue ; IRegion widgetRegion = extension . modelRange2WidgetRange ( new Region ( p . getOffset ( ) , p . getLength ( ) ) ) ; if ( widgetRegion == null ) continue ; try { if ( ANNOTATION_HEIGHT_SCALABLE ) { int numbersOfLines = document . getNumberOfLines ( p . getOffset ( ) , p . getLength ( ) ) ; IRegion lastLine = document . getLineInformationOfOffset ( p . getOffset ( ) + p . getLength ( ) ) ; if ( lastLine . getOffset ( ) == p . getOffset ( ) + p . getLength ( ) ) { numbersOfLines -= 2 ; hh = ( numbersOfLines * size . y ) / maxLines + ANNOTATION_HEIGHT ; if ( hh < ANNOTATION_HEIGHT ) hh = ANNOTATION_HEIGHT ; } else hh = ANNOTATION_HEIGHT ; } fAnnotationHeight = hh ; int startLine = textWidget . getLineAtOffset ( widgetRegion . getOffset ( ) ) ; int total = size . y - hh ; if ( startLine > 0 ) { total = textWidget . getTextBounds ( 0 , textWidget . getOffsetAtLine ( startLine - 1 ) ) . height + textWidget . getLineHeight ( ) / 2 ; } yy = total ; if ( fill != null ) { gc . setBackground ( fill ) ; gc . fillRectangle ( INSET , yy , size . x - ( 2 * INSET ) , hh ) ; } if ( stroke != null ) { gc . setForeground ( stroke ) ; r . x = INSET ; r . y = yy ; r . width = size . x - ( 2 * INSET ) ; r . height = hh ; gc . setLineWidth ( 1 ) ; gc . drawRectangle ( r ) ; } } catch ( BadLocationException x ) { } } } } fCachedAnnotations . clear ( ) ; } public void update ( ) { if ( fCanvas != null && ! fCanvas . isDisposed ( ) ) { Display d = fCanvas . getDisplay ( ) ; if ( d != null ) { d . asyncExec ( new Runnable ( ) { public void run ( ) { redraw ( ) ; updateHeader ( ) ; } } ) ; } } } private void redraw ( ) { if ( fTextViewer == null || fModel == null ) return ; if ( fCanvas != null && ! fCanvas . isDisposed ( ) ) { GC gc = new GC ( fCanvas ) ; doubleBufferPaint ( gc ) ; gc . dispose ( ) ; } } private int [ ] toLineNumbers ( int y_coordinate ) { StyledText textWidget = fTextViewer . getTextWidget ( ) ; int maxLines = textWidget . getContent ( ) . getLineCount ( ) ; int rulerLength = fCanvas . getSize ( ) . y ; int writable = JFaceTextUtil . computeLineHeight ( textWidget , 0 , maxLines , maxLines ) ; if ( rulerLength > writable ) rulerLength = Math . max ( writable - fHeader . getSize ( ) . y , 0 ) ; if ( y_coordinate >= writable || y_coordinate >= rulerLength ) return new int [ ] { - 1 , - 1 } ; int [ ] lines = new int [ 2 ] ; int pixel0 = Math . max ( y_coordinate - 1 , 0 ) ; int pixel1 = Math . min ( rulerLength , y_coordinate + 1 ) ; rulerLength = Math . max ( rulerLength , 1 ) ; lines [ 0 ] = ( pixel0 * maxLines ) / rulerLength ; lines [ 1 ] = ( pixel1 * maxLines ) / rulerLength ; if ( fTextViewer instanceof ITextViewerExtension5 ) { ITextViewerExtension5 extension = ( ITextViewerExtension5 ) fTextViewer ; lines [ 0 ] = extension . widgetLine2ModelLine ( lines [ 0 ] ) ; lines [ 1 ] = extension . widgetLine2ModelLine ( lines [ 1 ] ) ; } else { try { IRegion visible = fTextViewer . getVisibleRegion ( ) ; int lineNumber = fTextViewer . getDocument ( ) . getLineOfOffset ( visible . getOffset ( ) ) ; lines [ 0 ] += lineNumber ; lines [ 1 ] += lineNumber ; } catch ( BadLocationException x ) { } } return lines ; } private Position getAnnotationPosition ( int [ ] lineNumbers , boolean ignoreSelectedAnnotation ) { if ( lineNumbers [ 0 ] == - 1 ) return null ; Position found = null ; try { IDocument d = fTextViewer . getDocument ( ) ; IRegion line = d . getLineInformation ( lineNumbers [ 0 ] ) ; Point currentSelection = fTextViewer . getSelectedRange ( ) ; int start = line . getOffset ( ) ; line = d . getLineInformation ( lineNumbers [ lineNumbers . length - 1 ] ) ; int end = line . getOffset ( ) + line . getLength ( ) ; for ( int i = fAnnotationsSortedByLayer . size ( ) - 1 ; i >= 0 ; i -- ) { Object annotationType = fAnnotationsSortedByLayer . get ( i ) ; Iterator e = new FilterIterator ( annotationType , FilterIterator . PERSISTENT | FilterIterator . TEMPORARY ) ; while ( e . hasNext ( ) && found == null ) { Annotation a = ( Annotation ) e . next ( ) ; if ( a . isMarkedDeleted ( ) ) continue ; if ( skip ( a . getType ( ) ) ) continue ; Position p = fModel . getPosition ( a ) ; if ( p == null ) continue ; int posOffset = p . getOffset ( ) ; int posEnd = posOffset + p . getLength ( ) ; IRegion region = d . getLineInformationOfOffset ( posEnd ) ; if ( posEnd > posOffset && region . getOffset ( ) == posEnd ) { posEnd -- ; region = d . getLineInformationOfOffset ( posEnd ) ; } if ( posOffset <= end && posEnd >= start ) { if ( ignoreSelectedAnnotation || currentSelection . x != posOffset || currentSelection . y != p . getLength ( ) ) found = p ; } } } } catch ( BadLocationException x ) { } return found ; } private int findBestMatchingLineNumber ( int [ ] lineNumbers ) { if ( lineNumbers == null || lineNumbers . length < 1 ) return - 1 ; try { Position pos = getAnnotationPosition ( lineNumbers , true ) ; if ( pos == null ) return - 1 ; return fTextViewer . getDocument ( ) . getLineOfOffset ( pos . getOffset ( ) ) ; } catch ( BadLocationException ex ) { return - 1 ; } } private void handleMouseDown ( MouseEvent event ) { if ( fTextViewer != null ) { int [ ] lines = toLineNumbers ( event . y ) ; Position p = getAnnotationPosition ( lines , false ) ; if ( p != null ) { fTextViewer . revealRange ( p . getOffset ( ) , p . getLength ( ) ) ; fTextViewer . setSelectedRange ( p . getOffset ( ) , p . getLength ( ) ) ; } fTextViewer . getTextWidget ( ) . setFocus ( ) ; } fLastMouseButtonActivityLine = toDocumentLineNumber ( event . y ) ; } private void handleMouseMove ( MouseEvent event ) { if ( fTextViewer != null ) { int [ ] lines = toLineNumbers ( event . y ) ; Position p = getAnnotationPosition ( lines , true ) ; Cursor cursor = ( p != null ? fHitDetectionCursor : null ) ; if ( cursor != fLastCursor ) { fCanvas . setCursor ( cursor ) ; fLastCursor = cursor ; } } } public void addAnnotationType ( Object annotationType ) { fConfiguredAnnotationTypes . add ( annotationType ) ; fAllowedAnnotationTypes . clear ( ) ; } public void removeAnnotationType ( Object annotationType ) { fConfiguredAnnotationTypes . remove ( annotationType ) ; fAllowedAnnotationTypes . clear ( ) ; } public void setAnnotationTypeLayer ( Object annotationType , int layer ) { int j = fAnnotationsSortedByLayer . indexOf ( annotationType ) ; if ( j != - 1 ) { fAnnotationsSortedByLayer . remove ( j ) ; fLayersSortedByLayer . remove ( j ) ; } if ( layer >= 0 ) { int i = 0 ; int size = fLayersSortedByLayer . size ( ) ; while ( i < size && layer >= ( ( Integer ) fLayersSortedByLayer . get ( i ) ) . intValue ( ) ) i ++ ; Integer layerObj = new Integer ( layer ) ; fLayersSortedByLayer . add ( i , layerObj ) ; fAnnotationsSortedByLayer . add ( i , annotationType ) ; } } public void setAnnotationTypeColor ( Object annotationType , Color color ) { if ( color != null ) fAnnotationTypes2Colors . put ( annotationType , color ) ; else fAnnotationTypes2Colors . remove ( annotationType ) ; } private boolean skip ( Object annotationType ) { return ! contains ( annotationType , fAllowedAnnotationTypes , fConfiguredAnnotationTypes ) ; } private boolean skipInHeader ( Object annotationType ) { return ! contains ( annotationType , fAllowedHeaderAnnotationTypes , fConfiguredHeaderAnnotationTypes ) ; } private boolean contains ( Object annotationType , Map allowed , Set configured ) { Boolean cached = ( Boolean ) allowed . get ( annotationType ) ; if ( cached != null ) return cached . booleanValue ( ) ; boolean covered = isCovered ( annotationType , configured ) ; allowed . put ( annotationType , covered ? Boolean . TRUE : Boolean . FALSE ) ; return covered ; } private boolean isCovered ( Object annotationType , Set configured ) { if ( fAnnotationAccess instanceof IAnnotationAccessExtension ) { IAnnotationAccessExtension extension = ( IAnnotationAccessExtension ) fAnnotationAccess ; Iterator e = configured . iterator ( ) ; while ( e . hasNext ( ) ) { if ( extension . isSubtype ( annotationType , e . next ( ) ) ) return true ; } return false ; } return configured . contains ( annotationType ) ; } private static RGB interpolate ( RGB fg , RGB bg , double scale ) { return new RGB ( ( int ) ( ( 1.0 - scale ) * fg . red + scale * bg . red ) , ( int ) ( ( 1.0 - scale ) * fg . green + scale * bg . green ) , ( int ) ( ( 1.0 - scale ) * fg . blue + scale * bg . blue ) ) ; } private static double greyLevel ( RGB rgb ) { if ( rgb . red == rgb . green && rgb . green == rgb . blue ) return rgb . red ; return ( 0.299 * rgb . red + 0.587 * rgb . green + 0.114 * rgb . blue + 0.5 ) ; } private static boolean isDark ( RGB rgb ) { return greyLevel ( rgb ) > 128 ; } private Color getColor ( Object annotationType , double scale ) { Color base = findColor ( annotationType ) ; if ( base == null ) return null ; RGB baseRGB = base . getRGB ( ) ; RGB background = fCanvas . getBackground ( ) . getRGB ( ) ; boolean darkBase = isDark ( baseRGB ) ; boolean darkBackground = isDark ( background ) ; if ( darkBase && darkBackground ) background = new RGB ( 255 , 255 , 255 ) ; else if ( ! darkBase && ! darkBackground ) background = new RGB ( 0 , 0 , 0 ) ; return fSharedTextColors . getColor ( interpolate ( baseRGB , background , scale ) ) ; } private Color findColor ( Object annotationType ) { Color color = ( Color ) fAnnotationTypes2Colors . get ( annotationType ) ; if ( color != null ) return color ; if ( fAnnotationAccess instanceof IAnnotationAccessExtension ) { IAnnotationAccessExtension extension = ( IAnnotationAccessExtension ) fAnnotationAccess ; Object [ ] superTypes = extension . getSupertypes ( annotationType ) ; if ( superTypes != null ) { for ( int i = 0 ; i < superTypes . length ; i ++ ) { color = ( Color ) fAnnotationTypes2Colors . get ( superTypes [ i ] ) ; if ( color != null ) return color ; } } } return null ; } private Color getStrokeColor ( Object annotationType , boolean temporary ) { return getColor ( annotationType , temporary ? 0.5 : 0.2 ) ; } private Color getFillColor ( Object annotationType , boolean temporary ) { return getColor ( annotationType , temporary ? 0.9 : 0.6 ) ; } public int getLineOfLastMouseButtonActivity ( ) { return fLastMouseButtonActivityLine ; } public int toDocumentLineNumber ( int y_coordinate ) { if ( fTextViewer == null || y_coordinate == - 1 ) return - 1 ; int [ ] lineNumbers = toLineNumbers ( y_coordinate ) ; int bestLine = findBestMatchingLineNumber ( lineNumbers ) ; if ( bestLine == - 1 && lineNumbers . length > 0 ) return lineNumbers [ 0 ] ; return bestLine ; } public IAnnotationModel getModel ( ) { return fModel ; } public int getAnnotationHeight ( ) { return fAnnotationHeight ; } public boolean hasAnnotation ( int y ) { return findBestMatchingLineNumber ( toLineNumbers ( y ) ) != - 1 ; } public Control getHeaderControl ( ) { return fHeader ; } public void addHeaderAnnotationType ( Object annotationType ) { fConfiguredHeaderAnnotationTypes . add ( annotationType ) ; fAllowedHeaderAnnotationTypes . clear ( ) ; } public void removeHeaderAnnotationType ( Object annotationType ) { fConfiguredHeaderAnnotationTypes . remove ( annotationType ) ; fAllowedHeaderAnnotationTypes . clear ( ) ; } private void updateHeader ( ) { if ( fHeader == null || fHeader . isDisposed ( ) ) return ; Object colorType = null ; outer : for ( int i = fAnnotationsSortedByLayer . size ( ) - 1 ; i >= 0 ; i -- ) { Object annotationType = fAnnotationsSortedByLayer . get ( i ) ; if ( skipInHeader ( annotationType ) || skip ( annotationType ) ) continue ; for ( Iterator e = new FilterIterator ( annotationType , FilterIterator . PERSISTENT | FilterIterator . TEMPORARY | FilterIterator . IGNORE_BAGS ) ; e . hasNext ( ) ; ) { if ( e . next ( ) != null ) { colorType = annotationType ; break outer ; } } } Color color = null ; if ( colorType != null ) color = findColor ( colorType ) ; if ( color == null ) { if ( fHeaderPainter != null ) fHeaderPainter . setColor ( null ) ; } else { if ( fHeaderPainter == null ) { fHeaderPainter = new HeaderPainter ( ) ; fHeader . addPaintListener ( fHeaderPainter ) ; } fHeaderPainter . setColor ( color ) ; } fHeader . redraw ( ) ; updateHeaderToolTipText ( ) ; } private void updateHeaderToolTipText ( ) { if ( fHeader == null || fHeader . isDisposed ( ) ) return ; fHeader . setToolTipText ( null ) ; if ( ! ( fAnnotationAccess instanceof IAnnotationAccessExtension ) ) return ; String overview = "" ; for ( int i = fAnnotationsSortedByLayer . size ( ) - 1 ; i >= 0 ; i -- ) { Object annotationType = fAnnotationsSortedByLayer . get ( i ) ; if ( skipInHeader ( annotationType ) || skip ( annotationType ) ) continue ; int count = 0 ; String annotationTypeLabel = null ; for ( Iterator e = new FilterIterator ( annotationType , FilterIterator . PERSISTENT | FilterIterator . TEMPORARY | FilterIterator . IGNORE_BAGS ) ; e . hasNext ( ) ; ) { Annotation annotation = ( Annotation ) e . next ( ) ; if ( annotation != null ) { if ( annotationTypeLabel == null ) annotationTypeLabel = ( ( IAnnotationAccessExtension ) fAnnotationAccess ) . getTypeLabel ( annotation ) ; count ++ ; } } if ( annotationTypeLabel != null ) { if ( overview . length ( ) > 0 ) overview += "\n" ; overview += JFaceTextMessages . getFormattedString ( "OverviewRulerHeader.toolTipTextEntry" , new Object [ ] { annotationTypeLabel , new Integer ( count ) } ) ; } } if ( overview . length ( ) > 0 ) fHeader . setToolTipText ( overview ) ; } } 