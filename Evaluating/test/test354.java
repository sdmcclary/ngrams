public class GettextModule extends AbstractQuercusModule { private LruCache < Object , GettextResource > _cache = new LruCache < Object , GettextResource > ( 16 ) ; private final L10N L = new L10N ( GettextModule . class ) ; public String [ ] getLoadedExtensions ( ) { return new String [ ] { "gettext" } ; } public String bind_textdomain_codeset ( Env env , String domainName , String charset ) { getDomain ( env , domainName ) . setCharset ( charset ) ; return charset ; } public Value bindtextdomain ( Env env , String domainName , StringValue directory ) { GettextDomain domain = getDomain ( env , domainName ) ; domain . setPath ( env , directory ) ; if ( domain . getPath ( ) == null ) return BooleanValue . FALSE ; else return directory ; } public StringValue dcgettext ( Env env , String domainName , StringValue message , int category , Value args [ ] ) { return translate ( env , getDomain ( env , domainName ) , getCategory ( env , category ) , message , args ) ; } public StringValue dcngettext ( Env env , String domainName , StringValue msgid1 , StringValue msgid2 , int n , int category , Value args [ ] ) { return translate ( env , getDomain ( env , domainName ) , getCategory ( env , category ) , msgid1 , msgid2 , n , args ) ; } public StringValue dgettext ( Env env , String domainName , StringValue message , Value args [ ] ) { return translate ( env , getDomain ( env , domainName ) , "LC_MESSAGES" , message , args ) ; } public StringValue dngettext ( Env env , String domainName , StringValue msgid1 , StringValue msgid2 , int n , Value args [ ] ) { return translate ( env , getDomain ( env , domainName ) , "LC_MESSAGES" , msgid1 , msgid2 , n , args ) ; } public StringValue _ ( Env env , StringValue message , Value [ ] args ) { return gettext ( env , message , args ) ; } public StringValue gettext ( Env env , StringValue message , Value [ ] args ) { return translate ( env , getCurrentDomain ( env ) , "LC_MESSAGES" , message , args ) ; } public StringValue ngettext ( Env env , StringValue msgid1 , StringValue msgid2 , int n , Value args [ ] ) { return translate ( env , getCurrentDomain ( env ) , "LC_MESSAGES" , msgid1 , msgid2 , n , args ) ; } public String textdomain ( Env env , @ Optional Value domain ) { if ( ! domain . isNull ( ) ) { String name = domain . toString ( ) ; setCurrentDomain ( env , name ) ; return name ; } return getCurrentDomain ( env ) . getName ( ) ; } private StringValue translate ( Env env , GettextDomain domain , CharSequence category , StringValue message , Value [ ] args ) { Locale locale = env . getLocaleInfo ( ) . getMessages ( ) . getLocale ( ) ; GettextResource resource = getResource ( env , domain . getPath ( ) , locale , category , domain . getName ( ) ) ; StringValue unicodeTranslation = resource . getTranslation ( message ) ; if ( unicodeTranslation == null ) unicodeTranslation = message ; StringValue translation = message . create ( env , unicodeTranslation , domain . getCharset ( ) ) ; return format ( env , translation , args ) ; } private StringValue translate ( Env env , GettextDomain domain , CharSequence category , StringValue msgid1 , StringValue msgid2 , int quantity , Value [ ] args ) { Locale locale = env . getLocaleInfo ( ) . getMessages ( ) . getLocale ( ) ; GettextResource resource = getResource ( env , domain . getPath ( ) , locale , category , domain . getName ( ) ) ; StringValue unicodeTranslation = resource . getTranslation ( msgid1 , quantity ) ; if ( unicodeTranslation == null ) unicodeTranslation = errorReturn ( msgid1 , msgid2 , quantity ) ; StringValue translation = msgid1 . create ( env , unicodeTranslation , domain . getCharset ( ) ) ; return format ( env , translation , args ) ; } private GettextResource getResource ( Env env , Path path , Locale locale , CharSequence category , String domain ) { ArrayList < Object > key = new ArrayList < Object > ( ) ; key . add ( path . getFullPath ( ) ) ; key . add ( locale ) ; key . add ( category ) ; key . add ( domain ) ; GettextResource resource = _cache . get ( key ) ; if ( resource == null ) { resource = new GettextResource ( env , path , locale , category , domain ) ; _cache . put ( key , resource ) ; } return resource ; } private GettextDomainMap getDomains ( Env env ) { Object val = env . getSpecialValue ( "caucho.gettext_domains" ) ; if ( val == null ) { val = new GettextDomainMap ( ) ; env . setSpecialValue ( "caucho.gettext_domains" , val ) ; } return ( GettextDomainMap ) val ; } private GettextDomain getDomain ( Env env , String name ) { return getDomains ( env ) . getDomain ( env , name ) ; } private GettextDomain getCurrentDomain ( Env env ) { return getDomains ( env ) . getCurrent ( env ) ; } private void setCurrentDomain ( Env env , String name ) { getDomains ( env ) . setCurrent ( name ) ; } private String getCategory ( Env env , int category ) { switch ( category ) { case StringModule . LC_MESSAGES : return "LC_MESSAGES" ; case StringModule . LC_ALL : return "LC_ALL" ; case StringModule . LC_CTYPE : return "LC_CTYPE" ; case StringModule . LC_NUMERIC : return "LC_NUMERIC" ; case StringModule . LC_TIME : return "LC_TIME" ; case StringModule . LC_COLLATE : return "LC_COLLATE" ; case StringModule . LC_MONETARY : return "LC_MONETARY" ; default : env . warning ( L . l ( "Invalid category. Please use named constants" ) ) ; return "LC_MESSAGES" ; } } private static StringValue errorReturn ( StringValue msgid1 , StringValue msgid2 , int n ) { if ( n == 1 ) return msgid1 ; else return msgid2 ; } private static StringValue format ( Env env , StringValue msg , Value [ ] args ) { if ( args . length == 0 ) return msg ; StringValue sb ; if ( msg . isUnicode ( ) ) sb = env . createUnicodeBuilder ( ) ; else sb = env . createBinaryBuilder ( ) ; return formatImpl ( env , msg , args , sb ) ; } private static StringValue formatImpl ( Env env , StringValue msg , Value [ ] args , StringValue sb ) { int i = 0 ; int length = msg . length ( ) ; while ( i < length ) { char ch = msg . charAt ( i ) ; if ( ch != '[' || i + 4 > length ) { sb . append ( ch ) ; i ++ ; } else if ( msg . charAt ( i + 1 ) != '_' ) { sb . append ( ch ) ; i ++ ; } else if ( msg . charAt ( i + 3 ) != ']' ) { sb . append ( ch ) ; i ++ ; } else { ch = msg . charAt ( i + 2 ) ; int argIndex = ch - '0' ; if ( 0 <= argIndex && argIndex < args . length ) { sb . append ( args [ argIndex ] ) ; i += 4 ; } else { sb . append ( '[' ) ; i ++ ; } } } return sb ; } } 