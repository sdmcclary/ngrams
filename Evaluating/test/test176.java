public class ScriptEvaluatorManager { private static Map < String , ScriptEvaluator > evaluatorContexts = new HashMap < String , ScriptEvaluator > ( ) ; private static Map < String , Integer > evaluatorContextCounter = new HashMap < String , Integer > ( ) ; private static MappedSet < String , Object > objectsUsingEvaluator = new MappedSet < String , Object > ( ) ; private static Map < String , Map < String , Object > > maxObjectMap = new HashMap < String , Map < String , Object > > ( ) ; private static Constructor < ScriptEvaluator > evaluatorConstructor ; private static Map < Object , String [ ] > objectMetadata = new HashMap < Object , String [ ] > ( ) ; private ScriptEvaluatorManager ( ) { } public static ScriptEvaluator getRubyEvaluator ( String maxContext , String id , Object maxObject , CompatVersion rubyVersion ) { Map < String , Object > idMap = maxObjectMap . get ( maxContext ) ; if ( idMap == null ) { idMap = new HashMap < String , Object > ( ) ; maxObjectMap . put ( maxContext , idMap ) ; } else { ensureIdAvailable ( idMap , maxObject , id ) ; } idMap . put ( id , maxObject ) ; objectMetadata . put ( maxObject , new String [ ] { maxContext , id } ) ; String evaluatorContext = getEvaluatorContext ( maxContext , maxObject ) ; ScriptEvaluator evaluator = evaluatorContexts . get ( evaluatorContext ) ; if ( evaluator == null ) { evaluator = newRubyEvaluatorInstance ( rubyVersion ) ; evaluatorContexts . put ( evaluatorContext , evaluator ) ; evaluatorContextCounter . put ( evaluatorContext , 1 ) ; Set < Object > maxObjects = objectsUsingEvaluator . addValue ( evaluatorContext , maxObject ) ; evaluator . declareGlobal ( "max_objects" , maxObjects ) ; evaluator . declareGlobal ( "max_object_map" , maxObjectMap ) ; } else { int count = evaluatorContextCounter . get ( evaluatorContext ) ; count ++ ; evaluatorContextCounter . put ( evaluatorContext , count ) ; objectsUsingEvaluator . addValue ( evaluatorContext , maxObject ) ; } return evaluator ; } public static void removeRubyEvaluator ( Object maxObject ) { String [ ] contextAndId = objectMetadata . remove ( maxObject ) ; if ( contextAndId != null ) { String maxContext = contextAndId [ 0 ] ; String evaluatorContext = getEvaluatorContext ( maxContext , maxObject ) ; String id = contextAndId [ 1 ] ; int count = evaluatorContextCounter . get ( evaluatorContext ) ; count -- ; if ( count > 0 ) { evaluatorContextCounter . put ( evaluatorContext , count ++ ) ; objectsUsingEvaluator . get ( evaluatorContext ) . remove ( maxObject ) ; } else { notifyContextDestroyedListener ( maxContext , maxObject ) ; objectsUsingEvaluator . remove ( evaluatorContext ) ; evaluatorContextCounter . remove ( evaluatorContext ) ; evaluatorContexts . remove ( evaluatorContext ) ; } Map < String , Object > idMap = maxObjectMap . get ( maxContext ) ; idMap . remove ( id ) ; if ( idMap . isEmpty ( ) ) { maxObjectMap . remove ( maxContext ) ; } } } public static void updateId ( Object maxObject , String id ) { String [ ] contextAndId = objectMetadata . get ( maxObject ) ; if ( contextAndId != null ) { String maxContext = contextAndId [ 0 ] ; String oldId = contextAndId [ 1 ] ; Map < String , Object > idMap = maxObjectMap . get ( maxContext ) ; ensureIdAvailable ( idMap , maxObject , id ) ; idMap . remove ( oldId ) ; idMap . put ( id , maxObject ) ; contextAndId [ 1 ] = id ; } } private static void ensureIdAvailable ( Map < String , Object > idMap , Object maxObject , String id ) { Object existingObject = idMap . get ( id ) ; if ( existingObject != null && ! existingObject . equals ( maxObject ) ) { String base = id ; long index = 0 ; if ( id . matches ( ".*\\[\\d*\\]$" ) ) { int split = id . lastIndexOf ( '[' ) ; base = id . substring ( 0 , split ) ; String indexStr = id . substring ( split + 1 ) ; indexStr = indexStr . substring ( 0 , indexStr . length ( ) - 1 ) ; index = Long . parseLong ( indexStr ) ; } String suggest ; do { index ++ ; suggest = base + "[" + index + "]" ; } while ( idMap . containsKey ( suggest ) ) ; throw new IdInUseException ( suggest ) ; } } private static String getEvaluatorContext ( String maxContext , Object maxObject ) { if ( maxContext == null ) { return "__" + Integer . toHexString ( maxObject . hashCode ( ) ) ; } else { return maxContext ; } } public static void notifyContextDestroyedListener ( String maxContext , Object maxObject ) { String evaluatorContext = getEvaluatorContext ( maxContext , maxObject ) ; ScriptEvaluator ruby = evaluatorContexts . get ( evaluatorContext ) ; if ( ruby != null ) { ruby . exit ( ) ; } } private static ScriptEvaluator newRubyEvaluatorInstance ( CompatVersion rubyVersion ) { if ( evaluatorConstructor == null ) { String evaluatorClassName = RubyProperties . getRubyEngine ( ) ; try { @ SuppressWarnings ( "unchecked" ) Class < ScriptEvaluator > evaluatorClass = ( Class < ScriptEvaluator > ) Class . forName ( evaluatorClassName ) ; evaluatorConstructor = evaluatorClass . getConstructor ( CompatVersion . class ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } } try { return evaluatorConstructor . newInstance ( rubyVersion ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } } 