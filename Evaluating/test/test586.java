public class HTMLCodeFormatter extends BaseFormatter { private Stack tagNames = new Stack ( ) ; private Stack stillWrap = new Stack ( ) ; private HTMLCodeFormatterOptions codeoptions ; private boolean isSelfClosing ( int offset , LexemeList list ) { for ( int a = offset ; a < list . size ( ) ; a ++ ) { Lexeme lexeme = list . get ( a ) ; if ( lexeme . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . GREATER_THAN ) { return false ; } if ( lexeme . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . SLASH_GREATER_THAN ) { return true ; } } return false ; } boolean hasType ( LexemeList list , int offset , int tokenType ) { if ( list . size ( ) > offset ) { return list . get ( offset ) . getToken ( ) . getTypeIndex ( ) == tokenType ; } return false ; } private boolean isSmartNoWrap ( LexemeList lexemeList , int a , HTMLCodeFormatterOptions codeoptions2 ) { if ( codeoptions2 . doNotWrapSimple ) { if ( a > 0 ) { Lexeme fL = lexemeList . get ( a - 1 ) ; int typeIndex = fL . getToken ( ) . getTypeIndex ( ) ; if ( typeIndex == HTMLTokenTypes . END_TAG ) { return false ; } } else { return false ; } a ++ ; while ( a < lexemeList . size ( ) ) { Lexeme lexeme = lexemeList . get ( a ) ; int typeIndex = lexeme . getToken ( ) . getTypeIndex ( ) ; if ( typeIndex != HTMLTokenTypes . TEXT ) { if ( typeIndex == HTMLTokenTypes . END_TAG ) { return true ; } return false ; } a ++ ; } } return false ; } private String [ ] splitOnLines ( String comment ) { String [ ] result = null ; ArrayList lines = new ArrayList ( ) ; boolean lastSlash = false ; int lastPos = 0 ; for ( int a = 0 ; a < comment . length ( ) ; a ++ ) { char c = comment . charAt ( a ) ; if ( c == '\n' || c == '\r' ) { if ( ! lastSlash ) { lastSlash = true ; lines . add ( comment . substring ( lastPos , a ) ) ; lastPos = a + 1 ; } continue ; } lastSlash = false ; } lines . add ( comment . substring ( lastPos , comment . length ( ) ) ) ; result = new String [ lines . size ( ) ] ; lines . toArray ( result ) ; return result ; } public String getCurrentIndentationString ( String string ) { int pos = string . length ( ) ; int startLine = 0 ; for ( int a = string . length ( ) - 1 ; a >= 0 ; a -- ) { char charAt = string . charAt ( a ) ; if ( charAt == '\n' || charAt == '\r' ) { startLine = a + 1 ; break ; } if ( ! Character . isWhitespace ( charAt ) ) { pos = a ; } } if ( string . length ( ) == 0 ) { return "" ; } return string . substring ( startLine , pos ) ; } public String format ( String notFormatted , boolean isSelection , Map options , IProject project , String linedelimeters ) { String doc = null ; doc = notFormatted ; level = 0 ; tagNames . clear ( ) ; try { IParser parser = LanguageRegistry . getParser ( HTMLMimeType . MimeType ) ; HTMLParseState createParseState = ( HTMLParseState ) parser . createParseState ( null ) ; createParseState . setEditState ( doc , doc , 0 , 0 ) ; parser . parse ( createParseState ) ; LexemeList lexemeList = createParseState . getLexemeList ( ) ; Stack clevel = new Stack ( ) ; HashSet notClosed = new HashSet ( ) ; for ( int a = 0 ; a < lexemeList . size ( ) ; a ++ ) { Lexeme lexeme = lexemeList . get ( a ) ; if ( lexeme . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . START_TAG ) { if ( ! isSelfClosing ( a , lexemeList ) ) { clevel . push ( lexeme ) ; } } if ( lexeme . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . END_TAG ) { if ( ! clevel . isEmpty ( ) ) { Lexeme lex = ( Lexeme ) clevel . pop ( ) ; String ltagName = lex . getText ( ) . substring ( 1 ) ; String ktagName = lexeme . getText ( ) . substring ( 2 ) ; if ( ! ltagName . equals ( ktagName ) ) { clevel . push ( lex ) ; notClosed . add ( lex ) ; } } } } codeoptions = new HTMLCodeFormatterOptions ( options , project ) ; if ( ! codeoptions . doFormatting ) { return notFormatted ; } String indent = codeoptions . formatterTabChar ; if ( indent . length ( ) == 0 ) { indent = " " ; } if ( indent . charAt ( 0 ) == ' ' ) { StringBuffer bf = new StringBuffer ( ) ; for ( int a = 0 ; a < codeoptions . tabSize ; a ++ ) { bf . append ( ' ' ) ; } indent = bf . toString ( ) ; } SourceWriter buf = new SourceWriter ( 0 , indent , codeoptions . tabSize ) ; if ( linedelimeters != null ) { buf . setLineDelimeter ( linedelimeters ) ; } boolean inOtherLanguage = false ; int startOtherLanguage = - 1 ; String language = null ; boolean isInAttr = false ; boolean isSelfClosing = false ; int quoteStart = 0 ; boolean printLine = false ; boolean lastTextEndsWithSpace = false ; boolean inQuote = false ; boolean isInPre = false ; boolean inConditional = false ; boolean isSmartNoWrap = false ; int prePositon = - 1 ; boolean lastError = false ; boolean isInTag = false ; int preCount = 0 ; String tString = null ; int htmlPosition = - 1 ; String lastTagName = "" ; String realLastTagName = "" ; for ( int a = 0 ; a < lexemeList . size ( ) ; a ++ ) { Lexeme lexeme = lexemeList . get ( a ) ; int i = lexeme . getStartingOffset ( ) - 1 ; int typeIndex = lexeme . getToken ( ) . getTypeIndex ( ) ; if ( inOtherLanguage && lexeme . getLanguage ( ) . equals ( HTMLMimeType . MimeType ) ) { inOtherLanguage = false ; String substring = doc . substring ( startOtherLanguage , lexeme . getStartingOffset ( ) ) ; if ( ! isInAttr ) { formatAnotherLanguage ( isSelection , options , project , linedelimeters , buf , language , substring ) ; if ( tString != null ) { buf . print ( tString ) ; tString = null ; } } } if ( isInPre ) { if ( typeIndex == HTMLTokenTypes . START_TAG ) { String tagName = lexeme . getText ( ) . substring ( 1 ) . trim ( ) ; if ( tagName . equals ( "pre" ) ) { preCount ++ ; } continue ; } if ( typeIndex == HTMLTokenTypes . END_TAG ) { String tagName = lexeme . getText ( ) . substring ( 2 ) . trim ( ) ; if ( tagName . equals ( "pre" ) ) { if ( preCount == 0 ) { if ( buf . getCurrentIndentLevel ( ) == 0 ) { buf . printIndent ( ) ; } buf . print ( notFormatted . substring ( prePositon , lexeme . getStartingOffset ( ) ) ) ; isInPre = false ; buf . print ( lexeme . getText ( ) ) ; } else { preCount -- ; } continue ; } continue ; } else { continue ; } } if ( ! lexeme . getLanguage ( ) . equals ( HTMLMimeType . MimeType ) ) { if ( ! inOtherLanguage ) { if ( ! codeoptions . doFormatting ) { String txt = notFormatted . substring ( htmlPosition , lexeme . getStartingOffset ( ) ) ; tString = getCurrentIndentationString ( txt ) ; buf . print ( txt ) ; htmlPosition = - 1 ; } inOtherLanguage = true ; Lexeme previous = a > 0 ? lexemeList . get ( a - 1 ) : null ; isInAttr = previous != null ? ( previous . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . QUOTE ) : false ; if ( previous != null ) { startOtherLanguage = previous . getEndingOffset ( ) ; } else { startOtherLanguage = lexeme . getStartingOffset ( ) ; } language = lexeme . getLanguage ( ) ; continue ; } else { continue ; } } if ( typeIndex == HTMLTokenTypes . PI_TEXT ) { if ( ! isInAttr ) { formatAnotherLanguage ( false , options , project , linedelimeters , buf , "text/php" , lexeme . getText ( ) ) ; } htmlPosition = - 1 ; continue ; } if ( ! codeoptions . doFormatting ) { if ( htmlPosition == - 1 ) { htmlPosition = lexeme . getStartingOffset ( ) ; } continue ; } if ( typeIndex == HTMLTokenTypes . PI_OPEN ) { int iLevel = buf . getCurrentIndentLevel ( ) ; if ( iLevel != 0 ) { buf . println ( ) ; } buf . printIndent ( ) ; buf . print ( lexeme . getText ( ) ) ; continue ; } if ( typeIndex == HTMLTokenTypes . QUESTION_GREATER_THAN ) { if ( buf . getCurrentIndentLevel ( ) == 0 ) { buf . printIndent ( ) ; } buf . print ( lexeme . getText ( ) ) ; buf . println ( ) ; continue ; } if ( typeIndex == HTMLTokenTypes . ERROR || typeIndex == HTMLTokenTypes . STRING && lexeme . getCategoryIndex ( ) == HTMLTokenTypes . ERROR ) { if ( lexeme . getText ( ) . equals ( "<![endif]" ) ) { buf . print ( lexeme . getText ( ) ) ; inConditional = true ; buf . decreaseIndent ( ) ; continue ; } if ( inConditional ) { if ( lexeme . getText ( ) . endsWith ( "]" ) ) { buf . print ( lexeme . getText ( ) ) ; inConditional = false ; continue ; } } if ( lexeme . getText ( ) . startsWith ( "<![if" ) ) { buf . print ( lexeme . getText ( ) ) ; buf . increaseIndent ( ) ; continue ; } if ( a > 0 ) { Lexeme pl = lexemeList . get ( a - 1 ) ; String substring = notFormatted . substring ( pl . getEndingOffset ( ) , lexeme . getStartingOffset ( ) ) ; if ( substring . length ( ) > 0 ) { if ( substring . contains ( "\r" ) || substring . contains ( "\n" ) ) { buf . println ( ) ; } else if ( substring . contains ( " " ) || substring . contains ( "\t" ) ) { buf . print ( ' ' ) ; } } } if ( ! isInTag ) { if ( ! codeoptions . notWrappingTags . contains ( lastTagName ) ) { if ( buf . getCurrentIndentLevel ( ) != 0 ) { buf . println ( ) ; } buf . printIndent ( ) ; } } lastError = true ; buf . print ( lexeme . getText ( ) ) ; if ( a < lexemeList . size ( ) - 1 ) { Lexeme l1 = lexemeList . get ( a + 1 ) ; if ( l1 . getLanguage ( ) . equals ( HTMLMimeType . MimeType ) && l1 . typeIndex != HTMLTokenTypes . ERROR ) { String substring = notFormatted . substring ( lexeme . getEndingOffset ( ) , l1 . getStartingOffset ( ) ) ; if ( substring . length ( ) > 0 ) { if ( substring . contains ( "\r" ) || substring . contains ( "\n" ) ) { buf . println ( ) ; } else if ( substring . contains ( " " ) || substring . contains ( "\t" ) ) { buf . print ( ' ' ) ; } } } } if ( ! isInTag ) { if ( ! codeoptions . notWrappingTags . contains ( lastTagName ) ) { if ( a < lexemeList . size ( ) - 1 && lexemeList . get ( a + 1 ) . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . ERROR ) { continue ; } else { buf . println ( ) ; } } else { if ( a < lexemeList . size ( ) - 1 && lexemeList . get ( a + 1 ) . getToken ( ) . getTypeIndex ( ) != HTMLTokenTypes . ERROR ) { buf . print ( ' ' ) ; } } } continue ; } lastError = false ; if ( typeIndex == HTMLTokenTypes . COMMENT ) { appendComment ( lexemeList , codeoptions , buf , a , lexeme ) ; continue ; } if ( typeIndex == HTMLTokenTypes . TEXT ) { if ( lexeme . getText ( ) . startsWith ( "<![endif]>" ) ) { buf . print ( lexeme . getText ( ) ) ; inConditional = true ; buf . decreaseIndent ( ) ; continue ; } if ( inConditional ) { if ( lexeme . getText ( ) . endsWith ( "]" ) ) { buf . print ( lexeme . getText ( ) ) ; inConditional = false ; continue ; } } if ( lexeme . getText ( ) . startsWith ( "<![if" ) ) { buf . print ( lexeme . getText ( ) ) ; buf . increaseIndent ( ) ; continue ; } String [ ] splitOnLines = splitOnLines ( lexeme . getText ( ) ) ; boolean hasNotEmpty = false ; ArrayList withoutEmpty = new ArrayList ( ) ; boolean lastHasSpace = false ; if ( isSmartNoWrap ) { if ( splitOnLines . length == 1 ) { buf . print ( splitOnLines [ 0 ] ) ; continue ; } if ( splitOnLines . length == 2 && splitOnLines [ 1 ] . trim ( ) . length ( ) == 0 ) { buf . print ( splitOnLines [ 0 ] ) ; continue ; } } for ( int b = 0 ; b < splitOnLines . length ; b ++ ) { String string = splitOnLines [ b ] ; String text = string . trim ( ) ; boolean hasSpace = false ; for ( int j = string . length ( ) - 1 ; j > 0 ; j -- ) { char c = string . charAt ( j ) ; if ( c == ' ' || c == '\t' ) { hasSpace = true ; } if ( ! Character . isWhitespace ( c ) ) { break ; } } if ( hasSpace ) { String trim = text . trim ( ) ; int length = trim . length ( ) ; if ( length > 0 ) { text = text + ' ' ; } if ( lastHasSpace ) { hasSpace = false ; } if ( hasSpace ) { if ( ! withoutEmpty . isEmpty ( ) ) { String last = ( String ) withoutEmpty . get ( withoutEmpty . size ( ) - 1 ) ; if ( length > 0 ) { last = last + ' ' ; } withoutEmpty . set ( withoutEmpty . size ( ) - 1 , last ) ; } } } if ( text . length ( ) > 0 ) { if ( ! hasNotEmpty ) { if ( ! lastTextEndsWithSpace ) { if ( buf . getCurrentIndentLevel ( ) != 0 ) { if ( Character . isWhitespace ( string . charAt ( 0 ) ) ) { text = ' ' + text ; } } } } withoutEmpty . add ( text ) ; hasNotEmpty = true ; } lastHasSpace = hasSpace ; } lastTextEndsWithSpace = lastHasSpace ; splitOnLines = new String [ withoutEmpty . size ( ) ] ; withoutEmpty . toArray ( splitOnLines ) ; if ( ! hasNotEmpty ) { continue ; } boolean nextIndent = true ; if ( buf . getCurrentIndentLevel ( ) == 0 ) { buf . printIndent ( ) ; nextIndent = false ; } if ( splitOnLines [ 0 ] . length ( ) > 0 ) { buf . print ( splitOnLines [ 0 ] ) ; if ( splitOnLines . length > 1 ) { buf . println ( ) ; buf . printIndent ( ) ; nextIndent = false ; } } for ( int b = 1 ; b < splitOnLines . length ; b ++ ) { String text = splitOnLines [ b ] ; if ( text . length ( ) == 0 ) { nextIndent = false ; continue ; } if ( nextIndent || buf . getCurrentIndentLevel ( ) == 0 ) { buf . printIndent ( ) ; } if ( b == splitOnLines . length - 1 ) { boolean needContinue = false ; needContinue = shouldInsertNewLine ( lexemeList , codeoptions , a , needContinue ) ; if ( needContinue ) { buf . print ( text ) ; continue ; } } buf . println ( text ) ; nextIndent = true ; } continue ; } if ( typeIndex == HTMLTokenTypes . PERCENT_TEXT ) { appendPercentText ( lexemeList , codeoptions , buf , a , lexeme ) ; continue ; } if ( typeIndex == HTMLTokenTypes . GREATER_THAN ) { buf . print ( '>' ) ; boolean keepWithNext = false ; if ( ! isInTag && a + 1 < lexemeList . size ( ) ) { Lexeme next = lexemeList . get ( a + 1 ) ; if ( next != null && isLexemeOfType ( next , HTMLTokenTypes . TEXT ) && ( ! next . getText ( ) . startsWith ( " " ) && ! next . getText ( ) . startsWith ( "\t" ) && ! next . getText ( ) . startsWith ( "\r" ) && ! next . getText ( ) . startsWith ( "\n" ) ) ) { keepWithNext = true ; } } if ( isInTag && a + 1 < lexemeList . size ( ) ) { Lexeme next = lexemeList . get ( a + 1 ) ; keepWithNext = switchingLanguages ( lexeme , next ) ; } boolean wrapContent = ! codeoptions . notWrappingTags . contains ( lastTagName ) ; boolean alwaysWrapAfterwards = codeoptions . allwaysWrap . contains ( realLastTagName ) ; isSmartNoWrap = isSmartNoWrap ( lexemeList , a , codeoptions ) ; if ( ! isSmartNoWrap ) { if ( ( wrapContent || printLine ) && ! keepWithNext ) { if ( ! isSelfClosing || alwaysWrapAfterwards ) { buf . println ( ) ; } } else if ( alwaysWrapAfterwards ) { buf . println ( ) ; stillWrap . push ( this ) ; } } isInTag = false ; continue ; } if ( typeIndex == HTMLTokenTypes . SLASH_GREATER_THAN ) { checkPreviousTrail ( notFormatted , lexemeList , buf , a , lexeme ) ; buf . print ( '/' ) ; buf . print ( '>' ) ; if ( codeoptions . allwaysWrap . contains ( realLastTagName ) ) { if ( stillWrap . size ( ) > 0 ) { stillWrap . pop ( ) ; } stillWrap . push ( this ) ; buf . println ( ) ; } isInTag = false ; continue ; } if ( typeIndex == HTMLTokenTypes . START_TAG ) { isInTag = true ; String tagName = lexeme . getText ( ) . substring ( 1 ) . trim ( ) . toLowerCase ( ) ; int iL = buf . getCurrentIndentLevel ( ) ; if ( tagName . equals ( "pre" ) ) { isInPre = true ; prePositon = lexeme . getStartingOffset ( ) ; if ( iL == 0 ) { buf . printIndent ( ) ; } continue ; } realLastTagName = tagName ; boolean selfClosing = isSelfClosing ( a , lexemeList ) ; isSelfClosing = selfClosing ; boolean wrap = ! codeoptions . notWrappingTags . contains ( tagName ) && ! selfClosing && ! createParseState . isEmptyTagType ( tagName ) ; wrap |= codeoptions . allwaysWrap . contains ( tagName ) ; if ( wrap ) { if ( iL != 0 ) { buf . println ( ) ; iL = 0 ; } } if ( iL == 0 ) { buf . printIndent ( ) ; } buf . print ( lexeme . getText ( ) ) ; if ( ! selfClosing ) { if ( ! createParseState . isEmptyTagType ( tagName ) ) { if ( ! notClosed . contains ( lexeme ) ) { if ( ! codeoptions . doNotIndent . contains ( realLastTagName ) ) { buf . increaseIndent ( ) ; } tagNames . push ( lastTagName ) ; stillWrap . push ( null ) ; lastTagName = tagName ; } } else { isSelfClosing = true ; } } printLine = false ; continue ; } else if ( typeIndex == HTMLTokenTypes . END_TAG ) { String pTag = lastTagName ; int iLevel = buf . getCurrentIndentLevel ( ) ; String tagName = lexeme . getText ( ) . substring ( 2 ) . trim ( ) . toLowerCase ( ) ; boolean isBroken = ! ( pTag . equals ( tagName ) || pTag . length ( ) == 0 ) ; lastTagName = tagName ; boolean contains = codeoptions . notWrappingTags . contains ( tagName ) ; contains &= ( stillWrap . size ( ) == 0 || stillWrap . peek ( ) == null ) ; if ( iLevel != 0 ) { if ( ! contains || printLine ) { if ( ! isSmartNoWrap ) { buf . println ( ) ; iLevel = 0 ; } } } printLine = isSmartNoWrap ; if ( ! createParseState . isEmptyTagType ( tagName ) ) { if ( ! isBroken ) { if ( ! codeoptions . doNotIndent . contains ( pTag ) ) { buf . decreaseIndent ( ) ; } } } if ( iLevel == 0 ) { buf . printIndent ( ) ; } buf . print ( lexeme . getText ( ) ) ; if ( ! tagNames . isEmpty ( ) && ! isBroken ) { lastTagName = ( String ) tagNames . pop ( ) ; if ( ! stillWrap . isEmpty ( ) ) { stillWrap . pop ( ) ; } boolean lastNotWrap = codeoptions . notWrappingTags . contains ( lastTagName ) ; if ( lastNotWrap && ! contains ) { printLine = true ; } else if ( isSmartNoWrap && tagName . length ( ) >= 0 ) { printLine = codeoptions . notWrappingTags . contains ( ( String ) tagNames . peek ( ) ) ; } } else { lastTagName = "" ; } isSmartNoWrap = false ; continue ; } else if ( typeIndex == HTMLTokenTypes . PERCENT_OPEN ) { if ( buf . getCurrentIndentLevel ( ) == 0 ) { buf . printIndent ( ) ; } buf . print ( lexeme . getText ( ) ) ; if ( notFormatted . length ( ) > lexeme . getEndingOffset ( ) ) { char charAt = notFormatted . charAt ( lexeme . getEndingOffset ( ) ) ; if ( Character . isWhitespace ( charAt ) ) { buf . print ( charAt ) ; } } continue ; } else if ( typeIndex == HTMLTokenTypes . CDATA_START ) { buf . print ( lexeme . getText ( ) ) ; continue ; } else if ( typeIndex == HTMLTokenTypes . CDATA_END ) { buf . print ( lexeme . getText ( ) ) ; continue ; } else if ( typeIndex == HTMLTokenTypes . PERCENT_GREATER ) { buf . print ( ' ' ) ; buf . print ( lexeme . getText ( ) ) ; int pos = lexeme . getEndingOffset ( ) ; while ( pos < notFormatted . length ( ) ) { char charAt = notFormatted . charAt ( pos ) ; if ( ! Character . isWhitespace ( charAt ) ) { break ; } if ( charAt == '\r' || charAt == '\n' ) { buf . println ( ) ; break ; } pos ++ ; } continue ; } else if ( typeIndex == HTMLTokenTypes . QUOTE ) { if ( isInAttr ) { isInAttr = false ; } inQuote = ! inQuote ; if ( inQuote ) { quoteStart = lexeme . getEndingOffset ( ) ; } if ( ! inQuote ) { buf . print ( notFormatted . substring ( quoteStart , lexeme . getStartingOffset ( ) ) ) ; } buf . print ( lexeme . getText ( ) ) ; continue ; } else if ( i > 0 ) { char charAt = doc . charAt ( i ) ; if ( Character . isWhitespace ( charAt ) ) { buf . print ( ' ' ) ; } } buf . print ( lexeme . getText ( ) ) ; } if ( isInPre ) { String substring = doc . substring ( prePositon , doc . length ( ) ) ; buf . print ( substring ) ; } if ( inOtherLanguage ) { String substring = doc . substring ( startOtherLanguage , doc . length ( ) ) ; if ( ! isInAttr ) { formatAnotherLanguage ( isSelection , options , project , linedelimeters , buf , language , substring ) ; } } if ( ! codeoptions . doFormatting ) { if ( htmlPosition != - 1 ) { String substring = doc . substring ( htmlPosition , doc . length ( ) ) ; buf . print ( substring ) ; } } String end = buf . toString ( ) ; if ( ! isFormattingCorrect ( lexemeList , parser , notFormatted , end , new int [ ] { HTMLTokenTypes . TEXT } , new int [ ] { HTMLTokenTypes . TEXT } ) ) { end = notFormatted ; } return end ; } catch ( Exception e ) { IdeLog . logError ( HTMLPlugin . getDefault ( ) , "Unable to format code" , e ) ; return notFormatted ; } } private void checkPreviousTrail ( String notFormatted , LexemeList lexemeList , SourceWriter buf , int a , Lexeme lexeme ) { if ( a > 0 ) { Lexeme prev = lexemeList . get ( a - 1 ) ; if ( prev . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . STRING ) { if ( ! Character . isWhitespace ( buf . getBuffer ( ) . charAt ( buf . getBuffer ( ) . length ( ) - 1 ) ) ) { if ( Character . isWhitespace ( notFormatted . charAt ( lexeme . offset - 1 ) ) ) { buf . print ( ' ' ) ; } } } } } private boolean switchingLanguages ( Lexeme lexeme , Lexeme next ) { return next != null && ! lexeme . getLanguage ( ) . equals ( next . getLanguage ( ) ) ; } private void appendPercentText ( LexemeList lexemeList , HTMLCodeFormatterOptions codeoptions , SourceWriter buf , int a , Lexeme lexeme ) { ArrayList withoutEmpty = new ArrayList ( ) ; String [ ] splitOnLines = splitOnLines ( lexeme . getText ( ) ) ; for ( int b = 0 ; b < splitOnLines . length ; b ++ ) { String string = splitOnLines [ b ] ; String text = string . trim ( ) ; if ( text . length ( ) > 0 ) { withoutEmpty . add ( text ) ; } } splitOnLines = new String [ withoutEmpty . size ( ) ] ; withoutEmpty . toArray ( splitOnLines ) ; if ( buf . getCurrentIndentLevel ( ) == 0 ) { buf . printIndent ( ) ; } if ( splitOnLines [ 0 ] . length ( ) > 0 ) { buf . print ( splitOnLines [ 0 ] ) ; if ( splitOnLines . length > 1 ) { buf . println ( ) ; buf . printIndent ( ) ; } } for ( int b = 1 ; b < splitOnLines . length ; b ++ ) { String text = splitOnLines [ b ] . trim ( ) ; if ( text . length ( ) == 0 ) { continue ; } if ( b == splitOnLines . length - 1 ) { boolean needContinue = false ; needContinue = shouldInsertNewLine ( lexemeList , codeoptions , a , needContinue ) ; if ( needContinue ) { buf . print ( text ) ; continue ; } } if ( b != splitOnLines . length - 1 ) { buf . println ( text ) ; buf . printIndent ( ) ; } else { buf . print ( text ) ; } } } int level = 0 ; private void appendComment ( LexemeList lexemeList , HTMLCodeFormatterOptions codeoptions , SourceWriter buf , int a , Lexeme lexeme ) { String [ ] splitOnLines = splitOnLines ( lexeme . getText ( ) ) ; for ( int b = 0 ; b < splitOnLines . length ; b ++ ) { String text = splitOnLines [ b ] . trim ( ) ; if ( text . length ( ) == 0 ) { continue ; } int eif = countConditionalEnd ( text ) ; int iif = countConditionalStart ( text ) ; int delta = iif - eif ; for ( int i = delta ; i < 0 ; i ++ ) { if ( level > 0 ) { buf . decreaseIndent ( ) ; } level -- ; } if ( delta != 0 && buf . getCurrentIndentLevel ( ) != 0 && b == 0 ) { buf . println ( ) ; } if ( buf . getCurrentIndentLevel ( ) == 0 ) { buf . printIndent ( ) ; } for ( int i = 0 ; i < delta ; i ++ ) { level ++ ; buf . increaseIndent ( ) ; } if ( b == splitOnLines . length - 1 ) { boolean needContinue = false ; needContinue = shouldInsertNewLine ( lexemeList , codeoptions , a , needContinue ) ; if ( needContinue ) { buf . print ( text ) ; continue ; } } buf . println ( text ) ; } } private int countConditionalStart ( String text ) { int count = 0 ; int indexOf = text . indexOf ( "[if" ) ; while ( indexOf != - 1 ) { boolean shouldInd = isTrueConditional ( text , indexOf ) ; if ( shouldInd ) { count ++ ; } indexOf = text . indexOf ( "[if" , indexOf + 3 ) ; } return count ; } private boolean isTrueConditional ( String text , int indexOf ) { boolean shouldInd = false ; for ( int i = indexOf - 1 ; i > 0 ; i -- ) { char c = text . charAt ( i ) ; if ( c == '!' ) { if ( i > 0 ) { if ( text . charAt ( i - 1 ) != '<' ) { shouldInd = false ; } else { shouldInd = true ; } } break ; } if ( c == '<' ) { if ( text . charAt ( i + 1 ) == '[' ) { shouldInd = true ; break ; } } if ( c != '-' ) { shouldInd = false ; break ; } } return shouldInd ; } private int countConditionalEnd ( String text ) { int count = 0 ; int indexOf = text . indexOf ( "[endif]" ) ; while ( indexOf != - 1 ) { boolean shouldInd = isTrueConditional ( text , indexOf ) ; if ( shouldInd ) { count ++ ; } indexOf = text . indexOf ( "[endif]" , indexOf + 3 ) ; } return count ; } private boolean shouldInsertNewLine ( LexemeList lexemeList , HTMLCodeFormatterOptions codeoptions , int a , boolean needContinue ) { int ii = a + 1 ; while ( ii < lexemeList . size ( ) ) { Lexeme lexeme2 = lexemeList . get ( ii ) ; if ( lexeme2 . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . START_TAG ) { String tagName = lexeme2 . getText ( ) . substring ( 1 ) . trim ( ) ; if ( codeoptions . notWrappingTags . contains ( tagName . toLowerCase ( ) ) || isSelfClosing ( a + 1 , lexemeList ) ) { needContinue = true ; break ; } } if ( lexeme2 . getToken ( ) . getTypeIndex ( ) == HTMLTokenTypes . END_TAG ) { String tagName = lexeme2 . getText ( ) . substring ( 2 ) . trim ( ) ; if ( codeoptions . notWrappingTags . contains ( tagName . toLowerCase ( ) ) || isSelfClosing ( a + 1 , lexemeList ) ) { needContinue = true ; break ; } } ii ++ ; } return needContinue ; } private void formatAnotherLanguage ( boolean isSelection , Map options , IProject project , String linedelimeters , SourceWriter buf , String language , String substring ) { ICodeFormatter formatter = LanguageRegistry . getCodeFormatter ( language ) ; if ( formatter != null ) { String formatted = formatter . format ( substring , isSelection , options , project , linedelimeters ) ; formatted = normalizeCarriageReturns ( formatted ) ; String [ ] splitOnLines = formatted . split ( "\n" , - 1 ) ; if ( splitOnLines . length == 1 ) { buf . print ( splitOnLines [ 0 ] ) ; } else { if ( splitOnLines [ 0 ] . length ( ) > 0 ) { if ( ! Character . isWhitespace ( splitOnLines [ 0 ] . charAt ( 0 ) ) ) { buf . println ( ) ; buf . printIndent ( ) ; } } buf . println ( splitOnLines [ 0 ] ) ; for ( int b = 1 ; b < splitOnLines . length - 1 ; b ++ ) { if ( b == splitOnLines . length - 1 && splitOnLines [ b ] . trim ( ) . length ( ) == 0 ) { continue ; } buf . printlnWithIndent ( splitOnLines [ b ] ) ; } if ( splitOnLines . length >= 2 && ! splitOnLines [ splitOnLines . length - 1 ] . equals ( "" ) ) { buf . printlnWithIndent ( splitOnLines [ splitOnLines . length - 1 ] ) ; } } } else { buf . print ( substring ) ; } } public boolean handlesNested ( ) { return true ; } public String createNestedMark ( ) { return "nested" + System . currentTimeMillis ( ) ; } } 