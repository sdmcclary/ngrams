<<<<<<< HEAD
public class AptanaTextSearchPage extends TextSearchPage { public static final String EXTENSION_POINT_ID = "com.aptana.ide.search.epl.internal.ui.text.TextSearchPage" ; private class ScopeSelectionListener implements SelectionListener { public void widgetDefaultSelected ( SelectionEvent e ) { } public void widgetSelected ( SelectionEvent e ) { if ( ! AptanaTextSearchPage . this . firstOpen ) { return ; } Widget widget = e . widget ; if ( widget != null ) { Object data = widget . getData ( ) ; if ( data != null && data instanceof Integer ) { scope = ( ( Integer ) data ) . intValue ( ) ; } } } } private static final int DIRECTORY_SCOPE = 12 ; private static final int OPEN_FILES_SCOPE = 13 ; private ScopeSelectionListener scopeSelectionListener = new ScopeSelectionListener ( ) ; private static final String PAGE_NAME = "TextSearchPage" ; private static final String STORE_SEARCH_DIRECTORY = "SEARCH_DIRECTORY" ; private static final String SEARCH_SCOPE = "SEARCH_SCOPE" ; private ISearchPageContainer fContainer ; private Text fDirectory ; private Button fSearchInDirectory ; private Button fSearchInOpenFiles ; private String fSearchDirectory ; private int scope ; private boolean firstOpen ; public static class TextSearchPageInput extends TextSearchInput { private final String fSearchText ; private final boolean fIsCaseSensitive ; private final boolean fIsRegEx ; private final FileTextSearchScope fScope ; private final boolean isDirectory ; private final String directory ; private final boolean isOpenFiles ; private boolean fIsIgnoreLineEndings ; public boolean doRefresh ; public boolean isDirectory ( ) { return this . isDirectory ; } public String getDirectory ( ) { return this . directory ; } public boolean isIgnoreLineEndings ( ) { return fIsIgnoreLineEndings ; } public boolean isOpenFiles ( ) { return this . isOpenFiles ; } public TextSearchPageInput ( String searchText , boolean isCaseSensitive , boolean isRegEx , FileTextSearchScope scope , boolean isDir , String directory , boolean openFiles , boolean isIgnoreLineEndings ) { this . fSearchText = searchText ; this . isDirectory = isDir ; this . directory = directory ; this . isOpenFiles = openFiles ; this . fIsCaseSensitive = isCaseSensitive ; this . fIsRegEx = isRegEx ; this . fScope = scope ; this . fIsIgnoreLineEndings = isIgnoreLineEndings ; } public String getSearchText ( ) { return this . fSearchText ; } public boolean isCaseSensitiveSearch ( ) { return this . fIsCaseSensitive ; } public boolean isRegExSearch ( ) { return this . fIsRegEx ; } public FileTextSearchScope getScope ( ) { return this . fScope ; } public boolean isRefresh ( ) { return doRefresh ; } } private ISearchQuery newTextQuery ( ) throws CoreException { Method method ; try { method = TextSearchPage . class . getDeclaredMethod ( "newQuery" , ( Class [ ] ) null ) ; method . setAccessible ( true ) ; org . eclipse . search . internal . ui . text . FileSearchQuery query = ( org . eclipse . search . internal . ui . text . FileSearchQuery ) method . invoke ( this , ( Object [ ] ) null ) ; TextSearchPageInput input = new TextSearchPageInput ( query . getSearchString ( ) , query . isCaseSensitive ( ) , query . isRegexSearch ( ) , query . getSearchScope ( ) , isSearchingInDirectory ( ) , getDirectoryText ( ) , isSearchingInOpenFiles ( ) , false ) ; return ( new AptanaTextSearchQueryProvider ( ) ) . createQuery ( input ) ; } catch ( Exception e ) { } return null ; } public boolean performAction ( ) { try { NewSearchUI . runQueryInBackground ( newTextQuery ( ) ) ; } catch ( CoreException e ) { ErrorDialog . openError ( this . getShell ( ) , SearchMessages . TextSearchPage_replace_searchproblems_title , SearchMessages . TextSearchPage_replace_searchproblems_message , e . getStatus ( ) ) ; return false ; } return true ; } public boolean performReplace ( ) { try { IStatus status = NewSearchUI . runQueryInForeground ( getContainer ( ) . getRunnableContext ( ) , newTextQuery ( ) ) ; if ( status . matches ( IStatus . CANCEL ) ) { return false ; } if ( ! status . isOK ( ) ) { ErrorDialog . openError ( getShell ( ) , SearchMessages . TextSearchPage_replace_searchproblems_title , SearchMessages . TextSearchPage_replace_runproblem_message , status ) ; } Display . getCurrent ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { ISearchResultViewPart view = NewSearchUI . activateSearchResultView ( ) ; if ( view != null ) { ISearchResultPage page = view . getActivePage ( ) ; if ( page instanceof FileSearchPage ) { FileSearchPage filePage = ( FileSearchPage ) page ; new ReplaceAction ( filePage . getSite ( ) . getShell ( ) , ( FileSearchResult ) filePage . getInput ( ) , null , true ) . run ( ) ; } else if ( page instanceof FileSystemSearchPage ) { FileSystemSearchPage filePage = ( FileSystemSearchPage ) page ; new FileSystemReplaceAction ( filePage . getSite ( ) . getShell ( ) , ( FileSystemSearchResult ) filePage . getInput ( ) , null , true ) . run ( ) ; } } } } ) ; return true ; } catch ( CoreException e ) { ErrorDialog . openError ( getShell ( ) , SearchMessages . TextSearchPage_replace_searchproblems_title , SearchMessages . TextSearchPage_replace_querycreationproblem_message , e . getStatus ( ) ) ; return false ; } } private boolean isSearchingInOpenFiles ( ) { if ( fSearchInOpenFiles == null ) { IdeLog . logError ( Activator . getDefault ( ) , "Search in open files is null" ) ; return false ; } return fSearchInOpenFiles . getSelection ( ) ; } private String getDirectoryText ( ) { return fDirectory . getText ( ) ; } private boolean isSearchingInDirectory ( ) { if ( fSearchInDirectory == null ) { IdeLog . logError ( Activator . getDefault ( ) , "Search in directory is null" ) ; return false ; } return this . fSearchInDirectory . getSelection ( ) ; } public void createControl ( final Composite parent ) { super . createControl ( parent ) ; readConfiguration ( ) ; final Composite result = ( Composite ) parent . getChildren ( ) [ 0 ] ; result . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; parent . addControlListener ( new ControlListener ( ) { public void controlMoved ( ControlEvent e ) { } public void controlResized ( ControlEvent e ) { modifyScope ( parent , result ) ; } } ) ; Point computeSize = parent . getShell ( ) . computeSize ( - 1 , - 1 ) ; Point size = parent . getShell ( ) . getSize ( ) ; parent . getShell ( ) . setMinimumSize ( computeSize ) ; if ( size . x < computeSize . x || size . y < computeSize . y ) { parent . getShell ( ) . setSize ( computeSize . x , computeSize . y ) ; } parent . getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { modifyScope ( parent , result ) ; parent . getShell ( ) . layout ( true , true ) ; } } ) ; } public void setContainer ( ISearchPageContainer container ) { fContainer = container ; super . setContainer ( container ) ; } private ISearchPageContainer getContainer ( ) { return fContainer ; } public void dispose ( ) { writeConfiguration ( ) ; super . dispose ( ) ; } private IDialogSettings getDialogSettings ( ) { return SearchPlugin . getDefault ( ) . getDialogSettingsSection ( AptanaTextSearchPage . PAGE_NAME ) ; } private void readConfiguration ( ) { IDialogSettings s = getDialogSettings ( ) ; try { this . scope = s . getInt ( SEARCH_SCOPE ) ; } catch ( Exception ex ) { this . scope = ISearchPageContainer . WORKSPACE_SCOPE ; } this . fSearchDirectory = s . get ( AptanaTextSearchPage . STORE_SEARCH_DIRECTORY ) ; if ( this . fSearchDirectory == null ) { this . fSearchDirectory = "" ; } } private void writeConfiguration ( ) { IDialogSettings s = getDialogSettings ( ) ; s . put ( AptanaTextSearchPage . STORE_SEARCH_DIRECTORY , this . fSearchDirectory ) ; s . put ( SEARCH_SCOPE , scope ) ; } private void modifyScope ( final Composite parent , final Composite result ) { try { IdeLog . logInfo ( Activator . getDefault ( ) , StringUtils . format ( "Accessing children of " , new Object [ ] { parent . toString ( ) } ) ) ; Control [ ] children = parent . getChildren ( ) ; IdeLog . logInfo ( Activator . getDefault ( ) , StringUtils . format ( "children taken " , new Object [ ] { parent . toString ( ) } ) ) ; try { for ( int a = 0 ; a < children . length ; a ++ ) { if ( children [ a ] != result && ! firstOpen ) { IdeLog . logInfo ( Activator . getDefault ( ) , "Search in directory UI is creating" ) ; firstOpen = true ; children = ( ( Composite ) children [ a ] ) . getChildren ( ) ; final Group scopeGroup = ( Group ) children [ 0 ] ; Control [ ] children2 = scopeGroup . getChildren ( ) ; for ( Control control2 : children2 ) { if ( control2 instanceof Button ) { Button m = ( Button ) control2 ; if ( ( m . getStyle ( ) & SWT . RADIO ) != 0 ) { m . addSelectionListener ( scopeSelectionListener ) ; } if ( ( m . getStyle ( ) & SWT . PUSH ) != 0 ) { GridData gridData = new GridData ( ) ; m . setLayoutData ( gridData ) ; gridData . widthHint = SWTUtil . getButtonWidthHint ( m ) ; m . setLayoutData ( gridData ) ; } } } fSearchInDirectory = new Button ( scopeGroup , SWT . RADIO ) ; fSearchInDirectory . setText ( Messages . DIRECTORY ) ; fSearchInDirectory . addSelectionListener ( scopeSelectionListener ) ; fSearchInDirectory . setData ( new Integer ( DIRECTORY_SCOPE ) ) ; IdeLog . logInfo ( Activator . getDefault ( ) , "Search in directory UI is nearly created" ) ; fDirectory = new Text ( scopeGroup , SWT . READ_ONLY | SWT . BORDER ) ; GridData gridData = new GridData ( GridData . FILL_HORIZONTAL ) ; gridData . horizontalIndent = 8 ; gridData . horizontalSpan = 2 ; fDirectory . setLayoutData ( gridData ) ; fDirectory . setText ( fSearchDirectory ) ; IdeLog . logInfo ( Activator . getDefault ( ) , "Search in directory was created" ) ; Button choose = new Button ( scopeGroup , SWT . PUSH ) ; choose . setText ( Messages . CHOOSE ) ; choose . addSelectionListener ( new SelectionListener ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { } public void widgetSelected ( SelectionEvent e ) { DirectoryDialog ddialog = new DirectoryDialog ( fSearchInDirectory . getShell ( ) , SWT . NONE ) ; String open = ddialog . open ( ) ; if ( open != null ) { fSearchDirectory = open ; writeConfiguration ( ) ; fDirectory . setText ( open ) ; if ( fSearchInDirectory . getSelection ( ) ) { getContainer ( ) . setPerformActionEnabled ( fDirectory . getText ( ) . length ( ) > 0 ) ; } } } } ) ; fSearchInOpenFiles = new Button ( scopeGroup , SWT . RADIO ) ; fSearchInOpenFiles . addSelectionListener ( scopeSelectionListener ) ; fSearchInOpenFiles . setText ( Messages . OPEN_EDITORS ) ; fSearchInOpenFiles . setData ( new Integer ( OPEN_FILES_SCOPE ) ) ; fSearchInOpenFiles . setLayoutData ( new GridData ( SWT . LEFT , SWT . CENTER , false , false ) ) ; GridData gridData2 = new GridData ( ) ; gridData2 . widthHint = SWTUtil . getButtonWidthHint ( choose ) ; choose . setLayoutData ( gridData2 ) ; fSearchInDirectory . addSelectionListener ( new SelectionListener ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { } public void widgetSelected ( SelectionEvent e ) { boolean selection = fSearchInDirectory . getSelection ( ) ; if ( ! selection ) { getContainer ( ) . setPerformActionEnabled ( true ) ; return ; } getContainer ( ) . setSelectedScope ( 1 ) ; Control [ ] c = scopeGroup . getChildren ( ) ; for ( Control cm : c ) { if ( cm instanceof Button ) { Button b = ( Button ) cm ; if ( b != fSearchInDirectory ) { if ( b . getSelection ( ) ) { b . setSelection ( false ) ; } } } } getContainer ( ) . setPerformActionEnabled ( fDirectory . getText ( ) . length ( ) > 0 ) ; } } ) ; scopeGroup . layout ( true , true ) ; selectCurrentScope ( ) ; break ; } } if ( fSearchInDirectory == null ) { IdeLog . logError ( Activator . getDefault ( ) , "Search in directory UI was not created" ) ; } } catch ( Throwable e ) { IdeLog . logError ( Activator . getDefault ( ) , "Exception while modifing scope" , e ) ; } } catch ( Throwable e ) { IdeLog . logError ( Activator . getDefault ( ) , "Exception on top of  modifing scope" , e ) ; } } private void selectCurrentScope ( ) { if ( fSearchInDirectory != null ) { Composite parent = fSearchInDirectory . getParent ( ) ; Control [ ] children = parent . getChildren ( ) ; for ( Control child : children ) { if ( child instanceof Button ) { final Button btn = ( Button ) child ; if ( ( btn . getStyle ( ) & SWT . RADIO ) != 0 ) { Object data = btn . getData ( ) ; if ( data != null && data instanceof Integer ) { if ( ( ( Integer ) data ) . intValue ( ) == scope ) { Display . getCurrent ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { btn . setSelection ( true ) ; } } ) ; break ; } else { Display . getCurrent ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { btn . setSelection ( false ) ; } } ) ; } } } } } } } } 
=======
public class HttpTransportSE extends Transport { public HttpTransportSE ( String url ) { super ( url ) ; } public void call ( String soapAction , SoapEnvelope envelope ) throws IOException , XmlPullParserException { if ( soapAction == null ) soapAction = "\"\"" ; byte [ ] requestData = createRequestData ( envelope ) ; requestDump = debug ? new String ( requestData ) : null ; responseDump = null ; ServiceConnection connection = getServiceConnection ( ) ; connection . setRequestProperty ( "User-Agent" , "kSOAP/2.0" ) ; connection . setRequestProperty ( "SOAPAction" , soapAction ) ; connection . setRequestProperty ( "Content-Type" , "text/xml" ) ; connection . setRequestProperty ( "Connection" , "close" ) ; connection . setRequestProperty ( "Content-Length" , "" + requestData . length ) ; connection . setRequestMethod ( "POST" ) ; connection . connect ( ) ; OutputStream os = connection . openOutputStream ( ) ; os . write ( requestData , 0 , requestData . length ) ; os . flush ( ) ; os . close ( ) ; requestData = null ; InputStream is ; try { connection . connect ( ) ; is = connection . openInputStream ( ) ; } catch ( IOException e ) { is = connection . getErrorStream ( ) ; if ( is == null ) { connection . disconnect ( ) ; throw ( e ) ; } } if ( debug ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ 256 ] ; while ( true ) { int rd = is . read ( buf , 0 , 256 ) ; if ( rd == - 1 ) break ; bos . write ( buf , 0 , rd ) ; } bos . flush ( ) ; buf = bos . toByteArray ( ) ; responseDump = new String ( buf ) ; is . close ( ) ; is = new ByteArrayInputStream ( buf ) ; } parseResponse ( envelope , is ) ; } protected ServiceConnection getServiceConnection ( ) throws IOException { return new ServiceConnectionSE ( url ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
