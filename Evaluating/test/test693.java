public class ServerThreadRunnable implements Runnable { private boolean _stopped ; private HttpServer _server ; private ServerSocket _socketServer ; private IHttpResourceResolver _resourceResolver ; private IHttpLog _logger ; Vector threads = new Vector ( ) ; int workers = 5 ; int timeout = 5000 ; public ServerThreadRunnable ( HttpServer server ) { this ( server , 5000 ) ; } public ServerThreadRunnable ( HttpServer server , int timeout ) { this . _server = server ; this . _socketServer = this . _server . getSocketServer ( ) ; this . _resourceResolver = this . _server . getResourceResolver ( ) ; this . _logger = this . _server . getLogger ( ) ; this . timeout = timeout ; } public void run ( ) { for ( int i = 0 ; i < workers ; ++ i ) { Worker w = new Worker ( ) ; ( new Thread ( w , "Aptana: HTTP Worker " + i ) ) . start ( ) ; threads . addElement ( w ) ; } while ( this . _stopped == false && ! this . _socketServer . isClosed ( ) ) { try { Socket s = this . _socketServer . accept ( ) ; Worker w = null ; synchronized ( threads ) { if ( threads . isEmpty ( ) ) { Worker ws = new Worker ( ) ; ws . setSocket ( this , s , this . _server , this . _resourceResolver , this . _logger ) ; ( new Thread ( ws , "Aptana: HTTP Worker (Additional)" ) ) . start ( ) ; } else { w = ( Worker ) threads . elementAt ( 0 ) ; threads . removeElementAt ( 0 ) ; w . setSocket ( this , s , this . _server , this . _resourceResolver , this . _logger ) ; } } } catch ( Exception e ) { if ( this . _stopped == false || this . _socketServer . isClosed ( ) == false ) { this . _logger . logError ( e . getMessage ( ) , e ) ; } } } } public synchronized void stop ( ) { if ( this . _stopped == false ) { this . _stopped = true ; try { this . _socketServer . close ( ) ; } catch ( Exception e ) { this . _logger . logError ( e . getMessage ( ) , e ) ; } } } } class Worker implements Runnable { static final int BUF_SIZE = 2048 ; static final byte [ ] EOL = { ( byte ) '\r' , ( byte ) '\n' } ; private Socket s ; private ServerThreadRunnable _serverThreadRunnable ; private HttpServer _server ; private IHttpResourceResolver _resourceResolver ; private IHttpLog _logger ; byte [ ] buf ; Worker ( ) { buf = new byte [ BUF_SIZE ] ; s = null ; } synchronized void setSocket ( ServerThreadRunnable serverThreadRunnable , Socket s , HttpServer server , IHttpResourceResolver resourceResolver , IHttpLog logger ) { this . _serverThreadRunnable = serverThreadRunnable ; this . s = s ; this . _server = server ; this . _resourceResolver = resourceResolver ; this . _logger = logger ; notify ( ) ; } public synchronized void run ( ) { while ( true ) { if ( s == null ) { try { wait ( ) ; } catch ( InterruptedException e ) { continue ; } } try { processRequest ( ) ; } catch ( Exception e ) { } s = null ; Vector pool = _serverThreadRunnable . threads ; synchronized ( pool ) { if ( pool . size ( ) >= _serverThreadRunnable . workers ) { return ; } else { pool . addElement ( this ) ; } } } } private void processRequest ( ) throws IOException { String uri = null ; try { InputStream is = new BufferedInputStream ( s . getInputStream ( ) ) ; s . setSoTimeout ( _serverThreadRunnable . timeout ) ; s . setTcpNoDelay ( true ) ; for ( int i = 0 ; i < BUF_SIZE ; i ++ ) { buf [ i ] = 0 ; } int nread = 0 , r = 0 ; outerloop : while ( nread < BUF_SIZE ) { try { r = is . read ( buf , nread , BUF_SIZE - nread ) ; } catch ( SocketException e ) { return ; } if ( r == - 1 ) { return ; } int i = nread ; nread += r ; for ( ; i < nread ; i ++ ) { if ( buf [ i ] == ( byte ) '\n' || buf [ i ] == ( byte ) '\r' ) { break outerloop ; } } } String reqLine = new String ( buf ) ; RequestLineParser reqLineParser = new RequestLineParser ( reqLine ) ; uri = reqLineParser . getUri ( ) ; if ( uri != null && uri . length ( ) > 0 ) { try { IHttpResource resource = this . _resourceResolver . getResource ( reqLineParser ) ; if ( resource != null ) { if ( resource instanceof IHttpFolderResource ) { IHttpFolderResource folderResource = ( IHttpFolderResource ) resource ; if ( ! uri . endsWith ( "/" ) ) { this . sendRedirect ( s , uri + "/" ) ; } else { String [ ] fileNames = folderResource . getFileNames ( ) ; String [ ] folderNames = folderResource . getFolderNames ( ) ; String folderHTML = HttpResponseUtils . createBrowseFolderHTML ( new Path ( uri ) , fileNames , folderNames ) ; if ( reqLineParser . getMethod ( ) . equals ( "GET" ) ) { this . sendContent ( s , folderHTML , "text/html" ) ; } else if ( reqLineParser . getMethod ( ) . equals ( "HEAD" ) ) { this . sendHeaders ( s , "text/html" ) ; } } } else { InputStream contentInput = resource . getContentInputStream ( this . _server ) ; long length = resource . getContentLength ( ) ; String type = resource . getContentType ( ) ; try { if ( reqLineParser . getMethod ( ) . equals ( "GET" ) ) { this . sendFile ( s , contentInput , length , type ) ; } else if ( reqLineParser . getMethod ( ) . equals ( "HEAD" ) ) { this . sendHeaders ( s , type ) ; } } finally { if ( contentInput != null ) { contentInput . close ( ) ; } } } } else { throw new HttpServerException ( 404 , "file not found" , uri , "file not found: " + uri ) ; } } catch ( HttpServerException e ) { this . _logger . logTrace ( e . getStatusMessage ( ) + "-" + e . getRequestUri ( ) ) ; sendError ( s , e ) ; } } else { this . _logger . logTrace ( "bad request detected: " + reqLine != null ? reqLine : "request line was empty" ) ; sendError ( s , new HttpServerException ( 400 , "bad request" , uri , null ) ) ; } } catch ( Exception e ) { sendError ( s , new HttpServerException ( 500 , "Internal error" , uri , null , e ) ) ; IdeLog . logError ( ServerCorePlugin . getDefault ( ) , "Error" , e ) ; } finally { if ( s != null && ! s . isClosed ( ) ) { s . close ( ) ; } } } private Hashtable < String , String > makeHeaders ( ) { Hashtable < String , String > headers = new Hashtable < String , String > ( ) ; headers . put ( "Server" , "Aptana v0.2.7" ) ; headers . put ( "Expires" , "Mon, 26 Jul 1997 05:00:00 GMT" ) ; headers . put ( "Cache-Control" , "no-store, no-cache, must-revalidate" ) ; headers . put ( "Pragma" , "no-cache" ) ; SimpleDateFormat format = new SimpleDateFormat ( "EEE, dd MMM yyyy HH:mm:ss zZ" ) ; headers . put ( "Last-Modified" , format . format ( new Date ( ) ) ) ; return headers ; } private void sendContent ( Socket s , String content , String contentType ) throws IOException { OutputStream output = s . getOutputStream ( ) ; HttpResponse response = new HttpResponse ( output ) ; response . sendResponseContent ( content ) ; } private void sendHeaders ( Socket s , String contentType ) throws IOException { OutputStream output = s . getOutputStream ( ) ; HttpResponse response = new HttpResponse ( output ) ; response . sendReponseHeader ( 200 , "OK" , 0 , contentType , this . makeHeaders ( ) ) ; } private void sendFile ( Socket s , InputStream fileInput , long contentLength , String contentType ) throws IOException { OutputStream output = s . getOutputStream ( ) ; HttpResponse response = new HttpResponse ( output ) ; response . sendFileContent ( fileInput , contentLength , contentType , this . makeHeaders ( ) ) ; } private void sendError ( Socket s , HttpServerException e ) throws IOException { OutputStream output = s . getOutputStream ( ) ; HttpResponse response = new HttpResponse ( output ) ; response . sendError ( e ) ; } private void sendRedirect ( Socket s , String newURL ) throws IOException { OutputStream output = s . getOutputStream ( ) ; HttpResponse response = new HttpResponse ( output ) ; Hashtable < String , String > headers = new Hashtable < String , String > ( ) ; headers . put ( "location" , StringUtils . urlEncodeForSpaces ( newURL . toCharArray ( ) ) ) ; response . sendReponseHeader ( 307 , "redirect" , 1 , "text/html" , headers ) ; } } 