public abstract class AbstractInformationControlManager { public interface IInformationControlCloser { void setSubjectControl ( Control subject ) ; void setInformationControl ( IInformationControl control ) ; void start ( Rectangle subjectArea ) ; void stop ( ) ; } public static final class Anchor { private Anchor ( ) { } } private static final Anchor [ ] ANCHORS = { new Anchor ( ) , new Anchor ( ) , new Anchor ( ) , new Anchor ( ) } ; public static final Anchor ANCHOR_TOP = ANCHORS [ 0 ] ; public static final Anchor ANCHOR_BOTTOM = ANCHORS [ 1 ] ; public static final Anchor ANCHOR_LEFT = ANCHORS [ 2 ] ; public static final Anchor ANCHOR_RIGHT = ANCHORS [ 3 ] ; public static final Anchor ANCHOR_GLOBAL = new Anchor ( ) ; public static final String STORE_LOCATION_X = "location.x" ; public static final String STORE_LOCATION_Y = "location.y" ; public static final String STORE_SIZE_WIDTH = "size.width" ; public static final String STORE_SIZE_HEIGHT = "size.height" ; private Control fSubjectControl ; private Rectangle fSubjectArea ; private Object fInformation ; private boolean fTakesFocusWhenVisible = false ; protected IInformationControl fInformationControl ; protected IInformationControlCreator fInformationControlCreator ; protected IInformationControlCloser fInformationControlCloser ; protected boolean fDisposed = false ; private boolean fEnabled = false ; private Point fSizeConstraints ; private int fMarginY = 5 ; private int fMarginX = 5 ; private int fWidthConstraint = 60 ; private int fHeightConstraint = 6 ; private boolean fEnforceAsMinimalSize = false ; private boolean fEnforceAsMaximalSize = false ; private Anchor fAnchor = ANCHOR_BOTTOM ; private Anchor fComputedAnchor = ANCHOR_BOTTOM ; private int fVerticalOffset = 0 ; private Anchor [ ] fFallbackAnchors = ANCHORS ; private volatile IInformationControlCreator fCustomInformationControlCreator ; private boolean fIsCustomInformationControl = false ; private IDialogSettings fDialogSettings ; private boolean fIsRestoringLocation ; private boolean fIsRestoringSize ; private DisposeListener fSubjectControlDisposeListener ; protected AbstractInformationControlManager ( IInformationControlCreator creator ) { Assert . isNotNull ( creator ) ; fInformationControlCreator = creator ; } protected abstract void computeInformation ( ) ; protected final void setInformation ( String information , Rectangle subjectArea , int verticalOffset ) { fInformation = information ; fSubjectArea = subjectArea ; fVerticalOffset = verticalOffset ; presentInformation ( ) ; } protected final void setInformation ( String information , Rectangle subjectArea ) { fInformation = information ; fSubjectArea = subjectArea ; presentInformation ( ) ; } protected final void setInformation ( Object information , Rectangle subjectArea ) { fInformation = information ; fSubjectArea = subjectArea ; presentInformation ( ) ; } protected void setCloser ( IInformationControlCloser closer ) { fInformationControlCloser = closer ; } public void setMargins ( int xMargin , int yMargin ) { fMarginX = xMargin ; fMarginY = yMargin ; } public void setSizeConstraints ( int widthInChar , int heightInChar , boolean enforceAsMinimalSize , boolean enforceAsMaximalSize ) { fSizeConstraints = null ; fWidthConstraint = widthInChar ; fHeightConstraint = heightInChar ; fEnforceAsMinimalSize = enforceAsMinimalSize ; fEnforceAsMaximalSize = enforceAsMaximalSize ; } public void setRestoreInformationControlBounds ( IDialogSettings dialogSettings , boolean restoreLocation , boolean restoreSize ) { Assert . isTrue ( dialogSettings != null && ( restoreLocation || restoreSize ) ) ; fDialogSettings = dialogSettings ; fIsRestoringLocation = restoreLocation ; fIsRestoringSize = restoreSize ; } public void setAnchor ( Anchor anchor ) { fAnchor = anchor ; } public void setFallbackAnchors ( Anchor [ ] fallbackAnchors ) { if ( fallbackAnchors != null ) { fFallbackAnchors = new Anchor [ fallbackAnchors . length ] ; System . arraycopy ( fallbackAnchors , 0 , fFallbackAnchors , 0 , fallbackAnchors . length ) ; } else { fFallbackAnchors = null ; } } protected void setCustomInformationControlCreator ( IInformationControlCreator informationControlCreator ) { if ( fCustomInformationControlCreator instanceof IInformationControlCreatorExtension ) { IInformationControlCreatorExtension extension = ( IInformationControlCreatorExtension ) fCustomInformationControlCreator ; if ( extension . canReplace ( informationControlCreator ) ) { return ; } } fCustomInformationControlCreator = informationControlCreator ; } public void takesFocusWhenVisible ( boolean takesFocus ) { fTakesFocusWhenVisible = takesFocus ; } protected void handleSubjectControlDisposed ( ) { disposeInformationControl ( ) ; } public void install ( Control subjectControl ) { if ( fSubjectControl != null && ! fSubjectControl . isDisposed ( ) && fSubjectControlDisposeListener != null ) { fSubjectControl . removeDisposeListener ( fSubjectControlDisposeListener ) ; } fSubjectControl = subjectControl ; if ( fSubjectControl != null ) { fSubjectControl . addDisposeListener ( getSubjectControlDisposeListener ( ) ) ; } if ( fInformationControlCloser != null ) { fInformationControlCloser . setSubjectControl ( subjectControl ) ; } setEnabled ( true ) ; fDisposed = false ; } private DisposeListener getSubjectControlDisposeListener ( ) { if ( fSubjectControlDisposeListener == null ) { fSubjectControlDisposeListener = new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { handleSubjectControlDisposed ( ) ; } } ; } return fSubjectControlDisposeListener ; } protected Control getSubjectControl ( ) { return fSubjectControl ; } protected Rectangle getSubjectArea ( ) { return fSubjectArea ; } public void setEnabled ( boolean enabled ) { fEnabled = enabled ; } protected boolean isEnabled ( ) { return fEnabled ; } protected Point computeSizeConstraints ( Control subjectControl , IInformationControl informationControl ) { if ( fSizeConstraints == null ) { if ( subjectControl == null ) { return null ; } GC gc = new GC ( subjectControl ) ; gc . setFont ( subjectControl . getFont ( ) ) ; int width = gc . getFontMetrics ( ) . getAverageCharWidth ( ) ; int height = gc . getFontMetrics ( ) . getHeight ( ) ; gc . dispose ( ) ; fSizeConstraints = new Point ( fWidthConstraint * width , fHeightConstraint * height ) ; } return fSizeConstraints ; } protected Point computeSizeConstraints ( Control subjectControl , Rectangle subjectArea , IInformationControl informationControl ) { return computeSizeConstraints ( subjectControl , informationControl ) ; } protected void handleInformationControlDisposed ( ) { storeInformationControlBounds ( ) ; fInformationControl = null ; if ( fInformationControlCloser != null ) { fInformationControlCloser . setInformationControl ( null ) ; fInformationControlCloser . stop ( ) ; } } protected IInformationControl getInformationControl ( ) { if ( fDisposed ) { return fInformationControl ; } IInformationControlCreator creator = null ; if ( fCustomInformationControlCreator == null ) { creator = fInformationControlCreator ; if ( fIsCustomInformationControl && fInformationControl != null ) { fInformationControl . dispose ( ) ; fInformationControl = null ; } fIsCustomInformationControl = false ; } else { creator = fCustomInformationControlCreator ; if ( creator instanceof IInformationControlCreatorExtension ) { IInformationControlCreatorExtension extension = ( IInformationControlCreatorExtension ) creator ; if ( extension . canReuse ( fInformationControl ) ) { return fInformationControl ; } } if ( fInformationControl != null ) { fInformationControl . dispose ( ) ; fInformationControl = null ; } fIsCustomInformationControl = true ; } if ( fInformationControl == null ) { fInformationControl = creator . createInformationControl ( fSubjectControl . getShell ( ) ) ; fInformationControl . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { handleInformationControlDisposed ( ) ; } } ) ; if ( fInformationControlCloser != null ) { fInformationControlCloser . setInformationControl ( fInformationControl ) ; } } return fInformationControl ; } protected Point computeLocation ( Rectangle subjectArea , Point controlSize , Anchor anchor ) { if ( ANCHOR_GLOBAL == anchor ) { Point subjectControlSize = fSubjectControl . getSize ( ) ; Point location = new Point ( subjectControlSize . x / 2 , subjectControlSize . y / 2 ) ; location . x -= ( controlSize . x / 2 ) ; location . y -= ( controlSize . y / 2 ) ; return fSubjectControl . toDisplay ( location ) ; } int xShift = 0 ; int yShift = 0 ; if ( ANCHOR_BOTTOM == anchor ) { xShift = fMarginX ; yShift = subjectArea . height + fMarginY ; } else if ( ANCHOR_RIGHT == anchor ) { xShift = fMarginX + subjectArea . width ; yShift = fMarginY ; } else if ( ANCHOR_TOP == anchor ) { xShift = fMarginX ; yShift = - controlSize . y - fMarginY ; } else if ( ANCHOR_LEFT == anchor ) { xShift = - controlSize . x - fMarginX ; yShift = fMarginY ; } boolean isRTL = fSubjectControl != null && ( fSubjectControl . getStyle ( ) & SWT . RIGHT_TO_LEFT ) != 0 ; if ( isRTL ) { xShift += controlSize . x ; } return fSubjectControl . toDisplay ( new Point ( subjectArea . x + xShift , subjectArea . y + yShift ) ) ; } protected boolean updateLocation ( Point location , Point size , Rectangle displayArea , Anchor anchor ) { int displayLowerRightX = displayArea . x + displayArea . width ; int displayLowerRightY = displayArea . y + displayArea . height ; int lowerRightX = location . x + size . x ; int lowerRightY = location . y + size . y ; if ( ANCHOR_BOTTOM == anchor || ANCHOR_TOP == anchor ) { if ( lowerRightX > displayLowerRightX ) { location . x = location . x - ( lowerRightX - displayLowerRightX ) ; } return ( location . x >= 0 && location . y >= 0 ) ; } else if ( ANCHOR_RIGHT == anchor || ANCHOR_LEFT == anchor ) { if ( ANCHOR_RIGHT == anchor ) { if ( ( location . x - ( size . x * 3 ) ) < 0 ) { return true ; } if ( lowerRightX > displayLowerRightX ) { return false ; } } else { if ( location . x < displayArea . x ) { return false ; } } if ( lowerRightY > displayLowerRightY ) { location . y = location . y - ( lowerRightY - displayLowerRightY ) ; } return ( location . x >= 0 && location . y >= 0 ) ; } else if ( ANCHOR_GLOBAL == anchor ) { if ( lowerRightX > displayLowerRightX ) { location . x = location . x - ( lowerRightX - displayLowerRightX ) ; } if ( lowerRightY > displayLowerRightY ) { location . y = location . y - ( lowerRightY - displayLowerRightY ) ; } return ( location . x >= 0 && location . y >= 0 ) ; } return false ; } protected Anchor getNextFallbackAnchor ( Anchor anchor ) { if ( anchor == null || fFallbackAnchors == null ) { return null ; } for ( int i = 0 ; i < fFallbackAnchors . length ; i ++ ) { if ( fFallbackAnchors [ i ] == anchor ) { return fFallbackAnchors [ i + 1 == fFallbackAnchors . length ? 0 : i + 1 ] ; } } return null ; } protected Point computeInformationControlLocation ( Rectangle subjectArea , Point controlSize ) { Rectangle displayBounds = fSubjectControl . getDisplay ( ) . getClientArea ( ) ; Point upperLeft ; fComputedAnchor = fAnchor ; do { upperLeft = computeLocation ( subjectArea , controlSize , fComputedAnchor ) ; if ( updateLocation ( upperLeft , controlSize , displayBounds , fComputedAnchor ) ) { break ; } fComputedAnchor = getNextFallbackAnchor ( fComputedAnchor ) ; } while ( fComputedAnchor != fAnchor && fComputedAnchor != null ) ; return upperLeft ; } public void showInformation ( ) { if ( fEnabled ) { doShowInformation ( ) ; } } protected void doShowInformation ( ) { fSubjectArea = null ; fInformation = null ; computeInformation ( ) ; } protected void presentInformation ( ) { boolean hasContents = false ; if ( fInformation instanceof String ) { hasContents = ( ( String ) fInformation ) . trim ( ) . length ( ) > 0 ; } else { hasContents = ( fInformation != null ) ; } if ( fSubjectArea != null && hasContents ) { internalShowInformationControl ( fSubjectArea , fInformation ) ; } else { hideInformationControl ( ) ; } } private void internalShowInformationControl ( Rectangle subjectArea , Object information ) { IInformationControl informationControl = getInformationControl ( ) ; if ( informationControl != null ) { Point sizeConstraints = computeSizeConstraints ( fSubjectControl , fSubjectArea , informationControl ) ; informationControl . setSizeConstraints ( sizeConstraints . x , sizeConstraints . y ) ; if ( informationControl instanceof IInformationControlExtension2 ) { ( ( IInformationControlExtension2 ) informationControl ) . setInput ( information ) ; } else { informationControl . setInformation ( information . toString ( ) ) ; } if ( informationControl instanceof IInformationControlExtension ) { IInformationControlExtension extension = ( IInformationControlExtension ) informationControl ; if ( ! extension . hasContents ( ) ) { return ; } } Point size = null ; Point location = null ; Rectangle bounds = restoreInformationControlBounds ( ) ; if ( bounds != null ) { if ( bounds . x > - 1 && bounds . y > - 1 ) { location = new Point ( bounds . x , bounds . y ) ; } if ( bounds . width > - 1 && bounds . height > - 1 ) { size = new Point ( bounds . width , bounds . height ) ; } } if ( size == null ) { size = informationControl . computeSizeHint ( ) ; } if ( fEnforceAsMinimalSize ) { if ( size . x < sizeConstraints . x ) { size . x = sizeConstraints . x ; } if ( size . y < sizeConstraints . y ) { size . y = sizeConstraints . y ; } } if ( fEnforceAsMaximalSize ) { if ( size . x > sizeConstraints . x ) { size . x = sizeConstraints . x ; } if ( size . y > sizeConstraints . y ) { size . y = sizeConstraints . y ; } } informationControl . setSize ( size . x + 5 , size . y ) ; if ( location == null ) { location = computeInformationControlLocation ( subjectArea , size ) ; } if ( ( fComputedAnchor == ANCHOR_LEFT || fComputedAnchor == ANCHOR_RIGHT ) && fVerticalOffset != 0 ) { location . y = fVerticalOffset ; } informationControl . setLocation ( location ) ; showInformationControl ( subjectArea ) ; } } protected void hideInformationControl ( ) { if ( fInformationControl != null ) { storeInformationControlBounds ( ) ; fInformationControl . setVisible ( false ) ; if ( fInformationControlCloser != null ) { fInformationControlCloser . stop ( ) ; } } } protected void showInformationControl ( Rectangle subjectArea ) { fInformationControl . setVisible ( true ) ; if ( fTakesFocusWhenVisible ) { fInformationControl . setFocus ( ) ; } if ( fInformationControlCloser != null ) { fInformationControlCloser . start ( subjectArea ) ; } } public void disposeInformationControl ( ) { if ( fInformationControl != null ) { fInformationControl . dispose ( ) ; handleInformationControlDisposed ( ) ; } } public void dispose ( ) { if ( ! fDisposed ) { fDisposed = true ; setEnabled ( false ) ; disposeInformationControl ( ) ; if ( fSubjectControl != null && ! fSubjectControl . isDisposed ( ) && fSubjectControlDisposeListener != null ) { fSubjectControl . removeDisposeListener ( fSubjectControlDisposeListener ) ; } fSubjectControl = null ; fSubjectControlDisposeListener = null ; fIsCustomInformationControl = false ; fCustomInformationControlCreator = null ; fInformationControlCreator = null ; fInformationControlCloser = null ; } } protected void storeInformationControlBounds ( ) { if ( fDialogSettings == null || fInformationControl == null || ! ( fIsRestoringLocation || fIsRestoringSize ) ) { return ; } if ( ! ( fInformationControl instanceof IInformationControlExtension3 ) ) { throw new UnsupportedOperationException ( ) ; } boolean controlRestoresSize = ( ( IInformationControlExtension3 ) fInformationControl ) . restoresSize ( ) ; boolean controlRestoresLocation = ( ( IInformationControlExtension3 ) fInformationControl ) . restoresLocation ( ) ; Rectangle bounds = ( ( IInformationControlExtension3 ) fInformationControl ) . getBounds ( ) ; if ( bounds == null ) { return ; } if ( fIsRestoringSize && controlRestoresSize ) { fDialogSettings . put ( STORE_SIZE_WIDTH , bounds . width ) ; fDialogSettings . put ( STORE_SIZE_HEIGHT , bounds . height ) ; } if ( fIsRestoringLocation && controlRestoresLocation ) { fDialogSettings . put ( STORE_LOCATION_X , bounds . x ) ; fDialogSettings . put ( STORE_LOCATION_Y , bounds . y ) ; } } protected Rectangle restoreInformationControlBounds ( ) { if ( fDialogSettings == null || ! ( fIsRestoringLocation || fIsRestoringSize ) ) { return null ; } if ( ! ( fInformationControl instanceof IInformationControlExtension3 ) ) { throw new UnsupportedOperationException ( ) ; } boolean controlRestoresSize = ( ( IInformationControlExtension3 ) fInformationControl ) . restoresSize ( ) ; boolean controlRestoresLocation = ( ( IInformationControlExtension3 ) fInformationControl ) . restoresLocation ( ) ; Rectangle bounds = new Rectangle ( - 1 , - 1 , - 1 , - 1 ) ; if ( fIsRestoringSize && controlRestoresSize ) { try { bounds . width = fDialogSettings . getInt ( STORE_SIZE_WIDTH ) ; bounds . height = fDialogSettings . getInt ( STORE_SIZE_HEIGHT ) ; } catch ( NumberFormatException ex ) { bounds . width = - 1 ; bounds . height = - 1 ; } } if ( fIsRestoringLocation && controlRestoresLocation ) { try { bounds . x = fDialogSettings . getInt ( STORE_LOCATION_X ) ; bounds . y = fDialogSettings . getInt ( STORE_LOCATION_Y ) ; } catch ( NumberFormatException ex ) { bounds . x = - 1 ; bounds . y = - 1 ; } } if ( bounds . x == - 1 && bounds . y == - 1 && bounds . width == - 1 && bounds . height == - 1 ) { return null ; } Rectangle maxBounds = null ; if ( fSubjectControl != null && ! fSubjectControl . isDisposed ( ) ) { maxBounds = fSubjectControl . getDisplay ( ) . getBounds ( ) ; } else { Display display = Display . getCurrent ( ) ; if ( display == null ) { display = Display . getDefault ( ) ; } if ( display != null && ! display . isDisposed ( ) ) { maxBounds = display . getBounds ( ) ; } } if ( bounds . width > - 1 && bounds . height > - 1 ) { if ( maxBounds != null ) { bounds . width = Math . min ( bounds . width , maxBounds . width ) ; bounds . height = Math . min ( bounds . height , maxBounds . height ) ; } bounds . width = Math . max ( bounds . width , 30 ) ; bounds . height = Math . max ( bounds . height , 30 ) ; } if ( bounds . x > - 1 && bounds . y > - 1 && maxBounds != null ) { bounds . x = Math . max ( bounds . x , maxBounds . x ) ; bounds . y = Math . max ( bounds . y , maxBounds . y ) ; if ( bounds . width > - 1 && bounds . height > - 1 ) { bounds . x = Math . min ( bounds . x , maxBounds . width - bounds . width ) ; bounds . y = Math . min ( bounds . y , maxBounds . height - bounds . height ) ; } } return bounds ; } } 