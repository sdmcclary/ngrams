<<<<<<< HEAD
class DiskMapTurboProvider implements TurboProvider { static final String ATTR_STATUS_MAP = "git.STATUS_MAP" ; private static final int STATUS_VALUABLE = StatusInfo . STATUS_MANAGED & ~ StatusInfo . STATUS_VERSIONED_UPTODATE ; private static final String CACHE_DIRECTORY = "gitcache" ; private File cacheStore ; private int storeSerial ; private int cachedStoreSerial = - 1 ; private Map < File , StatusInfo > cachedValues ; DiskMapTurboProvider ( ) { initCacheStore ( ) ; } synchronized Map < File , StatusInfo > getAllModifiedValues ( ) { if ( cachedStoreSerial != storeSerial || cachedValues == null ) { cachedValues = new HashMap < File , StatusInfo > ( ) ; File [ ] files = cacheStore . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; if ( file . getName ( ) . endsWith ( ".bin" ) == false ) { continue ; } DataInputStream dis = null ; try { int retry = 0 ; while ( true ) { try { dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( file ) ) ) ; break ; } catch ( IOException ioex ) { retry ++ ; if ( retry > 7 ) { throw ioex ; } Thread . sleep ( retry * 30 ) ; } } for ( ; ; ) { int pathLen = dis . readInt ( ) ; dis . readInt ( ) ; String path = readChars ( dis , pathLen ) ; Map < File , StatusInfo > value = readValue ( dis , path ) ; for ( File f : value . keySet ( ) ) { StatusInfo info = value . get ( f ) ; if ( ( info . getStatus ( ) & DiskMapTurboProvider . STATUS_VALUABLE ) != 0 ) { cachedValues . put ( f , info ) ; } } } } catch ( EOFException e ) { } catch ( Exception e ) { Git . LOG . log ( Level . WARNING , null , e ) ; } finally { if ( dis != null ) try { dis . close ( ) ; } catch ( IOException e ) { } } } cachedStoreSerial = storeSerial ; cachedValues = Collections . unmodifiableMap ( cachedValues ) ; } return cachedValues ; } public boolean recognizesAttribute ( String name ) { return DiskMapTurboProvider . ATTR_STATUS_MAP . equals ( name ) ; } public boolean recognizesEntity ( Object key ) { return key instanceof File ; } public synchronized Object readEntry ( Object key , String name , MemoryCache memoryCache ) { assert key instanceof File ; assert name != null ; boolean readFailed = false ; File dir = ( File ) key ; File store = getStore ( dir ) ; if ( ! store . isFile ( ) ) { return null ; } String dirPath = dir . getAbsolutePath ( ) ; int dirPathLen = dirPath . length ( ) ; DataInputStream dis = null ; try { int retry = 0 ; while ( true ) { try { dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( store ) ) ) ; break ; } catch ( IOException ioex ) { retry ++ ; if ( retry > 7 ) { throw ioex ; } Thread . sleep ( retry * 30 ) ; } } for ( ; ; ) { int pathLen = dis . readInt ( ) ; int mapLen = dis . readInt ( ) ; if ( pathLen != dirPathLen ) { skip ( dis , pathLen * 2 + mapLen ) ; } else { String path = readChars ( dis , pathLen ) ; if ( dirPath . equals ( path ) ) { return readValue ( dis , path ) ; } else { skip ( dis , mapLen ) ; } } } } catch ( EOFException e ) { } catch ( Exception e ) { Git . LOG . log ( Level . INFO , null , e ) ; readFailed = true ; } finally { if ( dis != null ) try { dis . close ( ) ; } catch ( IOException e ) { } } if ( readFailed ) store . delete ( ) ; return null ; } public synchronized boolean writeEntry ( Object key , String name , Object value ) { assert key instanceof File ; assert name != null ; if ( value != null ) { if ( ! ( value instanceof Map ) ) return false ; if ( ! isValuable ( value ) ) value = null ; } File dir = ( File ) key ; String dirPath = dir . getAbsolutePath ( ) ; int dirPathLen = dirPath . length ( ) ; File store = getStore ( dir ) ; if ( value == null && ! store . exists ( ) ) return true ; File storeNew = new File ( store . getParentFile ( ) , store . getName ( ) + ".new" ) ; DataOutputStream oos = null ; DataInputStream dis = null ; try { oos = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( storeNew ) ) ) ; if ( value != null ) { writeEntry ( oos , dirPath , value ) ; } if ( store . exists ( ) ) { int retry = 0 ; while ( true ) { try { dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( store ) ) ) ; break ; } catch ( IOException ioex ) { retry ++ ; if ( retry > 7 ) { throw ioex ; } Thread . sleep ( retry * 30 ) ; } } for ( ; ; ) { int pathLen ; try { pathLen = dis . readInt ( ) ; } catch ( EOFException e ) { break ; } int mapLen = dis . readInt ( ) ; if ( pathLen == dirPathLen ) { String path = readChars ( dis , pathLen ) ; if ( dirPath . equals ( path ) ) { skip ( dis , mapLen ) ; } else { oos . writeInt ( pathLen ) ; oos . writeInt ( mapLen ) ; oos . writeChars ( path ) ; DiskMapTurboProvider . copyStreams ( oos , dis , mapLen ) ; } } else { oos . writeInt ( pathLen ) ; oos . writeInt ( mapLen ) ; DiskMapTurboProvider . copyStreams ( oos , dis , mapLen + pathLen * 2 ) ; } } } } catch ( Exception e ) { Git . LOG . log ( Level . WARNING , "writeEntry(): Copy: {0} to: {1}" , new Object [ ] { store . getAbsolutePath ( ) , storeNew . getAbsolutePath ( ) } ) ; return true ; } finally { if ( oos != null ) try { oos . close ( ) ; } catch ( IOException e ) { } if ( dis != null ) try { dis . close ( ) ; } catch ( IOException e ) { } } storeSerial ++ ; store . delete ( ) ; storeNew . renameTo ( store ) ; return true ; } private void skip ( InputStream is , long len ) throws IOException { while ( len > 0 ) { long n = is . skip ( len ) ; if ( n < 0 ) throw new EOFException ( "Missing " + len + " bytes." ) ; len -= n ; } } private String readChars ( DataInputStream dis , int len ) throws IOException { StringBuffer sb = new StringBuffer ( len ) ; while ( len -- > 0 ) { sb . append ( dis . readChar ( ) ) ; } return sb . toString ( ) ; } private Map < File , StatusInfo > readValue ( DataInputStream dis , String dirPath ) throws IOException { Map < File , StatusInfo > map = new HashMap < File , StatusInfo > ( ) ; int len = dis . readInt ( ) ; while ( len -- > 0 ) { int nameLen = dis . readInt ( ) ; String name = readChars ( dis , nameLen ) ; File file = new File ( dirPath , name ) ; int status = dis . readInt ( ) ; StatusInfo info = new StatusInfo ( status & 65535 , status > 65535 ) ; map . put ( file , info ) ; } return map ; } private void writeEntry ( DataOutputStream dos , String dirPath , Object value ) throws IOException { Map map = ( Map ) value ; Set set = map . keySet ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( set . size ( ) * 50 ) ; DataOutputStream temp = new DataOutputStream ( baos ) ; temp . writeInt ( set . size ( ) ) ; for ( Iterator i = set . iterator ( ) ; i . hasNext ( ) ; ) { File file = ( File ) i . next ( ) ; StatusInfo info = ( StatusInfo ) map . get ( file ) ; temp . writeInt ( file . getName ( ) . length ( ) ) ; temp . writeChars ( file . getName ( ) ) ; temp . writeInt ( info . getStatus ( ) + ( info . isDirectory ( ) ? 65536 : 0 ) ) ; } temp . close ( ) ; byte [ ] valueBytes = baos . toByteArray ( ) ; dos . writeInt ( dirPath . length ( ) ) ; dos . writeInt ( valueBytes . length ) ; dos . writeChars ( dirPath ) ; dos . write ( valueBytes ) ; } private boolean isValuable ( Object value ) { Map map = ( Map ) value ; for ( Iterator i = map . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { StatusInfo info = ( StatusInfo ) i . next ( ) ; if ( ( info . getStatus ( ) & DiskMapTurboProvider . STATUS_VALUABLE ) != 0 ) return true ; } return false ; } private File getStore ( File dir ) { String dirPath = dir . getAbsolutePath ( ) ; int dirHash = dirPath . hashCode ( ) ; return new File ( cacheStore , Integer . toString ( dirHash % 173 + 172 ) + ".bin" ) ; } private void initCacheStore ( ) { String userDir = System . getProperty ( "netbeans.user" ) ; File cacheRoot ; if ( userDir != null ) { cacheRoot = new File ( new File ( userDir , "var" ) , "cache" ) ; } else { cacheRoot = FileUtil . toFile ( FileUtil . getConfigRoot ( ) ) ; } cacheStore = new File ( cacheRoot , DiskMapTurboProvider . CACHE_DIRECTORY ) ; cacheStore . mkdirs ( ) ; } private static void copyStreams ( OutputStream out , InputStream in , int len ) throws IOException { byte [ ] buffer = new byte [ 4096 ] ; for ( ; ; ) { int n = ( len <= 4096 ) ? len : 4096 ; n = in . read ( buffer , 0 , n ) ; if ( n < 0 ) throw new EOFException ( "Missing " + len + " bytes." ) ; out . write ( buffer , 0 , n ) ; if ( ( len -= n ) == 0 ) break ; } out . flush ( ) ; } } 
=======
interface Measure { int getLength ( Object obj ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
