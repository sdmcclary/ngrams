public abstract class AbstractMigLayoutHandler extends AbstractTypeHandler implements ITypeChildrenHandler { private final static Map < DefaultResize , String > resizeConstraints = new HashMap < DefaultResize , String > ( ) ; protected final static Logger logger = LoggerFactory . getLogger ( AbstractMigLayoutHandler . class ) ; private Class < ? > defaultTypeClass = null ; private String defaultTypePropertyName = null ; static { resizeConstraints . put ( DefaultResize . BOTH , "grow" ) ; resizeConstraints . put ( DefaultResize . X_AXIS , "growx" ) ; resizeConstraints . put ( DefaultResize . Y_AXIS , "growy" ) ; } protected AbstractMigLayoutHandler ( Class < ? > defaultTypeClass , String defaultTypePropertyName ) { super ( ) ; this . defaultTypeClass = defaultTypeClass ; this . defaultTypePropertyName = defaultTypePropertyName ; } protected abstract void setLayout ( BuildProcess result , Node node , Object migLayout ) throws BuildException ; protected abstract Object getComponent ( BuildProcess result , Node components , String name ) throws BuildException ; protected abstract void setLayoutConstraints ( Object layout , String constraints ) throws BuildException ; protected abstract void setRowConstraints ( Object layout , String constraints ) throws BuildException ; protected abstract void setColumnConstraints ( Object layout , String constraints ) throws BuildException ; protected abstract void applyControlConstraints ( BuildProcess result , Node node , Node components , Map < String , String > layoutConstraints ) throws BuildException ; protected abstract void setControlName ( Object control , String name ) ; @ SuppressWarnings ( "unchecked" ) public final Node useExistingInstance ( BuilderConfig config , BuildProcess process , Node parent , String key , Map < String , Object > typeDefinition , Object instance ) throws BuildException { Node node = new Node ( parent , key , typeDefinition ) ; node . setMainObject ( instance ) ; Node components = parent ; setLayout ( process , node , node . getMainObject ( ) ) ; String layoutCo = "" , rowCo = "" , columnCo = "" ; Map < String , String > layoutConstraints = new LinkedHashMap < String , String > ( ) ; if ( typeDefinition . containsKey ( Builder . LAYOUT ) ) { String visualLayout = String . valueOf ( typeDefinition . get ( Builder . LAYOUT ) ) ; LayoutConstraints lo = LayoutConstraints . getParsedLayoutConstraints ( visualLayout , MigLayoutCommon . DEFAULT_ROW_COLUMN_CONSTRAINT , MigLayoutCommon . DEFAULT_ROW_COLUMN_CONSTRAINT ) ; layoutCo = lo . getLayoutConstraints ( ) ; for ( String row : lo . getRowConstraints ( ) ) { rowCo += " " + row ; } for ( String column : lo . getColumnConstraints ( ) ) { columnCo += " " + column ; } StringBuilder builder = new StringBuilder ( ) ; for ( LayoutCell cell : lo . getCells ( ) ) { boolean firstControl = true ; for ( ControlConstraint co : cell . getControls ( ) ) { Object component = getNamedComponentOrCreateOne ( process , components , co ) ; if ( component == null ) { throw new BuildException ( "MigLayout unable to find control named \"{0}\" in layout:\n{1}" , co . getControlName ( ) , visualLayout ) ; } builder . setLength ( 0 ) ; builder . append ( "cell " ) ; builder . append ( cell . getColumnIndex ( ) ) ; builder . append ( " " ) ; builder . append ( cell . getRowIndex ( ) ) ; if ( firstControl ) { if ( co . getHSpan ( ) > 1 || co . getVSpan ( ) > 1 ) { builder . append ( " " ) . append ( co . getHSpan ( ) ) . append ( " " ) . append ( co . getVSpan ( ) ) ; } if ( cell . getFlow ( ) == Flow . VERTICAL ) { builder . append ( ", flowy, top" ) ; } firstControl = false ; } MigLayoutCommon . handleResize ( builder , co , TypeDefinition . getDefaultResize ( config , component . getClass ( ) ) , lo . getAdditionalControlConstraints ( ) . get ( co . getControlName ( ) ) ) ; if ( co . getHAlign ( ) == HAlign . CENTER ) { builder . append ( ", alignx center" ) ; } else if ( co . getHAlign ( ) == HAlign . RIGHT ) { builder . append ( ", alignx right" ) ; } else if ( co . getHAlign ( ) == HAlign . LEFT ) { builder . append ( ", alignx left" ) ; } if ( co . getVAlign ( ) == VAlign . MIDDLE ) { builder . append ( ", aligny center" ) ; } else if ( co . getVAlign ( ) == VAlign . BOTTOM ) { builder . append ( ", aligny bottom" ) ; } else if ( co . getVAlign ( ) == VAlign . TOP ) { builder . append ( ", aligny top" ) ; } if ( co . getSizeGroup ( ) != null ) { if ( co . isSizeGroupX ( ) ) { builder . append ( ", sgx " ) . append ( co . getSizeGroup ( ) ) ; } else if ( co . isSizeGroupY ( ) ) { builder . append ( ", sgy " ) . append ( co . getSizeGroup ( ) ) ; } else { builder . append ( ", sg " ) . append ( co . getSizeGroup ( ) ) ; } } if ( lo . getAdditionalControlConstraints ( ) . containsKey ( co . getControlName ( ) ) ) { String constraints = lo . getAdditionalControlConstraints ( ) . get ( co . getControlName ( ) ) ; if ( constraints . matches ( BuilderConfig . GLOBAL_VARIABLE_REGEX ) ) { constraints = ( String ) config . getGlobalVariable ( constraints , String . class ) ; } builder . append ( ", " ) . append ( constraints ) ; } layoutConstraints . put ( co . getControlName ( ) , builder . toString ( ) ) ; } } } if ( typeDefinition . containsKey ( MigLayoutCommon . LAYOUT_CONSTRAINTS ) ) { layoutCo += " " + typeDefinition . get ( MigLayoutCommon . LAYOUT_CONSTRAINTS ) ; } if ( typeDefinition . containsKey ( MigLayoutCommon . ROW_CONSTRAINTS ) ) { rowCo += " " + typeDefinition . get ( MigLayoutCommon . ROW_CONSTRAINTS ) ; } if ( typeDefinition . containsKey ( MigLayoutCommon . COLUMN_CONSTRAINTS ) ) { columnCo += " " + typeDefinition . get ( MigLayoutCommon . COLUMN_CONSTRAINTS ) ; } if ( layoutCo . length ( ) > 0 ) { setLayoutConstraints ( instance , layoutCo ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "MigLayout constraints: " + layoutCo ) ; } } if ( rowCo . length ( ) > 0 ) { setRowConstraints ( instance , rowCo ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "MigLayout row constraints: " + rowCo ) ; } } if ( columnCo . length ( ) > 0 ) { setColumnConstraints ( instance , columnCo ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "MigLayout column constraints: " + columnCo ) ; } } if ( typeDefinition . containsKey ( Builder . CONSTRAINTS ) ) { List < ? extends Object > constraints = ( List < ? extends Object > ) typeDefinition . get ( Builder . CONSTRAINTS ) ; for ( Object constraint : constraints ) { if ( constraint instanceof String ) { if ( ! layoutConstraints . containsKey ( constraint ) ) { layoutConstraints . put ( String . valueOf ( constraint ) , "" ) ; } } else if ( constraint instanceof Map ) { Map < String , Object > map = ( Map < String , Object > ) constraint ; for ( String componentName : map . keySet ( ) ) { Object componentConstraint = map . get ( componentName ) ; String existingConstraint = layoutConstraints . get ( componentName ) ; if ( existingConstraint == null ) { existingConstraint = String . valueOf ( componentConstraint ) ; } else { existingConstraint += ", " + String . valueOf ( componentConstraint ) ; } layoutConstraints . put ( componentName , existingConstraint ) ; } } } } applyControlConstraints ( process , node , components , layoutConstraints ) ; return node ; } @ Override public String getCollectionPropertyName ( ) { return Builder . CONSTRAINTS ; } @ Override public String getSimpleValuePropertyName ( ) { return Builder . LAYOUT ; } private Object getNamedComponentOrCreateOne ( BuildProcess process , Node components , ControlConstraint co ) { String name = co . getControlName ( ) ; Object component = getComponent ( process , components , name ) ; if ( component == null ) { if ( name . startsWith ( "\"" ) && name . endsWith ( "\"" ) ) { String text = name . replace ( "\"" , "" ) ; text = BuilderUtils . handlePotentialHtmlContent ( text ) ; text = process . getBuildResult ( ) . getResource ( text ) ; if ( name . equals ( "\"\"" ) ) { name = "blank" ; } String prefix = null , suffix = null ; if ( process . getConfig ( ) instanceof IStringLiteralControlConfig ) { IStringLiteralControlConfig config = ( IStringLiteralControlConfig ) process . getConfig ( ) ; prefix = config . getStringLiteralControlPrefix ( ) ; suffix = config . getStringLiteralControlSuffix ( ) ; } name = BuilderUtils . generateName ( process . getBuildResult ( ) , name , prefix , suffix ) ; String compressedYaml = String . format ( "%s(name=%s,%s=\"%s\")" , defaultTypeClass . getSimpleName ( ) , name , defaultTypePropertyName , text ) ; component = Builder . createControlFromCompressedYaml ( process , components , compressedYaml ) ; co . setControlName ( name ) ; setControlName ( component , name ) ; } else { component = Builder . buildControlFromName ( process , components , name ) ; } } return component ; } } 