public class XMLContentAssistProcessor extends UnifiedContentAssistProcessor implements IContentAssistProcessor { private IContextInformationValidator validator ; public static Hashtable usage = new Hashtable ( ) ; public static Image [ ] NO_BROWSER_IMAGES = new Image [ 0 ] ; private static Image fIconField = UnifiedEditorsPlugin . getImage ( "icons/field_public.gif" ) ; private static Image fIconFieldGuess = UnifiedEditorsPlugin . getImage ( "icons/field_public_guess.gif" ) ; private static Image fIconTag = UnifiedEditorsPlugin . getImage ( "icons/html_tag.gif" ) ; private static Image fIconEvent = UnifiedEditorsPlugin . getImage ( "icons/event.gif" ) ; private static Image fIconFile = UnifiedEditorsPlugin . getImage ( "icons/file.gif" ) ; private static Image fIconFolder = UnifiedEditorsPlugin . getImage ( "icons/folder.gif" ) ; private XMLCompletionProposalComparator contentAssistComparator ; private String AUTO_ADDED = "Auto-added from environment" ; public static String ERROR = "ERROR" ; public static String OUTSIDE_ELEMENT = "OUTSIDE_ELEMENT" ; public static String INSIDE_OPEN_ELEMENT = "INSIDE_OPEN_ELEMENT" ; public static String INSIDE_END_TAG = "INSIDE_END_TAG" ; private EditorFileContext context ; private Hashtable additionalProposals = new Hashtable ( ) ; public XMLContentAssistProcessor ( EditorFileContext context ) { this . context = context ; contentAssistComparator = new XMLCompletionProposalComparator ( ) ; validator = new XMLContextInformationValidator ( this ) ; } public ICompletionProposal [ ] computeInnerCompletionProposals ( ITextViewer viewer , int offset , int position , LexemeList lexemeList , char activationChar , char previousChar ) { IMetadataEnvironment environment = getEnvironment ( lexemeList , offset ) ; additionalProposals . clear ( ) ; XMLContextLocation currentLocation = getLocation ( offset , lexemeList ) ; String tagPrefix = currentLocation . getTagName ( ) ; ICompletionProposal [ ] result = null ; if ( unifiedViewer != null && unifiedViewer . isHotkeyActivated ( ) ) { unifiedViewer . setHotkeyActivated ( false ) ; activationChar = DEFAULT_CHARACTER ; } if ( position < 0 ) { return null ; } Lexeme currentLexeme = lexemeList . get ( position ) ; if ( currentLocation . getLocation ( ) . equals ( ERROR ) ) { return result ; } if ( currentLocation . getLocation ( ) . equals ( INSIDE_END_TAG ) && currentLocation . getAttributes ( ) . size ( ) == 0 ) { return getTagCompletionProposals ( tagPrefix , previousChar , offset , currentLexeme , lexemeList , environment ) ; } if ( currentLocation . getLocation ( ) . equals ( OUTSIDE_ELEMENT ) && previousChar == '/' ) { return getTagCompletionProposals ( "" , activationChar , offset , currentLexeme , lexemeList , environment ) ; } if ( currentLocation . getLocation ( ) . equals ( OUTSIDE_ELEMENT ) && ( activationChar == '<' || activationChar == DEFAULT_CHARACTER ) ) { return getTagCompletionProposals ( "" , previousChar , offset , currentLexeme , lexemeList , environment ) ; } ArrayList attributes = currentLocation . getAttributes ( ) ; String attributePrefix = null ; String valuePrefix = null ; if ( attributes . size ( ) > 0 ) { KeyValuePair attribute = ( KeyValuePair ) attributes . get ( attributes . size ( ) - 1 ) ; attributePrefix = ( String ) attribute . getKey ( ) ; valuePrefix = ( String ) attribute . getValue ( ) ; } if ( currentLocation . getLocation ( ) . equals ( INSIDE_OPEN_ELEMENT ) ) { if ( ( previousChar == ' ' || previousChar == '\t' ) && tagPrefix != null ) { if ( XMLUtils . insideQuotedString ( currentLexeme , offset ) ) { return null ; } attributePrefix = "" ; if ( currentLexeme . getCategoryIndex ( ) != TokenCategories . ERROR ) { valuePrefix = null ; } } if ( attributePrefix == null || currentLexeme . typeIndex == XMLTokenTypes . START_TAG && currentLexeme . containsOffset ( offset ) ) { result = getTagCompletionProposals ( tagPrefix , previousChar , offset , currentLexeme , lexemeList , environment ) ; } else if ( valuePrefix != null ) { if ( valuePrefix . equals ( "/" ) ) { valuePrefix = "" ; } result = getAttributeValueCompletionProposals ( tagPrefix , attributePrefix , valuePrefix , offset , environment ) ; String strippedValue = StringUtils . trimStringQuotes ( valuePrefix ) ; setSelection ( strippedValue , result ) ; } else { Lexeme startTag = XMLUtils . getTagOpenLexeme ( currentLexeme , lexemeList ) ; Lexeme endTag = XMLUtils . getTagCloseLexeme ( currentLexeme , lexemeList ) ; Hashtable attribs = XMLUtils . gatherAttributes ( startTag , endTag , lexemeList ) ; boolean attributeQuoted = attribs . get ( attributePrefix ) == null ? false : true ; result = getAttributeCompletionProposals ( tagPrefix , attributePrefix , previousChar , attributes , attributeQuoted , offset , environment ) ; setSelection ( attributePrefix . toLowerCase ( ) , result ) ; } } return result ; } public ICompletionProposal [ ] getAttributeValueCompletionProposals ( String tagPrefix2 , String attributePrefix2 , String valuePrefix , int offset , IMetadataEnvironment environment ) { if ( tagPrefix2 == null || attributePrefix2 == null ) { return null ; } String strippedValue = StringUtils . trimStringQuotes ( valuePrefix ) ; ArrayList completionProposals = new ArrayList ( ) ; ArrayList addedFields = new ArrayList ( ) ; Hashtable fields = environment . getGlobalFields ( ) ; String tagNameLower = tagPrefix2 . toLowerCase ( ) ; String propertyNameLower = attributePrefix2 . toLowerCase ( ) ; String valueNameLower = strippedValue . toLowerCase ( ) ; int beginOffset = getOffsetForInsertion ( getXMLOffsetMapper ( ) . getCurrentLexeme ( ) , offset ) ; int replaceLength = valueNameLower . length ( ) ; Lexeme curLexeme = getXMLOffsetMapper ( ) . getCurrentLexeme ( ) ; if ( curLexeme . getCategoryIndex ( ) == TokenCategories . ERROR ) { beginOffset = curLexeme . offset ; } if ( valuePrefix . startsWith ( "\"" ) || valuePrefix . startsWith ( "'" ) ) { beginOffset ++ ; } int sortingType = XMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY ; ElementMetadata em = environment . getElement ( tagNameLower ) ; FieldMetadata fm = null ; if ( em == null ) { fm = ( FieldMetadata ) fields . get ( propertyNameLower ) ; } else { fm = ( FieldMetadata ) em . getFields ( ) . get ( propertyNameLower ) ; if ( fm == null ) { fm = ( FieldMetadata ) fields . get ( propertyNameLower ) ; } if ( fm == null ) { for ( String sm : em . getFields ( ) . keySet ( ) ) { if ( sm . toLowerCase ( ) . equals ( propertyNameLower ) ) { fm = ( FieldMetadata ) em . getFields ( ) . get ( sm ) ; break ; } } } } if ( fm != null ) { ICompletionProposal [ ] props = getFieldMetadataCompletionProposals ( em , fm , beginOffset , replaceLength , sortingType , valuePrefix ) ; if ( props != null ) { completionProposals . addAll ( Arrays . asList ( props ) ) ; } } try { if ( propertyNameLower . equals ( "src" ) ) { ICompletionProposal [ ] fileProps = getFilePathCompletionProposals ( valuePrefix , beginOffset , replaceLength , sortingType ) ; completionProposals . addAll ( Arrays . asList ( fileProps ) ) ; } } catch ( Exception ex ) { IdeLog . logError ( XMLPlugin . getDefault ( ) , "error computing file path" , ex ) ; } ICompletionProposal [ ] xPathProps = getXPathCompletionProposals ( propertyNameLower , beginOffset , replaceLength , sortingType ) ; completionProposals . addAll ( Arrays . asList ( xPathProps ) ) ; if ( additionalProposals . containsKey ( propertyNameLower ) ) { ArrayList addl = ( ArrayList ) additionalProposals . get ( fm . getName ( ) ) ; for ( int i = 0 ; i < addl . size ( ) ; i ++ ) { String s = ( String ) addl . get ( i ) ; String trimmedValue = StringUtils . trimStringQuotes ( StringUtils . trimStringQuotes ( s ) ) ; if ( trimmedValue . equals ( "" ) ) { continue ; } String replaceString = trimmedValue ; String displayString = trimmedValue ; int cursorPosition = replaceString . length ( ) ; XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconFieldGuess , displayString , null , "<b>" + trimmedValue + "</b><br>" + AUTO_ADDED , sortingType , unifiedViewer , null ) ; if ( cp != null && ! addedFields . contains ( s ) ) { addedFields . add ( s ) ; completionProposals . add ( cp ) ; } } } ICompletionProposal [ ] result = ( ICompletionProposal [ ] ) completionProposals . toArray ( new ICompletionProposal [ completionProposals . size ( ) ] ) ; Arrays . sort ( result , contentAssistComparator ) ; return result ; } public XMLContextLocation getLocation ( int offset , LexemeList ll ) { XMLContextLocation cl = new XMLContextLocation ( ) ; cl . setLocation ( OUTSIDE_ELEMENT ) ; if ( offset == 0 ) { return cl ; } int currentLexemePosition = computeCurrentLexemeIndex ( offset , ll ) ; KeyValuePair currentAttribute = null ; while ( currentLexemePosition >= 0 ) { Lexeme curLexeme = ll . get ( currentLexemePosition ) ; if ( curLexeme . typeIndex == XMLTokenTypes . NAME ) { boolean isAttributeValue = false ; if ( currentLexemePosition > 0 ) { Lexeme prev = ll . get ( currentLexemePosition - 1 ) ; if ( prev . typeIndex == XMLTokenTypes . EQUAL ) { isAttributeValue = true ; } } String lexemeText = curLexeme . getText ( ) ; if ( isAttributeValue ) { currentAttribute = new KeyValuePair ( "PLACEHOLDER" , lexemeText ) ; } else if ( currentAttribute != null ) { KeyValuePair foundAttribute = cl . find ( lexemeText ) ; if ( foundAttribute != null ) { cl . getAttributes ( ) . remove ( foundAttribute ) ; } cl . getAttributes ( ) . add ( 0 , new KeyValuePair ( lexemeText , currentAttribute . getValue ( ) ) ) ; currentAttribute = null ; } else { KeyValuePair foundAttribute = cl . find ( lexemeText ) ; if ( foundAttribute != null ) { cl . getAttributes ( ) . remove ( foundAttribute ) ; } cl . getAttributes ( ) . add ( 0 , new KeyValuePair ( lexemeText , null ) ) ; currentAttribute = null ; } } if ( curLexeme . typeIndex == XMLTokenTypes . EQUAL ) { if ( currentAttribute == null ) { currentAttribute = new KeyValuePair ( "PLACEHOLDER" , "" ) ; } } if ( curLexeme . typeIndex == XMLTokenTypes . STRING ) { currentAttribute = new KeyValuePair ( "PLACEHOLDER" , curLexeme . getText ( ) ) ; } if ( curLexeme . typeIndex == XMLTokenTypes . START_TAG ) { cl . setTagName ( curLexeme . getText ( ) . replaceAll ( "<" , "" ) ) ; } if ( curLexeme . typeIndex == XMLTokenTypes . END_TAG ) { cl . setTagName ( curLexeme . getText ( ) . replaceAll ( "</" , "" ) ) ; cl . setLocation ( INSIDE_END_TAG ) ; break ; } if ( curLexeme . typeIndex == XMLTokenTypes . GREATER_THAN ) { cl . setLocation ( OUTSIDE_ELEMENT ) ; break ; } if ( curLexeme . typeIndex == XMLTokenTypes . ERROR && curLexeme . getText ( ) . equals ( "/" ) ) { cl . setLocation ( ERROR ) ; break ; } if ( curLexeme . typeIndex == XMLTokenTypes . SLASH_GREATER_THAN && ( curLexeme . containsOffset ( offset ) || offset > curLexeme . getEndingOffset ( ) ) ) { cl . setLocation ( OUTSIDE_ELEMENT ) ; break ; } if ( curLexeme . typeIndex == XMLTokenTypes . START_TAG || curLexeme . typeIndex == XMLTokenTypes . ERROR && curLexeme . getText ( ) . equals ( "<" ) ) { cl . setLocation ( INSIDE_OPEN_ELEMENT ) ; break ; } currentLexemePosition -- ; } return cl ; } public char [ ] getCompletionProposalAutoActivationCharacters ( ) { return new char [ ] { '<' , '/' , ' ' , '\t' , '=' , '>' } ; } public char [ ] getContextInformationAutoActivationCharacters ( ) { return new char [ ] { '=' } ; } public int [ ] getCompletionProposalSeparatorLexemes ( ) { return new int [ ] { XMLTokenTypes . GREATER_THAN , XMLTokenTypes . SLASH_GREATER_THAN , XMLTokenTypes . EQUAL , XMLTokenTypes . START_TAG , XMLTokenTypes . END_TAG } ; } public int [ ] getCompletionProposalIdleActivationTokens ( ) { return new int [ ] { XMLTokenTypes . START_TAG , XMLTokenTypes . END_TAG , XMLTokenTypes . NAME } ; } public IContextInformationValidator getContextInformationValidator ( ) { return validator ; } public String getErrorMessage ( ) { return null ; } public static int getOffsetForInsertion ( Lexeme curLexeme , int offset ) { if ( curLexeme == null ) { return offset ; } int beginOffset = offset ; if ( curLexeme . typeIndex == XMLTokenTypes . TEXT ) { return beginOffset ; } if ( curLexeme . getCategoryIndex ( ) == TokenCategories . KEYWORD || curLexeme . getCategoryIndex ( ) == TokenCategories . LITERAL || XMLUtils . isStartTag ( curLexeme ) || XMLUtils . isEndTag ( curLexeme ) ) { beginOffset = curLexeme . getStartingOffset ( ) ; } return beginOffset ; } public ICompletionProposal [ ] getAttributeCompletionProposals ( String tagPrefix , String attributePrefix , char activationChar , ArrayList addedAttributes , boolean hasAttachedValue , int offset , IMetadataEnvironment environment ) { if ( tagPrefix == null ) { return null ; } Hashtable completionProposals = new Hashtable ( ) ; String tagPrefixLower = tagPrefix . toLowerCase ( ) ; String attributePrefixLower = attributePrefix . toLowerCase ( ) ; ElementMetadata em = environment . getElement ( tagPrefixLower ) ; if ( em == null ) { return null ; } int beginOffset = offset ; Lexeme curLexeme = getXMLOffsetMapper ( ) . getCurrentLexeme ( ) ; if ( curLexeme . typeIndex == XMLTokenTypes . NAME ) { beginOffset = curLexeme . getStartingOffset ( ) ; } Iterator iter = em . getFields ( ) . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { FieldMetadata fm = ( FieldMetadata ) iter . next ( ) ; XMLCompletionProposal cp = createFieldProposal ( attributePrefixLower , beginOffset , em , fm , hasAttachedValue , environment ) ; completionProposals . put ( fm . getName ( ) , cp ) ; } Iterator iterEvents = em . getEvents ( ) . values ( ) . iterator ( ) ; while ( iterEvents . hasNext ( ) ) { EventMetadata evm = ( EventMetadata ) iterEvents . next ( ) ; XMLCompletionProposal cp = createEventProposal ( attributePrefixLower , beginOffset , em , evm , hasAttachedValue , environment ) ; completionProposals . put ( evm . getName ( ) , cp ) ; } ICompletionProposal [ ] result = ( ICompletionProposal [ ] ) completionProposals . values ( ) . toArray ( new ICompletionProposal [ completionProposals . size ( ) ] ) ; Arrays . sort ( result , contentAssistComparator ) ; return result ; } public XMLCompletionProposal createFieldProposal ( String attributePrefix , int beginOffset , ElementMetadata em , FieldMetadata fm , boolean hasAttachedValue , IMetadataEnvironment environment ) { String docText = environment . getFieldDocumentation ( fm ) ; String replaceString = fm . getName ( ) ; String quoteString = XMLUtils . quoteAttributeValue ( getPreferenceStore ( ) , "" ) ; boolean insertEquals = XMLUtils . insertEquals ( getPreferenceStore ( ) ) ; if ( ! hasAttachedValue && insertEquals ) { replaceString = replaceString + "=" + quoteString ; } String displayString = fm . getName ( ) ; int cursorPosition = replaceString . length ( ) ; if ( ! hasAttachedValue && insertEquals && quoteString . length ( ) == 2 ) { cursorPosition -- ; } int replaceLength = attributePrefix . length ( ) ; Image [ ] userAgents = null ; if ( fm . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImagesA ( getUserAgents ( ) , em . getUserAgentPlatformNames ( ) ) ; } else { userAgents = getUserAgentImagesA ( getUserAgents ( ) , fm . getUserAgentPlatformNames ( ) ) ; } XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconField , displayString , null , docText , XMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , userAgents ) ; return cp ; } public Image [ ] getUserAgentImagesA ( String [ ] a , String [ ] b ) { return new Image [ 0 ] ; } public XMLCompletionProposal createEventProposal ( String attributePrefix , int beginOffset , ElementMetadata em , EventMetadata fm , boolean hasAttachedValue , IMetadataEnvironment environment ) { String docText = environment . getEventDocumentation ( fm ) ; String replaceString = fm . getName ( ) ; String quoteString = XMLUtils . quoteAttributeValue ( getPreferenceStore ( ) , "" ) ; boolean insertEquals = XMLUtils . insertEquals ( getPreferenceStore ( ) ) ; if ( ! hasAttachedValue && insertEquals ) { replaceString = replaceString + "=" + quoteString ; } String displayString = fm . getName ( ) ; int cursorPosition = replaceString . length ( ) ; int replaceLength = attributePrefix . length ( ) ; if ( ! hasAttachedValue && insertEquals && quoteString . length ( ) == 2 ) { cursorPosition -- ; } Image [ ] userAgents = null ; if ( fm . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImagesA ( getUserAgents ( ) , em . getUserAgentPlatformNames ( ) ) ; } else { userAgents = getUserAgentImagesA ( getUserAgents ( ) , fm . getUserAgentPlatformNames ( ) ) ; } XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconEvent , displayString , null , docText , XMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , userAgents ) ; return cp ; } public ICompletionProposal [ ] getTagCompletionProposals ( String prefix , char activationChar , int offset , Lexeme currentLexeme , LexemeList lexemeList , IMetadataEnvironment environment ) { IParseState parseState = context . getParseState ( ) ; XMLParseState htmlParseState = ( XMLParseState ) parseState . getParseState ( XMLMimeType . MimeType ) ; Hashtable completionProposals = new Hashtable ( ) ; if ( currentLexeme == null ) { return null ; } if ( currentLexeme . typeIndex != XMLTokenTypes . TEXT && ! XMLUtils . isStartTag ( currentLexeme ) && ! XMLUtils . isEndTag ( currentLexeme ) ) { return null ; } int tagClosedType = XMLUtils . isTagClosed ( currentLexeme , lexemeList ) ; boolean tagClosed = tagClosedType != XMLUtils . TAG_OPEN ; String textPrefix = XMLUtils . getOpenTagName ( currentLexeme , offset ) ; if ( tagClosed ) { textPrefix = XMLUtils . getOpenTagName ( currentLexeme , currentLexeme . getEndingOffset ( ) ) ; } if ( currentLexeme . typeIndex == XMLTokenTypes . TEXT ) { textPrefix = "" ; } String testPrefix = textPrefix . toLowerCase ( ) ; int beginOffset = getOffsetForInsertion ( currentLexeme , offset ) ; String [ ] em = environment != null ? environment . getAllElements ( ) : new String [ 0 ] ; MetadataEnvironment [ ] environments = ( ( MetadataRuntimeEnvironment ) environment ) . getEnvironments ( ) ; for ( int i = 0 ; i < em . length ; i ++ ) { String e = em [ i ] ; String docText = environment . getElementDocumentation ( e ) ; String displayString = e ; String replaceString = e ; int replaceLength = textPrefix . length ( ) ; int cursorPosition = replaceString . length ( ) ; if ( XMLUtils . isEndTag ( currentLexeme ) ) { if ( tagClosed ) { replaceString = XMLUtils . createOpenTag ( replaceString , false ) ; } else { replaceString = XMLUtils . createOpenTag ( replaceString , true ) ; } replaceLength = currentLexeme . length ; cursorPosition = replaceString . length ( ) ; } else { boolean insertClosingTags = true ; if ( getPreferenceStore ( ) != null ) { insertClosingTags = getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . AUTO_INSERT_CLOSE_TAGS ) ; } if ( insertClosingTags ) { int cursorOffset = 1 ; boolean empty = true ; for ( MetadataEnvironment ea : environments ) { ElementMetadata element = ea . getElement ( e ) ; boolean emptyTag = ( element instanceof IKnowsChildsMetadata ) ? ! ( ( IKnowsChildsMetadata ) element ) . mayHaveChilds ( ) : false ; if ( ! emptyTag ) { empty = false ; break ; } } boolean isDocType = replaceString != null && replaceString . toLowerCase ( ) . startsWith ( "!doctype" ) ; String startString = null ; if ( empty && ! tagClosed ) { startString = XMLUtils . createSelfClosedTag ( replaceString ) ; cursorOffset = 2 ; } else { startString = XMLUtils . createOpenTag ( replaceString , ! tagClosed ) ; } cursorPosition = startString . length ( ) ; if ( ! tagClosed && ! XMLUtils . isStartTagBalanced ( currentLexeme , lexemeList , htmlParseState ) && ! empty && ! isDocType ) { replaceString = startString + XMLUtils . createCloseTag ( replaceString , true ) ; cursorOffset = 1 ; } else { replaceString = startString ; } if ( ! tagClosed ) { cursorPosition = cursorPosition - cursorOffset ; } } else { replaceString = XMLUtils . createOpenTag ( replaceString , false ) ; cursorPosition = replaceString . length ( ) ; } if ( currentLexeme . typeIndex != XMLTokenTypes . TEXT ) { replaceLength ++ ; } } XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconTag , displayString , null , docText , XMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , getUserAgentImagesA ( getUserAgents ( ) , environment . getUserAgentPlatformNames ( e ) ) ) ; completionProposals . put ( displayString , cp ) ; } boolean addedCloseTag = false ; Lexeme unclosed = XMLUtils . getPreviousUnclosedTag ( currentLexeme , lexemeList , htmlParseState ) ; if ( unclosed != null && ! XMLUtils . isStartTagBalanced ( unclosed , lexemeList , htmlParseState ) ) { String displayString = XMLUtils . stripTagEndings ( unclosed . getText ( ) ) ; String replaceString = displayString ; boolean emptyTag = false ; if ( ! emptyTag ) { addedCloseTag = true ; if ( tagClosed ) { replaceString = XMLUtils . createCloseTag ( replaceString , false ) ; } else { replaceString = XMLUtils . createCloseTag ( replaceString , true ) ; } int replaceLength = getReplaceLengthByLexeme ( currentLexeme , activationChar ) ; int cursorPosition = replaceString . length ( ) ; displayString = "/" + displayString ; ElementMetadata elementMetadata = new ElementMetadata ( ) ; elementMetadata . setFullName ( displayString ) ; elementMetadata . setName ( displayString ) ; ElementMetadata e = environment != null ? environment . getElement ( unclosed ) : elementMetadata ; String docText = null ; if ( e != null ) { docText = environment != null ? environment . getElementDocumentation ( e . getName ( ) ) : "" ; } XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconTag , displayString , null , docText , XMLCompletionProposalComparator . OBJECT_TYPE_PROPERTY , unifiedViewer , NO_BROWSER_IMAGES ) ; completionProposals . put ( displayString , cp ) ; } } ICompletionProposal [ ] result = ( ICompletionProposal [ ] ) completionProposals . values ( ) . toArray ( new ICompletionProposal [ completionProposals . size ( ) ] ) ; Arrays . sort ( result , contentAssistComparator ) ; if ( XMLUtils . isEndTag ( currentLexeme ) && addedCloseTag ) { setSelection ( "/" + testPrefix , result ) ; } else { setSelection ( testPrefix , result ) ; } return result ; } public IOffsetMapper getOffsetMapper ( ) { IFileLanguageService ls = this . context . getLanguageService ( XMLMimeType . MimeType ) ; if ( ls != null ) { return ls . getOffsetMapper ( ) ; } else { return null ; } } public XMLOffsetMapper getXMLOffsetMapper ( ) { return ( XMLOffsetMapper ) getOffsetMapper ( ) ; } protected IPreferenceStore getPreferenceStore ( ) { if ( PluginUtils . isPluginLoaded ( XMLPlugin . getDefault ( ) ) ) { return XMLPlugin . getDefault ( ) . getPreferenceStore ( ) ; } else { return null ; } } public IContextInformation [ ] computeInnerContextInformation ( String documentSource , int offset , int position , LexemeList lexemeList ) { IMetadataEnvironment environment = getEnvironment ( lexemeList , offset ) ; IContextInformation [ ] ici = null ; XMLContextLocation currentLocation = getLocation ( offset , lexemeList ) ; String tagPrefix = currentLocation . getTagName ( ) ; if ( tagPrefix == null ) { return null ; } Hashtable fields = environment . getGlobalFields ( ) ; ArrayList attributes = currentLocation . getAttributes ( ) ; if ( attributes . size ( ) == 0 ) { return null ; } KeyValuePair attribute = ( KeyValuePair ) attributes . get ( attributes . size ( ) - 1 ) ; String propertyNameLower = ( ( String ) attribute . getKey ( ) ) . toLowerCase ( ) ; FieldMetadata fm = ( FieldMetadata ) fields . get ( propertyNameLower ) ; if ( fm == null || fm . getValues ( ) . size ( ) > 0 ) { return null ; } ContextInformation ci = new ContextInformation ( "contextDisplayString" , fm . getDescription ( ) ) ; if ( ci != null ) { ici = new IContextInformation [ ] { ci } ; } return ici ; } private IMetadataEnvironment getEnvironment ( LexemeList lexemeList , int offset ) { return XMLEnvironmentRegistry . getEnvironment ( lexemeList , offset ) ; } public Comparator getProposalComparator ( ) { return contentAssistComparator ; } private ICompletionProposal [ ] getFilePathCompletionProposals ( String valuePrefix , int beginOffset , int replaceLength , int sortingType ) { ArrayList completionProposals = new ArrayList ( ) ; Map < String , Image > ht = new HashMap < String , Image > ( ) ; IEditorInput pathEditor = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getActiveEditor ( ) . getEditorInput ( ) ; String urlPrefix = null ; if ( pathEditor instanceof FileEditorInput ) { urlPrefix = getProjectContextRoot ( pathEditor ) ; } String editorPath = CoreUIUtils . getPathFromEditorInput ( pathEditor ) ; if ( urlPrefix != null && ! "" . equals ( urlPrefix ) && valuePrefix != null && valuePrefix . indexOf ( '/' ) == 1 ) { editorPath = urlPrefix ; } String currentPath = editorPath ; if ( valuePrefix != null ) { String s = StringUtils . trimStringQuotes ( valuePrefix ) ; if ( ! "" . equals ( s ) ) { File current = new File ( currentPath ) ; if ( current . isDirectory ( ) ) { currentPath = currentPath + s ; } else { currentPath = current . getParent ( ) . toString ( ) + File . separator + s ; } } } File [ ] files = FileUtils . getFilesInDirectory ( new File ( currentPath ) ) ; if ( files == null ) { return new ICompletionProposal [ 0 ] ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . getName ( ) . startsWith ( "." ) ) { continue ; } String fileType = "" ; try { fileType = FileSystemView . getFileSystemView ( ) . getSystemTypeDescription ( f ) ; } catch ( Exception ex ) { IdeLog . logError ( XMLPlugin . getDefault ( ) , "Type Description Error" , ex ) ; } if ( f . toString ( ) . equals ( editorPath ) ) { continue ; } Image image = null ; if ( fileType != null ) { image = ( Image ) ht . get ( fileType ) ; } if ( image == null ) { image = fIconFile ; if ( f . isDirectory ( ) ) { image = fIconFolder ; } } String replaceString = FileUtils . makeFilePathRelative ( new File ( editorPath ) , f ) ; replaceString = replaceString . replaceAll ( "\\\\" , "/" ) ; String displayString = CoreUIUtils . getPathFromURI ( replaceString ) ; int cursorPosition = replaceString . length ( ) ; XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , image , displayString , null , f . toString ( ) , sortingType , unifiedViewer , new Image [ 0 ] ) ; if ( cp != null ) { completionProposals . add ( cp ) ; } } return ( ICompletionProposal [ ] ) completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private String getProjectContextRoot ( IEditorInput input ) { String urlPrefix = null ; FileEditorInput fei = ( FileEditorInput ) input ; IFile file = fei . getFile ( ) ; IProject project = file . getProject ( ) ; urlPrefix = project . getLocation ( ) . toOSString ( ) ; return urlPrefix ; } public ICompletionProposal [ ] getXPathCompletionProposals ( String attributeName , int offset , int replaceLength , int sortingType ) { ArrayList completionProposals = new ArrayList ( ) ; IParseNode root = context . getParseState ( ) . getRoot ( ) . getParseResults ( ) ; String editors = null ; if ( getPreferenceStore ( ) != null ) { editors = getPreferenceStore ( ) . getString ( com . aptana . ide . editors . preferences . IPreferenceConstants . CODE_ASSIST_EXPRESSIONS ) ; } CodeAssistExpression [ ] expressions = CodeAssistExpression . deserializeErrorDescriptors ( editors ) ; for ( int i = 0 ; i < expressions . length ; i ++ ) { CodeAssistExpression expression = expressions [ i ] ; if ( attributeName . matches ( expression . getExpression ( ) ) ) { try { XPath xpath = new ParseNodeXPath ( expression . getXPath ( ) ) ; Object result = xpath . evaluate ( root ) ; if ( result instanceof List ) { List xpathResult = ( List ) result ; for ( Iterator iter = xpathResult . iterator ( ) ; iter . hasNext ( ) ; ) { Object element = ( Object ) iter . next ( ) ; if ( element instanceof ParseNodeAttribute ) { ParseNodeAttribute pna = ( ParseNodeAttribute ) element ; String replaceString = pna . getValue ( ) ; int cursorPosition = replaceString . length ( ) ; XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , offset , replaceLength , cursorPosition , fIconFieldGuess , replaceString , null , "<b>" + replaceString + "</b><br>" + AUTO_ADDED , sortingType , unifiedViewer , null ) ; if ( cp != null ) { completionProposals . add ( cp ) ; } } } } } catch ( JaxenException e ) { IdeLog . logError ( XMLPlugin . getDefault ( ) , e . getMessage ( ) ) ; } } } return ( ICompletionProposal [ ] ) completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private ICompletionProposal [ ] getFieldMetadataCompletionProposals ( ElementMetadata em , FieldMetadata fm , int beginOffset , int replaceLength , int sortingType , String valuePrefix ) { ArrayList completionProposals = new ArrayList ( ) ; ArrayList values = fm . getValues ( ) ; if ( fm instanceof IProvidingCompletionMetadata ) { IProvidingCompletionMetadata cm = ( IProvidingCompletionMetadata ) fm ; String sourceURI = this . context . getSourceProvider ( ) . getSourceURI ( ) ; String path ; try { URL url = new URL ( sourceURI ) ; String file = url . getFile ( ) ; path = new File ( file ) . getAbsolutePath ( ) ; values . addAll ( cm . getFieldMetadataCompletionProposals ( em , fm , valuePrefix , path ) ) ; } catch ( MalformedURLException e ) { IdeLog . logError ( XMLPlugin . getDefault ( ) , e . getMessage ( ) , e ) ; } } for ( int i = 0 ; i < values . size ( ) ; i ++ ) { ValueMetadata value = ( ValueMetadata ) fm . getValues ( ) . get ( i ) ; if ( value . getName ( ) != "*" ) { String docText = "" ; docText = MetadataEnvironment . getValueDocumentation ( value ) ; String replaceString = value . getName ( ) ; String displayString = value . getName ( ) ; if ( replaceString . equals ( "*" ) ) { replaceString = "" ; } int cursorPosition = replaceString . length ( ) ; Image [ ] userAgents = null ; if ( value . getUserAgents ( ) . length == 0 && fm . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImagesA ( getUserAgents ( ) , em . getUserAgentPlatformNames ( ) ) ; } else if ( value . getUserAgents ( ) . length == 0 ) { userAgents = getUserAgentImagesA ( getUserAgents ( ) , fm . getUserAgentPlatformNames ( ) ) ; } else { userAgents = getUserAgentImagesA ( getUserAgents ( ) , value . getUserAgentPlatformNames ( ) ) ; } XMLCompletionProposal cp = new XMLCompletionProposal ( replaceString , beginOffset , replaceLength , cursorPosition , fIconField , displayString , null , docText , sortingType , unifiedViewer , userAgents ) ; if ( cp != null ) { completionProposals . add ( cp ) ; } } } return ( ICompletionProposal [ ] ) completionProposals . toArray ( new ICompletionProposal [ 0 ] ) ; } private int getReplaceLengthByLexeme ( Lexeme lexeme , char activationChar ) { String text = lexeme . getText ( ) ; String trimmed = text . trim ( ) ; int result = trimmed . length ( ) ; if ( activationChar == '\0' && lexeme . typeIndex == XMLTokenTypes . END_TAG ) { result = Math . max ( result , 2 ) ; } return result ; } } 