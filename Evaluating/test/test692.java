public class PasswordProvider extends org . eclipse . equinox . security . storage . provider . PasswordProvider { private static final String ALGORITHM = "AES/ECB/PKCS5Padding" ; private String accountName = System . getProperty ( "user.home" ) ; @ Override public PBEKeySpec getPassword ( IPreferencesContainer container , int passwordType ) { if ( accountName == null ) return null ; final boolean newPassword = ( ( passwordType & CREATE_NEW_PASSWORD ) != 0 ) ; final boolean passwordChange = ( ( passwordType & PASSWORD_CHANGE ) != 0 ) ; try { if ( ! newPassword && ! passwordChange ) { char [ ] existing = getPassword ( ) ; if ( existing != null && existing . length != 0 ) return new PBEKeySpec ( existing ) ; } if ( ! useUI ( ) ) return null ; final String [ ] result = new String [ 1 ] ; PlatformUI . getWorkbench ( ) . getDisplay ( ) . syncExec ( new Runnable ( ) { public void run ( ) { StorageLoginDialog loginDialog = new StorageLoginDialog ( Display . getDefault ( ) . getActiveShell ( ) , newPassword , passwordChange ) ; if ( loginDialog . open ( ) == Window . OK ) result [ 0 ] = loginDialog . getPassword ( ) ; else result [ 0 ] = null ; } } ) ; String password = result [ 0 ] ; if ( password == null || password . trim ( ) . length ( ) == 0 ) return null ; writePassword ( password ) ; return new PBEKeySpec ( password . toCharArray ( ) ) ; } catch ( IOException e ) { IdeLog . logError ( Activator . getDefault ( ) , e . getMessage ( ) , e ) ; } return null ; } private static boolean useUI ( ) { return PlatformUI . isWorkbenchRunning ( ) ; } private void writePassword ( String password ) throws IOException { SecretKeySpec key = getKeySpec ( ) ; byte [ ] encrypted = encrypt ( key , password ) ; if ( encrypted != null && encrypted . length > 0 ) { String b64 = Base64 . encodeBytes ( encrypted ) ; FileUtils . writeStringToFile ( b64 , getPasswordFile ( ) ) ; } } private char [ ] getPassword ( ) throws IOException { String encrypted = getEncryptedPassword ( ) ; if ( encrypted == null ) return new char [ 0 ] ; byte [ ] bytes = Base64 . decode ( encrypted ) ; if ( bytes != null ) { SecretKeySpec key = getKeySpec ( ) ; byte [ ] decrypted = decrypt ( key , bytes ) ; if ( decrypted == null || decrypted . length == 0 ) return new char [ 0 ] ; return new String ( decrypted ) . toCharArray ( ) ; } else { return new char [ 0 ] ; } } private String getEncryptedPassword ( ) throws IOException { File file = getPasswordFile ( ) ; if ( ! file . exists ( ) ) return null ; return FileUtils . readContent ( file ) ; } private File getPasswordFile ( ) throws IOException { File file = new File ( accountName + File . separator + ".aptanasecure" , ".store" ) ; file . getParentFile ( ) . mkdirs ( ) ; return file ; } private SecretKeySpec getKeySpec ( ) { String ksPref = Platform . getPreferencesService ( ) . getString ( AptanaCorePlugin . ID , IPreferenceConstants . CACHED_KEY , "" , null ) ; byte [ ] key = null ; if ( ! "" . equals ( ksPref ) ) { try { byte [ ] bytes = Base64 . decode ( ksPref ) ; if ( bytes != null ) { key = bytes ; } } catch ( Exception e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_UnableToDecodeExistingKey , e ) ; } } KeyGenerator kgen ; if ( key == null || key . length == 0 ) { try { kgen = KeyGenerator . getInstance ( "AES" ) ; kgen . init ( 128 ) ; SecretKey skey = kgen . generateKey ( ) ; key = skey . getEncoded ( ) ; String b64 = Base64 . encodeBytes ( skey . getEncoded ( ) ) ; IEclipsePreferences node = new InstanceScope ( ) . getNode ( AptanaCorePlugin . ID ) ; node . put ( IPreferenceConstants . CACHED_KEY , b64 ) ; node . flush ( ) ; } catch ( NoSuchAlgorithmException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchAlgorithm , e ) ; return null ; } catch ( BackingStoreException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , com . aptana . ide . security . internal . linux . Messages . PasswordProvider_ERR_UnableToStoreKey , e ) ; return null ; } } return new SecretKeySpec ( key , "AES" ) ; } private byte [ ] encrypt ( SecretKeySpec skeySpec , String password ) { try { Cipher cipher = Cipher . getInstance ( ALGORITHM ) ; cipher . init ( Cipher . ENCRYPT_MODE , skeySpec ) ; return cipher . doFinal ( password . getBytes ( ) ) ; } catch ( NoSuchAlgorithmException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchAlgorithm , e ) ; } catch ( NoSuchPaddingException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchPadding , e ) ; } catch ( InvalidKeyException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_InvalidKey , e ) ; } catch ( IllegalBlockSizeException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_IllegalBlockSize , e ) ; } catch ( BadPaddingException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_BadPadding , e ) ; } return null ; } private byte [ ] decrypt ( SecretKeySpec skeySpec , byte [ ] encryptedPassword ) { try { Cipher cipher = Cipher . getInstance ( ALGORITHM ) ; cipher . init ( Cipher . DECRYPT_MODE , skeySpec ) ; return cipher . doFinal ( encryptedPassword ) ; } catch ( NoSuchAlgorithmException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchAlgorithm , e ) ; } catch ( NoSuchPaddingException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchPadding , e ) ; } catch ( InvalidKeyException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_InvalidKey , e ) ; } catch ( IllegalBlockSizeException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_IllegalBlockSize , e ) ; } catch ( BadPaddingException e ) { IdeLog . logError ( AptanaCorePlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_BadPadding , e ) ; } return null ; } } 