public class MicrodataChecker extends Checker { class Element { public final Locator locator ; public final String [ ] itemProp ; public final String [ ] itemRef ; public final boolean itemScope ; public final List < Element > children ; private final int order ; public Element ( Locator locator , String [ ] itemProp , String [ ] itemRef , boolean itemScope ) { this . locator = locator ; this . itemProp = itemProp ; this . itemRef = itemRef ; this . itemScope = itemScope ; this . children = new LinkedList < Element > ( ) ; this . order = counter ++ ; } @ Override public boolean equals ( Object that ) { return this == that ; } @ Override public int hashCode ( ) { return order ; } class Builder { public final Builder parent ; public final int depth ; public Builder ( Builder parent , int depth ) { this . parent = parent ; this . depth = depth ; } public void appendChild ( Element elm ) { Element . this . children . add ( elm ) ; } } } private int depth ; private Element . Builder builder ; private static int counter ; private List < Element > items ; private Set < Element > properties ; private Map < String , Element > idmap ; private Locator locator ; @ Override public void reset ( ) { depth = 0 ; builder = null ; counter = 0 ; items = new LinkedList < Element > ( ) ; properties = new LinkedHashSet < Element > ( ) ; idmap = new HashMap < String , Element > ( ) ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { depth ++ ; if ( "http://www.w3.org/1999/xhtml" != uri ) { return ; } String id = null ; String [ ] itemProp = null ; String [ ] itemRef = null ; boolean itemScope = false ; int len = atts . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( atts . getURI ( i ) . isEmpty ( ) ) { String attLocal = atts . getLocalName ( i ) ; String attValue = atts . getValue ( i ) ; if ( "id" == attLocal ) { id = attValue ; } else if ( "itemprop" == attLocal ) { itemProp = AttributeUtil . split ( attValue ) ; } else if ( "itemref" == attLocal ) { itemRef = AttributeUtil . split ( attValue ) ; } else if ( "itemscope" == attLocal ) { itemScope = true ; } } } if ( id != null || itemProp != null || itemScope == true ) { Element elm = new Element ( new LocatorImpl ( locator ) , itemProp , itemRef , itemScope ) ; if ( itemProp != null ) { properties . add ( elm ) ; } else if ( itemScope ) { items . add ( elm ) ; } if ( ! idmap . containsKey ( id ) ) { idmap . put ( id , elm ) ; } if ( builder != null ) { builder . appendChild ( elm ) ; } builder = elm . new Builder ( builder , depth ) ; } } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( builder != null && builder . depth == depth ) { builder = builder . parent ; } depth -- ; } @ Override public void endDocument ( ) throws SAXException { for ( Element item : items ) { checkItem ( item , new ArrayDeque < Element > ( ) ) ; } for ( Element prop : properties ) { err ( "The “itemprop” attribute was specified, but the element is not a property of any item." , prop . locator ) ; } } private void checkItem ( Element root , Deque < Element > parents ) throws SAXException { Deque < Element > pending = new ArrayDeque < Element > ( ) ; Set < Element > memory = new HashSet < Element > ( ) ; memory . add ( root ) ; for ( Element child : root . children ) { pending . push ( child ) ; } if ( root . itemRef != null ) { for ( String id : root . itemRef ) { Element refElm = idmap . get ( id ) ; if ( refElm != null ) { pending . push ( refElm ) ; } else { err ( "The “itemref” attribute referenced “" + id + "”, but there is no element with an “id” attribute with that value." , root . locator ) ; } } } boolean memoryError = false ; while ( pending . size ( ) > 0 ) { Element current = pending . pop ( ) ; if ( memory . contains ( current ) ) { memoryError = true ; continue ; } memory . add ( current ) ; if ( ! current . itemScope ) { for ( Element child : current . children ) { pending . push ( child ) ; } } if ( current . itemProp != null ) { properties . remove ( current ) ; if ( current . itemScope ) { if ( ! parents . contains ( current ) ) { parents . push ( root ) ; checkItem ( current , parents ) ; parents . pop ( ) ; } else { err ( "The “itemref” attribute created a circular reference with another item." , current . locator ) ; } } } } if ( memoryError ) { err ( "The “itemref” attribute contained redundant references." , root . locator ) ; } } @ Override public void setDocumentLocator ( Locator locator ) { this . locator = locator ; } } 