<<<<<<< HEAD
public abstract class UnifiedContentAssistProcessor implements IUnifiedContentAssistProcessor { public static final String USERAGENT_ID = "userAgent" ; public static final String USERAGENT_ELEMENT = "user-agent" ; public static final String ATTR_USER_AGENT_NAME = "name" ; public static final String ATTR_USER_AGENT_ID = "id" ; public static final String ATTR_ICON = "icon" ; public static final String ATTR_ICON_DISABLED = "icon-disabled" ; protected IUnifiedViewer unifiedViewer = null ; public static char DEFAULT_CHARACTER = '\0' ; private List _contributors = new ArrayList ( ) ; private static HashMap agentImages = new HashMap ( ) ; private static List agentNames = new ArrayList ( ) ; static { try { loadUserAgents ( ) ; } catch ( Exception ex ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedContentAssistProcessor_ERR_UnableToLoadUserAgents , ex ) ; } } public static String [ ] getUserAgents ( ) { if ( PluginUtils . isPluginLoaded ( UnifiedEditorsPlugin . getDefault ( ) ) ) { IPreferenceStore prefs = UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) ; String agents = prefs . getString ( IPreferenceConstants . USER_AGENT_PREFERENCE ) ; return agents . split ( "," ) ; } else { return new String [ ] { Messages . UnifiedContentAssistProcessor_IE , Messages . UnifiedContentAssistProcessor_Mozilla } ; } } public static void addUserAgent ( String id , String name , Image normal , Image disabled ) { agentImages . put ( id , normal ) ; agentImages . put ( id + "Grey" , disabled ) ; agentNames . add ( id ) ; } private static void loadUserAgents ( ) { IExtensionRegistry registry = Platform . getExtensionRegistry ( ) ; if ( registry != null ) { IExtensionPoint extensionPoint = registry . getExtensionPoint ( UnifiedEditorsPlugin . ID , USERAGENT_ID ) ; if ( extensionPoint != null ) { IExtension [ ] extensions = extensionPoint . getExtensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { IExtension extension = extensions [ i ] ; IConfigurationElement [ ] elements = extension . getConfigurationElements ( ) ; for ( int j = 0 ; j < elements . length ; j ++ ) { IConfigurationElement element = elements [ j ] ; if ( element . getName ( ) . equals ( USERAGENT_ELEMENT ) ) { String agentID = element . getAttribute ( ATTR_USER_AGENT_ID ) ; String agentName = element . getAttribute ( ATTR_USER_AGENT_NAME ) ; String agentIconPath = element . getAttribute ( ATTR_ICON ) ; String agentIconDisabledPath = element . getAttribute ( ATTR_ICON_DISABLED ) ; if ( agentID != null ) { IExtension ext = element . getDeclaringExtension ( ) ; String pluginId = ext . getNamespaceIdentifier ( ) ; Bundle bundle = Platform . getBundle ( pluginId ) ; if ( agentIconPath == null || agentIconDisabledPath == null ) { continue ; } Image agentIcon = SWTUtils . getImage ( bundle , agentIconPath ) ; Image agentIconDisabled = SWTUtils . getImage ( bundle , agentIconDisabledPath ) ; if ( agentIcon != null && agentIconDisabled != null ) { addUserAgent ( agentID , agentName , agentIcon , agentIconDisabled ) ; } } } } } } } } public static String [ ] getDefaultUserAgents ( ) { return ( String [ ] ) agentNames . toArray ( new String [ 0 ] ) ; } public static HashMap getUserAgentImages ( ) { return agentImages ; } public abstract int [ ] getCompletionProposalIdleActivationTokens ( ) ; public char [ ] getCompletionProposalAutoActivationCharacters ( ) { return new char [ ] { } ; } public int [ ] getCompletionProposalSeparatorLexemes ( ) { return new int [ ] { } ; } public char [ ] getContextInformationAutoActivationCharacters ( ) { return new char [ ] { } ; } public char [ ] getCompletionProposalPrivateActivationCharacters ( ) { return new char [ ] { } ; } public char [ ] getCompletionProposalAllActivationCharacters ( ) { char [ ] allActivationChars = combine ( getCompletionProposalAutoActivationCharacters ( ) , getContextInformationAutoActivationCharacters ( ) ) ; Arrays . sort ( allActivationChars ) ; return allActivationChars ; } public boolean isValidIdleActivationLocation ( ITextViewer viewer , int offset ) { Lexeme currentLexeme = this . getOffsetMapper ( ) . getCurrentLexeme ( ) ; return isValidIdleActivationToken ( currentLexeme , getCompletionProposalIdleActivationTokens ( ) ) ; } public void addCompletionProposalContributor ( ICompletionProposalContributor contributor ) { _contributors . add ( contributor ) ; } public void removeCompletionProposalContributor ( ICompletionProposalContributor contributor ) { _contributors . remove ( contributor ) ; } public ICompletionProposalContributor [ ] getCompletionProposalContributors ( ) { return ( ICompletionProposalContributor [ ] ) _contributors . toArray ( new ICompletionProposalContributor [ 0 ] ) ; } public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { return computeCompletionProposals ( viewer , offset , DEFAULT_CHARACTER , false ) ; } public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset , char activationChar ) { return computeCompletionProposals ( viewer , offset , activationChar , false ) ; } public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset , char activationChar , boolean autoActivated ) { if ( viewer instanceof IUnifiedViewer ) { unifiedViewer = ( IUnifiedViewer ) viewer ; } Lexeme currentLexeme = this . getOffsetMapper ( ) . getCurrentLexeme ( ) ; int currentIndex = computeCurrentLexemeIndex ( offset , this . getOffsetMapper ( ) . getLexemeList ( ) ) ; ICompletionProposal [ ] results = null ; int sourceLength = 50 ; if ( offset < 50 ) { sourceLength = offset ; } String documentSnippet = StringUtils . EMPTY ; try { documentSnippet = viewer . getDocument ( ) . get ( offset - sourceLength , sourceLength ) ; } catch ( BadLocationException e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , CoreStrings . ERROR , e ) ; } char previousChar = getActivationChar ( documentSnippet , documentSnippet . length ( ) , getCompletionProposalAllActivationCharacters ( ) ) ; ArrayList proposals = new ArrayList ( ) ; results = computeInnerCompletionProposals ( viewer , offset , currentIndex , this . getOffsetMapper ( ) . getLexemeList ( ) , activationChar , previousChar ) ; if ( results != null ) { proposals . addAll ( Arrays . asList ( results ) ) ; } for ( Iterator iter = _contributors . iterator ( ) ; iter . hasNext ( ) ; ) { ICompletionProposalContributor element = ( ICompletionProposalContributor ) iter . next ( ) ; ICompletionProposal [ ] contribs = element . computeCompletionProposals ( viewer , offset , currentIndex , this . getOffsetMapper ( ) . getLexemeList ( ) , activationChar , previousChar , autoActivated ) ; if ( contribs != null ) { proposals . addAll ( Arrays . asList ( contribs ) ) ; } } if ( unifiedViewer != null ) { resetViewerState ( unifiedViewer ) ; } ICompletionProposal [ ] newResults = ( ICompletionProposal [ ] ) proposals . toArray ( new ICompletionProposal [ 0 ] ) ; Arrays . sort ( newResults , getProposalComparator ( ) ) ; return newResults ; } public abstract Comparator getProposalComparator ( ) ; public static void resetViewerState ( IUnifiedViewer unifiedViewer ) { unifiedViewer . setHotkeyActivated ( false ) ; } public int computeCurrentLexemeIndex ( int offset , LexemeList lexemeList ) { return computeCurrentLexemeIndex ( offset , lexemeList , getCompletionProposalSeparatorLexemes ( ) ) ; } public static int computeCurrentLexemeIndex ( int offset , LexemeList lexemeList , int [ ] separatorTokens ) { int lexemeIndex = lexemeList . getLexemeFloorIndex ( offset ) ; if ( lexemeIndex <= 0 ) { return lexemeIndex ; } Arrays . sort ( separatorTokens ) ; Lexeme l = lexemeList . get ( lexemeIndex ) ; int newIndex = lexemeIndex ; for ( int i = 0 ; i < separatorTokens . length ; i ++ ) { int test = separatorTokens [ i ] ; if ( l . typeIndex == test && l . offset == offset ) { newIndex = newIndex - 1 ; break ; } } return newIndex ; } public IContextInformation [ ] computeContextInformation ( ITextViewer viewer , int offset ) { IContextInformation [ ] results = null ; int currentIndex = computeCurrentLexemeIndex ( offset , this . getOffsetMapper ( ) . getLexemeList ( ) ) ; results = computeInnerContextInformation ( viewer . getDocument ( ) . get ( ) , offset , currentIndex , this . getOffsetMapper ( ) . getLexemeList ( ) ) ; return results ; } public abstract IOffsetMapper getOffsetMapper ( ) ; public abstract ICompletionProposal [ ] computeInnerCompletionProposals ( ITextViewer viewer , int offset , int position , LexemeList lexemeList , char activationChar , char previousChar ) ; public abstract IContextInformation [ ] computeInnerContextInformation ( String documentSource , int offset , int position , LexemeList lexemeList ) ; public static boolean isValidIdleActivationToken ( Lexeme lexeme , int [ ] tokens ) { if ( lexeme == null ) { return false ; } Arrays . sort ( tokens ) ; return ( Arrays . binarySearch ( tokens , lexeme . typeIndex ) >= 0 ) ; } public static int setSelection ( String prefix , ICompletionProposal [ ] results ) { int selectedIndex = - 1 ; if ( prefix == null || prefix . equals ( StringUtils . EMPTY ) || results == null ) { return selectedIndex ; } IUnifiedCompletionProposal sensitiveProposal = null ; IUnifiedCompletionProposal insensitiveProposal = null ; IUnifiedCompletionProposal suggestedProposal = null ; for ( int i = 0 ; i < results . length ; i ++ ) { IUnifiedCompletionProposal cp = ( IUnifiedCompletionProposal ) results [ i ] ; String display = cp . getDisplayString ( ) ; int result = display . compareToIgnoreCase ( prefix ) ; if ( result >= 0 ) { if ( display . toLowerCase ( ) . startsWith ( prefix . toLowerCase ( ) ) ) { if ( insensitiveProposal == null ) { insensitiveProposal = cp ; selectedIndex = i ; } if ( display . startsWith ( prefix ) ) { sensitiveProposal = cp ; selectedIndex = i ; break ; } } else { suggestedProposal = cp ; break ; } } if ( i == results . length - 1 ) { suggestedProposal = cp ; } } if ( sensitiveProposal != null ) { sensitiveProposal . setDefaultSelection ( true ) ; } else if ( insensitiveProposal != null ) { insensitiveProposal . setDefaultSelection ( true ) ; } else if ( suggestedProposal != null ) { suggestedProposal . setSuggestedSelection ( true ) ; } else if ( results . length > 0 ) { ( ( IUnifiedCompletionProposal ) results [ 0 ] ) . setSuggestedSelection ( true ) ; } return selectedIndex ; } public static int setSelectionUnsorted ( String prefix , ICompletionProposal [ ] results ) { IUnifiedCompletionProposal selectedProposal = null ; int selectedIndex = - 1 ; if ( prefix == null || prefix . equals ( StringUtils . EMPTY ) ) { return selectedIndex ; } for ( int i = 0 ; i < results . length ; i ++ ) { IUnifiedCompletionProposal cp = ( IUnifiedCompletionProposal ) results [ i ] ; if ( cp . getDisplayString ( ) . startsWith ( prefix ) ) { selectedProposal = cp ; selectedIndex = i ; break ; } } if ( selectedProposal != null ) { selectedProposal . setDefaultSelection ( true ) ; } else if ( results . length > 0 ) { ( ( IUnifiedCompletionProposal ) results [ 0 ] ) . setDefaultSelection ( true ) ; selectedIndex = 0 ; } return selectedIndex ; } public static Lexeme getPreviousLexemeOfType ( int offset , int [ ] lexemeTypes , LexemeList lexemeList , boolean includeCurrent ) { return UnifiedContentAssistProcessor . getPreviousLexemeOfType ( offset , lexemeTypes , new int [ 0 ] , lexemeList , includeCurrent ) ; } public static Lexeme getPreviousLexemeOfType ( int offset , int [ ] lexemeTypes , int [ ] lexemeTypesToBail , LexemeList lexemeList , boolean includeCurrent ) { Arrays . sort ( lexemeTypes ) ; Arrays . sort ( lexemeTypesToBail ) ; Lexeme startLexeme = lexemeList . getFloorLexeme ( offset ) ; if ( ! includeCurrent ) { startLexeme = getPreviousLexeme ( offset , lexemeList ) ; } if ( startLexeme == null ) { return null ; } int index = lexemeList . getLexemeIndex ( startLexeme ) ; for ( int i = index ; i >= 0 ; i -- ) { Lexeme l = lexemeList . get ( i ) ; if ( Arrays . binarySearch ( lexemeTypes , l . typeIndex ) >= 0 ) { return l ; } if ( Arrays . binarySearch ( lexemeTypesToBail , l . typeIndex ) >= 0 ) { return null ; } } return null ; } public static Lexeme getPreviousLexeme ( int offset , LexemeList lexemeList ) { if ( offset == 0 ) { return null ; } Lexeme floor = lexemeList . getFloorLexeme ( offset ) ; if ( floor . offset == offset ) { int index = lexemeList . getLexemeIndex ( floor ) ; if ( index > 0 ) { return lexemeList . get ( index - 1 ) ; } else { return null ; } } else { return floor ; } } public static char getActivationChar ( String source , int offset , char [ ] activationCharacters1 , char [ ] activationCharacters2 ) { char [ ] newArray = new char [ activationCharacters1 . length + activationCharacters2 . length ] ; for ( int i = 0 ; i < activationCharacters1 . length ; i ++ ) { newArray [ i ] = activationCharacters1 [ i ] ; } for ( int i = 0 ; i < activationCharacters2 . length ; i ++ ) { newArray [ i + activationCharacters1 . length ] = activationCharacters2 [ i ] ; } return getActivationChar ( source , offset , newArray ) ; } public static char getActivationChar ( String source , int offset , char [ ] activationCharacters ) { Arrays . sort ( activationCharacters ) ; if ( offset > 0 ) { char activationCharacter = getPreviousChar ( source , offset ) ; if ( Arrays . binarySearch ( activationCharacters , activationCharacter ) < 0 ) { activationCharacter = UnifiedContentAssistProcessor . DEFAULT_CHARACTER ; } return activationCharacter ; } else { return DEFAULT_CHARACTER ; } } public static char getPreviousChar ( String source , int offset ) { if ( source == null ) { throw new IndexOutOfBoundsException ( Messages . UnifiedContentAssistProcessor_StringNotNull ) ; } if ( offset > 0 && offset <= source . length ( ) ) { char activationCharacter = source . charAt ( offset - 1 ) ; return activationCharacter ; } else { return DEFAULT_CHARACTER ; } } protected abstract IPreferenceStore getPreferenceStore ( ) ; public static char [ ] combine ( char [ ] array1 , char [ ] array2 ) { char [ ] newArray = new char [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , 0 , newArray , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , newArray , array1 . length , array2 . length ) ; return newArray ; } public static boolean containsExactProposalMatch ( String proposal , ICompletionProposal [ ] proposals ) { if ( proposals == null ) { return false ; } for ( int i = 0 ; i < proposals . length ; i ++ ) { ICompletionProposal prop = proposals [ i ] ; String displayProp = prop . getDisplayString ( ) ; if ( displayProp . equals ( proposal ) ) { return true ; } if ( prop instanceof IUnifiedCompletionProposal && ( ( IUnifiedCompletionProposal ) prop ) . getReplaceString ( ) . equals ( proposal ) ) { return true ; } String tempProposal = proposal ; if ( tempProposal . startsWith ( "\"" ) || tempProposal . startsWith ( "'" ) ) { tempProposal = tempProposal . substring ( 1 ) ; } if ( tempProposal . endsWith ( "\"" ) || tempProposal . endsWith ( "'" ) ) { tempProposal = tempProposal . substring ( 0 , tempProposal . length ( ) - 1 ) ; } if ( displayProp . equals ( tempProposal ) ) { return true ; } } return false ; } public static Image [ ] getUserAgentImages ( String [ ] supportedUserAgents , String [ ] allUserAgents ) { if ( supportedUserAgents . length > 0 ) { ArrayList images = new ArrayList ( ) ; for ( int i = 0 ; i < supportedUserAgents . length ; i ++ ) { String agentName = supportedUserAgents [ i ] ; Image image = null ; for ( int j = 0 ; j < allUserAgents . length ; j ++ ) { String ua = allUserAgents [ j ] ; if ( ua . equals ( agentName ) ) { image = ( Image ) agentImages . get ( agentName ) ; } } if ( image == null ) { image = ( Image ) agentImages . get ( agentName + "Grey" ) ; } images . add ( image ) ; } return ( Image [ ] ) images . toArray ( new Image [ 0 ] ) ; } else { return getGreyUserAgentImages ( allUserAgents ) ; } } public static Image [ ] getGreyUserAgentImages ( String [ ] userAgents ) { ArrayList images = new ArrayList ( ) ; for ( int i = 0 ; i < userAgents . length ; i ++ ) { String agentName = userAgents [ i ] ; Image image = ( Image ) agentImages . get ( agentName + "Grey" ) ; images . add ( image ) ; } return ( Image [ ] ) images . toArray ( new Image [ 0 ] ) ; } public static Image [ ] getAllUserAgentImages ( String [ ] userAgents ) { ArrayList images = new ArrayList ( ) ; for ( int i = 0 ; i < userAgents . length ; i ++ ) { String agentName = userAgents [ i ] ; Image image = ( Image ) agentImages . get ( agentName ) ; images . add ( image ) ; } return ( Image [ ] ) images . toArray ( new Image [ 0 ] ) ; } } 
=======
public class DataUri { public static boolean startsWithData ( String uri ) { return uri != null && uri . length ( ) >= 5 && ( uri . charAt ( 0 ) == 'd' || uri . charAt ( 0 ) == 'D' ) && ( uri . charAt ( 1 ) == 'a' || uri . charAt ( 1 ) == 'A' ) && ( uri . charAt ( 2 ) == 't' || uri . charAt ( 2 ) == 'T' ) && ( uri . charAt ( 3 ) == 'a' || uri . charAt ( 3 ) == 'A' ) && ( uri . charAt ( 4 ) == ':' ) ; } private enum State { AT_START , IN_SUPERTYPE , AT_SUBTYPE_START , IN_SUBTYPE , SEMICOLON_SEEN , WS_BEFORE_SEMICOLON , IN_PARAM_NAME , EQUALS_SEEN , IN_QUOTED_STRING , IN_UNQUOTED_STRING , IN_QUOTED_PAIR , CLOSE_QUOTE_SEEN } private String contentType ; private InputStream inputStream ; protected void init ( IRI uri ) throws IOException , MalformedURLException { if ( ! uri . getScheme ( ) . equals ( "data" ) ) { throw new IllegalArgumentException ( "The input did not start with data:." ) ; } if ( uri . getRawFragment ( ) != null ) { throw new MalformedURLException ( "Fragment is not allowed for data: URIs according to RFC 2397. But if strictly comply with RFC 3986, ignore this error." ) ; } InputStream is = new PercentDecodingReaderInputStream ( new StringReader ( uri . getRawPath ( ) ) ) ; StringBuilder sb = new StringBuilder ( ) ; State state = State . AT_START ; int i = 0 ; for ( ; ; i ++ ) { int b = is . read ( ) ; if ( b == - 1 ) { throw new MalformedURLException ( "Premature end of URI." ) ; } if ( b >= 0x80 ) { throw new MalformedURLException ( "Non-ASCII character in MIME type part of the data URI." ) ; } char c = ( char ) b ; sb . append ( c ) ; switch ( state ) { case AT_START : if ( isTokenChar ( c ) ) { state = State . IN_SUPERTYPE ; continue ; } else if ( c == ';' ) { sb . setLength ( 0 ) ; sb . append ( "text/plain;" ) ; state = State . SEMICOLON_SEEN ; continue ; } else if ( c == ',' ) { contentType = "text/plain;charset=US-ASCII" ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected a token character or a semicolon but saw " , c , " instead." ) ; } case IN_SUPERTYPE : if ( isTokenChar ( c ) ) { continue ; } else if ( c == '/' ) { state = State . AT_SUBTYPE_START ; continue ; } else { throw newDatatypeException ( i , "Expected a token character or “/” but saw " , c , " instead." ) ; } case AT_SUBTYPE_START : if ( isTokenChar ( c ) ) { state = State . IN_SUBTYPE ; continue ; } else { throw newDatatypeException ( i , "Expected a token character but saw " , c , " instead." ) ; } case IN_SUBTYPE : if ( isTokenChar ( c ) ) { continue ; } else if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_SEMICOLON ; continue ; } else if ( c == ',' ) { contentType = sb . substring ( 0 , sb . length ( ) - 1 ) ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected a token character, whitespace, a semicolon or a comma but saw " , c , " instead." ) ; } case WS_BEFORE_SEMICOLON : if ( isWhitespace ( c ) ) { continue ; } else if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else { throw newDatatypeException ( i , "Expected whitespace or a semicolon but saw " , c , " instead." ) ; } case SEMICOLON_SEEN : if ( isWhitespace ( c ) ) { continue ; } else if ( isTokenChar ( c ) ) { state = State . IN_PARAM_NAME ; continue ; } else { throw newDatatypeException ( i , "Expected whitespace or a token character but saw " , c , " instead." ) ; } case IN_PARAM_NAME : if ( isTokenChar ( c ) ) { continue ; } else if ( c == '=' ) { state = State . EQUALS_SEEN ; continue ; } else if ( c == ',' ) { int baseFirst = sb . length ( ) - 8 ; if ( baseFirst >= 0 && ";base64," . equals ( sb . substring ( baseFirst , sb . length ( ) ) ) ) { contentType = sb . substring ( 0 , baseFirst ) ; inputStream = new Base64InputStream ( is ) ; return ; } } else { throw newDatatypeException ( i , "Expected an equals sign, a comma or a token character but saw " , c , " instead." ) ; } case EQUALS_SEEN : if ( c == '\"' ) { state = State . IN_QUOTED_STRING ; continue ; } else if ( isTokenChar ( c ) ) { state = State . IN_UNQUOTED_STRING ; continue ; } else { throw newDatatypeException ( i , "Expected a double quote or a token character but saw " , c , " instead." ) ; } case IN_QUOTED_STRING : if ( c == '\\' ) { state = State . IN_QUOTED_PAIR ; continue ; } else if ( c == '\"' ) { state = State . CLOSE_QUOTE_SEEN ; continue ; } else if ( isQDTextChar ( c ) ) { continue ; } else { throw newDatatypeException ( i , "Expected a non-control ASCII character but saw " , c , " instead." ) ; } case IN_QUOTED_PAIR : if ( c <= 127 ) { state = State . IN_QUOTED_STRING ; continue ; } else { throw newDatatypeException ( i , "Expected an ASCII character but saw " , c , " instead." ) ; } case CLOSE_QUOTE_SEEN : if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_SEMICOLON ; continue ; } else if ( c == ',' ) { contentType = sb . substring ( 0 , sb . length ( ) - 1 ) ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected an ASCII character but saw " , c , " instead." ) ; } case IN_UNQUOTED_STRING : if ( isTokenChar ( c ) ) { continue ; } else if ( c == ';' ) { state = State . SEMICOLON_SEEN ; continue ; } else if ( isWhitespace ( c ) ) { state = State . WS_BEFORE_SEMICOLON ; continue ; } else if ( c == ',' ) { contentType = sb . substring ( 0 , sb . length ( ) - 1 ) ; inputStream = is ; return ; } else { throw newDatatypeException ( i , "Expected a token character, whitespace, a semicolon, or a comma but saw " , c , " instead." ) ; } } } } public DataUri ( String uri ) throws IOException , MalformedURLException { IRIFactory fac = new IRIFactory ( ) ; fac . shouldViolation ( true , false ) ; fac . securityViolation ( true , false ) ; fac . dnsViolation ( true , false ) ; fac . mintingViolation ( false , false ) ; fac . useSpecificationIRI ( true ) ; init ( fac . construct ( uri ) ) ; } public DataUri ( IRI uri ) throws IOException , MalformedURLException { init ( uri ) ; } private IOException newDatatypeException ( int i , String head , char c , String tail ) { return new DataUriException ( i , head , c , tail ) ; } private boolean isQDTextChar ( char c ) { return ( c >= ' ' && c <= 126 ) || ( c == '\n' ) || ( c == '\r' ) || ( c == '\t' ) ; } private boolean isTokenChar ( char c ) { return ( c >= 33 && c <= 126 ) && ! ( c == '(' || c == ')' || c == '<' || c == '>' || c == '@' || c == ',' || c == ';' || c == ':' || c == '\\' || c == '\"' || c == '/' || c == '[' || c == ']' || c == '?' || c == '=' || c == '{' || c == '}' ) ; } private boolean isWhitespace ( char c ) { return c == ' ' || c == '\t' || c == '\n' || c == '\r' ; } public String getContentType ( ) { return contentType ; } public InputStream getInputStream ( ) { return inputStream ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
