public abstract class UnifiedContentAssistProcessor implements IUnifiedContentAssistProcessor { public static final String USERAGENT_ID = "userAgent" ; public static final String USERAGENT_ELEMENT = "user-agent" ; public static final String ATTR_USER_AGENT_NAME = "name" ; public static final String ATTR_USER_AGENT_ID = "id" ; public static final String ATTR_ICON = "icon" ; public static final String ATTR_ICON_DISABLED = "icon-disabled" ; protected IUnifiedViewer unifiedViewer = null ; public static char DEFAULT_CHARACTER = '\0' ; private List _contributors = new ArrayList ( ) ; private static HashMap agentImages = new HashMap ( ) ; private static List agentNames = new ArrayList ( ) ; static { try { loadUserAgents ( ) ; } catch ( Exception ex ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , Messages . UnifiedContentAssistProcessor_ERR_UnableToLoadUserAgents , ex ) ; } } public static String [ ] getUserAgents ( ) { if ( PluginUtils . isPluginLoaded ( UnifiedEditorsPlugin . getDefault ( ) ) ) { IPreferenceStore prefs = UnifiedEditorsPlugin . getDefault ( ) . getPreferenceStore ( ) ; String agents = prefs . getString ( IPreferenceConstants . USER_AGENT_PREFERENCE ) ; return agents . split ( "," ) ; } else { return new String [ ] { Messages . UnifiedContentAssistProcessor_IE , Messages . UnifiedContentAssistProcessor_Mozilla } ; } } public static void addUserAgent ( String id , String name , Image normal , Image disabled ) { agentImages . put ( id , normal ) ; agentImages . put ( id + "Grey" , disabled ) ; agentNames . add ( id ) ; } private static void loadUserAgents ( ) { IExtensionRegistry registry = Platform . getExtensionRegistry ( ) ; if ( registry != null ) { IExtensionPoint extensionPoint = registry . getExtensionPoint ( UnifiedEditorsPlugin . ID , USERAGENT_ID ) ; if ( extensionPoint != null ) { IExtension [ ] extensions = extensionPoint . getExtensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { IExtension extension = extensions [ i ] ; IConfigurationElement [ ] elements = extension . getConfigurationElements ( ) ; for ( int j = 0 ; j < elements . length ; j ++ ) { IConfigurationElement element = elements [ j ] ; if ( element . getName ( ) . equals ( USERAGENT_ELEMENT ) ) { String agentID = element . getAttribute ( ATTR_USER_AGENT_ID ) ; String agentName = element . getAttribute ( ATTR_USER_AGENT_NAME ) ; String agentIconPath = element . getAttribute ( ATTR_ICON ) ; String agentIconDisabledPath = element . getAttribute ( ATTR_ICON_DISABLED ) ; if ( agentID != null ) { IExtension ext = element . getDeclaringExtension ( ) ; String pluginId = ext . getNamespaceIdentifier ( ) ; Bundle bundle = Platform . getBundle ( pluginId ) ; if ( agentIconPath == null || agentIconDisabledPath == null ) { continue ; } Image agentIcon = SWTUtils . getImage ( bundle , agentIconPath ) ; Image agentIconDisabled = SWTUtils . getImage ( bundle , agentIconDisabledPath ) ; if ( agentIcon != null && agentIconDisabled != null ) { addUserAgent ( agentID , agentName , agentIcon , agentIconDisabled ) ; } } } } } } } } public static String [ ] getDefaultUserAgents ( ) { return ( String [ ] ) agentNames . toArray ( new String [ 0 ] ) ; } public static HashMap getUserAgentImages ( ) { return agentImages ; } public abstract int [ ] getCompletionProposalIdleActivationTokens ( ) ; public char [ ] getCompletionProposalAutoActivationCharacters ( ) { return new char [ ] { } ; } public int [ ] getCompletionProposalSeparatorLexemes ( ) { return new int [ ] { } ; } public char [ ] getContextInformationAutoActivationCharacters ( ) { return new char [ ] { } ; } public char [ ] getCompletionProposalPrivateActivationCharacters ( ) { return new char [ ] { } ; } public char [ ] getCompletionProposalAllActivationCharacters ( ) { char [ ] allActivationChars = combine ( getCompletionProposalAutoActivationCharacters ( ) , getContextInformationAutoActivationCharacters ( ) ) ; Arrays . sort ( allActivationChars ) ; return allActivationChars ; } public boolean isValidIdleActivationLocation ( ITextViewer viewer , int offset ) { Lexeme currentLexeme = this . getOffsetMapper ( ) . getCurrentLexeme ( ) ; return isValidIdleActivationToken ( currentLexeme , getCompletionProposalIdleActivationTokens ( ) ) ; } public void addCompletionProposalContributor ( ICompletionProposalContributor contributor ) { _contributors . add ( contributor ) ; } public void removeCompletionProposalContributor ( ICompletionProposalContributor contributor ) { _contributors . remove ( contributor ) ; } public ICompletionProposalContributor [ ] getCompletionProposalContributors ( ) { return ( ICompletionProposalContributor [ ] ) _contributors . toArray ( new ICompletionProposalContributor [ 0 ] ) ; } public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { return computeCompletionProposals ( viewer , offset , DEFAULT_CHARACTER , false ) ; } public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset , char activationChar ) { return computeCompletionProposals ( viewer , offset , activationChar , false ) ; } public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset , char activationChar , boolean autoActivated ) { if ( viewer instanceof IUnifiedViewer ) { unifiedViewer = ( IUnifiedViewer ) viewer ; } Lexeme currentLexeme = this . getOffsetMapper ( ) . getCurrentLexeme ( ) ; int currentIndex = computeCurrentLexemeIndex ( offset , this . getOffsetMapper ( ) . getLexemeList ( ) ) ; ICompletionProposal [ ] results = null ; int sourceLength = 50 ; if ( offset < 50 ) { sourceLength = offset ; } String documentSnippet = StringUtils . EMPTY ; try { documentSnippet = viewer . getDocument ( ) . get ( offset - sourceLength , sourceLength ) ; } catch ( BadLocationException e ) { IdeLog . logError ( UnifiedEditorsPlugin . getDefault ( ) , CoreStrings . ERROR , e ) ; } char previousChar = getActivationChar ( documentSnippet , documentSnippet . length ( ) , getCompletionProposalAllActivationCharacters ( ) ) ; ArrayList proposals = new ArrayList ( ) ; results = computeInnerCompletionProposals ( viewer , offset , currentIndex , this . getOffsetMapper ( ) . getLexemeList ( ) , activationChar , previousChar ) ; if ( results != null ) { proposals . addAll ( Arrays . asList ( results ) ) ; } for ( Iterator iter = _contributors . iterator ( ) ; iter . hasNext ( ) ; ) { ICompletionProposalContributor element = ( ICompletionProposalContributor ) iter . next ( ) ; ICompletionProposal [ ] contribs = element . computeCompletionProposals ( viewer , offset , currentIndex , this . getOffsetMapper ( ) . getLexemeList ( ) , activationChar , previousChar , autoActivated ) ; if ( contribs != null ) { proposals . addAll ( Arrays . asList ( contribs ) ) ; } } if ( unifiedViewer != null ) { resetViewerState ( unifiedViewer ) ; } ICompletionProposal [ ] newResults = ( ICompletionProposal [ ] ) proposals . toArray ( new ICompletionProposal [ 0 ] ) ; Arrays . sort ( newResults , getProposalComparator ( ) ) ; return newResults ; } public abstract Comparator getProposalComparator ( ) ; public static void resetViewerState ( IUnifiedViewer unifiedViewer ) { unifiedViewer . setHotkeyActivated ( false ) ; } public int computeCurrentLexemeIndex ( int offset , LexemeList lexemeList ) { return computeCurrentLexemeIndex ( offset , lexemeList , getCompletionProposalSeparatorLexemes ( ) ) ; } public static int computeCurrentLexemeIndex ( int offset , LexemeList lexemeList , int [ ] separatorTokens ) { int lexemeIndex = lexemeList . getLexemeFloorIndex ( offset ) ; if ( lexemeIndex <= 0 ) { return lexemeIndex ; } Arrays . sort ( separatorTokens ) ; Lexeme l = lexemeList . get ( lexemeIndex ) ; int newIndex = lexemeIndex ; for ( int i = 0 ; i < separatorTokens . length ; i ++ ) { int test = separatorTokens [ i ] ; if ( l . typeIndex == test && l . offset == offset ) { newIndex = newIndex - 1 ; break ; } } return newIndex ; } public IContextInformation [ ] computeContextInformation ( ITextViewer viewer , int offset ) { IContextInformation [ ] results = null ; int currentIndex = computeCurrentLexemeIndex ( offset , this . getOffsetMapper ( ) . getLexemeList ( ) ) ; results = computeInnerContextInformation ( viewer . getDocument ( ) . get ( ) , offset , currentIndex , this . getOffsetMapper ( ) . getLexemeList ( ) ) ; return results ; } public abstract IOffsetMapper getOffsetMapper ( ) ; public abstract ICompletionProposal [ ] computeInnerCompletionProposals ( ITextViewer viewer , int offset , int position , LexemeList lexemeList , char activationChar , char previousChar ) ; public abstract IContextInformation [ ] computeInnerContextInformation ( String documentSource , int offset , int position , LexemeList lexemeList ) ; public static boolean isValidIdleActivationToken ( Lexeme lexeme , int [ ] tokens ) { if ( lexeme == null ) { return false ; } Arrays . sort ( tokens ) ; return ( Arrays . binarySearch ( tokens , lexeme . typeIndex ) >= 0 ) ; } public static int setSelection ( String prefix , ICompletionProposal [ ] results ) { int selectedIndex = - 1 ; if ( prefix == null || prefix . equals ( StringUtils . EMPTY ) || results == null ) { return selectedIndex ; } IUnifiedCompletionProposal sensitiveProposal = null ; IUnifiedCompletionProposal insensitiveProposal = null ; IUnifiedCompletionProposal suggestedProposal = null ; for ( int i = 0 ; i < results . length ; i ++ ) { IUnifiedCompletionProposal cp = ( IUnifiedCompletionProposal ) results [ i ] ; String display = cp . getDisplayString ( ) ; int result = display . compareToIgnoreCase ( prefix ) ; if ( result >= 0 ) { if ( display . toLowerCase ( ) . startsWith ( prefix . toLowerCase ( ) ) ) { if ( insensitiveProposal == null ) { insensitiveProposal = cp ; selectedIndex = i ; } if ( display . startsWith ( prefix ) ) { sensitiveProposal = cp ; selectedIndex = i ; break ; } } else { suggestedProposal = cp ; break ; } } if ( i == results . length - 1 ) { suggestedProposal = cp ; } } if ( sensitiveProposal != null ) { sensitiveProposal . setDefaultSelection ( true ) ; } else if ( insensitiveProposal != null ) { insensitiveProposal . setDefaultSelection ( true ) ; } else if ( suggestedProposal != null ) { suggestedProposal . setSuggestedSelection ( true ) ; } else if ( results . length > 0 ) { ( ( IUnifiedCompletionProposal ) results [ 0 ] ) . setSuggestedSelection ( true ) ; } return selectedIndex ; } public static int setSelectionUnsorted ( String prefix , ICompletionProposal [ ] results ) { IUnifiedCompletionProposal selectedProposal = null ; int selectedIndex = - 1 ; if ( prefix == null || prefix . equals ( StringUtils . EMPTY ) ) { return selectedIndex ; } for ( int i = 0 ; i < results . length ; i ++ ) { IUnifiedCompletionProposal cp = ( IUnifiedCompletionProposal ) results [ i ] ; if ( cp . getDisplayString ( ) . startsWith ( prefix ) ) { selectedProposal = cp ; selectedIndex = i ; break ; } } if ( selectedProposal != null ) { selectedProposal . setDefaultSelection ( true ) ; } else if ( results . length > 0 ) { ( ( IUnifiedCompletionProposal ) results [ 0 ] ) . setDefaultSelection ( true ) ; selectedIndex = 0 ; } return selectedIndex ; } public static Lexeme getPreviousLexemeOfType ( int offset , int [ ] lexemeTypes , LexemeList lexemeList , boolean includeCurrent ) { return UnifiedContentAssistProcessor . getPreviousLexemeOfType ( offset , lexemeTypes , new int [ 0 ] , lexemeList , includeCurrent ) ; } public static Lexeme getPreviousLexemeOfType ( int offset , int [ ] lexemeTypes , int [ ] lexemeTypesToBail , LexemeList lexemeList , boolean includeCurrent ) { Arrays . sort ( lexemeTypes ) ; Arrays . sort ( lexemeTypesToBail ) ; Lexeme startLexeme = lexemeList . getFloorLexeme ( offset ) ; if ( ! includeCurrent ) { startLexeme = getPreviousLexeme ( offset , lexemeList ) ; } if ( startLexeme == null ) { return null ; } int index = lexemeList . getLexemeIndex ( startLexeme ) ; for ( int i = index ; i >= 0 ; i -- ) { Lexeme l = lexemeList . get ( i ) ; if ( Arrays . binarySearch ( lexemeTypes , l . typeIndex ) >= 0 ) { return l ; } if ( Arrays . binarySearch ( lexemeTypesToBail , l . typeIndex ) >= 0 ) { return null ; } } return null ; } public static Lexeme getPreviousLexeme ( int offset , LexemeList lexemeList ) { if ( offset == 0 ) { return null ; } Lexeme floor = lexemeList . getFloorLexeme ( offset ) ; if ( floor . offset == offset ) { int index = lexemeList . getLexemeIndex ( floor ) ; if ( index > 0 ) { return lexemeList . get ( index - 1 ) ; } else { return null ; } } else { return floor ; } } public static char getActivationChar ( String source , int offset , char [ ] activationCharacters1 , char [ ] activationCharacters2 ) { char [ ] newArray = new char [ activationCharacters1 . length + activationCharacters2 . length ] ; for ( int i = 0 ; i < activationCharacters1 . length ; i ++ ) { newArray [ i ] = activationCharacters1 [ i ] ; } for ( int i = 0 ; i < activationCharacters2 . length ; i ++ ) { newArray [ i + activationCharacters1 . length ] = activationCharacters2 [ i ] ; } return getActivationChar ( source , offset , newArray ) ; } public static char getActivationChar ( String source , int offset , char [ ] activationCharacters ) { Arrays . sort ( activationCharacters ) ; if ( offset > 0 ) { char activationCharacter = getPreviousChar ( source , offset ) ; if ( Arrays . binarySearch ( activationCharacters , activationCharacter ) < 0 ) { activationCharacter = UnifiedContentAssistProcessor . DEFAULT_CHARACTER ; } return activationCharacter ; } else { return DEFAULT_CHARACTER ; } } public static char getPreviousChar ( String source , int offset ) { if ( source == null ) { throw new IndexOutOfBoundsException ( Messages . UnifiedContentAssistProcessor_StringNotNull ) ; } if ( offset > 0 && offset <= source . length ( ) ) { char activationCharacter = source . charAt ( offset - 1 ) ; return activationCharacter ; } else { return DEFAULT_CHARACTER ; } } protected abstract IPreferenceStore getPreferenceStore ( ) ; public static char [ ] combine ( char [ ] array1 , char [ ] array2 ) { char [ ] newArray = new char [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , 0 , newArray , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , newArray , array1 . length , array2 . length ) ; return newArray ; } public static boolean containsExactProposalMatch ( String proposal , ICompletionProposal [ ] proposals ) { if ( proposals == null ) { return false ; } for ( int i = 0 ; i < proposals . length ; i ++ ) { ICompletionProposal prop = proposals [ i ] ; String displayProp = prop . getDisplayString ( ) ; if ( displayProp . equals ( proposal ) ) { return true ; } if ( prop instanceof IUnifiedCompletionProposal && ( ( IUnifiedCompletionProposal ) prop ) . getReplaceString ( ) . equals ( proposal ) ) { return true ; } String tempProposal = proposal ; if ( tempProposal . startsWith ( "\"" ) || tempProposal . startsWith ( "'" ) ) { tempProposal = tempProposal . substring ( 1 ) ; } if ( tempProposal . endsWith ( "\"" ) || tempProposal . endsWith ( "'" ) ) { tempProposal = tempProposal . substring ( 0 , tempProposal . length ( ) - 1 ) ; } if ( displayProp . equals ( tempProposal ) ) { return true ; } } return false ; } public static Image [ ] getUserAgentImages ( String [ ] supportedUserAgents , String [ ] allUserAgents ) { if ( supportedUserAgents . length > 0 ) { ArrayList images = new ArrayList ( ) ; for ( int i = 0 ; i < supportedUserAgents . length ; i ++ ) { String agentName = supportedUserAgents [ i ] ; Image image = null ; for ( int j = 0 ; j < allUserAgents . length ; j ++ ) { String ua = allUserAgents [ j ] ; if ( ua . equals ( agentName ) ) { image = ( Image ) agentImages . get ( agentName ) ; } } if ( image == null ) { image = ( Image ) agentImages . get ( agentName + "Grey" ) ; } images . add ( image ) ; } return ( Image [ ] ) images . toArray ( new Image [ 0 ] ) ; } else { return getGreyUserAgentImages ( allUserAgents ) ; } } public static Image [ ] getGreyUserAgentImages ( String [ ] userAgents ) { ArrayList images = new ArrayList ( ) ; for ( int i = 0 ; i < userAgents . length ; i ++ ) { String agentName = userAgents [ i ] ; Image image = ( Image ) agentImages . get ( agentName + "Grey" ) ; images . add ( image ) ; } return ( Image [ ] ) images . toArray ( new Image [ 0 ] ) ; } public static Image [ ] getAllUserAgentImages ( String [ ] userAgents ) { ArrayList images = new ArrayList ( ) ; for ( int i = 0 ; i < userAgents . length ; i ++ ) { String agentName = userAgents [ i ] ; Image image = ( Image ) agentImages . get ( agentName ) ; images . add ( image ) ; } return ( Image [ ] ) images . toArray ( new Image [ 0 ] ) ; } } 