<<<<<<< HEAD
public class BeanUtil { static final Logger log = Log . open ( BeanUtil . class ) ; static L10N L = new L10N ( BeanUtil . class ) ; public static Class getBeanPropertyClass ( Object obj , String name ) { Method method = getBeanPropertyMethod ( obj , name ) ; if ( method == null ) return null ; Class [ ] paramTypes = method . getParameterTypes ( ) ; if ( paramTypes . length == 1 ) return paramTypes [ 0 ] ; else return null ; } public static Method getBeanPropertyMethod ( Object obj , String name ) { name = configToBeanName ( name ) ; Class beanClass = obj . getClass ( ) ; Method method = getSetMethod ( beanClass , name ) ; if ( method == null ) method = getAddMethod ( beanClass , name ) ; return method ; } public static void validateClass ( Class < ? > cl , Class < ? > parent ) throws RegistryException { if ( parent . isAssignableFrom ( cl ) ) { } else if ( parent . isInterface ( ) ) throw new RegistryException ( L . l ( "{0} must implement {1}" , cl . getName ( ) , parent . getName ( ) ) ) ; else throw new RegistryException ( L . l ( "{0} must extend {1}" , cl . getName ( ) , parent . getName ( ) ) ) ; if ( cl . isInterface ( ) ) throw new RegistryException ( L . l ( "{0} must be a concrete class." , cl . getName ( ) ) ) ; if ( Modifier . isAbstract ( cl . getModifiers ( ) ) ) throw new RegistryException ( L . l ( "{0} must not be abstract." , cl . getName ( ) ) ) ; if ( ! Modifier . isPublic ( cl . getModifiers ( ) ) ) throw new RegistryException ( L . l ( "{0} must be public." , cl . getName ( ) ) ) ; Constructor < ? > zero = null ; try { zero = cl . getConstructor ( new Class [ 0 ] ) ; } catch ( Throwable e ) { } if ( zero == null ) throw new RegistryException ( L . l ( "{0} must have a public zero-arg constructor." , cl . getName ( ) ) ) ; } public static Path lookupPath ( String pathName , HashMap varMap , Path pwd ) { if ( pwd == null ) pwd = Vfs . lookup ( ) ; if ( pathName . startsWith ( "$" ) ) { int p = pathName . indexOf ( '/' ) ; String prefix ; String suffix ; if ( p > 0 ) { prefix = pathName . substring ( 1 , p ) ; suffix = pathName . substring ( p + 1 ) ; } else { prefix = pathName . substring ( 1 ) ; suffix = null ; } Object value = varMap != null ? varMap . get ( prefix ) : null ; if ( value instanceof Path ) { pwd = ( Path ) value ; pathName = suffix ; } } if ( pathName == null ) return pwd ; else if ( pathName . indexOf ( '$' ) < 0 ) return pwd . lookup ( pathName ) ; CharBuffer cb = CharBuffer . allocate ( ) ; int head = 0 ; int tail = 0 ; while ( ( tail = pathName . indexOf ( '$' , head ) ) >= 0 ) { cb . append ( pathName . substring ( head , tail ) ) ; if ( tail + 1 == pathName . length ( ) ) { cb . append ( '$' ) ; continue ; } int ch = pathName . charAt ( tail + 1 ) ; if ( ch >= '0' && ch <= '9' ) { for ( head = tail + 1 ; head < pathName . length ( ) ; head ++ ) { ch = pathName . charAt ( head ) ; if ( ch < '0' || ch > '9' ) break ; } } else { for ( head = tail + 1 ; head < pathName . length ( ) ; head ++ ) { ch = pathName . charAt ( head ) ; if ( ch == '/' || ch == '\\' || ch == '$' || ch == ' ' ) break ; } } String key = pathName . substring ( tail + 1 , head ) ; Object value = varMap != null ? varMap . get ( key ) : null ; if ( value == null ) value = System . getProperty ( key ) ; if ( value != null ) cb . append ( value ) ; else cb . append ( pathName . substring ( tail , head ) ) ; } if ( head > 0 && head < pathName . length ( ) ) cb . append ( pathName . substring ( head ) ) ; return pwd . lookupNative ( cb . close ( ) ) ; } private static String configToBeanName ( String name ) { CharBuffer cb = CharBuffer . allocate ( ) ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { char ch = name . charAt ( i ) ; if ( ch == '-' ) cb . append ( Character . toUpperCase ( name . charAt ( ++ i ) ) ) ; else cb . append ( ch ) ; } return cb . close ( ) ; } private static Method getAddMethod ( Class cl , String name ) { name = "add" + name ; Method [ ] methods = cl . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( ! Modifier . isPublic ( methods [ i ] . getModifiers ( ) ) ) continue ; if ( ! name . equalsIgnoreCase ( methods [ i ] . getName ( ) ) ) continue ; if ( methods [ i ] . getParameterTypes ( ) . length == 1 ) return methods [ i ] ; } return null ; } public static Method getSetMethod ( BeanInfo info , String propertyName ) { Method method = getSetMethod ( info . getBeanDescriptor ( ) . getBeanClass ( ) , propertyName ) ; PropertyDescriptor [ ] pds = info . getPropertyDescriptors ( ) ; Method bestMethod = method ; for ( int i = 0 ; i < pds . length ; i ++ ) { if ( pds [ i ] . getName ( ) . equals ( propertyName ) && pds [ i ] . getWriteMethod ( ) != null ) { Method writeMethod = pds [ i ] . getWriteMethod ( ) ; if ( method != null && writeMethod . getName ( ) . equals ( method . getName ( ) ) ) continue ; if ( writeMethod . getParameterTypes ( ) [ 0 ] . equals ( String . class ) ) return writeMethod ; else bestMethod = writeMethod ; } } return bestMethod ; } public static Method getSetMethod ( Class cl , String propertyName ) { Method method = getSetMethod ( cl , propertyName , false ) ; if ( method != null ) return method ; return getSetMethod ( cl , propertyName , true ) ; } public static Method getSetMethod ( Class cl , String propertyName , boolean ignoreCase ) { String setName = "set" + propertyNameToMethodName ( propertyName ) ; Method bestMethod = null ; for ( Class ptrCl = cl ; ptrCl != null ; ptrCl = ptrCl . getSuperclass ( ) ) { Method method = getSetMethod ( ptrCl . getMethods ( ) , setName , ignoreCase ) ; if ( method != null && method . getParameterTypes ( ) [ 0 ] . equals ( String . class ) ) return method ; else if ( method != null ) bestMethod = method ; } if ( bestMethod != null ) return bestMethod ; Class [ ] interfaces = cl . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { Method method = getSetMethod ( interfaces [ i ] . getMethods ( ) , setName , ignoreCase ) ; if ( method != null && method . getParameterTypes ( ) [ 0 ] . equals ( String . class ) ) return method ; else if ( method != null ) bestMethod = method ; } if ( bestMethod != null ) return bestMethod ; return null ; } private static Method getSetMethod ( Method [ ] methods , String setName , boolean ignoreCase ) { Method bestMethod = null ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( ! ignoreCase && ! method . getName ( ) . equals ( setName ) ) continue ; if ( ignoreCase && ! method . getName ( ) . equalsIgnoreCase ( setName ) ) continue ; if ( ! Modifier . isPublic ( method . getModifiers ( ) ) ) continue ; if ( ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) continue ; if ( method . getParameterTypes ( ) . length != 1 ) continue ; if ( ! method . getReturnType ( ) . equals ( void . class ) ) continue ; Class paramType = method . getParameterTypes ( ) [ 0 ] ; if ( paramType . equals ( String . class ) ) return method ; else if ( bestMethod == null ) bestMethod = method ; else if ( paramType . getName ( ) . compareTo ( bestMethod . getParameterTypes ( ) [ 0 ] . getName ( ) ) < 0 ) bestMethod = method ; } return bestMethod ; } public static Method getGetMethod ( BeanInfo info , String propertyName ) { PropertyDescriptor [ ] pds = info . getPropertyDescriptors ( ) ; for ( int i = 0 ; i < pds . length ; i ++ ) { if ( pds [ i ] . getName ( ) . equals ( propertyName ) && pds [ i ] . getReadMethod ( ) != null ) { if ( ! Modifier . isPublic ( pds [ i ] . getReadMethod ( ) . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { pds [ i ] . getReadMethod ( ) . setAccessible ( true ) ; } catch ( Throwable e ) { continue ; } } return pds [ i ] . getReadMethod ( ) ; } } return getGetMethod ( info . getBeanDescriptor ( ) . getBeanClass ( ) , propertyName ) ; } public static Method getGetMethod ( Class cl , String propertyName ) { Method method = getGetMethod ( cl , propertyName , false ) ; if ( method != null ) return method ; return getGetMethod ( cl , propertyName , true ) ; } public static Method getGetMethod ( Class cl , String propertyName , boolean ignoreCase ) { String getName = "get" + propertyNameToMethodName ( propertyName ) ; String isName = "is" + propertyNameToMethodName ( propertyName ) ; for ( Class ptrCl = cl ; ptrCl != null ; ptrCl = ptrCl . getSuperclass ( ) ) { Method method = getGetMethod ( ptrCl . getDeclaredMethods ( ) , getName , isName , ignoreCase ) ; if ( method != null ) return method ; Class [ ] interfaces = ptrCl . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { method = getGetMethod ( interfaces [ i ] . getDeclaredMethods ( ) , getName , isName , ignoreCase ) ; if ( method != null ) return method ; } } return null ; } private static Method getGetMethod ( Method [ ] methods , String getName , String isName , boolean ignoreCase ) { for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( ! Modifier . isPublic ( method . getModifiers ( ) ) ) continue ; if ( ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) continue ; if ( method . getParameterTypes ( ) . length != 0 ) continue ; if ( method . getReturnType ( ) . equals ( void . class ) ) continue ; else if ( ! ignoreCase && methods [ i ] . getName ( ) . equals ( getName ) ) return methods [ i ] ; else if ( ignoreCase && methods [ i ] . getName ( ) . equalsIgnoreCase ( getName ) ) return methods [ i ] ; else if ( ! methods [ i ] . getReturnType ( ) . equals ( boolean . class ) ) continue ; else if ( ! ignoreCase && methods [ i ] . getName ( ) . equals ( isName ) ) return methods [ i ] ; else if ( ignoreCase && methods [ i ] . getName ( ) . equalsIgnoreCase ( isName ) ) return methods [ i ] ; } return null ; } public static String propertyNameToMethodName ( String propertyName ) { char ch = propertyName . charAt ( 0 ) ; if ( Character . isLowerCase ( ch ) ) propertyName = Character . toUpperCase ( ch ) + propertyName . substring ( 1 ) ; return propertyName ; } public static String methodNameToPropertyName ( BeanInfo info , String methodName ) { PropertyDescriptor [ ] pds = info . getPropertyDescriptors ( ) ; for ( int i = 0 ; i < pds . length ; i ++ ) { if ( pds [ i ] . getReadMethod ( ) != null && pds [ i ] . getReadMethod ( ) . getName ( ) . equals ( methodName ) ) return pds [ i ] . getName ( ) ; if ( pds [ i ] . getWriteMethod ( ) != null && pds [ i ] . getWriteMethod ( ) . getName ( ) . equals ( methodName ) ) return pds [ i ] . getName ( ) ; } return methodNameToPropertyName ( methodName ) ; } public static String methodNameToPropertyName ( String methodName ) { if ( methodName . startsWith ( "get" ) ) methodName = methodName . substring ( 3 ) ; else if ( methodName . startsWith ( "set" ) ) methodName = methodName . substring ( 3 ) ; else if ( methodName . startsWith ( "is" ) ) methodName = methodName . substring ( 2 ) ; if ( methodName . length ( ) == 0 ) return null ; char ch = methodName . charAt ( 0 ) ; if ( Character . isUpperCase ( ch ) && ( methodName . length ( ) == 1 || ! Character . isUpperCase ( methodName . charAt ( 1 ) ) ) ) { methodName = Character . toLowerCase ( ch ) + methodName . substring ( 1 ) ; } return methodName ; } } 
=======
public abstract class Schema2 extends Schema { protected Schema2 ( ) { } public Validator2 newValidator ( ) { return new ValidatorImpl ( newValidatorHandler ( ) ) ; } public abstract ValidatorHandler2 newValidatorHandler ( ) ; } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
