<<<<<<< HEAD
public class ProfileStore { public static final String ENCODING = "UTF-8" ; protected static final String VERSION_KEY_SUFFIX = ".version" ; private final static class ProfileDefaultHandler extends DefaultHandler { private List fProfiles ; private int fVersion ; private String fName ; private Map fSettings ; private String fKind ; public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( qName . equals ( XML_NODE_SETTING ) ) { final String key = attributes . getValue ( XML_ATTRIBUTE_ID ) ; final String value = attributes . getValue ( XML_ATTRIBUTE_VALUE ) ; fSettings . put ( key , value ) ; } else if ( qName . equals ( XML_NODE_PROFILE ) ) { fName = attributes . getValue ( XML_ATTRIBUTE_NAME ) ; fKind = attributes . getValue ( XML_ATTRIBUTE_PROFILE_KIND ) ; fSettings = new HashMap ( 200 ) ; } else if ( qName . equals ( XML_NODE_ROOT ) ) { fProfiles = new ArrayList ( ) ; try { fVersion = Integer . parseInt ( attributes . getValue ( XML_ATTRIBUTE_VERSION ) ) ; } catch ( NumberFormatException ex ) { throw new SAXException ( ex ) ; } } } public void endElement ( String uri , String localName , String qName ) { if ( qName . equals ( XML_NODE_PROFILE ) ) { fProfiles . add ( new CustomProfile ( fName , fSettings , fVersion , fKind ) ) ; fName = null ; fSettings = null ; fKind = null ; } } public List getProfiles ( ) { return fProfiles ; } } private final static String XML_NODE_ROOT = "profiles" ; private final static String XML_NODE_PROFILE = "profile" ; private final static String XML_NODE_SETTING = "setting" ; private final static String XML_ATTRIBUTE_VERSION = "version" ; private final static String XML_ATTRIBUTE_ID = "id" ; private final static String XML_ATTRIBUTE_NAME = "name" ; private final static String XML_ATTRIBUTE_PROFILE_KIND = "kind" ; private final static String XML_ATTRIBUTE_VALUE = "value" ; private final String fProfilesKey ; private final String fProfilesVersionKey ; private String pluginId ; public ProfileStore ( String profilesKey , String pluginId ) { fProfilesKey = profilesKey ; fProfilesVersionKey = profilesKey + VERSION_KEY_SUFFIX ; this . pluginId = pluginId ; } public List readProfiles ( IScopeContext scope ) throws CoreException { return readProfilesFromString ( scope . getNode ( pluginId ) . get ( fProfilesKey , null ) ) ; } public void writeProfiles ( Collection profiles , IScopeContext instanceScope ) throws CoreException { ByteArrayOutputStream stream = new ByteArrayOutputStream ( 2000 ) ; try { writeProfilesToStream ( profiles , stream , ENCODING ) ; String val ; try { val = stream . toString ( ENCODING ) ; } catch ( UnsupportedEncodingException e ) { val = stream . toString ( ) ; } IEclipsePreferences uiPreferences = instanceScope . getNode ( pluginId ) ; uiPreferences . put ( fProfilesKey , val ) ; uiPreferences . putInt ( fProfilesVersionKey , 1 ) ; } finally { try { stream . close ( ) ; } catch ( IOException e ) { } } } public List readProfilesFromString ( String profiles ) throws CoreException { if ( profiles != null && profiles . length ( ) > 0 ) { byte [ ] bytes ; try { bytes = profiles . getBytes ( ENCODING ) ; } catch ( UnsupportedEncodingException e ) { bytes = profiles . getBytes ( ) ; } InputStream is = new ByteArrayInputStream ( bytes ) ; try { List res = readProfilesFromStream ( new InputSource ( is ) ) ; return res ; } finally { try { is . close ( ) ; } catch ( IOException e ) { } } } return null ; } public List readProfilesFromFile ( File file ) throws CoreException { try { final FileInputStream reader = new FileInputStream ( file ) ; try { return readProfilesFromStream ( new InputSource ( reader ) ) ; } finally { try { reader . close ( ) ; } catch ( IOException e ) { } } } catch ( IOException e ) { throw createException ( e , FormatterMessages . CodingStyleConfigurationBlock_error_reading_xml_message ) ; } } public static List readProfilesFromStream ( InputSource inputSource ) throws CoreException { final ProfileDefaultHandler handler = new ProfileDefaultHandler ( ) ; try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; final SAXParser parser = factory . newSAXParser ( ) ; parser . parse ( inputSource , handler ) ; } catch ( SAXException e ) { throw createException ( e , FormatterMessages . CodingStyleConfigurationBlock_error_reading_xml_message ) ; } catch ( IOException e ) { throw createException ( e , FormatterMessages . CodingStyleConfigurationBlock_error_reading_xml_message ) ; } catch ( ParserConfigurationException e ) { throw createException ( e , FormatterMessages . CodingStyleConfigurationBlock_error_reading_xml_message ) ; } return handler . getProfiles ( ) ; } public void writeProfilesToFile ( Collection profiles , File file , String encoding ) throws CoreException { final OutputStream stream ; try { stream = new FileOutputStream ( file ) ; try { writeProfilesToStream ( profiles , stream , encoding ) ; } finally { try { stream . close ( ) ; } catch ( IOException e ) { } } } catch ( IOException e ) { throw createException ( e , FormatterMessages . CodingStyleConfigurationBlock_error_serializing_xml_message ) ; } } public static void writeProfilesToStream ( Collection profiles , OutputStream stream , String encoding ) throws CoreException { try { final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; final DocumentBuilder builder = factory . newDocumentBuilder ( ) ; final Document document = builder . newDocument ( ) ; final Element rootElement = document . createElement ( XML_NODE_ROOT ) ; rootElement . setAttribute ( XML_ATTRIBUTE_VERSION , Integer . toString ( 1 ) ) ; document . appendChild ( rootElement ) ; for ( final Iterator iter = profiles . iterator ( ) ; iter . hasNext ( ) ; ) { final Profile profile = ( Profile ) iter . next ( ) ; if ( profile . isProfileToSave ( ) ) { final Element profileElement = createProfileElement ( profile , document ) ; rootElement . appendChild ( profileElement ) ; } } Transformer transformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . METHOD , "xml" ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , encoding ) ; transformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; transformer . transform ( new DOMSource ( document ) , new StreamResult ( stream ) ) ; } catch ( TransformerException e ) { throw createException ( e , FormatterMessages . CodingStyleConfigurationBlock_error_serializing_xml_message ) ; } catch ( ParserConfigurationException e ) { throw createException ( e , FormatterMessages . CodingStyleConfigurationBlock_error_serializing_xml_message ) ; } } private static Element createProfileElement ( Profile profile , Document document ) { final Element element = document . createElement ( XML_NODE_PROFILE ) ; element . setAttribute ( XML_ATTRIBUTE_NAME , profile . getName ( ) ) ; element . setAttribute ( XML_ATTRIBUTE_VERSION , Integer . toString ( profile . getVersion ( ) ) ) ; element . setAttribute ( XML_ATTRIBUTE_PROFILE_KIND , "" ) ; final Iterator keyIter = profile . getSettings ( ) . keySet ( ) . iterator ( ) ; while ( keyIter . hasNext ( ) ) { final String key = ( String ) keyIter . next ( ) ; final String value = ( String ) profile . getSettings ( ) . get ( key ) ; if ( value != null ) { final Element setting = document . createElement ( XML_NODE_SETTING ) ; setting . setAttribute ( XML_ATTRIBUTE_ID , key ) ; setting . setAttribute ( XML_ATTRIBUTE_VALUE , value ) ; element . appendChild ( setting ) ; } else { IdeLog . logError ( Activator . getDefault ( ) , "ProfileStore: Profile does not contain value for key " + key ) ; } } return element ; } private static CoreException createException ( Throwable t , String message ) { return new CoreException ( new Status ( IStatus . ERROR , Activator . PLUGIN_ID , 0 , message , t ) ) ; } } 
=======
public final class Pattern extends AbstractDatatype { public static final Pattern THE_INSTANCE = new Pattern ( ) ; private Pattern ( ) { super ( ) ; } public void checkValid ( CharSequence literal ) throws DatatypeException { ContextFactory cf = new ContextFactory ( ) ; Context cx = cf . enterContext ( ) ; RegExpImpl rei = new RegExpImpl ( ) ; String anchoredRegex = "^(?:" + literal + ")$" ; try { rei . compileRegExp ( cx , anchoredRegex , "" ) ; } catch ( EcmaError ee ) { throw newDatatypeException ( ee . getErrorMessage ( ) ) ; } finally { Context . exit ( ) ; } } @ Override public String getName ( ) { return "pattern" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
