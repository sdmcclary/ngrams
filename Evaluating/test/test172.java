<<<<<<< HEAD
public final class ThemeSupport { private static final Logger LOG = Logger . getLogger ( ThemeSupport . class . getName ( ) ) ; private static final char ZIP_SEPARATOR = '/' ; private static final String THEMES_INDEX = "resources/themes/index.txt" ; private static List < ITheme > themes ; private static ITheme defaultTheme ; private static String currentOS ; private static final String KEY_NAME = "name" ; private static final String KEY_TITLE = "title" ; private static final String KEY_HIDDEN = "hidden" ; private ThemeSupport ( ) { } public static synchronized List < ITheme > getThemes ( ) { if ( themes == null ) themes = loadThemes ( ) ; return themes ; } public static synchronized ITheme getDefaultTheme ( ) { if ( defaultTheme == null ) defaultTheme = loadDefaultTheme ( ) ; return defaultTheme ; } public static ITheme getThemeByName ( String name ) { for ( ITheme theme : getThemes ( ) ) if ( theme . getName ( ) . equals ( name ) ) return theme ; return null ; } private static List < ITheme > loadThemes ( ) { ITheme aDefaultTheme = getDefaultTheme ( ) ; return loadThemes ( aDefaultTheme ) ; } private static List < ITheme > loadThemes ( ITheme aDefaultTheme ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Calling loadThemes (" + aDefaultTheme + ")" ) ; } URL [ ] themesUrls = getThemesUrls ( ) ; List < ITheme > someThemes = new ArrayList < ITheme > ( themesUrls . length ) ; for ( URL themeUrl : themesUrls ) { ITheme theme = loadTheme ( themeUrl , aDefaultTheme ) ; if ( theme != null ) someThemes . add ( theme ) ; } return someThemes ; } private static ITheme loadDefaultTheme ( ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Calling LoadDefaultTheme()" ) ; } return loadTheme ( getThemeUrl ( "default.theme" ) , new LAFTheme ( ) ) ; } private static ITheme loadTheme ( URL themeUrl , ITheme aDefaultTheme ) { if ( themeUrl == null ) throw new IllegalArgumentException ( Strings . error ( "unspecified.theme.url" ) ) ; String os = getCurrentOS ( ) ; ITheme theme ; try { Properties properties = new Properties ( ) ; properties . load ( themeUrl . openStream ( ) ) ; theme = createTheme ( properties , aDefaultTheme , os ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( Strings . error ( "invalid.theme.url" ) ) ; } return theme ; } static ITheme createTheme ( Properties aProperties , ITheme aDefaultTheme , String aOs ) { if ( aDefaultTheme == null ) throw new IllegalArgumentException ( Strings . error ( "unspecified.default.theme" ) ) ; if ( aProperties == null ) throw new IllegalArgumentException ( Strings . error ( "unspecified.properties" ) ) ; if ( aOs == null ) throw new IllegalArgumentException ( Strings . error ( "unspecified.os" ) ) ; String name = aProperties . getProperty ( KEY_NAME ) ; String title = aProperties . getProperty ( KEY_TITLE ) ; String hidden = aProperties . getProperty ( KEY_HIDDEN ) ; ITheme theme = null ; boolean isHidden = name == null || title == null || isInList ( hidden , aOs ) ; if ( ! isHidden ) { aProperties = preProcessProperties ( aProperties , aOs ) ; theme = new Theme ( name , title , aProperties , aDefaultTheme ) ; } return theme ; } static Properties preProcessProperties ( Properties aProperties , String aOs ) { final Set keySet = aProperties . keySet ( ) ; final String [ ] keys = ( String [ ] ) keySet . toArray ( new String [ keySet . size ( ) ] ) ; aOs = "." + aOs ; int suffixLength = aOs . length ( ) ; for ( String key : keys ) { if ( key . endsWith ( aOs ) ) { String baseKey = key . substring ( 0 , key . length ( ) - suffixLength ) ; aProperties . setProperty ( baseKey , aProperties . getProperty ( key ) ) ; } } return aProperties ; } private static boolean isInList ( String list , String str ) { if ( list == null ) return false ; str = str . toLowerCase ( ) ; StringTokenizer tokenizer = new StringTokenizer ( list , "," ) ; boolean found = false ; while ( ! found && tokenizer . hasMoreTokens ( ) ) { String token = tokenizer . nextToken ( ) . trim ( ) . toLowerCase ( ) ; found = token . equals ( str ) ; } return found ; } private static URL getThemeUrl ( String themeFileName ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Calling getThemeUrl(" + themeFileName + ")" ) ; } return ResourceUtils . getURL ( "resources/themes/" + themeFileName ) ; } private static synchronized String getCurrentOS ( ) { if ( currentOS == null ) currentOS = detectCurrentOS ( ) ; return currentOS ; } private static String detectCurrentOS ( ) { String os = "mac" ; String propOsName = System . getProperty ( "os.name" ) ; if ( Pattern . compile ( "linux" , Pattern . CASE_INSENSITIVE ) . matcher ( propOsName ) . find ( ) ) { os = "linux" ; } else if ( Pattern . compile ( "windows" , Pattern . CASE_INSENSITIVE ) . matcher ( propOsName ) . find ( ) ) { os = "windows" ; } return os ; } private static URL [ ] getThemesUrls ( ) { List < URL > themesUrlsList = new ArrayList < URL > ( ) ; String directoryName = getDirectoryName ( THEMES_INDEX ) ; InputStream in = null ; try { in = ResourceUtils . getInputStream ( THEMES_INDEX ) ; if ( null == in ) return new URL [ 0 ] ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; try { String line ; do { line = reader . readLine ( ) ; if ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > 0 ) themesUrlsList . add ( ResourceUtils . getURL ( directoryName + line ) ) ; } } while ( line != null ) ; reader . close ( ) ; } catch ( IOException e ) { LOG . log ( Level . WARNING , MessageFormat . format ( Strings . error ( "failed.to.read.tips.index" ) , THEMES_INDEX ) , e ) ; } } finally { try { if ( in != null ) in . close ( ) ; } catch ( IOException e1 ) { } } return themesUrlsList . toArray ( new URL [ themesUrlsList . size ( ) ] ) ; } private static String getDirectoryName ( String filename ) { int lastSeparatorIndex = filename . lastIndexOf ( ZIP_SEPARATOR ) ; return ( lastSeparatorIndex == - 1 ) ? "" : filename . substring ( 0 , lastSeparatorIndex + 1 ) ; } public static void addTheme ( URL themeURL ) { getThemes ( ) . add ( loadTheme ( themeURL , getDefaultTheme ( ) ) ) ; } public static class FontsComboBoxModel extends DefaultComboBoxModel { private static final java . util . List fontFamilies ; static { GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; fontFamilies = Arrays . asList ( ge . getAvailableFontFamilyNames ( ) ) ; } public int getSize ( ) { return fontFamilies . size ( ) ; } public Object getElementAt ( int index ) { return fontFamilies . get ( index ) ; } public int getIndexOf ( Object anObject ) { return fontFamilies . indexOf ( anObject ) ; } } public static class ThemesComboBoxModel extends DefaultComboBoxModel { public int getSize ( ) { return getThemes ( ) . size ( ) ; } public Object getElementAt ( int index ) { return getThemes ( ) . get ( index ) ; } public int getIndexOf ( Object anObject ) { return getThemes ( ) . indexOf ( anObject ) ; } } } 
=======
public class ValidatorPatternBuilder extends PatternBuilder { private final Map < Pattern , PatternMemo > patternMemoMap = new HashMap < Pattern , PatternMemo > ( ) ; private final PatternFunction < Pattern > endAttributesFunction ; private final PatternFunction < Pattern > ignoreMissingAttributesFunction ; private final PatternFunction < Pattern > endTagDerivFunction ; private final PatternFunction < Pattern > mixedTextDerivFunction ; private final PatternFunction < Pattern > textOnlyFunction ; private final PatternFunction < Pattern > recoverAfterFunction ; private final PatternFunction < DataDerivType > dataDerivTypeFunction ; private final Map < Pattern , Pattern > choiceMap = new HashMap < Pattern , Pattern > ( ) ; private final PatternFunction < Pattern > removeChoicesFunction = new RemoveChoicesFunction ( ) ; private final PatternFunction < VoidValue > noteChoicesFunction = new NoteChoicesFunction ( ) ; private final PatternFunction < Set < Name > > requiredElementsFunction = new RequiredElementsFunction ( ) ; private final PatternFunction < Set < Name > > requiredAttributesFunction = new RequiredAttributesFunction ( ) ; private final PossibleNamesFunction possibleStartTagNamesFunction = new PossibleStartTagNamesFunction ( ) ; private final PossibleNamesFunction possibleAttributeNamesFunction = new PossibleAttributeNamesFunction ( ) ; private class NoteChoicesFunction extends AbstractPatternFunction < VoidValue > { public VoidValue caseOther ( Pattern p ) { choiceMap . put ( p , p ) ; return VoidValue . VOID ; } public VoidValue caseChoice ( ChoicePattern p ) { p . getOperand1 ( ) . apply ( this ) ; p . getOperand2 ( ) . apply ( this ) ; return VoidValue . VOID ; } } private class RemoveChoicesFunction extends AbstractPatternFunction < Pattern > { public Pattern caseOther ( Pattern p ) { if ( choiceMap . get ( p ) != null ) return notAllowed ; return p ; } public Pattern caseChoice ( ChoicePattern p ) { Pattern p1 = p . getOperand1 ( ) . apply ( this ) ; Pattern p2 = p . getOperand2 ( ) . apply ( this ) ; if ( p1 == p . getOperand1 ( ) && p2 == p . getOperand2 ( ) ) return p ; if ( p1 == notAllowed ) return p2 ; if ( p2 == notAllowed ) return p1 ; Pattern p3 = new ChoicePattern ( p1 , p2 ) ; return interner . intern ( p3 ) ; } } public ValidatorPatternBuilder ( PatternBuilder builder ) { super ( builder ) ; endAttributesFunction = new EndAttributesFunction ( this ) ; ignoreMissingAttributesFunction = new IgnoreMissingAttributesFunction ( this ) ; endTagDerivFunction = new EndTagDerivFunction ( this ) ; mixedTextDerivFunction = new MixedTextDerivFunction ( this ) ; textOnlyFunction = new TextOnlyFunction ( this ) ; recoverAfterFunction = new RecoverAfterFunction ( this ) ; dataDerivTypeFunction = new DataDerivTypeFunction ( this ) ; } PatternMemo getPatternMemo ( Pattern p ) { PatternMemo memo = patternMemoMap . get ( p ) ; if ( memo == null ) { memo = new PatternMemo ( p , this ) ; patternMemoMap . put ( p , memo ) ; } return memo ; } PatternFunction < Pattern > getEndAttributesFunction ( ) { return endAttributesFunction ; } PatternFunction < Pattern > getIgnoreMissingAttributesFunction ( ) { return ignoreMissingAttributesFunction ; } PatternFunction < Set < Name > > getRequiredElementsFunction ( ) { return requiredElementsFunction ; } PatternFunction < Set < Name > > getRequiredAttributesFunction ( ) { return requiredAttributesFunction ; } PossibleNamesFunction getPossibleStartTagNamesFunction ( ) { return possibleStartTagNamesFunction ; } PossibleNamesFunction getPossibleAttributeNamesFunction ( ) { return possibleAttributeNamesFunction ; } PatternFunction < Pattern > getEndTagDerivFunction ( ) { return endTagDerivFunction ; } PatternFunction < Pattern > getMixedTextDerivFunction ( ) { return mixedTextDerivFunction ; } PatternFunction < Pattern > getTextOnlyFunction ( ) { return textOnlyFunction ; } PatternFunction < Pattern > getRecoverAfterFunction ( ) { return recoverAfterFunction ; } PatternFunction < DataDerivType > getDataDerivTypeFunction ( ) { return dataDerivTypeFunction ; } Pattern makeAfter ( Pattern p1 , Pattern p2 ) { Pattern p = new AfterPattern ( p1 , p2 ) ; return interner . intern ( p ) ; } Pattern makeChoice ( Pattern p1 , Pattern p2 ) { if ( p1 == p2 ) return p1 ; if ( p1 == notAllowed ) return p2 ; if ( p2 == notAllowed ) return p1 ; if ( ! ( p1 instanceof ChoicePattern ) ) { if ( p2 . containsChoice ( p1 ) ) return p2 ; } else if ( ! ( p2 instanceof ChoicePattern ) ) { if ( p1 . containsChoice ( p2 ) ) return p1 ; } else { p1 . apply ( noteChoicesFunction ) ; p2 = p2 . apply ( removeChoicesFunction ) ; if ( choiceMap . size ( ) > 0 ) choiceMap . clear ( ) ; } if ( p1 instanceof AfterPattern && p2 instanceof AfterPattern ) { AfterPattern ap1 = ( AfterPattern ) p1 ; AfterPattern ap2 = ( AfterPattern ) p2 ; if ( ap1 . getOperand1 ( ) == ap2 . getOperand1 ( ) ) return makeAfter ( ap1 . getOperand1 ( ) , makeChoice ( ap1 . getOperand2 ( ) , ap2 . getOperand2 ( ) ) ) ; if ( ap1 . getOperand1 ( ) == notAllowed ) return ap2 ; if ( ap2 . getOperand1 ( ) == notAllowed ) return ap1 ; if ( ap1 . getOperand2 ( ) == ap2 . getOperand2 ( ) ) return makeAfter ( makeChoice ( ap1 . getOperand1 ( ) , ap2 . getOperand1 ( ) ) , ap1 . getOperand2 ( ) ) ; } return super . makeChoice ( p1 , p2 ) ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
