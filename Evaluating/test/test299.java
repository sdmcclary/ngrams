<<<<<<< HEAD
public class SocketEngineService implements ISocketEngineService { private int maxConnectingSockets = 100 ; private int maxOpenSockets = 200 ; final private AtomicInteger currentlyConnectingSockets = new AtomicInteger ( 0 ) ; final private AtomicInteger currentlyOpenSockets = new AtomicInteger ( 0 ) ; private Selector selector ; private Thread selectThread ; final private BlockingQueue < SelectionContext > registrationQueue = new LinkedBlockingQueue < SelectionContext > ( ) ; final private Map < AsynchronousSelectableChannel , SelectionContext > contextMap = Collections . synchronizedMap ( new HashMap < AsynchronousSelectableChannel , SelectionContext > ( ) ) ; private ILogger logger ; private final ExecutorService executor = Executors . newCachedThreadPool ( ) ; public int getMaxConnectingSockets ( ) { return maxConnectingSockets ; } public void setMaxConnectingSockets ( int limit ) { maxConnectingSockets = limit ; } public int getMaxOpenSockets ( ) { return maxOpenSockets ; } public void setMaxOpenSockets ( int limit ) { maxOpenSockets = limit ; } public TCPChannel openTCP ( ) throws IOException { if ( selector == null ) startSelector ( ) ; TCPChannel channel = new TCPChannel ( this , SocketChannel . open ( ) ) ; channel . getWrappedChannel ( ) . configureBlocking ( false ) ; SelectionContext context = new SelectionContext ( this , channel , logger ) ; registerChannel ( channel , context ) ; return channel ; } public UDPChannel openUDP ( ) throws IOException { if ( selector == null ) startSelector ( ) ; UDPChannel channel = new UDPChannel ( this , DatagramChannel . open ( ) ) ; channel . getWrappedChannel ( ) . configureBlocking ( false ) ; SelectionContext context = new SelectionContext ( this , channel , logger ) ; registerChannel ( channel , context ) ; return channel ; } public < A > Future < Void > asynchronousConnect ( TCPChannel channel , TCPSocketLocator remote , long timeout , TimeUnit unit , final A attachment , final CompletionHandler < Void , ? super A > handler ) throws IOException , InterruptedException { if ( selector == null ) startSelector ( ) ; synchronized ( this ) { while ( ! canConnect ( ) ) this . wait ( ) ; countConnectingSocket ( ) ; } final SocketChannel socket = channel . getWrappedChannel ( ) ; final CompletionHandler < Void , A > connectCompletion = new CompletionHandler < Void , A > ( ) { public void cancelled ( A a ) { handler . cancelled ( a ) ; countConnectFinished ( ) ; } public void completed ( Void result , A a ) { handler . completed ( result , a ) ; countConnectFinished ( ) ; } public void failed ( Throwable exc , A a ) { handler . failed ( exc , a ) ; countConnectFinished ( ) ; } } ; long deadline = System . currentTimeMillis ( ) + unit . toMillis ( timeout ) ; SelectionFuture < Void , ? super A > future = new SelectionFuture < Void , A > ( connectCompletion , attachment , deadline , logger , new Callable < Void > ( ) { public Void call ( ) throws Exception { socket . finishConnect ( ) ; return null ; } } ) ; InetSocketAddress sockaddr = new InetSocketAddress ( remote . getAddress ( ) . toInetAddress ( ) , remote . getPort ( ) ) ; socket . configureBlocking ( false ) ; try { socket . connect ( sockaddr ) ; } catch ( IOException e ) { countConnectFinished ( ) ; throw e ; } SelectionContext context = contextMap . get ( channel ) ; if ( context == null ) { logger . error ( "context not found on connect() " + channel ) ; handler . cancelled ( attachment ) ; return null ; } context . enqueueConnect ( future ) ; registrationQueue . add ( context ) ; selector . wakeup ( ) ; return future ; } public < A > Future < Integer > asynchronousRead ( final AsynchronousSelectableChannel channel , final ByteBuffer dst , long timeout , TimeUnit unit , final A attachment , final CompletionHandler < Integer , ? super A > handler ) { long deadline = System . currentTimeMillis ( ) + unit . toMillis ( timeout ) ; SelectionFuture < Integer , A > future = new SelectionFuture < Integer , A > ( handler , attachment , deadline , logger , new Callable < Integer > ( ) { public Integer call ( ) throws Exception { Integer count = ( ( ReadableByteChannel ) channel . getWrappedChannel ( ) ) . read ( dst ) ; if ( count <= 0 ) throw new ClosedChannelException ( ) ; return count ; } } ) ; SelectionContext context = contextMap . get ( channel ) ; if ( context == null ) { logger . error ( "Context not found on read() " + channel ) ; handler . cancelled ( attachment ) ; return null ; } context . enqueueRead ( future ) ; registrationQueue . add ( context ) ; selector . wakeup ( ) ; return future ; } public < A > Future < Integer > asynchronousWrite ( final AsynchronousSelectableChannel channel , final ByteBuffer src , long timeout , TimeUnit unit , final A attachment , final CompletionHandler < Integer , ? super A > handler ) { long deadline = System . currentTimeMillis ( ) + unit . toMillis ( timeout ) ; SelectionFuture < Integer , A > future = new SelectionFuture < Integer , A > ( handler , attachment , deadline , logger , new Callable < Integer > ( ) { public Integer call ( ) throws Exception { Integer count = ( ( WritableByteChannel ) channel . getWrappedChannel ( ) ) . write ( src ) ; if ( count <= 0 ) throw new ClosedChannelException ( ) ; return count ; } } ) ; SelectionContext context = contextMap . get ( channel ) ; if ( context == null ) { logger . error ( "Context not found on write() " + channel ) ; handler . cancelled ( attachment ) ; return null ; } context . enqueueWrite ( future ) ; registrationQueue . add ( context ) ; selector . wakeup ( ) ; return future ; } public < A > Future < UDPSocketLocator > asynchronousReceive ( final UDPChannel channel , final ByteBuffer dst , long timeout , TimeUnit unit , final A attachment , final CompletionHandler < UDPSocketLocator , ? super A > handler ) { long deadline = System . currentTimeMillis ( ) + unit . toMillis ( timeout ) ; SelectionFuture < UDPSocketLocator , A > future = new SelectionFuture < UDPSocketLocator , A > ( handler , attachment , deadline , logger , new Callable < UDPSocketLocator > ( ) { public UDPSocketLocator call ( ) throws Exception { InetSocketAddress address = ( InetSocketAddress ) channel . getWrappedChannel ( ) . receive ( dst ) ; return new UDPSocketLocator ( InternetAddress . fromInetAddress ( address . getAddress ( ) ) , address . getPort ( ) ) ; } } ) ; SelectionContext context = contextMap . get ( channel ) ; if ( context == null ) { logger . error ( "Context not found on recv() for " + channel ) ; handler . cancelled ( attachment ) ; return null ; } context . enqueueRead ( future ) ; registrationQueue . add ( context ) ; selector . wakeup ( ) ; return future ; } public < A > Future < Integer > asynchronousSend ( final UDPChannel channel , final ByteBuffer src , final UDPSocketLocator target , long timeout , TimeUnit unit , final A attachment , final CompletionHandler < Integer , ? super A > handler ) { long deadline = System . currentTimeMillis ( ) + unit . toMillis ( timeout ) ; SelectionFuture < Integer , A > future = new SelectionFuture < Integer , A > ( handler , attachment , deadline , logger , new Callable < Integer > ( ) { public Integer call ( ) throws Exception { return channel . getWrappedChannel ( ) . send ( src , new InetSocketAddress ( target . getAddress ( ) . toInetAddress ( ) , target . getPort ( ) ) ) ; } } ) ; SelectionContext context = contextMap . get ( channel ) ; if ( context == null ) { logger . error ( "Context not found on send() " + channel ) ; handler . cancelled ( attachment ) ; return null ; } context . enqueueWrite ( future ) ; registrationQueue . add ( context ) ; selector . wakeup ( ) ; return future ; } private void countOpenSocket ( ) { currentlyOpenSockets . incrementAndGet ( ) ; } private void countConnectingSocket ( ) { currentlyConnectingSockets . incrementAndGet ( ) ; } private void countConnectFinished ( ) { currentlyConnectingSockets . decrementAndGet ( ) ; synchronized ( this ) { this . notifyAll ( ) ; } } private void countSocketClose ( ) { currentlyOpenSockets . decrementAndGet ( ) ; synchronized ( this ) { this . notifyAll ( ) ; } } private boolean canConnect ( ) { return ( currentlyConnectingSockets . get ( ) < maxConnectingSockets ) && ( currentlyOpenSockets . get ( ) < maxOpenSockets ) ; } private void startSelector ( ) { assert ( selector == null ) ; try { selector = Selector . open ( ) ; } catch ( IOException e ) { assert logger != null ; logger . error ( "I/O error, cannot open selector" , e ) ; return ; } selectThread = new Thread ( new Runnable ( ) { public void run ( ) { selectLoop ( ) ; try { selector . close ( ) ; } catch ( IOException e ) { assert logger != null ; logger . error ( "I/O error closing selector" , e ) ; } selector = null ; } } ) ; selectThread . setDaemon ( true ) ; selectThread . setName ( "Socket Connect Engine Selector thread" ) ; selectThread . start ( ) ; } private void registerPending ( ) { SelectionContext context ; while ( ( context = registrationQueue . poll ( ) ) != null ) context . register ( ) ; } private void selectLoop ( ) { long timeout = 0 ; registerPending ( ) ; while ( ! Thread . interrupted ( ) ) { if ( contextMap . isEmpty ( ) && currentlyOpenSockets . get ( ) == 0 && currentlyConnectingSockets . get ( ) == 0 ) { assert logger != null ; logger . debug ( "SocketEngineService clean" ) ; timeout = 0 ; } else { timeout = Math . max ( timeout , 500 ) ; } try { selector . select ( timeout ) ; assert selector != null ; if ( selector . isOpen ( ) == false ) { return ; } } catch ( IOException e ) { assert logger != null ; logger . error ( "I/O error in Selector#select()" , e ) ; return ; } registerPending ( ) ; for ( SelectionKey key : selector . selectedKeys ( ) ) { SelectionContext context = ( SelectionContext ) key . attachment ( ) ; try { context . testKey ( key ) ; } catch ( CancelledKeyException e ) { context . close ( ) ; } } long now = System . currentTimeMillis ( ) ; timeout = Long . MAX_VALUE ; for ( SelectionKey key : selector . keys ( ) ) { SelectionContext context = ( SelectionContext ) key . attachment ( ) ; try { timeout = Math . min ( timeout , context . testTimeOut ( key , now ) ) ; } catch ( CancelledKeyException e ) { } } if ( timeout == Long . MAX_VALUE ) timeout = 0 ; } } void close ( ) { try { selector . close ( ) ; } catch ( IOException e ) { logger . error ( "I/O error closing selector" , e ) ; } executor . shutdownNow ( ) ; } private synchronized void registerChannel ( AsynchronousSelectableChannel channel , SelectionContext context ) { contextMap . put ( channel , context ) ; countOpenSocket ( ) ; } public synchronized void unregisterChannel ( AsynchronousSelectableChannel channel ) { if ( null != contextMap . remove ( channel ) ) countSocketClose ( ) ; } Selector getSelector ( ) { return selector ; } public ExecutorService getExecutor ( ) { return executor ; } protected void setLogManager ( ILogManager logManager ) { logger = logManager . getLogger ( "Socket Engine" ) ; } protected void unsetLogManager ( ILogManager logManager ) { } } 
=======
class ElementsOrAttributes { private static final int ELEMENTS_FLAG = 01 ; private static final int ATTRIBUTES_FLAG = 02 ; static final ElementsOrAttributes NEITHER = new ElementsOrAttributes ( 0 ) ; static final ElementsOrAttributes ELEMENTS = new ElementsOrAttributes ( ELEMENTS_FLAG ) ; static final ElementsOrAttributes ATTRIBUTES = new ElementsOrAttributes ( ATTRIBUTES_FLAG ) ; static final ElementsOrAttributes BOTH = new ElementsOrAttributes ( ELEMENTS_FLAG | ATTRIBUTES_FLAG ) ; private static final ElementsOrAttributes values [ ] = { NEITHER , ELEMENTS , ATTRIBUTES , BOTH } ; private int flags = 0 ; private ElementsOrAttributes ( int flags ) { this . flags = flags ; } ElementsOrAttributes addElements ( ) { return values [ flags | ELEMENTS_FLAG ] ; } ElementsOrAttributes addAttributes ( ) { return values [ flags | ATTRIBUTES_FLAG ] ; } boolean containsAttributes ( ) { return ( flags & ATTRIBUTES_FLAG ) != 0 ; } boolean containsElements ( ) { return ( flags & ELEMENTS_FLAG ) != 0 ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
