<<<<<<< HEAD
public class MasterDetailEngine < MT , DT > extends EngineBase < DT > { @ SuppressWarnings ( "unused" ) private Class < MT > masterRecordClass ; private final RecordInfo < MT > masterInfo ; private final MasterDetailSelector recordSelector ; public MasterDetailEngine ( Class < MT > masterRecordClass , Class < DT > detailRecordClass , MasterDetailSelector recordSelector ) { super ( detailRecordClass ) ; this . masterRecordClass = masterRecordClass ; this . masterInfo = new RecordInfo < MT > ( masterRecordClass ) ; this . recordSelector = recordSelector ; } public MasterDetailEngine ( Class < MT > masterRecordClass , Class < DT > detailRecordClass , CommonSelector action , String selector ) { super ( detailRecordClass ) ; this . masterInfo = new RecordInfo < MT > ( masterRecordClass ) ; final CommonInternalSelector sel = new CommonInternalSelector ( action , selector , masterInfo . isIgnoreEmptyLines ( ) || recordInfo . isIgnoreEmptyLines ( ) ) ; this . recordSelector = new MasterDetailSelector ( ) { @ Override public RecordAction getRecordAction ( String recordString ) { return sel . getCommonSelectorMethod ( recordString ) ; } } ; } public List < MasterDetails < MT , DT > > readResource ( String fileName ) throws IOException { List < MasterDetails < MT , DT > > tempRes = null ; InputStreamReader fr = null ; try { fr = new InputStreamReader ( getClass ( ) . getResourceAsStream ( fileName ) ) ; tempRes = readStream ( fr ) ; } finally { if ( fr != null ) { fr . close ( ) ; } } return tempRes ; } public List < MasterDetails < MT , DT > > fromString ( String s ) throws IOException { return readStream ( new InputStreamReader ( new ByteArrayInputStream ( s . getBytes ( ) ) ) ) ; } public List < MasterDetails < MT , DT > > readFile ( String fileName ) throws IOException { List < MasterDetails < MT , DT > > tempRes = null ; FileReader fr = null ; try { fr = new FileReader ( new File ( fileName ) ) ; tempRes = readStream ( fr ) ; } finally { if ( fr != null ) { fr . close ( ) ; } } return tempRes ; } public void writeFile ( String fileName , MasterDetails < MT , DT > record ) throws IOException { List < MasterDetails < MT , DT > > list = new ArrayList < MasterDetails < MT , DT > > ( ) ; list . add ( record ) ; writeFile ( fileName , list ) ; } public void writeFile ( String fileName , List < MasterDetails < MT , DT > > records ) throws IOException { writeFile ( fileName , records , - 1 ) ; } public void writeFile ( String fileName , List < MasterDetails < MT , DT > > records , int maxRecords ) throws IOException { FileWriter fw = null ; try { fw = new FileWriter ( new File ( fileName ) ) ; writeStream ( fw , records , maxRecords ) ; } finally { if ( fw != null ) { fw . flush ( ) ; fw . close ( ) ; } } } private void writeStream ( OutputStreamWriter osr , List < MasterDetails < MT , DT > > records , int maxRecords ) throws IOException { BufferedWriter writer = new BufferedWriter ( osr ) ; resetFields ( ) ; if ( getHeaderText ( ) != null && getHeaderText ( ) . length ( ) != 0 ) { writer . write ( getHeaderText ( ) ) ; if ( ! getHeaderText ( ) . endsWith ( StringHelper . NEW_LINE ) ) { writer . write ( StringHelper . NEW_LINE ) ; } } String currentLine = null ; int max = records . size ( ) ; if ( maxRecords >= 0 ) { max = Math . min ( max , maxRecords ) ; } ProgressHelper . notify ( notifyHandler , progressMode , 0 , max ) ; for ( int i = 0 ; i < max ; i ++ ) { try { if ( records . get ( i ) == null ) { throw new IllegalArgumentException ( "The record at index " + i + " is null." ) ; } ProgressHelper . notify ( notifyHandler , progressMode , i + 1 , max ) ; currentLine = masterInfo . recordToStr ( records . get ( i ) . getMaster ( ) ) ; writer . write ( currentLine + StringHelper . NEW_LINE ) ; if ( records . get ( i ) . getDetails ( ) != null ) { for ( int d = 0 ; d < records . get ( i ) . getDetails ( ) . size ( ) ; d ++ ) { currentLine = recordInfo . recordToStr ( records . get ( i ) . getDetails ( ) . get ( d ) ) ; writer . write ( currentLine + StringHelper . NEW_LINE ) ; } } writer . flush ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } totalRecords = records . size ( ) ; if ( getFooterText ( ) != null && getFooterText ( ) != "" ) { writer . write ( getFooterText ( ) ) ; if ( ! getFooterText ( ) . endsWith ( StringHelper . NEW_LINE ) ) { writer . write ( StringHelper . NEW_LINE ) ; } } } private List < MasterDetails < MT , DT > > readStream ( InputStreamReader fileReader ) throws IOException { BufferedReader reader = new BufferedReader ( fileReader ) ; resetFields ( ) ; setHeaderText ( "" ) ; setFooterText ( "" ) ; List < MasterDetails < MT , DT > > resArray = new ArrayList < MasterDetails < MT , DT > > ( ) ; ForwardReader freader = new ForwardReader ( reader , masterInfo . getIgnoreLast ( ) ) ; freader . setDiscardForward ( true ) ; String currentLine , completeLine ; lineNumber = 1 ; completeLine = freader . readNextLine ( ) ; currentLine = completeLine ; ProgressHelper . notify ( notifyHandler , progressMode , 0 , - 1 ) ; int currentRecord = 0 ; if ( masterInfo . getIgnoreFirst ( ) > 0 ) { for ( int i = 0 ; i < masterInfo . getIgnoreFirst ( ) && currentLine != null ; i ++ ) { headerText += currentLine + StringHelper . NEW_LINE ; currentLine = freader . readNextLine ( ) ; lineNumber ++ ; } } boolean byPass = false ; MasterDetails < MT , DT > record = null ; List < DT > tmpDetails = new ArrayList < DT > ( ) ; LineInfo line = new LineInfo ( currentLine ) ; line . setReader ( freader ) ; while ( currentLine != null ) { try { currentRecord ++ ; line . reload ( currentLine ) ; ProgressHelper . notify ( notifyHandler , progressMode , currentRecord , - 1 ) ; RecordAction action = recordSelector . getRecordAction ( currentLine ) ; switch ( action ) { case Master : if ( record != null ) { record . addDetails ( tmpDetails ) ; resArray . add ( record ) ; } totalRecords ++ ; record = new MasterDetails < MT , DT > ( ) ; tmpDetails . clear ( ) ; MT lastMaster = masterInfo . strToRecord ( line ) ; if ( lastMaster != null ) { record . setMaster ( lastMaster ) ; } break ; case Detail : DT lastChild = recordInfo . strToRecord ( line ) ; if ( lastChild != null ) { tmpDetails . add ( lastChild ) ; } break ; default : break ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( byPass == false ) { currentLine = freader . readNextLine ( ) ; completeLine = currentLine ; lineNumber = freader . getLineNumber ( ) ; } } } if ( record != null ) { record . addDetails ( tmpDetails ) ; resArray . add ( record ) ; } if ( masterInfo . getIgnoreLast ( ) > 0 ) { footerText = freader . getRemainingText ( ) ; } return resArray ; } class CommonInternalSelector { private final String selector ; private final boolean ignoreEmpty ; private final CommonSelector action ; public CommonInternalSelector ( CommonSelector action , String selector , boolean ignoreEmpty ) { this . action = action ; this . selector = selector ; this . ignoreEmpty = ignoreEmpty ; } protected RecordAction getCommonSelectorMethod ( String recordString ) { if ( ignoreEmpty && recordString . length ( ) < 1 ) { return RecordAction . Skip ; } switch ( action ) { case DetailIfContains : if ( recordString . indexOf ( selector ) >= 0 ) return RecordAction . Detail ; else return RecordAction . Master ; case MasterIfContains : if ( recordString . indexOf ( selector ) >= 0 ) return RecordAction . Master ; else return RecordAction . Detail ; case DetailIfBegins : if ( recordString . startsWith ( selector ) ) return RecordAction . Detail ; else return RecordAction . Master ; case MasterIfBegins : if ( recordString . startsWith ( selector ) ) return RecordAction . Master ; else return RecordAction . Detail ; case DetailIfEnds : if ( recordString . endsWith ( selector ) ) return RecordAction . Detail ; else return RecordAction . Master ; case MasterIfEnds : if ( recordString . endsWith ( selector ) ) return RecordAction . Master ; else return RecordAction . Detail ; case DetailIfEnclosed : if ( recordString . startsWith ( selector ) && recordString . endsWith ( selector ) ) return RecordAction . Detail ; else return RecordAction . Master ; case MasterIfEnclosed : if ( recordString . startsWith ( selector ) && recordString . endsWith ( selector ) ) return RecordAction . Master ; else return RecordAction . Detail ; } return RecordAction . Skip ; } } } 
=======
final class DataDerivFailure { private final Datatype datatype ; private final Name datatypeName ; private final List < String > datatypeParams ; private final String message ; private final String stringValue ; private final Object value ; private Pattern except ; private int index ; private int tokenIndex = - 1 ; private int tokenStart = - 1 ; private int tokenEnd = - 1 ; DataDerivFailure ( DataPattern p , DatatypeException e ) { this ( p . getDatatype ( ) , p . getDatatypeName ( ) , p . getParams ( ) , e . getMessage ( ) , e . getIndex ( ) ) ; } DataDerivFailure ( Datatype dt , Name dtName , DatatypeException e ) { this ( dt , dtName , null , e . getMessage ( ) , e . getIndex ( ) ) ; } DataDerivFailure ( DataExceptPattern p ) { this ( p . getDatatype ( ) , p . getDatatypeName ( ) , p . getParams ( ) , p . getExcept ( ) ) ; } DataDerivFailure ( ValuePattern p ) { this ( p . getDatatype ( ) , p . getDatatypeName ( ) , p . getValue ( ) , p . getStringValue ( ) ) ; } private DataDerivFailure ( Datatype datatype , Name datatypeName , List < String > datatypeParams , String message , int index ) { this . datatype = datatype ; this . datatypeName = datatypeName ; this . datatypeParams = datatypeParams ; this . message = message ; this . except = null ; this . index = index == DatatypeException . UNKNOWN ? - 1 : index ; this . stringValue = null ; this . value = null ; } private DataDerivFailure ( Datatype datatype , Name datatypeName , List < String > datatypeParams , Pattern except ) { this . datatype = datatype ; this . datatypeName = datatypeName ; this . datatypeParams = datatypeParams ; this . message = null ; this . except = except ; this . index = - 1 ; this . stringValue = null ; this . value = null ; } private DataDerivFailure ( Datatype datatype , Name datatypeName , Object value , String stringValue ) { this . datatype = datatype ; this . datatypeName = datatypeName ; this . datatypeParams = null ; this . message = null ; this . except = null ; this . index = - 1 ; this . stringValue = stringValue ; this . value = value ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof DataDerivFailure ) ) return false ; DataDerivFailure other = ( DataDerivFailure ) obj ; return ( datatype == other . datatype && equal ( message , other . message ) && equal ( stringValue , other . stringValue ) && except == other . except && tokenIndex == other . tokenIndex && index == other . index ) ; } public int hashCode ( ) { int hc = datatype . hashCode ( ) ; if ( message != null ) hc ^= message . hashCode ( ) ; if ( stringValue != null ) hc ^= stringValue . hashCode ( ) ; if ( except != null ) hc ^= except . hashCode ( ) ; return hc ; } private static boolean equal ( Object o1 , Object o2 ) { if ( o1 == null ) return o2 == null ; return o1 . equals ( o2 ) ; } Datatype getDatatype ( ) { return datatype ; } Name getDatatypeName ( ) { return datatypeName ; } List < String > getDatatypeParams ( ) { return datatypeParams ; } String getMessage ( ) { return message ; } String getStringValue ( ) { return stringValue ; } Object getValue ( ) { return value ; } Pattern getExcept ( ) { return except ; } int getIndex ( ) { return index ; } int getTokenIndex ( ) { return tokenIndex ; } int getTokenStart ( ) { return tokenStart ; } int getTokenEnd ( ) { return tokenEnd ; } void setToken ( int tokenIndex , int tokenStart , int tokenEnd ) { this . tokenIndex = tokenIndex ; this . tokenStart = tokenStart ; this . tokenEnd = tokenEnd ; if ( index < 0 ) index += tokenStart ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
