<<<<<<< HEAD
public class X509Download extends HttpServlet { private static Logger LOG = Logger . getLogger ( X509Download . class ) ; public static String PARAMETER_USERNAME = "user" ; public static String PARAMETER_KEYNAME = "keyName" ; public static String PARAMETER_CODE = "code" ; public void doGet ( HttpServletRequest request , HttpServletResponse response ) { String code = request . getParameter ( PARAMETER_CODE ) ; String userName = request . getParameter ( PARAMETER_USERNAME ) ; String keyName = request . getParameter ( PARAMETER_KEYNAME ) ; String mimetype = "application/zip" ; Calendar now = Calendar . getInstance ( ) ; keyName = ( keyName == null || "" . equals ( keyName ) ) ? "default" : keyName ; keyName = userName + String . format ( "-%1$ty%1$tm%1$te%1$tk%1$tM%1$tS" , now ) ; if ( userName == null || "" . equals ( userName ) ) { hasError ( "No user name provided" , response ) ; return ; } if ( code == null || "" . equals ( code ) ) { hasError ( "Wrong confirmation code" , response ) ; return ; } UserInfoWeb user = null ; try { user = EucalyptusManagement . getWebUser ( userName ) ; String [ ] certs = EucalyptusManagement . getUserCertificateAliases ( userName ) ; for ( String s : certs ) if ( s . equals ( keyName ) ) { hasError ( "Certificate name already exists" , response ) ; return ; } } catch ( Exception e ) { hasError ( "User does not exist" , response ) ; return ; } if ( ! user . getCertificateCode ( ) . equals ( code ) ) { hasError ( "Confirmation code is invalid" , response ) ; return ; } response . setContentType ( mimetype ) ; response . setHeader ( "Content-Disposition" , "attachment; filename=\"" + EucalyptusProperties . NAME_SHORT + "-" + userName + "-x509.zip\"" ) ; LOG . info ( "pushing out the X509 certificate for user " + userName ) ; try { byte [ ] x509zip = getX509Zip ( userName , keyName ) ; ServletOutputStream op = response . getOutputStream ( ) ; response . setContentLength ( x509zip . length ) ; op . write ( x509zip ) ; op . flush ( ) ; } catch ( GeneralSecurityException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void hasError ( String message , HttpServletResponse response ) { try { response . getWriter ( ) . print ( EucalyptusManagement . getError ( message ) ) ; response . getWriter ( ) . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static byte [ ] getX509Zip ( String userName , String newKeyName ) throws GeneralSecurityException , IOException { KeyTool keyTool = new KeyTool ( ) ; KeyPair keyPair = keyTool . getKeyPair ( ) ; X509Certificate x509 = keyTool . getCertificate ( keyPair , EucalyptusProperties . getDName ( userName ) ) ; X509Certificate cloudCert = null ; try { x509 . checkValidity ( ) ; AbstractKeyStore ks = UserKeyStore . getInstance ( ) ; ks . addCertificate ( newKeyName , x509 ) ; cloudCert = ks . getCertificate ( EucalyptusProperties . NAME ) ; ks . store ( ) ; } catch ( IOException e ) { LOG . fatal ( e , e ) ; } catch ( GeneralSecurityException e ) { LOG . fatal ( e , e ) ; } String userSecretKey = null ; String userAccessKey = null ; UserInfo userSearch = new UserInfo ( userName ) ; EntityWrapper < UserInfo > db = new EntityWrapper < UserInfo > ( ) ; List < UserInfo > userSearchList = db . query ( userSearch ) ; if ( userSearchList . size ( ) > 0 && ! userSearchList . isEmpty ( ) ) { UserInfo first = userSearchList . get ( 0 ) ; CertificateInfo newCert = new CertificateInfo ( ) ; newCert . setCertAlias ( newKeyName ) ; newCert . setValue ( new String ( UrlBase64 . encode ( Hashes . getPemBytes ( x509 ) ) ) ) ; List < CertificateInfo > certInfoList = null ; if ( first . getCertificates ( ) != null ) certInfoList = first . getCertificates ( ) ; else certInfoList = new ArrayList < CertificateInfo > ( ) ; certInfoList . add ( newCert ) ; first . setCertificates ( certInfoList ) ; userSecretKey = first . getSecretKey ( ) ; userAccessKey = first . getQueryId ( ) ; db . commit ( ) ; } else { db . rollback ( ) ; throw new EucalyptusCloudException ( "User not found; username=" + userName ) ; } ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; ZipOutputStream zipOut = new ZipOutputStream ( byteOut ) ; String baseName = EucalyptusProperties . NAME_SHORT + "-" + userName + "-" + Hashes . getFingerPrint ( keyPair . getPublic ( ) ) . replaceAll ( ":" , "" ) . toLowerCase ( ) . substring ( 0 , 8 ) ; zipOut . setComment ( "To setup the environment run: source /path/to/eucarc" ) ; StringBuffer sb = new StringBuffer ( ) ; String userNumber = UserInfo . getUserNumber ( userName ) ; sb . append ( "EUCA_KEY_DIR=$(dirname $(readlink -f ${BASH_SOURCE}))" ) ; sb . append ( "\nexport S3_URL=" + EucalyptusProperties . getSystemConfiguration ( ) . getStorageUrl ( ) ) ; sb . append ( "\nexport EC2_URL=" + EucalyptusProperties . getSystemConfiguration ( ) . getStorageUrl ( ) . replaceAll ( "Walrus" , "Eucalyptus" ) ) ; sb . append ( "\nexport EC2_PRIVATE_KEY=${EUCA_KEY_DIR}/" + baseName + "-pk.pem" ) ; sb . append ( "\nexport EC2_CERT=${EUCA_KEY_DIR}/" + baseName + "-cert.pem" ) ; sb . append ( "\nexport EUCALYPTUS_CERT=${EUCA_KEY_DIR}/cloud-cert.pem" ) ; sb . append ( "\nexport EC2_ACCESS_KEY='" + userAccessKey + "'" ) ; sb . append ( "\nexport EC2_SECRET_KEY='" + userSecretKey + "'" ) ; sb . append ( "\nexport EC2_USER_ID='" + userNumber + "'" ) ; sb . append ( "\nalias ec2-bundle-image=\"ec2-bundle-image --cert ${EC2_CERT} --privatekey ${EC2_PRIVATE_KEY} --user " + userNumber + " --ec2cert ${EUCALYPTUS_CERT}\"" ) ; sb . append ( "\nalias ec2-upload-bundle=\"ec2-upload-bundle -a ${EC2_ACCESS_KEY} -s ${EC2_SECRET_KEY} --url ${S3_URL} --ec2cert ${EUCALYPTUS_CERT}\"" ) ; sb . append ( "\n" ) ; zipOut . putNextEntry ( new ZipEntry ( "eucarc" ) ) ; zipOut . write ( sb . toString ( ) . getBytes ( ) ) ; zipOut . closeEntry ( ) ; zipOut . putNextEntry ( new ZipEntry ( "cloud-cert.pem" ) ) ; zipOut . write ( Hashes . getPemBytes ( cloudCert ) ) ; zipOut . closeEntry ( ) ; zipOut . putNextEntry ( new ZipEntry ( baseName + "-pk.pem" ) ) ; zipOut . write ( Hashes . getPemBytes ( keyPair . getPrivate ( ) ) ) ; zipOut . closeEntry ( ) ; zipOut . putNextEntry ( new ZipEntry ( baseName + "-cert.pem" ) ) ; zipOut . write ( Hashes . getPemBytes ( x509 ) ) ; zipOut . closeEntry ( ) ; zipOut . close ( ) ; return byteOut . toByteArray ( ) ; } } 
=======
public class LanguageData { private static final Pattern HYPHEN = Pattern . compile ( "-" ) ; private static final String [ ] [ ] EMPTY_DOUBLE_STRING_ARRAY = { } ; private static final String [ ] EMPTY_STRING_ARRAY = { } ; private static final String PREFIX = "prefix: " ; private static final String SUPPRESS_SCRIPT = "suppress-script: " ; private static final String SUBTAG = "subtag: " ; private static final String TAG = "tag: " ; private static final String TYPE = "type: " ; private static final String DEPRECATED = "deprecated: " ; private static final String PREFERRED_VALUE = "preferred-value: " ; private BufferedReader in ; private SortedSet < String > languageSet = new TreeSet < String > ( ) ; private SortedSet < String > extlangSet = new TreeSet < String > ( ) ; private SortedSet < String > scriptSet = new TreeSet < String > ( ) ; private SortedSet < String > regionSet = new TreeSet < String > ( ) ; private SortedSet < String > variantSet = new TreeSet < String > ( ) ; private SortedSet < String > grandfatheredSet = new TreeSet < String > ( ) ; private SortedSet < String > redundantSet = new TreeSet < String > ( ) ; private SortedSet < String > deprecatedLangSet = new TreeSet < String > ( ) ; private SortedSet < String > deprecatedSet = new TreeSet < String > ( ) ; private Map < String , String > suppressedScriptByLanguageMap = new HashMap < String , String > ( ) ; private Map < String , String > prefixByExtlangMap = new HashMap < String , String > ( ) ; private Map < String , String > preferredValueByLanguageMap = new HashMap < String , String > ( ) ; private Map < String , Set < String [ ] > > prefixesByVariantMap = new HashMap < String , Set < String [ ] > > ( ) ; private String [ ] languages = null ; private String [ ] extlangs = null ; private String [ ] scripts = null ; private String [ ] regions = null ; private String [ ] variants = null ; private String [ ] grandfathered = null ; private String [ ] redundant = null ; private String [ ] deprecatedLang = null ; private String [ ] deprecated = null ; private int [ ] suppressedScriptByLanguage = null ; private int [ ] prefixByExtlang = null ; private String [ ] [ ] [ ] prefixesByVariant = null ; public LanguageData ( ) throws IOException { super ( ) ; in = new BufferedReader ( new InputStreamReader ( LanguageData . class . getClassLoader ( ) . getResourceAsStream ( "nu/validator/localentities/files/language-subtag-registry" ) , "UTF-8" ) ) ; consumeRegistry ( ) ; prepareArrays ( ) ; } private void consumeRegistry ( ) throws IOException { while ( consumeRecord ( ) ) { } in . close ( ) ; } private void prepareArrays ( ) throws IOException { scripts = scriptSet . toArray ( EMPTY_STRING_ARRAY ) ; regions = regionSet . toArray ( EMPTY_STRING_ARRAY ) ; grandfathered = grandfatheredSet . toArray ( EMPTY_STRING_ARRAY ) ; redundant = redundantSet . toArray ( EMPTY_STRING_ARRAY ) ; deprecated = deprecatedSet . toArray ( EMPTY_STRING_ARRAY ) ; deprecatedLang = deprecatedLangSet . toArray ( EMPTY_STRING_ARRAY ) ; int i = 0 ; languages = new String [ languageSet . size ( ) ] ; suppressedScriptByLanguage = new int [ languageSet . size ( ) ] ; for ( String language : languageSet ) { languages [ i ] = language ; String suppressed = suppressedScriptByLanguageMap . get ( language ) ; if ( suppressed == null ) { suppressedScriptByLanguage [ i ] = - 1 ; } else { int index = Arrays . binarySearch ( scripts , suppressed ) ; if ( index < 0 ) { throw new IOException ( "Malformed registry: reference to non-existent script." ) ; } suppressedScriptByLanguage [ i ] = index ; } i ++ ; } i = 0 ; extlangs = new String [ extlangSet . size ( ) ] ; prefixByExtlang = new int [ extlangSet . size ( ) ] ; for ( String extlang : extlangSet ) { extlangs [ i ] = extlang ; String prefix = prefixByExtlangMap . get ( extlang ) ; if ( prefix == null ) { prefixByExtlang [ i ] = - 1 ; } else { int index = Arrays . binarySearch ( languages , prefix ) ; if ( index < 0 ) { throw new IOException ( "Malformed registry: reference to non-existent prefix for extlang." ) ; } prefixByExtlang [ i ] = index ; } i ++ ; } i = 0 ; variants = new String [ variantSet . size ( ) ] ; prefixesByVariant = new String [ variantSet . size ( ) ] [ ] [ ] ; for ( String variant : variantSet ) { variants [ i ] = variant ; Set < String [ ] > prefixes = prefixesByVariantMap . get ( variant ) ; if ( prefixes != null ) { prefixesByVariant [ i ] = prefixes . toArray ( EMPTY_DOUBLE_STRING_ARRAY ) ; } else { prefixesByVariant [ i ] = EMPTY_DOUBLE_STRING_ARRAY ; } i ++ ; } } private boolean consumeRecord ( ) throws IOException { boolean hasMore = true ; String type = null ; String subtag = null ; String suppressScript = null ; String preferredValue = null ; Set < String [ ] > prefixes = new HashSet < String [ ] > ( ) ; String singlePrefix = null ; boolean depr = false ; String line = null ; for ( ; ; ) { line = in . readLine ( ) ; if ( line == null ) { hasMore = false ; break ; } line = line . toLowerCase ( ) ; if ( "%%" . equals ( line ) ) { break ; } else if ( line . startsWith ( TYPE ) ) { type = line . substring ( TYPE . length ( ) ) . trim ( ) . intern ( ) ; } else if ( line . startsWith ( SUBTAG ) ) { subtag = line . substring ( SUBTAG . length ( ) ) . trim ( ) . intern ( ) ; } else if ( line . startsWith ( TAG ) ) { subtag = line . substring ( TAG . length ( ) ) . trim ( ) . intern ( ) ; } else if ( line . startsWith ( SUPPRESS_SCRIPT ) ) { suppressScript = line . substring ( SUPPRESS_SCRIPT . length ( ) ) . trim ( ) . intern ( ) ; } else if ( line . startsWith ( PREFIX ) ) { String [ ] prefixSubtags = HYPHEN . split ( line . substring ( PREFIX . length ( ) ) . trim ( ) ) ; for ( int i = 0 ; i < prefixSubtags . length ; i ++ ) { prefixSubtags [ i ] = prefixSubtags [ i ] . intern ( ) ; } prefixes . add ( prefixSubtags ) ; singlePrefix = prefixSubtags [ 0 ] ; } else if ( line . startsWith ( DEPRECATED ) ) { depr = true ; } else if ( line . startsWith ( PREFERRED_VALUE ) ) { preferredValue = line . substring ( PREFERRED_VALUE . length ( ) ) . trim ( ) . intern ( ) ; preferredValueByLanguageMap . put ( subtag , preferredValue ) ; } } if ( subtag == null ) { return hasMore ; } if ( depr ) { if ( "language" == type ) { deprecatedLangSet . add ( subtag ) ; } else { deprecatedSet . add ( subtag ) ; } } if ( "language" == type ) { languageSet . add ( subtag ) ; suppressedScriptByLanguageMap . put ( subtag , suppressScript ) ; } if ( "extlang" == type ) { extlangSet . add ( subtag ) ; prefixByExtlangMap . put ( subtag , singlePrefix ) ; } else if ( "region" == type ) { regionSet . add ( subtag ) ; } else if ( "script" == type ) { scriptSet . add ( subtag ) ; } else if ( "variant" == type ) { variantSet . add ( subtag ) ; prefixesByVariantMap . put ( subtag , prefixes ) ; } else if ( "grandfathered" == type ) { grandfatheredSet . add ( subtag ) ; } else if ( "redundant" == type ) { redundantSet . add ( subtag ) ; } return hasMore ; } public String [ ] getLanguages ( ) { return languages ; } public String [ ] getExtlangs ( ) { return extlangs ; } public String [ ] [ ] [ ] getPrefixesByVariant ( ) { return prefixesByVariant ; } public int [ ] getPrefixByExtlang ( ) { return prefixByExtlang ; } public String [ ] getRegions ( ) { return regions ; } public String [ ] getScripts ( ) { return scripts ; } public int [ ] getSuppressedScriptByLanguage ( ) { return suppressedScriptByLanguage ; } public String [ ] getVariants ( ) { return variants ; } public String [ ] getDeprecated ( ) { return deprecated ; } public Map < String , String > getPreferredValueByLanguageMap ( ) { return preferredValueByLanguageMap ; } public String [ ] getGrandfathered ( ) { return grandfathered ; } public String [ ] getRedundant ( ) { return redundant ; } public String [ ] getDeprecatedLang ( ) { return deprecatedLang ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
