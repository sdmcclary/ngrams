public class AptanaAuthenticator extends UpdateManagerAuthenticator { private static final int THREE_SECONDS = 3 * 1000 ; private static final String HOST_DELIMETER = "," ; private static final String ALGORITHM = "AES/ECB/PKCS5Padding" ; private static final String DEBUG_HOST_VALUE = RESTServiceProvider . DEBUG_HOST ; private static final AptanaAuthenticator authenticator = new AptanaAuthenticator ( ) ; private static Map < String , Long > requestMap = new HashMap < String , Long > ( ) ; private static Map < String , PasswordAuthentication > table = new Hashtable < String , PasswordAuthentication > ( ) ; private final IAuthentificationULRFilter filter ; public static void correctAuthenticator ( ) { Authenticator . setDefault ( authenticator ) ; } public AptanaAuthenticator ( ) { this ( new MultipleAuthenticationFilter ( new IAuthentificationULRFilter [ ] { new SkipPathAuthentificationFilter ( new String [ ] { "/update/xul/3.2/messages.xml" } ) , new SkipSitemanagerAuthFilter ( ) , new SkipCloudFilter ( ) } ) ) ; } public AptanaAuthenticator ( IAuthentificationULRFilter filter ) { this . filter = filter ; } protected PasswordAuthentication getPasswordAuthentication ( ) { InetAddress address = getRequestingSite ( ) ; String hostString = null ; if ( address != null ) { hostString = address . getHostName ( ) ; } if ( hostString == null ) { hostString = "" ; } if ( hostString . indexOf ( "aptanacloud.com" ) != - 1 && AptanaUser . getSignedInUser ( ) != null && AptanaUser . getSignedInUser ( ) . hasCredentials ( ) ) { return new PasswordAuthentication ( AptanaUser . getSignedInUser ( ) . getUsername ( ) , AptanaUser . getSignedInUser ( ) . getPassword ( ) . toCharArray ( ) ) ; } if ( hostString . indexOf ( "sitemanager.aptana.com" ) != - 1 && AptanaUser . getSignedInUser ( ) != null && AptanaUser . getSignedInUser ( ) . hasCredentials ( ) ) { return new PasswordAuthentication ( AptanaUser . getSignedInUser ( ) . getUsername ( ) , AptanaUser . getSignedInUser ( ) . getPassword ( ) . toCharArray ( ) ) ; } if ( DEBUG_HOST_VALUE != null && hostString . indexOf ( DEBUG_HOST_VALUE ) != - 1 && AptanaUser . getSignedInUser ( ) != null && AptanaUser . getSignedInUser ( ) . hasCredentials ( ) ) { return new PasswordAuthentication ( AptanaUser . getSignedInUser ( ) . getUsername ( ) , AptanaUser . getSignedInUser ( ) . getPassword ( ) . toCharArray ( ) ) ; } if ( filter != null && ! filter . requiresCheck ( getRequestingURL ( ) ) ) { return null ; } if ( hostString . indexOf ( "aptana" ) == - 1 ) { return doGetPasswordAuthentication ( ) ; } if ( cachingEnabled ( ) && ! looksLikeCachedAreBad ( hostString ) ) { PasswordAuthentication cached = getCachedAuthentication ( hostString ) ; if ( cached != null ) { return cached ; } } PasswordAuthentication auth = super . getPasswordAuthentication ( ) ; if ( auth != null && cachingEnabled ( ) ) { IdeLog . logInfo ( AptanaCorePlugin . getDefault ( ) , StringUtils . format ( Messages . AptanaAuthenticator_INF_LoggingPasswordForHost , hostString ) ) ; cacheAuthentication ( hostString , auth ) ; } return auth ; } private PasswordAuthentication doGetPasswordAuthentication ( ) { String address = null ; PasswordAuthentication auth = null ; try { address = InetAddress . getByName ( getRequestingHost ( ) ) . getHostAddress ( ) ; auth = ( PasswordAuthentication ) table . get ( address ) ; } catch ( Exception exc ) { } if ( auth == null ) { auth = super . getPasswordAuthentication ( ) ; if ( address != null && auth != null ) { table . put ( address , auth ) ; } } return auth ; } private static SecretKeySpec getKeySpec ( ) { String ksPref = Platform . getPreferencesService ( ) . getString ( AptanaCorePlugin . ID , IPreferenceConstants . CACHED_KEY , "" , null ) ; byte [ ] key = null ; if ( ! "" . equals ( ksPref ) ) { try { byte [ ] bytes = Base64 . decode ( ksPref ) ; if ( bytes != null ) { key = bytes ; } } catch ( Exception e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_UnableToDecodeExistingKey , e ) ; } } KeyGenerator kgen ; if ( key == null || key . length == 0 ) { try { kgen = KeyGenerator . getInstance ( "AES" ) ; kgen . init ( 128 ) ; SecretKey skey = kgen . generateKey ( ) ; key = skey . getEncoded ( ) ; String b64 = Base64 . encodeBytes ( skey . getEncoded ( ) ) ; IEclipsePreferences prefs = getPreferences ( ) ; prefs . put ( IPreferenceConstants . CACHED_KEY , b64 ) ; try { prefs . flush ( ) ; } catch ( BackingStoreException e ) { } } catch ( NoSuchAlgorithmException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchAlgorithm , e ) ; return null ; } } SecretKeySpec skeySpec ; skeySpec = new SecretKeySpec ( key , "AES" ) ; return skeySpec ; } private static byte [ ] encrypt ( SecretKeySpec skeySpec , String password ) { Cipher cipher ; try { cipher = Cipher . getInstance ( ALGORITHM ) ; cipher . init ( Cipher . ENCRYPT_MODE , skeySpec ) ; return cipher . doFinal ( password . getBytes ( ) ) ; } catch ( NoSuchAlgorithmException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchAlgorithm , e ) ; } catch ( NoSuchPaddingException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchPadding , e ) ; } catch ( InvalidKeyException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_InvalidKey , e ) ; } catch ( IllegalBlockSizeException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_IllegalBlockSize , e ) ; } catch ( BadPaddingException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_BadPadding , e ) ; } return null ; } private static byte [ ] decrypt ( SecretKeySpec skeySpec , byte [ ] encryptedPassword ) { Cipher cipher ; try { cipher = Cipher . getInstance ( ALGORITHM ) ; cipher . init ( Cipher . DECRYPT_MODE , skeySpec ) ; return cipher . doFinal ( encryptedPassword ) ; } catch ( NoSuchAlgorithmException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchAlgorithm , e ) ; } catch ( NoSuchPaddingException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_NoSuchPadding , e ) ; } catch ( InvalidKeyException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_InvalidKey , e ) ; } catch ( IllegalBlockSizeException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_IllegalBlockSize , e ) ; } catch ( BadPaddingException e ) { IdeLog . logError ( CoreUIPlugin . getDefault ( ) , Messages . AptanaAuthenticator_ERR_BadPadding , e ) ; } return null ; } public PasswordAuthentication encrypt ( PasswordAuthentication auth ) { if ( auth == null ) { return null ; } char [ ] password = auth . getPassword ( ) ; String username = auth . getUserName ( ) ; return new PasswordAuthentication ( username , password ) ; } private boolean looksLikeCachedAreBad ( String hostString ) { String serialized = getSerializedRequest ( hostString ) ; return looksLikeCachedAreBad ( hostString , serialized ) ; } public static boolean looksLikeCachedAreBad ( String hostString , String serializedRequest ) { try { if ( ! requestMap . containsKey ( serializedRequest ) ) { return false ; } Long lastRequestTimestamp = requestMap . get ( serializedRequest ) ; if ( lastRequestTimestamp . longValue ( ) > ( System . currentTimeMillis ( ) - THREE_SECONDS ) ) { return true ; } return false ; } finally { requestMap . put ( serializedRequest , new Long ( System . currentTimeMillis ( ) ) ) ; } } private String getSerializedRequest ( String hostString ) { return serializeRequest ( hostString , getRequestingPrompt ( ) , getRequestingProtocol ( ) , getRequestingScheme ( ) , getRequestingPort ( ) , getRequestingURL ( ) ) ; } public static String serializeRequest ( String hostString , String prompt , String protocol , String scheme , int port , URL url ) { StringBuffer request = new StringBuffer ( ) ; request . append ( hostString ) ; request . append ( ";" ) ; request . append ( prompt ) ; request . append ( ";" ) ; request . append ( protocol ) ; request . append ( ";" ) ; request . append ( scheme ) ; request . append ( ";" ) ; request . append ( port ) ; request . append ( ";" ) ; request . append ( url . toString ( ) ) ; return request . toString ( ) ; } public static boolean cachingEnabled ( ) { return Platform . getPreferencesService ( ) . getBoolean ( AptanaCorePlugin . ID , IPreferenceConstants . PREF_ENABLE_PASSWORD_CACHING , true , null ) ; } public void cacheAuthentication ( String hostString , PasswordAuthentication auth ) { if ( auth == null ) { return ; } char [ ] password = auth . getPassword ( ) ; String username = auth . getUserName ( ) ; IEclipsePreferences prefs = getPreferences ( ) ; String hostsString = Platform . getPreferencesService ( ) . getString ( AptanaCorePlugin . ID , IPreferenceConstants . SAVED_PASSWORD_HOSTS , "" , null ) ; int index = hostsString . indexOf ( hostString ) ; if ( index == - 1 ) { hostsString += HOST_DELIMETER + hostString ; prefs . put ( IPreferenceConstants . SAVED_PASSWORD_HOSTS , hostsString ) ; } SecretKeySpec key = getKeySpec ( ) ; byte [ ] encrypted = encrypt ( key , new String ( password ) ) ; if ( encrypted != null && encrypted . length > 0 ) { String b64 = Base64 . encodeBytes ( encrypted ) ; prefs . put ( generatePrefKey ( IPreferenceConstants . USERNAME , hostString ) , username ) ; prefs . put ( generatePrefKey ( IPreferenceConstants . PASSWORD , hostString ) , b64 ) ; } try { prefs . flush ( ) ; } catch ( BackingStoreException e ) { } } public static PasswordAuthentication getCachedAuthentication ( String hostString ) { char [ ] password = getPassword ( hostString ) ; if ( password . length == 0 ) { return null ; } String username = getUserName ( hostString ) ; if ( "" . equals ( username ) ) { return null ; } return new PasswordAuthentication ( username , password ) ; } private static IEclipsePreferences getPreferences ( ) { return ( new InstanceScope ( ) ) . getNode ( AptanaCorePlugin . ID ) ; } public static String getUserName ( String hostString ) { String username = Platform . getPreferencesService ( ) . getString ( AptanaCorePlugin . ID , generatePrefKey ( IPreferenceConstants . USERNAME , hostString ) , "" , null ) ; if ( username . length ( ) > 30 ) { username = username . substring ( 0 , 30 ) ; } return username ; } private static String generatePrefKey ( String prefix , String hostString ) { return prefix + "." + hostString ; } private static char [ ] getPassword ( String hostString ) { String encrypted = Platform . getPreferencesService ( ) . getString ( AptanaCorePlugin . ID , generatePrefKey ( IPreferenceConstants . PASSWORD , hostString ) , "" , null ) ; byte [ ] bytes = Base64 . decode ( encrypted ) ; if ( bytes != null && bytes . length > 0 ) { SecretKeySpec key = getKeySpec ( ) ; byte [ ] decrypted = decrypt ( key , bytes ) ; return new String ( decrypted ) . toCharArray ( ) ; } else { return new char [ 0 ] ; } } public static final Set < String > getSavedHosts ( ) { String [ ] hosts = Platform . getPreferencesService ( ) . getString ( AptanaCorePlugin . ID , IPreferenceConstants . SAVED_PASSWORD_HOSTS , "" , null ) . split ( AptanaAuthenticator . HOST_DELIMETER ) ; Set < String > hostSet = new HashSet < String > ( ) ; for ( int i = 0 ; i < hosts . length ; i ++ ) { hostSet . add ( hosts [ i ] ) ; } return hostSet ; } public static void removeCachedAuthentication ( String hostname ) { StringBuffer buffer = new StringBuffer ( ) ; Set < String > hosts = getSavedHosts ( ) ; for ( Iterator < String > iter = hosts . iterator ( ) ; iter . hasNext ( ) ; ) { String host = iter . next ( ) ; if ( host . equals ( hostname ) ) { continue ; } buffer . append ( host ) ; buffer . append ( HOST_DELIMETER ) ; } if ( buffer . length ( ) > 0 ) { buffer . deleteCharAt ( buffer . length ( ) - 1 ) ; } IEclipsePreferences prefs = getPreferences ( ) ; prefs . put ( IPreferenceConstants . SAVED_PASSWORD_HOSTS , buffer . toString ( ) ) ; prefs . put ( generatePrefKey ( IPreferenceConstants . USERNAME , hostname ) , "" ) ; prefs . put ( generatePrefKey ( IPreferenceConstants . PASSWORD , hostname ) , "" ) ; try { prefs . flush ( ) ; } catch ( BackingStoreException e ) { } } public static void addProxyEntry ( String hostname , String userid , String password ) { try { String address = InetAddress . getByName ( hostname ) . getHostAddress ( ) ; PasswordAuthentication auth = new PasswordAuthentication ( userid , password . toCharArray ( ) ) ; if ( address != null && auth != null ) { table . put ( address , auth ) ; } } catch ( Exception exc ) { } } } 