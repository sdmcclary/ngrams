<<<<<<< HEAD
public final class JSValidationUtils { private static final String JS_VALIDATE_COMMENT = "validate" ; private static final String JS_NOVALIDATE_COMMENT = "novalidate" ; private static JSParser parser ; private static IParseState parseState ; public static IFileError [ ] filterErrorsByNovalidate ( IFileError [ ] errors , String source ) throws ParserInitializationException , LexerException { if ( parser == null ) { parser = new JSParser ( ) ; } if ( parseState == null ) { parseState = parser . createParseState ( null ) ; } parseState . setEditState ( source , source , 0 , 0 ) ; parser . parse ( parseState ) ; LexemeList lexemes = parseState . getLexemeList ( ) ; return filterErrorsByNovalidate ( errors , lexemes , source ) ; } static ArrayList < ICleanup > cleanup = new ArrayList < ICleanup > ( ) ; static { IConfigurationElement [ ] configurationElementsFor = Platform . getExtensionRegistry ( ) . getConfigurationElementsFor ( "com.aptana.ide.editor.js.languageCleanup" ) ; for ( IConfigurationElement e : configurationElementsFor ) { try { ICleanup createExecutableExtension = ( ICleanup ) e . createExecutableExtension ( "class" ) ; cleanup . add ( createExecutableExtension ) ; } catch ( CoreException e1 ) { IdeLog . log ( JSPlugin . getDefault ( ) , IStatus . ERROR , "unable to instantiate cleanup object" , e1 ) ; } } } protected static IFileError [ ] filterErrors ( String source , UnifiedErrorReporter reporter , ArrayList < Range > ranges ) { IFileError [ ] errors = reporter . getErrors ( ) ; if ( JSPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . ENABLE_NO_VALIDATE_COMMENT ) ) { IParser ps = LanguageRegistry . getParser ( JSMimeType . MimeType ) ; IParseState createParseState = ps . createParseState ( null ) ; createParseState . setEditState ( source , source , 0 , 0 ) ; ArrayList < IFileError > ls = new ArrayList < IFileError > ( ) ; try { ps . parse ( createParseState ) ; } catch ( RuntimeException e1 ) { IdeLog . logError ( JSPlugin . getDefault ( ) , "parse exception while lexing cleared JS source" , e1 ) ; } catch ( LexerException e1 ) { IdeLog . logError ( JSPlugin . getDefault ( ) , "lexing exception while lexing cleared JS source" , e1 ) ; } catch ( java . text . ParseException e ) { IdeLog . logError ( JSPlugin . getDefault ( ) , "parse exception while lexing cleared JS source" , e ) ; } LexemeList lexemeList = createParseState . getLexemeList ( ) ; l2 : for ( IFileError e : errors ) { for ( Range r : ranges ) { Lexeme ceilingLexeme = lexemeList . getCeilingLexeme ( r . getEndingOffset ( ) ) ; int le = ceilingLexeme . getEndingOffset ( ) + 1 ; if ( e . getOffset ( ) < le + 1 && e . getOffset ( ) > r . getStartingOffset ( ) ) { continue l2 ; } } ls . add ( e ) ; } errors = new IFileError [ ls . size ( ) ] ; ls . toArray ( errors ) ; } return errors ; } public static String filterPIInstructions ( String source , ArrayList < Range > toFill ) throws LexerException , ParserInitializationException { StringBuilder bld = new StringBuilder ( source ) ; for ( ICleanup c : cleanup ) { List < Range > notJsCode = c . getNotJsCode ( source ) ; for ( Range r : notJsCode ) { toFill . add ( r ) ; StringBuilder spaces = new StringBuilder ( ) ; int startingOffset = r . getStartingOffset ( ) ; int endingOffset = r . getEndingOffset ( ) ; boolean found = false ; for ( int a = startingOffset ; a >= 0 ; a -- ) { char ch = source . charAt ( a ) ; if ( ch == '\r' || ch == '\n' ) { startingOffset = a ; found = true ; break ; } } if ( ! found ) { startingOffset = 0 ; } found = false ; for ( int a = endingOffset ; a < source . length ( ) ; a ++ ) { char ch = source . charAt ( a ) ; if ( ch == '\r' || ch == '\n' ) { endingOffset = a ; found = true ; break ; } } if ( ! found ) { endingOffset = source . length ( ) - 1 ; } for ( int a = startingOffset ; a < endingOffset ; a ++ ) { spaces . append ( ' ' ) ; } bld . replace ( startingOffset , endingOffset , spaces . toString ( ) ) ; } } return bld . toString ( ) ; } public static IFileError [ ] filterErrorsByNovalidate ( IFileError [ ] errors , LexemeList lexemes , String source ) { if ( lexemes . size ( ) < 2 ) { return errors ; } List < IFileError > filteredErrors = new LinkedList < IFileError > ( ) ; int currentErrorIndex = 0 ; boolean validating = true ; int validateStartIndex = 0 ; for ( int i = 0 ; i < lexemes . size ( ) - 1 ; i ++ ) { Lexeme currentLexeme = lexemes . get ( i ) ; Lexeme nextLexeme = lexemes . get ( i + 1 ) ; if ( currentLexeme . typeIndex == JSTokenTypes . COMMENT && nextLexeme . typeIndex == JSTokenTypes . CDO && nextLexeme . getText ( ) != null ) { if ( nextLexeme . getText ( ) . startsWith ( JS_NOVALIDATE_COMMENT ) && validating ) { validating = false ; currentErrorIndex = copyErrorsFromArea ( errors , filteredErrors , currentErrorIndex , validateStartIndex , currentLexeme . getStartingOffset ( ) ) ; } else if ( nextLexeme . getText ( ) . startsWith ( JS_VALIDATE_COMMENT ) && ! validating ) { validating = true ; validateStartIndex = currentLexeme . getEndingOffset ( ) ; currentErrorIndex = skipEmptyLineErrors ( currentErrorIndex , errors , nextLexeme , source ) ; } } } if ( validating ) { copyErrorsFromArea ( errors , filteredErrors , currentErrorIndex , validateStartIndex , lexemes . getAffectedRegion ( ) . getEndingOffset ( ) ) ; } IFileError [ ] toReturn = new IFileError [ filteredErrors . size ( ) ] ; filteredErrors . toArray ( toReturn ) ; return toReturn ; } private static int skipEmptyLineErrors ( int errorIndex , IFileError [ ] errors , Lexeme lexeme , String source ) { int endLineOffset = getEndLineIndex ( lexeme . getEndingOffset ( ) , source ) ; for ( int i = lexeme . getEndingOffset ( ) ; i < endLineOffset ; i ++ ) { char ch = source . charAt ( i ) ; if ( ! Character . isWhitespace ( ch ) ) { return errorIndex ; } } for ( int i = errorIndex ; i < errors . length ; i ++ ) { IFileError currentError = errors [ i ] ; if ( currentError . getOffset ( ) >= endLineOffset ) { return i ; } } return errors . length ; } private static int getEndLineIndex ( int startOffset , String source ) { StringReader reader = new StringReader ( source ) ; try { reader . skip ( startOffset ) ; int currentChar ; int currentOffset = 0 ; int lineNumber = 1 ; while ( ( currentChar = reader . read ( ) ) != - 1 ) { switch ( currentChar ) { case '\r' : reader . mark ( 1 ) ; int nextChar = reader . read ( ) ; currentOffset ++ ; if ( nextChar != '\n' ) { reader . reset ( ) ; currentOffset -- ; } case '\n' : if ( currentOffset + 1 < source . length ( ) ) { return currentOffset + startOffset + 1 ; } lineNumber ++ ; break ; default : break ; } currentOffset ++ ; } } catch ( IOException ex ) { IdeLog . logError ( JSPlugin . getDefault ( ) , "Exception searching for the line end" , ex ) ; } return source . length ( ) ; } private static int copyErrorsFromArea ( IFileError [ ] from , List < IFileError > to , int errorsStartIndex , int areaStartIndex , int areaEndIndex ) { if ( errorsStartIndex < from . length ) { int errorIndex = errorsStartIndex ; for ( ; errorIndex < from . length ; errorIndex ++ ) { IFileError currentError = from [ errorIndex ] ; if ( currentError . getOffset ( ) >= areaStartIndex ) { if ( currentError . getOffset ( ) <= areaEndIndex ) { to . add ( currentError ) ; } else { break ; } } } errorsStartIndex = errorIndex ; } return errorsStartIndex ; } private JSValidationUtils ( ) { } } 
=======
public class Id extends AbstractDatatype { public static final Id THE_INSTANCE = new Id ( ) ; protected Id ( ) { super ( ) ; } public void checkValid ( CharSequence literal ) throws DatatypeException { int len = literal . length ( ) ; if ( len == 0 ) { throw newDatatypeException ( "An ID must not be the empty string." ) ; } for ( int i = 0 ; i < len ; i ++ ) { char c = literal . charAt ( i ) ; if ( isWhitespace ( c ) ) { throw newDatatypeException ( i , "An ID must not contain whitespace." ) ; } } } @ Override public String getName ( ) { return "id" ; } } 
>>>>>>> ab1fba6c6e93a4331abe98d3c4c0cdc860e899a6
