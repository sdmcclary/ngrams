public class UpdatePanel extends javax . swing . JPanel { private File repository ; private List < String [ ] > revisionMap ; private RequestProcessor . Task refreshViewTask ; private static final RequestProcessor rp = new RequestProcessor ( "GitUpdate" , 1 ) ; private Thread refreshViewThread ; private static final int GIT_REVERT_TARGET_LIMIT = 100 ; public UpdatePanel ( File repo ) { repository = repo ; refreshViewTask = rp . create ( new RefreshViewTask ( ) ) ; initComponents ( ) ; refreshViewTask . schedule ( 0 ) ; } public String getSelectedRevision ( ) { String revStr = ( String ) revisionsComboBox . getSelectedItem ( ) ; if ( revStr != null ) { if ( revStr . equals ( NbBundle . getMessage ( RevertModificationsPanel . class , "MSG_Revision_Default" ) ) || revStr . equals ( NbBundle . getMessage ( RevertModificationsPanel . class , "MSG_Fetching_Revisions" ) ) ) { revStr = null ; } else if ( revisionMap != null ) { for ( String [ ] entry : revisionMap ) { if ( entry [ 0 ] . equals ( revStr ) ) { revStr = entry [ 1 ] ; break ; } } } } return revStr ; } public boolean isForcedUpdateRequested ( ) { return forcedUpdateChxBox . isSelected ( ) ; } private void initComponents ( ) { revisionsLabel = new javax . swing . JLabel ( ) ; revisionsComboBox = new javax . swing . JComboBox ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; jLabel2 = new javax . swing . JLabel ( ) ; jPanel1 = new javax . swing . JPanel ( ) ; forcedUpdateChxBox = new javax . swing . JCheckBox ( ) ; revisionsLabel . setLabelFor ( revisionsComboBox ) ; org . openide . awt . Mnemonics . setLocalizedText ( revisionsLabel , org . openide . util . NbBundle . getMessage ( UpdatePanel . class , "UpdatePanel.revisionsLabel.text" ) ) ; jLabel1 . setFont ( new java . awt . Font ( "Dialog" , 1 , 11 ) ) ; org . openide . awt . Mnemonics . setLocalizedText ( jLabel1 , org . openide . util . NbBundle . getMessage ( UpdatePanel . class , "UpdatePanel.infoLabel.text" ) ) ; jLabel2 . setForeground ( new java . awt . Color ( 153 , 153 , 153 ) ) ; org . openide . awt . Mnemonics . setLocalizedText ( jLabel2 , org . openide . util . NbBundle . getMessage ( UpdatePanel . class , "UpdatePanel.infoLabel2.text" ) ) ; jPanel1 . setBorder ( javax . swing . BorderFactory . createTitledBorder ( org . openide . util . NbBundle . getMessage ( UpdatePanel . class , "UpdatePanel.jPanel1.border.title" ) ) ) ; org . openide . awt . Mnemonics . setLocalizedText ( forcedUpdateChxBox , org . openide . util . NbBundle . getMessage ( UpdatePanel . class , "UpdatePanel.forcedUpdateChxBox.text" ) ) ; org . jdesktop . layout . GroupLayout jPanel1Layout = new org . jdesktop . layout . GroupLayout ( jPanel1 ) ; jPanel1 . setLayout ( jPanel1Layout ) ; jPanel1Layout . setHorizontalGroup ( jPanel1Layout . createParallelGroup ( org . jdesktop . layout . GroupLayout . LEADING ) . add ( jPanel1Layout . createSequentialGroup ( ) . addContainerGap ( ) . add ( forcedUpdateChxBox ) . addContainerGap ( 120 , Short . MAX_VALUE ) ) ) ; jPanel1Layout . setVerticalGroup ( jPanel1Layout . createParallelGroup ( org . jdesktop . layout . GroupLayout . LEADING ) . add ( jPanel1Layout . createSequentialGroup ( ) . add ( forcedUpdateChxBox ) . addContainerGap ( org . jdesktop . layout . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ) ; org . jdesktop . layout . GroupLayout layout = new org . jdesktop . layout . GroupLayout ( this ) ; this . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( org . jdesktop . layout . GroupLayout . LEADING ) . add ( layout . createSequentialGroup ( ) . addContainerGap ( ) . add ( layout . createParallelGroup ( org . jdesktop . layout . GroupLayout . LEADING ) . add ( jPanel1 , org . jdesktop . layout . GroupLayout . DEFAULT_SIZE , org . jdesktop . layout . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . add ( jLabel2 ) . add ( jLabel1 , org . jdesktop . layout . GroupLayout . DEFAULT_SIZE , 501 , Short . MAX_VALUE ) . add ( layout . createSequentialGroup ( ) . add ( 36 , 36 , 36 ) . add ( revisionsLabel ) . addPreferredGap ( org . jdesktop . layout . LayoutStyle . RELATED ) . add ( revisionsComboBox , 0 , 311 , Short . MAX_VALUE ) ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( org . jdesktop . layout . GroupLayout . LEADING ) . add ( layout . createSequentialGroup ( ) . add ( jLabel1 , org . jdesktop . layout . GroupLayout . PREFERRED_SIZE , 25 , org . jdesktop . layout . GroupLayout . PREFERRED_SIZE ) . add ( 4 , 4 , 4 ) . add ( jLabel2 ) . add ( 29 , 29 , 29 ) . add ( layout . createParallelGroup ( org . jdesktop . layout . GroupLayout . BASELINE ) . add ( revisionsLabel ) . add ( revisionsComboBox , org . jdesktop . layout . GroupLayout . PREFERRED_SIZE , 16 , org . jdesktop . layout . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( org . jdesktop . layout . LayoutStyle . UNRELATED ) . add ( jPanel1 , org . jdesktop . layout . GroupLayout . PREFERRED_SIZE , org . jdesktop . layout . GroupLayout . DEFAULT_SIZE , org . jdesktop . layout . GroupLayout . PREFERRED_SIZE ) . addContainerGap ( org . jdesktop . layout . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ) ; } private void setupModels ( ) { final ProgressHandle ph = ProgressHandleFactory . createHandle ( NbBundle . getMessage ( RevertModificationsPanel . class , "MSG_Refreshing_Update_Versions" ) ) ; try { Set < String > initialRevsSet = new LinkedHashSet < String > ( ) ; initialRevsSet . add ( NbBundle . getMessage ( RevertModificationsPanel . class , "MSG_Fetching_Revisions" ) ) ; ComboBoxModel targetsModel = new DefaultComboBoxModel ( new Vector < String > ( initialRevsSet ) ) ; revisionsComboBox . setModel ( targetsModel ) ; refreshViewThread = Thread . currentThread ( ) ; Thread . interrupted ( ) ; ph . start ( ) ; refreshRevisions ( ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { ph . finish ( ) ; refreshViewThread = null ; } } ) ; } } private void refreshRevisions ( ) { revisionMap = GitCommand . getRevisions ( repository , GIT_REVERT_TARGET_LIMIT ) ; Set < String > targetRevsSet = new LinkedHashSet < String > ( ) ; if ( revisionMap == null ) targetRevsSet . add ( NbBundle . getMessage ( RevertModificationsPanel . class , "MSG_Revision_Default" ) ) ; else for ( String [ ] entry : revisionMap ) { targetRevsSet . add ( entry [ 0 ] ) ; } ComboBoxModel targetsModel = new DefaultComboBoxModel ( new Vector < String > ( targetRevsSet ) ) ; revisionsComboBox . setModel ( targetsModel ) ; if ( targetRevsSet . size ( ) > 0 ) revisionsComboBox . setSelectedIndex ( 0 ) ; } private class RefreshViewTask implements Runnable { public void run ( ) { setupModels ( ) ; } } private javax . swing . JCheckBox forcedUpdateChxBox ; private javax . swing . JLabel jLabel1 ; private javax . swing . JLabel jLabel2 ; private javax . swing . JPanel jPanel1 ; private javax . swing . JComboBox revisionsComboBox ; private javax . swing . JLabel revisionsLabel ; } 